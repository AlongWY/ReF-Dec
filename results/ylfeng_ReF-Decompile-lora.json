[
    {
      "task_id": 2,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float x) {\n  int i = x;\n  x = x - i;\n  return x;\n}"
    },
    {
      "task_id": 2,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float x) {\n  int i = x;\n  x = x - i;\n  return x;\n}"
    },
    {
      "task_id": 2,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  movss  -0x4(%rbp),%xmm0\n  subss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  movss  -0x4(%rbp),%xmm0\n  subss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float x) {\n  float y;\n  y = x - (int)x;\n  return y;\n}"
    },
    {
      "task_id": 2,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float x) {\n  int i = x;\n  x = x - i;\n  return x;\n}"
    },
    {
      "task_id": 3,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1142 <func0+0x49>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jns    113e <func0+0x45>\n  mov    $0x1,%eax\n  jmp    114f <func0+0x56>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1118 <func0+0x1f>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jns    L1\n  mov    $0x1,%eax\n  jmp    L2\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  mov    $0x0,%eax\nL2:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4418
        },
        "L1": {
          "label": "L1",
          "addr": 4414
        },
        "L2": {
          "label": "L2",
          "addr": 4431
        },
        "L3": {
          "label": "L3",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int sum = 0;\n  for (int i = 0; i < len; i++) {\n    sum += arr[i];\n    if (sum < 0)\n      return 1;\n  }\n  return 0;\n}"
    },
    {
      "task_id": 3,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1131 <func0+0x38>\n  mov    (%rdi),%edx\n  test   %edx,%edx\n  js     1137 <func0+0x3e>\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%eax\n  lea    (%rdi,%rax,4),%rcx\n  cmp    %rcx,%rdi\n  je     112b <func0+0x32>\n  mov    %edx,%eax\n  add    (%rdi),%eax\n  mov    %eax,%edx\n  add    $0x4,%rdi\n  test   %eax,%eax\n  jns    1112 <func0+0x19>\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    (%rdi),%edx\n  test   %edx,%edx\n  js     L1\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%eax\n  lea    (%rdi,%rax,4),%rcx\nL3:\n  cmp    %rcx,%rdi\n  je     L2\n  mov    %edx,%eax\n  add    (%rdi),%eax\n  mov    %eax,%edx\n  add    $0x4,%rdi\n  test   %eax,%eax\n  jns    L3\n  mov    $0x1,%eax\n  ret\nL2:\n  mov    $0x0,%eax\n  ret\nL0:\n  mov    $0x0,%eax\n  ret\nL1:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4401
        },
        "L1": {
          "label": "L1",
          "addr": 4407
        },
        "L2": {
          "label": "L2",
          "addr": 4395
        },
        "L3": {
          "label": "L3",
          "addr": 4370
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int sum = 0;\n  for (int i = 0; i < len; ++i) {\n    sum += arr[i];\n    if (sum < 0)\n      return 1;\n  }\n  return 0;\n}"
    },
    {
      "task_id": 3,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    112f <func0+0x2f>\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     1138 <func0+0x38>\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%edx\n  lea    (%rdi,%rdx,4),%rdx\n  jmp    112a <func0+0x2a>\n  nopl   0x0(%rax,%rax,1)\n  add    (%rdi),%eax\n  add    $0x4,%rdi\n  test   %eax,%eax\n  js     1138 <func0+0x38>\n  cmp    %rdx,%rdi\n  jne    1120 <func0+0x20>\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     L1\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%edx\n  lea    (%rdi,%rdx,4),%rdx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    (%rdi),%eax\n  add    $0x4,%rdi\n  test   %eax,%eax\n  js     L1\nL2:\n  cmp    %rdx,%rdi\n  jne    L3\nL0:\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4399
        },
        "L1": {
          "label": "L1",
          "addr": 4408
        },
        "L2": {
          "label": "L2",
          "addr": 4394
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, sum;\n  sum = 0;\n  for (i = 0; i < len; i++) {\n    sum += arr[i];\n    if (sum < 0)\n      return 1;\n  }\n  return 0;\n}"
    },
    {
      "task_id": 3,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    112f <func0+0x2f>\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     1138 <func0+0x38>\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%edx\n  lea    (%rdi,%rdx,4),%rdx\n  jmp    112a <func0+0x2a>\n  nopl   0x0(%rax,%rax,1)\n  add    (%rdi),%eax\n  add    $0x4,%rdi\n  test   %eax,%eax\n  js     1138 <func0+0x38>\n  cmp    %rdx,%rdi\n  jne    1120 <func0+0x20>\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     L1\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%edx\n  lea    (%rdi,%rdx,4),%rdx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    (%rdi),%eax\n  add    $0x4,%rdi\n  test   %eax,%eax\n  js     L1\nL2:\n  cmp    %rdx,%rdi\n  jne    L3\nL0:\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4399
        },
        "L1": {
          "label": "L1",
          "addr": 4408
        },
        "L2": {
          "label": "L2",
          "addr": 4394
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, sum;\n  sum = 0;\n  for (i = 0; i < len; i++) {\n    sum += arr[i];\n    if (sum < 0)\n      return 1;\n  }\n  return 0;\n}"
    },
    {
      "task_id": 0,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movss  %xmm0,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1181 <func0+0x88>\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    1175 <func0+0x7c>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  subss  %xmm1,%xmm0\n  movss  0xea3(%rip),%xmm1        # 2000 <_fini+0xe70>\n  andps  %xmm0,%xmm1\n  movss  -0x20(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    1171 <func0+0x78>\n  mov    $0x1,%eax\n  jmp    118e <func0+0x95>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1121 <func0+0x28>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1116 <func0+0x1d>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movss  %xmm0,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL5:\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    L1\nL4:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  subss  %xmm1,%xmm0\n  movss  D0(%rip),%xmm1\n  andps  %xmm0,%xmm1\n  movss  -0x20(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    L2\n  mov    $0x1,%eax\n  jmp    L3\nL2:\n  addl   $0x1,-0x4(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    $0x0,%eax\nL3:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3747
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4481
        },
        "L1": {
          "label": "L1",
          "addr": 4469
        },
        "L2": {
          "label": "L2",
          "addr": 4465
        },
        "L3": {
          "label": "L3",
          "addr": 4494
        },
        "L4": {
          "label": "L4",
          "addr": 4385
        },
        "L5": {
          "label": "L5",
          "addr": 4374
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "dword",
            "value": 2147483647
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float *p, int n, float eps) {\n  int i, j;\n  for (i = 0; i < n; i++)\n    for (j = i + 1; j < n; j++)\n      if (fabsf(p[i] - p[j]) < eps)\n        return 1;\n  return 0;\n}"
    },
    {
      "task_id": 0,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    113c <func0+0x43>\n  mov    %esi,%ecx\n  mov    $0x1,%edx\n  movss  0xef0(%rip),%xmm3        # 2000 <_fini+0xeb0>\n  cmp    %rcx,%rdx\n  je     1142 <func0+0x49>\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  ja     1148 <func0+0x4f>\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     111e <func0+0x25>\n  add    $0x1,%rdx\n  jmp    1110 <func0+0x17>\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%ecx\n  mov    $0x1,%edx\n  movss  D0(%rip),%xmm3\nL4:\n  cmp    %rcx,%rdx\n  je     L1\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\nL3:\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  ja     L2\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L3\n  add    $0x1,%rdx\n  jmp    L4\nL0:\n  mov    $0x0,%eax\n  ret\nL1:\n  mov    $0x0,%eax\n  ret\nL2:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3824
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4412
        },
        "L1": {
          "label": "L1",
          "addr": 4418
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        },
        "L3": {
          "label": "L3",
          "addr": 4382
        },
        "L4": {
          "label": "L4",
          "addr": 4368
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "dword",
            "value": 2147483647
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(float *x, int n, float eps) {\n  int i, j;\n  for (i = 0; i < n; i++) {\n    for (j = i + 1; j < n; j++) {\n      if (fabsf(x[i] - x[j]) > eps)\n        return 1;\n    }\n  }\n  return 0;\n}"
    },
    {
      "task_id": 0,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1159 <func0+0x59>\n  movslq %esi,%rcx\n  mov    $0x1,%edx\n  movss  0xee8(%rip),%xmm3        # 2000 <_fini+0xea4>\n  cmp    %rcx,%rdx\n  je     1159 <func0+0x59>\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\n  jmp    1138 <func0+0x38>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1150 <func0+0x50>\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1130 <func0+0x30>\n  mov    $0x1,%eax\n  ret\n  xchg   %ax,%ax\n  add    $0x1,%rdx\n  cmp    %rcx,%rdx\n  jne    111d <func0+0x1d>\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rcx\n  mov    $0x1,%edx\n  movss  D0(%rip),%xmm3\n  cmp    %rcx,%rdx\n  je     L0\nL4:\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L2\nL1:\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L3\n  mov    $0x1,%eax\n  ret\n  xchg   %ax,%ax\nL2:\n  add    $0x1,%rdx\n  cmp    %rcx,%rdx\n  jne    L4\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3816
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4441
        },
        "L1": {
          "label": "L1",
          "addr": 4408
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4400
        },
        "L4": {
          "label": "L4",
          "addr": 4381
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "dword",
            "value": 2147483647
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float *x, int n, float eps) {\n  int i, j;\n  float t;\n  for (i = 0; i < n; i++) {\n    for (j = i + 1; j < n; j++) {\n      t = fabsf(x[i] - x[j]);\n      if (t < eps)\n        return 1;\n    }\n  }\n  return 0;\n}"
    },
    {
      "task_id": 0,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1159 <func0+0x59>\n  movslq %esi,%rcx\n  mov    $0x1,%edx\n  movss  0xee8(%rip),%xmm3        # 2000 <_fini+0xea4>\n  cmp    %rdx,%rcx\n  je     1159 <func0+0x59>\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\n  jmp    1138 <func0+0x38>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1150 <func0+0x50>\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1130 <func0+0x30>\n  mov    $0x1,%eax\n  ret\n  xchg   %ax,%ax\n  add    $0x1,%rdx\n  cmp    %rdx,%rcx\n  jne    111d <func0+0x1d>\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rcx\n  mov    $0x1,%edx\n  movss  D0(%rip),%xmm3\n  cmp    %rdx,%rcx\n  je     L0\nL4:\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L2\nL1:\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L3\n  mov    $0x1,%eax\n  ret\n  xchg   %ax,%ax\nL2:\n  add    $0x1,%rdx\n  cmp    %rdx,%rcx\n  jne    L4\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3816
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4441
        },
        "L1": {
          "label": "L1",
          "addr": 4408
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4400
        },
        "L4": {
          "label": "L4",
          "addr": 4381
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "dword",
            "value": 2147483647
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float *x, int n, float eps) {\n  int i, j;\n  float t;\n  for (i = 0; i < n; i++) {\n    for (j = i + 1; j < n; j++) {\n      t = fabsf(x[i] - x[j]);\n      if (t < eps)\n        return 1;\n    }\n  }\n  return 0;\n}"
    },
    {
      "task_id": 4,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  test   %esi,%esi\n  jle    1160 <func0+0x60>\n  lea    -0x1(%rsi),%eax\n  pxor   %xmm0,%xmm0\n  lea    0x4(%rdi,%rax,4),%rdx\n  mov    %rdi,%rax\n  nop\n  addss  (%rax),%xmm0\n  add    $0x4,%rax\n  cmp    %rax,%rdx\n  jne    1120 <func0+0x20>\n  divss  %xmm4,%xmm0\n  pxor   %xmm2,%xmm2\n  movss  0xec3(%rip),%xmm3        # 2000 <_fini+0xe94>\n  nopl   (%rax)\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  subss  %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  addss  %xmm1,%xmm2\n  cmp    %rdi,%rdx\n  jne    1140 <func0+0x40>\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret\n  pxor   %xmm2,%xmm2\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  pxor   %xmm0,%xmm0\n  lea    0x4(%rdi,%rax,4),%rdx\n  mov    %rdi,%rax\n  nop\nL1:\n  addss  (%rax),%xmm0\n  add    $0x4,%rax\n  cmp    %rax,%rdx\n  jne    L1\n  divss  %xmm4,%xmm0\n  pxor   %xmm2,%xmm2\n  movss  D0(%rip),%xmm3\n  nopl   (%rax)\nL2:\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  subss  %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  addss  %xmm1,%xmm2\n  cmp    %rdi,%rdx\n  jne    L2\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret\nL0:\n  pxor   %xmm2,%xmm2\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3779
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4448
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        },
        "L2": {
          "label": "L2",
          "addr": 4416
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "dword",
            "value": 2147483647
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float *x, int n) {\n  int i;\n  float sum = 0.0;\n  float mean;\n  for (i = 0; i < n; i++) {\n    sum += x[i];\n  }\n  mean = sum / n;\n  sum = 0.0;\n  for (i = 0; i < n; i++) {\n    sum += fabsf(x[i] - mean);\n  }\n  return sum / n;\n}"
    },
    {
      "task_id": 4,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  pxor   %xmm0,%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    114b <func0+0x52>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  -0x10(%rbp),%xmm1\n  addss  %xmm1,%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1121 <func0+0x28>\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x1c(%rbp),%xmm1\n  movss  -0x10(%rbp),%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  pxor   %xmm0,%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    11b6 <func0+0xbd>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  subss  -0x4(%rbp),%xmm0\n  movss  0xe5f(%rip),%xmm1        # 2000 <_fini+0xe2c>\n  andps  %xmm1,%xmm0\n  movss  -0xc(%rbp),%xmm1\n  addss  %xmm1,%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     117c <func0+0x83>\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x1c(%rbp),%xmm1\n  movss  -0xc(%rbp),%xmm0\n  divss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  pxor   %xmm0,%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL1:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  -0x10(%rbp),%xmm1\n  addss  %xmm1,%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L1\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x1c(%rbp),%xmm1\n  movss  -0x10(%rbp),%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  pxor   %xmm0,%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L2\nL3:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  subss  -0x4(%rbp),%xmm0\n  movss  D0(%rip),%xmm1\n  andps  %xmm1,%xmm0\n  movss  -0xc(%rbp),%xmm1\n  addss  %xmm1,%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\nL2:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x1c(%rbp),%xmm1\n  movss  -0xc(%rbp),%xmm0\n  divss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3679
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4427
        },
        "L1": {
          "label": "L1",
          "addr": 4385
        },
        "L2": {
          "label": "L2",
          "addr": 4534
        },
        "L3": {
          "label": "L3",
          "addr": 4476
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "dword",
            "value": 2147483647
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float *data, int N) {\n  float mean = 0;\n  int i = 0;\n  for (i = 0; i < N; i++) {\n    mean += data[i];\n  }\n  float mean_value = mean / N;\n  float var = 0;\n  for (i = 0; i < N; i++) {\n    var += fabs(data[i] - mean_value);\n  }\n  return var / N;\n}"
    },
    {
      "task_id": 4,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1155 <func0+0x5c>\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\n  pxor   %xmm0,%xmm0\n  addss  (%rdi),%xmm0\n  add    $0x4,%rdi\n  cmp    %rdx,%rdi\n  jne    1110 <func0+0x17>\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  divss  %xmm4,%xmm0\n  pxor   %xmm2,%xmm2\n  movss  0xecb(%rip),%xmm3        # 2000 <_fini+0xe9c>\n  movss  (%rax),%xmm1\n  subss  %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  addss  %xmm1,%xmm2\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    1135 <func0+0x3c>\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  pxor   %xmm2,%xmm2\n  jmp    114d <func0+0x54>",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\n  pxor   %xmm0,%xmm0\nL1:\n  addss  (%rdi),%xmm0\n  add    $0x4,%rdi\n  cmp    %rdx,%rdi\n  jne    L1\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  divss  %xmm4,%xmm0\n  pxor   %xmm2,%xmm2\n  movss  D0(%rip),%xmm3\nL2:\n  movss  (%rax),%xmm1\n  subss  %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  addss  %xmm1,%xmm2\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    L2\nL3:\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret\nL0:\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  pxor   %xmm2,%xmm2\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3787
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4437
        },
        "L1": {
          "label": "L1",
          "addr": 4368
        },
        "L2": {
          "label": "L2",
          "addr": 4405
        },
        "L3": {
          "label": "L3",
          "addr": 4429
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "dword",
            "value": 2147483647
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float *data, int n) {\n  int i;\n  float avg = 0.0;\n  float var = 0.0;\n  for (i = 0; i < n; i++) {\n    avg += data[i];\n  }\n  avg /= n;\n  for (i = 0; i < n; i++) {\n    var += fabs(data[i] - avg);\n  }\n  var /= n;\n  return var;\n}"
    },
    {
      "task_id": 5,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    1143 <func0+0x2a>\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  lea    -0x1(%rax),%edx\n  jmp    1148 <func0+0x2f>\n  mov    $0x0,%edx\n  mov    -0x28(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    1178 <func0+0x5f>\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,(%rax)\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  jmp    11de <func0+0xc5>\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x20(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1188 <func0+0x6f>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    L0\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  lea    -0x1(%rax),%edx\n  jmp    L1\nL0:\n  mov    $0x0,%edx\nL1:\n  mov    -0x28(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    L2\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,(%rax)\nL2:\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  jmp    L3\nL4:\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x20(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\nL3:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4419
        },
        "L1": {
          "label": "L1",
          "addr": 4424
        },
        "L2": {
          "label": "L2",
          "addr": 4472
        },
        "L3": {
          "label": "L3",
          "addr": 4574
        },
        "L4": {
          "label": "L4",
          "addr": 4488
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int y, int *m) {\n  int i, j;\n  *m = (n > 0) ? 2 * n - 1 : 0;\n  int *a = (int *)malloc((*m) * sizeof(int));\n  if (n > 0)\n    a[0] = x[0];\n  for (i = 1, j = 1; i < n; i++) {\n    a[j++] = y;\n    a[j++] = x[i];\n  }\n  return a;\n}"
    },
    {
      "task_id": 4,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  pxor   %xmm2,%xmm2\n  mov    %rdi,%rcx\n  mov    %esi,%edx\n  cvtsi2ss %esi,%xmm2\n  test   %esi,%esi\n  jle    1290 <func0+0x190>\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%r8d\n  jbe    12a0 <func0+0x1a0>\n  shr    $0x2,%esi\n  mov    %rdi,%rax\n  pxor   %xmm4,%xmm4\n  sub    $0x1,%esi\n  lea    0x10(%rdi),%rdi\n  movaps %xmm4,%xmm1\n  shl    $0x4,%rsi\n  add    %rdi,%rsi\n  nopw   0x0(%rax,%rax,1)\n  movups (%rax),%xmm0\n  add    $0x10,%rax\n  addss  %xmm0,%xmm1\n  movaps %xmm0,%xmm3\n  shufps $0x55,%xmm0,%xmm3\n  addss  %xmm3,%xmm1\n  movaps %xmm0,%xmm3\n  unpckhps %xmm0,%xmm3\n  shufps $0xff,%xmm0,%xmm0\n  addss  %xmm3,%xmm1\n  addss  %xmm0,%xmm1\n  cmp    %rsi,%rax\n  jne    1148 <func0+0x48>\n  mov    %edx,%eax\n  and    $0xfffffffc,%eax\n  cmp    %eax,%edx\n  je     1280 <func0+0x180>\n  movslq %eax,%rsi\n  addss  (%rcx,%rsi,4),%xmm1\n  lea    0x0(,%rsi,4),%rdi\n  lea    0x1(%rax),%esi\n  cmp    %esi,%edx\n  jle    11ac <func0+0xac>\n  add    $0x2,%eax\n  addss  0x4(%rcx,%rdi,1),%xmm1\n  cmp    %eax,%edx\n  jle    11ac <func0+0xac>\n  addss  0x8(%rcx,%rdi,1),%xmm1\n  movaps %xmm1,%xmm3\n  divss  %xmm2,%xmm3\n  cmp    $0x2,%r8d\n  jbe    1299 <func0+0x199>\n  lea    0x10(%rcx),%rdi\n  mov    %edx,%esi\n  movaps 0xe46(%rip),%xmm5        # 2010 <_fini+0xd60>\n  movaps %xmm3,%xmm6\n  mov    %rcx,%rax\n  shr    $0x2,%esi\n  movaps %xmm4,%xmm0\n  shufps $0x0,%xmm6,%xmm6\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  add    %rdi,%rsi\n  nopl   0x0(%rax)\n  movups (%rax),%xmm1\n  add    $0x10,%rax\n  subps  %xmm6,%xmm1\n  andps  %xmm5,%xmm1\n  addss  %xmm1,%xmm0\n  movaps %xmm1,%xmm4\n  shufps $0x55,%xmm1,%xmm4\n  addss  %xmm0,%xmm4\n  movaps %xmm1,%xmm0\n  unpckhps %xmm1,%xmm0\n  shufps $0xff,%xmm1,%xmm1\n  addss  %xmm4,%xmm0\n  addss  %xmm1,%xmm0\n  cmp    %rax,%rsi\n  jne    11e8 <func0+0xe8>\n  mov    %edx,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%dl\n  je     1278 <func0+0x178>\n  movslq %eax,%rsi\n  movss  0xdd0(%rip),%xmm4        # 2000 <_fini+0xd50>\n  movss  (%rcx,%rsi,4),%xmm1\n  lea    0x0(,%rsi,4),%rdi\n  lea    0x1(%rax),%esi\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\n  cmp    %edx,%esi\n  jge    1278 <func0+0x178>\n  movss  0x4(%rcx,%rdi,1),%xmm1\n  add    $0x2,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\n  cmp    %eax,%edx\n  jle    1278 <func0+0x178>\n  movss  0x8(%rcx,%rdi,1),%xmm1\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\n  divss  %xmm2,%xmm0\n  ret\n  nopl   (%rax)\n  movaps %xmm1,%xmm3\n  divss  %xmm2,%xmm3\n  jmp    11c1 <func0+0xc1>\n  nopl   0x0(%rax)\n  pxor   %xmm0,%xmm0\n  divss  %xmm2,%xmm0\n  ret\n  xor    %eax,%eax\n  movaps %xmm4,%xmm0\n  jmp    1225 <func0+0x125>\n  pxor   %xmm4,%xmm4\n  xor    %eax,%eax\n  movaps %xmm4,%xmm1\n  jmp    1182 <func0+0x82>",
      "asm_labeled": "<func0>:\n  endbr64\n  pxor   %xmm2,%xmm2\n  mov    %rdi,%rcx\n  mov    %esi,%edx\n  cvtsi2ss %esi,%xmm2\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%r8d\n  jbe    L1\n  shr    $0x2,%esi\n  mov    %rdi,%rax\n  pxor   %xmm4,%xmm4\n  sub    $0x1,%esi\n  lea    0x10(%rdi),%rdi\n  movaps %xmm4,%xmm1\n  shl    $0x4,%rsi\n  add    %rdi,%rsi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movups (%rax),%xmm0\n  add    $0x10,%rax\n  addss  %xmm0,%xmm1\n  movaps %xmm0,%xmm3\n  shufps $0x55,%xmm0,%xmm3\n  addss  %xmm3,%xmm1\n  movaps %xmm0,%xmm3\n  unpckhps %xmm0,%xmm3\n  shufps $0xff,%xmm0,%xmm0\n  addss  %xmm3,%xmm1\n  addss  %xmm0,%xmm1\n  cmp    %rsi,%rax\n  jne    L2\n  mov    %edx,%eax\n  and    $0xfffffffc,%eax\n  cmp    %eax,%edx\n  je     L3\nL10:\n  movslq %eax,%rsi\n  addss  (%rcx,%rsi,4),%xmm1\n  lea    0x0(,%rsi,4),%rdi\n  lea    0x1(%rax),%esi\n  cmp    %esi,%edx\n  jle    L4\n  add    $0x2,%eax\n  addss  0x4(%rcx,%rdi,1),%xmm1\n  cmp    %eax,%edx\n  jle    L4\n  addss  0x8(%rcx,%rdi,1),%xmm1\nL4:\n  movaps %xmm1,%xmm3\n  divss  %xmm2,%xmm3\n  cmp    $0x2,%r8d\n  jbe    L5\n  lea    0x10(%rcx),%rdi\nL8:\n  mov    %edx,%esi\n  movaps D0(%rip),%xmm5\n  movaps %xmm3,%xmm6\n  mov    %rcx,%rax\n  shr    $0x2,%esi\n  movaps %xmm4,%xmm0\n  shufps $0x0,%xmm6,%xmm6\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  add    %rdi,%rsi\n  nopl   0x0(%rax)\nL6:\n  movups (%rax),%xmm1\n  add    $0x10,%rax\n  subps  %xmm6,%xmm1\n  andps  %xmm5,%xmm1\n  addss  %xmm1,%xmm0\n  movaps %xmm1,%xmm4\n  shufps $0x55,%xmm1,%xmm4\n  addss  %xmm0,%xmm4\n  movaps %xmm1,%xmm0\n  unpckhps %xmm1,%xmm0\n  shufps $0xff,%xmm1,%xmm1\n  addss  %xmm4,%xmm0\n  addss  %xmm1,%xmm0\n  cmp    %rax,%rsi\n  jne    L6\n  mov    %edx,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%dl\n  je     L7\nL9:\n  movslq %eax,%rsi\n  movss  D1(%rip),%xmm4\n  movss  (%rcx,%rsi,4),%xmm1\n  lea    0x0(,%rsi,4),%rdi\n  lea    0x1(%rax),%esi\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\n  cmp    %edx,%esi\n  jge    L7\n  movss  0x4(%rcx,%rdi,1),%xmm1\n  add    $0x2,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\n  cmp    %eax,%edx\n  jle    L7\n  movss  0x8(%rcx,%rdi,1),%xmm1\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\nL7:\n  divss  %xmm2,%xmm0\n  ret\n  nopl   (%rax)\nL3:\n  movaps %xmm1,%xmm3\n  divss  %xmm2,%xmm3\n  jmp    L8\n  nopl   0x0(%rax)\nL0:\n  pxor   %xmm0,%xmm0\n  divss  %xmm2,%xmm0\n  ret\nL5:\n  xor    %eax,%eax\n  movaps %xmm4,%xmm0\n  jmp    L9\nL1:\n  pxor   %xmm4,%xmm4\n  xor    %eax,%eax\n  movaps %xmm4,%xmm1\n  jmp    L10",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8208,
          "bias": [
            3654
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3536
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4752
        },
        "L1": {
          "label": "L1",
          "addr": 4768
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        },
        "L3": {
          "label": "L3",
          "addr": 4736
        },
        "L4": {
          "label": "L4",
          "addr": 4524
        },
        "L5": {
          "label": "L5",
          "addr": 4761
        },
        "L6": {
          "label": "L6",
          "addr": 4584
        },
        "L7": {
          "label": "L7",
          "addr": 4728
        },
        "L8": {
          "label": "L8",
          "addr": 4545
        },
        "L9": {
          "label": "L9",
          "addr": 4645
        },
        "L10": {
          "label": "L10",
          "addr": 4482
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f000000000000000000000000ffffff7fffffff7fffffff7fffffff7f",
      "rodata_parsed": {
        "func0": {
          "0x2010": {
            "type": "dword[4]",
            "value": [
              2147483647,
              2147483647,
              2147483647,
              2147483647
            ]
          },
          "0x2000": {
            "type": "dword",
            "value": 2147483647
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float *x, int n) {\n  int i;\n  float sum = 0.0;\n  float mean;\n  for (i = 0; i < n; i++) {\n    sum += x[i];\n  }\n  mean = sum / n;\n  sum = 0.0;\n  for (i = 0; i < n; i++) {\n    sum += fabsf(x[i] - mean);\n  }\n  return sum / n;\n}"
    },
    {
      "task_id": 5,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1180 <func0+0x60>\n  push   %r12\n  mov    %edx,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  lea    -0x1(%rsi,%rsi,1),%edi\n  push   %rbx\n  mov    %esi,%ebx\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    0x0(%rbp),%edx\n  mov    %edx,(%rax)\n  cmp    $0x1,%ebx\n  je     1175 <func0+0x55>\n  movslq %ebx,%rsi\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\n  mov    0x0(%rbp,%rdx,4),%ecx\n  mov    %r12d,-0x4(%rax,%rdx,8)\n  mov    %ecx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    1160 <func0+0x40>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  movl   $0x0,(%rcx)\n  xor    %edi,%edi\n  jmp    1050 <malloc@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %r12\n  mov    %edx,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  lea    -0x1(%rsi,%rsi,1),%edi\n  push   %rbx\n  mov    %esi,%ebx\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    0x0(%rbp),%edx\n  mov    %edx,(%rax)\n  cmp    $0x1,%ebx\n  je     L1\n  movslq %ebx,%rsi\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    0x0(%rbp,%rdx,4),%ecx\n  mov    %r12d,-0x4(%rax,%rdx,8)\n  mov    %ecx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    L2\nL1:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  movl   $0x0,(%rcx)\n  xor    %edi,%edi\n  jmp    1050 <malloc@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4480
        },
        "L1": {
          "label": "L1",
          "addr": 4469
        },
        "L2": {
          "label": "L2",
          "addr": 4448
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int y, int *sz) {\n  int *a;\n  int i;\n  if (n <= 0) {\n    *sz = 0;\n    a = malloc(0);\n  } else {\n    *sz = 2 * n - 1;\n    a = malloc(2 * n - 1);\n    a[0] = x[0];\n    for (i = 1; i < n; i++) {\n      a[2 * i - 1] = y;\n      a[2 * i] = x[i];\n    }\n  }\n  return a;\n}"
    },
    {
      "task_id": 5,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    1169 <func0+0x50>\n  mov    %rdi,%rbx\n  mov    %esi,%r12d\n  mov    %edx,%ebp\n  lea    -0x1(%rsi,%rsi,1),%edi\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    (%rbx),%edx\n  mov    %edx,(%rax)\n  cmp    $0x1,%r12d\n  jle    1164 <func0+0x4b>\n  mov    %r12d,%esi\n  mov    $0x1,%edx\n  mov    %ebp,-0x4(%rax,%rdx,8)\n  mov    (%rbx,%rdx,4),%ecx\n  mov    %ecx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    1151 <func0+0x38>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  movl   $0x0,(%rcx)\n  mov    $0x0,%edi\n  call   1050 <malloc@plt>\n  jmp    1164 <func0+0x4b>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  mov    %esi,%r12d\n  mov    %edx,%ebp\n  lea    -0x1(%rsi,%rsi,1),%edi\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    (%rbx),%edx\n  mov    %edx,(%rax)\n  cmp    $0x1,%r12d\n  jle    L1\n  mov    %r12d,%esi\n  mov    $0x1,%edx\nL2:\n  mov    %ebp,-0x4(%rax,%rdx,8)\n  mov    (%rbx,%rdx,4),%ecx\n  mov    %ecx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    L2\nL1:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL0:\n  movl   $0x0,(%rcx)\n  mov    $0x0,%edi\n  call   <malloc@plt>\n  jmp    L1",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4457
        },
        "L1": {
          "label": "L1",
          "addr": 4452
        },
        "L2": {
          "label": "L2",
          "addr": 4433
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int y, int *m) {\n  int *a;\n  int i;\n  if (n > 0) {\n    *m = 2 * n - 1;\n    a = malloc((size_t)(*m) * sizeof(int));\n    a[0] = x[0];\n    for (i = 1; i < n; i++) {\n      a[2 * i - 1] = y;\n      a[2 * i] = x[i];\n    }\n  } else {\n    *m = 0;\n    a = malloc((size_t)(*m) * sizeof(int));\n  }\n  return a;\n}"
    },
    {
      "task_id": 1,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   10a0 <strlen@plt>\n  mov    $0x50,%edi\n  mov    %rax,%rbp\n  call   10b0 <malloc@plt>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r14\n  call   10b0 <malloc@plt>\n  mov    (%rsp),%rdx\n  mov    %rax,%r15\n  movl   $0x0,(%rdx)\n  test   %ebp,%ebp\n  jle    122c <func0+0x8c>\n  lea    -0x1(%rbp),%eax\n  mov    $0xa,%ecx\n  xor    %ebp,%ebp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%r13\n  jmp    120d <func0+0x6d>\n  xchg   %ax,%ax\n  cmp    $0x29,%al\n  je     1250 <func0+0xb0>\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     122c <func0+0x8c>\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  jne    1200 <func0+0x60>\n  movslq %ebp,%rax\n  add    $0x1,%rbx\n  add    $0x1,%r12d\n  add    $0x1,%ebp\n  movb   $0x28,(%r15,%rax,1)\n  cmp    %r13,%rbx\n  jne    120d <func0+0x6d>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  movb   $0x29,(%r15,%rax,1)\n  sub    $0x1,%r12d\n  jne    1204 <func0+0x64>\n  movslq (%rdx),%rax\n  movslq %ebp,%rbp\n  mov    %r15,%rdi\n  mov    %ecx,0x8(%rsp)\n  movb   $0x0,(%r15,%rbp,1)\n  mov    %rdx,(%rsp)\n  lea    (%r14,%rax,8),%rbp\n  call   10d0 <strdup@plt>\n  mov    (%rsp),%rdx\n  mov    0x8(%rsp),%ecx\n  mov    %rax,0x0(%rbp)\n  xor    %ebp,%ebp\n  mov    (%rdx),%eax\n  add    $0x1,%eax\n  mov    %eax,(%rdx)\n  cmp    %ecx,%eax\n  jl     1204 <func0+0x64>\n  add    %ecx,%ecx\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  movslq %ecx,%rsi\n  mov    %ecx,(%rsp)\n  shl    $0x3,%rsi\n  call   10c0 <realloc@plt>\n  mov    0x8(%rsp),%rdx\n  mov    (%rsp),%ecx\n  mov    %rax,%r14\n  jmp    1204 <func0+0x64>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   <strlen@plt>\n  mov    $0x50,%edi\n  mov    %rax,%rbp\n  call   <malloc@plt>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r14\n  call   <malloc@plt>\n  mov    (%rsp),%rdx\n  mov    %rax,%r15\n  movl   $0x0,(%rdx)\n  test   %ebp,%ebp\n  jle    L0\n  lea    -0x1(%rbp),%eax\n  mov    $0xa,%ecx\n  xor    %ebp,%ebp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%r13\n  jmp    L1\n  xchg   %ax,%ax\nL3:\n  cmp    $0x29,%al\n  je     L2\nL4:\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  jne    L3\n  movslq %ebp,%rax\n  add    $0x1,%rbx\n  add    $0x1,%r12d\n  add    $0x1,%ebp\n  movb   $0x28,(%r15,%rax,1)\n  cmp    %r13,%rbx\n  jne    L1\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  movb   $0x29,(%r15,%rax,1)\n  sub    $0x1,%r12d\n  jne    L4\n  movslq (%rdx),%rax\n  movslq %ebp,%rbp\n  mov    %r15,%rdi\n  mov    %ecx,0x8(%rsp)\n  movb   $0x0,(%r15,%rbp,1)\n  mov    %rdx,(%rsp)\n  lea    (%r14,%rax,8),%rbp\n  call   <strdup@plt>\n  mov    (%rsp),%rdx\n  mov    0x8(%rsp),%ecx\n  mov    %rax,0x0(%rbp)\n  xor    %ebp,%ebp\n  mov    (%rdx),%eax\n  add    $0x1,%eax\n  mov    %eax,(%rdx)\n  cmp    %ecx,%eax\n  jl     L4\n  add    %ecx,%ecx\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  movslq %ecx,%rsi\n  mov    %ecx,(%rsp)\n  shl    $0x3,%rsi\n  call   <realloc@plt>\n  mov    0x8(%rsp),%rdx\n  mov    (%rsp),%ecx\n  mov    %rax,%r14\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4652
        },
        "L1": {
          "label": "L1",
          "addr": 4621
        },
        "L2": {
          "label": "L2",
          "addr": 4688
        },
        "L3": {
          "label": "L3",
          "addr": 4608
        },
        "L4": {
          "label": "L4",
          "addr": 4612
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(const char *text, int *count) {\n  int len = strlen(text);\n  char **result = malloc(10 * sizeof(char *));\n  char *tmp = malloc(len + 1);\n  int i, j = 0, k = 0, l = 10;\n  *count = 0;\n  for (i = 0; i < len; i++) {\n    if (text[i] == '(') {\n      tmp[k++] = text[i];\n      j++;\n    } else if (text[i] == ')') {\n      tmp[k++] = text[i];\n      j--;\n      if (j == 0) {\n        tmp[k] = '\\0';\n        result[*count] = strdup(tmp);\n        (*count)++;\n        if (*count >= l) {\n          l *= 2;\n          result = realloc(result, l * sizeof(char *));\n        }\n        k = 0;\n      }\n    }\n  }\n  free(tmp);\n  return result;\n}"
    },
    {
      "task_id": 1,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   10a0 <strlen@plt>\n  mov    $0x50,%edi\n  mov    %rax,%rbp\n  call   10b0 <malloc@plt>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r14\n  call   10b0 <malloc@plt>\n  mov    (%rsp),%rdx\n  mov    %rax,%r15\n  movl   $0x0,(%rdx)\n  test   %ebp,%ebp\n  jle    122c <func0+0x8c>\n  lea    -0x1(%rbp),%eax\n  mov    $0xa,%ecx\n  xor    %ebp,%ebp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%r13\n  jmp    120d <func0+0x6d>\n  xchg   %ax,%ax\n  cmp    $0x29,%al\n  je     1250 <func0+0xb0>\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     122c <func0+0x8c>\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  jne    1200 <func0+0x60>\n  movslq %ebp,%rax\n  add    $0x1,%rbx\n  add    $0x1,%r12d\n  add    $0x1,%ebp\n  movb   $0x28,(%r15,%rax,1)\n  cmp    %r13,%rbx\n  jne    120d <func0+0x6d>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  movb   $0x29,(%r15,%rax,1)\n  sub    $0x1,%r12d\n  jne    1204 <func0+0x64>\n  movslq (%rdx),%rax\n  movslq %ebp,%rbp\n  mov    %r15,%rdi\n  mov    %ecx,0x8(%rsp)\n  movb   $0x0,(%r15,%rbp,1)\n  mov    %rdx,(%rsp)\n  lea    (%r14,%rax,8),%rbp\n  call   10d0 <strdup@plt>\n  mov    (%rsp),%rdx\n  mov    0x8(%rsp),%ecx\n  mov    %rax,0x0(%rbp)\n  xor    %ebp,%ebp\n  mov    (%rdx),%eax\n  add    $0x1,%eax\n  mov    %eax,(%rdx)\n  cmp    %ecx,%eax\n  jl     1204 <func0+0x64>\n  add    %ecx,%ecx\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  movslq %ecx,%rsi\n  mov    %ecx,(%rsp)\n  shl    $0x3,%rsi\n  call   10c0 <realloc@plt>\n  mov    0x8(%rsp),%rdx\n  mov    (%rsp),%ecx\n  mov    %rax,%r14\n  jmp    1204 <func0+0x64>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   <strlen@plt>\n  mov    $0x50,%edi\n  mov    %rax,%rbp\n  call   <malloc@plt>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r14\n  call   <malloc@plt>\n  mov    (%rsp),%rdx\n  mov    %rax,%r15\n  movl   $0x0,(%rdx)\n  test   %ebp,%ebp\n  jle    L0\n  lea    -0x1(%rbp),%eax\n  mov    $0xa,%ecx\n  xor    %ebp,%ebp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%r13\n  jmp    L1\n  xchg   %ax,%ax\nL3:\n  cmp    $0x29,%al\n  je     L2\nL4:\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  jne    L3\n  movslq %ebp,%rax\n  add    $0x1,%rbx\n  add    $0x1,%r12d\n  add    $0x1,%ebp\n  movb   $0x28,(%r15,%rax,1)\n  cmp    %r13,%rbx\n  jne    L1\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  movb   $0x29,(%r15,%rax,1)\n  sub    $0x1,%r12d\n  jne    L4\n  movslq (%rdx),%rax\n  movslq %ebp,%rbp\n  mov    %r15,%rdi\n  mov    %ecx,0x8(%rsp)\n  movb   $0x0,(%r15,%rbp,1)\n  mov    %rdx,(%rsp)\n  lea    (%r14,%rax,8),%rbp\n  call   <strdup@plt>\n  mov    (%rsp),%rdx\n  mov    0x8(%rsp),%ecx\n  mov    %rax,0x0(%rbp)\n  xor    %ebp,%ebp\n  mov    (%rdx),%eax\n  add    $0x1,%eax\n  mov    %eax,(%rdx)\n  cmp    %ecx,%eax\n  jl     L4\n  add    %ecx,%ecx\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  movslq %ecx,%rsi\n  mov    %ecx,(%rsp)\n  shl    $0x3,%rsi\n  call   <realloc@plt>\n  mov    0x8(%rsp),%rdx\n  mov    (%rsp),%ecx\n  mov    %rax,%r14\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4652
        },
        "L1": {
          "label": "L1",
          "addr": 4621
        },
        "L2": {
          "label": "L2",
          "addr": 4688
        },
        "L3": {
          "label": "L3",
          "addr": 4608
        },
        "L4": {
          "label": "L4",
          "addr": 4612
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(const char *text, int *count) {\n  int len = strlen(text);\n  char **result = malloc(10 * sizeof(char *));\n  char *tmp = malloc(len + 1);\n  int i, j = 0, k = 0, l = 10;\n  *count = 0;\n  for (i = 0; i < len; i++) {\n    if (text[i] == '(') {\n      tmp[k++] = text[i];\n      j++;\n    } else if (text[i] == ')') {\n      tmp[k++] = text[i];\n      j--;\n      if (j == 0) {\n        tmp[k] = '\\0';\n        result[*count] = strdup(tmp);\n        (*count)++;\n        if (*count >= l) {\n          l *= 2;\n          result = realloc(result, l * sizeof(char *));\n        }\n        k = 0;\n      }\n    }\n  }\n  free(tmp);\n  return result;\n}"
    },
    {
      "task_id": 1,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,-0x24(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movl   $0xa,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x24(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  mov    -0x50(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x28(%rbp)\n  jmp    12f8 <func0+0x15f>\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x35(%rbp)\n  cmpb   $0x28,-0x35(%rbp)\n  jne    124c <func0+0xb3>\n  addl   $0x1,-0x34(%rbp)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x35(%rbp),%eax\n  mov    %al,(%rdx)\n  jmp    12f4 <func0+0x15b>\n  cmpb   $0x29,-0x35(%rbp)\n  jne    12f4 <func0+0x15b>\n  subl   $0x1,-0x34(%rbp)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x35(%rbp),%eax\n  mov    %al,(%rdx)\n  cmpl   $0x0,-0x34(%rbp)\n  jne    12f4 <func0+0x15b>\n  mov    -0x2c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strdup@plt>\n  mov    %rax,(%rbx)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x50(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x30(%rbp)\n  jg     12ed <func0+0x154>\n  shll   -0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10c0 <realloc@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  addl   $0x1,-0x28(%rbp)\n  mov    -0x28(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     1211 <func0+0x78>\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x24(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movl   $0xa,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x24(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  mov    -0x50(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x28(%rbp)\n  jmp    L0\nL4:\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x35(%rbp)\n  cmpb   $0x28,-0x35(%rbp)\n  jne    L1\n  addl   $0x1,-0x34(%rbp)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x35(%rbp),%eax\n  mov    %al,(%rdx)\n  jmp    L2\nL1:\n  cmpb   $0x29,-0x35(%rbp)\n  jne    L2\n  subl   $0x1,-0x34(%rbp)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x35(%rbp),%eax\n  mov    %al,(%rdx)\n  cmpl   $0x0,-0x34(%rbp)\n  jne    L2\n  mov    -0x2c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,(%rbx)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x50(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x30(%rbp)\n  jg     L3\n  shll   -0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x20(%rbp)\nL3:\n  movl   $0x0,-0x2c(%rbp)\nL2:\n  addl   $0x1,-0x28(%rbp)\nL0:\n  mov    -0x28(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     L4\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4856
        },
        "L1": {
          "label": "L1",
          "addr": 4684
        },
        "L2": {
          "label": "L2",
          "addr": 4852
        },
        "L3": {
          "label": "L3",
          "addr": 4845
        },
        "L4": {
          "label": "L4",
          "addr": 4625
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char *s, int *n) {\n  int len = strlen(s);\n  int count = 0;\n  int size = 10;\n  char **result = malloc(size * sizeof(char *));\n  char *tmp = malloc(len + 1);\n  int i, j = 0;\n  *n = 0;\n  for (i = 0; i < len; i++) {\n    char c = s[i];\n    if (c == '(') {\n      count++;\n      tmp[j++] = c;\n    } else if (c == ')') {\n      count--;\n      tmp[j++] = c;\n      if (count == 0) {\n        tmp[j] = '\\0';\n        result[*n] = strdup(tmp);\n        (*n)++;\n        if (*n >= size) {\n          size *= 2;\n          result = realloc(result, size * sizeof(char *));\n        }\n        j = 0;\n      }\n    }\n  }\n  free(tmp);\n  return result;\n}"
    },
    {
      "task_id": 1,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r13\n  mov    %rsi,%r14\n  call   10a0 <strlen@plt>\n  mov    %rax,%rbp\n  mov    $0x50,%edi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r15\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r12\n  movl   $0x0,(%r14)\n  test   %ebp,%ebp\n  jle    1288 <func0+0xef>\n  mov    %r13,%rbx\n  lea    -0x1(%rbp),%eax\n  lea    0x1(%r13,%rax,1),%r13\n  mov    $0x0,%edx\n  movl   $0xa,0x4(%rsp)\n  mov    $0x0,%ebp\n  jmp    1219 <func0+0x80>\n  add    $0x1,%ebp\n  movslq %edx,%rax\n  movb   $0x28,(%r12,%rax,1)\n  lea    0x1(%rdx),%edx\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     1288 <func0+0xef>\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  je     1202 <func0+0x69>\n  cmp    $0x29,%al\n  jne    1210 <func0+0x77>\n  lea    0x1(%rdx),%eax\n  movslq %edx,%rdx\n  movb   $0x29,(%r12,%rdx,1)\n  mov    %eax,%edx\n  sub    $0x1,%ebp\n  jne    1210 <func0+0x77>\n  cltq\n  movb   $0x0,(%r12,%rax,1)\n  movslq (%r14),%rax\n  lea    (%r15,%rax,8),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %r12,%rdi\n  call   10d0 <strdup@plt>\n  mov    0x8(%rsp),%rcx\n  mov    %rax,(%rcx)\n  mov    (%r14),%eax\n  add    $0x1,%eax\n  mov    %eax,(%r14)\n  mov    %ebp,%edx\n  cmp    0x4(%rsp),%eax\n  jl     1210 <func0+0x77>\n  shll   0x4(%rsp)\n  mov    0x4(%rsp),%eax\n  movslq %eax,%rsi\n  shl    $0x3,%rsi\n  mov    %r15,%rdi\n  call   10c0 <realloc@plt>\n  mov    %rax,%r15\n  mov    %ebp,%edx\n  jmp    1210 <func0+0x77>\n  mov    %r12,%rdi\n  call   1090 <free@plt>\n  mov    %r15,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r13\n  mov    %rsi,%r14\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  mov    $0x50,%edi\n  call   <malloc@plt>\n  mov    %rax,%r15\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r12\n  movl   $0x0,(%r14)\n  test   %ebp,%ebp\n  jle    L0\n  mov    %r13,%rbx\n  lea    -0x1(%rbp),%eax\n  lea    0x1(%r13,%rax,1),%r13\n  mov    $0x0,%edx\n  movl   $0xa,0x4(%rsp)\n  mov    $0x0,%ebp\n  jmp    L1\nL2:\n  add    $0x1,%ebp\n  movslq %edx,%rax\n  movb   $0x28,(%r12,%rax,1)\n  lea    0x1(%rdx),%edx\nL3:\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  je     L2\n  cmp    $0x29,%al\n  jne    L3\n  lea    0x1(%rdx),%eax\n  movslq %edx,%rdx\n  movb   $0x29,(%r12,%rdx,1)\n  mov    %eax,%edx\n  sub    $0x1,%ebp\n  jne    L3\n  cltq\n  movb   $0x0,(%r12,%rax,1)\n  movslq (%r14),%rax\n  lea    (%r15,%rax,8),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %r12,%rdi\n  call   <strdup@plt>\n  mov    0x8(%rsp),%rcx\n  mov    %rax,(%rcx)\n  mov    (%r14),%eax\n  add    $0x1,%eax\n  mov    %eax,(%r14)\n  mov    %ebp,%edx\n  cmp    0x4(%rsp),%eax\n  jl     L3\n  shll   0x4(%rsp)\n  mov    0x4(%rsp),%eax\n  movslq %eax,%rsi\n  shl    $0x3,%rsi\n  mov    %r15,%rdi\n  call   <realloc@plt>\n  mov    %rax,%r15\n  mov    %ebp,%edx\n  jmp    L3\nL0:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    %r15,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4744
        },
        "L1": {
          "label": "L1",
          "addr": 4633
        },
        "L2": {
          "label": "L2",
          "addr": 4610
        },
        "L3": {
          "label": "L3",
          "addr": 4624
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char **func0(char *s, int *returnSize) {\n  int n = strlen(s);\n  char **res = (char **)malloc(sizeof(char *) * 10);\n  char *stack = (char *)malloc(sizeof(char) * (n + 1));\n  int top = 0, i, alloc = 10;\n  *returnSize = 0;\n  for (i = 0; i < n; i++) {\n    if (s[i] == '(') {\n      stack[top++] = '(';\n    } else if (s[i] == ')') {\n      stack[top++] = ')';\n      top--;\n      if (top == 0) {\n        stack[top] = 0;\n        res[*returnSize] = strdup(stack);\n        (*returnSize)++;\n        if (*returnSize >= alloc) {\n          alloc *= 2;\n          res = (char **)realloc(res, sizeof(char *) * alloc);\n        }\n      }\n    }\n  }\n  free(stack);\n  return res;\n}"
    },
    {
      "task_id": 5,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1230 <func0+0x110>\n  push   %r12\n  mov    %edx,%r12d\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi,%rsi,1),%edi\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r8\n  mov    (%rbx),%eax\n  mov    %eax,(%r8)\n  cmp    $0x1,%ebp\n  je     1223 <func0+0x103>\n  lea    -0x2(%rbp),%eax\n  lea    -0x1(%rbp),%esi\n  cmp    $0x2,%eax\n  jbe    123d <func0+0x11d>\n  mov    %esi,%ecx\n  movd   %r12d,%xmm4\n  xor    %eax,%eax\n  shr    $0x2,%ecx\n  pshufd $0x0,%xmm4,%xmm0\n  shl    $0x4,%rcx\n  nop\n  movdqu 0x4(%rbx,%rax,1),%xmm2\n  movdqa %xmm0,%xmm1\n  punpckldq %xmm2,%xmm1\n  movups %xmm1,0x4(%r8,%rax,2)\n  movdqa %xmm0,%xmm1\n  punpckhdq %xmm2,%xmm1\n  movups %xmm1,0x14(%r8,%rax,2)\n  add    $0x10,%rax\n  cmp    %rax,%rcx\n  jne    1180 <func0+0x60>\n  mov    %esi,%ecx\n  and    $0xfffffffc,%ecx\n  lea    0x1(%rcx),%eax\n  lea    0x1(%rcx,%rcx,1),%edx\n  cmp    %ecx,%esi\n  je     1223 <func0+0x103>\n  movslq %eax,%rcx\n  movd   %r12d,%xmm0\n  movslq %edx,%rdx\n  lea    0x0(,%rcx,4),%rdi\n  mov    (%rbx,%rcx,4),%ecx\n  lea    0x0(,%rdx,4),%rsi\n  movd   %ecx,%xmm5\n  punpckldq %xmm5,%xmm0\n  movq   %xmm0,(%r8,%rdx,4)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%ebp\n  jle    1223 <func0+0x103>\n  movd   0x4(%rbx,%rdi,1),%xmm6\n  movd   %r12d,%xmm0\n  add    $0x2,%eax\n  punpckldq %xmm6,%xmm0\n  movq   %xmm0,0x8(%r8,%rsi,1)\n  cmp    %eax,%ebp\n  jle    1223 <func0+0x103>\n  mov    0x8(%rbx,%rdi,1),%eax\n  movd   %r12d,%xmm0\n  movd   %eax,%xmm7\n  punpckldq %xmm7,%xmm0\n  movq   %xmm0,0x10(%r8,%rsi,1)\n  pop    %rbx\n  mov    %r8,%rax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\n  movl   $0x0,(%rcx)\n  xor    %edi,%edi\n  jmp    1050 <malloc@plt>\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  jmp    11bb <func0+0x9b>",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %r12\n  mov    %edx,%r12d\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi,%rsi,1),%edi\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  mov    (%rbx),%eax\n  mov    %eax,(%r8)\n  cmp    $0x1,%ebp\n  je     L1\n  lea    -0x2(%rbp),%eax\n  lea    -0x1(%rbp),%esi\n  cmp    $0x2,%eax\n  jbe    L2\n  mov    %esi,%ecx\n  movd   %r12d,%xmm4\n  xor    %eax,%eax\n  shr    $0x2,%ecx\n  pshufd $0x0,%xmm4,%xmm0\n  shl    $0x4,%rcx\n  nop\nL3:\n  movdqu 0x4(%rbx,%rax,1),%xmm2\n  movdqa %xmm0,%xmm1\n  punpckldq %xmm2,%xmm1\n  movups %xmm1,0x4(%r8,%rax,2)\n  movdqa %xmm0,%xmm1\n  punpckhdq %xmm2,%xmm1\n  movups %xmm1,0x14(%r8,%rax,2)\n  add    $0x10,%rax\n  cmp    %rax,%rcx\n  jne    L3\n  mov    %esi,%ecx\n  and    $0xfffffffc,%ecx\n  lea    0x1(%rcx),%eax\n  lea    0x1(%rcx,%rcx,1),%edx\n  cmp    %ecx,%esi\n  je     L1\nL4:\n  movslq %eax,%rcx\n  movd   %r12d,%xmm0\n  movslq %edx,%rdx\n  lea    0x0(,%rcx,4),%rdi\n  mov    (%rbx,%rcx,4),%ecx\n  lea    0x0(,%rdx,4),%rsi\n  movd   %ecx,%xmm5\n  punpckldq %xmm5,%xmm0\n  movq   %xmm0,(%r8,%rdx,4)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%ebp\n  jle    L1\n  movd   0x4(%rbx,%rdi,1),%xmm6\n  movd   %r12d,%xmm0\n  add    $0x2,%eax\n  punpckldq %xmm6,%xmm0\n  movq   %xmm0,0x8(%r8,%rsi,1)\n  cmp    %eax,%ebp\n  jle    L1\n  mov    0x8(%rbx,%rdi,1),%eax\n  movd   %r12d,%xmm0\n  movd   %eax,%xmm7\n  punpckldq %xmm7,%xmm0\n  movq   %xmm0,0x10(%r8,%rsi,1)\nL1:\n  pop    %rbx\n  mov    %r8,%rax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  movl   $0x0,(%rcx)\n  xor    %edi,%edi\n  jmp    1050 <malloc@plt>\nL2:\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4656
        },
        "L1": {
          "label": "L1",
          "addr": 4643
        },
        "L2": {
          "label": "L2",
          "addr": 4669
        },
        "L3": {
          "label": "L3",
          "addr": 4480
        },
        "L4": {
          "label": "L4",
          "addr": 4539
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int y, int *m) {\n  int i;\n  int *a;\n  *m = 0;\n  for (i = 0; i < n; i++) {\n    *m = *m + 1;\n    if (x[i] == y) {\n      *m = *m - 1;\n    }\n  }\n  a = (int *)malloc((*m) * sizeof(int));\n  *m = 0;\n  for (i = 0; i < n; i++) {\n    *m = *m + 1;\n    if (x[i] == y) {\n      *m = *m - 1;\n    } else {\n      a[*m] = x[i];\n    }\n  }\n  return a;\n}"
    },
    {
      "task_id": 8,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    115f <func0+0x66>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x8(%rbp),%edx\n  imul   %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1123 <func0+0x2a>\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x8(%rbp),%edx\n  imul   %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L1\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4447
        },
        "L1": {
          "label": "L1",
          "addr": 4387
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *arr, int n, int *out) {\n  int sum = 0;\n  int prod = 1;\n  for (int i = 0; i < n; i++) {\n    sum += arr[i];\n    prod *= arr[i];\n  }\n  out[0] = sum;\n  out[1] = prod;\n}"
    },
    {
      "task_id": 8,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1140 <func0+0x40>\n  lea    -0x1(%rsi),%eax\n  mov    $0x1,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rdi),%eax\n  add    $0x4,%rdi\n  imul   %eax,%ecx\n  add    %eax,%esi\n  cmp    %r8,%rdi\n  jne    1120 <func0+0x20>\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  mov    $0x1,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    $0x1,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    (%rdi),%eax\n  add    $0x4,%rdi\n  imul   %eax,%ecx\n  add    %eax,%esi\n  cmp    %r8,%rdi\n  jne    L1\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *a, int n, int *p) {\n  int i, s = 0, t = 1;\n  for (i = 0; i < n; ++i) {\n    s += a[i];\n    t *= a[i];\n  }\n  p[0] = s;\n  p[1] = t;\n}"
    },
    {
      "task_id": 8,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    112c <func0+0x33>\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%ecx\n  lea    0x4(%rdi,%rcx,4),%r8\n  mov    $0x1,%esi\n  mov    $0x0,%edi\n  mov    (%rax),%ecx\n  add    %ecx,%edi\n  imul   %ecx,%esi\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  jne    1116 <func0+0x1d>\n  mov    %edi,(%rdx)\n  mov    %esi,0x4(%rdx)\n  ret\n  mov    $0x1,%esi\n  mov    $0x0,%edi\n  jmp    1126 <func0+0x2d>",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%ecx\n  lea    0x4(%rdi,%rcx,4),%r8\n  mov    $0x1,%esi\n  mov    $0x0,%edi\nL1:\n  mov    (%rax),%ecx\n  add    %ecx,%edi\n  imul   %ecx,%esi\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  jne    L1\nL2:\n  mov    %edi,(%rdx)\n  mov    %esi,0x4(%rdx)\n  ret\nL0:\n  mov    $0x1,%esi\n  mov    $0x0,%edi\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4396
        },
        "L1": {
          "label": "L1",
          "addr": 4374
        },
        "L2": {
          "label": "L2",
          "addr": 4390
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *a, int n, int *p) {\n  int i;\n  int s = 0, pd = 1;\n  for (i = 0; i < n; i++) {\n    s += a[i];\n    pd *= a[i];\n  }\n  p[0] = s;\n  p[1] = pd;\n}"
    },
    {
      "task_id": 7,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    11d8 <func0+0x98>\n  lea    -0x1(%rsi),%eax\n  mov    %rdx,%r13\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%rax\n  xor    %ebp,%ebp\n  mov    %rax,(%rsp)\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx),%r14\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   1070 <strstr@plt>\n  test   %rax,%rax\n  je     11ad <func0+0x6d>\n  add    $0x1,%r12d\n  mov    %rbp,%rdi\n  movslq %r12d,%rdx\n  lea    0x0(,%rdx,8),%r15\n  mov    %r15,%rsi\n  call   1060 <realloc@plt>\n  mov    %r14,-0x8(%rax,%r15,1)\n  mov    %rax,%rbp\n  add    $0x8,%rbx\n  cmp    (%rsp),%rbx\n  jne    1178 <func0+0x38>\n  mov    0x8(%rsp),%rax\n  mov    %r12d,(%rax)\n  add    $0x18,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  jmp    11b7 <func0+0x77>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdx,%r13\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%rax\n  xor    %ebp,%ebp\n  mov    %rax,(%rsp)\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    (%rbx),%r14\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L1\n  add    $0x1,%r12d\n  mov    %rbp,%rdi\n  movslq %r12d,%rdx\n  lea    0x0(,%rdx,8),%r15\n  mov    %r15,%rsi\n  call   <realloc@plt>\n  mov    %r14,-0x8(%rax,%r15,1)\n  mov    %rax,%rbp\nL1:\n  add    $0x8,%rbx\n  cmp    (%rsp),%rbx\n  jne    L2\nL3:\n  mov    0x8(%rsp),%rax\n  mov    %r12d,(%rax)\n  add    $0x18,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4568
        },
        "L1": {
          "label": "L1",
          "addr": 4525
        },
        "L2": {
          "label": "L2",
          "addr": 4472
        },
        "L3": {
          "label": "L3",
          "addr": 4535
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **argv, int argc, const char *str, int *count) {\n  int i;\n  int c = 0;\n  char **tmp = NULL;\n  for (i = 0; i < argc; i++) {\n    if (strstr(argv[i], str)) {\n      c++;\n      tmp = (char **)realloc(tmp, c * sizeof(char *));\n      tmp[c - 1] = argv[i];\n    }\n  }\n  *count = c;\n  return tmp;\n}"
    },
    {
      "task_id": 6,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     11b8 <func0+0x98>\n  lea    0x1(%rdi),%rbx\n  xor    %r14d,%r14d\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  xor    %eax,%eax\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax)\n  cmp    $0x29,%dl\n  je     1190 <func0+0x70>\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  je     117a <func0+0x5a>\n  cmp    $0x28,%dl\n  jne    1150 <func0+0x30>\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  jne    1160 <func0+0x40>\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\n  sub    $0x1,%ebp\n  jne    1155 <func0+0x35>\n  add    $0x1,%r14d\n  mov    %rax,%rdi\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  call   1050 <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  xor    %r12d,%r12d\n  jmp    1155 <func0+0x35>\n  nopl   (%rax)\n  xor    %r14d,%r14d\n  xor    %eax,%eax\n  jmp    117a <func0+0x5a>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     L0\n  lea    0x1(%rdi),%rbx\n  xor    %r14d,%r14d\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  xor    %eax,%eax\n  jmp    L1\n  nopl   0x0(%rax)\nL4:\n  cmp    $0x29,%dl\n  je     L2\nL5:\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  je     L3\nL1:\n  cmp    $0x28,%dl\n  jne    L4\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  jne    L1\nL3:\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\nL2:\n  sub    $0x1,%ebp\n  jne    L5\n  add    $0x1,%r14d\n  mov    %rax,%rdi\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  call   <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  xor    %r12d,%r12d\n  jmp    L5\n  nopl   (%rax)\nL0:\n  xor    %r14d,%r14d\n  xor    %eax,%eax\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4536
        },
        "L1": {
          "label": "L1",
          "addr": 4448
        },
        "L2": {
          "label": "L2",
          "addr": 4496
        },
        "L3": {
          "label": "L3",
          "addr": 4474
        },
        "L4": {
          "label": "L4",
          "addr": 4432
        },
        "L5": {
          "label": "L5",
          "addr": 4437
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(char *s, int *returnSize) {\n  int *arr = NULL;\n  int arrSize = 0;\n  int max = 0;\n  int level = 0;\n  for (int i = 0; s[i]; i++) {\n    if (s[i] == '(') {\n      level++;\n      if (level > max)\n        max = level;\n    } else if (s[i] == ')') {\n      level--;\n      if (level == 0) {\n        arrSize++;\n        arr = realloc(arr, arrSize * sizeof(int));\n        arr[arrSize - 1] = max;\n        max = 0;\n      }\n    }\n  }\n  *returnSize = arrSize;\n  return arr;\n}"
    },
    {
      "task_id": 6,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     11b8 <func0+0x98>\n  lea    0x1(%rdi),%rbx\n  xor    %r14d,%r14d\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  xor    %eax,%eax\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax)\n  cmp    $0x29,%dl\n  je     1190 <func0+0x70>\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  je     117a <func0+0x5a>\n  cmp    $0x28,%dl\n  jne    1150 <func0+0x30>\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  jne    1160 <func0+0x40>\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\n  sub    $0x1,%ebp\n  jne    1155 <func0+0x35>\n  add    $0x1,%r14d\n  mov    %rax,%rdi\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  call   1050 <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  xor    %r12d,%r12d\n  jmp    1155 <func0+0x35>\n  nopl   (%rax)\n  xor    %r14d,%r14d\n  xor    %eax,%eax\n  jmp    117a <func0+0x5a>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     L0\n  lea    0x1(%rdi),%rbx\n  xor    %r14d,%r14d\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  xor    %eax,%eax\n  jmp    L1\n  nopl   0x0(%rax)\nL4:\n  cmp    $0x29,%dl\n  je     L2\nL5:\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  je     L3\nL1:\n  cmp    $0x28,%dl\n  jne    L4\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  jne    L1\nL3:\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\nL2:\n  sub    $0x1,%ebp\n  jne    L5\n  add    $0x1,%r14d\n  mov    %rax,%rdi\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  call   <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  xor    %r12d,%r12d\n  jmp    L5\n  nopl   (%rax)\nL0:\n  xor    %r14d,%r14d\n  xor    %eax,%eax\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4536
        },
        "L1": {
          "label": "L1",
          "addr": 4448
        },
        "L2": {
          "label": "L2",
          "addr": 4496
        },
        "L3": {
          "label": "L3",
          "addr": 4474
        },
        "L4": {
          "label": "L4",
          "addr": 4432
        },
        "L5": {
          "label": "L5",
          "addr": 4437
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(char *s, int *returnSize) {\n  int *arr = NULL;\n  int arrSize = 0;\n  int max = 0;\n  int level = 0;\n  for (int i = 0; s[i]; i++) {\n    if (s[i] == '(') {\n      level++;\n      if (level > max)\n        max = level;\n    } else if (s[i] == ')') {\n      level--;\n      if (level == 0) {\n        arrSize++;\n        arr = realloc(arr, arrSize * sizeof(int));\n        arr[arrSize - 1] = max;\n        max = 0;\n      }\n    }\n  }\n  *returnSize = arrSize;\n  return arr;\n}"
    },
    {
      "task_id": 7,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdx,(%rsp)\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    11ad <func0+0x74>\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r15\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\n  jmp    1179 <func0+0x40>\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  je     11b8 <func0+0x7f>\n  mov    (%rbx),%r13\n  mov    (%rsp),%rsi\n  mov    %r13,%rdi\n  call   1070 <strstr@plt>\n  test   %rax,%rax\n  je     1170 <func0+0x37>\n  add    $0x1,%r14d\n  movslq %r14d,%r12\n  shl    $0x3,%r12\n  mov    %r12,%rsi\n  mov    %rbp,%rdi\n  call   1060 <realloc@plt>\n  mov    %rax,%rbp\n  mov    %r13,-0x8(%rax,%r12,1)\n  jmp    1170 <func0+0x37>\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\n  mov    0x8(%rsp),%rax\n  mov    %r14d,(%rax)\n  mov    %rbp,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdx,(%rsp)\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r15\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\n  jmp    L1\nL3:\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  je     L2\nL1:\n  mov    (%rbx),%r13\n  mov    (%rsp),%rsi\n  mov    %r13,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L3\n  add    $0x1,%r14d\n  movslq %r14d,%r12\n  shl    $0x3,%r12\n  mov    %r12,%rsi\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  mov    %r13,-0x8(%rax,%r12,1)\n  jmp    L3\nL0:\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\nL2:\n  mov    0x8(%rsp),%rax\n  mov    %r14d,(%rax)\n  mov    %rbp,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4525
        },
        "L1": {
          "label": "L1",
          "addr": 4473
        },
        "L2": {
          "label": "L2",
          "addr": 4536
        },
        "L3": {
          "label": "L3",
          "addr": 4464
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **strings, int n, char *substr, int *nres) {\n  char **results = NULL;\n  int nresults = 0;\n  for (int i = 0; i < n; i++) {\n    char *s = strings[i];\n    if (strstr(s, substr) != NULL) {\n      nresults++;\n      results = realloc(results, nresults * sizeof(char *));\n      results[nresults - 1] = s;\n    }\n  }\n  *nres = nresults;\n  return results;\n}"
    },
    {
      "task_id": 6,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movq   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11e7 <func0+0xce>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x19(%rbp)\n  cmpb   $0x28,-0x19(%rbp)\n  jne    118a <func0+0x71>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    11e3 <func0+0xca>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    11e3 <func0+0xca>\n  cmpb   $0x29,-0x19(%rbp)\n  jne    11e3 <func0+0xca>\n  subl   $0x1,-0x18(%rbp)\n  cmpl   $0x0,-0x18(%rbp)\n  jne    11e3 <func0+0xca>\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1050 <realloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  movl   $0x0,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    115d <func0+0x44>\n  mov    -0x30(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movq   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL3:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x19(%rbp)\n  cmpb   $0x28,-0x19(%rbp)\n  jne    L1\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    L2\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    L2\nL1:\n  cmpb   $0x29,-0x19(%rbp)\n  jne    L2\n  subl   $0x1,-0x18(%rbp)\n  cmpl   $0x0,-0x18(%rbp)\n  jne    L2\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  movl   $0x0,-0x14(%rbp)\nL2:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L3\n  mov    -0x30(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4583
        },
        "L1": {
          "label": "L1",
          "addr": 4490
        },
        "L2": {
          "label": "L2",
          "addr": 4579
        },
        "L3": {
          "label": "L3",
          "addr": 4445
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(char *s, int *returnSize) {\n  int *ret = NULL;\n  int level = 0;\n  int max_level = 0;\n  int i = 0;\n  int j = 0;\n  char c;\n  for (i = 0; s[i] != '\\0'; i++) {\n    c = s[i];\n    if (c == '(') {\n      level++;\n      if (level > max_level)\n        max_level = level;\n    } else if (c == ')') {\n      level--;\n      if (level == 0) {\n        ret = realloc(ret, (j + 1) * sizeof(int));\n        ret[j++] = max_level;\n        max_level = 0;\n      }\n    }\n  }\n  *returnSize = j;\n  return ret;\n}"
    },
    {
      "task_id": 7,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %rcx,-0x30(%rbp)\n  movq   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11f4 <func0+0xbb>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strstr@plt>\n  test   %rax,%rax\n  je     11f0 <func0+0xb7>\n  mov    -0x10(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1060 <realloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     116f <func0+0x36>\n  mov    -0x30(%rbp),%rax\n  mov    -0x10(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %rcx,-0x30(%rbp)\n  movq   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL2:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L1\n  mov    -0x10(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\nL1:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0x30(%rbp),%rax\n  mov    -0x10(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4596
        },
        "L1": {
          "label": "L1",
          "addr": 4592
        },
        "L2": {
          "label": "L2",
          "addr": 4463
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **argv, int argc, const char *s, int *newargc) {\n  char **newargv = NULL;\n  int i, j = 0;\n  for (i = 0; i < argc; i++) {\n    if (strstr(argv[i], s)) {\n      newargv = (char **)realloc(newargv, (j + 1) * sizeof(char *));\n      newargv[j] = argv[i];\n      j++;\n    }\n  }\n  *newargc = j;\n  return newargv;\n}"
    },
    {
      "task_id": 7,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    11d8 <func0+0x98>\n  lea    -0x1(%rsi),%eax\n  mov    %rdx,%r13\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%rax\n  xor    %ebp,%ebp\n  mov    %rax,(%rsp)\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx),%r14\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   1070 <strstr@plt>\n  test   %rax,%rax\n  je     11ad <func0+0x6d>\n  add    $0x1,%r12d\n  mov    %rbp,%rdi\n  movslq %r12d,%rdx\n  lea    0x0(,%rdx,8),%r15\n  mov    %r15,%rsi\n  call   1060 <realloc@plt>\n  mov    %r14,-0x8(%rax,%r15,1)\n  mov    %rax,%rbp\n  add    $0x8,%rbx\n  cmp    (%rsp),%rbx\n  jne    1178 <func0+0x38>\n  mov    0x8(%rsp),%rax\n  mov    %r12d,(%rax)\n  add    $0x18,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  jmp    11b7 <func0+0x77>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdx,%r13\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%rax\n  xor    %ebp,%ebp\n  mov    %rax,(%rsp)\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    (%rbx),%r14\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L1\n  add    $0x1,%r12d\n  mov    %rbp,%rdi\n  movslq %r12d,%rdx\n  lea    0x0(,%rdx,8),%r15\n  mov    %r15,%rsi\n  call   <realloc@plt>\n  mov    %r14,-0x8(%rax,%r15,1)\n  mov    %rax,%rbp\nL1:\n  add    $0x8,%rbx\n  cmp    (%rsp),%rbx\n  jne    L2\nL3:\n  mov    0x8(%rsp),%rax\n  mov    %r12d,(%rax)\n  add    $0x18,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4568
        },
        "L1": {
          "label": "L1",
          "addr": 4525
        },
        "L2": {
          "label": "L2",
          "addr": 4472
        },
        "L3": {
          "label": "L3",
          "addr": 4535
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **strings, int nstrings, char *substr, int *nres) {\n  int i, n = 0;\n  char **res = NULL;\n  for (i = 0; i < nstrings; i++) {\n    char *s = strings[i];\n    if (strstr(s, substr) != NULL) {\n      n++;\n      res = (char **)realloc(res, n * sizeof(char *));\n      res[n - 1] = s;\n    }\n  }\n  *nres = n;\n  return res;\n}"
    },
    {
      "task_id": 6,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rsi,%r13\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     1196 <func0+0x7d>\n  lea    0x1(%rdi),%rbx\n  mov    $0x0,%r14d\n  mov    $0x0,%r12d\n  mov    $0x0,%ebp\n  mov    $0x0,%eax\n  jmp    1167 <func0+0x4e>\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\n  add    $0x1,%rbx\n  movzbl -0x1(%rbx),%edx\n  test   %dl,%dl\n  je     11a1 <func0+0x88>\n  cmp    $0x28,%dl\n  je     1151 <func0+0x38>\n  cmp    $0x29,%dl\n  jne    115b <func0+0x42>\n  sub    $0x1,%ebp\n  jne    115b <func0+0x42>\n  add    $0x1,%r14d\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  call   1050 <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  mov    %ebp,%r12d\n  jmp    115b <func0+0x42>\n  mov    $0x0,%r14d\n  mov    $0x0,%eax\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rsi,%r13\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     L0\n  lea    0x1(%rdi),%rbx\n  mov    $0x0,%r14d\n  mov    $0x0,%r12d\n  mov    $0x0,%ebp\n  mov    $0x0,%eax\n  jmp    L1\nL3:\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\nL4:\n  add    $0x1,%rbx\n  movzbl -0x1(%rbx),%edx\n  test   %dl,%dl\n  je     L2\nL1:\n  cmp    $0x28,%dl\n  je     L3\n  cmp    $0x29,%dl\n  jne    L4\n  sub    $0x1,%ebp\n  jne    L4\n  add    $0x1,%r14d\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  mov    %ebp,%r12d\n  jmp    L4\nL0:\n  mov    $0x0,%r14d\n  mov    $0x0,%eax\nL2:\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4502
        },
        "L1": {
          "label": "L1",
          "addr": 4455
        },
        "L2": {
          "label": "L2",
          "addr": 4513
        },
        "L3": {
          "label": "L3",
          "addr": 4433
        },
        "L4": {
          "label": "L4",
          "addr": 4443
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(char *s, int *sz) {\n  int *r = NULL;\n  int rsz = 0;\n  int lvl = 0;\n  int max_lvl = 0;\n  int i;\n  for (i = 0; s[i]; i++) {\n    switch (s[i]) {\n    case '(':\n      lvl++;\n      if (lvl > max_lvl)\n        max_lvl = lvl;\n      break;\n    case ')':\n      lvl--;\n      if (lvl == 0) {\n        rsz++;\n        r = realloc(r, rsz * sizeof(int));\n        r[rsz - 1] = max_lvl;\n        max_lvl = lvl;\n      }\n      break;\n    }\n  }\n  *sz = rsz;\n  return r;\n}"
    },
    {
      "task_id": 9,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  test   %esi,%esi\n  jle    1166 <func0+0x4d>\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %esi,%ebp\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  test   %rax,%rax\n  je     115f <func0+0x46>\n  mov    (%rbx),%ecx\n  mov    %ebp,%edi\n  mov    $0x0,%edx\n  mov    (%rbx,%rdx,4),%esi\n  cmp    %esi,%ecx\n  cmovl  %esi,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdi,%rdx\n  jne    114b <func0+0x32>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  test   %esi,%esi\n  jle    L0\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %esi,%ebp\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L1\n  mov    (%rbx),%ecx\n  mov    %ebp,%edi\n  mov    $0x0,%edx\nL2:\n  mov    (%rbx,%rdx,4),%esi\n  cmp    %esi,%ecx\n  cmovl  %esi,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdi,%rdx\n  jne    L2\nL1:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4454
        },
        "L1": {
          "label": "L1",
          "addr": 4447
        },
        "L2": {
          "label": "L2",
          "addr": 4427
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *arr, int len) {\n  if (len <= 0)\n    return NULL;\n  int *ret = (int *)malloc(len * sizeof(int));\n  if (ret == NULL)\n    return NULL;\n  int max = arr[0];\n  for (int i = 0; i < len; i++) {\n    if (max < arr[i])\n      max = arr[i];\n    ret[i] = max;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 9,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jg     113c <func0+0x23>\n  mov    $0x0,%eax\n  jmp    11ce <func0+0xb5>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    115f <func0+0x46>\n  mov    $0x0,%eax\n  jmp    11ce <func0+0xb5>\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11c2 <func0+0xa9>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    11a5 <func0+0x8c>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x10(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1171 <func0+0x58>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jg     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L2\n  mov    $0x0,%eax\n  jmp    L1\nL2:\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L3\nL5:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    L4\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\nL4:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x10(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\nL3:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4412
        },
        "L1": {
          "label": "L1",
          "addr": 4558
        },
        "L2": {
          "label": "L2",
          "addr": 4447
        },
        "L3": {
          "label": "L3",
          "addr": 4546
        },
        "L4": {
          "label": "L4",
          "addr": 4517
        },
        "L5": {
          "label": "L5",
          "addr": 4465
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *arr, int len) {\n  if (len <= 0)\n    return NULL;\n  int *ret = (int *)malloc(len * sizeof(int));\n  if (ret == NULL)\n    return NULL;\n  int max = arr[0];\n  for (int i = 0; i < len; i++) {\n    if (arr[i] > max)\n      max = arr[i];\n    ret[i] = max;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 9,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1180 <func0+0x60>\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  test   %rax,%rax\n  je     1174 <func0+0x54>\n  mov    (%rbx),%ecx\n  lea    -0x1(%rbp),%edi\n  xor    %edx,%edx\n  shl    $0x2,%rdi\n  mov    %ecx,%esi\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax,%rax,1)\n  mov    0x4(%rbx,%rdx,1),%esi\n  add    $0x4,%rdx\n  cmp    %esi,%ecx\n  cmovl  %esi,%ecx\n  mov    %ecx,(%rax,%rdx,1)\n  cmp    %rdi,%rdx\n  jne    1158 <func0+0x38>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  add    $0x8,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L1\n  mov    (%rbx),%ecx\n  lea    -0x1(%rbp),%edi\n  xor    %edx,%edx\n  shl    $0x2,%rdi\n  mov    %ecx,%esi\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    0x4(%rbx,%rdx,1),%esi\n  add    $0x4,%rdx\nL2:\n  cmp    %esi,%ecx\n  cmovl  %esi,%ecx\n  mov    %ecx,(%rax,%rdx,1)\n  cmp    %rdi,%rdx\n  jne    L3\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL1:\n  add    $0x8,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4480
        },
        "L1": {
          "label": "L1",
          "addr": 4468
        },
        "L2": {
          "label": "L2",
          "addr": 4448
        },
        "L3": {
          "label": "L3",
          "addr": 4440
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *arr, int n) {\n  if (n <= 0)\n    return NULL;\n  int *ret = (int *)malloc(n * sizeof(int));\n  if (ret == NULL)\n    return NULL;\n  int i;\n  int max = arr[0];\n  for (i = 0; i < n; i++) {\n    if (max < arr[i])\n      max = arr[i];\n    ret[i] = max;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 8,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  mov    %esi,%r8d\n  test   %esi,%esi\n  jle    1200 <func0+0x100>\n  lea    -0x1(%rsi),%eax\n  cmp    $0x15,%eax\n  jbe    120d <func0+0x10d>\n  mov    %esi,%ecx\n  movdqa 0xed8(%rip),%xmm0        # 2000 <_fini+0xde8>\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  shr    $0x2,%ecx\n  sub    $0x1,%ecx\n  shl    $0x4,%rcx\n  lea    0x10(%rdi,%rcx,1),%rcx\n  xchg   %ax,%ax\n  movdqu (%rax),%xmm2\n  movdqa %xmm0,%xmm3\n  psrlq  $0x20,%xmm0\n  add    $0x10,%rax\n  pmuludq %xmm2,%xmm3\n  paddd  %xmm2,%xmm1\n  psrlq  $0x20,%xmm2\n  pmuludq %xmm2,%xmm0\n  pshufd $0x8,%xmm3,%xmm2\n  pshufd $0x8,%xmm0,%xmm3\n  movdqa %xmm2,%xmm0\n  punpckldq %xmm3,%xmm0\n  cmp    %rcx,%rax\n  jne    1140 <func0+0x40>\n  movdqa %xmm0,%xmm2\n  mov    %r8d,%ecx\n  psrldq $0x8,%xmm2\n  and    $0xfffffffc,%ecx\n  movdqa %xmm2,%xmm3\n  psrlq  $0x20,%xmm2\n  pmuludq %xmm0,%xmm3\n  psrlq  $0x20,%xmm0\n  pmuludq %xmm0,%xmm2\n  pshufd $0x8,%xmm3,%xmm3\n  pshufd $0x8,%xmm2,%xmm2\n  punpckldq %xmm2,%xmm3\n  movdqa %xmm3,%xmm0\n  psrldq $0x4,%xmm0\n  pmuludq %xmm3,%xmm0\n  movd   %xmm0,%edi\n  movdqa %xmm1,%xmm0\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%r8b\n  je     11fa <func0+0xfa>\n  movslq %ecx,%rcx\n  nopl   0x0(%rax)\n  mov    (%r9,%rcx,4),%esi\n  add    $0x1,%rcx\n  imul   %esi,%edi\n  add    %esi,%eax\n  cmp    %ecx,%r8d\n  jg     11e8 <func0+0xe8>\n  mov    %eax,(%rdx)\n  mov    %edi,0x4(%rdx)\n  ret\n  mov    $0x1,%edi\n  xor    %eax,%eax\n  mov    %eax,(%rdx)\n  mov    %edi,0x4(%rdx)\n  ret\n  xor    %ecx,%ecx\n  mov    $0x1,%edi\n  xor    %eax,%eax\n  jmp    11e1 <func0+0xe1>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  mov    %esi,%r8d\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cmp    $0x15,%eax\n  jbe    L1\n  mov    %esi,%ecx\n  movdqa D0(%rip),%xmm0\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  shr    $0x2,%ecx\n  sub    $0x1,%ecx\n  shl    $0x4,%rcx\n  lea    0x10(%rdi,%rcx,1),%rcx\n  xchg   %ax,%ax\nL2:\n  movdqu (%rax),%xmm2\n  movdqa %xmm0,%xmm3\n  psrlq  $0x20,%xmm0\n  add    $0x10,%rax\n  pmuludq %xmm2,%xmm3\n  paddd  %xmm2,%xmm1\n  psrlq  $0x20,%xmm2\n  pmuludq %xmm2,%xmm0\n  pshufd $0x8,%xmm3,%xmm2\n  pshufd $0x8,%xmm0,%xmm3\n  movdqa %xmm2,%xmm0\n  punpckldq %xmm3,%xmm0\n  cmp    %rcx,%rax\n  jne    L2\n  movdqa %xmm0,%xmm2\n  mov    %r8d,%ecx\n  psrldq $0x8,%xmm2\n  and    $0xfffffffc,%ecx\n  movdqa %xmm2,%xmm3\n  psrlq  $0x20,%xmm2\n  pmuludq %xmm0,%xmm3\n  psrlq  $0x20,%xmm0\n  pmuludq %xmm0,%xmm2\n  pshufd $0x8,%xmm3,%xmm3\n  pshufd $0x8,%xmm2,%xmm2\n  punpckldq %xmm2,%xmm3\n  movdqa %xmm3,%xmm0\n  psrldq $0x4,%xmm0\n  pmuludq %xmm3,%xmm0\n  movd   %xmm0,%edi\n  movdqa %xmm1,%xmm0\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%r8b\n  je     L3\nL5:\n  movslq %ecx,%rcx\n  nopl   0x0(%rax)\nL4:\n  mov    (%r9,%rcx,4),%esi\n  add    $0x1,%rcx\n  imul   %esi,%edi\n  add    %esi,%eax\n  cmp    %ecx,%r8d\n  jg     L4\nL3:\n  mov    %eax,(%rdx)\n  mov    %edi,0x4(%rdx)\n  ret\nL0:\n  mov    $0x1,%edi\n  xor    %eax,%eax\n  mov    %eax,(%rdx)\n  mov    %edi,0x4(%rdx)\n  ret\nL1:\n  xor    %ecx,%ecx\n  mov    $0x1,%edi\n  xor    %eax,%eax\n  jmp    L5",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3800
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4608
        },
        "L1": {
          "label": "L1",
          "addr": 4621
        },
        "L2": {
          "label": "L2",
          "addr": 4416
        },
        "L3": {
          "label": "L3",
          "addr": 4602
        },
        "L4": {
          "label": "L4",
          "addr": 4584
        },
        "L5": {
          "label": "L5",
          "addr": 4577
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "01000000010000000100000001000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *a, int n, int *rf) {\n  int i;\n  int sum = 0;\n  int prod = 1;\n  for (i = 0; i < n; i++) {\n    sum += a[i];\n    prod *= a[i];\n  }\n  rf[0] = sum;\n  rf[1] = prod;\n}"
    },
    {
      "task_id": 9,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1178 <func0+0x58>\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  movslq %esi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  test   %rax,%rax\n  je     116c <func0+0x4c>\n  mov    0x0(%rbp),%ecx\n  xor    %edx,%edx\n  nopl   0x0(%rax,%rax,1)\n  mov    0x0(%rbp,%rdx,4),%edi\n  cmp    %edi,%ecx\n  cmovl  %edi,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rbx\n  jne    1150 <func0+0x30>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  add    $0x8,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  movslq %esi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L1\n  mov    0x0(%rbp),%ecx\n  xor    %edx,%edx\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    0x0(%rbp,%rdx,4),%edi\n  cmp    %edi,%ecx\n  cmovl  %edi,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rbx\n  jne    L2\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL1:\n  add    $0x8,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4472
        },
        "L1": {
          "label": "L1",
          "addr": 4460
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int *arr, int len) {\n  int *new_arr;\n  int i;\n  if (len <= 0)\n    return NULL;\n  new_arr = malloc(len * sizeof(int));\n  if (new_arr == NULL)\n    return NULL;\n  for (i = 0; i < len; i++) {\n    if (arr[i] > arr[0])\n      new_arr[i] = arr[i];\n    else\n      new_arr[i] = arr[0];\n  }\n  return new_arr;\n}"
    },
    {
      "task_id": 13,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  jmp    111f <func0+0x26>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x18(%rbp)\n  mov    %edx,-0x4(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\n  cmpl   $0x0,-0x18(%rbp)\n  jne    1109 <func0+0x10>\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  jmp    L0\nL1:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x18(%rbp)\n  mov    %edx,-0x4(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\nL0:\n  cmpl   $0x0,-0x18(%rbp)\n  jne    L1\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4383
        },
        "L1": {
          "label": "L1",
          "addr": 4361
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b) {\n  while (b != 0) {\n    int c = a % b;\n    a = b;\n    b = c;\n  }\n  return a;\n}"
    },
    {
      "task_id": 13,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  test   %esi,%esi\n  je     1113 <func0+0x1a>\n  mov    %esi,%ecx\n  cltd\n  idiv   %esi\n  mov    %edx,%esi\n  mov    %ecx,%eax\n  test   %edx,%edx\n  jne    1103 <func0+0xa>\n  mov    %ecx,%eax\n  ret\n  mov    %edi,%ecx\n  jmp    1110 <func0+0x17>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  test   %esi,%esi\n  je     L0\nL1:\n  mov    %esi,%ecx\n  cltd\n  idiv   %esi\n  mov    %edx,%esi\n  mov    %ecx,%eax\n  test   %edx,%edx\n  jne    L1\nL2:\n  mov    %ecx,%eax\n  ret\nL0:\n  mov    %edi,%ecx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4371
        },
        "L1": {
          "label": "L1",
          "addr": 4355
        },
        "L2": {
          "label": "L2",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b) {\n  int c;\n  while (b != 0) {\n    c = a % b;\n    a = b;\n    b = c;\n  }\n  return a;\n}"
    },
    {
      "task_id": 13,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     1128 <func0+0x28>\n  nopl   0x0(%rax)\n  mov    %edx,%r8d\n  cltd\n  idiv   %r8d\n  mov    %r8d,%eax\n  test   %edx,%edx\n  jne    1110 <func0+0x10>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     L0\n  nopl   0x0(%rax)\nL1:\n  mov    %edx,%r8d\n  cltd\n  idiv   %r8d\n  mov    %r8d,%eax\n  test   %edx,%edx\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    %edi,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4392
        },
        "L1": {
          "label": "L1",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b) {\n  while (b != 0) {\n    int c = a % b;\n    a = b;\n    b = c;\n  }\n  return a;\n}"
    },
    {
      "task_id": 13,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     1128 <func0+0x28>\n  nopl   0x0(%rax)\n  mov    %edx,%r8d\n  cltd\n  idiv   %r8d\n  mov    %r8d,%eax\n  test   %edx,%edx\n  jne    1110 <func0+0x10>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     L0\n  nopl   0x0(%rax)\nL1:\n  mov    %edx,%r8d\n  cltd\n  idiv   %r8d\n  mov    %r8d,%eax\n  test   %edx,%edx\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    %edi,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4392
        },
        "L1": {
          "label": "L1",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b) {\n  while (b != 0) {\n    int c = a % b;\n    a = b;\n    b = c;\n  }\n  return a;\n}"
    },
    {
      "task_id": 11,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  call   1060 <strlen@plt>\n  mov    %r12,%rdi\n  mov    %rax,%rbx\n  call   1060 <strlen@plt>\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   1070 <malloc@plt>\n  test   %rax,%rax\n  je     119f <func0+0x5f>\n  movslq %ebx,%rsi\n  xor    %edx,%edx\n  test   %ebx,%ebx\n  jle    119b <func0+0x5b>\n  nopl   0x0(%rax)\n  movzbl (%r12,%rdx,1),%ebx\n  cmp    %bl,0x0(%rbp,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%rax,%rdx,1)\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    1180 <func0+0x40>\n  movb   $0x0,(%rax,%rsi,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  call   <strlen@plt>\n  mov    %r12,%rdi\n  mov    %rax,%rbx\n  call   <strlen@plt>\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L0\n  movslq %ebx,%rsi\n  xor    %edx,%edx\n  test   %ebx,%ebx\n  jle    L1\n  nopl   0x0(%rax)\nL2:\n  movzbl (%r12,%rdx,1),%ebx\n  cmp    %bl,0x0(%rbp,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%rax,%rdx,1)\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    L2\nL1:\n  movb   $0x0,(%rax,%rsi,1)\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4511
        },
        "L1": {
          "label": "L1",
          "addr": 4507
        },
        "L2": {
          "label": "L2",
          "addr": 4480
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *s, const char *t) {\n  int i;\n  int min = strlen(s) < strlen(t) ? strlen(s) : strlen(t);\n  char *res = malloc(min + 1);\n  if (res == NULL)\n    return NULL;\n  for (i = 0; i < min; i++)\n    res[i] = s[i] == t[i] ? '0' : '1';\n  res[min] = '\\0';\n  return res;\n}"
    },
    {
      "task_id": 12,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  lea    0xecd(%rip),%rax        # 2000 <_fini+0xe5c>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    1196 <func0+0x7d>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    1192 <func0+0x79>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1147 <func0+0x2e>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL2:\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    L1\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\nL1:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L2\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3789
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4502
        },
        "L1": {
          "label": "L1",
          "addr": 4498
        },
        "L2": {
          "label": "L2",
          "addr": 4423
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *argv[], int argc) {\n  char *ret = \"\";\n  int i, max = 0, len;\n  for (i = 0; i < argc; i++) {\n    len = strlen(argv[i]);\n    if (len > max) {\n      ret = argv[i];\n      max = len;\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 11,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %eax,-0x14(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    119b <func0+0x62>\n  mov    $0x0,%eax\n  jmp    1203 <func0+0xca>\n  movl   $0x0,-0x18(%rbp)\n  jmp    11e7 <func0+0xae>\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    11cf <func0+0x96>\n  mov    $0x30,%edx\n  jmp    11d4 <func0+0x9b>\n  mov    $0x31,%edx\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     11a4 <func0+0x6b>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x14(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0x18(%rbp)\n  jmp    L2\nL5:\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    L3\n  mov    $0x30,%edx\n  jmp    L4\nL3:\n  mov    $0x31,%edx\nL4:\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  addl   $0x1,-0x18(%rbp)\nL2:\n  mov    -0x18(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L5\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4507
        },
        "L1": {
          "label": "L1",
          "addr": 4611
        },
        "L2": {
          "label": "L2",
          "addr": 4583
        },
        "L3": {
          "label": "L3",
          "addr": 4559
        },
        "L4": {
          "label": "L4",
          "addr": 4564
        },
        "L5": {
          "label": "L5",
          "addr": 4516
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *str0, char *str1) {\n  int len0 = strlen(str0);\n  int len1 = strlen(str1);\n  int len = len0 < len1 ? len0 : len1;\n  char *str = malloc(len + 1);\n  if (str == NULL)\n    return NULL;\n  for (int i = 0; i < len; i++)\n    str[i] = str0[i] == str1[i] ? '0' : '1';\n  str[len] = '\\0';\n  return str;\n}"
    },
    {
      "task_id": 12,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  lea    0xed4(%rip),%r14        # 2000 <_fini+0xe90>\n  test   %esi,%esi\n  jle    1164 <func0+0x4b>\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r13\n  mov    $0x0,%r12d\n  jmp    114c <func0+0x33>\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  je     1164 <func0+0x4b>\n  mov    (%rbx),%rbp\n  mov    %rbp,%rdi\n  call   1050 <strlen@plt>\n  cmp    %r12d,%eax\n  jle    1143 <func0+0x2a>\n  mov    %eax,%r12d\n  mov    %rbp,%r14\n  jmp    1143 <func0+0x2a>\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  lea    D0(%rip),%r14\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r13\n  mov    $0x0,%r12d\n  jmp    L1\nL2:\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  mov    (%rbx),%rbp\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  cmp    %r12d,%eax\n  jle    L2\n  mov    %eax,%r12d\n  mov    %rbp,%r14\n  jmp    L2\nL0:\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3796
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4452
        },
        "L1": {
          "label": "L1",
          "addr": 4428
        },
        "L2": {
          "label": "L2",
          "addr": 4419
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *argv[], int argc) {\n  int i, max, len;\n  char *ret;\n  max = 0;\n  ret = \"\";\n  for (i = 0; i < argc; i++) {\n    len = strlen(argv[i]);\n    if (len > max) {\n      max = len;\n      ret = argv[i];\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 12,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    0xecf(%rip),%r12        # 2000 <_fini+0xe8c>\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    1165 <func0+0x45>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax)\n  mov    (%rbx),%r14\n  mov    %r14,%rdi\n  call   1050 <strlen@plt>\n  cmp    %ebp,%eax\n  jle    115c <func0+0x3c>\n  mov    %eax,%ebp\n  mov    %r14,%r12\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  jne    1148 <func0+0x28>\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    D0(%rip),%r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax)\nL2:\n  mov    (%rbx),%r14\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  cmp    %ebp,%eax\n  jle    L1\n  mov    %eax,%ebp\n  mov    %r14,%r12\nL1:\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  jne    L2\nL0:\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3791
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4453
        },
        "L1": {
          "label": "L1",
          "addr": 4444
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *argv[], int argc) {\n  int i, max = 0;\n  char *res = \"\";\n  for (i = 0; i < argc; i++) {\n    int len = strlen(argv[i]);\n    if (len > max) {\n      max = len;\n      res = argv[i];\n    }\n  }\n  return res;\n}"
    },
    {
      "task_id": 11,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rsi,%rbp\n  call   1060 <strlen@plt>\n  mov    %rax,%r12\n  mov    %rbp,%rdi\n  call   1060 <strlen@plt>\n  cmp    %eax,%r12d\n  cmovg  %eax,%r12d\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   1070 <malloc@plt>\n  test   %rax,%rax\n  je     11a0 <func0+0x67>\n  test   %r12d,%r12d\n  jle    1198 <func0+0x5f>\n  mov    %r12d,%esi\n  mov    $0x0,%edx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%rbx,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%rax,%rdx,1)\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    117d <func0+0x44>\n  movslq %r12d,%r12\n  movb   $0x0,(%rax,%r12,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rsi,%rbp\n  call   <strlen@plt>\n  mov    %rax,%r12\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  cmp    %eax,%r12d\n  cmovg  %eax,%r12d\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L0\n  test   %r12d,%r12d\n  jle    L1\n  mov    %r12d,%esi\n  mov    $0x0,%edx\nL2:\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%rbx,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%rax,%rdx,1)\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    L2\nL1:\n  movslq %r12d,%r12\n  movb   $0x0,(%rax,%r12,1)\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4512
        },
        "L1": {
          "label": "L1",
          "addr": 4504
        },
        "L2": {
          "label": "L2",
          "addr": 4477
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *s, const char *t) {\n  int s_len = strlen(s);\n  int t_len = strlen(t);\n  int min_len = s_len < t_len ? s_len : t_len;\n  char *result = malloc(min_len + 1);\n  if (result == NULL) {\n    return NULL;\n  }\n  int i;\n  for (i = 0; i < min_len; i++) {\n    result[i] = s[i] == t[i] ? '0' : '1';\n  }\n  result[min_len] = '\\0';\n  return result;\n}"
    },
    {
      "task_id": 12,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    0xecf(%rip),%r12        # 2000 <_fini+0xe8c>\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    1165 <func0+0x45>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax)\n  mov    (%rbx),%r14\n  mov    %r14,%rdi\n  call   1050 <strlen@plt>\n  cmp    %ebp,%eax\n  jle    115c <func0+0x3c>\n  mov    %eax,%ebp\n  mov    %r14,%r12\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  jne    1148 <func0+0x28>\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    D0(%rip),%r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax)\nL2:\n  mov    (%rbx),%r14\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  cmp    %ebp,%eax\n  jle    L1\n  mov    %eax,%ebp\n  mov    %r14,%r12\nL1:\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  jne    L2\nL0:\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3791
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4453
        },
        "L1": {
          "label": "L1",
          "addr": 4444
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *argv[], int argc) {\n  int i, max = 0;\n  char *res = \"\";\n  for (i = 0; i < argc; i++) {\n    int len = strlen(argv[i]);\n    if (len > max) {\n      max = len;\n      res = argv[i];\n    }\n  }\n  return res;\n}"
    },
    {
      "task_id": 10,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   1080 <strlen@plt>\n  lea    (%rax,%rax,1),%ebx\n  mov    %rax,%r12\n  mov    %eax,%r15d\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     1260 <func0+0x100>\n  movslq %r12d,%r14\n  test   %r12d,%r12d\n  jle    12c5 <func0+0x165>\n  xor    %ebp,%ebp\n  mov    %r12d,%edx\n  lea    -0x1(%r12),%edi\n  mov    %r13,%rax\n  sub    %ebp,%edx\n  mov    %r12d,%r10d\n  movslq %edi,%rdi\n  mov    %edx,%ecx\n  sar    %ecx\n  je     1210 <func0+0xb0>\n  nopl   0x0(%rax)\n  lea    0x1(%rax),%r9\n  sub    $0x1,%ecx\n  lea    0x0(%r13,%rdi,1),%rdx\n  add    %r9,%rcx\n  jmp    11ed <func0+0x8d>\n  nopl   0x0(%rax)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %rcx,%rax\n  je     1210 <func0+0xb0>\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rax)\n  je     11e0 <func0+0x80>\n  add    $0x1,%ebp\n  cmp    %ebp,%r15d\n  je     1272 <func0+0x112>\n  mov    %r12d,%edx\n  mov    %r9,%rax\n  sub    %ebp,%edx\n  mov    %edx,%ecx\n  sar    %ecx\n  jne    11c8 <func0+0x68>\n  nopl   0x0(%rax,%rax,1)\n  mov    %r8,%rdi\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  call   1070 <strncpy@plt>\n  mov    %rax,%r8\n  test   %ebp,%ebp\n  je     1254 <func0+0xf4>\n  movslq %ebp,%rdx\n  add    %r8,%r14\n  lea    -0x2(%r13,%rdx,1),%rcx\n  lea    -0x1(%r13,%rdx,1),%rax\n  lea    -0x1(%rbp),%edx\n  sub    %rdx,%rcx\n  nopl   0x0(%rax,%rax,1)\n  movzbl (%rax),%edx\n  sub    $0x1,%rax\n  add    $0x1,%r14\n  mov    %dl,-0x1(%r14)\n  cmp    %rcx,%rax\n  jne    1240 <func0+0xe0>\n  lea    0x0(%rbp,%r12,1),%eax\n  cltq\n  movb   $0x0,(%r8,%rax,1)\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %r8,%rdi\n  mov    %r10d,0xc(%rsp)\n  call   1070 <strncpy@plt>\n  mov    0xc(%rsp),%r10d\n  lea    -0x2(%r13,%r14,1),%rsi\n  mov    %rax,%r8\n  lea    -0x1(%r13,%r14,1),%rax\n  lea    -0x1(%r10),%ecx\n  lea    (%r8,%r14,1),%rdx\n  sub    %rcx,%rsi\n  nopw   0x0(%rax,%rax,1)\n  movzbl (%rax),%ecx\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %cl,-0x1(%rdx)\n  cmp    %rax,%rsi\n  jne    12a8 <func0+0x148>\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\n  jmp    1260 <func0+0x100>\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  mov    %rax,%r8\n  jmp    12bb <func0+0x15b>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  lea    (%rax,%rax,1),%ebx\n  mov    %rax,%r12\n  mov    %eax,%r15d\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L0\n  movslq %r12d,%r14\n  test   %r12d,%r12d\n  jle    L1\n  xor    %ebp,%ebp\n  mov    %r12d,%edx\n  lea    -0x1(%r12),%edi\n  mov    %r13,%rax\n  sub    %ebp,%edx\n  mov    %r12d,%r10d\n  movslq %edi,%rdi\n  mov    %edx,%ecx\n  sar    %ecx\n  je     L2\n  nopl   0x0(%rax)\nL6:\n  lea    0x1(%rax),%r9\n  sub    $0x1,%ecx\n  lea    0x0(%r13,%rdi,1),%rdx\n  add    %r9,%rcx\n  jmp    L3\n  nopl   0x0(%rax)\nL4:\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %rcx,%rax\n  je     L2\nL3:\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rax)\n  je     L4\n  add    $0x1,%ebp\n  cmp    %ebp,%r15d\n  je     L5\n  mov    %r12d,%edx\n  mov    %r9,%rax\n  sub    %ebp,%edx\n  mov    %edx,%ecx\n  sar    %ecx\n  jne    L6\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    %r8,%rdi\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  call   <strncpy@plt>\n  mov    %rax,%r8\n  test   %ebp,%ebp\n  je     L7\n  movslq %ebp,%rdx\n  add    %r8,%r14\n  lea    -0x2(%r13,%rdx,1),%rcx\n  lea    -0x1(%r13,%rdx,1),%rax\n  lea    -0x1(%rbp),%edx\n  sub    %rdx,%rcx\n  nopl   0x0(%rax,%rax,1)\nL8:\n  movzbl (%rax),%edx\n  sub    $0x1,%rax\n  add    $0x1,%r14\n  mov    %dl,-0x1(%r14)\n  cmp    %rcx,%rax\n  jne    L8\nL7:\n  lea    0x0(%rbp,%r12,1),%eax\n  cltq\n  movb   $0x0,(%r8,%rax,1)\nL0:\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL5:\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %r8,%rdi\n  mov    %r10d,0xc(%rsp)\n  call   <strncpy@plt>\n  mov    0xc(%rsp),%r10d\n  lea    -0x2(%r13,%r14,1),%rsi\n  mov    %rax,%r8\n  lea    -0x1(%r13,%r14,1),%rax\n  lea    -0x1(%r10),%ecx\n  lea    (%r8,%r14,1),%rdx\n  sub    %rcx,%rsi\n  nopw   0x0(%rax,%rax,1)\nL9:\n  movzbl (%rax),%ecx\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %cl,-0x1(%rdx)\n  cmp    %rax,%rsi\n  jne    L9\nL10:\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\n  jmp    L0\nL1:\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  mov    %rax,%r8\n  jmp    L10",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4704
        },
        "L1": {
          "label": "L1",
          "addr": 4805
        },
        "L2": {
          "label": "L2",
          "addr": 4624
        },
        "L3": {
          "label": "L3",
          "addr": 4589
        },
        "L4": {
          "label": "L4",
          "addr": 4576
        },
        "L5": {
          "label": "L5",
          "addr": 4722
        },
        "L6": {
          "label": "L6",
          "addr": 4552
        },
        "L7": {
          "label": "L7",
          "addr": 4692
        },
        "L8": {
          "label": "L8",
          "addr": 4672
        },
        "L9": {
          "label": "L9",
          "addr": 4776
        },
        "L10": {
          "label": "L10",
          "addr": 4795
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *src) {\n  char *ret;\n  int len, i, j;\n  len = strlen(src);\n  ret = malloc(len * 2 + 1);\n  if (ret == NULL)\n    return NULL;\n  for (i = 0; i < len; i++) {\n    for (j = 0; j < len - i; j++) {\n      if (src[j] != src[len - 1 - j])\n        break;\n    }\n    if (j == len - i)\n      break;\n  }\n  strncpy(ret, src, len);\n  for (j = 0; j < i; j++)\n    ret[len + j] = src[i - 1 - j];\n  ret[len * 2] = '\\0';\n  return ret;\n}"
    },
    {
      "task_id": 10,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   1080 <strlen@plt>\n  lea    (%rax,%rax,1),%ebx\n  mov    %rax,%r12\n  mov    %eax,%r15d\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     1260 <func0+0x100>\n  movslq %r12d,%r14\n  test   %r12d,%r12d\n  jle    12c5 <func0+0x165>\n  xor    %ebp,%ebp\n  mov    %r12d,%edx\n  lea    -0x1(%r12),%edi\n  mov    %r13,%rax\n  sub    %ebp,%edx\n  mov    %r12d,%r10d\n  movslq %edi,%rdi\n  mov    %edx,%ecx\n  sar    %ecx\n  je     1210 <func0+0xb0>\n  nopl   0x0(%rax)\n  lea    0x1(%rax),%r9\n  sub    $0x1,%ecx\n  lea    0x0(%r13,%rdi,1),%rdx\n  add    %r9,%rcx\n  jmp    11ed <func0+0x8d>\n  nopl   0x0(%rax)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %rcx,%rax\n  je     1210 <func0+0xb0>\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rax)\n  je     11e0 <func0+0x80>\n  add    $0x1,%ebp\n  cmp    %ebp,%r15d\n  je     1272 <func0+0x112>\n  mov    %r12d,%edx\n  mov    %r9,%rax\n  sub    %ebp,%edx\n  mov    %edx,%ecx\n  sar    %ecx\n  jne    11c8 <func0+0x68>\n  nopl   0x0(%rax,%rax,1)\n  mov    %r8,%rdi\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  call   1070 <strncpy@plt>\n  mov    %rax,%r8\n  test   %ebp,%ebp\n  je     1254 <func0+0xf4>\n  movslq %ebp,%rdx\n  add    %r8,%r14\n  lea    -0x2(%r13,%rdx,1),%rcx\n  lea    -0x1(%r13,%rdx,1),%rax\n  lea    -0x1(%rbp),%edx\n  sub    %rdx,%rcx\n  nopl   0x0(%rax,%rax,1)\n  movzbl (%rax),%edx\n  sub    $0x1,%rax\n  add    $0x1,%r14\n  mov    %dl,-0x1(%r14)\n  cmp    %rax,%rcx\n  jne    1240 <func0+0xe0>\n  lea    0x0(%rbp,%r12,1),%eax\n  cltq\n  movb   $0x0,(%r8,%rax,1)\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %r8,%rdi\n  mov    %r10d,0xc(%rsp)\n  call   1070 <strncpy@plt>\n  mov    0xc(%rsp),%r10d\n  lea    -0x2(%r13,%r14,1),%rsi\n  mov    %rax,%r8\n  lea    -0x1(%r13,%r14,1),%rax\n  lea    -0x1(%r10),%ecx\n  lea    (%r8,%r14,1),%rdx\n  sub    %rcx,%rsi\n  nopw   0x0(%rax,%rax,1)\n  movzbl (%rax),%ecx\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %cl,-0x1(%rdx)\n  cmp    %rax,%rsi\n  jne    12a8 <func0+0x148>\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\n  jmp    1260 <func0+0x100>\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  mov    %rax,%r8\n  jmp    12bb <func0+0x15b>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  lea    (%rax,%rax,1),%ebx\n  mov    %rax,%r12\n  mov    %eax,%r15d\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L0\n  movslq %r12d,%r14\n  test   %r12d,%r12d\n  jle    L1\n  xor    %ebp,%ebp\n  mov    %r12d,%edx\n  lea    -0x1(%r12),%edi\n  mov    %r13,%rax\n  sub    %ebp,%edx\n  mov    %r12d,%r10d\n  movslq %edi,%rdi\n  mov    %edx,%ecx\n  sar    %ecx\n  je     L2\n  nopl   0x0(%rax)\nL6:\n  lea    0x1(%rax),%r9\n  sub    $0x1,%ecx\n  lea    0x0(%r13,%rdi,1),%rdx\n  add    %r9,%rcx\n  jmp    L3\n  nopl   0x0(%rax)\nL4:\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %rcx,%rax\n  je     L2\nL3:\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rax)\n  je     L4\n  add    $0x1,%ebp\n  cmp    %ebp,%r15d\n  je     L5\n  mov    %r12d,%edx\n  mov    %r9,%rax\n  sub    %ebp,%edx\n  mov    %edx,%ecx\n  sar    %ecx\n  jne    L6\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    %r8,%rdi\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  call   <strncpy@plt>\n  mov    %rax,%r8\n  test   %ebp,%ebp\n  je     L7\n  movslq %ebp,%rdx\n  add    %r8,%r14\n  lea    -0x2(%r13,%rdx,1),%rcx\n  lea    -0x1(%r13,%rdx,1),%rax\n  lea    -0x1(%rbp),%edx\n  sub    %rdx,%rcx\n  nopl   0x0(%rax,%rax,1)\nL8:\n  movzbl (%rax),%edx\n  sub    $0x1,%rax\n  add    $0x1,%r14\n  mov    %dl,-0x1(%r14)\n  cmp    %rax,%rcx\n  jne    L8\nL7:\n  lea    0x0(%rbp,%r12,1),%eax\n  cltq\n  movb   $0x0,(%r8,%rax,1)\nL0:\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL5:\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %r8,%rdi\n  mov    %r10d,0xc(%rsp)\n  call   <strncpy@plt>\n  mov    0xc(%rsp),%r10d\n  lea    -0x2(%r13,%r14,1),%rsi\n  mov    %rax,%r8\n  lea    -0x1(%r13,%r14,1),%rax\n  lea    -0x1(%r10),%ecx\n  lea    (%r8,%r14,1),%rdx\n  sub    %rcx,%rsi\n  nopw   0x0(%rax,%rax,1)\nL9:\n  movzbl (%rax),%ecx\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %cl,-0x1(%rdx)\n  cmp    %rax,%rsi\n  jne    L9\nL10:\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\n  jmp    L0\nL1:\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  mov    %rax,%r8\n  jmp    L10",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4704
        },
        "L1": {
          "label": "L1",
          "addr": 4805
        },
        "L2": {
          "label": "L2",
          "addr": 4624
        },
        "L3": {
          "label": "L3",
          "addr": 4589
        },
        "L4": {
          "label": "L4",
          "addr": 4576
        },
        "L5": {
          "label": "L5",
          "addr": 4722
        },
        "L6": {
          "label": "L6",
          "addr": 4552
        },
        "L7": {
          "label": "L7",
          "addr": 4692
        },
        "L8": {
          "label": "L8",
          "addr": 4672
        },
        "L9": {
          "label": "L9",
          "addr": 4776
        },
        "L10": {
          "label": "L10",
          "addr": 4795
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *src) {\n  int len = strlen(src);\n  char *dst = malloc(len * 2 + 1);\n  if (dst == NULL)\n    return NULL;\n  int i = 0, j = 0;\n  for (; i < len; i++) {\n    for (j = 0; j < len - i; j++) {\n      if (src[j] != src[len - 1 - j])\n        break;\n    }\n    if (j == len - i)\n      break;\n  }\n  strncpy(dst, src, len);\n  for (; i > 0; i--)\n    dst[len + i] = src[i - 1];\n  dst[len * 2] = '\\0';\n  return dst;\n}"
    },
    {
      "task_id": 11,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  call   1060 <strlen@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%rbx\n  call   1060 <strlen@plt>\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     13c8 <func0+0x288>\n  test   %ebx,%ebx\n  jle    13c0 <func0+0x280>\n  lea    -0x1(%rbx),%eax\n  cmp    $0xe,%eax\n  jbe    13d0 <func0+0x290>\n  mov    %ebx,%edx\n  movdqa 0xe68(%rip),%xmm3        # 2000 <_fini+0xc28>\n  movdqa 0xe70(%rip),%xmm2        # 2010 <_fini+0xc38>\n  xor    %eax,%eax\n  shr    $0x4,%edx\n  shl    $0x4,%rdx\n  nopl   0x0(%rax)\n  movdqu (%r12,%rax,1),%xmm0\n  movdqu 0x0(%rbp,%rax,1),%xmm4\n  movdqa %xmm3,%xmm1\n  pcmpeqb %xmm4,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm2,%xmm0\n  por    %xmm1,%xmm0\n  movups %xmm0,(%r8,%rax,1)\n  add    $0x10,%rax\n  cmp    %rdx,%rax\n  jne    11b0 <func0+0x70>\n  mov    %ebx,%eax\n  and    $0xfffffff0,%eax\n  test   $0xf,%bl\n  je     13c0 <func0+0x280>\n  movslq %eax,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl (%r12,%rdx,1),%esi\n  cmp    %sil,0x0(%rbp,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x2(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x3(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x4(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x5(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x6(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x7(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x8(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x9(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xa(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xb(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xc(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xd(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0xe,%eax\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  cmp    %eax,%ebx\n  jle    13c0 <func0+0x280>\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%esi\n  cmp    %sil,(%r12,%rax,1)\n  setne  %dl\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rax,1)\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\n  pop    %rbx\n  mov    %r8,%rax\n  pop    %rbp\n  pop    %r12\n  ret\n  xor    %eax,%eax\n  jmp    11ec <func0+0xac>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  call   <strlen@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%rbx\n  call   <strlen@plt>\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L0\n  test   %ebx,%ebx\n  jle    L1\n  lea    -0x1(%rbx),%eax\n  cmp    $0xe,%eax\n  jbe    L2\n  mov    %ebx,%edx\n  movdqa D0(%rip),%xmm3\n  movdqa D1(%rip),%xmm2\n  xor    %eax,%eax\n  shr    $0x4,%edx\n  shl    $0x4,%rdx\n  nopl   0x0(%rax)\nL3:\n  movdqu (%r12,%rax,1),%xmm0\n  movdqu 0x0(%rbp,%rax,1),%xmm4\n  movdqa %xmm3,%xmm1\n  pcmpeqb %xmm4,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm2,%xmm0\n  por    %xmm1,%xmm0\n  movups %xmm0,(%r8,%rax,1)\n  add    $0x10,%rax\n  cmp    %rdx,%rax\n  jne    L3\n  mov    %ebx,%eax\n  and    $0xfffffff0,%eax\n  test   $0xf,%bl\n  je     L1\nL4:\n  movslq %eax,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl (%r12,%rdx,1),%esi\n  cmp    %sil,0x0(%rbp,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x2(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x3(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x4(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x5(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x6(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x7(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x8(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x9(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xa(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xb(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xc(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xd(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0xe,%eax\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  cmp    %eax,%ebx\n  jle    L1\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%esi\n  cmp    %sil,(%r12,%rax,1)\n  setne  %dl\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rax,1)\nL1:\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\nL0:\n  pop    %rbx\n  mov    %r8,%rax\n  pop    %rbp\n  pop    %r12\n  ret\nL2:\n  xor    %eax,%eax\n  jmp    L4",
      "num_missing": 2,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3688
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3696
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5064
        },
        "L1": {
          "label": "L1",
          "addr": 5056
        },
        "L2": {
          "label": "L2",
          "addr": 5072
        },
        "L3": {
          "label": "L3",
          "addr": 4528
        },
        "L4": {
          "label": "L4",
          "addr": 4588
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "3030303030303030303030303030303031313131313131313131313131313131",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              48,
              48,
              48,
              48,
              48,
              48,
              48,
              48,
              48,
              48,
              48,
              48,
              48,
              48,
              48,
              48
            ]
          },
          "0x2010": {
            "type": "byte[16]",
            "value": [
              49,
              49,
              49,
              49,
              49,
              49,
              49,
              49,
              49,
              49,
              49,
              49,
              49,
              49,
              49,
              49
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s1, char *s2) {\n  int i;\n  int len1 = strlen(s1);\n  int len2 = strlen(s2);\n  int min = len1 < len2 ? len1 : len2;\n  char *s = malloc(min + 1);\n  if (s == NULL)\n    return NULL;\n  for (i = 0; i < min; i++)\n    s[i] = s1[i] == s2[i] ? '0' : '1';\n  s[i] = '\\0';\n  return s;\n}"
    },
    {
      "task_id": 10,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    119f <func0+0x46>\n  mov    $0x0,%eax\n  jmp    1302 <func0+0x1a9>\n  movl   $0x0,-0x18(%rbp)\n  jmp    1288 <func0+0x12f>\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11f7 <func0+0x9e>\n  mov    -0x18(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     11f3 <func0+0x9a>\n  movl   $0x0,-0x10(%rbp)\n  jmp    120b <func0+0xb2>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0xc(%rbp),%eax\n  sub    -0x18(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x14(%rbp)\n  jl     11bb <func0+0x62>\n  cmpl   $0x0,-0x10(%rbp)\n  je     1284 <func0+0x12b>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  movl   $0x0,-0x14(%rbp)\n  jmp    1261 <func0+0x108>\n  mov    -0x18(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%ecx\n  mov    -0x14(%rbp),%edx\n  add    %ecx,%edx\n  movslq %edx,%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     1233 <func0+0xda>\n  mov    -0xc(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  jmp    1302 <func0+0x1a9>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     11ab <func0+0x52>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  movl   $0x0,-0x14(%rbp)\n  jmp    12e4 <func0+0x18b>\n  mov    -0xc(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%ecx\n  mov    -0x14(%rbp),%edx\n  add    %ecx,%edx\n  movslq %edx,%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     12b6 <func0+0x15d>\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0x18(%rbp)\n  jmp    L2\nL10:\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L3\nL6:\n  mov    -0x18(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     L4\n  movl   $0x0,-0x10(%rbp)\n  jmp    L5\nL4:\n  addl   $0x1,-0x14(%rbp)\nL3:\n  mov    -0xc(%rbp),%eax\n  sub    -0x18(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x14(%rbp)\n  jl     L6\nL5:\n  cmpl   $0x0,-0x10(%rbp)\n  je     L7\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  movl   $0x0,-0x14(%rbp)\n  jmp    L8\nL9:\n  mov    -0x18(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%ecx\n  mov    -0x14(%rbp),%edx\n  add    %ecx,%edx\n  movslq %edx,%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x14(%rbp)\nL8:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     L9\n  mov    -0xc(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  jmp    L1\nL7:\n  addl   $0x1,-0x18(%rbp)\nL2:\n  mov    -0x18(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L10\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  movl   $0x0,-0x14(%rbp)\n  jmp    L11\nL12:\n  mov    -0xc(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%ecx\n  mov    -0x14(%rbp),%edx\n  add    %ecx,%edx\n  movslq %edx,%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x14(%rbp)\nL11:\n  mov    -0x14(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L12\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4511
        },
        "L1": {
          "label": "L1",
          "addr": 4866
        },
        "L2": {
          "label": "L2",
          "addr": 4744
        },
        "L3": {
          "label": "L3",
          "addr": 4599
        },
        "L4": {
          "label": "L4",
          "addr": 4595
        },
        "L5": {
          "label": "L5",
          "addr": 4619
        },
        "L6": {
          "label": "L6",
          "addr": 4539
        },
        "L7": {
          "label": "L7",
          "addr": 4740
        },
        "L8": {
          "label": "L8",
          "addr": 4705
        },
        "L9": {
          "label": "L9",
          "addr": 4659
        },
        "L10": {
          "label": "L10",
          "addr": 4523
        },
        "L11": {
          "label": "L11",
          "addr": 4836
        },
        "L12": {
          "label": "L12",
          "addr": 4790
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s) {\n  int len = strlen(s);\n  char *buf = malloc(len * 2 + 1);\n  if (!buf)\n    return NULL;\n  for (int i = 0; i < len; i++) {\n    int ok = 1;\n    for (int j = 0; j < (len - i) / 2; j++) {\n      if (s[i + j] != s[len - 1 - j]) {\n        ok = 0;\n        break;\n      }\n    }\n    if (ok) {\n      strncpy(buf, s, len);\n      for (int j = 0; j < i; j++)\n        buf[len + j] = s[i - 1 - j];\n      buf[len + i] = 0;\n      return buf;\n    }\n  }\n  strncpy(buf, s, len);\n  for (int j = 0; j < len; j++)\n    buf[len + j] = s[len - 1 - j];\n  buf[len * 2] = 0;\n  return buf;\n}"
    },
    {
      "task_id": 10,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%rbp\n  call   1080 <strlen@plt>\n  mov    %rax,%r14\n  mov    %eax,%r13d\n  lea    (%rax,%rax,1),%eax\n  mov    %eax,0xc(%rsp)\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r15\n  test   %rax,%rax\n  je     1209 <func0+0xb0>\n  test   %r14d,%r14d\n  jle    11b8 <func0+0x5f>\n  mov    %r14d,%r8d\n  lea    -0x1(%r14),%r12d\n  mov    %rbp,%rsi\n  mov    $0x0,%ebx\n  movslq %r14d,%rdi\n  sub    $0x1,%rdi\n  jmp    1227 <func0+0xce>\n  mov    %r12d,%ebx\n  jmp    125e <func0+0x105>\n  movslq %r14d,%rdx\n  mov    %rbp,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  jmp    11ff <func0+0xa6>\n  movslq %ebx,%rbx\n  mov    %rbx,%rdx\n  mov    %rbp,%rsi\n  mov    %r15,%rdi\n  call   1070 <strncpy@plt>\n  lea    -0x1(%rbp,%rbx,1),%rax\n  lea    (%r15,%rbx,1),%rdx\n  lea    -0x2(%rbp,%rbx,1),%rsi\n  mov    %r12d,%r12d\n  sub    %r12,%rsi\n  movzbl (%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    11ed <func0+0x94>\n  movslq 0xc(%rsp),%rax\n  movb   $0x0,(%r15,%rax,1)\n  mov    %r15,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  add    $0x1,%ebx\n  add    $0x1,%rsi\n  cmp    %ebx,%r13d\n  je     11c8 <func0+0x6f>\n  mov    %r8d,%eax\n  sub    %ebx,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    %r12d,%ebx\n  je     11b0 <func0+0x57>\n  lea    0x0(%rbp,%rdi,1),%rdx\n  mov    $0x0,%eax\n  movzbl (%rdx),%r9d\n  cmp    %r9b,(%rsi,%rax,1)\n  jne    121b <func0+0xc2>\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     1248 <func0+0xef>\n  movslq %r14d,%r12\n  mov    %r12,%rdx\n  mov    %rbp,%rsi\n  mov    %r15,%rdi\n  call   1070 <strncpy@plt>\n  test   %ebx,%ebx\n  jle    129c <func0+0x143>\n  movslq %ebx,%rcx\n  lea    -0x1(%rbp,%rcx,1),%rax\n  lea    (%r15,%r12,1),%rdx\n  lea    -0x2(%rbp,%rcx,1),%rsi\n  lea    -0x1(%rbx),%ecx\n  sub    %rcx,%rsi\n  movzbl (%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    128a <func0+0x131>\n  lea    (%rbx,%r14,1),%eax\n  cltq\n  movb   $0x0,(%r15,%rax,1)\n  jmp    1209 <func0+0xb0>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%rbp\n  call   <strlen@plt>\n  mov    %rax,%r14\n  mov    %eax,%r13d\n  lea    (%rax,%rax,1),%eax\n  mov    %eax,0xc(%rsp)\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r15\n  test   %rax,%rax\n  je     L0\n  test   %r14d,%r14d\n  jle    L1\n  mov    %r14d,%r8d\n  lea    -0x1(%r14),%r12d\n  mov    %rbp,%rsi\n  mov    $0x0,%ebx\n  movslq %r14d,%rdi\n  sub    $0x1,%rdi\n  jmp    L2\nL7:\n  mov    %r12d,%ebx\n  jmp    L3\nL1:\n  movslq %r14d,%rdx\n  mov    %rbp,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  jmp    L4\nL6:\n  movslq %ebx,%rbx\n  mov    %rbx,%rdx\n  mov    %rbp,%rsi\n  mov    %r15,%rdi\n  call   <strncpy@plt>\n  lea    -0x1(%rbp,%rbx,1),%rax\n  lea    (%r15,%rbx,1),%rdx\n  lea    -0x2(%rbp,%rbx,1),%rsi\n  mov    %r12d,%r12d\n  sub    %r12,%rsi\nL5:\n  movzbl (%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    L5\nL4:\n  movslq 0xc(%rsp),%rax\n  movb   $0x0,(%r15,%rax,1)\nL0:\n  mov    %r15,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  add    $0x1,%ebx\n  add    $0x1,%rsi\n  cmp    %ebx,%r13d\n  je     L6\nL2:\n  mov    %r8d,%eax\n  sub    %ebx,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    %r12d,%ebx\n  je     L7\n  lea    0x0(%rbp,%rdi,1),%rdx\n  mov    $0x0,%eax\nL9:\n  movzbl (%rdx),%r9d\n  cmp    %r9b,(%rsi,%rax,1)\n  jne    L8\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     L9\nL3:\n  movslq %r14d,%r12\n  mov    %r12,%rdx\n  mov    %rbp,%rsi\n  mov    %r15,%rdi\n  call   <strncpy@plt>\n  test   %ebx,%ebx\n  jle    L10\n  movslq %ebx,%rcx\n  lea    -0x1(%rbp,%rcx,1),%rax\n  lea    (%r15,%r12,1),%rdx\n  lea    -0x2(%rbp,%rcx,1),%rsi\n  lea    -0x1(%rbx),%ecx\n  sub    %rcx,%rsi\nL11:\n  movzbl (%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    L11\nL10:\n  lea    (%rbx,%r14,1),%eax\n  cltq\n  movb   $0x0,(%r15,%rax,1)\n  jmp    L0",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4617
        },
        "L1": {
          "label": "L1",
          "addr": 4536
        },
        "L2": {
          "label": "L2",
          "addr": 4647
        },
        "L3": {
          "label": "L3",
          "addr": 4702
        },
        "L4": {
          "label": "L4",
          "addr": 4607
        },
        "L5": {
          "label": "L5",
          "addr": 4589
        },
        "L6": {
          "label": "L6",
          "addr": 4552
        },
        "L7": {
          "label": "L7",
          "addr": 4528
        },
        "L8": {
          "label": "L8",
          "addr": 4635
        },
        "L9": {
          "label": "L9",
          "addr": 4680
        },
        "L10": {
          "label": "L10",
          "addr": 4764
        },
        "L11": {
          "label": "L11",
          "addr": 4746
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s) {\n  int len = (int)strlen(s);\n  int i, j, k;\n  char *p;\n  p = (char *)malloc(len * 2 + 1);\n  if (p == NULL)\n    return NULL;\n  for (i = 0; i < len; i++) {\n    for (j = 0; j < (len - i) / 2; j++) {\n      if (s[i + j] != s[len - 1 - j])\n        break;\n    }\n    if (j == (len - i) / 2) {\n      strncpy(p, s, len);\n      for (k = 0; k < i; k++)\n        p[len + k] = s[len - 1 - k];\n      p[len + i] = '\\0';\n      return p;\n    }\n  }\n  strncpy(p, s, len);\n  for (k = 0; k < i; k++)\n    p[len + k] = s[len - 1 - k];\n  p[len * 2] = '\\0';\n  return p;\n}"
    },
    {
      "task_id": 14,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r14\n  mov    %rsi,(%rsp)\n  call   10b0 <strlen@plt>\n  mov    %rax,%r15\n  mov    %rax,0x8(%rsp)\n  movslq %eax,%rdi\n  shl    $0x3,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%r13\n  lea    0x1(%r15),%edi\n  movslq %edi,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%rbx\n  movb   $0x0,(%rax)\n  test   %r15d,%r15d\n  jle    1243 <func0+0xaa>\n  lea    -0x1(%r15),%r15d\n  mov    $0x0,%r12d\n  mov    %rbx,%rdi\n  call   10b0 <strlen@plt>\n  mov    %rax,%rbp\n  lea    0x2(%rax),%rsi\n  mov    %rbx,%rdi\n  call   10d0 <realloc@plt>\n  mov    %rax,%rbx\n  movzbl (%r14,%r12,1),%eax\n  mov    %al,(%rbx,%rbp,1)\n  movb   $0x0,0x1(%rbx,%rbp,1)\n  mov    %rbx,%rdi\n  call   10b0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13,%r12,8)\n  mov    %rbx,%rsi\n  call   10a0 <strcpy@plt>\n  mov    %r12,%rax\n  add    $0x1,%r12\n  cmp    %r15,%rax\n  jne    11ef <func0+0x56>\n  mov    %rbx,%rdi\n  call   1090 <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%edx\n  mov    %edx,(%rax)\n  mov    %r13,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r14\n  mov    %rsi,(%rsp)\n  call   <strlen@plt>\n  mov    %rax,%r15\n  mov    %rax,0x8(%rsp)\n  movslq %eax,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  lea    0x1(%r15),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbx\n  movb   $0x0,(%rax)\n  test   %r15d,%r15d\n  jle    L0\n  lea    -0x1(%r15),%r15d\n  mov    $0x0,%r12d\nL1:\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  lea    0x2(%rax),%rsi\n  mov    %rbx,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbx\n  movzbl (%r14,%r12,1),%eax\n  mov    %al,(%rbx,%rbp,1)\n  movb   $0x0,0x1(%rbx,%rbp,1)\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13,%r12,8)\n  mov    %rbx,%rsi\n  call   <strcpy@plt>\n  mov    %r12,%rax\n  add    $0x1,%r12\n  cmp    %r15,%rax\n  jne    L1\nL0:\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%edx\n  mov    %edx,(%rax)\n  mov    %r13,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4675
        },
        "L1": {
          "label": "L1",
          "addr": 4591
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char *str, int *len) {\n  int i;\n  size_t l = strlen(str);\n  char **res = malloc(l * sizeof(char *));\n  char *tmp = malloc(l + 1);\n  tmp[0] = '\\0';\n  for (i = 0; i < l; i++) {\n    size_t tmpl = strlen(tmp);\n    tmp = realloc(tmp, tmpl + 2);\n    tmp[tmpl] = str[i];\n    tmp[tmpl + 1] = '\\0';\n    res[i] = malloc(strlen(tmp) + 1);\n    strcpy(res[i], tmp);\n  }\n  free(tmp);\n  *len = l;\n  return res;\n}"
    },
    {
      "task_id": 14,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x2c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0x30(%rbp)\n  jmp    12ae <func0+0x115>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  lea    0x2(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10d0 <realloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x28(%rbp),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x18(%rbp),%rax\n  lea    0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  add    $0x1,%rax\n  mov    -0x30(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  lea    (%rcx,%rdx,1),%rbx\n  mov    %rax,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10a0 <strcpy@plt>\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     11f9 <func0+0x60>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x2c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0x30(%rbp)\n  jmp    L0\nL1:\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  lea    0x2(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x28(%rbp),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x18(%rbp),%rax\n  lea    0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  add    $0x1,%rax\n  mov    -0x30(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  lea    (%rcx,%rdx,1),%rbx\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  addl   $0x1,-0x30(%rbp)\nL0:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L1\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4782
        },
        "L1": {
          "label": "L1",
          "addr": 4601
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char *str, int *len) {\n  int i, j, k;\n  int n = strlen(str);\n  char **res = (char **)malloc(n * sizeof(char *));\n  char *tmp = (char *)malloc(n + 1);\n  tmp[0] = '\\0';\n  for (i = 0; i < n; i++) {\n    j = strlen(tmp);\n    tmp = (char *)realloc(tmp, j + 2);\n    tmp[j] = str[i];\n    tmp[j + 1] = '\\0';\n    res[i] = (char *)malloc(strlen(tmp) + 1);\n    strcpy(res[i], tmp);\n  }\n  free(tmp);\n  *len = n;\n  return res;\n}"
    },
    {
      "task_id": 16,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    $0x80,%ecx\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  movzbl 0x0(%rbp),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  test   %bl,%bl\n  je     1210 <func0+0xb0>\n  call   1080 <__ctype_tolower_loc@plt>\n  add    $0x1,%rbp\n  xor    %r12d,%r12d\n  mov    (%rax),%r14\n  nopl   0x0(%rax,%rax,1)\n  mov    (%r14,%rbx,4),%ebx\n  movsbq %bl,%r13\n  mov    (%rsp,%r13,4),%eax\n  test   %eax,%eax\n  jne    11de <func0+0x7e>\n  call   1090 <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     11de <func0+0x7e>\n  movl   $0x1,(%rsp,%r13,4)\n  add    $0x1,%r12d\n  movzbl 0x0(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  jne    11b0 <func0+0x50>\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1215 <func0+0xb5>\n  add    $0x410,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r12d,%r12d\n  jmp    11ea <func0+0x8a>\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    $0x80,%ecx\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  movzbl 0x0(%rbp),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  test   %bl,%bl\n  je     L0\n  call   <__ctype_tolower_loc@plt>\n  add    $0x1,%rbp\n  xor    %r12d,%r12d\n  mov    (%rax),%r14\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    (%r14,%rbx,4),%ebx\n  movsbq %bl,%r13\n  mov    (%rsp,%r13,4),%eax\n  test   %eax,%eax\n  jne    L1\n  call   <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     L1\n  movl   $0x1,(%rsp,%r13,4)\n  add    $0x1,%r12d\nL1:\n  movzbl 0x0(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  jne    L2\nL4:\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  add    $0x410,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  xor    %r12d,%r12d\n  jmp    L4\nL3:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4624
        },
        "L1": {
          "label": "L1",
          "addr": 4574
        },
        "L2": {
          "label": "L2",
          "addr": 4528
        },
        "L3": {
          "label": "L3",
          "addr": 4629
        },
        "L4": {
          "label": "L4",
          "addr": 4586
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(const char *s) {\n  int i = 0;\n  int j = 0;\n  char c;\n  int a[256] = {0};\n  while (c = *s++) {\n    c = (*__ctype_tolower_loc(a) + 1)[c];\n    if (a[c] == 0 && ((*__ctype_b_loc(a) + 1)[c] & 0x04)) {\n      a[c] = 1;\n      j++;\n    }\n  }\n  return j;\n}"
    },
    {
      "task_id": 14,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   10a0 <strlen@plt>\n  movslq %eax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x8(%rsp)\n  shl    $0x3,%rdi\n  call   10c0 <malloc@plt>\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r12\n  call   10c0 <malloc@plt>\n  movb   $0x0,(%rax)\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    124b <func0+0xab>\n  lea    -0x1(%rbx),%r13d\n  xor    %ebx,%ebx\n  mov    %r15,%rdi\n  call   10a0 <strlen@plt>\n  mov    %r15,%rdi\n  lea    0x2(%rax),%rsi\n  mov    %rax,%r14\n  call   10d0 <realloc@plt>\n  mov    %rax,%r15\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movb   $0x0,0x1(%r15,%r14,1)\n  mov    %r15,%rdi\n  mov    %al,(%r15,%r14,1)\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%r14\n  mov    %r14,%rdi\n  call   10c0 <malloc@plt>\n  mov    %r14,%rdx\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  mov    %rax,(%r12,%rbx,8)\n  call   10b0 <memcpy@plt>\n  mov    %rbx,%rax\n  add    $0x1,%rbx\n  cmp    %r13,%rax\n  jne    11f0 <func0+0x50>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   <strlen@plt>\n  movslq %eax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x8(%rsp)\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r12\n  call   <malloc@plt>\n  movb   $0x0,(%rax)\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    L0\n  lea    -0x1(%rbx),%r13d\n  xor    %ebx,%ebx\nL1:\n  mov    %r15,%rdi\n  call   <strlen@plt>\n  mov    %r15,%rdi\n  lea    0x2(%rax),%rsi\n  mov    %rax,%r14\n  call   <realloc@plt>\n  mov    %rax,%r15\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movb   $0x0,0x1(%r15,%r14,1)\n  mov    %r15,%rdi\n  mov    %al,(%r15,%r14,1)\n  call   <strlen@plt>\n  lea    0x1(%rax),%r14\n  mov    %r14,%rdi\n  call   <malloc@plt>\n  mov    %r14,%rdx\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  mov    %rax,(%r12,%rbx,8)\n  call   <memcpy@plt>\n  mov    %rbx,%rax\n  add    $0x1,%rbx\n  cmp    %r13,%rax\n  jne    L1\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4683
        },
        "L1": {
          "label": "L1",
          "addr": 4592
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char *str, int *len) {\n  int i;\n  size_t l = strlen(str);\n  char **ret = malloc(l * sizeof(char *));\n  char *tmp = malloc(l + 1);\n  tmp[0] = '\\0';\n  for (i = 0; i < l; i++) {\n    size_t tmpl = strlen(tmp);\n    tmp = realloc(tmp, tmpl + 2);\n    tmp[tmpl] = str[i];\n    tmp[tmpl + 1] = '\\0';\n    size_t meml = strlen(tmp) + 1;\n    ret[i] = malloc(meml);\n    memcpy(ret[i], tmp, meml);\n  }\n  free(tmp);\n  *len = l;\n  return ret;\n}"
    },
    {
      "task_id": 16,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x430,%rsp\n  mov    %rdi,-0x428(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x418(%rbp)\n  lea    -0x410(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x80,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x414(%rbp)\n  jmp    1231 <func0+0xd8>\n  mov    -0x414(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x428(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   1080 <tolower@plt>\n  mov    %al,-0x419(%rbp)\n  movsbl -0x419(%rbp),%eax\n  cltq\n  mov    -0x410(%rbp,%rax,4),%eax\n  test   %eax,%eax\n  jne    122a <func0+0xd1>\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x419(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     122a <func0+0xd1>\n  movsbl -0x419(%rbp),%eax\n  cltq\n  movl   $0x1,-0x410(%rbp,%rax,4)\n  addl   $0x1,-0x418(%rbp)\n  addl   $0x1,-0x414(%rbp)\n  mov    -0x414(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x428(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11ae <func0+0x55>\n  mov    -0x418(%rbp),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     1269 <func0+0x110>\n  call   1070 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x430,%rsp\n  mov    %rdi,-0x428(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x418(%rbp)\n  lea    -0x410(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x80,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x414(%rbp)\n  jmp    L0\nL2:\n  mov    -0x414(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x428(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   <tolower@plt>\n  mov    %al,-0x419(%rbp)\n  movsbl -0x419(%rbp),%eax\n  cltq\n  mov    -0x410(%rbp,%rax,4),%eax\n  test   %eax,%eax\n  jne    L1\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x419(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     L1\n  movsbl -0x419(%rbp),%eax\n  cltq\n  movl   $0x1,-0x410(%rbp,%rax,4)\n  addl   $0x1,-0x418(%rbp)\nL1:\n  addl   $0x1,-0x414(%rbp)\nL0:\n  mov    -0x414(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x428(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\n  mov    -0x418(%rbp),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L3\n  call   <__stack_chk_fail@plt>\nL3:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4657
        },
        "L1": {
          "label": "L1",
          "addr": 4650
        },
        "L2": {
          "label": "L2",
          "addr": 4526
        },
        "L3": {
          "label": "L3",
          "addr": 4713
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const char *s) {\n  int i, j;\n  char c;\n  int count = 0;\n  int letter[256] = {0};\n  for (i = 0; s[i] != '\\0'; i++) {\n    c = tolower(s[i]);\n    if (letter[c] == 0 && (((*((unsigned short int *)(__ctype_b_loc() + 2 * (c)))) & 0x400) != 0)) {\n      letter[c] = 1;\n      count++;\n    }\n  }\n  return count;\n}"
    },
    {
      "task_id": 16,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    $0x80,%ecx\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  movzbl 0x0(%rbp),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  test   %bl,%bl\n  je     1210 <func0+0xb0>\n  call   1080 <__ctype_tolower_loc@plt>\n  add    $0x1,%rbp\n  xor    %r12d,%r12d\n  mov    (%rax),%r14\n  nopl   0x0(%rax,%rax,1)\n  mov    (%r14,%rbx,4),%ebx\n  movsbq %bl,%r13\n  mov    (%rsp,%r13,4),%eax\n  test   %eax,%eax\n  jne    11de <func0+0x7e>\n  call   1090 <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     11de <func0+0x7e>\n  movl   $0x1,(%rsp,%r13,4)\n  add    $0x1,%r12d\n  movzbl 0x0(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  jne    11b0 <func0+0x50>\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1215 <func0+0xb5>\n  add    $0x410,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r12d,%r12d\n  jmp    11ea <func0+0x8a>\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    $0x80,%ecx\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  movzbl 0x0(%rbp),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  test   %bl,%bl\n  je     L0\n  call   <__ctype_tolower_loc@plt>\n  add    $0x1,%rbp\n  xor    %r12d,%r12d\n  mov    (%rax),%r14\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    (%r14,%rbx,4),%ebx\n  movsbq %bl,%r13\n  mov    (%rsp,%r13,4),%eax\n  test   %eax,%eax\n  jne    L1\n  call   <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     L1\n  movl   $0x1,(%rsp,%r13,4)\n  add    $0x1,%r12d\nL1:\n  movzbl 0x0(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  jne    L2\nL4:\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  add    $0x410,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  xor    %r12d,%r12d\n  jmp    L4\nL3:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4624
        },
        "L1": {
          "label": "L1",
          "addr": 4574
        },
        "L2": {
          "label": "L2",
          "addr": 4528
        },
        "L3": {
          "label": "L3",
          "addr": 4629
        },
        "L4": {
          "label": "L4",
          "addr": 4586
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(const char *s) {\n  int i = 0;\n  int j = 0;\n  char c;\n  int a[256] = {0};\n  while (c = *s++) {\n    c = (*__ctype_tolower_loc(a) + 1)[c];\n    if (a[c] == 0 && ((*__ctype_b_loc(a) + 1)[c] & 0x04)) {\n      a[c] = 1;\n      j++;\n    }\n  }\n  return j;\n}"
    },
    {
      "task_id": 14,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   10a0 <strlen@plt>\n  movslq %eax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x8(%rsp)\n  shl    $0x3,%rdi\n  call   10c0 <malloc@plt>\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r12\n  call   10c0 <malloc@plt>\n  movb   $0x0,(%rax)\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    124b <func0+0xab>\n  lea    -0x1(%rbx),%r13d\n  xor    %ebx,%ebx\n  mov    %r15,%rdi\n  call   10a0 <strlen@plt>\n  mov    %r15,%rdi\n  lea    0x2(%rax),%rsi\n  mov    %rax,%r14\n  call   10d0 <realloc@plt>\n  mov    %rax,%r15\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movb   $0x0,0x1(%r15,%r14,1)\n  mov    %r15,%rdi\n  mov    %al,(%r15,%r14,1)\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%r14\n  mov    %r14,%rdi\n  call   10c0 <malloc@plt>\n  mov    %r14,%rdx\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  mov    %rax,(%r12,%rbx,8)\n  call   10b0 <memcpy@plt>\n  mov    %rbx,%rax\n  add    $0x1,%rbx\n  cmp    %rax,%r13\n  jne    11f0 <func0+0x50>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   <strlen@plt>\n  movslq %eax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x8(%rsp)\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r12\n  call   <malloc@plt>\n  movb   $0x0,(%rax)\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    L0\n  lea    -0x1(%rbx),%r13d\n  xor    %ebx,%ebx\nL1:\n  mov    %r15,%rdi\n  call   <strlen@plt>\n  mov    %r15,%rdi\n  lea    0x2(%rax),%rsi\n  mov    %rax,%r14\n  call   <realloc@plt>\n  mov    %rax,%r15\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movb   $0x0,0x1(%r15,%r14,1)\n  mov    %r15,%rdi\n  mov    %al,(%r15,%r14,1)\n  call   <strlen@plt>\n  lea    0x1(%rax),%r14\n  mov    %r14,%rdi\n  call   <malloc@plt>\n  mov    %r14,%rdx\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  mov    %rax,(%r12,%rbx,8)\n  call   <memcpy@plt>\n  mov    %rbx,%rax\n  add    $0x1,%rbx\n  cmp    %rax,%r13\n  jne    L1\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4683
        },
        "L1": {
          "label": "L1",
          "addr": 4592
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char *str, int *len) {\n  int i;\n  int slen = strlen(str);\n  char **array = malloc(slen * sizeof(char *));\n  char *buffer = malloc(slen + 1);\n  buffer[0] = '\\0';\n  for (i = 0; i < slen; i++) {\n    size_t blen = strlen(buffer);\n    buffer = realloc(buffer, blen + 2);\n    buffer[blen] = str[i];\n    buffer[blen + 1] = '\\0';\n    size_t clen = strlen(buffer);\n    array[i] = malloc(clen + 1);\n    memcpy(array[i], buffer, clen + 1);\n  }\n  free(buffer);\n  *len = slen;\n  return array;\n}"
    },
    {
      "task_id": 15,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  movl   $0x2,-0x1c(%rbp)\n  movl   $0x1,-0x18(%rbp)\n  jmp    11a2 <func0+0x49>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,%ecx\n  lea    0xe7c(%rip),%rax        # 2000 <_fini+0xdcc>\n  mov    %rax,%rdx\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  mov    $0x0,%eax\n  call   1070 <snprintf@plt>\n  add    %eax,-0x1c(%rbp)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    1178 <func0+0x1f>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  mov    %rax,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    11c9 <func0+0x70>\n  mov    $0x0,%eax\n  jmp    122f <func0+0xd6>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  lea    0xe28(%rip),%rdx        # 2004 <_fini+0xdd0>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1090 <sprintf@plt>\n  cltq\n  add    %rax,-0x10(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    1223 <func0+0xca>\n  mov    -0x14(%rbp),%edx\n  mov    -0x10(%rbp),%rax\n  lea    0xdf7(%rip),%rcx        # 2000 <_fini+0xdcc>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1090 <sprintf@plt>\n  cltq\n  add    %rax,-0x10(%rbp)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    11fb <func0+0xa2>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  movl   $0x2,-0x1c(%rbp)\n  movl   $0x1,-0x18(%rbp)\n  jmp    L0\nL1:\n  mov    -0x18(%rbp),%eax\n  mov    %eax,%ecx\n  lea    D0(%rip),%rax\n  mov    %rax,%rdx\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  mov    $0x0,%eax\n  call   <snprintf@plt>\n  add    %eax,-0x1c(%rbp)\n  addl   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    L1\n  mov    -0x1c(%rbp),%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L2\n  mov    $0x0,%eax\n  jmp    L3\nL2:\n  mov    -0x8(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  cltq\n  add    %rax,-0x10(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    L4\nL5:\n  mov    -0x14(%rbp),%edx\n  mov    -0x10(%rbp),%rax\n  lea    D0(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  cltq\n  add    %rax,-0x10(%rbp)\n  addl   $0x1,-0x14(%rbp)\nL4:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    L5\n  mov    -0x8(%rbp),%rax\nL3:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3708,
            3575
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3624
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4514
        },
        "L1": {
          "label": "L1",
          "addr": 4472
        },
        "L2": {
          "label": "L2",
          "addr": 4553
        },
        "L3": {
          "label": "L3",
          "addr": 4655
        },
        "L4": {
          "label": "L4",
          "addr": 4643
        },
        "L5": {
          "label": "L5",
          "addr": 4603
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "202564003000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\" %d\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"0\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(int n) {\n  int i;\n  int j;\n  int len = 2;\n  char *p;\n  char *q;\n  for (i = 1; i <= n; i++)\n    len += snprintf(NULL, 0, \" %d\", i);\n  q = malloc(len);\n  if (q == NULL)\n    return NULL;\n  p = q;\n  p += sprintf(p, \"0\");\n  for (j = 1; j <= n; j++)\n    p += sprintf(p, \" %d\", j);\n  return q;\n}"
    },
    {
      "task_id": 15,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    1213 <func0+0xba>\n  mov    %edi,%r12d\n  lea    0x1(%rdi),%r14d\n  mov    $0x1,%ebx\n  mov    $0x2,%ebp\n  lea    0xe7b(%rip),%r13        # 2000 <_fini+0xdd4>\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  mov    $0x1,%edx\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  mov    $0x0,%eax\n  call   1070 <__snprintf_chk@plt>\n  add    %eax,%ebp\n  add    $0x1,%ebx\n  cmp    %r14d,%ebx\n  jne    1185 <func0+0x2c>\n  movslq %ebp,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%r14\n  test   %rax,%rax\n  je     1207 <func0+0xae>\n  movw   $0x30,(%r14)\n  lea    0x1(%r14),%rbp\n  mov    $0x1,%ebx\n  lea    0xe25(%rip),%r13        # 2000 <_fini+0xdd4>\n  mov    %ebx,%r8d\n  mov    %r13,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  mov    %rbp,%rdi\n  mov    $0x0,%eax\n  call   1090 <__sprintf_chk@plt>\n  cltq\n  add    %rax,%rbp\n  add    $0x1,%ebx\n  cmp    %ebx,%r12d\n  jge    11db <func0+0x82>\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x2,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r14\n  test   %rax,%rax\n  je     1207 <func0+0xae>\n  movw   $0x30,(%rax)\n  jmp    1207 <func0+0xae>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%r12d\n  lea    0x1(%rdi),%r14d\n  mov    $0x1,%ebx\n  mov    $0x2,%ebp\n  lea    D0(%rip),%r13\nL1:\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  mov    $0x1,%edx\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  mov    $0x0,%eax\n  call   <__snprintf_chk@plt>\n  add    %eax,%ebp\n  add    $0x1,%ebx\n  cmp    %r14d,%ebx\n  jne    L1\n  movslq %ebp,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %rax,%rax\n  je     L2\n  movw   $0x30,(%r14)\n  lea    0x1(%r14),%rbp\n  mov    $0x1,%ebx\n  lea    D0(%rip),%r13\nL3:\n  mov    %ebx,%r8d\n  mov    %r13,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  mov    %rbp,%rdi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\n  cltq\n  add    %rax,%rbp\n  add    $0x1,%ebx\n  cmp    %ebx,%r12d\n  jge    L3\nL2:\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  mov    $0x2,%edi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %rax,%rax\n  je     L2\n  movw   $0x30,(%rax)\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3707,
            3621
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4627
        },
        "L1": {
          "label": "L1",
          "addr": 4485
        },
        "L2": {
          "label": "L2",
          "addr": 4615
        },
        "L3": {
          "label": "L3",
          "addr": 4571
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "20256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\" %d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int n) {\n  char *buf;\n  char *p;\n  int i;\n  int len = 2;\n  for (i = 1; i <= n; i++)\n    len += __snprintf_chk(0, 0, 1, -1, \" %d\", i);\n  buf = malloc(len);\n  if (!buf)\n    return 0;\n  p = buf;\n  *p++ = '0';\n  *p++ = '\\0';\n  for (i = 1; i <= n; i++)\n    p += __sprintf_chk(p, 1, -1, \" %d\", i);\n  return buf;\n}"
    },
    {
      "task_id": 15,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    1220 <func0+0xc0>\n  lea    0x1(%rdi),%ebp\n  mov    $0x1,%ebx\n  mov    $0x2,%r12d\n  lea    0xe77(%rip),%r13        # 2000 <_fini+0xdb4>\n  nopl   0x0(%rax)\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  xor    %esi,%esi\n  mov    $0x1,%edx\n  xor    %edi,%edi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   1070 <__snprintf_chk@plt>\n  add    %eax,%r12d\n  cmp    %ebp,%ebx\n  jne    1190 <func0+0x30>\n  movslq %r12d,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     1246 <func0+0xe6>\n  mov    $0x30,%eax\n  lea    0x1(%r13),%r14\n  mov    $0x1,%ebx\n  mov    %ax,0x0(%r13)\n  lea    0xe1f(%rip),%r12        # 2000 <_fini+0xdb4>\n  nopl   0x0(%rax)\n  mov    %ebx,%r8d\n  mov    %r14,%rdi\n  mov    %r12,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   1090 <__sprintf_chk@plt>\n  cltq\n  add    %rax,%r14\n  cmp    %ebp,%ebx\n  jne    11e8 <func0+0x88>\n  pop    %rbx\n  mov    %r13,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\n  mov    $0x2,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     1246 <func0+0xe6>\n  mov    $0x30,%edx\n  mov    %dx,(%rax)\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r13d,%r13d\n  jmp    1210 <func0+0xb0>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    L0\n  lea    0x1(%rdi),%ebp\n  mov    $0x1,%ebx\n  mov    $0x2,%r12d\n  lea    D0(%rip),%r13\n  nopl   0x0(%rax)\nL1:\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  xor    %esi,%esi\n  mov    $0x1,%edx\n  xor    %edi,%edi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   <__snprintf_chk@plt>\n  add    %eax,%r12d\n  cmp    %ebp,%ebx\n  jne    L1\n  movslq %r12d,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     L2\n  mov    $0x30,%eax\n  lea    0x1(%r13),%r14\n  mov    $0x1,%ebx\n  mov    %ax,0x0(%r13)\n  lea    D0(%rip),%r12\n  nopl   0x0(%rax)\nL3:\n  mov    %ebx,%r8d\n  mov    %r14,%rdi\n  mov    %r12,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   <__sprintf_chk@plt>\n  cltq\n  add    %rax,%r14\n  cmp    %ebp,%ebx\n  jne    L3\nL4:\n  pop    %rbx\n  mov    %r13,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x2,%edi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     L2\n  mov    $0x30,%edx\n  mov    %dx,(%rax)\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL2:\n  xor    %r13d,%r13d\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3703,
            3615
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4640
        },
        "L1": {
          "label": "L1",
          "addr": 4496
        },
        "L2": {
          "label": "L2",
          "addr": 4678
        },
        "L3": {
          "label": "L3",
          "addr": 4584
        },
        "L4": {
          "label": "L4",
          "addr": 4624
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "20256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\" %d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int n) {\n  int i;\n  int len = 2;\n  char *p;\n  for (i = 1; i <= n; i++)\n    len += __snprintf_chk(0, 0, 1, -1, \" %d\", i);\n  p = (char *)malloc(len);\n  if (!p)\n    return 0;\n  p[0] = '0';\n  p[1] = '\\0';\n  for (i = 1; i <= n; i++)\n    p += __sprintf_chk(p, 1, -1, \" %d\", i);\n  return p;\n}"
    },
    {
      "task_id": 16,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  mov    %rdi,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x80,%ecx\n  rep stos %rax,%es:(%rdi)\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     11ed <func0+0x94>\n  call   1080 <__ctype_tolower_loc@plt>\n  mov    (%rax),%r12\n  add    $0x1,%rbp\n  mov    $0x0,%r13d\n  jmp    11b5 <func0+0x5c>\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     11f3 <func0+0x9a>\n  movzbl %bl,%ebx\n  mov    (%r12,%rbx,4),%ebx\n  movsbl %bl,%r14d\n  movsbq %bl,%rax\n  cmpl   $0x0,(%rsp,%rax,4)\n  jne    11a9 <func0+0x50>\n  call   1090 <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     11a9 <func0+0x50>\n  movslq %r14d,%r14\n  movl   $0x1,(%rsp,%r14,4)\n  add    $0x1,%r13d\n  jmp    11a9 <func0+0x50>\n  mov    $0x0,%r13d\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1219 <func0+0xc0>\n  mov    %r13d,%eax\n  add    $0x410,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  mov    %rdi,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x80,%ecx\n  rep stos %rax,%es:(%rdi)\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     L0\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%r12\n  add    $0x1,%rbp\n  mov    $0x0,%r13d\n  jmp    L1\nL3:\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\nL1:\n  movzbl %bl,%ebx\n  mov    (%r12,%rbx,4),%ebx\n  movsbl %bl,%r14d\n  movsbq %bl,%rax\n  cmpl   $0x0,(%rsp,%rax,4)\n  jne    L3\n  call   <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     L3\n  movslq %r14d,%r14\n  movl   $0x1,(%rsp,%r14,4)\n  add    $0x1,%r13d\n  jmp    L3\nL0:\n  mov    $0x0,%r13d\nL2:\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L4\n  mov    %r13d,%eax\n  add    $0x410,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL4:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4589
        },
        "L1": {
          "label": "L1",
          "addr": 4533
        },
        "L2": {
          "label": "L2",
          "addr": 4595
        },
        "L3": {
          "label": "L3",
          "addr": 4521
        },
        "L4": {
          "label": "L4",
          "addr": 4633
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(const char *s) {\n  int i = 0;\n  int j = 0;\n  int a[256] = {0};\n  const unsigned char *_s = (const unsigned char *)s;\n  const int *pw = *__ctype_tolower_loc();\n  while (*_s != '\\0') {\n    unsigned char c = _s[i];\n    int lower = pw[c];\n    if (a[lower] == 0) {\n      const unsigned char *_w = (const unsigned char *)__ctype_b_loc();\n      unsigned char wc = _w[1][lower + 1];\n      if ((wc & 0x04) != 0) {\n        a[lower] = 1;\n        j++;\n      }\n    }\n    i++;\n  }\n  return j;\n}"
    },
    {
      "task_id": 15,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    1220 <func0+0xc0>\n  lea    0x1(%rdi),%ebp\n  mov    $0x1,%ebx\n  mov    $0x2,%r12d\n  lea    0xe77(%rip),%r13        # 2000 <_fini+0xdb4>\n  nopl   0x0(%rax)\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  xor    %esi,%esi\n  mov    $0x1,%edx\n  xor    %edi,%edi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   1070 <__snprintf_chk@plt>\n  add    %eax,%r12d\n  cmp    %ebp,%ebx\n  jne    1190 <func0+0x30>\n  movslq %r12d,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     1246 <func0+0xe6>\n  mov    $0x30,%eax\n  lea    0x1(%r13),%r14\n  mov    $0x1,%ebx\n  mov    %ax,0x0(%r13)\n  lea    0xe1f(%rip),%r12        # 2000 <_fini+0xdb4>\n  nopl   0x0(%rax)\n  mov    %ebx,%r8d\n  mov    %r14,%rdi\n  mov    %r12,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   1090 <__sprintf_chk@plt>\n  cltq\n  add    %rax,%r14\n  cmp    %ebp,%ebx\n  jne    11e8 <func0+0x88>\n  pop    %rbx\n  mov    %r13,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\n  mov    $0x2,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     1246 <func0+0xe6>\n  mov    $0x30,%edx\n  mov    %dx,(%rax)\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r13d,%r13d\n  jmp    1210 <func0+0xb0>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    L0\n  lea    0x1(%rdi),%ebp\n  mov    $0x1,%ebx\n  mov    $0x2,%r12d\n  lea    D0(%rip),%r13\n  nopl   0x0(%rax)\nL1:\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  xor    %esi,%esi\n  mov    $0x1,%edx\n  xor    %edi,%edi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   <__snprintf_chk@plt>\n  add    %eax,%r12d\n  cmp    %ebp,%ebx\n  jne    L1\n  movslq %r12d,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     L2\n  mov    $0x30,%eax\n  lea    0x1(%r13),%r14\n  mov    $0x1,%ebx\n  mov    %ax,0x0(%r13)\n  lea    D0(%rip),%r12\n  nopl   0x0(%rax)\nL3:\n  mov    %ebx,%r8d\n  mov    %r14,%rdi\n  mov    %r12,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   <__sprintf_chk@plt>\n  cltq\n  add    %rax,%r14\n  cmp    %ebp,%ebx\n  jne    L3\nL4:\n  pop    %rbx\n  mov    %r13,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x2,%edi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     L2\n  mov    $0x30,%edx\n  mov    %dx,(%rax)\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL2:\n  xor    %r13d,%r13d\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3703,
            3615
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4640
        },
        "L1": {
          "label": "L1",
          "addr": 4496
        },
        "L2": {
          "label": "L2",
          "addr": 4678
        },
        "L3": {
          "label": "L3",
          "addr": 4584
        },
        "L4": {
          "label": "L4",
          "addr": 4624
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "20256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\" %d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int n) {\n  int i;\n  int len = 2;\n  char *p;\n  for (i = 1; i <= n; i++)\n    len += __snprintf_chk(0, 0, 1, -1, \" %d\", i);\n  p = (char *)malloc(len);\n  if (!p)\n    return 0;\n  p[0] = '0';\n  p[1] = '\\0';\n  for (i = 1; i <= n; i++)\n    p += __sprintf_chk(p, 1, -1, \" %d\", i);\n  return p;\n}"
    },
    {
      "task_id": 18,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jne    117f <func0+0x46>\n  mov    $0x0,%eax\n  jmp    11c4 <func0+0x8b>\n  movl   $0x0,-0xc(%rbp)\n  jmp    11b6 <func0+0x7d>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rcx\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   1060 <strncmp@plt>\n  test   %eax,%eax\n  jne    11b2 <func0+0x79>\n  addl   $0x1,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0x8(%rbp),%eax\n  sub    -0x4(%rbp),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    1188 <func0+0x4f>\n  mov    -0x10(%rbp),%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0xc(%rbp)\n  jmp    L2\nL4:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rcx\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   <strncmp@plt>\n  test   %eax,%eax\n  jne    L3\n  addl   $0x1,-0x10(%rbp)\nL3:\n  addl   $0x1,-0xc(%rbp)\nL2:\n  mov    -0x8(%rbp),%eax\n  sub    -0x4(%rbp),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L4\n  mov    -0x10(%rbp),%eax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4479
        },
        "L1": {
          "label": "L1",
          "addr": 4548
        },
        "L2": {
          "label": "L2",
          "addr": 4534
        },
        "L3": {
          "label": "L3",
          "addr": 4530
        },
        "L4": {
          "label": "L4",
          "addr": 4488
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str, char *sub) {\n  int i, j, count = 0, len, len1;\n  len = strlen(str);\n  len1 = strlen(sub);\n  if (len == 0)\n    return 0;\n  for (i = 0; i <= len - len1; i++) {\n    if (!strncmp(str + i, sub, (size_t)len1))\n      count++;\n  }\n  return count;\n}"
    },
    {
      "task_id": 18,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %rsi,%r12\n  call   1070 <strlen@plt>\n  mov    %eax,%ebp\n  test   %eax,%eax\n  je     1193 <func0+0x5a>\n  mov    %r12,%rdi\n  call   1070 <strlen@plt>\n  mov    %ebp,%edx\n  sub    %eax,%edx\n  js     119e <func0+0x65>\n  mov    %r14,%rbx\n  mov    %edx,%edx\n  lea    0x1(%r14,%rdx,1),%r14\n  mov    $0x0,%ebp\n  movslq %eax,%r13\n  mov    %r13,%rdx\n  mov    %r12,%rsi\n  mov    %rbx,%rdi\n  call   1060 <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%ebp\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    1176 <func0+0x3d>\n  mov    %ebp,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x0,%ebp\n  jmp    1193 <func0+0x5a>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %rsi,%r12\n  call   <strlen@plt>\n  mov    %eax,%ebp\n  test   %eax,%eax\n  je     L0\n  mov    %r12,%rdi\n  call   <strlen@plt>\n  mov    %ebp,%edx\n  sub    %eax,%edx\n  js     L1\n  mov    %r14,%rbx\n  mov    %edx,%edx\n  lea    0x1(%r14,%rdx,1),%r14\n  mov    $0x0,%ebp\n  movslq %eax,%r13\nL2:\n  mov    %r13,%rdx\n  mov    %r12,%rsi\n  mov    %rbx,%rdi\n  call   <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%ebp\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    L2\nL0:\n  mov    %ebp,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL1:\n  mov    $0x0,%ebp\n  jmp    L0",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4499
        },
        "L1": {
          "label": "L1",
          "addr": 4510
        },
        "L2": {
          "label": "L2",
          "addr": 4470
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *str, char *sub) {\n  int i, j, k, m, n, count = 0;\n  n = strlen(str);\n  m = strlen(sub);\n  for (i = 0; i <= n - m; i++) {\n    j = i;\n    k = 0;\n    while (k < m && strncmp(str + j, sub, m)) {\n      j++;\n      k++;\n    }\n    if (k == m)\n      count++;\n  }\n  return count;\n}"
    },
    {
      "task_id": 18,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1070 <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     119e <func0+0x5e>\n  mov    %r13,%rdi\n  mov    %rax,%r14\n  call   1070 <strlen@plt>\n  sub    %eax,%r14d\n  js     11b0 <func0+0x70>\n  movslq %r14d,%r14\n  movslq %eax,%rbp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%r14,1),%r14\n  nopl   0x0(%rax)\n  mov    %rbx,%rdi\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  call   1060 <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%r12d\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    1180 <func0+0x40>\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r12d,%r12d\n  jmp    119e <func0+0x5e>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     L0\n  mov    %r13,%rdi\n  mov    %rax,%r14\n  call   <strlen@plt>\n  sub    %eax,%r14d\n  js     L1\n  movslq %r14d,%r14\n  movslq %eax,%rbp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%r14,1),%r14\n  nopl   0x0(%rax)\nL2:\n  mov    %rbx,%rdi\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  call   <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%r12d\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    L2\nL0:\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  xor    %r12d,%r12d\n  jmp    L0",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4510
        },
        "L1": {
          "label": "L1",
          "addr": 4528
        },
        "L2": {
          "label": "L2",
          "addr": 4480
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *str, char *sub) {\n  int i, j, k, len, len1, count;\n  count = 0;\n  len = strlen(str);\n  len1 = strlen(sub);\n  for (i = 0; i < len; i++) {\n    j = i;\n    k = 0;\n    while (j < (i + len1)) {\n      if (strncmp(&str[j], &sub[k], len1) == 0) {\n        count++;\n        break;\n      }\n      j++;\n    }\n  }\n  return count;\n}"
    },
    {
      "task_id": 18,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1070 <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     119e <func0+0x5e>\n  mov    %r13,%rdi\n  mov    %rax,%r14\n  call   1070 <strlen@plt>\n  sub    %eax,%r14d\n  js     11b0 <func0+0x70>\n  movslq %r14d,%r14\n  movslq %eax,%rbp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%r14,1),%r14\n  nopl   0x0(%rax)\n  mov    %rbx,%rdi\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  call   1060 <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%r12d\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    1180 <func0+0x40>\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r12d,%r12d\n  jmp    119e <func0+0x5e>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     L0\n  mov    %r13,%rdi\n  mov    %rax,%r14\n  call   <strlen@plt>\n  sub    %eax,%r14d\n  js     L1\n  movslq %r14d,%r14\n  movslq %eax,%rbp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%r14,1),%r14\n  nopl   0x0(%rax)\nL2:\n  mov    %rbx,%rdi\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  call   <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%r12d\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    L2\nL0:\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  xor    %r12d,%r12d\n  jmp    L0",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4510
        },
        "L1": {
          "label": "L1",
          "addr": 4528
        },
        "L2": {
          "label": "L2",
          "addr": 4480
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *str, char *sub) {\n  int i, j, k, len, len1, count;\n  count = 0;\n  len = strlen(str);\n  len1 = strlen(sub);\n  for (i = 0; i < len; i++) {\n    j = i;\n    k = 0;\n    while (j < (i + len1)) {\n      if (strncmp(&str[j], &sub[k], len1) == 0) {\n        count++;\n        break;\n      }\n      j++;\n    }\n  }\n  return count;\n}"
    },
    {
      "task_id": 21,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
      "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x18(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  jmp    11a9 <func0+0xb0>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  movss  -0x10(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    116a <func0+0x71>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss -0xc(%rbp),%xmm0\n  jbe    11a5 <func0+0xac>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     112b <func0+0x32>\n  movl   $0x0,-0x4(%rbp)\n  jmp    1205 <func0+0x10c>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  subss  -0x10(%rbp),%xmm0\n  movss  -0xc(%rbp),%xmm1\n  subss  -0x10(%rbp),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     11be <func0+0xc5>\n  nop\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x18(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  jmp    L0\nL3:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  movss  -0x10(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    L1\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x10(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss -0xc(%rbp),%xmm0\n  jbe    L2\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\nL2:\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  movl   $0x0,-0x4(%rbp)\n  jmp    L4\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  subss  -0x10(%rbp),%xmm0\n  movss  -0xc(%rbp),%xmm1\n  subss  -0x10(%rbp),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x4(%rbp)\nL4:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  nop\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4521
        },
        "L1": {
          "label": "L1",
          "addr": 4458
        },
        "L2": {
          "label": "L2",
          "addr": 4517
        },
        "L3": {
          "label": "L3",
          "addr": 4395
        },
        "L4": {
          "label": "L4",
          "addr": 4613
        },
        "L5": {
          "label": "L5",
          "addr": 4542
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(float *data, int n) {\n  int i;\n  float min = data[0];\n  float max = data[0];\n  for (i = 1; i < n; i++) {\n    if (data[i] < min)\n      min = data[i];\n    if (data[i] > max)\n      max = data[i];\n  }\n  for (i = 0; i < n; i++)\n    data[i] = (data[i] - min) / (max - min);\n}"
    },
    {
      "task_id": 21,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
      "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm1\n  cmp    $0x1,%esi\n  jle    1157 <func0+0x5e>\n  lea    0x4(%rdi),%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x8(%rdi,%rdx,4),%rdx\n  movaps %xmm1,%xmm0\n  movss  (%rax),%xmm2\n  movaps %xmm2,%xmm3\n  minss  %xmm1,%xmm3\n  movaps %xmm3,%xmm1\n  maxss  %xmm0,%xmm2\n  movaps %xmm2,%xmm0\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    1115 <func0+0x1c>\n  mov    $0x0,%eax\n  subss  %xmm3,%xmm2\n  movss  (%rdi,%rax,4),%xmm0\n  subss  %xmm1,%xmm0\n  divss  %xmm2,%xmm0\n  movss  %xmm0,(%rdi,%rax,4)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     113c <func0+0x43>\n  ret\n  je     115a <func0+0x61>\n  ret\n  movss  (%rdi),%xmm0\n  subss  %xmm1,%xmm0\n  subss  %xmm1,%xmm1\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  jmp    1159 <func0+0x60>",
      "asm_labeled": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm1\n  cmp    $0x1,%esi\n  jle    L0\n  lea    0x4(%rdi),%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x8(%rdi,%rdx,4),%rdx\n  movaps %xmm1,%xmm0\nL1:\n  movss  (%rax),%xmm2\n  movaps %xmm2,%xmm3\n  minss  %xmm1,%xmm3\n  movaps %xmm3,%xmm1\n  maxss  %xmm0,%xmm2\n  movaps %xmm2,%xmm0\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    L1\n  mov    $0x0,%eax\n  subss  %xmm3,%xmm2\nL2:\n  movss  (%rdi,%rax,4),%xmm0\n  subss  %xmm1,%xmm0\n  divss  %xmm2,%xmm0\n  movss  %xmm0,(%rdi,%rax,4)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L2\n  ret\nL0:\n  je     L3\nL4:\n  ret\nL3:\n  movss  (%rdi),%xmm0\n  subss  %xmm1,%xmm0\n  subss  %xmm1,%xmm1\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4439
        },
        "L1": {
          "label": "L1",
          "addr": 4373
        },
        "L2": {
          "label": "L2",
          "addr": 4412
        },
        "L3": {
          "label": "L3",
          "addr": 4442
        },
        "L4": {
          "label": "L4",
          "addr": 4441
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(float *x, int n) {\n  int i;\n  float min, max, range;\n  min = x[0];\n  max = x[0];\n  for (i = 1; i < n; i++) {\n    if (x[i] < min)\n      min = x[i];\n    if (x[i] > max)\n      max = x[i];\n  }\n  range = max - min;\n  for (i = 0; i < n; i++)\n    x[i] = (x[i] - min) / range;\n}"
    },
    {
      "task_id": 21,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
      "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  cmp    $0x1,%esi\n  jle    1170 <func0+0x70>\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi),%rax\n  movaps %xmm0,%xmm1\n  lea    0x8(%rdi,%rdx,4),%rdx\n  movaps %xmm0,%xmm2\n  nop\n  movss  (%rax),%xmm3\n  add    $0x4,%rax\n  movaps %xmm3,%xmm4\n  maxss  %xmm1,%xmm3\n  minss  %xmm2,%xmm4\n  movaps %xmm3,%xmm1\n  movaps %xmm4,%xmm2\n  cmp    %rax,%rdx\n  jne    1120 <func0+0x20>\n  subss  %xmm2,%xmm1\n  xor    %eax,%eax\n  jmp    1155 <func0+0x55>\n  cs nopw 0x0(%rax,%rax,1)\n  movss  (%rdi,%rax,4),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi,%rax,4)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     1150 <func0+0x50>\n  ret\n  nopl   0x0(%rax,%rax,1)\n  jne    116a <func0+0x6a>\n  movaps %xmm0,%xmm1\n  movaps %xmm0,%xmm2\n  jmp    113e <func0+0x3e>",
      "asm_labeled": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi),%rax\n  movaps %xmm0,%xmm1\n  lea    0x8(%rdi,%rdx,4),%rdx\n  movaps %xmm0,%xmm2\n  nop\nL1:\n  movss  (%rax),%xmm3\n  add    $0x4,%rax\n  movaps %xmm3,%xmm4\n  maxss  %xmm1,%xmm3\n  minss  %xmm2,%xmm4\n  movaps %xmm3,%xmm1\n  movaps %xmm4,%xmm2\n  cmp    %rax,%rdx\n  jne    L1\nL5:\n  subss  %xmm2,%xmm1\n  xor    %eax,%eax\n  jmp    L2\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  movss  (%rdi,%rax,4),%xmm0\nL2:\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi,%rax,4)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L3\nL4:\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  jne    L4\n  movaps %xmm0,%xmm1\n  movaps %xmm0,%xmm2\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4464
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        },
        "L2": {
          "label": "L2",
          "addr": 4437
        },
        "L3": {
          "label": "L3",
          "addr": 4432
        },
        "L4": {
          "label": "L4",
          "addr": 4458
        },
        "L5": {
          "label": "L5",
          "addr": 4414
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(float *x, int n) {\n  int i;\n  float min, max;\n  min = max = x[0];\n  for (i = 1; i < n; i++) {\n    min = (((min) < (x[i])) ? (min) : (x[i]));\n    max = (((max) > (x[i])) ? (max) : (x[i]));\n  }\n  for (i = 0; i < n; i++)\n    x[i] = (x[i] - min) / (max - min);\n}"
    },
    {
      "task_id": 21,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
      "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm3\n  mov    %rdi,%rdx\n  movaps %xmm3,%xmm2\n  cmp    $0x1,%esi\n  jle    1208 <func0+0x108>\n  lea    -0x2(%rsi),%ecx\n  lea    0x4(%rdi),%rax\n  movaps %xmm3,%xmm1\n  lea    0x8(%rdi,%rcx,4),%rcx\n  cs nopw 0x0(%rax,%rax,1)\n  movss  (%rax),%xmm0\n  add    $0x4,%rax\n  movaps %xmm0,%xmm5\n  maxss  %xmm1,%xmm0\n  minss  %xmm2,%xmm5\n  movaps %xmm0,%xmm1\n  movaps %xmm5,%xmm2\n  cmp    %rcx,%rax\n  jne    1130 <func0+0x30>\n  test   %esi,%esi\n  mov    $0x1,%edi\n  subss  %xmm5,%xmm1\n  cmovg  %esi,%edi\n  cmp    $0x3,%esi\n  jle    120b <func0+0x10b>\n  mov    %edi,%ecx\n  movaps %xmm5,%xmm4\n  mov    %rdx,%rax\n  shr    $0x2,%ecx\n  movaps %xmm1,%xmm3\n  shufps $0x0,%xmm4,%xmm4\n  sub    $0x1,%ecx\n  shufps $0x0,%xmm3,%xmm3\n  shl    $0x4,%rcx\n  lea    0x10(%rdx,%rcx,1),%rcx\n  nopw   0x0(%rax,%rax,1)\n  movups (%rax),%xmm0\n  add    $0x10,%rax\n  subps  %xmm4,%xmm0\n  divps  %xmm3,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rcx,%rax\n  jne    1190 <func0+0x90>\n  mov    %edi,%eax\n  and    $0xfffffffc,%eax\n  and    $0x3,%edi\n  je     120a <func0+0x10a>\n  movslq %eax,%rcx\n  add    $0x1,%eax\n  shl    $0x2,%rcx\n  lea    (%rdx,%rcx,1),%rdi\n  movss  (%rdi),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  cmp    %esi,%eax\n  jge    120a <func0+0x10a>\n  lea    0x4(%rdx,%rcx,1),%rdi\n  add    $0x1,%eax\n  movss  (%rdi),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  cmp    %esi,%eax\n  jge    120a <func0+0x10a>\n  lea    0x8(%rdx,%rcx,1),%rax\n  movss  (%rax),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  ret\n  nopl   0x0(%rax)\n  je     1220 <func0+0x120>\n  ret\n  subss  %xmm5,%xmm3\n  mov    $0x1,%eax\n  xor    %ecx,%ecx\n  divss  %xmm1,%xmm3\n  movss  %xmm3,(%rdx)\n  jmp    11d2 <func0+0xd2>\n  subss  %xmm3,%xmm3\n  divss  %xmm3,%xmm3\n  movss  %xmm3,(%rdi)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm3\n  mov    %rdi,%rdx\n  movaps %xmm3,%xmm2\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%ecx\n  lea    0x4(%rdi),%rax\n  movaps %xmm3,%xmm1\n  lea    0x8(%rdi,%rcx,4),%rcx\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  movss  (%rax),%xmm0\n  add    $0x4,%rax\n  movaps %xmm0,%xmm5\n  maxss  %xmm1,%xmm0\n  minss  %xmm2,%xmm5\n  movaps %xmm0,%xmm1\n  movaps %xmm5,%xmm2\n  cmp    %rcx,%rax\n  jne    L1\n  test   %esi,%esi\n  mov    $0x1,%edi\n  subss  %xmm5,%xmm1\n  cmovg  %esi,%edi\n  cmp    $0x3,%esi\n  jle    L2\n  mov    %edi,%ecx\n  movaps %xmm5,%xmm4\n  mov    %rdx,%rax\n  shr    $0x2,%ecx\n  movaps %xmm1,%xmm3\n  shufps $0x0,%xmm4,%xmm4\n  sub    $0x1,%ecx\n  shufps $0x0,%xmm3,%xmm3\n  shl    $0x4,%rcx\n  lea    0x10(%rdx,%rcx,1),%rcx\n  nopw   0x0(%rax,%rax,1)\nL3:\n  movups (%rax),%xmm0\n  add    $0x10,%rax\n  subps  %xmm4,%xmm0\n  divps  %xmm3,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rcx,%rax\n  jne    L3\n  mov    %edi,%eax\n  and    $0xfffffffc,%eax\n  and    $0x3,%edi\n  je     L4\n  movslq %eax,%rcx\n  add    $0x1,%eax\n  shl    $0x2,%rcx\n  lea    (%rdx,%rcx,1),%rdi\n  movss  (%rdi),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  cmp    %esi,%eax\n  jge    L4\nL6:\n  lea    0x4(%rdx,%rcx,1),%rdi\n  add    $0x1,%eax\n  movss  (%rdi),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  cmp    %esi,%eax\n  jge    L4\n  lea    0x8(%rdx,%rcx,1),%rax\n  movss  (%rax),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  ret\n  nopl   0x0(%rax)\nL0:\n  je     L5\nL4:\n  ret\nL2:\n  subss  %xmm5,%xmm3\n  mov    $0x1,%eax\n  xor    %ecx,%ecx\n  divss  %xmm1,%xmm3\n  movss  %xmm3,(%rdx)\n  jmp    L6\nL5:\n  subss  %xmm3,%xmm3\n  divss  %xmm3,%xmm3\n  movss  %xmm3,(%rdi)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4616
        },
        "L1": {
          "label": "L1",
          "addr": 4400
        },
        "L2": {
          "label": "L2",
          "addr": 4619
        },
        "L3": {
          "label": "L3",
          "addr": 4496
        },
        "L4": {
          "label": "L4",
          "addr": 4618
        },
        "L5": {
          "label": "L5",
          "addr": 4640
        },
        "L6": {
          "label": "L6",
          "addr": 4562
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(float *x, int n) {\n  int i;\n  float min, max, range;\n  min = x[0];\n  max = x[0];\n  for (i = 1; i < n; i++) {\n    min = (x[i] < min) ? x[i] : min;\n    max = (x[i] > max) ? x[i] : max;\n  }\n  range = max - min;\n  for (i = 0; i < n; i++)\n    x[i] = (x[i] - min) / range;\n}"
    },
    {
      "task_id": 20,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdx,%rcx\n  movss  (%rdi),%xmm0\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm0\n  movss  %xmm0,0x4(%rdx)\n  test   %esi,%esi\n  jle    118d <func0+0x94>\n  lea    0x4(%rdi),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r9d\n  mov    $0x1,%r8d\n  movss  0xed1(%rip),%xmm2        # 2000 <_fini+0xe58>\n  add    $0x8,%rdi\n  movss  0xed5(%rip),%xmm3        # 2010 <_fini+0xe68>\n  jmp    1174 <func0+0x7b>\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     116c <func0+0x73>\n  movss  -0x4(%rdx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rax),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    113d <func0+0x44>\n  movss  %xmm1,(%rcx)\n  movss  (%rax),%xmm1\n  movss  %xmm1,0x4(%rcx)\n  movaps %xmm0,%xmm2\n  jmp    113d <func0+0x44>\n  add    $0x1,%r8\n  add    $0x4,%rdx\n  cmp    %r9,%r8\n  je     118d <func0+0x94>\n  mov    %r10d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rdi,%rax,4),%rsi\n  mov    %rdx,%rax\n  jmp    1146 <func0+0x4d>\n  movss  (%rcx),%xmm0\n  movss  0x4(%rcx),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    11a4 <func0+0xab>\n  movss  %xmm1,(%rcx)\n  movss  %xmm0,0x4(%rcx)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdx,%rcx\n  movss  (%rdi),%xmm0\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm0\n  movss  %xmm0,0x4(%rdx)\n  test   %esi,%esi\n  jle    L0\n  lea    0x4(%rdi),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r9d\n  mov    $0x1,%r8d\n  movss  D0(%rip),%xmm2\n  add    $0x8,%rdi\n  movss  D1(%rip),%xmm3\n  jmp    L1\nL3:\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     L2\nL4:\n  movss  -0x4(%rdx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rax),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    L3\n  movss  %xmm1,(%rcx)\n  movss  (%rax),%xmm1\n  movss  %xmm1,0x4(%rcx)\n  movaps %xmm0,%xmm2\n  jmp    L3\nL2:\n  add    $0x1,%r8\n  add    $0x4,%rdx\nL1:\n  cmp    %r9,%r8\n  je     L0\n  mov    %r10d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rdi,%rax,4),%rsi\n  mov    %rdx,%rax\n  jmp    L4\nL0:\n  movss  (%rcx),%xmm0\n  movss  0x4(%rcx),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L5\n  movss  %xmm1,(%rcx)\n  movss  %xmm0,0x4(%rcx)\nL5:\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3793
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3797
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4493
        },
        "L1": {
          "label": "L1",
          "addr": 4468
        },
        "L2": {
          "label": "L2",
          "addr": 4460
        },
        "L3": {
          "label": "L3",
          "addr": 4413
        },
        "L4": {
          "label": "L4",
          "addr": 4422
        },
        "L5": {
          "label": "L5",
          "addr": 4516
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffff7f7f000000000000000000000000ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2010": {
            "type": "dword",
            "value": 2147483647
          },
          "0x2000": {
            "type": "byte[4]",
            "value": [
              255,
              255,
              127,
              127
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(float *x, int n, float *minmax) {\n  int i, j;\n  float t, min;\n  minmax[0] = x[0];\n  minmax[1] = x[1];\n  for (i = 0; i < n; i++) {\n    for (j = i + 1; j < n; j++) {\n      t = fabsf(x[i] - x[j]);\n      if (t < min) {\n        min = t;\n        minmax[0] = x[i];\n        minmax[1] = x[j];\n      }\n    }\n  }\n  if (minmax[0] > minmax[1]) {\n    t = minmax[0];\n    minmax[0] = minmax[1];\n    minmax[1] = t;\n  }\n}"
    },
    {
      "task_id": 20,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  movss  0xeec(%rip),%xmm0        # 2000 <_fini+0xd9c>\n  movss  %xmm0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0x38(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  movss  0x4(%rax),%xmm0\n  movss  %xmm0,(%rdx)\n  movl   $0x0,-0x10(%rbp)\n  jmp    1209 <func0+0x110>\n  mov    -0x10(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    11f9 <func0+0x100>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  subss  %xmm1,%xmm0\n  movss  0xe7c(%rip),%xmm1        # 2010 <_fini+0xdac>\n  andps  %xmm1,%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  movss  -0x14(%rbp),%xmm0\n  comiss -0x4(%rbp),%xmm0\n  jbe    11f5 <func0+0xfc>\n  movss  -0x4(%rbp),%xmm0\n  movss  %xmm0,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1158 <func0+0x5f>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     114a <func0+0x51>\n  mov    -0x38(%rbp),%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  ja     1230 <func0+0x137>\n  jmp    125f <func0+0x166>\n  mov    -0x38(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  mov    -0x38(%rbp),%rax\n  movss  0x4(%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  -0x8(%rbp),%xmm0\n  movss  %xmm0,(%rax)\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  movss  D0(%rip),%xmm0\n  movss  %xmm0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0x38(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  movss  0x4(%rax),%xmm0\n  movss  %xmm0,(%rdx)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL4:\n  mov    -0x10(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    L1\nL3:\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  subss  %xmm1,%xmm0\n  movss  D1(%rip),%xmm1\n  andps  %xmm1,%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  movss  -0x14(%rbp),%xmm0\n  comiss -0x4(%rbp),%xmm0\n  jbe    L2\n  movss  -0x4(%rbp),%xmm0\n  movss  %xmm0,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL1:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L3\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L4\n  mov    -0x38(%rbp),%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  ja     L5\n  jmp    L6\nL5:\n  mov    -0x38(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  mov    -0x38(%rbp),%rax\n  movss  0x4(%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  -0x8(%rbp),%xmm0\n  movss  %xmm0,(%rax)\nL6:\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3820
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3708
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4617
        },
        "L1": {
          "label": "L1",
          "addr": 4601
        },
        "L2": {
          "label": "L2",
          "addr": 4597
        },
        "L3": {
          "label": "L3",
          "addr": 4440
        },
        "L4": {
          "label": "L4",
          "addr": 4426
        },
        "L5": {
          "label": "L5",
          "addr": 4656
        },
        "L6": {
          "label": "L6",
          "addr": 4703
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffff7f7f000000000000000000000000ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2010": {
            "type": "dword",
            "value": 2147483647
          },
          "0x2000": {
            "type": "byte[4]",
            "value": [
              255,
              255,
              127,
              127
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(float *p, int n, float *minmax) {\n  int i, j;\n  float diff, min;\n  min = 1.0e37f;\n  minmax[0] = p[0];\n  minmax[1] = p[1];\n  for (i = 0; i < n; i++) {\n    for (j = i + 1; j < n; j++) {\n      diff = fabsf(p[i] - p[j]);\n      if (diff < min) {\n        min = diff;\n        minmax[0] = p[i];\n        minmax[1] = p[j];\n      }\n    }\n  }\n  if (minmax[0] > minmax[1]) {\n    float tmp;\n    tmp = minmax[0];\n    minmax[0] = minmax[1];\n    minmax[1] = tmp;\n  }\n}"
    },
    {
      "task_id": 20,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm1\n  movss  %xmm1,0x4(%rdx)\n  test   %esi,%esi\n  jle    118b <func0+0x8b>\n  cmp    $0x1,%esi\n  je     1182 <func0+0x82>\n  movss  0xed9(%rip),%xmm2        # 2000 <_fini+0xe64>\n  mov    %rdi,%rcx\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  movss  0xed5(%rip),%xmm3        # 2010 <_fini+0xe74>\n  nopl   0x0(%rax,%rax,1)\n  mov    %r8,%rax\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rcx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rdi,%rax,4),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    116d <func0+0x6d>\n  movss  %xmm1,(%rdx)\n  movss  (%rdi,%rax,4),%xmm1\n  movaps %xmm0,%xmm2\n  movss  %xmm1,0x4(%rdx)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     1148 <func0+0x48>\n  add    $0x1,%r8\n  add    $0x4,%rcx\n  cmp    %r8,%r9\n  jne    1140 <func0+0x40>\n  movss  (%rdx),%xmm0\n  movss  0x4(%rdx),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1199 <func0+0x99>\n  movss  %xmm1,(%rdx)\n  movss  %xmm0,0x4(%rdx)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm1\n  movss  %xmm1,0x4(%rdx)\n  test   %esi,%esi\n  jle    L0\n  cmp    $0x1,%esi\n  je     L1\n  movss  D0(%rip),%xmm2\n  mov    %rdi,%rcx\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  movss  D1(%rip),%xmm3\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    %r8,%rax\n  nopl   0x0(%rax,%rax,1)\nL3:\n  movss  (%rcx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rdi,%rax,4),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    L2\n  movss  %xmm1,(%rdx)\n  movss  (%rdi,%rax,4),%xmm1\n  movaps %xmm0,%xmm2\n  movss  %xmm1,0x4(%rdx)\nL2:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L3\n  add    $0x1,%r8\n  add    $0x4,%rcx\n  cmp    %r8,%r9\n  jne    L4\nL1:\n  movss  (%rdx),%xmm0\n  movss  0x4(%rdx),%xmm1\nL0:\n  comiss %xmm1,%xmm0\n  jbe    L5\n  movss  %xmm1,(%rdx)\n  movss  %xmm0,0x4(%rdx)\nL5:\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3801
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3797
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4491
        },
        "L1": {
          "label": "L1",
          "addr": 4482
        },
        "L2": {
          "label": "L2",
          "addr": 4461
        },
        "L3": {
          "label": "L3",
          "addr": 4424
        },
        "L4": {
          "label": "L4",
          "addr": 4416
        },
        "L5": {
          "label": "L5",
          "addr": 4505
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffff7f7f000000000000000000000000ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2010": {
            "type": "dword",
            "value": 2147483647
          },
          "0x2000": {
            "type": "byte[4]",
            "value": [
              255,
              255,
              127,
              127
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(float *p, int n, float *minmax) {\n  int i, j;\n  float t;\n  minmax[0] = p[0];\n  minmax[1] = p[1];\n  for (i = 0; i < n; i++)\n    for (j = i + 1; j < n; j++) {\n      t = fabsf(p[i] - p[j]);\n      if (t < minmax[0]) {\n        minmax[0] = p[i];\n        minmax[1] = p[j];\n      }\n    }\n  if (minmax[0] > minmax[1]) {\n    t = minmax[0];\n    minmax[0] = minmax[1];\n    minmax[1] = t;\n  }\n}"
    },
    {
      "task_id": 23,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1112 <func0+0x19>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    110e <func0+0x15>\n  mov    -0x4(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L1\n  mov    -0x4(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4370
        },
        "L1": {
          "label": "L1",
          "addr": 4366
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str) {\n  int i;\n  for (i = 0; str[i]; i++)\n    ;\n  return i;\n}"
    },
    {
      "task_id": 20,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  mov    %rdx,%rcx\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm1\n  movss  %xmm1,0x4(%rdx)\n  test   %esi,%esi\n  jle    11ab <func0+0xab>\n  mov    %esi,%r9d\n  lea    0x4(%rdi),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    $0x1,%r8d\n  movss  0xec6(%rip),%xmm2        # 2000 <_fini+0xe44>\n  add    $0x8,%rdi\n  movss  0xeca(%rip),%xmm3        # 2010 <_fini+0xe54>\n  cmp    %r9,%r8\n  je     11a2 <func0+0xa2>\n  nopl   0x0(%rax,%rax,1)\n  mov    %r10d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rdi,%rax,4),%rsi\n  mov    %rdx,%rax\n  nopw   0x0(%rax,%rax,1)\n  movss  -0x4(%rdx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rax),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    118c <func0+0x8c>\n  movss  %xmm1,(%rcx)\n  movss  (%rax),%xmm1\n  movaps %xmm0,%xmm2\n  movss  %xmm1,0x4(%rcx)\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  jne    1168 <func0+0x68>\n  add    $0x1,%r8\n  add    $0x4,%rdx\n  cmp    %r9,%r8\n  jne    1150 <func0+0x50>\n  movss  (%rcx),%xmm0\n  movss  0x4(%rcx),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    11b9 <func0+0xb9>\n  movss  %xmm1,(%rcx)\n  movss  %xmm0,0x4(%rcx)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  mov    %rdx,%rcx\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm1\n  movss  %xmm1,0x4(%rdx)\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%r9d\n  lea    0x4(%rdi),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    $0x1,%r8d\n  movss  D0(%rip),%xmm2\n  add    $0x8,%rdi\n  movss  D1(%rip),%xmm3\n  cmp    %r9,%r8\n  je     L1\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    %r10d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rdi,%rax,4),%rsi\n  mov    %rdx,%rax\n  nopw   0x0(%rax,%rax,1)\nL3:\n  movss  -0x4(%rdx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rax),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    L2\n  movss  %xmm1,(%rcx)\n  movss  (%rax),%xmm1\n  movaps %xmm0,%xmm2\n  movss  %xmm1,0x4(%rcx)\nL2:\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  jne    L3\n  add    $0x1,%r8\n  add    $0x4,%rdx\n  cmp    %r9,%r8\n  jne    L4\nL1:\n  movss  (%rcx),%xmm0\n  movss  0x4(%rcx),%xmm1\nL0:\n  comiss %xmm1,%xmm0\n  jbe    L5\n  movss  %xmm1,(%rcx)\n  movss  %xmm0,0x4(%rcx)\nL5:\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3782
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3786
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4523
        },
        "L1": {
          "label": "L1",
          "addr": 4514
        },
        "L2": {
          "label": "L2",
          "addr": 4492
        },
        "L3": {
          "label": "L3",
          "addr": 4456
        },
        "L4": {
          "label": "L4",
          "addr": 4432
        },
        "L5": {
          "label": "L5",
          "addr": 4537
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffff7f7f000000000000000000000000ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2010": {
            "type": "dword",
            "value": 2147483647
          },
          "0x2000": {
            "type": "byte[4]",
            "value": [
              255,
              255,
              127,
              127
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(float *ptr, int N, float *minmax) {\n  int i, j;\n  float diff;\n  float *pi, *pj;\n  minmax[0] = *ptr;\n  minmax[1] = *(ptr + 1);\n  for (i = 0; i < N; i++) {\n    pi = ptr + i;\n    for (j = i + 1; j < N; j++) {\n      pj = ptr + j;\n      diff = fabsf(*pi - *pj);\n      if (diff < minmax[0]) {\n        minmax[0] = diff;\n        minmax[1] = *pj;\n      }\n    }\n  }\n  if (minmax[0] > minmax[1]) {\n    diff = minmax[0];\n    minmax[0] = minmax[1];\n    minmax[1] = diff;\n  }\n}"
    },
    {
      "task_id": 23,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     1117 <func0+0x1e>\n  mov    $0x1,%eax\n  mov    %eax,%edx\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    1107 <func0+0xe>\n  mov    %edx,%eax\n  ret\n  mov    $0x0,%edx\n  jmp    1114 <func0+0x1b>",
      "asm_labeled": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    $0x1,%eax\nL1:\n  mov    %eax,%edx\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    L1\nL2:\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x0,%edx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4375
        },
        "L1": {
          "label": "L1",
          "addr": 4359
        },
        "L2": {
          "label": "L2",
          "addr": 4372
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str) {\n  int i = 0;\n  while (str[i] != '\\0')\n    i++;\n  return i;\n}"
    },
    {
      "task_id": 23,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     1128 <func0+0x28>\n  mov    $0x1,%eax\n  xchg   %ax,%ax\n  mov    %eax,%r8d\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    1110 <func0+0x10>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    $0x1,%eax\n  xchg   %ax,%ax\nL1:\n  mov    %eax,%r8d\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4392
        },
        "L1": {
          "label": "L1",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str) {\n  int i = 0;\n  while (str[i] != '\\0')\n    i++;\n  return i;\n}"
    },
    {
      "task_id": 23,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     1128 <func0+0x28>\n  mov    $0x1,%eax\n  xchg   %ax,%ax\n  mov    %eax,%r8d\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    1110 <func0+0x10>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    $0x1,%eax\n  xchg   %ax,%ax\nL1:\n  mov    %eax,%r8d\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4392
        },
        "L1": {
          "label": "L1",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str) {\n  int i = 0;\n  while (str[i] != '\\0')\n    i++;\n  return i;\n}"
    },
    {
      "task_id": 17,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movw   $0x0,-0xb(%rbp)\n  movb   $0x0,-0x9(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strlen@plt>\n  add    $0x1,%eax\n  mov    %eax,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   1100 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x48(%rbp),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10c0 <strcpy@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strlen@plt>\n  mov    %rax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movw   $0x20,(%rax)\n  movl   $0x0,-0x30(%rbp)\n  jmp    1444 <func0+0x26b>\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  jne    13ff <func0+0x226>\n  lea    -0xb(%rbp),%rax\n  lea    0xd61(%rip),%rdx        # 2000 <_fini+0xb80>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    130b <func0+0x132>\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    12eb <func0+0x112>\n  cmpl   $0x0,-0x34(%rbp)\n  jle    12c3 <func0+0xea>\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    12c8 <func0+0xef>\n  mov    $0x4,%eax\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x4,(%rax)\n  lea    -0xb(%rbp),%rax\n  lea    0xcec(%rip),%rdx        # 2002 <_fini+0xb82>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    1382 <func0+0x1a9>\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    1362 <func0+0x189>\n  cmpl   $0x0,-0x34(%rbp)\n  jle    133a <func0+0x161>\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    133f <func0+0x166>\n  mov    $0x4,%eax\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x2,(%rax)\n  lea    -0xb(%rbp),%rax\n  lea    0xc78(%rip),%rdx        # 2005 <_fini+0xb85>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    13f9 <func0+0x220>\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    13d9 <func0+0x200>\n  cmpl   $0x0,-0x34(%rbp)\n  jle    13b1 <func0+0x1d8>\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    13b6 <func0+0x1dd>\n  mov    $0x4,%eax\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x1,(%rax)\n  movb   $0x0,-0xb(%rbp)\n  jmp    1440 <func0+0x267>\n  lea    -0xb(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  cmpq   $0x1,-0x18(%rbp)\n  ja     1440 <func0+0x267>\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  lea    -0xb(%rbp),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    %al,(%rdx)\n  mov    -0x18(%rbp),%rax\n  add    $0x1,%rax\n  movb   $0x0,-0xb(%rbp,%rax,1)\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     127c <func0+0xa3>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <free@plt>\n  mov    -0x50(%rbp),%rax\n  mov    -0x38(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     147d <func0+0x2a4>\n  call   10e0 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movw   $0x0,-0xb(%rbp)\n  movb   $0x0,-0x9(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  add    $0x1,%eax\n  mov    %eax,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x48(%rbp),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movw   $0x20,(%rax)\n  movl   $0x0,-0x30(%rbp)\n  jmp    L0\nL15:\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  jne    L1\n  lea    -0xb(%rbp),%rax\n  lea    D0(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L2\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    L3\n  cmpl   $0x0,-0x34(%rbp)\n  jle    L4\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    L5\nL4:\n  mov    $0x4,%eax\nL5:\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x28(%rbp)\nL3:\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x4,(%rax)\nL2:\n  lea    -0xb(%rbp),%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L6\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    L7\n  cmpl   $0x0,-0x34(%rbp)\n  jle    L8\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    L9\nL8:\n  mov    $0x4,%eax\nL9:\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x28(%rbp)\nL7:\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x2,(%rax)\nL6:\n  lea    -0xb(%rbp),%rax\n  lea    D2(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L10\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    L11\n  cmpl   $0x0,-0x34(%rbp)\n  jle    L12\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    L13\nL12:\n  mov    $0x4,%eax\nL13:\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x28(%rbp)\nL11:\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x1,(%rax)\nL10:\n  movb   $0x0,-0xb(%rbp)\n  jmp    L14\nL1:\n  lea    -0xb(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  cmpq   $0x1,-0x18(%rbp)\n  ja     L14\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  lea    -0xb(%rbp),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    %al,(%rdx)\n  mov    -0x18(%rbp),%rax\n  add    $0x1,%rax\n  movb   $0x0,-0xb(%rbp,%rax,1)\nL14:\n  addl   $0x1,-0x30(%rbp)\nL0:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L15\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x50(%rbp),%rax\n  mov    -0x38(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L16\n  call   <__stack_chk_fail@plt>\nL16:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3425
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8194,
          "bias": [
            3308
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8197,
          "bias": [
            3192
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5188
        },
        "L1": {
          "label": "L1",
          "addr": 5119
        },
        "L2": {
          "label": "L2",
          "addr": 4875
        },
        "L3": {
          "label": "L3",
          "addr": 4843
        },
        "L4": {
          "label": "L4",
          "addr": 4803
        },
        "L5": {
          "label": "L5",
          "addr": 4808
        },
        "L6": {
          "label": "L6",
          "addr": 4994
        },
        "L7": {
          "label": "L7",
          "addr": 4962
        },
        "L8": {
          "label": "L8",
          "addr": 4922
        },
        "L9": {
          "label": "L9",
          "addr": 4927
        },
        "L10": {
          "label": "L10",
          "addr": 5113
        },
        "L11": {
          "label": "L11",
          "addr": 5081
        },
        "L12": {
          "label": "L12",
          "addr": 5041
        },
        "L13": {
          "label": "L13",
          "addr": 5046
        },
        "L14": {
          "label": "L14",
          "addr": 5184
        },
        "L15": {
          "label": "L15",
          "addr": 4732
        },
        "L16": {
          "label": "L16",
          "addr": 5245
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6f006f7c002e7c00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"o\""
          },
          "0x2002": {
            "type": "string",
            "value": "\"o|\""
          },
          "0x2005": {
            "type": "string",
            "value": "\".|\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(char *str, int *len) {\n  int *arr = NULL;\n  int i, j, k, l = 0, m = 0;\n  char *s, tmp[3] = {0};\n  k = strlen(str) + 1;\n  s = (char *)malloc(k + 1);\n  strcpy(s, str);\n  strcat(s, \" \");\n  for (i = 0; i < k; i++) {\n    if (s[i] == ' ') {\n      if (!strcmp(tmp, \"o\")) {\n        if (l == m) {\n          m = m > 0 ? 2 * m : 4;\n          arr = (int *)realloc(arr, m * sizeof(int));\n        }\n        arr[l++] = 4;\n      }\n      if (!strcmp(tmp, \"o|\")) {\n        if (l == m) {\n          m = m > 0 ? 2 * m : 4;\n          arr = (int *)realloc(arr, m * sizeof(int));\n        }\n        arr[l++] = 2;\n      }\n      if (!strcmp(tmp, \".|\")) {\n        if (l == m) {\n          m = m > 0 ? 2 * m : 4;\n          arr = (int *)realloc(arr, m * sizeof(int));\n        }\n        arr[l++] = 1;\n      }\n      tmp[0] = '\\0';\n    } else {\n      j = strlen(tmp);\n      if (j < 2) {\n        tmp[j] = s[i];\n        tmp[j + 1] = '\\0';\n      }\n    }\n  }\n  free(s);\n  *len = l;\n  return arr;\n}"
    },
    {
      "task_id": 24,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    1127 <func0+0x2e>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1123 <func0+0x2a>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  jmp    1137 <func0+0x3e>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    110d <func0+0x14>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  jmp    L2\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L3\n  mov    $0x1,%eax\nL2:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4391
        },
        "L1": {
          "label": "L1",
          "addr": 4387
        },
        "L2": {
          "label": "L2",
          "addr": 4407
        },
        "L3": {
          "label": "L3",
          "addr": 4365
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i;\n  for (i = 2; i * i <= n; i++)\n    if (n % i == 0)\n      return n / i;\n  return 1;\n}"
    },
    {
      "task_id": 24,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    1135 <func0+0x35>\n  mov    $0x2,%ecx\n  test   $0x1,%dil\n  jne    1129 <func0+0x29>\n  jmp    1140 <func0+0x40>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1140 <func0+0x40>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  test   $0x1,%dil\n  jne    L1\n  jmp    L2\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\nL1:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L3\nL0:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4405
        },
        "L1": {
          "label": "L1",
          "addr": 4393
        },
        "L2": {
          "label": "L2",
          "addr": 4416
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i;\n  for (i = 2; i * i <= n; i++)\n    if (n % i == 0)\n      return n / i;\n  return 1;\n}"
    },
    {
      "task_id": 24,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    1135 <func0+0x3c>\n  test   $0x1,%dil\n  je     1128 <func0+0x2f>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     112f <func0+0x36>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    110d <func0+0x14>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret\n  mov    $0x2,%ecx\n  jmp    1122 <func0+0x29>\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    L0\n  test   $0x1,%dil\n  je     L1\n  mov    $0x2,%ecx\nL3:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     L2\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L3\nL4:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret\nL1:\n  mov    $0x2,%ecx\n  jmp    L4\nL2:\n  mov    $0x1,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4405
        },
        "L1": {
          "label": "L1",
          "addr": 4392
        },
        "L2": {
          "label": "L2",
          "addr": 4399
        },
        "L3": {
          "label": "L3",
          "addr": 4365
        },
        "L4": {
          "label": "L4",
          "addr": 4386
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i;\n  for (i = 2; i * i <= n; i++)\n    if (n % i == 0)\n      return n / i;\n  return 1;\n}"
    },
    {
      "task_id": 22,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x20(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  jmp    1269 <func0+0x110>\n  addq   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     11d3 <func0+0x7a>\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x800,%eax\n  test   %eax,%eax\n  jne    11d3 <func0+0x7a>\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2d,%al\n  jne    1190 <func0+0x37>\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     127a <func0+0x121>\n  lea    -0x18(%rbp),%rcx\n  mov    -0x10(%rbp),%rax\n  mov    $0xa,%edx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   1080 <strtol@plt>\n  mov    %eax,-0x1c(%rbp)\n  mov    -0x18(%rbp),%rax\n  cmp    %rax,-0x10(%rbp)\n  je     124b <func0+0xf2>\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  je     121d <func0+0xc4>\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    124b <func0+0xf2>\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  lea    0x2e29(%rip),%rdx        # 4060 <out.0>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rcx,%rdx,1)\n  jmp    1261 <func0+0x108>\n  mov    -0x18(%rbp),%rax\n  add    $0x1,%rax\n  mov    %rax,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     1261 <func0+0x108>\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    123f <func0+0xe6>\n  mov    -0x18(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1195 <func0+0x3c>\n  jmp    127b <func0+0x122>\n  nop\n  mov    -0x30(%rbp),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  lea    0x2dd5(%rip),%rax        # 4060 <out.0>\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     129f <func0+0x146>\n  call   1070 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x20(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  jmp    L0\nL2:\n  addq   $0x1,-0x10(%rbp)\nL8:\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L1\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x800,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2d,%al\n  jne    L2\nL1:\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L3\n  lea    -0x18(%rbp),%rcx\n  mov    -0x10(%rbp),%rax\n  mov    $0xa,%edx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strtol@plt>\n  mov    %eax,-0x1c(%rbp)\n  mov    -0x18(%rbp),%rax\n  cmp    %rax,-0x10(%rbp)\n  je     L4\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  je     L5\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L4\nL5:\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  lea    D0(%rip),%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rcx,%rdx,1)\n  jmp    L6\nL7:\n  mov    -0x18(%rbp),%rax\n  add    $0x1,%rax\n  mov    %rax,-0x18(%rbp)\nL4:\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L6\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    L7\nL6:\n  mov    -0x18(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L8\n  jmp    L9\nL3:\n  nop\nL9:\n  mov    -0x30(%rbp),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  lea    D0(%rip),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L10\n  call   <__stack_chk_fail@plt>\nL10:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 16480,
          "bias": [
            11817,
            11733
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4713
        },
        "L1": {
          "label": "L1",
          "addr": 4563
        },
        "L2": {
          "label": "L2",
          "addr": 4496
        },
        "L3": {
          "label": "L3",
          "addr": 4730
        },
        "L4": {
          "label": "L4",
          "addr": 4683
        },
        "L5": {
          "label": "L5",
          "addr": 4637
        },
        "L6": {
          "label": "L6",
          "addr": 4705
        },
        "L7": {
          "label": "L7",
          "addr": 4671
        },
        "L8": {
          "label": "L8",
          "addr": 4501
        },
        "L9": {
          "label": "L9",
          "addr": 4731
        },
        "L10": {
          "label": "L10",
          "addr": 4767
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int *func0(const char *s, int *outlen) {\n  static int buf[10];\n  int n = 0;\n  const char *p = s;\n  while (*p) {\n    while (*p && !((**(__const unsigned short *)(__ctype_b_loc()) + (unsigned int)(*p)) & 0x800) && *p != '-')\n      ++p;\n    if (*p) {\n      char *q;\n      int t = strtol(p, &q, 10);\n      if (q != p && (*q == ',' || !*q))\n        buf[n++] = t;\n      else\n        while (*q && *q != ',')\n          ++q;\n      p = q;\n    }\n  }\n  *outlen = n;\n  return buf;\n}"
    },
    {
      "task_id": 17,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  movw   $0x0,0x25(%rsp)\n  movb   $0x0,0x27(%rsp)\n  call   10d0 <strlen@plt>\n  mov    %rax,%rbp\n  lea    0x2(%rax),%edi\n  movslq %edi,%rdi\n  call   1100 <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  mov    %rbx,%rsi\n  mov    %rax,%rbx\n  mov    %rax,%rdi\n  call   10c0 <strcpy@plt>\n  mov    %rbx,%rdi\n  call   10d0 <strlen@plt>\n  movw   $0x20,(%rbx,%rax,1)\n  lea    0x1(%rbp),%eax\n  test   %eax,%eax\n  jle    13bb <func0+0x1e2>\n  mov    %ebp,%ebp\n  lea    0x1(%rbx,%rbp,1),%r15\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\n  movq   $0x0,0x8(%rsp)\n  lea    0x25(%rsp),%r13\n  jmp    130f <func0+0x136>\n  lea    0xd86(%rip),%rsi        # 2000 <_fini+0xbfc>\n  mov    %r13,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    12a1 <func0+0xc8>\n  cmp    %r14d,%ebp\n  je     1337 <func0+0x15e>\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x4,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\n  lea    0xd5a(%rip),%rsi        # 2002 <_fini+0xbfe>\n  mov    %r13,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    12cf <func0+0xf6>\n  cmp    %r14d,%ebp\n  je     1363 <func0+0x18a>\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x2,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\n  lea    0xd2f(%rip),%rsi        # 2005 <_fini+0xc01>\n  mov    %r13,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    12fd <func0+0x124>\n  cmp    %r14d,%ebp\n  je     138f <func0+0x1b6>\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x1,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\n  movb   $0x0,0x25(%rsp)\n  add    $0x1,%rbx\n  cmp    %r15,%rbx\n  je     13c9 <func0+0x1f0>\n  movzbl (%rbx),%r12d\n  cmp    $0x20,%r12b\n  je     1273 <func0+0x9a>\n  mov    %r13,%rdi\n  call   10d0 <strlen@plt>\n  cmp    $0x1,%rax\n  ja     1302 <func0+0x129>\n  mov    %r12b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\n  jmp    1302 <func0+0x129>\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    128f <func0+0xb6>\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    12bd <func0+0xe4>\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    12eb <func0+0x112>\n  mov    $0x0,%ebp\n  movq   $0x0,0x8(%rsp)\n  mov    0x10(%rsp),%rdi\n  call   10b0 <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %ebp,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    13fe <func0+0x225>\n  mov    0x8(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10e0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  movw   $0x0,0x25(%rsp)\n  movb   $0x0,0x27(%rsp)\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  lea    0x2(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  mov    %rbx,%rsi\n  mov    %rax,%rbx\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  movw   $0x20,(%rbx,%rax,1)\n  lea    0x1(%rbp),%eax\n  test   %eax,%eax\n  jle    L0\n  mov    %ebp,%ebp\n  lea    0x1(%rbx,%rbp,1),%r15\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\n  movq   $0x0,0x8(%rsp)\n  lea    0x25(%rsp),%r13\n  jmp    L1\nL9:\n  lea    D0(%rip),%rsi\n  mov    %r13,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L2\n  cmp    %r14d,%ebp\n  je     L3\nL11:\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x4,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\nL2:\n  lea    D1(%rip),%rsi\n  mov    %r13,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L4\n  cmp    %r14d,%ebp\n  je     L5\nL12:\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x2,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\nL4:\n  lea    D2(%rip),%rsi\n  mov    %r13,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L6\n  cmp    %r14d,%ebp\n  je     L7\nL13:\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x1,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\nL6:\n  movb   $0x0,0x25(%rsp)\nL10:\n  add    $0x1,%rbx\n  cmp    %r15,%rbx\n  je     L8\nL1:\n  movzbl (%rbx),%r12d\n  cmp    $0x20,%r12b\n  je     L9\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  cmp    $0x1,%rax\n  ja     L10\n  mov    %r12b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\n  jmp    L10\nL3:\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    L11\nL5:\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    L12\nL7:\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    L13\nL0:\n  mov    $0x0,%ebp\n  movq   $0x0,0x8(%rsp)\nL8:\n  mov    0x10(%rsp),%rdi\n  call   <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %ebp,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L14\n  mov    0x8(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL14:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3462
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8194,
          "bias": [
            3418
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8197,
          "bias": [
            3375
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5051
        },
        "L1": {
          "label": "L1",
          "addr": 4879
        },
        "L2": {
          "label": "L2",
          "addr": 4769
        },
        "L3": {
          "label": "L3",
          "addr": 4919
        },
        "L4": {
          "label": "L4",
          "addr": 4815
        },
        "L5": {
          "label": "L5",
          "addr": 4963
        },
        "L6": {
          "label": "L6",
          "addr": 4861
        },
        "L7": {
          "label": "L7",
          "addr": 5007
        },
        "L8": {
          "label": "L8",
          "addr": 5065
        },
        "L9": {
          "label": "L9",
          "addr": 4723
        },
        "L10": {
          "label": "L10",
          "addr": 4866
        },
        "L11": {
          "label": "L11",
          "addr": 4751
        },
        "L12": {
          "label": "L12",
          "addr": 4797
        },
        "L13": {
          "label": "L13",
          "addr": 4843
        },
        "L14": {
          "label": "L14",
          "addr": 5118
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6f006f7c002e7c00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"o\""
          },
          "0x2002": {
            "type": "string",
            "value": "\"o|\""
          },
          "0x2005": {
            "type": "string",
            "value": "\".|\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(char *s, int *len) {\n  int *a = NULL;\n  int i = 0, j = 0, k = 0, l = 0;\n  char *tmp = NULL;\n  char buf[5] = {0};\n  size_t size = strlen(s);\n  tmp = (char *)malloc(sizeof(char) * (size + 2));\n  strcpy(tmp, s);\n  tmp[strlen(tmp)] = ' ';\n  for (i = 0; i < (int)size + 1; i++) {\n    if (tmp[i] == ' ') {\n      if (!strcmp(buf, \"o\")) {\n        if (k == j) {\n          j = (j > 0) ? j * 2 : 4;\n          a = (int *)realloc(a, sizeof(int) * j);\n        }\n        a[k++] = 4;\n      }\n      if (!strcmp(buf, \"o|\")) {\n        if (k == j) {\n          j = (j > 0) ? j * 2 : 4;\n          a = (int *)realloc(a, sizeof(int) * j);\n        }\n        a[k++] = 2;\n      }\n      if (!strcmp(buf, \".|\")) {\n        if (k == j) {\n          j = (j > 0) ? j * 2 : 4;\n          a = (int *)realloc(a, sizeof(int) * j);\n        }\n        a[k++] = 1;\n      }\n      buf[0] = '\\0';\n    } else {\n      l = strlen(buf);\n      if (l < 2) {\n        buf[l] = tmp[i];\n        buf[l + 1] = '\\0';\n      }\n    }\n  }\n  free(tmp);\n  *len = k;\n  return a;\n}"
    },
    {
      "task_id": 24,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    1135 <func0+0x35>\n  mov    $0x2,%ecx\n  test   $0x1,%dil\n  jne    1129 <func0+0x29>\n  jmp    1140 <func0+0x40>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1140 <func0+0x40>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  test   $0x1,%dil\n  jne    L1\n  jmp    L2\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\nL1:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L3\nL0:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4405
        },
        "L1": {
          "label": "L1",
          "addr": 4393
        },
        "L2": {
          "label": "L2",
          "addr": 4416
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i;\n  for (i = 2; i * i <= n; i++)\n    if (n % i == 0)\n      return n / i;\n  return 1;\n}"
    },
    {
      "task_id": 17,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  movb   $0x0,0x27(%rsp)\n  mov    %ax,0x25(%rsp)\n  call   10b0 <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbp\n  movslq %edi,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rbp,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x10(%rsp)\n  call   10d0 <memcpy@plt>\n  mov    $0x20,%edx\n  lea    0x1(%rbp),%eax\n  mov    %dx,(%rbx,%rbp,1)\n  test   %eax,%eax\n  jle    1400 <func0+0x240>\n  mov    %ebp,%ebp\n  movl   $0x0,0xc(%rsp)\n  xor    %r15d,%r15d\n  lea    0x25(%rsp),%r14\n  lea    0x1(%rbx,%rbp,1),%r12\n  xor    %ebp,%ebp\n  jmp    1275 <func0+0xb5>\n  xchg   %ax,%ax\n  mov    %r14,%rdi\n  call   10b0 <strlen@plt>\n  cmp    $0x2,%rax\n  je     1268 <func0+0xa8>\n  mov    %r13b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\n  add    $0x1,%rbx\n  cmp    %rbx,%r12\n  je     1314 <func0+0x154>\n  movzbl (%rbx),%r13d\n  cmp    $0x20,%r13b\n  jne    1250 <func0+0x90>\n  cmpb   $0x6f,(%r14)\n  jne    12a6 <func0+0xe6>\n  cmpb   $0x0,0x1(%r14)\n  jne    12a6 <func0+0xe6>\n  cmp    0xc(%rsp),%r15d\n  je     1350 <func0+0x190>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x4,0x0(%rbp,%rax,4)\n  cmpb   $0x6f,(%r14)\n  jne    12d4 <func0+0x114>\n  cmpb   $0x7c,0x1(%r14)\n  jne    12d4 <func0+0x114>\n  cmpb   $0x0,0x2(%r14)\n  jne    12d4 <func0+0x114>\n  cmp    0xc(%rsp),%r15d\n  je     13a0 <func0+0x1e0>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x2,0x0(%rbp,%rax,4)\n  cmpb   $0x2e,(%r14)\n  jne    1302 <func0+0x142>\n  cmpb   $0x7c,0x1(%r14)\n  jne    1302 <func0+0x142>\n  cmpb   $0x0,0x2(%r14)\n  jne    1302 <func0+0x142>\n  cmp    0xc(%rsp),%r15d\n  je     1378 <func0+0x1b8>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x1,0x0(%rbp,%rax,4)\n  add    $0x1,%rbx\n  movb   $0x0,0x25(%rsp)\n  cmp    %rbx,%r12\n  jne    1275 <func0+0xb5>\n  mov    0x10(%rsp),%rdi\n  call   10a0 <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    140a <func0+0x24a>\n  add    $0x38,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13c8 <func0+0x208>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    1297 <func0+0xd7>\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13f0 <func0+0x230>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    12f3 <func0+0x133>\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13e0 <func0+0x220>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    12c5 <func0+0x105>\n  nopl   0x0(%rax)\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    1364 <func0+0x1a4>\n  nopw   0x0(%rax,%rax,1)\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    13b4 <func0+0x1f4>\n  nop\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    138c <func0+0x1cc>\n  nop\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  jmp    1314 <func0+0x154>\n  call   10c0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  movb   $0x0,0x27(%rsp)\n  mov    %ax,0x25(%rsp)\n  call   <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbp\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rbp,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x10(%rsp)\n  call   <memcpy@plt>\n  mov    $0x20,%edx\n  lea    0x1(%rbp),%eax\n  mov    %dx,(%rbx,%rbp,1)\n  test   %eax,%eax\n  jle    L0\n  mov    %ebp,%ebp\n  movl   $0x0,0xc(%rsp)\n  xor    %r15d,%r15d\n  lea    0x25(%rsp),%r14\n  lea    0x1(%rbx,%rbp,1),%r12\n  xor    %ebp,%ebp\n  jmp    L1\n  xchg   %ax,%ax\nL4:\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  cmp    $0x2,%rax\n  je     L2\n  mov    %r13b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\nL2:\n  add    $0x1,%rbx\n  cmp    %rbx,%r12\n  je     L3\nL1:\n  movzbl (%rbx),%r13d\n  cmp    $0x20,%r13b\n  jne    L4\n  cmpb   $0x6f,(%r14)\n  jne    L5\n  cmpb   $0x0,0x1(%r14)\n  jne    L5\n  cmp    0xc(%rsp),%r15d\n  je     L6\nL13:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x4,0x0(%rbp,%rax,4)\nL5:\n  cmpb   $0x6f,(%r14)\n  jne    L7\n  cmpb   $0x7c,0x1(%r14)\n  jne    L7\n  cmpb   $0x0,0x2(%r14)\n  jne    L7\n  cmp    0xc(%rsp),%r15d\n  je     L8\nL17:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x2,0x0(%rbp,%rax,4)\nL7:\n  cmpb   $0x2e,(%r14)\n  jne    L9\n  cmpb   $0x7c,0x1(%r14)\n  jne    L9\n  cmpb   $0x0,0x2(%r14)\n  jne    L9\n  cmp    0xc(%rsp),%r15d\n  je     L10\nL15:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x1,0x0(%rbp,%rax,4)\nL9:\n  add    $0x1,%rbx\n  movb   $0x0,0x25(%rsp)\n  cmp    %rbx,%r12\n  jne    L1\nL3:\n  mov    0x10(%rsp),%rdi\n  call   <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L11\n  add    $0x38,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL6:\n  test   %r15d,%r15d\n  jle    L12\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL18:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L13\n  nopl   0x0(%rax)\nL10:\n  test   %r15d,%r15d\n  jle    L14\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL20:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L15\n  nopl   0x0(%rax)\nL8:\n  test   %r15d,%r15d\n  jle    L16\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL19:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L17\n  nopl   0x0(%rax)\nL12:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L18\n  nopw   0x0(%rax,%rax,1)\nL16:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L19\n  nop\nL14:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L20\n  nop\nL0:\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  jmp    L3\nL11:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 5120
        },
        "L1": {
          "label": "L1",
          "addr": 4725
        },
        "L2": {
          "label": "L2",
          "addr": 4712
        },
        "L3": {
          "label": "L3",
          "addr": 4884
        },
        "L4": {
          "label": "L4",
          "addr": 4688
        },
        "L5": {
          "label": "L5",
          "addr": 4774
        },
        "L6": {
          "label": "L6",
          "addr": 4944
        },
        "L7": {
          "label": "L7",
          "addr": 4820
        },
        "L8": {
          "label": "L8",
          "addr": 5024
        },
        "L9": {
          "label": "L9",
          "addr": 4866
        },
        "L10": {
          "label": "L10",
          "addr": 4984
        },
        "L11": {
          "label": "L11",
          "addr": 5130
        },
        "L12": {
          "label": "L12",
          "addr": 5064
        },
        "L13": {
          "label": "L13",
          "addr": 4759
        },
        "L14": {
          "label": "L14",
          "addr": 5104
        },
        "L15": {
          "label": "L15",
          "addr": 4851
        },
        "L16": {
          "label": "L16",
          "addr": 5088
        },
        "L17": {
          "label": "L17",
          "addr": 4805
        },
        "L18": {
          "label": "L18",
          "addr": 4964
        },
        "L19": {
          "label": "L19",
          "addr": 5044
        },
        "L20": {
          "label": "L20",
          "addr": 5004
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(char *s, int *len) {\n  int *a = NULL;\n  char *tmp = NULL;\n  char buf[5] = {0};\n  int i = 0, j = 0, k = 0, l = 0;\n  size_t size = strlen(s);\n  tmp = (char *)malloc(size + 2);\n  memcpy(tmp, s, size);\n  tmp[size] = ' ';\n  tmp[size + 1] = '\\0';\n  for (i = 0; i < (int)size + 1; i++) {\n    if (tmp[i] == ' ') {\n      if (!strcmp(buf, \"o\") && k == l) {\n        if (k > 0)\n          l = k * 2;\n        else\n          l = 4;\n        a = (int *)realloc(a, l * sizeof(int));\n      }\n      if (!strcmp(buf, \"o|\")) {\n        if (k > 0)\n          l = k * 2;\n        else\n          l = 4;\n        a = (int *)realloc(a, l * sizeof(int));\n        a[j++] = 4;\n      }\n      if (!strcmp(buf, \"o.|\")) {\n        if (k > 0)\n          l = k * 2;\n        else\n          l = 4;\n        a = (int *)realloc(a, l * sizeof(int));\n        a[j++] = 1;\n      }\n      if (!strcmp(buf, \".\")) {\n        if (k > 0)\n          l = k * 2;\n        else\n          l = 4;\n        a = (int *)realloc(a, l * sizeof(int));\n        a[j++] = 2;\n      }\n      memset(buf, 0, sizeof(buf));\n    } else {\n      size_t size = strlen(buf);\n      if (size < 3) {\n        buf[size] = tmp[i];\n        buf[size + 1] = '\\0';\n      }\n    }\n  }\n  free(tmp);\n  *len = j;\n  return a;\n}"
    },
    {
      "task_id": 25,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    $0x100,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x20(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x2,-0xc(%rbp)\n  jmp    118d <func0+0x74>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %eax,-0x14(%rbp)\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x20(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  je     114d <func0+0x34>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    117c <func0+0x63>\n  cmpl   $0x1,-0x14(%rbp)\n  jle    11c3 <func0+0xaa>\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x20(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    $0x100,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x20(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x2,-0xc(%rbp)\n  jmp    L0\nL1:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %eax,-0x14(%rbp)\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x20(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  je     L1\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L2\n  cmpl   $0x1,-0x14(%rbp)\n  jle    L3\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x20(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\nL3:\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4493
        },
        "L1": {
          "label": "L1",
          "addr": 4429
        },
        "L2": {
          "label": "L2",
          "addr": 4476
        },
        "L3": {
          "label": "L3",
          "addr": 4547
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int x, int *sz) {\n  int *a = malloc(sizeof(int) * 64);\n  *sz = 0;\n  for (int i = 2; i * i <= x; i++) {\n    while (x % i == 0) {\n      x /= i;\n      a[(*sz)++] = i;\n    }\n  }\n  if (x > 1)\n    a[(*sz)++] = x;\n  return a;\n}"
    },
    {
      "task_id": 22,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,%r15\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%ebx\n  mov    $0x0,%r13d\n  test   %bl,%bl\n  je     1207 <func0+0xae>\n  mov    %rdi,%rbp\n  call   1090 <__ctype_b_loc@plt>\n  mov    %rax,%r12\n  mov    $0x0,%r13d\n  lea    0x2ebd(%rip),%r14        # 4060 <out.0>\n  jmp    11e7 <func0+0x8e>\n  test   %bl,%bl\n  je     1207 <func0+0xae>\n  mov    %rsp,%rsi\n  mov    $0xa,%edx\n  mov    %rbp,%rdi\n  call   1080 <strtol@plt>\n  mov    (%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     1230 <func0+0xd7>\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     11ce <func0+0x75>\n  test   %cl,%cl\n  jne    123c <func0+0xe3>\n  movslq %r13d,%rdx\n  mov    %eax,(%r14,%rdx,4)\n  lea    0x1(%r13),%r13d\n  mov    (%rsp),%rax\n  movzbl (%rax),%ebx\n  test   %bl,%bl\n  je     1207 <func0+0xae>\n  mov    %rax,%rbp\n  movsbq %bl,%rax\n  mov    (%r12),%rdx\n  testb  $0x8,0x1(%rdx,%rax,2)\n  jne    11a5 <func0+0x4c>\n  cmp    $0x2d,%bl\n  je     11a5 <func0+0x4c>\n  lea    0x1(%rbp),%rax\n  movzbl 0x1(%rbp),%ebx\n  test   %bl,%bl\n  jne    11e4 <func0+0x8b>\n  mov    %r13d,(%r15)\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1256 <func0+0xfd>\n  lea    0x2e3f(%rip),%rax        # 4060 <out.0>\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  movzbl 0x0(%rbp),%eax\n  test   %al,%al\n  je     11d9 <func0+0x80>\n  cmp    $0x2c,%al\n  je     11d9 <func0+0x80>\n  lea    0x1(%rdx),%rax\n  mov    %rax,(%rsp)\n  movzbl (%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  je     11d9 <func0+0x80>\n  cmp    $0x2c,%dl\n  jne    1240 <func0+0xe7>\n  jmp    11d9 <func0+0x80>\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,%r15\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%ebx\n  mov    $0x0,%r13d\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r12\n  mov    $0x0,%r13d\n  lea    D0(%rip),%r14\n  jmp    L1\nL5:\n  test   %bl,%bl\n  je     L0\n  mov    %rsp,%rsi\n  mov    $0xa,%edx\n  mov    %rbp,%rdi\n  call   <strtol@plt>\n  mov    (%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     L2\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     L3\n  test   %cl,%cl\n  jne    L4\nL3:\n  movslq %r13d,%rdx\n  mov    %eax,(%r14,%rdx,4)\n  lea    0x1(%r13),%r13d\nL8:\n  mov    (%rsp),%rax\n  movzbl (%rax),%ebx\n  test   %bl,%bl\n  je     L0\nL6:\n  mov    %rax,%rbp\nL1:\n  movsbq %bl,%rax\n  mov    (%r12),%rdx\n  testb  $0x8,0x1(%rdx,%rax,2)\n  jne    L5\n  cmp    $0x2d,%bl\n  je     L5\n  lea    0x1(%rbp),%rax\n  movzbl 0x1(%rbp),%ebx\n  test   %bl,%bl\n  jne    L6\nL0:\n  mov    %r13d,(%r15)\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  lea    D0(%rip),%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL2:\n  movzbl 0x0(%rbp),%eax\n  test   %al,%al\n  je     L8\n  cmp    $0x2c,%al\n  je     L8\nL4:\n  lea    0x1(%rdx),%rax\nL9:\n  mov    %rax,(%rsp)\n  movzbl (%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  je     L8\n  cmp    $0x2c,%dl\n  jne    L9\n  jmp    L8\nL7:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 16480,
          "bias": [
            11965,
            11839
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4615
        },
        "L1": {
          "label": "L1",
          "addr": 4583
        },
        "L2": {
          "label": "L2",
          "addr": 4656
        },
        "L3": {
          "label": "L3",
          "addr": 4558
        },
        "L4": {
          "label": "L4",
          "addr": 4668
        },
        "L5": {
          "label": "L5",
          "addr": 4517
        },
        "L6": {
          "label": "L6",
          "addr": 4580
        },
        "L7": {
          "label": "L7",
          "addr": 4694
        },
        "L8": {
          "label": "L8",
          "addr": 4569
        },
        "L9": {
          "label": "L9",
          "addr": 4672
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int *func0(const char *s, int *p) {\n  static int a[100];\n  int i = 0;\n  while (*s) {\n    const unsigned char *to = (const unsigned char *)s;\n    char *end;\n    int j;\n    if (((_CTYPE_DISC_DATA_1[(*(to))] & 0x08) != 0) || *to == '-') {\n      if (*to == 0)\n        break;\n      j = strtol(s, &end, 10);\n      if (end == s) {\n        if (*s == 0 || *s == ',')\n          goto o;\n      } else {\n        if (*end == ',' || *end == 0)\n          goto k;\n      }\n      s = end + 1;\n      while (*s && *s != ',')\n        s++;\n      continue;\n    k:\n      a[i++] = j;\n    o:\n      s = end;\n    }\n    if (*s)\n      s++;\n  }\n  *p = i;\n  return a;\n}"
    },
    {
      "task_id": 25,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %edi,%ebx\n  mov    %rsi,%rbp\n  mov    $0x100,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,%r10\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  cmp    $0x3,%ebx\n  jg     119e <func0+0x85>\n  cmp    $0x1,%ebx\n  jle    115a <func0+0x41>\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  cltq\n  mov    %ebx,(%r10,%rax,4)\n  mov    %r10,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  cltq\n  lea    (%r10,%rax,4),%rsi\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%ebx\n  mov    %edi,%r9d\n  mov    %ecx,(%rsi)\n  add    $0x1,%rdi\n  add    $0x4,%rsi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1173 <func0+0x5a>\n  mov    %r9d,0x0(%rbp)\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     1146 <func0+0x2d>\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1164 <func0+0x4b>\n  jmp    1192 <func0+0x79>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %edi,%ebx\n  mov    %rsi,%rbp\n  mov    $0x100,%edi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  cmp    $0x3,%ebx\n  jg     L0\nL3:\n  cmp    $0x1,%ebx\n  jle    L1\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  cltq\n  mov    %ebx,(%r10,%rax,4)\nL1:\n  mov    %r10,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL4:\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  cltq\n  lea    (%r10,%rax,4),%rsi\nL2:\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%ebx\n  mov    %edi,%r9d\n  mov    %ecx,(%rsi)\n  add    $0x1,%rdi\n  add    $0x4,%rsi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\n  mov    %r9d,0x0(%rbp)\nL5:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     L3\nL0:\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L4\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4510
        },
        "L1": {
          "label": "L1",
          "addr": 4442
        },
        "L2": {
          "label": "L2",
          "addr": 4467
        },
        "L3": {
          "label": "L3",
          "addr": 4422
        },
        "L4": {
          "label": "L4",
          "addr": 4452
        },
        "L5": {
          "label": "L5",
          "addr": 4498
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int x, int *sz) {\n  int *ret = malloc(sizeof(int) * 64);\n  int i;\n  *sz = 0;\n  for (i = 2; i * i <= x; i++) {\n    while (x % i == 0) {\n      x /= i;\n      ret[(*sz)++] = i;\n    }\n  }\n  if (x > 1)\n    ret[(*sz)++] = x;\n  return ret;\n}"
    },
    {
      "task_id": 22,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  lea    0x2eee(%rip),%r14        # 4060 <out.0>\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rsi,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    %rdi,%rbp\n  xor    %r15d,%r15d\n  lea    0x10(%rsp),%r13\n  call   1090 <__ctype_b_loc@plt>\n  lea    0x2ead(%rip),%r14        # 4060 <out.0>\n  mov    (%rax),%rcx\n  mov    %rax,%r12\n  jmp    11d4 <func0+0x74>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x2d,%bl\n  je     11df <func0+0x7f>\n  movzbl 0x1(%rbp),%ebx\n  lea    0x1(%rbp),%rdx\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    %rdx,%rbp\n  movsbq %bl,%rax\n  testb  $0x8,0x1(%rcx,%rax,2)\n  je     11c0 <func0+0x60>\n  mov    $0xa,%edx\n  mov    %r13,%rsi\n  mov    %rbp,%rdi\n  call   1080 <strtol@plt>\n  mov    0x10(%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     1220 <func0+0xc0>\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     1205 <func0+0xa5>\n  test   %cl,%cl\n  jne    122d <func0+0xcd>\n  movslq %r15d,%rcx\n  add    $0x1,%r15d\n  mov    %eax,(%r14,%rcx,4)\n  movzbl (%rdx),%ebx\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    (%r12),%rcx\n  jmp    11d1 <func0+0x71>\n  nopl   (%rax)\n  movzbl 0x0(%rbp),%ebx\n  cmp    $0x2c,%bl\n  je     127a <func0+0x11a>\n  test   %bl,%bl\n  je     127a <func0+0x11a>\n  lea    0x1(%rdx),%rax\n  jmp    123d <func0+0xdd>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x2c,%bl\n  je     1213 <func0+0xb3>\n  mov    %rax,0x10(%rsp)\n  movzbl (%rax),%ebx\n  mov    %rax,%rdx\n  add    $0x1,%rax\n  test   %bl,%bl\n  jne    1238 <func0+0xd8>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    127f <func0+0x11f>\n  add    $0x28,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    %rbp,%rdx\n  jmp    1213 <func0+0xb3>\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  lea    D0(%rip),%r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rsi,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  xor    %r15d,%r15d\n  lea    0x10(%rsp),%r13\n  call   <__ctype_b_loc@plt>\n  lea    D0(%rip),%r14\n  mov    (%rax),%rcx\n  mov    %rax,%r12\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    $0x2d,%bl\n  je     L2\n  movzbl 0x1(%rbp),%ebx\n  lea    0x1(%rbp),%rdx\n  test   %bl,%bl\n  je     L0\nL7:\n  mov    %rdx,%rbp\nL1:\n  movsbq %bl,%rax\n  testb  $0x8,0x1(%rcx,%rax,2)\n  je     L3\nL2:\n  mov    $0xa,%edx\n  mov    %r13,%rsi\n  mov    %rbp,%rdi\n  call   <strtol@plt>\n  mov    0x10(%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     L4\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     L5\n  test   %cl,%cl\n  jne    L6\nL5:\n  movslq %r15d,%rcx\n  add    $0x1,%r15d\n  mov    %eax,(%r14,%rcx,4)\n  movzbl (%rdx),%ebx\nL10:\n  test   %bl,%bl\n  je     L0\n  mov    (%r12),%rcx\n  jmp    L7\n  nopl   (%rax)\nL4:\n  movzbl 0x0(%rbp),%ebx\n  cmp    $0x2c,%bl\n  je     L8\n  test   %bl,%bl\n  je     L8\nL6:\n  lea    0x1(%rdx),%rax\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL11:\n  cmp    $0x2c,%bl\n  je     L10\nL9:\n  mov    %rax,0x10(%rsp)\n  movzbl (%rax),%ebx\n  mov    %rax,%rdx\n  add    $0x1,%rax\n  test   %bl,%bl\n  jne    L11\nL0:\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L12\n  add    $0x28,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  mov    %rbp,%rdx\n  jmp    L10\nL12:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 16480,
          "bias": [
            12014,
            11949
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4688
        },
        "L1": {
          "label": "L1",
          "addr": 4564
        },
        "L2": {
          "label": "L2",
          "addr": 4575
        },
        "L3": {
          "label": "L3",
          "addr": 4544
        },
        "L4": {
          "label": "L4",
          "addr": 4640
        },
        "L5": {
          "label": "L5",
          "addr": 4613
        },
        "L6": {
          "label": "L6",
          "addr": 4653
        },
        "L7": {
          "label": "L7",
          "addr": 4561
        },
        "L8": {
          "label": "L8",
          "addr": 4730
        },
        "L9": {
          "label": "L9",
          "addr": 4669
        },
        "L10": {
          "label": "L10",
          "addr": 4627
        },
        "L11": {
          "label": "L11",
          "addr": 4664
        },
        "L12": {
          "label": "L12",
          "addr": 4735
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(const char *a, int *b) {\n  static int c[10];\n  int d = 0;\n  char *e;\n  const unsigned char *f = (const unsigned char *)a;\n  const unsigned short int *g;\n  int h;\n  while (*f != '\\0') {\n    g = __ctype_b_loc();\n    if (((g[*f + 1] & 8) != 0) || *f == '-') {\n      h = strtol((char *)f, &e, 10);\n      if (e == f || (*e != ',' && *e != '\\0')) {\n        while (*e != '\\0') {\n          if (*e == ',')\n            break;\n          e++;\n        }\n      }\n      c[d++] = h;\n      f = (const unsigned char *)e;\n    } else {\n      f++;\n    }\n  }\n  *b = d;\n  return c;\n}"
    },
    {
      "task_id": 22,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  lea    0x2eee(%rip),%r14        # 4060 <out.0>\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rsi,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    %rdi,%rbp\n  xor    %r15d,%r15d\n  lea    0x10(%rsp),%r13\n  call   1090 <__ctype_b_loc@plt>\n  lea    0x2ead(%rip),%r14        # 4060 <out.0>\n  mov    (%rax),%rcx\n  mov    %rax,%r12\n  jmp    11d4 <func0+0x74>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x2d,%bl\n  je     11df <func0+0x7f>\n  movzbl 0x1(%rbp),%ebx\n  lea    0x1(%rbp),%rdx\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    %rdx,%rbp\n  movsbq %bl,%rax\n  testb  $0x8,0x1(%rcx,%rax,2)\n  je     11c0 <func0+0x60>\n  mov    $0xa,%edx\n  mov    %r13,%rsi\n  mov    %rbp,%rdi\n  call   1080 <strtol@plt>\n  mov    0x10(%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     1220 <func0+0xc0>\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     1205 <func0+0xa5>\n  test   %cl,%cl\n  jne    122d <func0+0xcd>\n  movslq %r15d,%rcx\n  add    $0x1,%r15d\n  mov    %eax,(%r14,%rcx,4)\n  movzbl (%rdx),%ebx\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    (%r12),%rcx\n  jmp    11d1 <func0+0x71>\n  nopl   (%rax)\n  movzbl 0x0(%rbp),%ebx\n  cmp    $0x2c,%bl\n  je     127a <func0+0x11a>\n  test   %bl,%bl\n  je     127a <func0+0x11a>\n  lea    0x1(%rdx),%rax\n  jmp    123d <func0+0xdd>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x2c,%bl\n  je     1213 <func0+0xb3>\n  mov    %rax,0x10(%rsp)\n  movzbl (%rax),%ebx\n  mov    %rax,%rdx\n  add    $0x1,%rax\n  test   %bl,%bl\n  jne    1238 <func0+0xd8>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    127f <func0+0x11f>\n  add    $0x28,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    %rbp,%rdx\n  jmp    1213 <func0+0xb3>\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  lea    D0(%rip),%r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rsi,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  xor    %r15d,%r15d\n  lea    0x10(%rsp),%r13\n  call   <__ctype_b_loc@plt>\n  lea    D0(%rip),%r14\n  mov    (%rax),%rcx\n  mov    %rax,%r12\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    $0x2d,%bl\n  je     L2\n  movzbl 0x1(%rbp),%ebx\n  lea    0x1(%rbp),%rdx\n  test   %bl,%bl\n  je     L0\nL7:\n  mov    %rdx,%rbp\nL1:\n  movsbq %bl,%rax\n  testb  $0x8,0x1(%rcx,%rax,2)\n  je     L3\nL2:\n  mov    $0xa,%edx\n  mov    %r13,%rsi\n  mov    %rbp,%rdi\n  call   <strtol@plt>\n  mov    0x10(%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     L4\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     L5\n  test   %cl,%cl\n  jne    L6\nL5:\n  movslq %r15d,%rcx\n  add    $0x1,%r15d\n  mov    %eax,(%r14,%rcx,4)\n  movzbl (%rdx),%ebx\nL10:\n  test   %bl,%bl\n  je     L0\n  mov    (%r12),%rcx\n  jmp    L7\n  nopl   (%rax)\nL4:\n  movzbl 0x0(%rbp),%ebx\n  cmp    $0x2c,%bl\n  je     L8\n  test   %bl,%bl\n  je     L8\nL6:\n  lea    0x1(%rdx),%rax\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL11:\n  cmp    $0x2c,%bl\n  je     L10\nL9:\n  mov    %rax,0x10(%rsp)\n  movzbl (%rax),%ebx\n  mov    %rax,%rdx\n  add    $0x1,%rax\n  test   %bl,%bl\n  jne    L11\nL0:\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L12\n  add    $0x28,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  mov    %rbp,%rdx\n  jmp    L10\nL12:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 16480,
          "bias": [
            12014,
            11949
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4688
        },
        "L1": {
          "label": "L1",
          "addr": 4564
        },
        "L2": {
          "label": "L2",
          "addr": 4575
        },
        "L3": {
          "label": "L3",
          "addr": 4544
        },
        "L4": {
          "label": "L4",
          "addr": 4640
        },
        "L5": {
          "label": "L5",
          "addr": 4613
        },
        "L6": {
          "label": "L6",
          "addr": 4653
        },
        "L7": {
          "label": "L7",
          "addr": 4561
        },
        "L8": {
          "label": "L8",
          "addr": 4730
        },
        "L9": {
          "label": "L9",
          "addr": 4669
        },
        "L10": {
          "label": "L10",
          "addr": 4627
        },
        "L11": {
          "label": "L11",
          "addr": 4664
        },
        "L12": {
          "label": "L12",
          "addr": 4735
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(const char *a, int *b) {\n  static int c[10];\n  int d = 0;\n  char *e;\n  const unsigned char *f = (const unsigned char *)a;\n  const unsigned short int *g;\n  int h;\n  while (*f != '\\0') {\n    g = __ctype_b_loc();\n    if (((g[*f + 1] & 8) != 0) || *f == '-') {\n      h = strtol((char *)f, &e, 10);\n      if (e == f || (*e != ',' && *e != '\\0')) {\n        while (*e != '\\0') {\n          if (*e == ',')\n            break;\n          e++;\n        }\n      }\n      c[d++] = h;\n      f = (const unsigned char *)e;\n    } else {\n      f++;\n    }\n  }\n  *b = d;\n  return c;\n}"
    },
    {
      "task_id": 25,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x100,%edi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  mov    %rax,%r8\n  cmp    $0x3,%ebx\n  jle    1190 <func0+0x70>\n  nopl   (%rax)\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    1184 <func0+0x64>\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%esi\n  movslq %esi,%rsi\n  nopw   0x0(%rax,%rax,1)\n  mov    %ebx,%eax\n  mov    %ecx,-0x4(%r8,%rsi,4)\n  mov    %esi,%edi\n  add    $0x1,%rsi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%ebx\n  idiv   %ecx\n  test   %edx,%edx\n  je     1168 <func0+0x48>\n  mov    %edi,0x0(%rbp)\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jle    1150 <func0+0x30>\n  cmp    $0x1,%ebx\n  jle    11a3 <func0+0x83>\n  movslq 0x0(%rbp),%rax\n  lea    0x1(%rax),%edx\n  mov    %ebx,(%r8,%rax,4)\n  mov    %edx,0x0(%rbp)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x100,%edi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  mov    %rax,%r8\n  cmp    $0x3,%ebx\n  jle    L0\n  nopl   (%rax)\nL3:\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L1\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%esi\n  movslq %esi,%rsi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    %ebx,%eax\n  mov    %ecx,-0x4(%r8,%rsi,4)\n  mov    %esi,%edi\n  add    $0x1,%rsi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%ebx\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\n  mov    %edi,0x0(%rbp)\nL1:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jle    L3\nL0:\n  cmp    $0x1,%ebx\n  jle    L4\n  movslq 0x0(%rbp),%rax\n  lea    0x1(%rax),%edx\n  mov    %ebx,(%r8,%rax,4)\n  mov    %edx,0x0(%rbp)\nL4:\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4496
        },
        "L1": {
          "label": "L1",
          "addr": 4484
        },
        "L2": {
          "label": "L2",
          "addr": 4456
        },
        "L3": {
          "label": "L3",
          "addr": 4432
        },
        "L4": {
          "label": "L4",
          "addr": 4515
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int x, int *y) {\n  int *ptr = malloc(sizeof(int) * 64);\n  int i;\n  *y = 0;\n  for (i = 2; i * i <= x; i++) {\n    while (x % i == 0) {\n      ptr[(*y)++] = i;\n      x /= i;\n    }\n  }\n  if (x > 1)\n    ptr[(*y)++] = x;\n  return ptr;\n}"
    },
    {
      "task_id": 25,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x100,%edi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  mov    %rax,%r8\n  cmp    $0x3,%ebx\n  jle    1190 <func0+0x70>\n  nopl   (%rax)\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    1184 <func0+0x64>\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%esi\n  movslq %esi,%rsi\n  nopw   0x0(%rax,%rax,1)\n  mov    %ebx,%eax\n  mov    %ecx,-0x4(%r8,%rsi,4)\n  mov    %esi,%edi\n  add    $0x1,%rsi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%ebx\n  idiv   %ecx\n  test   %edx,%edx\n  je     1168 <func0+0x48>\n  mov    %edi,0x0(%rbp)\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jle    1150 <func0+0x30>\n  cmp    $0x1,%ebx\n  jle    11a3 <func0+0x83>\n  movslq 0x0(%rbp),%rax\n  lea    0x1(%rax),%edx\n  mov    %ebx,(%r8,%rax,4)\n  mov    %edx,0x0(%rbp)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x100,%edi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  mov    %rax,%r8\n  cmp    $0x3,%ebx\n  jle    L0\n  nopl   (%rax)\nL3:\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L1\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%esi\n  movslq %esi,%rsi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    %ebx,%eax\n  mov    %ecx,-0x4(%r8,%rsi,4)\n  mov    %esi,%edi\n  add    $0x1,%rsi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%ebx\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\n  mov    %edi,0x0(%rbp)\nL1:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jle    L3\nL0:\n  cmp    $0x1,%ebx\n  jle    L4\n  movslq 0x0(%rbp),%rax\n  lea    0x1(%rax),%edx\n  mov    %ebx,(%r8,%rax,4)\n  mov    %edx,0x0(%rbp)\nL4:\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4496
        },
        "L1": {
          "label": "L1",
          "addr": 4484
        },
        "L2": {
          "label": "L2",
          "addr": 4456
        },
        "L3": {
          "label": "L3",
          "addr": 4432
        },
        "L4": {
          "label": "L4",
          "addr": 4515
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int x, int *y) {\n  int *ptr = malloc(sizeof(int) * 64);\n  int i;\n  *y = 0;\n  for (i = 2; i * i <= x; i++) {\n    while (x % i == 0) {\n      ptr[(*y)++] = i;\n      x /= i;\n    }\n  }\n  if (x > 1)\n    ptr[(*y)++] = x;\n  return ptr;\n}"
    },
    {
      "task_id": 19,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xb0,%rsp\n  mov    %rdi,-0xa8(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x90(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  lea    0xe6d(%rip),%rax        # 2000 <_fini+0xbd0>\n  mov    %rax,-0x60(%rbp)\n  lea    0xe67(%rip),%rax        # 2005 <_fini+0xbd5>\n  mov    %rax,-0x58(%rbp)\n  lea    0xe60(%rip),%rax        # 2009 <_fini+0xbd9>\n  mov    %rax,-0x50(%rbp)\n  lea    0xe59(%rip),%rax        # 200d <_fini+0xbdd>\n  mov    %rax,-0x48(%rbp)\n  lea    0xe54(%rip),%rax        # 2013 <_fini+0xbe3>\n  mov    %rax,-0x40(%rbp)\n  lea    0xe4e(%rip),%rax        # 2018 <_fini+0xbe8>\n  mov    %rax,-0x38(%rbp)\n  lea    0xe48(%rip),%rax        # 201d <_fini+0xbed>\n  mov    %rax,-0x30(%rbp)\n  lea    0xe41(%rip),%rax        # 2021 <_fini+0xbf1>\n  mov    %rax,-0x28(%rbp)\n  lea    0xe3c(%rip),%rax        # 2027 <_fini+0xbf7>\n  mov    %rax,-0x20(%rbp)\n  lea    0xe37(%rip),%rax        # 202d <_fini+0xbfd>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0xa0(%rbp)\n  mov    -0xa8(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     1314 <func0+0x1db>\n  movl   $0x0,-0x9c(%rbp)\n  jmp    124b <func0+0x112>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    %dl,-0xe(%rbp,%rax,1)\n  addl   $0x1,-0x9c(%rbp)\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     127f <func0+0x146>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1222 <func0+0xe9>\n  mov    -0x9c(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe(%rbp,%rax,1)\n  movl   $0x0,-0x98(%rbp)\n  jmp    12e2 <func0+0x1a9>\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  lea    -0xe(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  jne    12db <func0+0x1a2>\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    -0x90(%rbp,%rax,4),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    %edx,-0x90(%rbp,%rax,4)\n  jmp    12eb <func0+0x1b2>\n  addl   $0x1,-0x98(%rbp)\n  cmpl   $0x9,-0x98(%rbp)\n  jle    1298 <func0+0x15f>\n  mov    -0x9c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  add    %rax,-0xa8(%rbp)\n  mov    -0xa8(%rbp),%rax\n  sub    $0x1,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1216 <func0+0xdd>\n  movl   $0x0,-0x9c(%rbp)\n  jmp    13dd <func0+0x2a4>\n  movl   $0x0,-0x98(%rbp)\n  jmp    13bb <func0+0x282>\n  movl   $0x0,-0x94(%rbp)\n  jmp    1379 <func0+0x240>\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  mov    -0x94(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xa0(%rbp),%eax\n  cltq\n  lea    0x2cf8(%rip),%rcx        # 4060 <out.0>\n  mov    %dl,(%rax,%rcx,1)\n  addl   $0x1,-0x94(%rbp)\n  addl   $0x1,-0xa0(%rbp)\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  mov    -0x94(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    133e <func0+0x205>\n  mov    -0xa0(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xa0(%rbp)\n  cltq\n  lea    0x2cb0(%rip),%rdx        # 4060 <out.0>\n  movb   $0x20,(%rax,%rdx,1)\n  addl   $0x1,-0x98(%rbp)\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x90(%rbp,%rax,4),%eax\n  cmp    %eax,-0x98(%rbp)\n  jl     1332 <func0+0x1f9>\n  addl   $0x1,-0x9c(%rbp)\n  cmpl   $0x9,-0x9c(%rbp)\n  jle    1323 <func0+0x1ea>\n  cmpl   $0x0,-0xa0(%rbp)\n  jle    140b <func0+0x2d2>\n  mov    -0xa0(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  lea    0x2c5b(%rip),%rdx        # 4060 <out.0>\n  movb   $0x0,(%rax,%rdx,1)\n  jmp    1412 <func0+0x2d9>\n  movb   $0x0,0x2c4e(%rip)        # 4060 <out.0>\n  lea    0x2c47(%rip),%rax        # 4060 <out.0>\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     142d <func0+0x2f4>\n  call   1060 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xb0,%rsp\n  mov    %rdi,-0xa8(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x90(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x60(%rbp)\n  lea    D1(%rip),%rax\n  mov    %rax,-0x58(%rbp)\n  lea    D2(%rip),%rax\n  mov    %rax,-0x50(%rbp)\n  lea    D3(%rip),%rax\n  mov    %rax,-0x48(%rbp)\n  lea    D4(%rip),%rax\n  mov    %rax,-0x40(%rbp)\n  lea    D5(%rip),%rax\n  mov    %rax,-0x38(%rbp)\n  lea    D6(%rip),%rax\n  mov    %rax,-0x30(%rbp)\n  lea    D7(%rip),%rax\n  mov    %rax,-0x28(%rbp)\n  lea    D8(%rip),%rax\n  mov    %rax,-0x20(%rbp)\n  lea    D9(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0xa0(%rbp)\n  mov    -0xa8(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L0\nL8:\n  movl   $0x0,-0x9c(%rbp)\n  jmp    L1\nL3:\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    %dl,-0xe(%rbp,%rax,1)\n  addl   $0x1,-0x9c(%rbp)\nL1:\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L2\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L3\nL2:\n  mov    -0x9c(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe(%rbp,%rax,1)\n  movl   $0x0,-0x98(%rbp)\n  jmp    L4\nL7:\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  lea    -0xe(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L5\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    -0x90(%rbp,%rax,4),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    %edx,-0x90(%rbp,%rax,4)\n  jmp    L6\nL5:\n  addl   $0x1,-0x98(%rbp)\nL4:\n  cmpl   $0x9,-0x98(%rbp)\n  jle    L7\nL6:\n  mov    -0x9c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  add    %rax,-0xa8(%rbp)\n  mov    -0xa8(%rbp),%rax\n  sub    $0x1,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L8\nL0:\n  movl   $0x0,-0x9c(%rbp)\n  jmp    L9\nL14:\n  movl   $0x0,-0x98(%rbp)\n  jmp    L10\nL13:\n  movl   $0x0,-0x94(%rbp)\n  jmp    L11\nL12:\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  mov    -0x94(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xa0(%rbp),%eax\n  cltq\n  lea    D10(%rip),%rcx\n  mov    %dl,(%rax,%rcx,1)\n  addl   $0x1,-0x94(%rbp)\n  addl   $0x1,-0xa0(%rbp)\nL11:\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  mov    -0x94(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L12\n  mov    -0xa0(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xa0(%rbp)\n  cltq\n  lea    D10(%rip),%rdx\n  movb   $0x20,(%rax,%rdx,1)\n  addl   $0x1,-0x98(%rbp)\nL10:\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x90(%rbp,%rax,4),%eax\n  cmp    %eax,-0x98(%rbp)\n  jl     L13\n  addl   $0x1,-0x9c(%rbp)\nL9:\n  cmpl   $0x9,-0x9c(%rbp)\n  jle    L14\n  cmpl   $0x0,-0xa0(%rbp)\n  jle    L15\n  mov    -0xa0(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  lea    D10(%rip),%rdx\n  movb   $0x0,(%rax,%rdx,1)\n  jmp    L16\nL15:\n  movb   $0x0,D10(%rip)\nL16:\n  lea    D10(%rip),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L17\n  call   <__stack_chk_fail@plt>\nL17:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3693
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8197,
          "bias": [
            3687
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8201,
          "bias": [
            3680
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8205,
          "bias": [
            3673
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8211,
          "bias": [
            3668
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8216,
          "bias": [
            3662
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8221,
          "bias": [
            3656
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8225,
          "bias": [
            3649
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8231,
          "bias": [
            3644
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8237,
          "bias": [
            3639
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 16480,
          "bias": [
            11512,
            11440,
            11355,
            11342,
            11335
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4884
        },
        "L1": {
          "label": "L1",
          "addr": 4683
        },
        "L2": {
          "label": "L2",
          "addr": 4735
        },
        "L3": {
          "label": "L3",
          "addr": 4642
        },
        "L4": {
          "label": "L4",
          "addr": 4834
        },
        "L5": {
          "label": "L5",
          "addr": 4827
        },
        "L6": {
          "label": "L6",
          "addr": 4843
        },
        "L7": {
          "label": "L7",
          "addr": 4760
        },
        "L8": {
          "label": "L8",
          "addr": 4630
        },
        "L9": {
          "label": "L9",
          "addr": 5085
        },
        "L10": {
          "label": "L10",
          "addr": 5051
        },
        "L11": {
          "label": "L11",
          "addr": 4985
        },
        "L12": {
          "label": "L12",
          "addr": 4926
        },
        "L13": {
          "label": "L13",
          "addr": 4914
        },
        "L14": {
          "label": "L14",
          "addr": 4899
        },
        "L15": {
          "label": "L15",
          "addr": 5131
        },
        "L16": {
          "label": "L16",
          "addr": 5138
        },
        "L17": {
          "label": "L17",
          "addr": 5165
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "7a65726f006f6e650074776f00746872656500666f757200666976650073697800736576656e006569676874006e696e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"zero\""
          },
          "0x2021": {
            "type": "string",
            "value": "\"seven\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"one\""
          },
          "0x2027": {
            "type": "string",
            "value": "\"eight\""
          },
          "0x2009": {
            "type": "string",
            "value": "\"two\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"three\""
          },
          "0x202d": {
            "type": "string",
            "value": "\"nine\""
          },
          "0x2013": {
            "type": "string",
            "value": "\"four\""
          },
          "0x2018": {
            "type": "string",
            "value": "\"five\""
          },
          "0x201d": {
            "type": "string",
            "value": "\"six\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s) {\n  static char result[100];\n  int i, j, k, count[10] = {0};\n  char *str[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n  int len;\n  k = 0;\n  while (*s != '\\0') {\n    for (len = 0; s[len] != ' ' && s[len] != '\\0'; len++)\n      result[len] = s[len];\n    result[len] = '\\0';\n    for (i = 0; i < 10; i++)\n      if (strcmp(result, str[i]) == 0) {\n        count[i]++;\n        break;\n      }\n    s += len + 1;\n  }\n  for (len = 0; len < 10; len++)\n    for (i = 0; i < count[len]; i++) {\n      for (j = 0; str[len][j] != '\\0'; j++, k++)\n        result[k] = str[len][j];\n      result[k++] = ' ';\n    }\n  if (k > 0)\n    result[k - 1] = '\\0';\n  else\n    result[k] = '\\0';\n  return result;\n}"
    },
    {
      "task_id": 19,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,(%rsp)\n  movq   $0x0,0x8(%rsp)\n  movq   $0x0,0x10(%rsp)\n  movq   $0x0,0x18(%rsp)\n  movq   $0x0,0x20(%rsp)\n  lea    0xe6c(%rip),%rax        # 2000 <_fini+0xc98>\n  mov    %rax,0x30(%rsp)\n  lea    0xe65(%rip),%rax        # 2005 <_fini+0xc9d>\n  mov    %rax,0x38(%rsp)\n  lea    0xe5d(%rip),%rax        # 2009 <_fini+0xca1>\n  mov    %rax,0x40(%rsp)\n  lea    0xe55(%rip),%rax        # 200d <_fini+0xca5>\n  mov    %rax,0x48(%rsp)\n  lea    0xe4f(%rip),%rax        # 2013 <_fini+0xcab>\n  mov    %rax,0x50(%rsp)\n  lea    0xe48(%rip),%rax        # 2018 <_fini+0xcb0>\n  mov    %rax,0x58(%rsp)\n  lea    0xe41(%rip),%rax        # 201d <_fini+0xcb5>\n  mov    %rax,0x60(%rsp)\n  lea    0xe39(%rip),%rax        # 2021 <_fini+0xcb9>\n  mov    %rax,0x68(%rsp)\n  lea    0xe33(%rip),%rax        # 2027 <_fini+0xcbf>\n  mov    %rax,0x70(%rsp)\n  lea    0xe2d(%rip),%rax        # 202d <_fini+0xcc5>\n  mov    %rax,0x78(%rsp)\n  cmpb   $0x0,(%rdi)\n  je     1295 <func0+0x15c>\n  mov    %rdi,%rbp\n  lea    0x81(%rsp),%r15\n  lea    0x82(%rsp),%r14\n  jmp    1243 <func0+0x10a>\n  mov    $0x0,%ecx\n  mov    $0x0,%r13d\n  jmp    1268 <func0+0x12f>\n  movslq %ebx,%r12\n  addl   $0x1,(%rsp,%r12,4)\n  lea    0x1(%rbp,%r13,1),%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     1295 <func0+0x15c>\n  movzbl 0x0(%rbp),%edx\n  test   $0xdf,%dl\n  je     1223 <func0+0xea>\n  mov    $0x1,%eax\n  mov    %dl,(%r15,%rax,1)\n  mov    %eax,%ecx\n  movzbl 0x0(%rbp,%rax,1),%edx\n  mov    %rax,%r13\n  add    $0x1,%rax\n  test   $0xdf,%dl\n  jne    1251 <func0+0x118>\n  movslq %ecx,%rcx\n  movb   $0x0,0x82(%rsp,%rcx,1)\n  mov    $0x0,%ebx\n  mov    0x30(%rsp,%rbx,8),%rsi\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1230 <func0+0xf7>\n  add    $0x1,%rbx\n  cmp    $0xa,%rbx\n  jne    1278 <func0+0x13f>\n  jmp    1238 <func0+0xff>\n  mov    $0x0,%r12d\n  mov    $0x0,%r8d\n  lea    0x2db7(%rip),%rdi        # 405f <completed.0+0x1f>\n  lea    0x1(%rdi),%rbp\n  jmp    12fb <func0+0x1c2>\n  mov    %dl,(%rax,%rdi,1)\n  mov    %eax,%ecx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    12ae <func0+0x175>\n  lea    0x1(%rcx),%r8d\n  movslq %ecx,%rcx\n  movb   $0x20,0x0(%rbp,%rcx,1)\n  add    $0x1,%r9d\n  cmp    %r11d,%r9d\n  je     12f1 <func0+0x1b8>\n  lea    0x1(%r8),%eax\n  cltq\n  mov    %r10d,%edx\n  movslq %r8d,%rcx\n  mov    %rbx,%rsi\n  sub    %rcx,%rsi\n  mov    %r8d,%ecx\n  test   %r10b,%r10b\n  jne    12ae <func0+0x175>\n  jmp    12c0 <func0+0x187>\n  add    $0x1,%r12\n  cmp    $0xa,%r12\n  je     1315 <func0+0x1dc>\n  mov    (%rsp,%r12,4),%r11d\n  test   %r11d,%r11d\n  jle    12f1 <func0+0x1b8>\n  mov    0x30(%rsp,%r12,8),%rbx\n  movzbl (%rbx),%r10d\n  mov    $0x0,%r9d\n  jmp    12d5 <func0+0x19c>\n  test   %r8d,%r8d\n  jle    1357 <func0+0x21e>\n  lea    -0x1(%r8),%eax\n  cltq\n  lea    0x2d39(%rip),%rdx        # 4060 <out.0>\n  movb   $0x0,(%rdx,%rax,1)\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1360 <func0+0x227>\n  lea    0x2d1b(%rip),%rax        # 4060 <out.0>\n  add    $0x98,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  movb   $0x0,0x2d02(%rip)        # 4060 <out.0>\n  jmp    132b <func0+0x1f2>\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,(%rsp)\n  movq   $0x0,0x8(%rsp)\n  movq   $0x0,0x10(%rsp)\n  movq   $0x0,0x18(%rsp)\n  movq   $0x0,0x20(%rsp)\n  lea    D0(%rip),%rax\n  mov    %rax,0x30(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x50(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x58(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x60(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x68(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x70(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x78(%rsp)\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    %rdi,%rbp\n  lea    0x81(%rsp),%r15\n  lea    0x82(%rsp),%r14\n  jmp    L1\nL3:\n  mov    $0x0,%ecx\n  mov    $0x0,%r13d\n  jmp    L2\nL5:\n  movslq %ebx,%r12\n  addl   $0x1,(%rsp,%r12,4)\nL7:\n  lea    0x1(%rbp,%r13,1),%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     L0\nL1:\n  movzbl 0x0(%rbp),%edx\n  test   $0xdf,%dl\n  je     L3\n  mov    $0x1,%eax\nL4:\n  mov    %dl,(%r15,%rax,1)\n  mov    %eax,%ecx\n  movzbl 0x0(%rbp,%rax,1),%edx\n  mov    %rax,%r13\n  add    $0x1,%rax\n  test   $0xdf,%dl\n  jne    L4\nL2:\n  movslq %ecx,%rcx\n  movb   $0x0,0x82(%rsp,%rcx,1)\n  mov    $0x0,%ebx\nL6:\n  mov    0x30(%rsp,%rbx,8),%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L5\n  add    $0x1,%rbx\n  cmp    $0xa,%rbx\n  jne    L6\n  jmp    L7\nL0:\n  mov    $0x0,%r12d\n  mov    $0x0,%r8d\n  lea    D10(%rip),%rdi\n  lea    0x1(%rdi),%rbp\n  jmp    L8\nL9:\n  mov    %dl,(%rax,%rdi,1)\n  mov    %eax,%ecx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    L9\nL11:\n  lea    0x1(%rcx),%r8d\n  movslq %ecx,%rcx\n  movb   $0x20,0x0(%rbp,%rcx,1)\n  add    $0x1,%r9d\n  cmp    %r11d,%r9d\n  je     L10\nL13:\n  lea    0x1(%r8),%eax\n  cltq\n  mov    %r10d,%edx\n  movslq %r8d,%rcx\n  mov    %rbx,%rsi\n  sub    %rcx,%rsi\n  mov    %r8d,%ecx\n  test   %r10b,%r10b\n  jne    L9\n  jmp    L11\nL10:\n  add    $0x1,%r12\n  cmp    $0xa,%r12\n  je     L12\nL8:\n  mov    (%rsp,%r12,4),%r11d\n  test   %r11d,%r11d\n  jle    L10\n  mov    0x30(%rsp,%r12,8),%rbx\n  movzbl (%rbx),%r10d\n  mov    $0x0,%r9d\n  jmp    L13\nL12:\n  test   %r8d,%r8d\n  jle    L14\n  lea    -0x1(%r8),%eax\n  cltq\n  lea    D11(%rip),%rdx\n  movb   $0x0,(%rdx,%rax,1)\nL16:\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L15\n  lea    D11(%rip),%rax\n  add    $0x98,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL14:\n  movb   $0x0,D11(%rip)\n  jmp    L16\nL15:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3692
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8197,
          "bias": [
            3685
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8201,
          "bias": [
            3677
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8205,
          "bias": [
            3669
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8211,
          "bias": [
            3663
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8216,
          "bias": [
            3656
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8221,
          "bias": [
            3649
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8225,
          "bias": [
            3641
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8231,
          "bias": [
            3635
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8237,
          "bias": [
            3629
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 16479,
          "bias": [
            11703
          ]
        },
        "D11": {
          "label": "D11",
          "addr": 16480,
          "bias": [
            11577,
            11547,
            11522
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4757
        },
        "L1": {
          "label": "L1",
          "addr": 4675
        },
        "L2": {
          "label": "L2",
          "addr": 4712
        },
        "L3": {
          "label": "L3",
          "addr": 4643
        },
        "L4": {
          "label": "L4",
          "addr": 4689
        },
        "L5": {
          "label": "L5",
          "addr": 4656
        },
        "L6": {
          "label": "L6",
          "addr": 4728
        },
        "L7": {
          "label": "L7",
          "addr": 4664
        },
        "L8": {
          "label": "L8",
          "addr": 4859
        },
        "L9": {
          "label": "L9",
          "addr": 4782
        },
        "L10": {
          "label": "L10",
          "addr": 4849
        },
        "L11": {
          "label": "L11",
          "addr": 4800
        },
        "L12": {
          "label": "L12",
          "addr": 4885
        },
        "L13": {
          "label": "L13",
          "addr": 4821
        },
        "L14": {
          "label": "L14",
          "addr": 4951
        },
        "L15": {
          "label": "L15",
          "addr": 4960
        },
        "L16": {
          "label": "L16",
          "addr": 4907
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "7a65726f006f6e650074776f00746872656500666f757200666976650073697800736576656e006569676874006e696e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"zero\""
          },
          "0x2021": {
            "type": "string",
            "value": "\"seven\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"one\""
          },
          "0x2027": {
            "type": "string",
            "value": "\"eight\""
          },
          "0x2009": {
            "type": "string",
            "value": "\"two\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"three\""
          },
          "0x202d": {
            "type": "string",
            "value": "\"nine\""
          },
          "0x2013": {
            "type": "string",
            "value": "\"four\""
          },
          "0x2018": {
            "type": "string",
            "value": "\"five\""
          },
          "0x201d": {
            "type": "string",
            "value": "\"six\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s) {\n  static char *nums[] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n  static char str[100];\n  int i, j, k, l, m, n, len;\n  int count[10] = {0};\n  char *p, *q;\n  while (*s) {\n    for (i = 0; s[i] != ' ' && s[i] != '\\0'; i++)\n      ;\n    str[i + 1] = '\\0';\n    for (j = 0; j < 10; j++) {\n      if (!strcmp(str, nums[j]))\n        count[j]++;\n    }\n    s += i + 1;\n  }\n  k = 0;\n  for (i = 0; i < 10; i++) {\n    for (j = 0; j < count[i]; j++) {\n      for (l = 0; nums[i][l] != '\\0'; l++)\n        str[k++] = nums[i][l];\n      str[k++] = ' ';\n    }\n  }\n  if (k > 0)\n    str[k - 1] = '\\0';\n  else\n    str[k] = '\\0';\n  return str;\n}"
    },
    {
      "task_id": 27,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    119d <func0+0x84>\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x9(%rbp)\n  cmpb   $0x60,-0x9(%rbp)\n  jle    1170 <func0+0x57>\n  cmpb   $0x7a,-0x9(%rbp)\n  jg     1170 <func0+0x57>\n  movzbl -0x9(%rbp),%eax\n  sub    $0x20,%eax\n  mov    %al,-0x9(%rbp)\n  jmp    1186 <func0+0x6d>\n  cmpb   $0x40,-0x9(%rbp)\n  jle    1186 <func0+0x6d>\n  cmpb   $0x5a,-0x9(%rbp)\n  jg     1186 <func0+0x6d>\n  movzbl -0x9(%rbp),%eax\n  add    $0x20,%eax\n  mov    %al,-0x9(%rbp)\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x9(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     1145 <func0+0x2c>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL3:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x9(%rbp)\n  cmpb   $0x60,-0x9(%rbp)\n  jle    L1\n  cmpb   $0x7a,-0x9(%rbp)\n  jg     L1\n  movzbl -0x9(%rbp),%eax\n  sub    $0x20,%eax\n  mov    %al,-0x9(%rbp)\n  jmp    L2\nL1:\n  cmpb   $0x40,-0x9(%rbp)\n  jle    L2\n  cmpb   $0x5a,-0x9(%rbp)\n  jg     L2\n  movzbl -0x9(%rbp),%eax\n  add    $0x20,%eax\n  mov    %al,-0x9(%rbp)\nL2:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x9(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L3\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4509
        },
        "L1": {
          "label": "L1",
          "addr": 4464
        },
        "L2": {
          "label": "L2",
          "addr": 4486
        },
        "L3": {
          "label": "L3",
          "addr": 4421
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *str, char *ret) {\n  int i, len = strlen(str);\n  char c;\n  for (i = 0; i < len; i++) {\n    c = str[i];\n    if (c >= 'a' && c <= 'z')\n      c -= 32;\n    else if (c >= 'A' && c <= 'Z')\n      c += 32;\n    ret[i] = c;\n  }\n  ret[len] = '\\0';\n}"
    },
    {
      "task_id": 28,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11a9 <func0+0x50>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     117c <func0+0x23>\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    11d3 <func0+0x7a>\n  mov    $0x0,%eax\n  jmp    1219 <func0+0xc0>\n  mov    -0x8(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  jmp    120d <func0+0xb4>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcat@plt>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     11e3 <func0+0x8a>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL1:\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L1\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L2\n  mov    $0x0,%eax\n  jmp    L3\nL2:\n  mov    -0x8(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L4\nL5:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcat@plt>\n  addl   $0x1,-0xc(%rbp)\nL4:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L5\n  mov    -0x8(%rbp),%rax\nL3:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4521
        },
        "L1": {
          "label": "L1",
          "addr": 4476
        },
        "L2": {
          "label": "L2",
          "addr": 4563
        },
        "L3": {
          "label": "L3",
          "addr": 4633
        },
        "L4": {
          "label": "L4",
          "addr": 4621
        },
        "L5": {
          "label": "L5",
          "addr": 4579
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *argv[], int n) {\n  int totlen = 0;\n  for (int i = 0; i < n; i++)\n    totlen += strlen(argv[i]);\n  char *ret = malloc(totlen + 1);\n  if (!ret)\n    return NULL;\n  ret[0] = '\\0';\n  for (int i = 0; i < n; i++)\n    strcat(ret, argv[i]);\n  return ret;\n}"
    },
    {
      "task_id": 27,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  call   1050 <strlen@plt>\n  test   %eax,%eax\n  jle    116e <func0+0x55>\n  lea    -0x1(%rax),%r8d\n  mov    $0x0,%ecx\n  jmp    1159 <func0+0x40>\n  lea    -0x41(%rdx),%edi\n  add    $0x20,%esi\n  cmp    $0x1a,%dil\n  cmovb  %esi,%edx\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %r8,%rcx\n  je     116e <func0+0x55>\n  mov    %rdx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%edx\n  mov    %edx,%esi\n  lea    -0x61(%rdx),%edi\n  cmp    $0x19,%dil\n  ja     113d <func0+0x24>\n  sub    $0x20,%edx\n  jmp    114a <func0+0x31>\n  cltq\n  movb   $0x0,(%rbx,%rax,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  call   <strlen@plt>\n  test   %eax,%eax\n  jle    L0\n  lea    -0x1(%rax),%r8d\n  mov    $0x0,%ecx\n  jmp    L1\nL2:\n  lea    -0x41(%rdx),%edi\n  add    $0x20,%esi\n  cmp    $0x1a,%dil\n  cmovb  %esi,%edx\nL3:\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %r8,%rcx\n  je     L0\n  mov    %rdx,%rcx\nL1:\n  movzbl 0x0(%rbp,%rcx,1),%edx\n  mov    %edx,%esi\n  lea    -0x61(%rdx),%edi\n  cmp    $0x19,%dil\n  ja     L2\n  sub    $0x20,%edx\n  jmp    L3\nL0:\n  cltq\n  movb   $0x0,(%rbx,%rax,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4462
        },
        "L1": {
          "label": "L1",
          "addr": 4441
        },
        "L2": {
          "label": "L2",
          "addr": 4413
        },
        "L3": {
          "label": "L3",
          "addr": 4426
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *str, char *str1) {\n  int i, len;\n  len = strlen(str);\n  for (i = 0; i < len; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z')\n      str1[i] = str[i] - 32;\n    else if (str[i] >= 'A' && str[i] <= 'Z')\n      str1[i] = str[i] + 32;\n    else\n      str1[i] = str[i];\n  }\n  str1[i] = '\\0';\n}"
    },
    {
      "task_id": 28,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    11e8 <func0+0x88>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  mov    %rdi,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax,%rax,1)\n  mov    0x0(%rbp),%rdi\n  add    $0x8,%rbp\n  call   1070 <strlen@plt>\n  add    %eax,%r12d\n  cmp    %r13,%rbp\n  jne    1188 <func0+0x28>\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     120b <func0+0xab>\n  movb   $0x0,(%r8)\n  cs nopw 0x0(%rax,%rax,1)\n  mov    (%rbx),%rsi\n  mov    %r8,%rdi\n  add    $0x8,%rbx\n  call   1090 <strcat@plt>\n  mov    %rax,%r8\n  cmp    %r13,%rbx\n  jne    11c0 <func0+0x60>\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   (%rax)\n  mov    $0x1,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     120b <func0+0xab>\n  movb   $0x0,(%rax)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  xor    %r8d,%r8d\n  jmp    11d7 <func0+0x77>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  mov    %rdi,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax,%rax,1)\nL1:\n  mov    0x0(%rbp),%rdi\n  add    $0x8,%rbp\n  call   <strlen@plt>\n  add    %eax,%r12d\n  cmp    %r13,%rbp\n  jne    L1\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,(%r8)\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    (%rbx),%rsi\n  mov    %r8,%rdi\n  add    $0x8,%rbx\n  call   <strcat@plt>\n  mov    %rax,%r8\n  cmp    %r13,%rbx\n  jne    L3\nL4:\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   (%rax)\nL0:\n  mov    $0x1,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,(%rax)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL2:\n  xor    %r8d,%r8d\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4584
        },
        "L1": {
          "label": "L1",
          "addr": 4488
        },
        "L2": {
          "label": "L2",
          "addr": 4619
        },
        "L3": {
          "label": "L3",
          "addr": 4544
        },
        "L4": {
          "label": "L4",
          "addr": 4567
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *const *argv, int argc) {\n  int i;\n  size_t len = 0;\n  char *buf;\n  for (i = 0; i < argc; i++)\n    len += strlen(argv[i]);\n  if ((buf = malloc(len + 1)) == NULL)\n    return NULL;\n  buf[0] = '\\0';\n  for (i = 0; i < argc; i++)\n    buf = strcat(buf, argv[i]);\n  return buf;\n}"
    },
    {
      "task_id": 27,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  test   %eax,%eax\n  jle    117b <func0+0x5b>\n  lea    -0x1(%rax),%esi\n  xor    %ecx,%ecx\n  jmp    1152 <func0+0x32>\n  sub    $0x20,%edx\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %rcx,%rsi\n  je     117b <func0+0x5b>\n  mov    %rdx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%edx\n  lea    -0x61(%rdx),%r8d\n  cmp    $0x19,%r8b\n  jbe    1140 <func0+0x20>\n  lea    -0x41(%rdx),%r8d\n  lea    0x20(%rdx),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%edx\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %rcx,%rsi\n  jne    114f <func0+0x2f>\n  cltq\n  movb   $0x0,(%rbx,%rax,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  test   %eax,%eax\n  jle    L0\n  lea    -0x1(%rax),%esi\n  xor    %ecx,%ecx\n  jmp    L1\nL2:\n  sub    $0x20,%edx\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %rcx,%rsi\n  je     L0\nL3:\n  mov    %rdx,%rcx\nL1:\n  movzbl 0x0(%rbp,%rcx,1),%edx\n  lea    -0x61(%rdx),%r8d\n  cmp    $0x19,%r8b\n  jbe    L2\n  lea    -0x41(%rdx),%r8d\n  lea    0x20(%rdx),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%edx\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %rcx,%rsi\n  jne    L3\nL0:\n  cltq\n  movb   $0x0,(%rbx,%rax,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4475
        },
        "L1": {
          "label": "L1",
          "addr": 4434
        },
        "L2": {
          "label": "L2",
          "addr": 4416
        },
        "L3": {
          "label": "L3",
          "addr": 4431
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *str, char *str1) {\n  int i, len;\n  len = strlen(str);\n  for (i = 0; i < len; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z')\n      str1[i] = str[i] - 32;\n    else if (str[i] >= 'A' && str[i] <= 'Z')\n      str1[i] = str[i] + 32;\n    else\n      str1[i] = str[i];\n  }\n  str1[len] = '\\0';\n}"
    },
    {
      "task_id": 28,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    11d0 <func0+0x77>\n  mov    %rdi,%r13\n  mov    %esi,%r12d\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r14\n  mov    $0x0,%ebp\n  mov    (%rbx),%rdi\n  call   1070 <strlen@plt>\n  add    %eax,%ebp\n  add    $0x8,%rbx\n  cmp    %r14,%rbx\n  jne    117f <func0+0x26>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     11c4 <func0+0x6b>\n  movb   $0x0,0x0(%rbp)\n  mov    $0x0,%ebx\n  mov    0x0(%r13,%rbx,8),%rsi\n  mov    %rbp,%rdi\n  call   1090 <strcat@plt>\n  add    $0x1,%rbx\n  cmp    %ebx,%r12d\n  jg     11ae <func0+0x55>\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x1,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     11c4 <func0+0x6b>\n  movb   $0x0,(%rax)\n  jmp    11c4 <func0+0x6b>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r13\n  mov    %esi,%r12d\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r14\n  mov    $0x0,%ebp\nL1:\n  mov    (%rbx),%rdi\n  call   <strlen@plt>\n  add    %eax,%ebp\n  add    $0x8,%rbx\n  cmp    %r14,%rbx\n  jne    L1\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,0x0(%rbp)\n  mov    $0x0,%ebx\nL3:\n  mov    0x0(%r13,%rbx,8),%rsi\n  mov    %rbp,%rdi\n  call   <strcat@plt>\n  add    $0x1,%rbx\n  cmp    %ebx,%r12d\n  jg     L3\nL2:\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  mov    $0x1,%edi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,(%rax)\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4560
        },
        "L1": {
          "label": "L1",
          "addr": 4479
        },
        "L2": {
          "label": "L2",
          "addr": 4548
        },
        "L3": {
          "label": "L3",
          "addr": 4526
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *const argv[], int argv_len) {\n  int size = 0;\n  for (int i = 0; i < argv_len; i++) {\n    size += strlen(argv[i]);\n  }\n  char *result = malloc(size + 1);\n  if (result == NULL) {\n    return NULL;\n  }\n  result[0] = '\\0';\n  for (int i = 0; i < argv_len; i++) {\n    strcat(result, argv[i]);\n  }\n  return result;\n}"
    },
    {
      "task_id": 19,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  pxor   %xmm0,%xmm0\n  xor    %r10d,%r10d\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  lea    0xe8a(%rip),%rax        # 2000 <_fini+0xca0>\n  movaps %xmm0,(%rsp)\n  mov    %rax,0x30(%rsp)\n  lea    0xe7f(%rip),%rax        # 2005 <_fini+0xca5>\n  mov    %rax,0x38(%rsp)\n  lea    0xe77(%rip),%rax        # 2009 <_fini+0xca9>\n  mov    %rax,0x40(%rsp)\n  lea    0xe6f(%rip),%rax        # 200d <_fini+0xcad>\n  mov    %rax,0x48(%rsp)\n  lea    0xe69(%rip),%rax        # 2013 <_fini+0xcb3>\n  mov    %rax,0x50(%rsp)\n  lea    0xe62(%rip),%rax        # 2018 <_fini+0xcb8>\n  mov    %rax,0x58(%rsp)\n  lea    0xe5b(%rip),%rax        # 201d <_fini+0xcbd>\n  mov    %rax,0x60(%rsp)\n  lea    0xe53(%rip),%rax        # 2021 <_fini+0xcc1>\n  mov    %rax,0x68(%rsp)\n  lea    0xe4d(%rip),%rax        # 2027 <_fini+0xcc7>\n  mov    %rax,0x70(%rsp)\n  lea    0xe47(%rip),%rax        # 202d <_fini+0xccd>\n  mov    %rax,0x78(%rsp)\n  movzbl (%rdi),%eax\n  movq   $0x0,0x20(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  test   %al,%al\n  je     129a <func0+0x15a>\n  mov    %rdi,%rbp\n  lea    0x82(%rsp),%r13\n  mov    $0x1,%ebx\n  lea    0x81(%rsp),%r14\n  test   $0xdf,%al\n  je     1284 <func0+0x144>\n  mov    %al,(%r14,%rbx,1)\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movslq %ebx,%rdx\n  add    $0x1,%rbx\n  test   $0xdf,%al\n  jne    1220 <func0+0xe0>\n  movb   $0x0,0x82(%rsp,%rdx,1)\n  xor    %r15d,%r15d\n  lea    0xdba(%rip),%rsi        # 2000 <_fini+0xca0>\n  jmp    1255 <func0+0x115>\n  nopl   0x0(%rax,%rax,1)\n  mov    0x30(%rsp,%r15,8),%rsi\n  mov    %r13,%rdi\n  movslq %r15d,%r12\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1288 <func0+0x148>\n  add    $0x1,%r15\n  cmp    $0xa,%r15\n  jne    1250 <func0+0x110>\n  add    %rbx,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     1296 <func0+0x156>\n  movzbl 0x0(%rbp),%eax\n  mov    $0x1,%ebx\n  test   $0xdf,%al\n  jne    1220 <func0+0xe0>\n  xor    %edx,%edx\n  jmp    1234 <func0+0xf4>\n  add    %rbx,%rbp\n  addl   $0x1,(%rsp,%r12,4)\n  cmpb   $0x0,-0x1(%rbp)\n  jne    1277 <func0+0x137>\n  mov    (%rsp),%r10d\n  lea    0x2dbf(%rip),%r11        # 4060 <out.0>\n  xor    %ebp,%ebp\n  xor    %esi,%esi\n  lea    -0x1(%r11),%rdi\n  nopl   0x0(%rax)\n  test   %r10d,%r10d\n  jle    130c <func0+0x1cc>\n  mov    0x30(%rsp,%rbp,2),%rbx\n  xor    %r8d,%r8d\n  movzbl (%rbx),%r9d\n  nopl   0x0(%rax)\n  movslq %esi,%rcx\n  test   %r9b,%r9b\n  je     12fb <func0+0x1bb>\n  lea    0x1(%rsi),%eax\n  movslq %esi,%rcx\n  mov    %rbx,%rsi\n  mov    %r9d,%edx\n  cltq\n  sub    %rcx,%rsi\n  nopl   0x0(%rax)\n  mov    %dl,(%rdi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    12e8 <func0+0x1a8>\n  add    $0x1,%r8d\n  movb   $0x20,(%r11,%rcx,1)\n  lea    0x1(%rcx),%esi\n  cmp    %r10d,%r8d\n  jne    12c8 <func0+0x188>\n  add    $0x4,%rbp\n  cmp    $0x28,%rbp\n  je     131c <func0+0x1dc>\n  mov    (%rsp,%rbp,1),%r10d\n  jmp    12b0 <func0+0x170>\n  test   %esi,%esi\n  je     1352 <func0+0x212>\n  lea    -0x1(%rsi),%eax\n  cltq\n  movb   $0x0,(%r11,%rax,1)\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    135b <func0+0x21b>\n  add    $0x98,%rsp\n  mov    %r11,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  movb   $0x0,0x2d07(%rip)        # 4060 <out.0>\n  jmp    132a <func0+0x1ea>\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  pxor   %xmm0,%xmm0\n  xor    %r10d,%r10d\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  movaps %xmm0,(%rsp)\n  mov    %rax,0x30(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x50(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x58(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x60(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x68(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x70(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x78(%rsp)\n  movzbl (%rdi),%eax\n  movq   $0x0,0x20(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  test   %al,%al\n  je     L0\n  mov    %rdi,%rbp\n  lea    0x82(%rsp),%r13\n  mov    $0x1,%ebx\n  lea    0x81(%rsp),%r14\n  test   $0xdf,%al\n  je     L1\nL2:\n  mov    %al,(%r14,%rbx,1)\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movslq %ebx,%rdx\n  add    $0x1,%rbx\n  test   $0xdf,%al\n  jne    L2\nL7:\n  movb   $0x0,0x82(%rsp,%rdx,1)\n  xor    %r15d,%r15d\n  lea    D0(%rip),%rsi\n  jmp    L3\n  nopl   0x0(%rax,%rax,1)\nL5:\n  mov    0x30(%rsp,%r15,8),%rsi\nL3:\n  mov    %r13,%rdi\n  movslq %r15d,%r12\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L4\n  add    $0x1,%r15\n  cmp    $0xa,%r15\n  jne    L5\n  add    %rbx,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     L6\nL8:\n  movzbl 0x0(%rbp),%eax\n  mov    $0x1,%ebx\n  test   $0xdf,%al\n  jne    L2\nL1:\n  xor    %edx,%edx\n  jmp    L7\nL4:\n  add    %rbx,%rbp\n  addl   $0x1,(%rsp,%r12,4)\n  cmpb   $0x0,-0x1(%rbp)\n  jne    L8\nL6:\n  mov    (%rsp),%r10d\nL0:\n  lea    D10(%rip),%r11\n  xor    %ebp,%ebp\n  xor    %esi,%esi\n  lea    -0x1(%r11),%rdi\n  nopl   0x0(%rax)\nL14:\n  test   %r10d,%r10d\n  jle    L9\n  mov    0x30(%rsp,%rbp,2),%rbx\n  xor    %r8d,%r8d\n  movzbl (%rbx),%r9d\n  nopl   0x0(%rax)\nL12:\n  movslq %esi,%rcx\n  test   %r9b,%r9b\n  je     L10\n  lea    0x1(%rsi),%eax\n  movslq %esi,%rcx\n  mov    %rbx,%rsi\n  mov    %r9d,%edx\n  cltq\n  sub    %rcx,%rsi\n  nopl   0x0(%rax)\nL11:\n  mov    %dl,(%rdi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    L11\nL10:\n  add    $0x1,%r8d\n  movb   $0x20,(%r11,%rcx,1)\n  lea    0x1(%rcx),%esi\n  cmp    %r10d,%r8d\n  jne    L12\nL9:\n  add    $0x4,%rbp\n  cmp    $0x28,%rbp\n  je     L13\n  mov    (%rsp,%rbp,1),%r10d\n  jmp    L14\nL13:\n  test   %esi,%esi\n  je     L15\n  lea    -0x1(%rsi),%eax\n  cltq\n  movb   $0x0,(%r11,%rax,1)\nL17:\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L16\n  add    $0x98,%rsp\n  mov    %r11,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL15:\n  movb   $0x0,D10(%rip)\n  jmp    L17\nL16:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3722,
            3514
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8197,
          "bias": [
            3711
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8201,
          "bias": [
            3703
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8205,
          "bias": [
            3695
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8211,
          "bias": [
            3689
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8216,
          "bias": [
            3682
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8221,
          "bias": [
            3675
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8225,
          "bias": [
            3667
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8231,
          "bias": [
            3661
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8237,
          "bias": [
            3655
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 16480,
          "bias": [
            11711,
            11527
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4762
        },
        "L1": {
          "label": "L1",
          "addr": 4740
        },
        "L2": {
          "label": "L2",
          "addr": 4640
        },
        "L3": {
          "label": "L3",
          "addr": 4693
        },
        "L4": {
          "label": "L4",
          "addr": 4744
        },
        "L5": {
          "label": "L5",
          "addr": 4688
        },
        "L6": {
          "label": "L6",
          "addr": 4758
        },
        "L7": {
          "label": "L7",
          "addr": 4660
        },
        "L8": {
          "label": "L8",
          "addr": 4727
        },
        "L9": {
          "label": "L9",
          "addr": 4876
        },
        "L10": {
          "label": "L10",
          "addr": 4859
        },
        "L11": {
          "label": "L11",
          "addr": 4840
        },
        "L12": {
          "label": "L12",
          "addr": 4808
        },
        "L13": {
          "label": "L13",
          "addr": 4892
        },
        "L14": {
          "label": "L14",
          "addr": 4784
        },
        "L15": {
          "label": "L15",
          "addr": 4946
        },
        "L16": {
          "label": "L16",
          "addr": 4955
        },
        "L17": {
          "label": "L17",
          "addr": 4906
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "7a65726f006f6e650074776f00746872656500666f757200666976650073697800736576656e006569676874006e696e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"zero\""
          },
          "0x2021": {
            "type": "string",
            "value": "\"seven\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"one\""
          },
          "0x2027": {
            "type": "string",
            "value": "\"eight\""
          },
          "0x2009": {
            "type": "string",
            "value": "\"two\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"three\""
          },
          "0x202d": {
            "type": "string",
            "value": "\"nine\""
          },
          "0x2013": {
            "type": "string",
            "value": "\"four\""
          },
          "0x2018": {
            "type": "string",
            "value": "\"five\""
          },
          "0x201d": {
            "type": "string",
            "value": "\"six\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s) {\n  static char *nums[] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n  static char *nums_en[] = {\"z\\0\", \"o\\0\", \"t\\0\", \"th\\0\", \"f\\0\", \"fi\\0\", \"s\\0\", \"se\\0\", \"e\\0\", \"n\\0\"};\n  int nums_cn[10] = {0};\n  char *p = s;\n  int i = 0, j = 0, k = 0;\n  char tmp[10];\n  while (*p) {\n    while (*p != ' ' && *p != '\\0')\n      tmp[i++] = *p++;\n    tmp[i] = '\\0';\n    for (j = 0; j < 10; j++)\n      if (!strcmp(tmp, nums[j])) {\n        nums_cn[j]++;\n        break;\n      }\n    i = 0;\n    p++;\n  }\n  for (i = 0; i < 10; i++)\n    for (j = 0; j < nums_cn[i]; j++) {\n      while (*nums_en[i])\n        nums_en[9][k++] = *nums_en[i]++;\n      nums_en[9][k++] = ' ';\n    }\n  if (k)\n    nums_en[9][k - 1] = '\\0';\n  else\n    nums_en[9][0] = '\\0';\n  return nums_en[9];\n}"
    },
    {
      "task_id": 26,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %esi,%r15d\n  mov    %rdx,%r13\n  movslq %esi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r12\n  mov    $0x4,%esi\n  mov    %rbx,%rdi\n  call   1080 <calloc@plt>\n  mov    %rax,%rbp\n  mov    $0x4,%esi\n  mov    %rbx,%rdi\n  call   1080 <calloc@plt>\n  mov    %rax,%rbx\n  test   %r15d,%r15d\n  jle    11df <func0+0x86>\n  mov    %r14,%rsi\n  lea    -0x1(%r15),%eax\n  lea    0x4(%r14,%rax,4),%rdi\n  mov    $0x0,%r8d\n  mov    $0x0,%r9d\n  lea    0x4(%rbp),%r11\n  lea    0x4(%rbx),%r10\n  jmp    124b <func0+0xf2>\n  lea    -0x1(%r8),%eax\n  lea    0x4(%rbx,%rax,4),%rcx\n  mov    $0x0,%r9d\n  jmp    121f <func0+0xc6>\n  mov    $0x0,%r9d\n  mov    %r9d,0x0(%r13)\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  mov    %rbx,%rdi\n  call   1070 <free@plt>\n  mov    %r12,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  movslq %r9d,%rax\n  mov    %edx,(%r12,%rax,4)\n  lea    0x1(%r9),%r9d\n  add    $0x4,%rsi\n  cmp    %rdi,%rsi\n  je     11e5 <func0+0x8c>\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  jle    120b <func0+0xb2>\n  mov    %rbx,%rax\n  cmp    %edx,(%rax)\n  je     1216 <func0+0xbd>\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  jne    1229 <func0+0xd0>\n  jmp    120b <func0+0xb2>\n  movslq %r8d,%rax\n  mov    %edx,(%rbx,%rax,4)\n  lea    0x1(%r8),%r8d\n  add    $0x4,%r14\n  cmp    %rdi,%r14\n  je     11ce <func0+0x75>\n  mov    (%r14),%edx\n  test   %r8d,%r8d\n  jle    126b <func0+0x112>\n  mov    %rbx,%rax\n  lea    -0x1(%r8),%ecx\n  lea    (%r10,%rcx,4),%rcx\n  cmp    %edx,(%rax)\n  je     1242 <func0+0xe9>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    125e <func0+0x105>\n  test   %r9d,%r9d\n  jle    1288 <func0+0x12f>\n  mov    %rbp,%rax\n  lea    -0x1(%r9),%ecx\n  lea    (%r11,%rcx,4),%rcx\n  cmp    %edx,(%rax)\n  je     1238 <func0+0xdf>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    127b <func0+0x122>\n  movslq %r9d,%rax\n  mov    %edx,0x0(%rbp,%rax,4)\n  lea    0x1(%r9),%r9d\n  jmp    1242 <func0+0xe9>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %esi,%r15d\n  mov    %rdx,%r13\n  movslq %esi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r12\n  mov    $0x4,%esi\n  mov    %rbx,%rdi\n  call   <calloc@plt>\n  mov    %rax,%rbp\n  mov    $0x4,%esi\n  mov    %rbx,%rdi\n  call   <calloc@plt>\n  mov    %rax,%rbx\n  test   %r15d,%r15d\n  jle    L0\n  mov    %r14,%rsi\n  lea    -0x1(%r15),%eax\n  lea    0x4(%r14,%rax,4),%rdi\n  mov    $0x0,%r8d\n  mov    $0x0,%r9d\n  lea    0x4(%rbp),%r11\n  lea    0x4(%rbx),%r10\n  jmp    L1\nL7:\n  lea    -0x1(%r8),%eax\n  lea    0x4(%rbx,%rax,4),%rcx\n  mov    $0x0,%r9d\n  jmp    L2\nL0:\n  mov    $0x0,%r9d\nL3:\n  mov    %r9d,0x0(%r13)\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %r12,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL4:\n  movslq %r9d,%rax\n  mov    %edx,(%r12,%rax,4)\n  lea    0x1(%r9),%r9d\nL5:\n  add    $0x4,%rsi\n  cmp    %rdi,%rsi\n  je     L3\nL2:\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  jle    L4\n  mov    %rbx,%rax\nL6:\n  cmp    %edx,(%rax)\n  je     L5\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  jne    L6\n  jmp    L4\nL12:\n  movslq %r8d,%rax\n  mov    %edx,(%rbx,%rax,4)\n  lea    0x1(%r8),%r8d\nL9:\n  add    $0x4,%r14\n  cmp    %rdi,%r14\n  je     L7\nL1:\n  mov    (%r14),%edx\n  test   %r8d,%r8d\n  jle    L8\n  mov    %rbx,%rax\n  lea    -0x1(%r8),%ecx\n  lea    (%r10,%rcx,4),%rcx\nL10:\n  cmp    %edx,(%rax)\n  je     L9\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L10\nL8:\n  test   %r9d,%r9d\n  jle    L11\n  mov    %rbp,%rax\n  lea    -0x1(%r9),%ecx\n  lea    (%r11,%rcx,4),%rcx\nL13:\n  cmp    %edx,(%rax)\n  je     L12\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L13\nL11:\n  movslq %r9d,%rax\n  mov    %edx,0x0(%rbp,%rax,4)\n  lea    0x1(%r9),%r9d\n  jmp    L9",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4575
        },
        "L1": {
          "label": "L1",
          "addr": 4683
        },
        "L2": {
          "label": "L2",
          "addr": 4639
        },
        "L3": {
          "label": "L3",
          "addr": 4581
        },
        "L4": {
          "label": "L4",
          "addr": 4619
        },
        "L5": {
          "label": "L5",
          "addr": 4630
        },
        "L6": {
          "label": "L6",
          "addr": 4649
        },
        "L7": {
          "label": "L7",
          "addr": 4558
        },
        "L8": {
          "label": "L8",
          "addr": 4715
        },
        "L9": {
          "label": "L9",
          "addr": 4674
        },
        "L10": {
          "label": "L10",
          "addr": 4702
        },
        "L11": {
          "label": "L11",
          "addr": 4744
        },
        "L12": {
          "label": "L12",
          "addr": 4664
        },
        "L13": {
          "label": "L13",
          "addr": 4731
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int *nn) {\n  int *a = (int *)malloc(n * sizeof(int));\n  int *b = (int *)calloc(n, sizeof(int));\n  int *c = (int *)calloc(n, sizeof(int));\n  int nb = 0, nc = 0;\n  for (int i = 0; i < n; i++) {\n    int ok = 0;\n    for (int j = 0; j < nc; j++) {\n      if (c[j] == x[i]) {\n        ok = 1;\n        break;\n      }\n    }\n    if (ok)\n      continue;\n    for (int j = 0; j < nb; j++) {\n      if (b[j] == x[i]) {\n        ok = 1;\n        break;\n      }\n    }\n    if (ok) {\n      c[nc++] = x[i];\n    } else {\n      b[nb++] = x[i];\n    }\n  }\n  *nn = nc;\n  free(b);\n  free(c);\n  return a;\n}"
    },
    {
      "task_id": 29,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rdi\n  mov    %rdx,0x8(%rsp)\n  mov    %rcx,%r15\n  call   1080 <strlen@plt>\n  mov    %eax,%r13d\n  movslq %ebp,%rdi\n  shl    $0x3,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,(%r15)\n  test   %ebp,%ebp\n  jle    11dd <func0+0x84>\n  mov    %r12,%rbx\n  lea    -0x1(%rbp),%eax\n  lea    0x8(%r12,%rax,8),%r14\n  mov    $0x0,%r12d\n  movslq %r13d,%r13\n  jmp    11b5 <func0+0x5c>\n  add    $0x8,%rbx\n  cmp    %r14,%rbx\n  je     11e3 <func0+0x8a>\n  mov    (%rbx),%rbp\n  mov    %r13,%rdx\n  mov    0x8(%rsp),%rsi\n  mov    %rbp,%rdi\n  call   1070 <strncmp@plt>\n  test   %eax,%eax\n  jne    11ac <func0+0x53>\n  movslq %r12d,%rdx\n  mov    (%r15),%rax\n  mov    %rbp,(%rax,%rdx,8)\n  lea    0x1(%r12),%r12d\n  jmp    11ac <func0+0x53>\n  mov    $0x0,%r12d\n  mov    %r12d,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rdi\n  mov    %rdx,0x8(%rsp)\n  mov    %rcx,%r15\n  call   <strlen@plt>\n  mov    %eax,%r13d\n  movslq %ebp,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%r15)\n  test   %ebp,%ebp\n  jle    L0\n  mov    %r12,%rbx\n  lea    -0x1(%rbp),%eax\n  lea    0x8(%r12,%rax,8),%r14\n  mov    $0x0,%r12d\n  movslq %r13d,%r13\n  jmp    L1\nL3:\n  add    $0x8,%rbx\n  cmp    %r14,%rbx\n  je     L2\nL1:\n  mov    (%rbx),%rbp\n  mov    %r13,%rdx\n  mov    0x8(%rsp),%rsi\n  mov    %rbp,%rdi\n  call   <strncmp@plt>\n  test   %eax,%eax\n  jne    L3\n  movslq %r12d,%rdx\n  mov    (%r15),%rax\n  mov    %rbp,(%rax,%rdx,8)\n  lea    0x1(%r12),%r12d\n  jmp    L3\nL0:\n  mov    $0x0,%r12d\nL2:\n  mov    %r12d,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4573
        },
        "L1": {
          "label": "L1",
          "addr": 4533
        },
        "L2": {
          "label": "L2",
          "addr": 4579
        },
        "L3": {
          "label": "L3",
          "addr": 4524
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char **strings, int size, char *str, char ***ans) {\n  int i, j = 0, len = strlen(str);\n  *ans = (char **)malloc(size * sizeof(char *));\n  for (i = 0; i < size; i++) {\n    if (!strncmp(strings[i], str, len)) {\n      (*ans)[j++] = strings[i];\n    }\n  }\n  return j;\n}"
    },
    {
      "task_id": 29,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %rcx,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x30(%rbp),%rax\n  mov    %rdx,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1217 <func0+0xbe>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncmp@plt>\n  test   %eax,%eax\n  jne    1213 <func0+0xba>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%rsi\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  shl    $0x3,%rax\n  lea    (%rsi,%rax,1),%rdx\n  mov    (%rcx),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     11ae <func0+0x55>\n  mov    -0xc(%rbp),%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %rcx,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x30(%rbp),%rax\n  mov    %rdx,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncmp@plt>\n  test   %eax,%eax\n  jne    L1\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%rsi\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  shl    $0x3,%rax\n  lea    (%rsi,%rax,1),%rdx\n  mov    (%rcx),%rax\n  mov    %rax,(%rdx)\nL1:\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0xc(%rbp),%eax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4631
        },
        "L1": {
          "label": "L1",
          "addr": 4627
        },
        "L2": {
          "label": "L2",
          "addr": 4526
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *arr[], int sz, char *str, char ***ans) {\n  int len = strlen(str);\n  *ans = (char **)malloc(sz * sizeof(char *));\n  int cnt = 0;\n  for (int i = 0; i < sz; i++)\n    if (!strncmp(arr[i], str, len))\n      (*ans)[cnt++] = arr[i];\n  return cnt;\n}"
    },
    {
      "task_id": 28,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    11e8 <func0+0x88>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  mov    %rdi,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax,%rax,1)\n  mov    0x0(%rbp),%rdi\n  add    $0x8,%rbp\n  call   1070 <strlen@plt>\n  add    %eax,%r12d\n  cmp    %rbp,%r13\n  jne    1188 <func0+0x28>\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     120b <func0+0xab>\n  movb   $0x0,(%r8)\n  cs nopw 0x0(%rax,%rax,1)\n  mov    (%rbx),%rsi\n  mov    %r8,%rdi\n  add    $0x8,%rbx\n  call   1090 <strcat@plt>\n  mov    %rax,%r8\n  cmp    %rbx,%r13\n  jne    11c0 <func0+0x60>\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   (%rax)\n  mov    $0x1,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     120b <func0+0xab>\n  movb   $0x0,(%rax)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  xor    %r8d,%r8d\n  jmp    11d7 <func0+0x77>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  mov    %rdi,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax,%rax,1)\nL1:\n  mov    0x0(%rbp),%rdi\n  add    $0x8,%rbp\n  call   <strlen@plt>\n  add    %eax,%r12d\n  cmp    %rbp,%r13\n  jne    L1\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,(%r8)\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    (%rbx),%rsi\n  mov    %r8,%rdi\n  add    $0x8,%rbx\n  call   <strcat@plt>\n  mov    %rax,%r8\n  cmp    %rbx,%r13\n  jne    L3\nL4:\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   (%rax)\nL0:\n  mov    $0x1,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,(%rax)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL2:\n  xor    %r8d,%r8d\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4584
        },
        "L1": {
          "label": "L1",
          "addr": 4488
        },
        "L2": {
          "label": "L2",
          "addr": 4619
        },
        "L3": {
          "label": "L3",
          "addr": 4544
        },
        "L4": {
          "label": "L4",
          "addr": 4567
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *const *argv, int argc) {\n  int i;\n  size_t len = 0;\n  char *ret;\n  for (i = 0; i < argc; i++)\n    len += strlen(argv[i]);\n  if ((ret = malloc(len + 1)) == NULL)\n    return NULL;\n  ret[0] = '\\0';\n  for (i = 0; i < argc; i++)\n    ret = strcat(ret, argv[i]);\n  return ret;\n}"
    },
    {
      "task_id": 30,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11ba <func0+0xa1>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    11b6 <func0+0x9d>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rsi\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rsi),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1158 <func0+0x3f>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL2:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L1\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rsi\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rsi),%xmm0\n  movss  %xmm0,(%rax)\nL1:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4538
        },
        "L1": {
          "label": "L1",
          "addr": 4534
        },
        "L2": {
          "label": "L2",
          "addr": 4440
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float *func0(float *x, int n, int *len) {\n  int i;\n  float *y = malloc(n * sizeof(float));\n  *len = 0;\n  for (i = 0; i < n; i++)\n    if (x[i] > 0)\n      y[(*len)++] = x[i];\n  return y;\n}"
    },
    {
      "task_id": 26,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x70,%rsp\n  mov    %rdi,-0x58(%rbp)\n  mov    %esi,-0x5c(%rbp)\n  mov    %rdx,-0x68(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   1080 <calloc@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   1080 <calloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x4c(%rbp)\n  movl   $0x0,-0x48(%rbp)\n  movl   $0x0,-0x44(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  jmp    12c2 <func0+0x169>\n  mov    -0x40(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x1c(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  jmp    1223 <func0+0xca>\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x1c(%rbp)\n  jne    121f <func0+0xc6>\n  movl   $0x1,-0x3c(%rbp)\n  jmp    122b <func0+0xd2>\n  addl   $0x1,-0x38(%rbp)\n  mov    -0x38(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     11fb <func0+0xa2>\n  cmpl   $0x0,-0x3c(%rbp)\n  jne    12bd <func0+0x164>\n  movl   $0x0,-0x34(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    126d <func0+0x114>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x1c(%rbp)\n  jne    1269 <func0+0x110>\n  movl   $0x1,-0x34(%rbp)\n  jmp    1275 <func0+0x11c>\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     1245 <func0+0xec>\n  cmpl   $0x0,-0x34(%rbp)\n  je     129c <func0+0x143>\n  mov    -0x48(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x48(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    12be <func0+0x165>\n  mov    -0x4c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x4c(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    12be <func0+0x165>\n  nop\n  addl   $0x1,-0x40(%rbp)\n  mov    -0x40(%rbp),%eax\n  cmp    -0x5c(%rbp),%eax\n  jl     11d2 <func0+0x79>\n  movl   $0x0,-0x2c(%rbp)\n  jmp    135c <func0+0x203>\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x20(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    132b <func0+0x1d2>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x20(%rbp)\n  jne    1327 <func0+0x1ce>\n  movl   $0x1,-0x28(%rbp)\n  jmp    1333 <func0+0x1da>\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     1303 <func0+0x1aa>\n  cmpl   $0x0,-0x28(%rbp)\n  jne    1358 <func0+0x1ff>\n  mov    -0x44(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x44(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x20(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x5c(%rbp),%eax\n  jl     12da <func0+0x181>\n  mov    -0x68(%rbp),%rax\n  mov    -0x44(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x18(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x70,%rsp\n  mov    %rdi,-0x58(%rbp)\n  mov    %esi,-0x5c(%rbp)\n  mov    %rdx,-0x68(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   <calloc@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   <calloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x4c(%rbp)\n  movl   $0x0,-0x48(%rbp)\n  movl   $0x0,-0x44(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  jmp    L0\nL12:\n  mov    -0x40(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x1c(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  jmp    L1\nL4:\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x1c(%rbp)\n  jne    L2\n  movl   $0x1,-0x3c(%rbp)\n  jmp    L3\nL2:\n  addl   $0x1,-0x38(%rbp)\nL1:\n  mov    -0x38(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     L4\nL3:\n  cmpl   $0x0,-0x3c(%rbp)\n  jne    L5\n  movl   $0x0,-0x34(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    L6\nL9:\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x1c(%rbp)\n  jne    L7\n  movl   $0x1,-0x34(%rbp)\n  jmp    L8\nL7:\n  addl   $0x1,-0x30(%rbp)\nL6:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     L9\nL8:\n  cmpl   $0x0,-0x34(%rbp)\n  je     L10\n  mov    -0x48(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x48(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    L11\nL10:\n  mov    -0x4c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x4c(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    L11\nL5:\n  nop\nL11:\n  addl   $0x1,-0x40(%rbp)\nL0:\n  mov    -0x40(%rbp),%eax\n  cmp    -0x5c(%rbp),%eax\n  jl     L12\n  movl   $0x0,-0x2c(%rbp)\n  jmp    L13\nL19:\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x20(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L14\nL17:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x20(%rbp)\n  jne    L15\n  movl   $0x1,-0x28(%rbp)\n  jmp    L16\nL15:\n  addl   $0x1,-0x24(%rbp)\nL14:\n  mov    -0x24(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     L17\nL16:\n  cmpl   $0x0,-0x28(%rbp)\n  jne    L18\n  mov    -0x44(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x44(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x20(%rbp),%eax\n  mov    %eax,(%rdx)\nL18:\n  addl   $0x1,-0x2c(%rbp)\nL13:\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x5c(%rbp),%eax\n  jl     L19\n  mov    -0x68(%rbp),%rax\n  mov    -0x44(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x18(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4802
        },
        "L1": {
          "label": "L1",
          "addr": 4643
        },
        "L2": {
          "label": "L2",
          "addr": 4639
        },
        "L3": {
          "label": "L3",
          "addr": 4651
        },
        "L4": {
          "label": "L4",
          "addr": 4603
        },
        "L5": {
          "label": "L5",
          "addr": 4797
        },
        "L6": {
          "label": "L6",
          "addr": 4717
        },
        "L7": {
          "label": "L7",
          "addr": 4713
        },
        "L8": {
          "label": "L8",
          "addr": 4725
        },
        "L9": {
          "label": "L9",
          "addr": 4677
        },
        "L10": {
          "label": "L10",
          "addr": 4764
        },
        "L11": {
          "label": "L11",
          "addr": 4798
        },
        "L12": {
          "label": "L12",
          "addr": 4562
        },
        "L13": {
          "label": "L13",
          "addr": 4956
        },
        "L14": {
          "label": "L14",
          "addr": 4907
        },
        "L15": {
          "label": "L15",
          "addr": 4903
        },
        "L16": {
          "label": "L16",
          "addr": 4915
        },
        "L17": {
          "label": "L17",
          "addr": 4867
        },
        "L18": {
          "label": "L18",
          "addr": 4952
        },
        "L19": {
          "label": "L19",
          "addr": 4826
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int *nn) {\n  int *a = malloc(n * sizeof(int));\n  int *b = calloc(n, sizeof(int));\n  int *c = calloc(n, sizeof(int));\n  int m = 0, k = 0, l = 0;\n  for (int i = 0; i < n; i++) {\n    int y = x[i];\n    int f = 0;\n    for (int j = 0; j < k; j++)\n      if (c[j] == y) {\n        f = 1;\n        break;\n      }\n    if (f)\n      continue;\n    int g = 0;\n    for (int j = 0; j < m; j++)\n      if (b[j] == y) {\n        g = 1;\n        break;\n      }\n    if (g)\n      c[k++] = y;\n    else\n      b[m++] = y;\n  }\n  for (int i = 0; i < n; i++) {\n    int y = x[i];\n    int f = 0;\n    for (int j = 0; j < k; j++)\n      if (c[j] == y) {\n        f = 1;\n        break;\n      }\n    if (!f)\n      a[l++] = y;\n  }\n  *nn = l;\n  free(b);\n  free(c);\n  return a;\n}"
    },
    {
      "task_id": 30,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x0,(%rbx)\n  test   %ebp,%ebp\n  jle    1177 <func0+0x5e>\n  mov    %r12,%rdx\n  lea    -0x1(%rbp),%ecx\n  lea    0x4(%r12,%rcx,4),%rdi\n  pxor   %xmm1,%xmm1\n  jmp    116c <func0+0x53>\n  mov    (%rbx),%ecx\n  lea    0x1(%rcx),%esi\n  mov    %esi,(%rbx)\n  movslq %ecx,%rcx\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax,%rcx,4)\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  je     1177 <func0+0x5e>\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  ja     1150 <func0+0x37>\n  jmp    1163 <func0+0x4a>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x0,(%rbx)\n  test   %ebp,%ebp\n  jle    L0\n  mov    %r12,%rdx\n  lea    -0x1(%rbp),%ecx\n  lea    0x4(%r12,%rcx,4),%rdi\n  pxor   %xmm1,%xmm1\n  jmp    L1\nL2:\n  mov    (%rbx),%ecx\n  lea    0x1(%rcx),%esi\n  mov    %esi,(%rbx)\n  movslq %ecx,%rcx\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax,%rcx,4)\nL3:\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  je     L0\nL1:\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  ja     L2\n  jmp    L3\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4471
        },
        "L1": {
          "label": "L1",
          "addr": 4460
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4451
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float *func0(float *x, int n, int *ni) {\n  float *y = malloc(n * sizeof *y);\n  *ni = 0;\n  for (int i = 0; i < n; i++) {\n    if (x[i] > 0)\n      y[(*ni)++] = x[i];\n  }\n  return y;\n}"
    },
    {
      "task_id": 30,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    1181 <func0+0x61>\n  lea    -0x1(%r12),%ecx\n  mov    %rbx,%rdx\n  pxor   %xmm1,%xmm1\n  lea    0x4(%rbx,%rcx,4),%rdi\n  nopw   0x0(%rax,%rax,1)\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    1178 <func0+0x58>\n  movslq 0x0(%rbp),%rcx\n  lea    0x1(%rcx),%esi\n  movss  %xmm0,(%rax,%rcx,4)\n  mov    %esi,0x0(%rbp)\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    1160 <func0+0x40>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%ecx\n  mov    %rbx,%rdx\n  pxor   %xmm1,%xmm1\n  lea    0x4(%rbx,%rcx,4),%rdi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    L1\n  movslq 0x0(%rbp),%rcx\n  lea    0x1(%rcx),%esi\n  movss  %xmm0,(%rax,%rcx,4)\n  mov    %esi,0x0(%rbp)\nL1:\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    L2\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4481
        },
        "L1": {
          "label": "L1",
          "addr": 4472
        },
        "L2": {
          "label": "L2",
          "addr": 4448
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float *func0(float *x, int n, int *res_n) {\n  float *y = malloc(n * sizeof(float));\n  *res_n = 0;\n  for (int i = 0; i < n; i++) {\n    if (x[i] > 0) {\n      y[*res_n] = x[i];\n      (*res_n)++;\n    }\n  }\n  return y;\n}"
    },
    {
      "task_id": 31,
      "type": "O0",
      "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  cmpq   $0x1,-0x18(%rbp)\n  jg     1113 <func0+0x1a>\n  mov    $0x0,%eax\n  jmp    114e <func0+0x55>\n  movq   $0x2,-0x8(%rbp)\n  jmp    113b <func0+0x42>\n  mov    -0x18(%rbp),%rax\n  cqto\n  idivq  -0x8(%rbp)\n  mov    %rdx,%rax\n  test   %rax,%rax\n  jne    1136 <func0+0x3d>\n  mov    $0x0,%eax\n  jmp    114e <func0+0x55>\n  addq   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  imul   %rax,%rax\n  cmp    %rax,-0x18(%rbp)\n  jge    111d <func0+0x24>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  cmpq   $0x1,-0x18(%rbp)\n  jg     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movq   $0x2,-0x8(%rbp)\n  jmp    L2\nL4:\n  mov    -0x18(%rbp),%rax\n  cqto\n  idivq  -0x8(%rbp)\n  mov    %rdx,%rax\n  test   %rax,%rax\n  jne    L3\n  mov    $0x0,%eax\n  jmp    L1\nL3:\n  addq   $0x1,-0x8(%rbp)\nL2:\n  mov    -0x8(%rbp),%rax\n  imul   %rax,%rax\n  cmp    %rax,-0x18(%rbp)\n  jge    L4\n  mov    $0x1,%eax\nL1:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4371
        },
        "L1": {
          "label": "L1",
          "addr": 4430
        },
        "L2": {
          "label": "L2",
          "addr": 4411
        },
        "L3": {
          "label": "L3",
          "addr": 4406
        },
        "L4": {
          "label": "L4",
          "addr": 4381
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " long func0(long x) {\n  long i;\n  if (x <= 1)\n    return 0;\n  for (i = 2; i * i <= x; i++)\n    if (x % i == 0)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 29,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rcx,%r15\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rdx,%rdi\n  sub    $0x18,%rsp\n  call   1080 <strlen@plt>\n  movslq %r12d,%rdi\n  shl    $0x3,%rdi\n  mov    %rax,%rbp\n  call   1090 <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  mov    %rax,(%r15)\n  test   %r12d,%r12d\n  jle    1200 <func0+0xa0>\n  lea    -0x1(%r12),%eax\n  movslq %ebp,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rbx,%rax,8),%r15\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx),%r14\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   1070 <strncmp@plt>\n  test   %eax,%eax\n  jne    11dd <func0+0x7d>\n  mov    0x8(%rsp),%rcx\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r14,(%rcx,%rax,8)\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    11b8 <func0+0x58>\n  add    $0x18,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %r12d,%r12d\n  jmp    11e6 <func0+0x86>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rcx,%r15\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rdx,%rdi\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  movslq %r12d,%rdi\n  shl    $0x3,%rdi\n  mov    %rax,%rbp\n  call   <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  mov    %rax,(%r15)\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  movslq %ebp,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rbx,%rax,8),%r15\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    (%rbx),%r14\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   <strncmp@plt>\n  test   %eax,%eax\n  jne    L1\n  mov    0x8(%rsp),%rcx\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r14,(%rcx,%rax,8)\nL1:\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    L2\nL3:\n  add    $0x18,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  xor    %r12d,%r12d\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4608
        },
        "L1": {
          "label": "L1",
          "addr": 4573
        },
        "L2": {
          "label": "L2",
          "addr": 4536
        },
        "L3": {
          "label": "L3",
          "addr": 4582
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char **strings, int n, char *substr, char ***answer) {\n  int substr_len = strlen(substr);\n  *answer = (char **)malloc(n * sizeof(char *));\n  char **ans = *answer;\n  int ans_len = 0;\n  for (int i = 0; i < n; i++) {\n    char *str = strings[i];\n    if (!strncmp(str, substr, substr_len)) {\n      ans[ans_len++] = str;\n    }\n  }\n  return ans_len;\n}"
    },
    {
      "task_id": 30,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    1181 <func0+0x61>\n  lea    -0x1(%r12),%ecx\n  mov    %rbx,%rdx\n  pxor   %xmm1,%xmm1\n  lea    0x4(%rbx,%rcx,4),%rdi\n  nopw   0x0(%rax,%rax,1)\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    1178 <func0+0x58>\n  movslq 0x0(%rbp),%rcx\n  lea    0x1(%rcx),%esi\n  movss  %xmm0,(%rax,%rcx,4)\n  mov    %esi,0x0(%rbp)\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    1160 <func0+0x40>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%ecx\n  mov    %rbx,%rdx\n  pxor   %xmm1,%xmm1\n  lea    0x4(%rbx,%rcx,4),%rdi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    L1\n  movslq 0x0(%rbp),%rcx\n  lea    0x1(%rcx),%esi\n  movss  %xmm0,(%rax,%rcx,4)\n  mov    %esi,0x0(%rbp)\nL1:\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    L2\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4481
        },
        "L1": {
          "label": "L1",
          "addr": 4472
        },
        "L2": {
          "label": "L2",
          "addr": 4448
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float *func0(float *x, int n, int *res_n) {\n  float *y = malloc(n * sizeof(float));\n  *res_n = 0;\n  for (int i = 0; i < n; i++) {\n    if (x[i] > 0) {\n      y[*res_n] = x[i];\n      (*res_n)++;\n    }\n  }\n  return y;\n}"
    },
    {
      "task_id": 29,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rcx,%r15\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rdx,%rdi\n  sub    $0x18,%rsp\n  call   1080 <strlen@plt>\n  movslq %r12d,%rdi\n  shl    $0x3,%rdi\n  mov    %rax,%rbp\n  call   1090 <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  mov    %rax,(%r15)\n  test   %r12d,%r12d\n  jle    1200 <func0+0xa0>\n  lea    -0x1(%r12),%eax\n  movslq %ebp,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rbx,%rax,8),%r15\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx),%r14\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   1070 <strncmp@plt>\n  test   %eax,%eax\n  jne    11dd <func0+0x7d>\n  mov    0x8(%rsp),%rcx\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r14,(%rcx,%rax,8)\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    11b8 <func0+0x58>\n  add    $0x18,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %r12d,%r12d\n  jmp    11e6 <func0+0x86>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rcx,%r15\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rdx,%rdi\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  movslq %r12d,%rdi\n  shl    $0x3,%rdi\n  mov    %rax,%rbp\n  call   <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  mov    %rax,(%r15)\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  movslq %ebp,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rbx,%rax,8),%r15\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    (%rbx),%r14\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   <strncmp@plt>\n  test   %eax,%eax\n  jne    L1\n  mov    0x8(%rsp),%rcx\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r14,(%rcx,%rax,8)\nL1:\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    L2\nL3:\n  add    $0x18,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  xor    %r12d,%r12d\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4608
        },
        "L1": {
          "label": "L1",
          "addr": 4573
        },
        "L2": {
          "label": "L2",
          "addr": 4536
        },
        "L3": {
          "label": "L3",
          "addr": 4582
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char **strings, int n, char *substr, char ***answer) {\n  int substr_len = strlen(substr);\n  *answer = (char **)malloc(n * sizeof(char *));\n  char **ans = *answer;\n  int ans_len = 0;\n  for (int i = 0; i < n; i++) {\n    char *str = strings[i];\n    if (!strncmp(str, substr, substr_len)) {\n      ans[ans_len++] = str;\n    }\n  }\n  return ans_len;\n}"
    },
    {
      "task_id": 31,
      "type": "O2",
      "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%rdi\n  jle    114a <func0+0x4a>\n  cmp    $0x3,%rdi\n  jle    113d <func0+0x3d>\n  test   $0x1,%dil\n  je     114a <func0+0x4a>\n  mov    $0x2,%ecx\n  jmp    112d <func0+0x2d>\n  nop\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  je     1148 <func0+0x48>\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jle    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%rdi\n  jle    L0\n  cmp    $0x3,%rdi\n  jle    L1\n  test   $0x1,%dil\n  je     L0\n  mov    $0x2,%ecx\n  jmp    L2\n  nop\nL4:\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  je     L3\nL2:\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jle    L4\nL1:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  xor    %eax,%eax\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4426
        },
        "L1": {
          "label": "L1",
          "addr": 4413
        },
        "L2": {
          "label": "L2",
          "addr": 4397
        },
        "L3": {
          "label": "L3",
          "addr": 4424
        },
        "L4": {
          "label": "L4",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(long x) {\n  long i;\n  if (x < 2)\n    return 0;\n  for (i = 2; i * i <= x; i++)\n    if (x % i == 0)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 31,
      "type": "O3",
      "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%rdi\n  jle    114a <func0+0x4a>\n  cmp    $0x3,%rdi\n  jle    113d <func0+0x3d>\n  test   $0x1,%dil\n  je     114a <func0+0x4a>\n  mov    $0x2,%ecx\n  jmp    112d <func0+0x2d>\n  nop\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  je     1148 <func0+0x48>\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jle    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%rdi\n  jle    L0\n  cmp    $0x3,%rdi\n  jle    L1\n  test   $0x1,%dil\n  je     L0\n  mov    $0x2,%ecx\n  jmp    L2\n  nop\nL4:\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  je     L3\nL2:\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jle    L4\nL1:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  xor    %eax,%eax\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4426
        },
        "L1": {
          "label": "L1",
          "addr": 4413
        },
        "L2": {
          "label": "L2",
          "addr": 4397
        },
        "L3": {
          "label": "L3",
          "addr": 4424
        },
        "L4": {
          "label": "L4",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(long x) {\n  long i;\n  if (x < 2)\n    return 0;\n  for (i = 2; i * i <= x; i++)\n    if (x % i == 0)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 31,
      "type": "O1",
      "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  cmp    $0x1,%rdi\n  jle    113b <func0+0x42>\n  cmp    $0x3,%rdi\n  jle    1142 <func0+0x49>\n  test   $0x1,%dil\n  je     1148 <func0+0x4f>\n  mov    $0x2,%ecx\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jg     113c <func0+0x43>\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  jne    1119 <func0+0x20>\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  cmp    $0x1,%rdi\n  jle    L0\n  cmp    $0x3,%rdi\n  jle    L1\n  test   $0x1,%dil\n  je     L2\n  mov    $0x2,%ecx\nL4:\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jg     L3\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  jne    L4\n  mov    $0x0,%eax\nL0:\n  ret\nL3:\n  mov    $0x1,%eax\n  ret\nL1:\n  mov    $0x1,%eax\n  ret\nL2:\n  mov    $0x0,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4411
        },
        "L1": {
          "label": "L1",
          "addr": 4418
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        },
        "L3": {
          "label": "L3",
          "addr": 4412
        },
        "L4": {
          "label": "L4",
          "addr": 4377
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(long x) {\n  long i;\n  if (x <= 1)\n    return 0;\n  for (i = 2; i * i <= x; i++)\n    if (x % i == 0)\n      return 1;\n  return 0;\n}"
    },
    {
      "task_id": 27,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  mov    %rax,%rdx\n  test   %eax,%eax\n  jle    148b <func0+0x36b>\n  lea    0x1(%rbp),%rsi\n  mov    %rbx,%rcx\n  lea    -0x1(%rax),%eax\n  sub    %rsi,%rcx\n  cmp    $0xe,%rcx\n  jbe    14a0 <func0+0x380>\n  cmp    $0xe,%eax\n  jbe    14a0 <func0+0x380>\n  mov    %edx,%ecx\n  movdqa 0xeb6(%rip),%xmm5        # 2020 <_fini+0x9f0>\n  xor    %eax,%eax\n  pxor   %xmm4,%xmm4\n  shr    $0x4,%ecx\n  movdqa 0xeb5(%rip),%xmm7        # 2030 <_fini+0xa00>\n  movdqa 0xe7c(%rip),%xmm9        # 2000 <_fini+0x9d0>\n  movdqa 0xe83(%rip),%xmm8        # 2010 <_fini+0x9e0>\n  movdqa 0xeab(%rip),%xmm6        # 2040 <_fini+0xa10>\n  shl    $0x4,%rcx\n  nopl   0x0(%rax)\n  movdqu 0x0(%rbp,%rax,1),%xmm3\n  movdqa %xmm3,%xmm0\n  movdqa %xmm3,%xmm1\n  paddb  %xmm8,%xmm0\n  paddb  %xmm9,%xmm1\n  movdqa %xmm0,%xmm2\n  psubusb %xmm5,%xmm1\n  pminub %xmm5,%xmm2\n  pcmpeqb %xmm4,%xmm1\n  pcmpeqb %xmm0,%xmm2\n  psubusb %xmm5,%xmm0\n  pcmpeqb %xmm4,%xmm0\n  movdqa %xmm1,%xmm10\n  pcmpeqb %xmm4,%xmm10\n  pcmpeqb %xmm4,%xmm0\n  pand   %xmm10,%xmm2\n  pand   %xmm10,%xmm0\n  movdqa %xmm3,%xmm10\n  paddb  %xmm7,%xmm10\n  pand   %xmm1,%xmm10\n  pandn  %xmm3,%xmm1\n  por    %xmm10,%xmm1\n  movdqa %xmm3,%xmm10\n  paddb  %xmm6,%xmm3\n  pand   %xmm0,%xmm10\n  pandn  %xmm1,%xmm0\n  pand   %xmm2,%xmm3\n  por    %xmm10,%xmm0\n  pandn  %xmm0,%xmm2\n  por    %xmm3,%xmm2\n  movups %xmm2,(%rbx,%rax,1)\n  add    $0x10,%rax\n  cmp    %rcx,%rax\n  jne    11a0 <func0+0x80>\n  mov    %edx,%eax\n  and    $0xfffffff0,%eax\n  test   $0xf,%dl\n  je     148b <func0+0x36b>\n  movslq %eax,%rsi\n  movzbl 0x0(%rbp,%rsi,1),%ecx\n  lea    -0x61(%rcx),%edi\n  cmp    $0x19,%dil\n  jbe    14e0 <func0+0x3c0>\n  lea    -0x41(%rcx),%r8d\n  lea    0x20(%rcx),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%ecx\n  mov    %cl,(%rbx,%rsi,1)\n  lea    0x1(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     14f0 <func0+0x3d0>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x2(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1508 <func0+0x3e8>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x3(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1520 <func0+0x400>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1538 <func0+0x418>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x5(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1550 <func0+0x430>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x6(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1568 <func0+0x448>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x7(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  jbe    1580 <func0+0x460>\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x8(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1590 <func0+0x470>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x9(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     15a8 <func0+0x488>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xa(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     15c0 <func0+0x4a0>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xb(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     15d8 <func0+0x4b8>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xc(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     15f0 <func0+0x4d0>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xd(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1608 <func0+0x4e8>\n  sub    $0x20,%esi\n  add    $0xe,%eax\n  mov    %sil,(%rbx,%rcx,1)\n  cmp    %eax,%edx\n  jle    148b <func0+0x36b>\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%ecx\n  lea    -0x61(%rcx),%esi\n  cmp    $0x19,%sil\n  ja     161b <func0+0x4fb>\n  sub    $0x20,%ecx\n  mov    %cl,(%rbx,%rax,1)\n  movslq %edx,%rdx\n  movb   $0x0,(%rbx,%rdx,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   0x0(%rax)\n  mov    %eax,%esi\n  xor    %ecx,%ecx\n  jmp    14c2 <func0+0x3a2>\n  cs nopw 0x0(%rax,%rax,1)\n  sub    $0x20,%eax\n  mov    %al,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rax\n  cmp    %rsi,%rcx\n  je     148b <func0+0x36b>\n  mov    %rax,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%eax\n  lea    -0x61(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    14b0 <func0+0x390>\n  lea    -0x41(%rax),%r8d\n  lea    0x20(%rax),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%eax\n  jmp    14b3 <func0+0x393>\n  sub    $0x20,%ecx\n  jmp    1269 <func0+0x149>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    128f <func0+0x16f>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    12b6 <func0+0x196>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    12dd <func0+0x1bd>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    1304 <func0+0x1e4>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    132b <func0+0x20b>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    1352 <func0+0x232>\n  nopl   0x0(%rax,%rax,1)\n  sub    $0x20,%esi\n  jmp    1384 <func0+0x264>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    13ab <func0+0x28b>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    13d2 <func0+0x2b2>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    13f9 <func0+0x2d9>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    1420 <func0+0x300>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    1443 <func0+0x323>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    1466 <func0+0x346>\n  lea    -0x41(%rcx),%edi\n  lea    0x20(%rcx),%esi\n  cmp    $0x1a,%dil\n  cmovb  %esi,%ecx\n  jmp    1488 <func0+0x368>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    %rax,%rdx\n  test   %eax,%eax\n  jle    L0\n  lea    0x1(%rbp),%rsi\n  mov    %rbx,%rcx\n  lea    -0x1(%rax),%eax\n  sub    %rsi,%rcx\n  cmp    $0xe,%rcx\n  jbe    L1\n  cmp    $0xe,%eax\n  jbe    L1\n  mov    %edx,%ecx\n  movdqa D0(%rip),%xmm5\n  xor    %eax,%eax\n  pxor   %xmm4,%xmm4\n  shr    $0x4,%ecx\n  movdqa D1(%rip),%xmm7\n  movdqa D2(%rip),%xmm9\n  movdqa D3(%rip),%xmm8\n  movdqa D4(%rip),%xmm6\n  shl    $0x4,%rcx\n  nopl   0x0(%rax)\nL2:\n  movdqu 0x0(%rbp,%rax,1),%xmm3\n  movdqa %xmm3,%xmm0\n  movdqa %xmm3,%xmm1\n  paddb  %xmm8,%xmm0\n  paddb  %xmm9,%xmm1\n  movdqa %xmm0,%xmm2\n  psubusb %xmm5,%xmm1\n  pminub %xmm5,%xmm2\n  pcmpeqb %xmm4,%xmm1\n  pcmpeqb %xmm0,%xmm2\n  psubusb %xmm5,%xmm0\n  pcmpeqb %xmm4,%xmm0\n  movdqa %xmm1,%xmm10\n  pcmpeqb %xmm4,%xmm10\n  pcmpeqb %xmm4,%xmm0\n  pand   %xmm10,%xmm2\n  pand   %xmm10,%xmm0\n  movdqa %xmm3,%xmm10\n  paddb  %xmm7,%xmm10\n  pand   %xmm1,%xmm10\n  pandn  %xmm3,%xmm1\n  por    %xmm10,%xmm1\n  movdqa %xmm3,%xmm10\n  paddb  %xmm6,%xmm3\n  pand   %xmm0,%xmm10\n  pandn  %xmm1,%xmm0\n  pand   %xmm2,%xmm3\n  por    %xmm10,%xmm0\n  pandn  %xmm0,%xmm2\n  por    %xmm3,%xmm2\n  movups %xmm2,(%rbx,%rax,1)\n  add    $0x10,%rax\n  cmp    %rcx,%rax\n  jne    L2\n  mov    %edx,%eax\n  and    $0xfffffff0,%eax\n  test   $0xf,%dl\n  je     L0\n  movslq %eax,%rsi\n  movzbl 0x0(%rbp,%rsi,1),%ecx\n  lea    -0x61(%rcx),%edi\n  cmp    $0x19,%dil\n  jbe    L3\n  lea    -0x41(%rcx),%r8d\n  lea    0x20(%rcx),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%ecx\nL21:\n  mov    %cl,(%rbx,%rsi,1)\n  lea    0x1(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L4\n  sub    $0x20,%esi\nL22:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x2(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L5\n  sub    $0x20,%esi\nL23:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x3(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L6\n  sub    $0x20,%esi\nL24:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L7\n  sub    $0x20,%esi\nL25:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x5(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L8\n  sub    $0x20,%esi\nL26:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x6(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L9\n  sub    $0x20,%esi\nL27:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x7(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  jbe    L10\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\nL28:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x8(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L11\n  sub    $0x20,%esi\nL29:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x9(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L12\n  sub    $0x20,%esi\nL30:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xa(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L13\n  sub    $0x20,%esi\nL31:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xb(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L14\n  sub    $0x20,%esi\nL32:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xc(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L15\n  sub    $0x20,%esi\nL33:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xd(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L16\n  sub    $0x20,%esi\nL34:\n  add    $0xe,%eax\n  mov    %sil,(%rbx,%rcx,1)\n  cmp    %eax,%edx\n  jle    L0\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%ecx\n  lea    -0x61(%rcx),%esi\n  cmp    $0x19,%sil\n  ja     L17\n  sub    $0x20,%ecx\nL35:\n  mov    %cl,(%rbx,%rax,1)\nL0:\n  movslq %edx,%rdx\n  movb   $0x0,(%rbx,%rdx,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    %eax,%esi\n  xor    %ecx,%ecx\n  jmp    L18\n  cs nopw 0x0(%rax,%rax,1)\nL19:\n  sub    $0x20,%eax\nL20:\n  mov    %al,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rax\n  cmp    %rsi,%rcx\n  je     L0\n  mov    %rax,%rcx\nL18:\n  movzbl 0x0(%rbp,%rcx,1),%eax\n  lea    -0x61(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    L19\n  lea    -0x41(%rax),%r8d\n  lea    0x20(%rax),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%eax\n  jmp    L20\nL3:\n  sub    $0x20,%ecx\n  jmp    L21\n  nopl   0x0(%rax,%rax,1)\nL4:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L22\n  nopl   0x0(%rax,%rax,1)\nL5:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L23\n  nopl   0x0(%rax,%rax,1)\nL6:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L24\n  nopl   0x0(%rax,%rax,1)\nL7:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L25\n  nopl   0x0(%rax,%rax,1)\nL8:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L26\n  nopl   0x0(%rax,%rax,1)\nL9:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L27\n  nopl   0x0(%rax,%rax,1)\nL10:\n  sub    $0x20,%esi\n  jmp    L28\n  nopl   0x0(%rax,%rax,1)\nL11:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L29\n  nopl   0x0(%rax,%rax,1)\nL12:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L30\n  nopl   0x0(%rax,%rax,1)\nL13:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L31\n  nopl   0x0(%rax,%rax,1)\nL14:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L32\n  nopl   0x0(%rax,%rax,1)\nL15:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L33\n  nopl   0x0(%rax,%rax,1)\nL16:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L34\nL17:\n  lea    -0x41(%rcx),%edi\n  lea    0x20(%rcx),%esi\n  cmp    $0x1a,%dil\n  cmovb  %esi,%ecx\n  jmp    L35",
      "num_missing": 5,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8224,
          "bias": [
            3766
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8240,
          "bias": [
            3765
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8192,
          "bias": [
            3708
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8208,
          "bias": [
            3715
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8256,
          "bias": [
            3755
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5259
        },
        "L1": {
          "label": "L1",
          "addr": 5280
        },
        "L2": {
          "label": "L2",
          "addr": 4512
        },
        "L3": {
          "label": "L3",
          "addr": 5344
        },
        "L4": {
          "label": "L4",
          "addr": 5360
        },
        "L5": {
          "label": "L5",
          "addr": 5384
        },
        "L6": {
          "label": "L6",
          "addr": 5408
        },
        "L7": {
          "label": "L7",
          "addr": 5432
        },
        "L8": {
          "label": "L8",
          "addr": 5456
        },
        "L9": {
          "label": "L9",
          "addr": 5480
        },
        "L10": {
          "label": "L10",
          "addr": 5504
        },
        "L11": {
          "label": "L11",
          "addr": 5520
        },
        "L12": {
          "label": "L12",
          "addr": 5544
        },
        "L13": {
          "label": "L13",
          "addr": 5568
        },
        "L14": {
          "label": "L14",
          "addr": 5592
        },
        "L15": {
          "label": "L15",
          "addr": 5616
        },
        "L16": {
          "label": "L16",
          "addr": 5640
        },
        "L17": {
          "label": "L17",
          "addr": 5659
        },
        "L18": {
          "label": "L18",
          "addr": 5314
        },
        "L19": {
          "label": "L19",
          "addr": 5296
        },
        "L20": {
          "label": "L20",
          "addr": 5299
        },
        "L21": {
          "label": "L21",
          "addr": 4713
        },
        "L22": {
          "label": "L22",
          "addr": 4751
        },
        "L23": {
          "label": "L23",
          "addr": 4790
        },
        "L24": {
          "label": "L24",
          "addr": 4829
        },
        "L25": {
          "label": "L25",
          "addr": 4868
        },
        "L26": {
          "label": "L26",
          "addr": 4907
        },
        "L27": {
          "label": "L27",
          "addr": 4946
        },
        "L28": {
          "label": "L28",
          "addr": 4996
        },
        "L29": {
          "label": "L29",
          "addr": 5035
        },
        "L30": {
          "label": "L30",
          "addr": 5074
        },
        "L31": {
          "label": "L31",
          "addr": 5113
        },
        "L32": {
          "label": "L32",
          "addr": 5152
        },
        "L33": {
          "label": "L33",
          "addr": 5187
        },
        "L34": {
          "label": "L34",
          "addr": 5222
        },
        "L35": {
          "label": "L35",
          "addr": 5256
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9fbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf19191919191919191919191919191919e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e020202020202020202020202020202020",
      "rodata_parsed": {
        "func0": {
          "0x2020": {
            "type": "byte[16]",
            "value": [
              25,
              25,
              25,
              25,
              25,
              25,
              25,
              25,
              25,
              25,
              25,
              25,
              25,
              25,
              25,
              25
            ]
          },
          "0x2030": {
            "type": "byte[16]",
            "value": [
              224,
              224,
              224,
              224,
              224,
              224,
              224,
              224,
              224,
              224,
              224,
              224,
              224,
              224,
              224,
              224
            ]
          },
          "0x2000": {
            "type": "byte[16]",
            "value": [
              159,
              159,
              159,
              159,
              159,
              159,
              159,
              159,
              159,
              159,
              159,
              159,
              159,
              159,
              159,
              159
            ]
          },
          "0x2010": {
            "type": "byte[16]",
            "value": [
              191,
              191,
              191,
              191,
              191,
              191,
              191,
              191,
              191,
              191,
              191,
              191,
              191,
              191,
              191,
              191
            ]
          },
          "0x2040": {
            "type": "byte[16]",
            "value": [
              32,
              32,
              32,
              32,
              32,
              32,
              32,
              32,
              32,
              32,
              32,
              32,
              32,
              32,
              32,
              32
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *str, char *str1) {\n  int i = 0;\n  int len = strlen(str);\n  for (i = 0; i < len; i++) {\n    if (str[i] >= 'a' && str[i] <= 'z') {\n      str1[i] = str[i] - 32;\n    } else if (str[i] >= 'A' && str[i] <= 'Z') {\n      str1[i] = str[i] + 32;\n    } else {\n      str1[i] = str[i];\n    }\n  }\n  str1[len] = '\\0';\n}"
    },
    {
      "task_id": 19,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  lea    0xebc(%rip),%r15        # 2009 <_fini+0xad1>\n  pxor   %xmm0,%xmm0\n  push   %r14\n  lea    0xeb3(%rip),%r14        # 200d <_fini+0xad5>\n  movq   %r15,%xmm4\n  push   %r13\n  lea    0xe98(%rip),%r13        # 2000 <_fini+0xac8>\n  movq   %r14,%xmm6\n  push   %r12\n  movq   %r13,%xmm5\n  punpcklqdq %xmm6,%xmm4\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  movq   0x2c67(%rip),%xmm3        # 3df0 <__do_global_dtors_aux_fini_array_entry+0x10>\n  movq   0x2c6f(%rip),%xmm2        # 3e00 <__do_global_dtors_aux_fini_array_entry+0x20>\n  movq   0x2c77(%rip),%xmm1        # 3e10 <__do_global_dtors_aux_fini_array_entry+0x30>\n  movhps 0x2c48(%rip),%xmm5        # 3de8 <__do_global_dtors_aux_fini_array_entry+0x8>\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%eax\n  movhps 0x2c3b(%rip),%xmm3        # 3df8 <__do_global_dtors_aux_fini_array_entry+0x18>\n  movaps %xmm0,(%rsp)\n  movhps 0x2c40(%rip),%xmm2        # 3e08 <__do_global_dtors_aux_fini_array_entry+0x28>\n  movhps 0x2c49(%rip),%xmm1        # 3e18 <__do_global_dtors_aux_fini_array_entry+0x38>\n  movaps %xmm0,0x10(%rsp)\n  movq   $0x0,0x20(%rsp)\n  movaps %xmm5,0x30(%rsp)\n  movaps %xmm4,0x40(%rsp)\n  movaps %xmm3,0x50(%rsp)\n  movaps %xmm2,0x60(%rsp)\n  movaps %xmm1,0x70(%rsp)\n  test   %al,%al\n  je     139b <func0+0x25b>\n  mov    %rdi,%rbp\n  lea    0x82(%rsp),%rbx\n  jmp    1372 <func0+0x232>\n  mov    %al,0x82(%rsp)\n  movzbl 0x1(%rbp),%eax\n  test   $0xdf,%al\n  je     1458 <func0+0x318>\n  mov    %al,0x83(%rsp)\n  movzbl 0x2(%rbp),%eax\n  test   $0xdf,%al\n  je     1468 <func0+0x328>\n  mov    %al,0x84(%rsp)\n  movzbl 0x3(%rbp),%eax\n  test   $0xdf,%al\n  je     1481 <func0+0x341>\n  mov    %al,0x85(%rsp)\n  movzbl 0x4(%rbp),%eax\n  test   $0xdf,%al\n  je     1491 <func0+0x351>\n  mov    %al,0x86(%rsp)\n  movzbl 0x5(%rbp),%eax\n  test   $0xdf,%al\n  je     14a1 <func0+0x361>\n  mov    %al,0x87(%rsp)\n  mov    $0x6,%r12d\n  mov    $0x6,%eax\n  add    $0x1,%r12\n  mov    %r13,%rsi\n  mov    %rbx,%rdi\n  movb   $0x0,0x82(%rsp,%rax,1)\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     138c <func0+0x24c>\n  lea    0xd60(%rip),%rsi        # 2005 <_fini+0xacd>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1387 <func0+0x247>\n  mov    %r15,%rsi\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     14c1 <func0+0x381>\n  mov    %r14,%rsi\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     14b1 <func0+0x371>\n  lea    0xd31(%rip),%rsi        # 2013 <_fini+0xadb>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     14e1 <func0+0x3a1>\n  lea    0xd1f(%rip),%rsi        # 2018 <_fini+0xae0>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     14d1 <func0+0x391>\n  lea    0xd0d(%rip),%rsi        # 201d <_fini+0xae5>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1501 <func0+0x3c1>\n  lea    0xcfa(%rip),%rsi        # 2021 <_fini+0xae9>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1511 <func0+0x3d1>\n  lea    0xce9(%rip),%rsi        # 2027 <_fini+0xaef>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1521 <func0+0x3e1>\n  lea    0xcd8(%rip),%rsi        # 202d <_fini+0xaf5>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     14f1 <func0+0x3b1>\n  add    %r12,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     139b <func0+0x25b>\n  movzbl 0x0(%rbp),%eax\n  test   $0xdf,%al\n  jne    120e <func0+0xce>\n  mov    $0x1,%r12d\n  xor    %eax,%eax\n  jmp    1283 <func0+0x143>\n  mov    $0x1,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  add    %r12,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  jne    136e <func0+0x22e>\n  lea    0x2cbe(%rip),%r12        # 4060 <out.0>\n  xor    %ebx,%ebx\n  xor    %esi,%esi\n  mov    %rsp,%rbp\n  lea    -0x1(%r12),%rdi\n  xchg   %ax,%ax\n  mov    0x0(%rbp,%rbx,4),%r10d\n  test   %r10d,%r10d\n  jle    1414 <func0+0x2d4>\n  mov    0x30(%rsp,%rbx,8),%r11\n  xor    %r8d,%r8d\n  movzbl (%r11),%r9d\n  cs nopw 0x0(%rax,%rax,1)\n  movslq %esi,%rcx\n  test   %r9b,%r9b\n  je     1403 <func0+0x2c3>\n  lea    0x1(%rsi),%eax\n  movslq %esi,%rcx\n  mov    %r11,%rsi\n  mov    %r9d,%edx\n  cltq\n  sub    %rcx,%rsi\n  nopl   0x0(%rax)\n  mov    %dl,(%rdi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    13f0 <func0+0x2b0>\n  add    $0x1,%r8d\n  movb   $0x20,(%r12,%rcx,1)\n  lea    0x1(%rcx),%esi\n  cmp    %r8d,%r10d\n  jne    13d0 <func0+0x290>\n  add    $0x1,%rbx\n  cmp    $0xa,%rbx\n  jne    13b0 <func0+0x270>\n  test   %esi,%esi\n  je     1478 <func0+0x338>\n  lea    -0x1(%rsi),%eax\n  cltq\n  movb   $0x0,(%r12,%rax,1)\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1531 <func0+0x3f1>\n  add    $0x98,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    $0x1,%eax\n  mov    $0x1,%r12d\n  jmp    127f <func0+0x13f>\n  mov    $0x2,%eax\n  mov    $0x2,%r12d\n  jmp    127f <func0+0x13f>\n  movb   $0x0,0x2be1(%rip)        # 4060 <out.0>\n  jmp    142c <func0+0x2ec>\n  mov    $0x3,%eax\n  mov    $0x3,%r12d\n  jmp    127f <func0+0x13f>\n  mov    $0x4,%eax\n  mov    $0x4,%r12d\n  jmp    127f <func0+0x13f>\n  mov    $0x5,%eax\n  mov    $0x5,%r12d\n  jmp    127f <func0+0x13f>\n  mov    $0x3,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x2,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x5,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x4,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x9,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x6,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x7,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x8,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  lea    D0(%rip),%r15\n  pxor   %xmm0,%xmm0\n  push   %r14\n  lea    D1(%rip),%r14\n  movq   %r15,%xmm4\n  push   %r13\n  lea    D2(%rip),%r13\n  movq   %r14,%xmm6\n  push   %r12\n  movq   %r13,%xmm5\n  punpcklqdq %xmm6,%xmm4\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  movq   D3(%rip),%xmm3\n  movq   D4(%rip),%xmm2\n  movq   D5(%rip),%xmm1\n  movhps D6(%rip),%xmm5\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%eax\n  movhps D7(%rip),%xmm3\n  movaps %xmm0,(%rsp)\n  movhps D8(%rip),%xmm2\n  movhps D9(%rip),%xmm1\n  movaps %xmm0,0x10(%rsp)\n  movq   $0x0,0x20(%rsp)\n  movaps %xmm5,0x30(%rsp)\n  movaps %xmm4,0x40(%rsp)\n  movaps %xmm3,0x50(%rsp)\n  movaps %xmm2,0x60(%rsp)\n  movaps %xmm1,0x70(%rsp)\n  test   %al,%al\n  je     L0\n  mov    %rdi,%rbp\n  lea    0x82(%rsp),%rbx\n  jmp    L1\nL17:\n  mov    %al,0x82(%rsp)\n  movzbl 0x1(%rbp),%eax\n  test   $0xdf,%al\n  je     L2\n  mov    %al,0x83(%rsp)\n  movzbl 0x2(%rbp),%eax\n  test   $0xdf,%al\n  je     L3\n  mov    %al,0x84(%rsp)\n  movzbl 0x3(%rbp),%eax\n  test   $0xdf,%al\n  je     L4\n  mov    %al,0x85(%rsp)\n  movzbl 0x4(%rbp),%eax\n  test   $0xdf,%al\n  je     L5\n  mov    %al,0x86(%rsp)\n  movzbl 0x5(%rbp),%eax\n  test   $0xdf,%al\n  je     L6\n  mov    %al,0x87(%rsp)\n  mov    $0x6,%r12d\n  mov    $0x6,%eax\nL27:\n  add    $0x1,%r12\nL18:\n  mov    %r13,%rsi\n  mov    %rbx,%rdi\n  movb   $0x0,0x82(%rsp,%rax,1)\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L7\n  lea    D10(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L8\n  mov    %r15,%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L9\n  mov    %r14,%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L10\n  lea    D11(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L11\n  lea    D12(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L12\n  lea    D13(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L13\n  lea    D14(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L14\n  lea    D15(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L15\n  lea    D16(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L16\n  add    %r12,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     L0\nL19:\n  movzbl 0x0(%rbp),%eax\nL1:\n  test   $0xdf,%al\n  jne    L17\n  mov    $0x1,%r12d\n  xor    %eax,%eax\n  jmp    L18\nL8:\n  mov    $0x1,%eax\nL7:\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\nL29:\n  add    %r12,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  jne    L19\nL0:\n  lea    D17(%rip),%r12\n  xor    %ebx,%ebx\n  xor    %esi,%esi\n  mov    %rsp,%rbp\n  lea    -0x1(%r12),%rdi\n  xchg   %ax,%ax\nL24:\n  mov    0x0(%rbp,%rbx,4),%r10d\n  test   %r10d,%r10d\n  jle    L20\n  mov    0x30(%rsp,%rbx,8),%r11\n  xor    %r8d,%r8d\n  movzbl (%r11),%r9d\n  cs nopw 0x0(%rax,%rax,1)\nL23:\n  movslq %esi,%rcx\n  test   %r9b,%r9b\n  je     L21\n  lea    0x1(%rsi),%eax\n  movslq %esi,%rcx\n  mov    %r11,%rsi\n  mov    %r9d,%edx\n  cltq\n  sub    %rcx,%rsi\n  nopl   0x0(%rax)\nL22:\n  mov    %dl,(%rdi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    L22\nL21:\n  add    $0x1,%r8d\n  movb   $0x20,(%r12,%rcx,1)\n  lea    0x1(%rcx),%esi\n  cmp    %r8d,%r10d\n  jne    L23\nL20:\n  add    $0x1,%rbx\n  cmp    $0xa,%rbx\n  jne    L24\n  test   %esi,%esi\n  je     L25\n  lea    -0x1(%rsi),%eax\n  cltq\n  movb   $0x0,(%r12,%rax,1)\nL28:\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L26\n  add    $0x98,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL2:\n  mov    $0x1,%eax\n  mov    $0x1,%r12d\n  jmp    L27\nL3:\n  mov    $0x2,%eax\n  mov    $0x2,%r12d\n  jmp    L27\nL25:\n  movb   $0x0,D17(%rip)\n  jmp    L28\nL4:\n  mov    $0x3,%eax\n  mov    $0x3,%r12d\n  jmp    L27\nL5:\n  mov    $0x4,%eax\n  mov    $0x4,%r12d\n  jmp    L27\nL6:\n  mov    $0x5,%eax\n  mov    $0x5,%r12d\n  jmp    L27\nL10:\n  mov    $0x3,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL9:\n  mov    $0x2,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL12:\n  mov    $0x5,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL11:\n  mov    $0x4,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL16:\n  mov    $0x9,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL13:\n  mov    $0x6,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL14:\n  mov    $0x7,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL15:\n  mov    $0x8,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL26:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 7,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8201,
          "bias": [
            3772
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8205,
          "bias": [
            3763
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8192,
          "bias": [
            3736
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 15856,
          "bias": [
            11367
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 15872,
          "bias": [
            11375
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 15888,
          "bias": [
            11383
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 15848,
          "bias": [
            11336
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 15864,
          "bias": [
            11323
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 15880,
          "bias": [
            11328
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 15896,
          "bias": [
            11337
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 8197,
          "bias": [
            3424
          ]
        },
        "D11": {
          "label": "D11",
          "addr": 8211,
          "bias": [
            3377
          ]
        },
        "D12": {
          "label": "D12",
          "addr": 8216,
          "bias": [
            3359
          ]
        },
        "D13": {
          "label": "D13",
          "addr": 8221,
          "bias": [
            3341
          ]
        },
        "D14": {
          "label": "D14",
          "addr": 8225,
          "bias": [
            3322
          ]
        },
        "D15": {
          "label": "D15",
          "addr": 8231,
          "bias": [
            3305
          ]
        },
        "D16": {
          "label": "D16",
          "addr": 8237,
          "bias": [
            3288
          ]
        },
        "D17": {
          "label": "D17",
          "addr": 16480,
          "bias": [
            11454,
            11233
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5019
        },
        "L1": {
          "label": "L1",
          "addr": 4978
        },
        "L2": {
          "label": "L2",
          "addr": 5208
        },
        "L3": {
          "label": "L3",
          "addr": 5224
        },
        "L4": {
          "label": "L4",
          "addr": 5249
        },
        "L5": {
          "label": "L5",
          "addr": 5265
        },
        "L6": {
          "label": "L6",
          "addr": 5281
        },
        "L7": {
          "label": "L7",
          "addr": 5004
        },
        "L8": {
          "label": "L8",
          "addr": 4999
        },
        "L9": {
          "label": "L9",
          "addr": 5313
        },
        "L10": {
          "label": "L10",
          "addr": 5297
        },
        "L11": {
          "label": "L11",
          "addr": 5345
        },
        "L12": {
          "label": "L12",
          "addr": 5329
        },
        "L13": {
          "label": "L13",
          "addr": 5377
        },
        "L14": {
          "label": "L14",
          "addr": 5393
        },
        "L15": {
          "label": "L15",
          "addr": 5409
        },
        "L16": {
          "label": "L16",
          "addr": 5361
        },
        "L17": {
          "label": "L17",
          "addr": 4622
        },
        "L18": {
          "label": "L18",
          "addr": 4739
        },
        "L19": {
          "label": "L19",
          "addr": 4974
        },
        "L20": {
          "label": "L20",
          "addr": 5140
        },
        "L21": {
          "label": "L21",
          "addr": 5123
        },
        "L22": {
          "label": "L22",
          "addr": 5104
        },
        "L23": {
          "label": "L23",
          "addr": 5072
        },
        "L24": {
          "label": "L24",
          "addr": 5040
        },
        "L25": {
          "label": "L25",
          "addr": 5240
        },
        "L26": {
          "label": "L26",
          "addr": 5425
        },
        "L27": {
          "label": "L27",
          "addr": 4735
        },
        "L28": {
          "label": "L28",
          "addr": 5164
        },
        "L29": {
          "label": "L29",
          "addr": 5010
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "7a65726f006f6e650074776f00746872656500666f757200666976650073697800736576656e006569676874006e696e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"zero\""
          },
          "0x2021": {
            "type": "string",
            "value": "\"seven\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"one\""
          },
          "0x2027": {
            "type": "string",
            "value": "\"eight\""
          },
          "0x2009": {
            "type": "string",
            "value": "\"two\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"three\""
          },
          "0x202d": {
            "type": "string",
            "value": "\"nine\""
          },
          "0x2013": {
            "type": "string",
            "value": "\"four\""
          },
          "0x2018": {
            "type": "string",
            "value": "\"five\""
          },
          "0x201d": {
            "type": "string",
            "value": "\"six\""
          },
          "0x3df0": {
            "type": "byte[8]",
            "value": []
          },
          "0x3e00": {
            "type": "byte[8]",
            "value": []
          },
          "0x3e10": {
            "type": "byte[8]",
            "value": []
          },
          "0x3de8": {
            "type": "byte[8]",
            "value": []
          },
          "0x3df8": {
            "type": "byte[8]",
            "value": []
          },
          "0x3e08": {
            "type": "byte[8]",
            "value": []
          },
          "0x3e18": {
            "type": "byte[8]",
            "value": []
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s) {\n  static char result[100];\n  char *words[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n  int nums[10] = {0};\n  int i, j, k, l, m;\n  char tmp[10];\n  for (i = 0; s[i] != '\\0'; i++) {\n    for (j = 0; j < 10 && s[i] != ' ' && s[i] != '\\0'; j++) {\n      tmp[j] = s[i];\n      i++;\n    }\n    tmp[j] = '\\0';\n    for (k = 0; k < 10; k++) {\n      if (!strcmp(tmp, words[k])) {\n        nums[k]++;\n        break;\n      }\n    }\n  }\n  l = 0;\n  for (i = 0; i < 10; i++) {\n    for (j = 0; j < nums[i]; j++) {\n      for (m = 0; words[i][m] != '\\0'; m++) {\n        result[l++] = words[i][m];\n      }\n      result[l++] = ' ';\n    }\n  }\n  if (l == 0) {\n    result[l] = '\\0';\n  } else {\n    result[l - 1] = '\\0';\n  }\n  return result;\n}"
    },
    {
      "task_id": 17,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  movb   $0x0,0x27(%rsp)\n  mov    %ax,0x25(%rsp)\n  call   10b0 <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbp\n  movslq %edi,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rbp,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x10(%rsp)\n  call   10d0 <memcpy@plt>\n  mov    $0x20,%edx\n  lea    0x1(%rbp),%eax\n  mov    %dx,(%rbx,%rbp,1)\n  test   %eax,%eax\n  jle    1400 <func0+0x240>\n  mov    %ebp,%ebp\n  movl   $0x0,0xc(%rsp)\n  xor    %r15d,%r15d\n  lea    0x25(%rsp),%r14\n  lea    0x1(%rbx,%rbp,1),%r12\n  xor    %ebp,%ebp\n  jmp    1275 <func0+0xb5>\n  xchg   %ax,%ax\n  mov    %r14,%rdi\n  call   10b0 <strlen@plt>\n  cmp    $0x2,%rax\n  je     1268 <func0+0xa8>\n  mov    %r13b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\n  add    $0x1,%rbx\n  cmp    %r12,%rbx\n  je     1314 <func0+0x154>\n  movzbl (%rbx),%r13d\n  cmp    $0x20,%r13b\n  jne    1250 <func0+0x90>\n  cmpb   $0x6f,(%r14)\n  jne    12a6 <func0+0xe6>\n  cmpb   $0x0,0x1(%r14)\n  jne    12a6 <func0+0xe6>\n  cmp    0xc(%rsp),%r15d\n  je     1350 <func0+0x190>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x4,0x0(%rbp,%rax,4)\n  cmpb   $0x6f,(%r14)\n  jne    12d4 <func0+0x114>\n  cmpb   $0x7c,0x1(%r14)\n  jne    12d4 <func0+0x114>\n  cmpb   $0x0,0x2(%r14)\n  jne    12d4 <func0+0x114>\n  cmp    0xc(%rsp),%r15d\n  je     13a0 <func0+0x1e0>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x2,0x0(%rbp,%rax,4)\n  cmpb   $0x2e,(%r14)\n  jne    1302 <func0+0x142>\n  cmpb   $0x7c,0x1(%r14)\n  jne    1302 <func0+0x142>\n  cmpb   $0x0,0x2(%r14)\n  jne    1302 <func0+0x142>\n  cmp    0xc(%rsp),%r15d\n  je     1378 <func0+0x1b8>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x1,0x0(%rbp,%rax,4)\n  add    $0x1,%rbx\n  movb   $0x0,0x25(%rsp)\n  cmp    %r12,%rbx\n  jne    1275 <func0+0xb5>\n  mov    0x10(%rsp),%rdi\n  call   10a0 <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    140a <func0+0x24a>\n  add    $0x38,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13c8 <func0+0x208>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    1297 <func0+0xd7>\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13f0 <func0+0x230>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    12f3 <func0+0x133>\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13e0 <func0+0x220>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    12c5 <func0+0x105>\n  nopl   0x0(%rax)\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    1364 <func0+0x1a4>\n  nopw   0x0(%rax,%rax,1)\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    13b4 <func0+0x1f4>\n  nop\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    138c <func0+0x1cc>\n  nop\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  jmp    1314 <func0+0x154>\n  call   10c0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  movb   $0x0,0x27(%rsp)\n  mov    %ax,0x25(%rsp)\n  call   <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbp\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rbp,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x10(%rsp)\n  call   <memcpy@plt>\n  mov    $0x20,%edx\n  lea    0x1(%rbp),%eax\n  mov    %dx,(%rbx,%rbp,1)\n  test   %eax,%eax\n  jle    L0\n  mov    %ebp,%ebp\n  movl   $0x0,0xc(%rsp)\n  xor    %r15d,%r15d\n  lea    0x25(%rsp),%r14\n  lea    0x1(%rbx,%rbp,1),%r12\n  xor    %ebp,%ebp\n  jmp    L1\n  xchg   %ax,%ax\nL4:\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  cmp    $0x2,%rax\n  je     L2\n  mov    %r13b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\nL2:\n  add    $0x1,%rbx\n  cmp    %r12,%rbx\n  je     L3\nL1:\n  movzbl (%rbx),%r13d\n  cmp    $0x20,%r13b\n  jne    L4\n  cmpb   $0x6f,(%r14)\n  jne    L5\n  cmpb   $0x0,0x1(%r14)\n  jne    L5\n  cmp    0xc(%rsp),%r15d\n  je     L6\nL13:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x4,0x0(%rbp,%rax,4)\nL5:\n  cmpb   $0x6f,(%r14)\n  jne    L7\n  cmpb   $0x7c,0x1(%r14)\n  jne    L7\n  cmpb   $0x0,0x2(%r14)\n  jne    L7\n  cmp    0xc(%rsp),%r15d\n  je     L8\nL17:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x2,0x0(%rbp,%rax,4)\nL7:\n  cmpb   $0x2e,(%r14)\n  jne    L9\n  cmpb   $0x7c,0x1(%r14)\n  jne    L9\n  cmpb   $0x0,0x2(%r14)\n  jne    L9\n  cmp    0xc(%rsp),%r15d\n  je     L10\nL15:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x1,0x0(%rbp,%rax,4)\nL9:\n  add    $0x1,%rbx\n  movb   $0x0,0x25(%rsp)\n  cmp    %r12,%rbx\n  jne    L1\nL3:\n  mov    0x10(%rsp),%rdi\n  call   <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L11\n  add    $0x38,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL6:\n  test   %r15d,%r15d\n  jle    L12\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL18:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L13\n  nopl   0x0(%rax)\nL10:\n  test   %r15d,%r15d\n  jle    L14\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL20:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L15\n  nopl   0x0(%rax)\nL8:\n  test   %r15d,%r15d\n  jle    L16\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL19:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L17\n  nopl   0x0(%rax)\nL12:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L18\n  nopw   0x0(%rax,%rax,1)\nL16:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L19\n  nop\nL14:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L20\n  nop\nL0:\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  jmp    L3\nL11:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 5120
        },
        "L1": {
          "label": "L1",
          "addr": 4725
        },
        "L2": {
          "label": "L2",
          "addr": 4712
        },
        "L3": {
          "label": "L3",
          "addr": 4884
        },
        "L4": {
          "label": "L4",
          "addr": 4688
        },
        "L5": {
          "label": "L5",
          "addr": 4774
        },
        "L6": {
          "label": "L6",
          "addr": 4944
        },
        "L7": {
          "label": "L7",
          "addr": 4820
        },
        "L8": {
          "label": "L8",
          "addr": 5024
        },
        "L9": {
          "label": "L9",
          "addr": 4866
        },
        "L10": {
          "label": "L10",
          "addr": 4984
        },
        "L11": {
          "label": "L11",
          "addr": 5130
        },
        "L12": {
          "label": "L12",
          "addr": 5064
        },
        "L13": {
          "label": "L13",
          "addr": 4759
        },
        "L14": {
          "label": "L14",
          "addr": 5104
        },
        "L15": {
          "label": "L15",
          "addr": 4851
        },
        "L16": {
          "label": "L16",
          "addr": 5088
        },
        "L17": {
          "label": "L17",
          "addr": 4805
        },
        "L18": {
          "label": "L18",
          "addr": 4964
        },
        "L19": {
          "label": "L19",
          "addr": 5044
        },
        "L20": {
          "label": "L20",
          "addr": 5004
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int *func0(char *str, int *len) {\n  int i, j, k, l, m, n;\n  char *s, *s1, *s2, *s3, *s4, *s5, *s6, *s7, *s8, *s9, *s10, *s11, *s12, *s13, *s14, *s15, *s16, *s17, *s18, *s19, *s20, *s21, *s22, *s23, *s24, *s25, *s26, *s27, *s28, *s29, *s30, *s31, *s32, *s33, *s34, *s35, *s36, *s37, *s38, *s39, *s40, *s41, *s42, *s43, *s44, *s45, *s46, *s47, *s48, *s49, *s50, *s51, *s52, *s53, *s54, *s55, *s56, *s57, *s58, *s59, *s60, *s61, *s62, *s63, *s64, *s65, *s66, *s67, *s68, *s69, *s70, *s71, *s72, *s73, *s74, *s75, *s76, *s77, *s78, *s79, *s80, *s81, *s82, *s83, *s84, *s85, *s86, *s87, *s88, *s89, *s90, *s91, *s92, *s93, *s94, *s95, *s96, *s97, *s98, *s99, *s100, *s101, *s102, *s103, *s104, *s105, *s106, *s107, *s108, *s109, *s110, *s111, *s112, *s113, *s114, *s115, *s116, *s117, *s118, *s119, *s120, *s121, *s122, *s123, *s124, *s125, *s126, *s127, *s128, *s129, *s130, *s131, *s132, *s133, *s134, *s135, *s136, *s137, *s138, *s139, *s140, *s141, *s142, *s143, *s144, *s145, *s146, *s147, *s148, *s149, *s150, *s151, *s152, *s153, *s154, *s155, *s156, *s157, *s158, *s159, *s160, *s161, *s162, *s163, *s164, *s165, *s166, *s167, *s168, *s169, *s170, *s171, *s172, *s173, *s174, *s175, *s176, *s177, *s178, *s179, *s180, *s181, *s182, *s183"
    },
    {
      "task_id": 26,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  lea    0x0(,%r13,4),%rdi\n  mov    %r13,%r14\n  push   %rbp\n  push   %rbx\n  mov    %rdx,%rbx\n  sub    $0x8,%rsp\n  call   1090 <malloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%r12\n  call   1080 <calloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%rbp\n  call   1080 <calloc@plt>\n  mov    %rax,%r13\n  test   %r14d,%r14d\n  jle    12e5 <func0+0x185>\n  lea    -0x1(%r14),%eax\n  mov    %r15,%rsi\n  mov    %r15,%rdi\n  xor    %r8d,%r8d\n  lea    0x4(%r15,%rax,4),%r9\n  xor    %r10d,%r10d\n  lea    0x4(%r13),%r11\n  lea    0x4(%rbp),%r14\n  nopl   0x0(%rax)\n  mov    (%rdi),%edx\n  test   %r8d,%r8d\n  je     1260 <func0+0x100>\n  lea    -0x1(%r8),%ecx\n  mov    %r13,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    11f9 <func0+0x99>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     1260 <func0+0x100>\n  cmp    %edx,(%rax)\n  jne    11f0 <func0+0x90>\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  lea    -0x1(%r8),%eax\n  xor    %edi,%edi\n  lea    (%r11,%rax,4),%rcx\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  je     12a8 <func0+0x148>\n  mov    %r13,%rax\n  jmp    1229 <func0+0xc9>\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  je     12a8 <func0+0x148>\n  cmp    %edx,(%rax)\n  jne    1220 <func0+0xc0>\n  add    $0x4,%rsi\n  cmp    %r9,%rsi\n  jne    1210 <func0+0xb0>\n  mov    %edi,(%rbx)\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  mov    %r13,%rdi\n  call   1070 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  test   %r10d,%r10d\n  je     12c8 <func0+0x168>\n  lea    -0x1(%r10),%ecx\n  mov    %rbp,%rax\n  lea    (%r14,%rcx,4),%rcx\n  jmp    1281 <func0+0x121>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     12c8 <func0+0x168>\n  cmp    %edx,(%rax)\n  jne    1278 <func0+0x118>\n  movslq %r8d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r8d\n  mov    %edx,0x0(%r13,%rax,4)\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  jmp    1206 <func0+0xa6>\n  nopl   0x0(%rax,%rax,1)\n  movslq %edi,%rax\n  add    $0x4,%rsi\n  add    $0x1,%edi\n  mov    %edx,(%r12,%rax,4)\n  cmp    %r9,%rsi\n  jne    1210 <func0+0xb0>\n  jmp    1236 <func0+0xd6>\n  nopl   0x0(%rax)\n  movslq %r10d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r10d\n  mov    %edx,0x0(%rbp,%rax,4)\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  jmp    1206 <func0+0xa6>\n  xor    %edi,%edi\n  jmp    1236 <func0+0xd6>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  lea    0x0(,%r13,4),%rdi\n  mov    %r13,%r14\n  push   %rbp\n  push   %rbx\n  mov    %rdx,%rbx\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%r12\n  call   <calloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%rbp\n  call   <calloc@plt>\n  mov    %rax,%r13\n  test   %r14d,%r14d\n  jle    L0\n  lea    -0x1(%r14),%eax\n  mov    %r15,%rsi\n  mov    %r15,%rdi\n  xor    %r8d,%r8d\n  lea    0x4(%r15,%rax,4),%r9\n  xor    %r10d,%r10d\n  lea    0x4(%r13),%r11\n  lea    0x4(%rbp),%r14\n  nopl   0x0(%rax)\nL4:\n  mov    (%rdi),%edx\n  test   %r8d,%r8d\n  je     L1\n  lea    -0x1(%r8),%ecx\n  mov    %r13,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    L2\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    L4\nL12:\n  lea    -0x1(%r8),%eax\n  xor    %edi,%edi\n  lea    (%r11,%rax,4),%rcx\nL8:\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  je     L5\n  mov    %r13,%rax\n  jmp    L6\nL7:\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  je     L5\nL6:\n  cmp    %edx,(%rax)\n  jne    L7\n  add    $0x4,%rsi\n  cmp    %r9,%rsi\n  jne    L8\nL13:\n  mov    %edi,(%rbx)\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  test   %r10d,%r10d\n  je     L9\n  lea    -0x1(%r10),%ecx\n  mov    %rbp,%rax\n  lea    (%r14,%rcx,4),%rcx\n  jmp    L10\n  nopw   0x0(%rax,%rax,1)\nL11:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L9\nL10:\n  cmp    %edx,(%rax)\n  jne    L11\n  movslq %r8d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r8d\n  mov    %edx,0x0(%r13,%rax,4)\n  cmp    %r9,%rdi\n  jne    L4\n  jmp    L12\n  nopl   0x0(%rax,%rax,1)\nL5:\n  movslq %edi,%rax\n  add    $0x4,%rsi\n  add    $0x1,%edi\n  mov    %edx,(%r12,%rax,4)\n  cmp    %r9,%rsi\n  jne    L8\n  jmp    L13\n  nopl   0x0(%rax)\nL9:\n  movslq %r10d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r10d\n  mov    %edx,0x0(%rbp,%rax,4)\n  cmp    %r9,%rdi\n  jne    L4\n  jmp    L12\nL0:\n  xor    %edi,%edi\n  jmp    L13",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4837
        },
        "L1": {
          "label": "L1",
          "addr": 4704
        },
        "L2": {
          "label": "L2",
          "addr": 4601
        },
        "L3": {
          "label": "L3",
          "addr": 4592
        },
        "L4": {
          "label": "L4",
          "addr": 4568
        },
        "L5": {
          "label": "L5",
          "addr": 4776
        },
        "L6": {
          "label": "L6",
          "addr": 4649
        },
        "L7": {
          "label": "L7",
          "addr": 4640
        },
        "L8": {
          "label": "L8",
          "addr": 4624
        },
        "L9": {
          "label": "L9",
          "addr": 4808
        },
        "L10": {
          "label": "L10",
          "addr": 4737
        },
        "L11": {
          "label": "L11",
          "addr": 4728
        },
        "L12": {
          "label": "L12",
          "addr": 4614
        },
        "L13": {
          "label": "L13",
          "addr": 4662
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int *arr, int n, int *returnSize) {\n  int *returnArr = (int *)malloc(n * sizeof(int));\n  int *nums = (int *)calloc(n, sizeof(int));\n  int *numsCount = (int *)calloc(n, sizeof(int));\n  int numsLen = 0, numsCountLen = 0;\n  for (int i = 0; i < n; i++) {\n    bool isDup = false;\n    for (int j = 0; j < numsCountLen; j++) {\n      if (numsCount[j] == arr[i]) {\n        isDup = true;\n        break;\n      }\n    }\n    if (!isDup) {\n      nums[numsLen++] = arr[i];\n    } else {\n      bool isDup = false;\n      for (int j = 0; j < numsLen; j++) {\n        if (nums[j] == arr[i]) {\n          isDup = true;\n          break;\n        }\n      }\n      if (!isDup) {\n        numsCount[numsCountLen++] = arr[i];\n      }\n    }\n  }\n  *returnSize = numsLen;\n  int *returnArr2 = (int *)malloc(numsLen * sizeof(int));\n  int returnArr2Len = 0;\n  for (int i = 0; i < numsLen; i++) {\n    bool isDup = false;\n    for (int j = 0; j < numsCountLen; j++) {\n      if (numsCount[j] == nums[i]) {\n        isDup = true;\n        break;\n      }\n    }\n    if (!isDup) {\n      returnArr2[returnArr2Len++] = nums[i];\n    }\n  }\n  *returnSize = returnArr2Len;\n  free(nums);\n  free(numsCount);\n  return returnArr;\n}"
    },
    {
      "task_id": 26,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  lea    0x0(,%r13,4),%rdi\n  mov    %r13,%r14\n  push   %rbp\n  push   %rbx\n  mov    %rdx,%rbx\n  sub    $0x8,%rsp\n  call   1090 <malloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%r12\n  call   1080 <calloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%rbp\n  call   1080 <calloc@plt>\n  mov    %rax,%r13\n  test   %r14d,%r14d\n  jle    12e5 <func0+0x185>\n  lea    -0x1(%r14),%eax\n  mov    %r15,%rsi\n  mov    %r15,%rdi\n  xor    %r8d,%r8d\n  lea    0x4(%r15,%rax,4),%r9\n  xor    %r10d,%r10d\n  lea    0x4(%r13),%r11\n  lea    0x4(%rbp),%r14\n  nopl   0x0(%rax)\n  mov    (%rdi),%edx\n  test   %r8d,%r8d\n  je     1260 <func0+0x100>\n  lea    -0x1(%r8),%ecx\n  mov    %r13,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    11f9 <func0+0x99>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     1260 <func0+0x100>\n  cmp    %edx,(%rax)\n  jne    11f0 <func0+0x90>\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  lea    -0x1(%r8),%eax\n  xor    %edi,%edi\n  lea    (%r11,%rax,4),%rcx\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  je     12a8 <func0+0x148>\n  mov    %r13,%rax\n  jmp    1229 <func0+0xc9>\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  je     12a8 <func0+0x148>\n  cmp    %edx,(%rax)\n  jne    1220 <func0+0xc0>\n  add    $0x4,%rsi\n  cmp    %r9,%rsi\n  jne    1210 <func0+0xb0>\n  mov    %edi,(%rbx)\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  mov    %r13,%rdi\n  call   1070 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  test   %r10d,%r10d\n  je     12c8 <func0+0x168>\n  lea    -0x1(%r10),%ecx\n  mov    %rbp,%rax\n  lea    (%r14,%rcx,4),%rcx\n  jmp    1281 <func0+0x121>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     12c8 <func0+0x168>\n  cmp    %edx,(%rax)\n  jne    1278 <func0+0x118>\n  movslq %r8d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r8d\n  mov    %edx,0x0(%r13,%rax,4)\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  jmp    1206 <func0+0xa6>\n  nopl   0x0(%rax,%rax,1)\n  movslq %edi,%rax\n  add    $0x4,%rsi\n  add    $0x1,%edi\n  mov    %edx,(%r12,%rax,4)\n  cmp    %r9,%rsi\n  jne    1210 <func0+0xb0>\n  jmp    1236 <func0+0xd6>\n  nopl   0x0(%rax)\n  movslq %r10d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r10d\n  mov    %edx,0x0(%rbp,%rax,4)\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  jmp    1206 <func0+0xa6>\n  xor    %edi,%edi\n  jmp    1236 <func0+0xd6>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  lea    0x0(,%r13,4),%rdi\n  mov    %r13,%r14\n  push   %rbp\n  push   %rbx\n  mov    %rdx,%rbx\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%r12\n  call   <calloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%rbp\n  call   <calloc@plt>\n  mov    %rax,%r13\n  test   %r14d,%r14d\n  jle    L0\n  lea    -0x1(%r14),%eax\n  mov    %r15,%rsi\n  mov    %r15,%rdi\n  xor    %r8d,%r8d\n  lea    0x4(%r15,%rax,4),%r9\n  xor    %r10d,%r10d\n  lea    0x4(%r13),%r11\n  lea    0x4(%rbp),%r14\n  nopl   0x0(%rax)\nL4:\n  mov    (%rdi),%edx\n  test   %r8d,%r8d\n  je     L1\n  lea    -0x1(%r8),%ecx\n  mov    %r13,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    L2\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    L4\nL12:\n  lea    -0x1(%r8),%eax\n  xor    %edi,%edi\n  lea    (%r11,%rax,4),%rcx\nL8:\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  je     L5\n  mov    %r13,%rax\n  jmp    L6\nL7:\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  je     L5\nL6:\n  cmp    %edx,(%rax)\n  jne    L7\n  add    $0x4,%rsi\n  cmp    %r9,%rsi\n  jne    L8\nL13:\n  mov    %edi,(%rbx)\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  test   %r10d,%r10d\n  je     L9\n  lea    -0x1(%r10),%ecx\n  mov    %rbp,%rax\n  lea    (%r14,%rcx,4),%rcx\n  jmp    L10\n  nopw   0x0(%rax,%rax,1)\nL11:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L9\nL10:\n  cmp    %edx,(%rax)\n  jne    L11\n  movslq %r8d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r8d\n  mov    %edx,0x0(%r13,%rax,4)\n  cmp    %r9,%rdi\n  jne    L4\n  jmp    L12\n  nopl   0x0(%rax,%rax,1)\nL5:\n  movslq %edi,%rax\n  add    $0x4,%rsi\n  add    $0x1,%edi\n  mov    %edx,(%r12,%rax,4)\n  cmp    %r9,%rsi\n  jne    L8\n  jmp    L13\n  nopl   0x0(%rax)\nL9:\n  movslq %r10d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r10d\n  mov    %edx,0x0(%rbp,%rax,4)\n  cmp    %r9,%rdi\n  jne    L4\n  jmp    L12\nL0:\n  xor    %edi,%edi\n  jmp    L13",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4837
        },
        "L1": {
          "label": "L1",
          "addr": 4704
        },
        "L2": {
          "label": "L2",
          "addr": 4601
        },
        "L3": {
          "label": "L3",
          "addr": 4592
        },
        "L4": {
          "label": "L4",
          "addr": 4568
        },
        "L5": {
          "label": "L5",
          "addr": 4776
        },
        "L6": {
          "label": "L6",
          "addr": 4649
        },
        "L7": {
          "label": "L7",
          "addr": 4640
        },
        "L8": {
          "label": "L8",
          "addr": 4624
        },
        "L9": {
          "label": "L9",
          "addr": 4808
        },
        "L10": {
          "label": "L10",
          "addr": 4737
        },
        "L11": {
          "label": "L11",
          "addr": 4728
        },
        "L12": {
          "label": "L12",
          "addr": 4614
        },
        "L13": {
          "label": "L13",
          "addr": 4662
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int *arr, int n, int *returnSize) {\n  int *returnArr = (int *)malloc(n * sizeof(int));\n  int *nums = (int *)calloc(n, sizeof(int));\n  int *numsCount = (int *)calloc(n, sizeof(int));\n  int numsLen = 0, numsCountLen = 0;\n  for (int i = 0; i < n; i++) {\n    bool isDup = false;\n    for (int j = 0; j < numsCountLen; j++) {\n      if (numsCount[j] == arr[i]) {\n        isDup = true;\n        break;\n      }\n    }\n    if (!isDup) {\n      nums[numsLen++] = arr[i];\n    } else {\n      bool isDup = false;\n      for (int j = 0; j < numsLen; j++) {\n        if (nums[j] == arr[i]) {\n          isDup = true;\n          break;\n        }\n      }\n      if (!isDup) {\n        numsCount[numsCountLen++] = arr[i];\n      }\n    }\n  }\n  *returnSize = numsLen;\n  int *returnArr2 = (int *)malloc(numsLen * sizeof(int));\n  int returnArr2Len = 0;\n  for (int i = 0; i < numsLen; i++) {\n    bool isDup = false;\n    for (int j = 0; j < numsCountLen; j++) {\n      if (numsCount[j] == nums[i]) {\n        isDup = true;\n        break;\n      }\n    }\n    if (!isDup) {\n      returnArr2[returnArr2Len++] = nums[i];\n    }\n  }\n  *returnSize = returnArr2Len;\n  free(nums);\n  free(numsCount);\n  return returnArr;\n}"
    },
    {
      "task_id": 35,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movss  0xef0(%rip),%xmm0        # 2000 <_fini+0xe94>\n  movss  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    115d <func0+0x64>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss -0x8(%rbp),%xmm0\n  jbe    1159 <func0+0x60>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111e <func0+0x25>\n  movss  -0x8(%rbp),%xmm0\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movss  D0(%rip),%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss -0x8(%rbp),%xmm0\n  jbe    L1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  movss  -0x8(%rbp),%xmm0\n  pop    %rbp\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3824
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4445
        },
        "L1": {
          "label": "L1",
          "addr": 4441
        },
        "L2": {
          "label": "L2",
          "addr": 4382
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00401cc6",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[4]",
            "value": [
              0,
              64,
              28,
              198
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float *a, int n) {\n  float max = -10000000;\n  for (int i = 0; i < n; i++) {\n    if (a[i] > max)\n      max = a[i];\n  }\n  return max;\n}"
    },
    {
      "task_id": 33,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  mov    %rdx,%r12\n  movslq %esi,%rdi\n  imul   $0x55555556,%rdi,%rdi\n  shr    $0x20,%rdi\n  mov    %esi,%eax\n  sar    $0x1f,%eax\n  sub    %eax,%edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    1254 <func0+0x11b>\n  mov    $0x0,%edx\n  mov    $0x0,%eax\n  mov    %eax,%r10d\n  mov    0x0(%rbp,%rdx,4),%ecx\n  mov    %ecx,(%rdi,%rax,4)\n  add    $0x1,%rax\n  add    $0x3,%rdx\n  cmp    %edx,%ebx\n  jg     1188 <func0+0x4f>\n  test   %r10d,%r10d\n  jle    1264 <func0+0x12b>\n  lea    -0x1(%r10),%r13d\n  mov    %r10d,%r9d\n  mov    $0x0,%esi\n  jmp    11c2 <func0+0x89>\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     1264 <func0+0x12b>\n  mov    %esi,%edx\n  mov    %esi,%r11d\n  cmp    %r10d,%esi\n  jge    11b5 <func0+0x7c>\n  lea    0x1(%rsi),%rax\n  mov    %r13d,%ecx\n  sub    %esi,%ecx\n  lea    0x2(%rsi,%rcx,1),%r8\n  movslq %edx,%rcx\n  mov    (%rdi,%rcx,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  jne    11da <func0+0xa1>\n  cmp    %r11d,%edx\n  je     11b5 <func0+0x7c>\n  mov    (%rdi,%rsi,4),%ecx\n  movslq %edx,%rdx\n  lea    (%rdi,%rdx,4),%rax\n  mov    (%rax),%edx\n  mov    %edx,(%rdi,%rsi,4)\n  mov    %ecx,(%rax)\n  jmp    11b5 <func0+0x7c>\n  mov    0x0(%rbp,%rdx,4),%eax\n  mov    %eax,(%r12,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rbx\n  je     1254 <func0+0x11b>\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,2),%eax\n  cmp    %edx,%eax\n  jne    1207 <func0+0xce>\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cltq\n  mov    (%rdi,%rax,4),%eax\n  mov    %eax,(%r12,%rdx,4)\n  jmp    120f <func0+0xd6>\n  call   1060 <free@plt>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  mov    %ebx,%ebx\n  mov    $0x0,%edx\n  jmp    1218 <func0+0xdf>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  mov    %rdx,%r12\n  movslq %esi,%rdi\n  imul   $0x55555556,%rdi,%rdi\n  shr    $0x20,%rdi\n  mov    %esi,%eax\n  sar    $0x1f,%eax\n  sub    %eax,%edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    L0\n  mov    $0x0,%edx\n  mov    $0x0,%eax\nL1:\n  mov    %eax,%r10d\n  mov    0x0(%rbp,%rdx,4),%ecx\n  mov    %ecx,(%rdi,%rax,4)\n  add    $0x1,%rax\n  add    $0x3,%rdx\n  cmp    %edx,%ebx\n  jg     L1\n  test   %r10d,%r10d\n  jle    L2\n  lea    -0x1(%r10),%r13d\n  mov    %r10d,%r9d\n  mov    $0x0,%esi\n  jmp    L3\nL4:\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     L2\nL3:\n  mov    %esi,%edx\n  mov    %esi,%r11d\n  cmp    %r10d,%esi\n  jge    L4\n  lea    0x1(%rsi),%rax\n  mov    %r13d,%ecx\n  sub    %esi,%ecx\n  lea    0x2(%rsi,%rcx,1),%r8\nL5:\n  movslq %edx,%rcx\n  mov    (%rdi,%rcx,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  jne    L5\n  cmp    %r11d,%edx\n  je     L4\n  mov    (%rdi,%rsi,4),%ecx\n  movslq %edx,%rdx\n  lea    (%rdi,%rdx,4),%rax\n  mov    (%rax),%edx\n  mov    %edx,(%rdi,%rsi,4)\n  mov    %ecx,(%rax)\n  jmp    L4\nL6:\n  mov    0x0(%rbp,%rdx,4),%eax\n  mov    %eax,(%r12,%rdx,4)\nL7:\n  add    $0x1,%rdx\n  cmp    %rdx,%rbx\n  je     L0\nL8:\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,2),%eax\n  cmp    %edx,%eax\n  jne    L6\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cltq\n  mov    (%rdi,%rax,4),%eax\n  mov    %eax,(%r12,%rdx,4)\n  jmp    L7\nL0:\n  call   <free@plt>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL2:\n  mov    %ebx,%ebx\n  mov    $0x0,%edx\n  jmp    L8",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4692
        },
        "L1": {
          "label": "L1",
          "addr": 4488
        },
        "L2": {
          "label": "L2",
          "addr": 4708
        },
        "L3": {
          "label": "L3",
          "addr": 4546
        },
        "L4": {
          "label": "L4",
          "addr": 4533
        },
        "L5": {
          "label": "L5",
          "addr": 4570
        },
        "L6": {
          "label": "L6",
          "addr": 4615
        },
        "L7": {
          "label": "L7",
          "addr": 4623
        },
        "L8": {
          "label": "L8",
          "addr": 4632
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *p, int n, int *q) {\n  int *tmp = (int *)malloc((n / 3 + 1) * sizeof(int));\n  int i, j, k, m, x;\n  for (i = 0; i < n; i += 3)\n    tmp[i / 3] = p[i];\n  for (i = 0; i < n / 3; i++)\n    for (j = i; j < n / 3; j++)\n      if (tmp[j] < tmp[i])\n        i = j;\n  for (i = 0; i < n; i++)\n    if (i % 3 == 0)\n      q[i] = tmp[i / 3];\n    else\n      q[i] = p[i];\n  free(tmp);\n}"
    },
    {
      "task_id": 33,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  movslq %esi,%r12\n  push   %rbp\n  mov    %r12d,%eax\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  imul   $0x55555556,%r12,%rdi\n  sar    $0x1f,%eax\n  shr    $0x20,%rdi\n  sub    %eax,%edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    1250 <func0+0x110>\n  mov    %r12,%r13\n  xor    %edx,%edx\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx,%rdx,4),%ecx\n  mov    %rax,%r9\n  add    $0x3,%rdx\n  mov    %eax,%r11d\n  mov    %ecx,(%rdi,%rax,4)\n  lea    0x1(%r9),%rax\n  cmp    %edx,%r13d\n  jg     1190 <func0+0x50>\n  test   %r11d,%r11d\n  je     120b <func0+0xcb>\n  lea    -0x1(%r11),%r13d\n  xor    %esi,%esi\n  nopl   0x0(%rax)\n  mov    %esi,%edx\n  mov    %esi,%r14d\n  lea    0x1(%rsi),%r10\n  cmp    %r11d,%esi\n  jge    1203 <func0+0xc3>\n  mov    %r13d,%ecx\n  mov    %r10,%rax\n  sub    %esi,%ecx\n  lea    0x2(%rsi,%rcx,1),%r8\n  nopl   0x0(%rax,%rax,1)\n  movslq %edx,%rcx\n  mov    (%rdi,%rcx,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  jne    11d8 <func0+0x98>\n  cmp    %edx,%r14d\n  je     1203 <func0+0xc3>\n  movslq %edx,%rdx\n  mov    (%rdi,%rsi,4),%ecx\n  lea    (%rdi,%rdx,4),%rax\n  mov    (%rax),%edx\n  mov    %edx,(%rdi,%rsi,4)\n  mov    %ecx,(%rax)\n  mov    %r10,%rsi\n  cmp    %r9,%r10\n  jne    11b8 <func0+0x78>\n  xor    %eax,%eax\n  mov    $0xaaaaaaab,%ecx\n  jmp    1232 <func0+0xf2>\n  nopl   0x0(%rax)\n  mov    %eax,%edx\n  imul   %rcx,%rdx\n  shr    $0x21,%rdx\n  mov    (%rdi,%rdx,4),%edx\n  mov    %edx,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r12\n  je     1250 <func0+0x110>\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  jbe    1218 <func0+0xd8>\n  mov    (%rbx,%rax,4),%edx\n  mov    %edx,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r12\n  jne    1232 <func0+0xf2>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1060 <free@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  movslq %esi,%r12\n  push   %rbp\n  mov    %r12d,%eax\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  imul   $0x55555556,%r12,%rdi\n  sar    $0x1f,%eax\n  shr    $0x20,%rdi\n  sub    %eax,%edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    L0\n  mov    %r12,%r13\n  xor    %edx,%edx\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    (%rbx,%rdx,4),%ecx\n  mov    %rax,%r9\n  add    $0x3,%rdx\n  mov    %eax,%r11d\n  mov    %ecx,(%rdi,%rax,4)\n  lea    0x1(%r9),%rax\n  cmp    %edx,%r13d\n  jg     L1\n  test   %r11d,%r11d\n  je     L2\n  lea    -0x1(%r11),%r13d\n  xor    %esi,%esi\n  nopl   0x0(%rax)\nL5:\n  mov    %esi,%edx\n  mov    %esi,%r14d\n  lea    0x1(%rsi),%r10\n  cmp    %r11d,%esi\n  jge    L3\n  mov    %r13d,%ecx\n  mov    %r10,%rax\n  sub    %esi,%ecx\n  lea    0x2(%rsi,%rcx,1),%r8\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movslq %edx,%rcx\n  mov    (%rdi,%rcx,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  jne    L4\n  cmp    %edx,%r14d\n  je     L3\n  movslq %edx,%rdx\n  mov    (%rdi,%rsi,4),%ecx\n  lea    (%rdi,%rdx,4),%rax\n  mov    (%rax),%edx\n  mov    %edx,(%rdi,%rsi,4)\n  mov    %ecx,(%rax)\nL3:\n  mov    %r10,%rsi\n  cmp    %r9,%r10\n  jne    L5\nL2:\n  xor    %eax,%eax\n  mov    $0xaaaaaaab,%ecx\n  jmp    L6\n  nopl   0x0(%rax)\nL7:\n  mov    %eax,%edx\n  imul   %rcx,%rdx\n  shr    $0x21,%rdx\n  mov    (%rdi,%rdx,4),%edx\n  mov    %edx,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r12\n  je     L0\nL6:\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  jbe    L7\n  mov    (%rbx,%rax,4),%edx\n  mov    %edx,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r12\n  jne    L6\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1060 <free@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4688
        },
        "L1": {
          "label": "L1",
          "addr": 4496
        },
        "L2": {
          "label": "L2",
          "addr": 4619
        },
        "L3": {
          "label": "L3",
          "addr": 4611
        },
        "L4": {
          "label": "L4",
          "addr": 4568
        },
        "L5": {
          "label": "L5",
          "addr": 4536
        },
        "L6": {
          "label": "L6",
          "addr": 4658
        },
        "L7": {
          "label": "L7",
          "addr": 4632
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int *y) {\n  int i, j, k, *z;\n  z = (int *)malloc(((n / 3) + 1) * sizeof(int));\n  for (i = 0; i < n; i += 3)\n    z[i / 3] = x[i];\n  for (i = 0; i < (n / 3); i++)\n    for (j = i + 1; j < (n / 3); j++)\n      if (z[j] < z[i])\n        k = j;\n  for (i = 0; i < n; i++)\n    if (i % 3 == 0)\n      y[i] = z[i / 3];\n    else\n      y[i] = x[i];\n  free(z);\n}"
    },
    {
      "task_id": 34,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r10\n  test   %ebp,%ebp\n  jle    11b8 <func0+0x9f>\n  mov    %r12,%rsi\n  lea    -0x1(%rbp),%eax\n  lea    0x4(%r12,%rax,4),%rdi\n  mov    $0x0,%r9d\n  lea    0x4(%r10),%r8\n  jmp    11e3 <func0+0xca>\n  cmp    $0x1,%r9d\n  jle    11be <func0+0xa5>\n  lea    0x4(%r10),%rsi\n  lea    -0x2(%r9),%r11d\n  add    $0x2,%r11\n  mov    $0x1,%r8d\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbp\n  jmp    119e <func0+0x85>\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     1191 <func0+0x78>\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    1178 <func0+0x5f>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  jmp    1178 <func0+0x5f>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r11,%r8\n  je     11be <func0+0xa5>\n  cmp    %r8d,%r9d\n  jle    1191 <func0+0x78>\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%rbp,%rax,4),%rdi\n  mov    %rsi,%rax\n  jmp    1181 <func0+0x68>\n  mov    $0x0,%r9d\n  mov    %r9d,(%rbx)\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  movslq %r9d,%rax\n  mov    (%rsi),%edx\n  mov    %edx,(%r10,%rax,4)\n  lea    0x1(%r9),%r9d\n  add    $0x4,%rsi\n  cmp    %rdi,%rsi\n  je     1156 <func0+0x3d>\n  test   %r9d,%r9d\n  jle    11c9 <func0+0xb0>\n  mov    (%rsi),%edx\n  mov    %r10,%rax\n  lea    -0x1(%r9),%ecx\n  lea    (%r8,%rcx,4),%rcx\n  cmp    (%rax),%edx\n  je     11d6 <func0+0xbd>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    11f5 <func0+0xdc>\n  jmp    11c9 <func0+0xb0>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  test   %ebp,%ebp\n  jle    L0\n  mov    %r12,%rsi\n  lea    -0x1(%rbp),%eax\n  lea    0x4(%r12,%rax,4),%rdi\n  mov    $0x0,%r9d\n  lea    0x4(%r10),%r8\n  jmp    L1\nL7:\n  cmp    $0x1,%r9d\n  jle    L2\n  lea    0x4(%r10),%rsi\n  lea    -0x2(%r9),%r11d\n  add    $0x2,%r11\n  mov    $0x1,%r8d\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbp\n  jmp    L3\nL5:\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     L4\nL6:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L5\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  jmp    L5\nL4:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r11,%r8\n  je     L2\nL3:\n  cmp    %r8d,%r9d\n  jle    L4\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%rbp,%rax,4),%rdi\n  mov    %rsi,%rax\n  jmp    L6\nL0:\n  mov    $0x0,%r9d\nL2:\n  mov    %r9d,(%rbx)\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL8:\n  movslq %r9d,%rax\n  mov    (%rsi),%edx\n  mov    %edx,(%r10,%rax,4)\n  lea    0x1(%r9),%r9d\nL9:\n  add    $0x4,%rsi\n  cmp    %rdi,%rsi\n  je     L7\nL1:\n  test   %r9d,%r9d\n  jle    L8\n  mov    (%rsi),%edx\n  mov    %r10,%rax\n  lea    -0x1(%r9),%ecx\n  lea    (%r8,%rcx,4),%rcx\nL10:\n  cmp    (%rax),%edx\n  je     L9\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L10\n  jmp    L8",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4536
        },
        "L1": {
          "label": "L1",
          "addr": 4579
        },
        "L2": {
          "label": "L2",
          "addr": 4542
        },
        "L3": {
          "label": "L3",
          "addr": 4510
        },
        "L4": {
          "label": "L4",
          "addr": 4497
        },
        "L5": {
          "label": "L5",
          "addr": 4472
        },
        "L6": {
          "label": "L6",
          "addr": 4481
        },
        "L7": {
          "label": "L7",
          "addr": 4438
        },
        "L8": {
          "label": "L8",
          "addr": 4553
        },
        "L9": {
          "label": "L9",
          "addr": 4566
        },
        "L10": {
          "label": "L10",
          "addr": 4597
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int *m) {\n  int i, j, k, *y;\n  y = (int *)malloc(n * sizeof(int));\n  k = 0;\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < k; j++)\n      if (x[i] == y[j])\n        break;\n    if (j == k)\n      y[k++] = x[i];\n  }\n  for (i = 0; i < k; i++)\n    for (j = i + 1; j < k; j++)\n      if (y[i] > y[j]) {\n        int tmp = y[i];\n        y[i] = y[j];\n        y[j] = tmp;\n      }\n  *m = k;\n  return y;\n}"
    },
    {
      "task_id": 35,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1129 <func0+0x30>\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\n  movss  0xeec(%rip),%xmm0        # 2000 <_fini+0xecc>\n  movss  (%rax),%xmm1\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    1114 <func0+0x1b>\n  ret\n  movss  0xecf(%rip),%xmm0        # 2000 <_fini+0xecc>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\n  movss  D0(%rip),%xmm0\nL1:\n  movss  (%rax),%xmm1\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    L1\n  ret\nL0:\n  movss  D0(%rip),%xmm0\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3820,
            3791
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4393
        },
        "L1": {
          "label": "L1",
          "addr": 4372
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00401cc6",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[4]",
            "value": [
              0,
              64,
              28,
              198
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " float func0(float *x, int n) {\n  int i;\n  float y = 1.0e37;\n  for (i = 0; i < n; i++)\n    if (x[i] < y)\n      y = x[i];\n  return y;\n}"
    },
    {
      "task_id": 35,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1138 <func0+0x38>\n  lea    -0x1(%rsi),%eax\n  movss  0xeed(%rip),%xmm0        # 2000 <_fini+0xebc>\n  lea    0x4(%rdi,%rax,4),%rax\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  cmp    %rax,%rdi\n  jne    1120 <func0+0x20>\n  ret\n  nopl   (%rax)\n  movss  0xec0(%rip),%xmm0        # 2000 <_fini+0xebc>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movss  D0(%rip),%xmm0\n  lea    0x4(%rdi,%rax,4),%rax\n  nopl   0x0(%rax,%rax,1)\nL1:\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  cmp    %rax,%rdi\n  jne    L1\n  ret\n  nopl   (%rax)\nL0:\n  movss  D0(%rip),%xmm0\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3821,
            3776
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00401cc6",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[4]",
            "value": [
              0,
              64,
              28,
              198
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " float func0(float *x, int n) {\n  int i;\n  float y = 1.0e+10;\n  for (i = 0; i < n; i++)\n    if (x[i] < y)\n      y = x[i];\n  return y;\n}"
    },
    {
      "task_id": 35,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1138 <func0+0x38>\n  lea    -0x1(%rsi),%eax\n  movss  0xeed(%rip),%xmm0        # 2000 <_fini+0xebc>\n  lea    0x4(%rdi,%rax,4),%rax\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  cmp    %rax,%rdi\n  jne    1120 <func0+0x20>\n  ret\n  nopl   (%rax)\n  movss  0xec0(%rip),%xmm0        # 2000 <_fini+0xebc>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movss  D0(%rip),%xmm0\n  lea    0x4(%rdi,%rax,4),%rax\n  nopl   0x0(%rax,%rax,1)\nL1:\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  cmp    %rax,%rdi\n  jne    L1\n  ret\n  nopl   (%rax)\nL0:\n  movss  D0(%rip),%xmm0\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3821,
            3776
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00401cc6",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[4]",
            "value": [
              0,
              64,
              28,
              198
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " float func0(float *x, int n) {\n  int i;\n  float y = 1.0e+10;\n  for (i = 0; i < n; i++)\n    if (x[i] < y)\n      y = x[i];\n  return y;\n}"
    },
    {
      "task_id": 34,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r10\n  test   %r12d,%r12d\n  jle    122d <func0+0x10d>\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rdi\n  lea    0x4(%r10),%r8\n  xor    %r9d,%r9d\n  lea    0x4(%rbx,%rax,4),%rsi\n  nopl   (%rax)\n  mov    (%rdi),%edx\n  test   %r9d,%r9d\n  je     1210 <func0+0xf0>\n  lea    -0x1(%r9),%ecx\n  mov    %r10,%rax\n  lea    (%r8,%rcx,4),%rcx\n  jmp    118d <func0+0x6d>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     1210 <func0+0xf0>\n  cmp    %edx,(%rax)\n  jne    1180 <func0+0x60>\n  add    $0x4,%rdi\n  cmp    %rsi,%rdi\n  jne    1160 <func0+0x40>\n  cmp    $0x1,%r9d\n  je     1204 <func0+0xe4>\n  lea    -0x2(%r9),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r8d\n  add    $0x2,%r11\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbx\n  nopw   0x0(%rax,%rax,1)\n  cmp    %r8d,%r9d\n  jle    11f7 <func0+0xd7>\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rbx,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopw   0x0(%rax,%rax,1)\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11ee <func0+0xce>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    11e0 <func0+0xc0>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r11,%r8\n  jne    11c0 <func0+0xa0>\n  pop    %rbx\n  mov    %r9d,0x0(%rbp)\n  mov    %r10,%rax\n  pop    %rbp\n  pop    %r12\n  ret\n  movslq %r9d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r9d\n  mov    %edx,(%r10,%rax,4)\n  cmp    %rsi,%rdi\n  jne    1160 <func0+0x40>\n  jmp    119a <func0+0x7a>\n  xor    %r9d,%r9d\n  pop    %rbx\n  mov    %r10,%rax\n  mov    %r9d,0x0(%rbp)\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rdi\n  lea    0x4(%r10),%r8\n  xor    %r9d,%r9d\n  lea    0x4(%rbx,%rax,4),%rsi\n  nopl   (%rax)\nL4:\n  mov    (%rdi),%edx\n  test   %r9d,%r9d\n  je     L1\n  lea    -0x1(%r9),%ecx\n  mov    %r10,%rax\n  lea    (%r8,%rcx,4),%rcx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\n  add    $0x4,%rdi\n  cmp    %rsi,%rdi\n  jne    L4\nL10:\n  cmp    $0x1,%r9d\n  je     L5\n  lea    -0x2(%r9),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r8d\n  add    $0x2,%r11\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbx\n  nopw   0x0(%rax,%rax,1)\nL9:\n  cmp    %r8d,%r9d\n  jle    L6\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rbx,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L7\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\nL7:\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    L8\nL6:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r11,%r8\n  jne    L9\nL5:\n  pop    %rbx\n  mov    %r9d,0x0(%rbp)\n  mov    %r10,%rax\n  pop    %rbp\n  pop    %r12\n  ret\nL1:\n  movslq %r9d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r9d\n  mov    %edx,(%r10,%rax,4)\n  cmp    %rsi,%rdi\n  jne    L4\n  jmp    L10\nL0:\n  xor    %r9d,%r9d\n  pop    %rbx\n  mov    %r10,%rax\n  mov    %r9d,0x0(%rbp)\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4653
        },
        "L1": {
          "label": "L1",
          "addr": 4624
        },
        "L2": {
          "label": "L2",
          "addr": 4493
        },
        "L3": {
          "label": "L3",
          "addr": 4480
        },
        "L4": {
          "label": "L4",
          "addr": 4448
        },
        "L5": {
          "label": "L5",
          "addr": 4612
        },
        "L6": {
          "label": "L6",
          "addr": 4599
        },
        "L7": {
          "label": "L7",
          "addr": 4590
        },
        "L8": {
          "label": "L8",
          "addr": 4576
        },
        "L9": {
          "label": "L9",
          "addr": 4544
        },
        "L10": {
          "label": "L10",
          "addr": 4506
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int *ret_n) {\n  int *a = (int *)malloc(n * sizeof(int));\n  int i, j, k, t;\n  for (i = 0, j = 0; i < n; i++) {\n    for (k = 0; k < j; k++) {\n      if (a[k] == x[i])\n        break;\n    }\n    if (k == j) {\n      a[j] = x[i];\n      j++;\n    }\n  }\n  for (i = 0; i < j - 1; i++) {\n    for (k = i + 1; k < j; k++) {\n      if (a[i] > a[k]) {\n        t = a[i];\n        a[i] = a[k];\n        a[k] = t;\n      }\n    }\n  }\n  *ret_n = j;\n  return a;\n}"
    },
    {
      "task_id": 33,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    11d1 <func0+0x98>\n  mov    -0x1c(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cmp    %eax,-0x2c(%rbp)\n  jg     1196 <func0+0x5d>\n  movl   $0x0,-0x1c(%rbp)\n  jmp    12a9 <func0+0x170>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x18(%rbp)\n  jmp    1236 <func0+0xfd>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    1232 <func0+0xf9>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     11fc <func0+0xc3>\n  mov    -0x10(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  je     12a5 <func0+0x16c>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x14(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     11eb <func0+0xb2>\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1361 <func0+0x228>\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  test   %eax,%eax\n  jne    1330 <func0+0x1f7>\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  jmp    135d <func0+0x224>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     12c4 <func0+0x18b>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <free@plt>\n  nop\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL1:\n  mov    -0x1c(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cmp    %eax,-0x2c(%rbp)\n  jg     L1\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L2\nL7:\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x18(%rbp)\n  jmp    L3\nL5:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L4\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\nL4:\n  addl   $0x1,-0x18(%rbp)\nL3:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L5\n  mov    -0x10(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  je     L6\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\nL6:\n  addl   $0x1,-0x1c(%rbp)\nL2:\n  mov    -0x14(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     L7\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L8\nL11:\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  test   %eax,%eax\n  jne    L9\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  jmp    L10\nL9:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL10:\n  addl   $0x1,-0x1c(%rbp)\nL8:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L11\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  nop\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4561
        },
        "L1": {
          "label": "L1",
          "addr": 4502
        },
        "L2": {
          "label": "L2",
          "addr": 4777
        },
        "L3": {
          "label": "L3",
          "addr": 4662
        },
        "L4": {
          "label": "L4",
          "addr": 4658
        },
        "L5": {
          "label": "L5",
          "addr": 4604
        },
        "L6": {
          "label": "L6",
          "addr": 4773
        },
        "L7": {
          "label": "L7",
          "addr": 4587
        },
        "L8": {
          "label": "L8",
          "addr": 4961
        },
        "L9": {
          "label": "L9",
          "addr": 4912
        },
        "L10": {
          "label": "L10",
          "addr": 4957
        },
        "L11": {
          "label": "L11",
          "addr": 4804
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *p, int n, int *q) {\n  int *tmp = (int *)malloc((n / 3 + 1) * sizeof(int));\n  int i = 0, j = 0, k;\n  for (i = 0; i * 3 < n; i++) {\n    tmp[i] = p[i * 3];\n    j++;\n  }\n  for (i = 0; i < j - 1; i++) {\n    k = i;\n    for (i = k + 1; i < j; i++)\n      if (tmp[i] < tmp[k])\n        k = i;\n    if (k != i) {\n      int tmp1 = tmp[i];\n      tmp[i] = tmp[k];\n      tmp[k] = tmp1;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    if (i % 3 == 0)\n      q[i] = tmp[i / 3];\n    else\n      q[i] = p[i];\n  }\n  free(tmp);\n}"
    },
    {
      "task_id": 34,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11ea <func0+0xd1>\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11a5 <func0+0x8c>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    11a1 <func0+0x88>\n  movl   $0x1,-0x1c(%rbp)\n  jmp    11ad <func0+0x94>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     1168 <func0+0x4f>\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    11e6 <func0+0xcd>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1158 <func0+0x3f>\n  movl   $0x0,-0x14(%rbp)\n  jmp    12b3 <func0+0x19a>\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    12a3 <func0+0x18a>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    129f <func0+0x186>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     1210 <func0+0xf7>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     1202 <func0+0xe9>\n  mov    -0x38(%rbp),%rax\n  mov    -0x18(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL6:\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L1\nL4:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L2\n  movl   $0x1,-0x1c(%rbp)\n  jmp    L3\nL2:\n  addl   $0x1,-0x10(%rbp)\nL1:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     L4\nL3:\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    L5\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\nL5:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L6\n  movl   $0x0,-0x14(%rbp)\n  jmp    L7\nL11:\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    L8\nL10:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L9\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\nL9:\n  addl   $0x1,-0x10(%rbp)\nL8:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     L10\n  addl   $0x1,-0x14(%rbp)\nL7:\n  mov    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     L11\n  mov    -0x38(%rbp),%rax\n  mov    -0x18(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4586
        },
        "L1": {
          "label": "L1",
          "addr": 4517
        },
        "L2": {
          "label": "L2",
          "addr": 4513
        },
        "L3": {
          "label": "L3",
          "addr": 4525
        },
        "L4": {
          "label": "L4",
          "addr": 4456
        },
        "L5": {
          "label": "L5",
          "addr": 4582
        },
        "L6": {
          "label": "L6",
          "addr": 4440
        },
        "L7": {
          "label": "L7",
          "addr": 4787
        },
        "L8": {
          "label": "L8",
          "addr": 4771
        },
        "L9": {
          "label": "L9",
          "addr": 4767
        },
        "L10": {
          "label": "L10",
          "addr": 4624
        },
        "L11": {
          "label": "L11",
          "addr": 4610
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int *ret) {\n  int *y = (int *)malloc(n * sizeof(int));\n  int i, j, k, m;\n  m = 0;\n  for (i = 0; i < n; i++) {\n    k = 0;\n    for (j = 0; j < m; j++) {\n      if (x[i] == y[j]) {\n        k = 1;\n        break;\n      }\n    }\n    if (k == 0) {\n      y[m++] = x[i];\n    }\n  }\n  for (i = 0; i < m - 1; i++) {\n    for (j = i + 1; j < m; j++) {\n      if (y[i] > y[j]) {\n        k = y[i];\n        y[i] = y[j];\n        y[j] = k;\n      }\n    }\n  }\n  *ret = m;\n  return y;\n}"
    },
    {
      "task_id": 34,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r10\n  test   %r12d,%r12d\n  jle    122d <func0+0x10d>\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rdi\n  lea    0x4(%r10),%r8\n  xor    %r9d,%r9d\n  lea    0x4(%rbx,%rax,4),%rsi\n  nopl   (%rax)\n  mov    (%rdi),%edx\n  test   %r9d,%r9d\n  je     1210 <func0+0xf0>\n  lea    -0x1(%r9),%ecx\n  mov    %r10,%rax\n  lea    (%r8,%rcx,4),%rcx\n  jmp    118d <func0+0x6d>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     1210 <func0+0xf0>\n  cmp    %edx,(%rax)\n  jne    1180 <func0+0x60>\n  add    $0x4,%rdi\n  cmp    %rsi,%rdi\n  jne    1160 <func0+0x40>\n  cmp    $0x1,%r9d\n  je     1204 <func0+0xe4>\n  lea    -0x2(%r9),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r8d\n  add    $0x2,%r11\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbx\n  nopw   0x0(%rax,%rax,1)\n  cmp    %r8d,%r9d\n  jle    11f7 <func0+0xd7>\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rbx,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopw   0x0(%rax,%rax,1)\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11ee <func0+0xce>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    11e0 <func0+0xc0>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r8,%r11\n  jne    11c0 <func0+0xa0>\n  pop    %rbx\n  mov    %r9d,0x0(%rbp)\n  mov    %r10,%rax\n  pop    %rbp\n  pop    %r12\n  ret\n  movslq %r9d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r9d\n  mov    %edx,(%r10,%rax,4)\n  cmp    %rsi,%rdi\n  jne    1160 <func0+0x40>\n  jmp    119a <func0+0x7a>\n  xor    %r9d,%r9d\n  pop    %rbx\n  mov    %r10,%rax\n  mov    %r9d,0x0(%rbp)\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rdi\n  lea    0x4(%r10),%r8\n  xor    %r9d,%r9d\n  lea    0x4(%rbx,%rax,4),%rsi\n  nopl   (%rax)\nL4:\n  mov    (%rdi),%edx\n  test   %r9d,%r9d\n  je     L1\n  lea    -0x1(%r9),%ecx\n  mov    %r10,%rax\n  lea    (%r8,%rcx,4),%rcx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\n  add    $0x4,%rdi\n  cmp    %rsi,%rdi\n  jne    L4\nL10:\n  cmp    $0x1,%r9d\n  je     L5\n  lea    -0x2(%r9),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r8d\n  add    $0x2,%r11\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbx\n  nopw   0x0(%rax,%rax,1)\nL9:\n  cmp    %r8d,%r9d\n  jle    L6\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rbx,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L7\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\nL7:\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    L8\nL6:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r8,%r11\n  jne    L9\nL5:\n  pop    %rbx\n  mov    %r9d,0x0(%rbp)\n  mov    %r10,%rax\n  pop    %rbp\n  pop    %r12\n  ret\nL1:\n  movslq %r9d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r9d\n  mov    %edx,(%r10,%rax,4)\n  cmp    %rsi,%rdi\n  jne    L4\n  jmp    L10\nL0:\n  xor    %r9d,%r9d\n  pop    %rbx\n  mov    %r10,%rax\n  mov    %r9d,0x0(%rbp)\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4653
        },
        "L1": {
          "label": "L1",
          "addr": 4624
        },
        "L2": {
          "label": "L2",
          "addr": 4493
        },
        "L3": {
          "label": "L3",
          "addr": 4480
        },
        "L4": {
          "label": "L4",
          "addr": 4448
        },
        "L5": {
          "label": "L5",
          "addr": 4612
        },
        "L6": {
          "label": "L6",
          "addr": 4599
        },
        "L7": {
          "label": "L7",
          "addr": 4590
        },
        "L8": {
          "label": "L8",
          "addr": 4576
        },
        "L9": {
          "label": "L9",
          "addr": 4544
        },
        "L10": {
          "label": "L10",
          "addr": 4506
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int *ret_n) {\n  int *a = (int *)malloc(n * sizeof(int));\n  int i, j, k, t;\n  for (i = 0, j = 0; i < n; i++) {\n    for (k = 0; k < j; k++) {\n      if (a[k] == x[i])\n        break;\n    }\n    if (k == j) {\n      a[j] = x[i];\n      j++;\n    }\n  }\n  for (i = 0; i < j - 1; i++) {\n    for (k = i + 1; k < j; k++) {\n      if (a[i] > a[k]) {\n        t = a[i];\n        a[i] = a[k];\n        a[k] = t;\n      }\n    }\n  }\n  *ret_n = j;\n  return a;\n}"
    },
    {
      "task_id": 36,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    11db <func0+0xe2>\n  mov    -0x8(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x2e8ba2e9,%rax,%rax\n  shr    $0x20,%rax\n  sar    %eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  test   %edx,%edx\n  je     1176 <func0+0x7d>\n  mov    -0x8(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  test   %edx,%edx\n  jne    11d7 <func0+0xde>\n  mov    -0x8(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    11d1 <func0+0xd8>\n  mov    -0x4(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  cmp    $0x7,%edx\n  jne    11b1 <func0+0xb8>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x0,-0x4(%rbp)\n  jg     117e <func0+0x85>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     1117 <func0+0x1e>\n  mov    -0xc(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL6:\n  mov    -0x8(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x2e8ba2e9,%rax,%rax\n  shr    $0x20,%rax\n  sar    %eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  test   %edx,%edx\n  je     L1\n  mov    -0x8(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  test   %edx,%edx\n  jne    L2\nL1:\n  mov    -0x8(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    L3\nL5:\n  mov    -0x4(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  cmp    $0x7,%edx\n  jne    L4\n  addl   $0x1,-0xc(%rbp)\nL4:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x4(%rbp)\nL3:\n  cmpl   $0x0,-0x4(%rbp)\n  jg     L5\nL2:\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L6\n  mov    -0xc(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4571
        },
        "L1": {
          "label": "L1",
          "addr": 4470
        },
        "L2": {
          "label": "L2",
          "addr": 4567
        },
        "L3": {
          "label": "L3",
          "addr": 4561
        },
        "L4": {
          "label": "L4",
          "addr": 4529
        },
        "L5": {
          "label": "L5",
          "addr": 4478
        },
        "L6": {
          "label": "L6",
          "addr": 4375
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, j, c = 0;\n  for (i = 0; i < n; i++) {\n    if (i % 11 == 0 || i % 13 == 0) {\n      j = i;\n      while (j > 0) {\n        if (j % 10 == 7)\n          c++;\n        j /= 10;\n      }\n    }\n  }\n  return c;\n}"
    },
    {
      "task_id": 36,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    11af <func0+0xb6>\n  mov    $0x0,%ecx\n  mov    $0x0,%esi\n  jmp    1166 <func0+0x6d>\n  mov    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%r8d\n  sar    $0x1f,%r8d\n  sub    %r8d,%eax\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  mov    %edx,%r8d\n  sub    %eax,%r8d\n  cmp    $0x7,%r8d\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%esi\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%r8d\n  sar    $0x1f,%r8d\n  sub    %r8d,%eax\n  cmp    $0x9,%edx\n  jg     1111 <func0+0x18>\n  add    $0x1,%ecx\n  cmp    %ecx,%edi\n  je     11b4 <func0+0xbb>\n  movslq %ecx,%rax\n  imul   $0x2e8ba2e9,%rax,%rax\n  sar    $0x21,%rax\n  mov    %ecx,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%edx\n  lea    (%rax,%rdx,2),%eax\n  cmp    %eax,%ecx\n  je     11a4 <func0+0xab>\n  movslq %ecx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x22,%rax\n  mov    %ecx,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,2),%edx\n  lea    (%rax,%rdx,4),%eax\n  cmp    %eax,%ecx\n  jne    115f <func0+0x66>\n  test   %ecx,%ecx\n  jle    115f <func0+0x66>\n  mov    %ecx,%edx\n  jmp    1113 <func0+0x1a>\n  mov    $0x0,%esi\n  mov    %esi,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  mov    $0x0,%ecx\n  mov    $0x0,%esi\n  jmp    L1\nL2:\n  mov    %eax,%edx\nL6:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%r8d\n  sar    $0x1f,%r8d\n  sub    %r8d,%eax\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  mov    %edx,%r8d\n  sub    %eax,%r8d\n  cmp    $0x7,%r8d\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%esi\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%r8d\n  sar    $0x1f,%r8d\n  sub    %r8d,%eax\n  cmp    $0x9,%edx\n  jg     L2\nL5:\n  add    $0x1,%ecx\n  cmp    %ecx,%edi\n  je     L3\nL1:\n  movslq %ecx,%rax\n  imul   $0x2e8ba2e9,%rax,%rax\n  sar    $0x21,%rax\n  mov    %ecx,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%edx\n  lea    (%rax,%rdx,2),%eax\n  cmp    %eax,%ecx\n  je     L4\n  movslq %ecx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x22,%rax\n  mov    %ecx,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,2),%edx\n  lea    (%rax,%rdx,4),%eax\n  cmp    %eax,%ecx\n  jne    L5\nL4:\n  test   %ecx,%ecx\n  jle    L5\n  mov    %ecx,%edx\n  jmp    L6\nL0:\n  mov    $0x0,%esi\nL3:\n  mov    %esi,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4527
        },
        "L1": {
          "label": "L1",
          "addr": 4454
        },
        "L2": {
          "label": "L2",
          "addr": 4369
        },
        "L3": {
          "label": "L3",
          "addr": 4532
        },
        "L4": {
          "label": "L4",
          "addr": 4516
        },
        "L5": {
          "label": "L5",
          "addr": 4447
        },
        "L6": {
          "label": "L6",
          "addr": 4371
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, j, c = 0;\n  for (i = 0; i < n; i++) {\n    if (i % 11 == 0 || i % 12 == 0) {\n      j = i;\n      while (j > 0) {\n        if (j % 10 == 7)\n          c++;\n        j /= 10;\n      }\n    }\n  }\n  return c;\n}"
    },
    {
      "task_id": 36,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    116e <func0+0x6e>\n  xor    %esi,%esi\n  xor    %r8d,%r8d\n  mov    $0xcccccccd,%r9d\n  jmp    112c <func0+0x2c>\n  nopl   (%rax)\n  imul   $0xc4ec4ec5,%esi,%eax\n  cmp    $0x13b13b13,%eax\n  jbe    1139 <func0+0x39>\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  je     116a <func0+0x6a>\n  imul   $0xba2e8ba3,%esi,%eax\n  cmp    $0x1745d174,%eax\n  ja     1118 <func0+0x18>\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     1125 <func0+0x25>\n  nop\n  mov    %edx,%eax\n  imul   %r9,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  cmp    $0x7,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%r8d\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    1140 <func0+0x40>\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  jne    112c <func0+0x2c>\n  mov    %r8d,%eax\n  ret\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %esi,%esi\n  xor    %r8d,%r8d\n  mov    $0xcccccccd,%r9d\n  jmp    L1\n  nopl   (%rax)\nL4:\n  imul   $0xc4ec4ec5,%esi,%eax\n  cmp    $0x13b13b13,%eax\n  jbe    L2\nL5:\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  je     L3\nL1:\n  imul   $0xba2e8ba3,%esi,%eax\n  cmp    $0x1745d174,%eax\n  ja     L4\nL2:\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     L5\n  nop\nL6:\n  mov    %edx,%eax\n  imul   %r9,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  cmp    $0x7,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%r8d\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    L6\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  jne    L1\nL3:\n  mov    %r8d,%eax\n  ret\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4462
        },
        "L1": {
          "label": "L1",
          "addr": 4396
        },
        "L2": {
          "label": "L2",
          "addr": 4409
        },
        "L3": {
          "label": "L3",
          "addr": 4458
        },
        "L4": {
          "label": "L4",
          "addr": 4376
        },
        "L5": {
          "label": "L5",
          "addr": 4389
        },
        "L6": {
          "label": "L6",
          "addr": 4416
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, j, ret = 0;\n  for (i = 0; i < n; i++) {\n    if (i % 20 == 0 || i % 21 == 0) {\n      j = i;\n      while (j) {\n        if (j % 10 == 7)\n          ret++;\n        j /= 10;\n      }\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 33,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  mov    %r13d,%eax\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  imul   $0x55555556,%r13,%rdi\n  sar    $0x1f,%eax\n  push   %rbx\n  shr    $0x20,%rdi\n  sub    %eax,%edi\n  sub    $0x8,%rsp\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%r10\n  test   %r13d,%r13d\n  jle    1319 <func0+0x1d9>\n  lea    -0x1(%r13),%esi\n  mov    $0xaaaaaaab,%edx\n  mov    %r13,%rbx\n  mov    %rsi,%rax\n  imul   %rdx,%rsi\n  shr    $0x21,%rsi\n  add    $0x1,%esi\n  cmp    $0x8,%eax\n  jbe    1358 <func0+0x218>\n  mov    %esi,%ecx\n  movdqa 0xe4a(%rip),%xmm2        # 2000 <_fini+0xc94>\n  mov    %rbp,%rax\n  mov    %r10,%rdx\n  shr    $0x2,%ecx\n  movdqa 0xe49(%rip),%xmm4        # 2010 <_fini+0xca4>\n  shl    $0x4,%rcx\n  add    %r10,%rcx\n  xchg   %ax,%ax\n  movd   (%rax),%xmm0\n  add    $0x10,%rdx\n  movdqa %xmm2,%xmm3\n  add    $0x30,%rax\n  movd   -0x18(%rax),%xmm1\n  movd   -0xc(%rax),%xmm5\n  paddd  %xmm4,%xmm2\n  movd   -0x24(%rax),%xmm6\n  punpckldq %xmm5,%xmm1\n  punpckldq %xmm6,%xmm0\n  punpcklqdq %xmm1,%xmm0\n  movups %xmm0,-0x10(%rdx)\n  cmp    %rcx,%rdx\n  jne    11d0 <func0+0x90>\n  mov    %esi,%eax\n  pshufd $0xff,%xmm3,%xmm3\n  and    $0xfffffffc,%eax\n  movd   %xmm3,%r8d\n  lea    (%rax,%rax,2),%edx\n  cmp    %eax,%esi\n  je     1346 <func0+0x206>\n  movslq %edx,%rdx\n  movslq %eax,%rcx\n  mov    0x0(%rbp,%rdx,4),%edx\n  lea    0x0(,%rcx,4),%rsi\n  mov    %edx,(%r10,%rcx,4)\n  lea    0x1(%rax),%ecx\n  lea    (%rcx,%rcx,2),%edx\n  cmp    %edx,%ebx\n  jle    1343 <func0+0x203>\n  movslq %edx,%rdi\n  add    $0x3,%edx\n  lea    0x2(%rax),%r8d\n  lea    0x0(,%rdi,4),%r9\n  mov    0x0(%rbp,%rdi,4),%edi\n  mov    %edi,0x4(%r10,%rsi,1)\n  cmp    %ebx,%edx\n  jge    1361 <func0+0x221>\n  mov    0xc(%rbp,%r9,1),%eax\n  mov    %eax,0x8(%r10,%rsi,1)\n  lea    0x4(%r10),%rbx\n  xor    %r11d,%r11d\n  nopw   0x0(%rax,%rax,1)\n  mov    -0x4(%rbx),%r15d\n  mov    %r11d,%r14d\n  add    $0x1,%r11d\n  mov    %rbx,%rax\n  mov    %r14d,%r9d\n  mov    %r11d,%edx\n  mov    %r15d,%esi\n  jmp    12b5 <func0+0x175>\n  nopl   0x0(%rax)\n  movslq %r9d,%rcx\n  add    $0x4,%rax\n  lea    (%r10,%rcx,4),%rdi\n  lea    0x1(%rdx),%ecx\n  cmp    %r8d,%edx\n  jge    12cf <func0+0x18f>\n  mov    %ecx,%edx\n  mov    (%rax),%ecx\n  mov    %rax,%rdi\n  cmp    %esi,%ecx\n  jge    12a0 <func0+0x160>\n  mov    %ecx,%esi\n  mov    %edx,%r9d\n  lea    0x1(%rdx),%ecx\n  add    $0x4,%rax\n  cmp    %r8d,%edx\n  jl     12b3 <func0+0x173>\n  cmp    %r14d,%r9d\n  je     12da <func0+0x19a>\n  mov    %esi,-0x4(%rbx)\n  mov    %r15d,(%rdi)\n  add    $0x4,%rbx\n  cmp    %r8d,%r11d\n  jne    1280 <func0+0x140>\n  xor    %eax,%eax\n  mov    $0xaaaaaaab,%ecx\n  nopw   0x0(%rax,%rax,1)\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  ja     1330 <func0+0x1f0>\n  mov    %eax,%edx\n  imul   %rcx,%rdx\n  shr    $0x21,%rdx\n  mov    (%r10,%rdx,4),%edx\n  mov    %edx,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %r13,%rax\n  jne    12f0 <func0+0x1b0>\n  add    $0x8,%rsp\n  mov    %r10,%rdi\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  jmp    1060 <free@plt>\n  nop\n  mov    0x0(%rbp,%rax,4),%edx\n  mov    %edx,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r13\n  jne    12f0 <func0+0x1b0>\n  jmp    1319 <func0+0x1d9>\n  mov    %eax,%r8d\n  test   %r8d,%r8d\n  jg     1273 <func0+0x133>\n  jmp    12e3 <func0+0x1a3>\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    1222 <func0+0xe2>\n  mov    %ecx,%r8d\n  jmp    1273 <func0+0x133>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  mov    %r13d,%eax\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  imul   $0x55555556,%r13,%rdi\n  sar    $0x1f,%eax\n  push   %rbx\n  shr    $0x20,%rdi\n  sub    %eax,%edi\n  sub    $0x8,%rsp\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%esi\n  mov    $0xaaaaaaab,%edx\n  mov    %r13,%rbx\n  mov    %rsi,%rax\n  imul   %rdx,%rsi\n  shr    $0x21,%rsi\n  add    $0x1,%esi\n  cmp    $0x8,%eax\n  jbe    L1\n  mov    %esi,%ecx\n  movdqa D0(%rip),%xmm2\n  mov    %rbp,%rax\n  mov    %r10,%rdx\n  shr    $0x2,%ecx\n  movdqa D1(%rip),%xmm4\n  shl    $0x4,%rcx\n  add    %r10,%rcx\n  xchg   %ax,%ax\nL2:\n  movd   (%rax),%xmm0\n  add    $0x10,%rdx\n  movdqa %xmm2,%xmm3\n  add    $0x30,%rax\n  movd   -0x18(%rax),%xmm1\n  movd   -0xc(%rax),%xmm5\n  paddd  %xmm4,%xmm2\n  movd   -0x24(%rax),%xmm6\n  punpckldq %xmm5,%xmm1\n  punpckldq %xmm6,%xmm0\n  punpcklqdq %xmm1,%xmm0\n  movups %xmm0,-0x10(%rdx)\n  cmp    %rcx,%rdx\n  jne    L2\n  mov    %esi,%eax\n  pshufd $0xff,%xmm3,%xmm3\n  and    $0xfffffffc,%eax\n  movd   %xmm3,%r8d\n  lea    (%rax,%rax,2),%edx\n  cmp    %eax,%esi\n  je     L3\nL16:\n  movslq %edx,%rdx\n  movslq %eax,%rcx\n  mov    0x0(%rbp,%rdx,4),%edx\n  lea    0x0(,%rcx,4),%rsi\n  mov    %edx,(%r10,%rcx,4)\n  lea    0x1(%rax),%ecx\n  lea    (%rcx,%rcx,2),%edx\n  cmp    %edx,%ebx\n  jle    L4\n  movslq %edx,%rdi\n  add    $0x3,%edx\n  lea    0x2(%rax),%r8d\n  lea    0x0(,%rdi,4),%r9\n  mov    0x0(%rbp,%rdi,4),%edi\n  mov    %edi,0x4(%r10,%rsi,1)\n  cmp    %ebx,%edx\n  jge    L5\n  mov    0xc(%rbp,%r9,1),%eax\n  mov    %eax,0x8(%r10,%rsi,1)\nL14:\n  lea    0x4(%r10),%rbx\n  xor    %r11d,%r11d\n  nopw   0x0(%rax,%rax,1)\nL11:\n  mov    -0x4(%rbx),%r15d\n  mov    %r11d,%r14d\n  add    $0x1,%r11d\n  mov    %rbx,%rax\n  mov    %r14d,%r9d\n  mov    %r11d,%edx\n  mov    %r15d,%esi\n  jmp    L6\n  nopl   0x0(%rax)\nL8:\n  movslq %r9d,%rcx\n  add    $0x4,%rax\n  lea    (%r10,%rcx,4),%rdi\n  lea    0x1(%rdx),%ecx\n  cmp    %r8d,%edx\n  jge    L7\nL9:\n  mov    %ecx,%edx\nL6:\n  mov    (%rax),%ecx\n  mov    %rax,%rdi\n  cmp    %esi,%ecx\n  jge    L8\n  mov    %ecx,%esi\n  mov    %edx,%r9d\n  lea    0x1(%rdx),%ecx\n  add    $0x4,%rax\n  cmp    %r8d,%edx\n  jl     L9\nL7:\n  cmp    %r14d,%r9d\n  je     L10\n  mov    %esi,-0x4(%rbx)\n  mov    %r15d,(%rdi)\nL10:\n  add    $0x4,%rbx\n  cmp    %r8d,%r11d\n  jne    L11\nL15:\n  xor    %eax,%eax\n  mov    $0xaaaaaaab,%ecx\n  nopw   0x0(%rax,%rax,1)\nL13:\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  ja     L12\n  mov    %eax,%edx\n  imul   %rcx,%rdx\n  shr    $0x21,%rdx\n  mov    (%r10,%rdx,4),%edx\n  mov    %edx,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %r13,%rax\n  jne    L13\nL0:\n  add    $0x8,%rsp\n  mov    %r10,%rdi\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  jmp    1060 <free@plt>\n  nop\nL12:\n  mov    0x0(%rbp,%rax,4),%edx\n  mov    %edx,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r13\n  jne    L13\n  jmp    L0\nL4:\n  mov    %eax,%r8d\nL3:\n  test   %r8d,%r8d\n  jg     L14\n  jmp    L15\n  nopl   0x0(%rax)\nL1:\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    L16\nL5:\n  mov    %ecx,%r8d\n  jmp    L14",
      "num_missing": 2,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3658
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3657
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4889
        },
        "L1": {
          "label": "L1",
          "addr": 4952
        },
        "L2": {
          "label": "L2",
          "addr": 4560
        },
        "L3": {
          "label": "L3",
          "addr": 4934
        },
        "L4": {
          "label": "L4",
          "addr": 4931
        },
        "L5": {
          "label": "L5",
          "addr": 4961
        },
        "L6": {
          "label": "L6",
          "addr": 4789
        },
        "L7": {
          "label": "L7",
          "addr": 4815
        },
        "L8": {
          "label": "L8",
          "addr": 4768
        },
        "L9": {
          "label": "L9",
          "addr": 4787
        },
        "L10": {
          "label": "L10",
          "addr": 4826
        },
        "L11": {
          "label": "L11",
          "addr": 4736
        },
        "L12": {
          "label": "L12",
          "addr": 4912
        },
        "L13": {
          "label": "L13",
          "addr": 4848
        },
        "L14": {
          "label": "L14",
          "addr": 4723
        },
        "L15": {
          "label": "L15",
          "addr": 4835
        },
        "L16": {
          "label": "L16",
          "addr": 4642
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000000001000000020000000300000004000000040000000400000004000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              2,
              0,
              0,
              0,
              3,
              0,
              0,
              0
            ]
          },
          "0x2010": {
            "type": "byte[16]",
            "value": [
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *p, int n, int *q) {\n  int *t = (int *)malloc((n / 3 + 1) * sizeof(int));\n  int i, j, k, tmp;\n  for (i = 0; i < n; i++)\n    t[i / 3] = p[i];\n  for (i = 0; i < n; i++) {\n    k = i;\n    for (j = i + 1; j < n; j++)\n      if (t[j] < t[k])\n        k = j;\n    if (k != i) {\n      tmp = t[i];\n      t[i] = t[k];\n      t[k] = tmp;\n    }\n  }\n  for (i = 0; i < n; i++)\n    if (i % 3 == 0)\n      q[i / 3] = t[i / 3];\n    else\n      q[i / 3] = p[i];\n  free(t);\n}"
    },
    {
      "task_id": 36,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    116e <func0+0x6e>\n  xor    %esi,%esi\n  xor    %r8d,%r8d\n  mov    $0xcccccccd,%r9d\n  jmp    112c <func0+0x2c>\n  nopl   (%rax)\n  imul   $0xc4ec4ec5,%esi,%eax\n  cmp    $0x13b13b13,%eax\n  jbe    1139 <func0+0x39>\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  je     116a <func0+0x6a>\n  imul   $0xba2e8ba3,%esi,%eax\n  cmp    $0x1745d174,%eax\n  ja     1118 <func0+0x18>\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     1125 <func0+0x25>\n  nop\n  mov    %edx,%eax\n  imul   %r9,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  cmp    $0x7,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%r8d\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    1140 <func0+0x40>\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  jne    112c <func0+0x2c>\n  mov    %r8d,%eax\n  ret\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %esi,%esi\n  xor    %r8d,%r8d\n  mov    $0xcccccccd,%r9d\n  jmp    L1\n  nopl   (%rax)\nL4:\n  imul   $0xc4ec4ec5,%esi,%eax\n  cmp    $0x13b13b13,%eax\n  jbe    L2\nL5:\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  je     L3\nL1:\n  imul   $0xba2e8ba3,%esi,%eax\n  cmp    $0x1745d174,%eax\n  ja     L4\nL2:\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     L5\n  nop\nL6:\n  mov    %edx,%eax\n  imul   %r9,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  cmp    $0x7,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%r8d\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    L6\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  jne    L1\nL3:\n  mov    %r8d,%eax\n  ret\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4462
        },
        "L1": {
          "label": "L1",
          "addr": 4396
        },
        "L2": {
          "label": "L2",
          "addr": 4409
        },
        "L3": {
          "label": "L3",
          "addr": 4458
        },
        "L4": {
          "label": "L4",
          "addr": 4376
        },
        "L5": {
          "label": "L5",
          "addr": 4389
        },
        "L6": {
          "label": "L6",
          "addr": 4416
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, j, ret = 0;\n  for (i = 0; i < n; i++) {\n    if (i % 20 == 0 || i % 21 == 0) {\n      j = i;\n      while (j) {\n        if (j % 10 == 7)\n          ret++;\n        j /= 10;\n      }\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 32,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  pxor   %xmm0,%xmm0\n  movsd  %xmm0,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  movsd  (%rax),%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    1187 <func0+0x8e>\n  movsd  0xed1(%rip),%xmm0        # 2000 <_fini+0xd18>\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  jmp    1150 <func0+0x57>\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     113d <func0+0x44>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x18(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     1127 <func0+0x2e>\n  jmp    12b5 <func0+0x1bc>\n  pxor   %xmm0,%xmm0\n  movsd  %xmm0,-0x10(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    1213 <func0+0x11a>\n  movsd  0xe52(%rip),%xmm0        # 2000 <_fini+0xd18>\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x1,-0x28(%rbp)\n  jmp    11cf <func0+0xd6>\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x28(%rbp)\n  mov    -0x28(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     11bc <func0+0xc3>\n  pxor   %xmm1,%xmm1\n  cvtsi2sdl -0x30(%rbp),%xmm1\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  %xmm1,%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x10(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x10(%rbp)\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     11a6 <func0+0xad>\n  movsd  -0x18(%rbp),%xmm0\n  movapd %xmm0,%xmm1\n  divsd  -0x10(%rbp),%xmm1\n  movsd  -0x20(%rbp),%xmm0\n  subsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  movsd  (%rax),%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    12ad <func0+0x1b4>\n  movsd  0xdab(%rip),%xmm0        # 2000 <_fini+0xd18>\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    1276 <func0+0x17d>\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     1263 <func0+0x16a>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x18(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     124d <func0+0x154>\n  movsd  -0x18(%rbp),%xmm0\n  movq   0xd4e(%rip),%xmm1        # 2010 <_fini+0xd28>\n  andpd  %xmm1,%xmm0\n  comisd 0xd52(%rip),%xmm0        # 2020 <_fini+0xd38>\n  ja     1194 <func0+0x9b>\n  movsd  -0x20(%rbp),%xmm0\n  movq   %xmm0,%rax\n  movq   %rax,%xmm0\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  pxor   %xmm0,%xmm0\n  movsd  %xmm0,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  movsd  (%rax),%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    L0\nL3:\n  movsd  D0(%rip),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  jmp    L1\nL2:\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x2c(%rbp)\nL1:\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L2\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x18(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  addl   $0x1,-0x30(%rbp)\nL0:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L3\n  jmp    L4\nL13:\n  pxor   %xmm0,%xmm0\n  movsd  %xmm0,-0x10(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    L5\nL8:\n  movsd  D0(%rip),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x1,-0x28(%rbp)\n  jmp    L6\nL7:\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x28(%rbp)\nL6:\n  mov    -0x28(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L7\n  pxor   %xmm1,%xmm1\n  cvtsi2sdl -0x30(%rbp),%xmm1\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  %xmm1,%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x10(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x10(%rbp)\n  addl   $0x1,-0x30(%rbp)\nL5:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L8\n  movsd  -0x18(%rbp),%xmm0\n  movapd %xmm0,%xmm1\n  divsd  -0x10(%rbp),%xmm1\n  movsd  -0x20(%rbp),%xmm0\n  subsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  movsd  (%rax),%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    L9\nL12:\n  movsd  D0(%rip),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L10\nL11:\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x24(%rbp)\nL10:\n  mov    -0x24(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L11\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x18(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  addl   $0x1,-0x30(%rbp)\nL9:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L12\nL4:\n  movsd  -0x18(%rbp),%xmm0\n  movq   D1(%rip),%xmm1\n  andpd  %xmm1,%xmm0\n  comisd D2(%rip),%xmm0\n  ja     L13\n  movsd  -0x20(%rbp),%xmm0\n  movq   %xmm0,%rax\n  movq   %rax,%xmm0\n  pop    %rbp\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3793,
            3666,
            3499
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3406
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8224,
          "bias": [
            3410
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4487
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        },
        "L2": {
          "label": "L2",
          "addr": 4413
        },
        "L3": {
          "label": "L3",
          "addr": 4391
        },
        "L4": {
          "label": "L4",
          "addr": 4789
        },
        "L5": {
          "label": "L5",
          "addr": 4627
        },
        "L6": {
          "label": "L6",
          "addr": 4559
        },
        "L7": {
          "label": "L7",
          "addr": 4540
        },
        "L8": {
          "label": "L8",
          "addr": 4518
        },
        "L9": {
          "label": "L9",
          "addr": 4781
        },
        "L10": {
          "label": "L10",
          "addr": 4726
        },
        "L11": {
          "label": "L11",
          "addr": 4707
        },
        "L12": {
          "label": "L12",
          "addr": 4685
        },
        "L13": {
          "label": "L13",
          "addr": 4500
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000000000000f03f0000000000000000ffffffffffffff7f00000000000000008dedb5a0f7c6b03e",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f64",
            "value": 1.0
          },
          "0x2010": {
            "type": "qword",
            "value": 9223372036854775807
          },
          "0x2020": {
            "type": "byte[16]",
            "value": [
              141,
              237,
              181,
              160,
              247,
              198,
              176,
              62
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " double func0(double *x, int N) {\n  double t = 0.0;\n  double y = x[0];\n  int i, j, k;\n  double tmp;\n  for (i = 1; i < N; i++) {\n    tmp = 1.0;\n    for (j = 0; j < i; j++)\n      tmp *= t;\n    y += tmp * x[i];\n  }\n  while (fabs(y) > 0.000001) {\n    double dydt = 0.0;\n    for (i = 1; i < N; i++) {\n      tmp = 1.0;\n      for (k = 1; k < i; k++)\n        tmp *= t;\n      dydt += i * x[i] * tmp;\n    }\n    t -= y / dydt;\n    y = x[0];\n    for (i = 1; i < N; i++) {\n      tmp = 1.0;\n      for (j = 0; j < i; j++)\n        tmp *= t;\n      y += tmp * x[i];\n    }\n  }\n  return t;\n}"
    },
    {
      "task_id": 39,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    $0x0,%r8d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  jmp    1125 <func0+0x2c>\n  mov    $0x0,%esi\n  mov    %esi,%eax\n  ret\n  add    $0x1,%r8d\n  cmp    %r8d,%edi\n  je     1114 <func0+0x1b>\n  mov    %esi,%eax\n  mov    %r9d,%esi\n  cmp    %edi,%r8d\n  jge    110f <func0+0x16>\n  lea    (%rax,%rsi,1),%r9d\n  cmp    $0x3,%esi\n  jle    1117 <func0+0x1e>\n  test   $0x1,%sil\n  je     1120 <func0+0x27>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     1117 <func0+0x1e>\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    113e <func0+0x45>\n  jmp    1120 <func0+0x27>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x0,%r8d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  jmp    L0\nL2:\n  mov    $0x0,%esi\nL1:\n  mov    %esi,%eax\n  ret\nL3:\n  add    $0x1,%r8d\n  cmp    %r8d,%edi\n  je     L1\nL4:\n  mov    %esi,%eax\n  mov    %r9d,%esi\nL0:\n  cmp    %edi,%r8d\n  jge    L2\n  lea    (%rax,%rsi,1),%r9d\n  cmp    $0x3,%esi\n  jle    L3\n  test   $0x1,%sil\n  je     L4\n  mov    $0x2,%ecx\nL5:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     L3\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L5\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4389
        },
        "L1": {
          "label": "L1",
          "addr": 4372
        },
        "L2": {
          "label": "L2",
          "addr": 4367
        },
        "L3": {
          "label": "L3",
          "addr": 4375
        },
        "L4": {
          "label": "L4",
          "addr": 4384
        },
        "L5": {
          "label": "L5",
          "addr": 4414
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, j, k;\n  for (i = 0; i < n; i++) {\n    for (j = 2; j < i; j++) {\n      if (i % j == 0)\n        goto exit;\n    }\n    k = j;\n  exit:;\n  }\n  return k;\n}"
    },
    {
      "task_id": 39,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1158 <func0+0x58>\n  xor    %r9d,%r9d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  nopl   (%rax)\n  mov    %esi,%r8d\n  add    %eax,%esi\n  cmp    $0x3,%r8d\n  jle    1147 <func0+0x47>\n  test   $0x1,%r8b\n  je     1150 <func0+0x50>\n  mov    $0x2,%ecx\n  jmp    113a <func0+0x3a>\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1150 <func0+0x50>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    1130 <func0+0x30>\n  add    $0x1,%r9d\n  cmp    %r9d,%edi\n  je     115b <func0+0x5b>\n  mov    %r8d,%eax\n  cmp    %r9d,%edi\n  jg     1118 <func0+0x18>\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %r9d,%r9d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  nopl   (%rax)\nL6:\n  mov    %esi,%r8d\n  add    %eax,%esi\n  cmp    $0x3,%r8d\n  jle    L1\n  test   $0x1,%r8b\n  je     L2\n  mov    $0x2,%ecx\n  jmp    L3\nL4:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\nL3:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    L4\nL1:\n  add    $0x1,%r9d\n  cmp    %r9d,%edi\n  je     L5\nL2:\n  mov    %r8d,%eax\n  cmp    %r9d,%edi\n  jg     L6\nL0:\n  xor    %r8d,%r8d\nL5:\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4440
        },
        "L1": {
          "label": "L1",
          "addr": 4423
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4410
        },
        "L4": {
          "label": "L4",
          "addr": 4400
        },
        "L5": {
          "label": "L5",
          "addr": 4443
        },
        "L6": {
          "label": "L6",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, j, k;\n  for (i = 0; i < n; i++) {\n    for (j = 2; j * j <= i; j++) {\n      if (i % j == 0)\n        goto exit;\n    }\n    return i;\n  exit:;\n  }\n  return 0;\n}"
    },
    {
      "task_id": 40,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    1197 <func0+0x9e>\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    118b <func0+0x92>\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    117f <func0+0x86>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %eax,%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  test   %eax,%eax\n  jne    117b <func0+0x82>\n  mov    $0x1,%eax\n  jmp    11a8 <func0+0xaf>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     112a <func0+0x31>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111f <func0+0x26>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1114 <func0+0x1b>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL7:\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    L1\nL6:\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    L2\nL5:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %eax,%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  test   %eax,%eax\n  jne    L3\n  mov    $0x1,%eax\n  jmp    L4\nL3:\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L6\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L7\n  mov    $0x0,%eax\nL4:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4503
        },
        "L1": {
          "label": "L1",
          "addr": 4491
        },
        "L2": {
          "label": "L2",
          "addr": 4479
        },
        "L3": {
          "label": "L3",
          "addr": 4475
        },
        "L4": {
          "label": "L4",
          "addr": 4520
        },
        "L5": {
          "label": "L5",
          "addr": 4394
        },
        "L6": {
          "label": "L6",
          "addr": 4383
        },
        "L7": {
          "label": "L7",
          "addr": 4372
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int n) {\n  int i, j, k;\n  for (i = 0; i < n; i++)\n    for (j = i + 1; j < n; j++)\n      for (k = j + 1; k < n; k++)\n        if (arr[i] + arr[j] + arr[k] == 0)\n          return 1;\n  return 0;\n}"
    },
    {
      "task_id": 39,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1158 <func0+0x58>\n  xor    %r9d,%r9d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  nopl   (%rax)\n  mov    %esi,%r8d\n  add    %eax,%esi\n  cmp    $0x3,%r8d\n  jle    1147 <func0+0x47>\n  test   $0x1,%r8b\n  je     1150 <func0+0x50>\n  mov    $0x2,%ecx\n  jmp    113a <func0+0x3a>\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1150 <func0+0x50>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    1130 <func0+0x30>\n  add    $0x1,%r9d\n  cmp    %r9d,%edi\n  je     115b <func0+0x5b>\n  mov    %r8d,%eax\n  cmp    %r9d,%edi\n  jg     1118 <func0+0x18>\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %r9d,%r9d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  nopl   (%rax)\nL6:\n  mov    %esi,%r8d\n  add    %eax,%esi\n  cmp    $0x3,%r8d\n  jle    L1\n  test   $0x1,%r8b\n  je     L2\n  mov    $0x2,%ecx\n  jmp    L3\nL4:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\nL3:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    L4\nL1:\n  add    $0x1,%r9d\n  cmp    %r9d,%edi\n  je     L5\nL2:\n  mov    %r8d,%eax\n  cmp    %r9d,%edi\n  jg     L6\nL0:\n  xor    %r8d,%r8d\nL5:\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4440
        },
        "L1": {
          "label": "L1",
          "addr": 4423
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4410
        },
        "L4": {
          "label": "L4",
          "addr": 4400
        },
        "L5": {
          "label": "L5",
          "addr": 4443
        },
        "L6": {
          "label": "L6",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, j, c;\n  for (i = 0, c = 2; i < n; i++) {\n    for (j = 2; j * j <= c; j++)\n      if (c % j == 0)\n        break;\n    if (i < n)\n      c = c + j;\n    else\n      return c;\n  }\n  return 0;\n}"
    },
    {
      "task_id": 37,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebp,%ebp\n  jle    128f <func0+0x14f>\n  lea    -0x1(%rbp),%eax\n  mov    %eax,%edx\n  shr    %edx\n  cmp    $0x7,%eax\n  jbe    12bd <func0+0x17d>\n  shr    $0x3,%eax\n  mov    %eax,%esi\n  xor    %eax,%eax\n  mov    %rsi,%rcx\n  shl    $0x4,%rsi\n  nopl   0x0(%rax)\n  movups (%rbx,%rax,2),%xmm0\n  movups 0x10(%rbx,%rax,2),%xmm4\n  shufps $0x88,%xmm4,%xmm0\n  movups %xmm0,(%rdi,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rsi\n  jne    1198 <func0+0x58>\n  lea    0x0(,%rcx,4),%esi\n  lea    0x0(,%rcx,8),%eax\n  movslq %eax,%r9\n  movslq %esi,%rcx\n  movss  (%rbx,%r9,4),%xmm0\n  lea    0x0(,%rcx,4),%rsi\n  lea    0x0(,%r9,4),%r8\n  movss  %xmm0,(%rdi,%rcx,4)\n  lea    0x2(%rax),%ecx\n  cmp    %ecx,%ebp\n  jle    121d <func0+0xdd>\n  movss  0x8(%rbx,%r8,1),%xmm0\n  lea    0x4(%rax),%ecx\n  movss  %xmm0,0x4(%rdi,%rsi,1)\n  cmp    %ecx,%ebp\n  jle    121d <func0+0xdd>\n  movss  0x10(%rbx,%r8,1),%xmm0\n  add    $0x6,%eax\n  movss  %xmm0,0x8(%rdi,%rsi,1)\n  cmp    %eax,%ebp\n  jle    121d <func0+0xdd>\n  movss  0x18(%rbx,%r8,1),%xmm0\n  movss  %xmm0,0xc(%rdi,%rsi,1)\n  test   %edx,%edx\n  je     1261 <func0+0x121>\n  lea    0x4(%rdi),%rsi\n  nopl   (%rax)\n  sub    $0x1,%edx\n  mov    %rdi,%rax\n  mov    %rdx,%rcx\n  lea    (%rsi,%rdx,4),%rdx\n  nopl   (%rax)\n  movq   (%rax),%xmm0\n  movaps %xmm0,%xmm3\n  movaps %xmm0,%xmm2\n  shufps $0xe5,%xmm3,%xmm3\n  comiss %xmm3,%xmm0\n  shufps $0xe1,%xmm2,%xmm2\n  jbe    1252 <func0+0x112>\n  movlps %xmm2,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdx\n  jne    1238 <func0+0xf8>\n  mov    %ecx,%edx\n  test   %ecx,%ecx\n  jne    1228 <func0+0xe8>\n  movslq %ebp,%rdx\n  xor    %eax,%eax\n  cs nopw 0x0(%rax,%rax,1)\n  test   $0x1,%al\n  jne    12a0 <func0+0x160>\n  mov    %eax,%ecx\n  sar    %ecx\n  movslq %ecx,%rcx\n  movss  (%rdi,%rcx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rdx,%rax\n  jne    1270 <func0+0x130>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rbx,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rdx\n  jne    1270 <func0+0x130>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>\n  xor    %esi,%esi\n  xor    %eax,%eax\n  jmp    11c0 <func0+0x80>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebp,%ebp\n  jle    L0\n  lea    -0x1(%rbp),%eax\n  mov    %eax,%edx\n  shr    %edx\n  cmp    $0x7,%eax\n  jbe    L1\n  shr    $0x3,%eax\n  mov    %eax,%esi\n  xor    %eax,%eax\n  mov    %rsi,%rcx\n  shl    $0x4,%rsi\n  nopl   0x0(%rax)\nL2:\n  movups (%rbx,%rax,2),%xmm0\n  movups 0x10(%rbx,%rax,2),%xmm4\n  shufps $0x88,%xmm4,%xmm0\n  movups %xmm0,(%rdi,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rsi\n  jne    L2\n  lea    0x0(,%rcx,4),%esi\n  lea    0x0(,%rcx,8),%eax\nL10:\n  movslq %eax,%r9\n  movslq %esi,%rcx\n  movss  (%rbx,%r9,4),%xmm0\n  lea    0x0(,%rcx,4),%rsi\n  lea    0x0(,%r9,4),%r8\n  movss  %xmm0,(%rdi,%rcx,4)\n  lea    0x2(%rax),%ecx\n  cmp    %ecx,%ebp\n  jle    L3\n  movss  0x8(%rbx,%r8,1),%xmm0\n  lea    0x4(%rax),%ecx\n  movss  %xmm0,0x4(%rdi,%rsi,1)\n  cmp    %ecx,%ebp\n  jle    L3\n  movss  0x10(%rbx,%r8,1),%xmm0\n  add    $0x6,%eax\n  movss  %xmm0,0x8(%rdi,%rsi,1)\n  cmp    %eax,%ebp\n  jle    L3\n  movss  0x18(%rbx,%r8,1),%xmm0\n  movss  %xmm0,0xc(%rdi,%rsi,1)\nL3:\n  test   %edx,%edx\n  je     L4\n  lea    0x4(%rdi),%rsi\n  nopl   (%rax)\nL7:\n  sub    $0x1,%edx\n  mov    %rdi,%rax\n  mov    %rdx,%rcx\n  lea    (%rsi,%rdx,4),%rdx\n  nopl   (%rax)\nL6:\n  movq   (%rax),%xmm0\n  movaps %xmm0,%xmm3\n  movaps %xmm0,%xmm2\n  shufps $0xe5,%xmm3,%xmm3\n  comiss %xmm3,%xmm0\n  shufps $0xe1,%xmm2,%xmm2\n  jbe    L5\n  movlps %xmm2,(%rax)\nL5:\n  add    $0x4,%rax\n  cmp    %rax,%rdx\n  jne    L6\n  mov    %ecx,%edx\n  test   %ecx,%ecx\n  jne    L7\nL4:\n  movslq %ebp,%rdx\n  xor    %eax,%eax\n  cs nopw 0x0(%rax,%rax,1)\nL9:\n  test   $0x1,%al\n  jne    L8\n  mov    %eax,%ecx\n  sar    %ecx\n  movslq %ecx,%rcx\n  movss  (%rdi,%rcx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rdx,%rax\n  jne    L9\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>\n  nopl   0x0(%rax,%rax,1)\nL8:\n  movss  (%rbx,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rdx\n  jne    L9\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>\nL1:\n  xor    %esi,%esi\n  xor    %eax,%eax\n  jmp    L10",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4751
        },
        "L1": {
          "label": "L1",
          "addr": 4797
        },
        "L2": {
          "label": "L2",
          "addr": 4504
        },
        "L3": {
          "label": "L3",
          "addr": 4637
        },
        "L4": {
          "label": "L4",
          "addr": 4705
        },
        "L5": {
          "label": "L5",
          "addr": 4690
        },
        "L6": {
          "label": "L6",
          "addr": 4664
        },
        "L7": {
          "label": "L7",
          "addr": 4648
        },
        "L8": {
          "label": "L8",
          "addr": 4768
        },
        "L9": {
          "label": "L9",
          "addr": 4720
        },
        "L10": {
          "label": "L10",
          "addr": 4544
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(float *x, int n, float *y) {\n  int i;\n  float *t = (float *)malloc((n / 2 + 1) * sizeof(float));\n  for (i = 0; i < n; i += 2)\n    t[i / 2] = x[i];\n  for (i = 0; i < n / 2; i++)\n    if (t[i] < t[i + 1]) {\n      float tmp = t[i];\n      t[i] = t[i + 1];\n      t[i + 1] = tmp;\n    }\n  for (i = 0; i < n; i++)\n    if (i % 2 == 0)\n      y[i] = t[i / 2];\n    else\n      y[i] = x[i];\n  free(t);\n}"
    },
    {
      "task_id": 37,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  movslq %esi,%rbx\n  mov    %ebx,%edi\n  shr    $0x1f,%edi\n  add    %ebx,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    1214 <func0+0xd4>\n  xor    %eax,%eax\n  cs nopw 0x0(%rax,%rax,1)\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%rdi,%rax,2)\n  add    $0x2,%rax\n  cmp    %eax,%ebx\n  jg     1180 <func0+0x40>\n  lea    -0x1(%rbx),%edx\n  shr    %edx\n  je     11d6 <func0+0x96>\n  lea    0x4(%rdi),%rsi\n  xchg   %ax,%ax\n  sub    $0x1,%edx\n  mov    %rdi,%rax\n  mov    %rdx,%rcx\n  lea    (%rsi,%rdx,4),%rdx\n  nopl   (%rax)\n  movss  (%rax),%xmm0\n  movss  0x4(%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    11c7 <func0+0x87>\n  movss  %xmm1,(%rax)\n  movss  %xmm0,0x4(%rax)\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    11b0 <func0+0x70>\n  mov    %ecx,%edx\n  test   %ecx,%ecx\n  jne    11a0 <func0+0x60>\n  xor    %eax,%eax\n  jmp    11fb <func0+0xbb>\n  nopw   0x0(%rax,%rax,1)\n  mov    %eax,%edx\n  sar    %edx\n  movslq %edx,%rdx\n  movss  (%rdi,%rdx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rbx\n  je     1214 <func0+0xd4>\n  test   $0x1,%al\n  je     11e0 <func0+0xa0>\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rbx\n  jne    11fb <func0+0xbb>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  movslq %esi,%rbx\n  mov    %ebx,%edi\n  shr    $0x1f,%edi\n  add    %ebx,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    L0\n  xor    %eax,%eax\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%rdi,%rax,2)\n  add    $0x2,%rax\n  cmp    %eax,%ebx\n  jg     L1\n  lea    -0x1(%rbx),%edx\n  shr    %edx\n  je     L2\n  lea    0x4(%rdi),%rsi\n  xchg   %ax,%ax\nL5:\n  sub    $0x1,%edx\n  mov    %rdi,%rax\n  mov    %rdx,%rcx\n  lea    (%rsi,%rdx,4),%rdx\n  nopl   (%rax)\nL4:\n  movss  (%rax),%xmm0\n  movss  0x4(%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L3\n  movss  %xmm1,(%rax)\n  movss  %xmm0,0x4(%rax)\nL3:\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    L4\n  mov    %ecx,%edx\n  test   %ecx,%ecx\n  jne    L5\nL2:\n  xor    %eax,%eax\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL7:\n  mov    %eax,%edx\n  sar    %edx\n  movslq %edx,%rdx\n  movss  (%rdi,%rdx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rbx\n  je     L0\nL6:\n  test   $0x1,%al\n  je     L7\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rbx\n  jne    L6\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4628
        },
        "L1": {
          "label": "L1",
          "addr": 4480
        },
        "L2": {
          "label": "L2",
          "addr": 4566
        },
        "L3": {
          "label": "L3",
          "addr": 4551
        },
        "L4": {
          "label": "L4",
          "addr": 4528
        },
        "L5": {
          "label": "L5",
          "addr": 4512
        },
        "L6": {
          "label": "L6",
          "addr": 4603
        },
        "L7": {
          "label": "L7",
          "addr": 4576
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(float *x, int n, float *y) {\n  int i, j;\n  float *z;\n  z = (float *)malloc(((n / 2) + 1) * sizeof(float));\n  for (i = 0; i < n; i += 2)\n    z[i / 2] = x[i];\n  for (i = n - 1; i > 0; i--)\n    for (j = 0; j < i; j++)\n      if (z[j] > z[j + 1]) {\n        float tmp = z[j];\n        z[j] = z[j + 1];\n        z[j + 1] = tmp;\n      }\n  for (i = 0; i < n; i++)\n    if (i % 2 == 0)\n      y[i] = z[i / 2];\n    else\n      y[i] = x[i];\n  free(z);\n}"
    },
    {
      "task_id": 37,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  mov    %rdx,%r12\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    11fa <func0+0xc1>\n  mov    $0x0,%eax\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%rdi,%rax,2)\n  add    $0x2,%rax\n  cmp    %eax,%ebx\n  jg     1171 <func0+0x38>\n  lea    -0x1(%rbx),%ecx\n  shr    %ecx\n  je     1204 <func0+0xcb>\n  lea    0x4(%rdi),%rsi\n  jmp    11b8 <func0+0x7f>\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  je     11b3 <func0+0x7a>\n  movss  (%rax),%xmm0\n  movss  0x4(%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1191 <func0+0x58>\n  movss  %xmm1,(%rax)\n  movss  %xmm0,0x4(%rax)\n  jmp    1191 <func0+0x58>\n  sub    $0x1,%ecx\n  je     1204 <func0+0xcb>\n  test   %ecx,%ecx\n  jle    11b3 <func0+0x7a>\n  mov    %rdi,%rax\n  lea    -0x1(%rcx),%edx\n  lea    (%rsi,%rdx,4),%rdx\n  jmp    119a <func0+0x61>\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rbx,%rax\n  je     11fa <func0+0xc1>\n  test   $0x1,%al\n  jne    11c8 <func0+0x8f>\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %eax,%edx\n  sar    %edx\n  movslq %edx,%rdx\n  movss  (%rdi,%rdx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  jmp    11d4 <func0+0x9b>\n  call   1060 <free@plt>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  mov    %ebx,%ebx\n  mov    $0x0,%eax\n  jmp    11dd <func0+0xa4>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  mov    %rdx,%r12\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    L0\n  mov    $0x0,%eax\nL1:\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%rdi,%rax,2)\n  add    $0x2,%rax\n  cmp    %eax,%ebx\n  jg     L1\n  lea    -0x1(%rbx),%ecx\n  shr    %ecx\n  je     L2\n  lea    0x4(%rdi),%rsi\n  jmp    L3\nL5:\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  je     L4\nL6:\n  movss  (%rax),%xmm0\n  movss  0x4(%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L5\n  movss  %xmm1,(%rax)\n  movss  %xmm0,0x4(%rax)\n  jmp    L5\nL4:\n  sub    $0x1,%ecx\n  je     L2\nL3:\n  test   %ecx,%ecx\n  jle    L4\n  mov    %rdi,%rax\n  lea    -0x1(%rcx),%edx\n  lea    (%rsi,%rdx,4),%rdx\n  jmp    L6\nL7:\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\nL8:\n  add    $0x1,%rax\n  cmp    %rbx,%rax\n  je     L0\nL9:\n  test   $0x1,%al\n  jne    L7\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %eax,%edx\n  sar    %edx\n  movslq %edx,%rdx\n  movss  (%rdi,%rdx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  jmp    L8\nL0:\n  call   <free@plt>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL2:\n  mov    %ebx,%ebx\n  mov    $0x0,%eax\n  jmp    L9",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4602
        },
        "L1": {
          "label": "L1",
          "addr": 4465
        },
        "L2": {
          "label": "L2",
          "addr": 4612
        },
        "L3": {
          "label": "L3",
          "addr": 4536
        },
        "L4": {
          "label": "L4",
          "addr": 4531
        },
        "L5": {
          "label": "L5",
          "addr": 4497
        },
        "L6": {
          "label": "L6",
          "addr": 4506
        },
        "L7": {
          "label": "L7",
          "addr": 4552
        },
        "L8": {
          "label": "L8",
          "addr": 4564
        },
        "L9": {
          "label": "L9",
          "addr": 4573
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(float *x, int n, float *y) {\n  int i, j;\n  float *t, tmp;\n  t = (float *)malloc(((n / 2) + 1) * sizeof(float));\n  for (i = 0; i < n; i += 2)\n    t[i / 2] = x[i];\n  for (i = n - 1; i > 0; i--)\n    for (j = 0; j < i; j++)\n      if (t[j] > t[j + 1]) {\n        tmp = t[j];\n        t[j] = t[j + 1];\n        t[j + 1] = tmp;\n      }\n  for (i = 0; i < n; i++)\n    if (i % 2 == 0)\n      y[i] = t[i / 2];\n    else\n      y[i] = x[i];\n  free(t);\n}"
    },
    {
      "task_id": 41,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int a = x * x;\n  return a;\n}"
    },
    {
      "task_id": 37,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    11bc <func0+0x83>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rcx),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x2,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1181 <func0+0x48>\n  movl   $0x0,-0x18(%rbp)\n  jmp    12a1 <func0+0x168>\n  movl   $0x0,-0x14(%rbp)\n  jmp    128b <func0+0x152>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1287 <func0+0x14e>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  -0xc(%rbp),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  sub    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     11dc <func0+0xa3>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x10(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     11d0 <func0+0x97>\n  movl   $0x0,-0x18(%rbp)\n  jmp    1332 <func0+0x1f9>\n  mov    -0x18(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    12fe <func0+0x1c5>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  jmp    132e <func0+0x1f5>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     12b9 <func0+0x180>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <free@plt>\n  nop\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    L0\nL1:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rcx),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x2,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L1\n  movl   $0x0,-0x18(%rbp)\n  jmp    L2\nL6:\n  movl   $0x0,-0x14(%rbp)\n  jmp    L3\nL5:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L4\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  -0xc(%rbp),%xmm0\n  movss  %xmm0,(%rax)\nL4:\n  addl   $0x1,-0x14(%rbp)\nL3:\n  mov    -0x10(%rbp),%eax\n  sub    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     L5\n  addl   $0x1,-0x18(%rbp)\nL2:\n  mov    -0x10(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     L6\n  movl   $0x0,-0x18(%rbp)\n  jmp    L7\nL10:\n  mov    -0x18(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L8\n  mov    -0x18(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  jmp    L9\nL8:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\nL9:\n  addl   $0x1,-0x18(%rbp)\nL7:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L10\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  nop\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4540
        },
        "L1": {
          "label": "L1",
          "addr": 4481
        },
        "L2": {
          "label": "L2",
          "addr": 4769
        },
        "L3": {
          "label": "L3",
          "addr": 4747
        },
        "L4": {
          "label": "L4",
          "addr": 4743
        },
        "L5": {
          "label": "L5",
          "addr": 4572
        },
        "L6": {
          "label": "L6",
          "addr": 4560
        },
        "L7": {
          "label": "L7",
          "addr": 4914
        },
        "L8": {
          "label": "L8",
          "addr": 4862
        },
        "L9": {
          "label": "L9",
          "addr": 4910
        },
        "L10": {
          "label": "L10",
          "addr": 4793
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(float *ptr, int n, float *out) {\n  int i, j;\n  float *tmp = (float *)malloc((n / 2 + 1) * sizeof(float));\n  int k = 0;\n  for (i = 0; i < n; i += 2) {\n    tmp[k++] = ptr[i];\n  }\n  for (i = 0; i < k - 1; i++) {\n    for (j = 0; j < k - i - 1; j++) {\n      if (tmp[j] > tmp[j + 1]) {\n        float t = tmp[j];\n        tmp[j] = tmp[j + 1];\n        tmp[j + 1] = t;\n      }\n    }\n  }\n  for (i = 0; i < n; i++) {\n    if (i % 2 == 0) {\n      out[i] = tmp[i / 2];\n    } else {\n      out[i] = ptr[i];\n    }\n  }\n  free(tmp);\n}"
    },
    {
      "task_id": 41,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  imul   %edi,%edi\n  mov    %edi,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  imul   %edi,%edi\n  mov    %edi,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int a = x * x;\n  return a;\n}"
    },
    {
      "task_id": 39,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x24(%rbp)\n  movl   $0x1,-0x18(%rbp)\n  movl   $0x2,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    117f <func0+0x86>\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    115d <func0+0x64>\n  mov    -0x18(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1159 <func0+0x60>\n  movl   $0x0,-0xc(%rbp)\n  jmp    1168 <func0+0x6f>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x18(%rbp)\n  jge    1143 <func0+0x4a>\n  cmpl   $0x0,-0xc(%rbp)\n  je     1172 <func0+0x79>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jne    117f <func0+0x86>\n  mov    -0x18(%rbp),%eax\n  jmp    118c <func0+0x93>\n  mov    -0x10(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     111b <func0+0x22>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x24(%rbp)\n  movl   $0x1,-0x18(%rbp)\n  movl   $0x2,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL7:\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    L1\nL4:\n  mov    -0x18(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L2\n  movl   $0x0,-0xc(%rbp)\n  jmp    L3\nL2:\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x18(%rbp)\n  jge    L4\nL3:\n  cmpl   $0x0,-0xc(%rbp)\n  je     L5\n  addl   $0x1,-0x10(%rbp)\nL5:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jne    L0\n  mov    -0x18(%rbp),%eax\n  jmp    L6\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     L7\n  mov    $0x0,%eax\nL6:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4479
        },
        "L1": {
          "label": "L1",
          "addr": 4445
        },
        "L2": {
          "label": "L2",
          "addr": 4441
        },
        "L3": {
          "label": "L3",
          "addr": 4456
        },
        "L4": {
          "label": "L4",
          "addr": 4419
        },
        "L5": {
          "label": "L5",
          "addr": 4466
        },
        "L6": {
          "label": "L6",
          "addr": 4492
        },
        "L7": {
          "label": "L7",
          "addr": 4379
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int a = 1, b = 2, c, d, e, f;\n  for (c = 0; c < n; c++) {\n    a = a + b;\n    d = a;\n    a = b;\n    b = d;\n    e = 1;\n    for (f = 2; f * f <= a; f++)\n      if (a % f == 0) {\n        e = 0;\n        break;\n      }\n    if (e)\n      continue;\n    else\n      break;\n  }\n  if (c == n)\n    return a;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 38,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <strlen@plt>\n  mov    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  add    $0x2,%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1284 <func0+0x12b>\n  mov    -0x1c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cmp    %eax,-0x18(%rbp)\n  jge    11d8 <func0+0x7f>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shl    $0x2,%eax\n  sub    %eax,%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  jmp    11dd <func0+0x84>\n  mov    $0x3,%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x1c(%rbp),%ecx\n  mov    %ecx,%eax\n  add    %eax,%eax\n  add    %ecx,%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rcx\n  lea    -0xc(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  mov    -0x10(%rbp),%eax\n  cltq\n  movb   $0x0,-0xc(%rbp,%rax,1)\n  cmpl   $0x3,-0x10(%rbp)\n  jne    1258 <func0+0xff>\n  cmpl   $0x0,-0x2c(%rbp)\n  je     123c <func0+0xe3>\n  movzbl -0xa(%rbp),%eax\n  mov    %al,-0x1d(%rbp)\n  movzbl -0xb(%rbp),%eax\n  mov    %al,-0xa(%rbp)\n  movzbl -0xc(%rbp),%eax\n  mov    %al,-0xb(%rbp)\n  movzbl -0x1d(%rbp),%eax\n  mov    %al,-0xc(%rbp)\n  jmp    1258 <func0+0xff>\n  movzbl -0xc(%rbp),%eax\n  mov    %al,-0x1e(%rbp)\n  movzbl -0xb(%rbp),%eax\n  mov    %al,-0xc(%rbp)\n  movzbl -0xa(%rbp),%eax\n  mov    %al,-0xb(%rbp)\n  movzbl -0x1e(%rbp),%eax\n  mov    %al,-0xa(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x1c(%rbp),%ecx\n  mov    %ecx,%eax\n  add    %eax,%eax\n  add    %ecx,%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rcx\n  lea    -0xc(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   1070 <strncpy@plt>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     11b6 <func0+0x5d>\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     12a5 <func0+0x14c>\n  call   1090 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  add    $0x2,%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL5:\n  mov    -0x1c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cmp    %eax,-0x18(%rbp)\n  jge    L1\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shl    $0x2,%eax\n  sub    %eax,%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  jmp    L2\nL1:\n  mov    $0x3,%eax\nL2:\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x1c(%rbp),%ecx\n  mov    %ecx,%eax\n  add    %eax,%eax\n  add    %ecx,%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rcx\n  lea    -0xc(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  mov    -0x10(%rbp),%eax\n  cltq\n  movb   $0x0,-0xc(%rbp,%rax,1)\n  cmpl   $0x3,-0x10(%rbp)\n  jne    L3\n  cmpl   $0x0,-0x2c(%rbp)\n  je     L4\n  movzbl -0xa(%rbp),%eax\n  mov    %al,-0x1d(%rbp)\n  movzbl -0xb(%rbp),%eax\n  mov    %al,-0xa(%rbp)\n  movzbl -0xc(%rbp),%eax\n  mov    %al,-0xb(%rbp)\n  movzbl -0x1d(%rbp),%eax\n  mov    %al,-0xc(%rbp)\n  jmp    L3\nL4:\n  movzbl -0xc(%rbp),%eax\n  mov    %al,-0x1e(%rbp)\n  movzbl -0xb(%rbp),%eax\n  mov    %al,-0xc(%rbp)\n  movzbl -0xa(%rbp),%eax\n  mov    %al,-0xb(%rbp)\n  movzbl -0x1e(%rbp),%eax\n  mov    %al,-0xa(%rbp)\nL3:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x1c(%rbp),%ecx\n  mov    %ecx,%eax\n  add    %eax,%eax\n  add    %ecx,%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rcx\n  lea    -0xc(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   <strncpy@plt>\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L5\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     L6\n  call   <__stack_chk_fail@plt>\nL6:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4740
        },
        "L1": {
          "label": "L1",
          "addr": 4568
        },
        "L2": {
          "label": "L2",
          "addr": 4573
        },
        "L3": {
          "label": "L3",
          "addr": 4696
        },
        "L4": {
          "label": "L4",
          "addr": 4668
        },
        "L5": {
          "label": "L5",
          "addr": 4534
        },
        "L6": {
          "label": "L6",
          "addr": 4773
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *src, int flag) {\n  int i, j, k, len;\n  char buf[4];\n  len = strlen(src);\n  k = (len + 2) / 3;\n  for (i = 0; i < k; i++) {\n    j = (i + 1) * 3 > len ? 3 : len - i * 3;\n    strncpy(buf, src + i * 3, j);\n    buf[j] = '\\0';\n    if (j == 3) {\n      if (flag) {\n        char tmp;\n        tmp = buf[0];\n        buf[0] = buf[2];\n        buf[2] = tmp;\n      } else {\n        char tmp;\n        tmp = buf[0];\n        buf[0] = buf[2];\n        buf[2] = buf[1];\n        buf[1] = tmp;\n      }\n    }\n    strncpy(src + i * 3, buf, j);\n  }\n}"
    },
    {
      "task_id": 41,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  imul   %edi,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  imul   %edi,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int a = x * x;\n  return a;\n}"
    },
    {
      "task_id": 41,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  imul   %edi,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  imul   %edi,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int a = x * x;\n  return a;\n}"
    },
    {
      "task_id": 38,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1090 <strlen@plt>\n  mov    %rax,%rbp\n  mov    %eax,%r14d\n  add    $0x2,%eax\n  movslq %eax,%r13\n  sar    $0x1f,%eax\n  imul   $0x55555556,%r13,%r13\n  shr    $0x20,%r13\n  sub    %eax,%r13d\n  test   %ebp,%ebp\n  jle    1288 <func0+0x108>\n  xor    %ebx,%ebx\n  lea    0x14(%rsp),%r12\n  jmp    1237 <func0+0xb7>\n  nopl   0x0(%rax)\n  mov    $0x3,%edx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  call   1080 <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\n  mov    0xc(%rsp),%esi\n  movzbl 0x15(%rsp),%ecx\n  movzbl 0x16(%rsp),%edx\n  movzbl 0x14(%rsp),%eax\n  test   %esi,%esi\n  je     1270 <func0+0xf0>\n  mov    %cl,0x16(%rsp)\n  mov    %al,0x15(%rsp)\n  mov    %dl,0x14(%rsp)\n  mov    $0x3,%edx\n  nopl   (%rax)\n  mov    %r15,%rdi\n  mov    %r12,%rsi\n  add    $0x3,%r15\n  sub    $0x3,%ebp\n  call   1080 <strncpy@plt>\n  cmp    %r13d,%ebx\n  jge    1288 <func0+0x108>\n  add    $0x1,%ebx\n  lea    (%rbx,%rbx,2),%eax\n  cmp    %r14d,%eax\n  jle    11e0 <func0+0x60>\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  mov    %rdx,(%rsp)\n  call   10b0 <__strncpy_chk@plt>\n  mov    (%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    1220 <func0+0xa0>\n  jmp    11f5 <func0+0x75>\n  nopl   0x0(%rax)\n  mov    %dl,0x15(%rsp)\n  mov    $0x3,%edx\n  mov    %cl,0x14(%rsp)\n  mov    %al,0x16(%rsp)\n  jmp    1220 <func0+0xa0>\n  nopl   0x0(%rax,%rax,1)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12a7 <func0+0x127>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10a0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  mov    %eax,%r14d\n  add    $0x2,%eax\n  movslq %eax,%r13\n  sar    $0x1f,%eax\n  imul   $0x55555556,%r13,%r13\n  shr    $0x20,%r13\n  sub    %eax,%r13d\n  test   %ebp,%ebp\n  jle    L0\n  xor    %ebx,%ebx\n  lea    0x14(%rsp),%r12\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  mov    $0x3,%edx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\nL5:\n  mov    0xc(%rsp),%esi\n  movzbl 0x15(%rsp),%ecx\n  movzbl 0x16(%rsp),%edx\n  movzbl 0x14(%rsp),%eax\n  test   %esi,%esi\n  je     L2\n  mov    %cl,0x16(%rsp)\n  mov    %al,0x15(%rsp)\n  mov    %dl,0x14(%rsp)\n  mov    $0x3,%edx\n  nopl   (%rax)\nL4:\n  mov    %r15,%rdi\n  mov    %r12,%rsi\n  add    $0x3,%r15\n  sub    $0x3,%ebp\n  call   <strncpy@plt>\n  cmp    %r13d,%ebx\n  jge    L0\nL1:\n  add    $0x1,%ebx\n  lea    (%rbx,%rbx,2),%eax\n  cmp    %r14d,%eax\n  jle    L3\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  mov    %rdx,(%rsp)\n  call   <__strncpy_chk@plt>\n  mov    (%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    L4\n  jmp    L5\n  nopl   0x0(%rax)\nL2:\n  mov    %dl,0x15(%rsp)\n  mov    $0x3,%edx\n  mov    %cl,0x14(%rsp)\n  mov    %al,0x16(%rsp)\n  jmp    L4\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL6:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4744
        },
        "L1": {
          "label": "L1",
          "addr": 4663
        },
        "L2": {
          "label": "L2",
          "addr": 4720
        },
        "L3": {
          "label": "L3",
          "addr": 4576
        },
        "L4": {
          "label": "L4",
          "addr": 4640
        },
        "L5": {
          "label": "L5",
          "addr": 4597
        },
        "L6": {
          "label": "L6",
          "addr": 4775
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *src, int reverse) {\n  int i;\n  int len = strlen(src);\n  int times = (len + 2) / 3;\n  for (i = 0; i < times; i++) {\n    char buf[4];\n    if (3 * (i + 1) <= len) {\n      strncpy(buf, src + 3 * i, 3);\n      buf[3] = '\\0';\n    } else {\n      __strncpy_chk(buf, src + 3 * i, len - 3 * i, __builtin_strlen(\"\"));\n      buf[len - 3 * i] = '\\0';\n    }\n    if (reverse) {\n      char tmp = buf[0];\n      buf[0] = buf[2];\n      buf[2] = tmp;\n    }\n    strncpy(src + 3 * i, buf, 3);\n  }\n}"
    },
    {
      "task_id": 42,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    111c <func0+0x1c>\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\n  addl   $0x1,(%rdi)\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  jne    1110 <func0+0x10>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\nL1:\n  addl   $0x1,(%rdi)\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  jne    L1\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4380
        },
        "L1": {
          "label": "L1",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *a, int n) {\n  int i;\n  for (i = 0; i < n; ++i)\n    a[i]++;\n}"
    },
    {
      "task_id": 40,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1157 <func0+0x57>\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\n  cmp    %r9,%r10\n  je     1157 <func0+0x57>\n  mov    %r9,%r8\n  cmp    %r8d,%esi\n  jle    1151 <func0+0x51>\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  add    -0x8(%rdi,%r9,4),%edx\n  jmp    1138 <func0+0x38>\n  xchg   %ax,%ax\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1148 <func0+0x48>\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    1130 <func0+0x30>\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\n  add    $0x1,%r8\n  cmp    %r8d,%esi\n  jg     111f <func0+0x1f>\n  add    $0x1,%r9\n  jmp    1112 <func0+0x12>\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\nL6:\n  cmp    %r9,%r10\n  je     L0\n  mov    %r9,%r8\n  cmp    %r8d,%esi\n  jle    L1\nL5:\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  add    -0x8(%rdi,%r9,4),%edx\n  jmp    L2\n  xchg   %ax,%ax\nL4:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L3\nL2:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    L4\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\nL3:\n  add    $0x1,%r8\n  cmp    %r8d,%esi\n  jg     L5\nL1:\n  add    $0x1,%r9\n  jmp    L6\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4439
        },
        "L1": {
          "label": "L1",
          "addr": 4433
        },
        "L2": {
          "label": "L2",
          "addr": 4408
        },
        "L3": {
          "label": "L3",
          "addr": 4424
        },
        "L4": {
          "label": "L4",
          "addr": 4400
        },
        "L5": {
          "label": "L5",
          "addr": 4383
        },
        "L6": {
          "label": "L6",
          "addr": 4370
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int y) {\n  int i, j, k;\n  for (i = 0; i < y; i++)\n    for (j = i + 1; j < y; j++)\n      for (k = j + 1; k < y; k++)\n        if (x[i] + x[j] + x[k] == 0)\n          return 1;\n  return 0;\n}"
    },
    {
      "task_id": 40,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    113a <func0+0x41>\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\n  cmp    %r10,%r9\n  je     1140 <func0+0x47>\n  mov    %r9,%r8\n  cmp    %r8d,%esi\n  jle    114c <func0+0x53>\n  mov    -0x4(%rdi,%r8,4),%edx\n  add    -0x8(%rdi,%r9,4),%edx\n  mov    %r8,%rax\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  je     1146 <func0+0x4d>\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     1125 <func0+0x2c>\n  add    $0x1,%r8\n  jmp    1113 <func0+0x1a>\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  add    $0x1,%r9\n  jmp    110b <func0+0x12>",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\nL6:\n  cmp    %r10,%r9\n  je     L1\n  mov    %r9,%r8\nL5:\n  cmp    %r8d,%esi\n  jle    L2\n  mov    -0x4(%rdi,%r8,4),%edx\n  add    -0x8(%rdi,%r9,4),%edx\n  mov    %r8,%rax\nL4:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  je     L3\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L4\n  add    $0x1,%r8\n  jmp    L5\nL0:\n  mov    $0x0,%eax\n  ret\nL1:\n  mov    $0x0,%eax\n  ret\nL3:\n  mov    $0x1,%eax\n  ret\nL2:\n  add    $0x1,%r9\n  jmp    L6",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4410
        },
        "L1": {
          "label": "L1",
          "addr": 4416
        },
        "L2": {
          "label": "L2",
          "addr": 4428
        },
        "L3": {
          "label": "L3",
          "addr": 4422
        },
        "L4": {
          "label": "L4",
          "addr": 4389
        },
        "L5": {
          "label": "L5",
          "addr": 4371
        },
        "L6": {
          "label": "L6",
          "addr": 4363
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, j, k;\n  for (i = 0; i < len; i++)\n    for (j = i + 1; j < len; j++)\n      for (k = j + 1; k < len; k++)\n        if (arr[i] + arr[j] + arr[k] == 0)\n          return 1;\n  return 0;\n}"
    },
    {
      "task_id": 42,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1118 <func0+0x1f>\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\n  addl   $0x1,(%rax)\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    110c <func0+0x13>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\nL1:\n  addl   $0x1,(%rax)\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    L1\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4376
        },
        "L1": {
          "label": "L1",
          "addr": 4364
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *ary, int size) {\n  int i;\n  for (i = 0; i < size; i++) {\n    ary[i]++;\n  }\n}"
    },
    {
      "task_id": 38,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,0xc(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1090 <strlen@plt>\n  mov    %rax,%r12\n  mov    %eax,0x8(%rsp)\n  lea    0x2(%rax),%eax\n  movslq %eax,%r15\n  imul   $0x55555556,%r15,%r15\n  shr    $0x20,%r15\n  sar    $0x1f,%eax\n  sub    %eax,%r15d\n  test   %r12d,%r12d\n  jle    128b <func0+0x112>\n  mov    $0x0,%ebx\n  lea    0x14(%rsp),%r14\n  jmp    121c <func0+0xa3>\n  movslq %r12d,%r13\n  mov    %rbp,(%rsp)\n  mov    $0x4,%ecx\n  mov    %r13,%rdx\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   10b0 <__strncpy_chk@plt>\n  movb   $0x0,0x14(%rsp,%r13,1)\n  cmp    $0x3,%r12d\n  je     1247 <func0+0xce>\n  mov    %r13,%rdx\n  mov    %r14,%rsi\n  mov    (%rsp),%rdi\n  call   1080 <strncpy@plt>\n  add    $0x3,%rbp\n  sub    $0x3,%r12d\n  cmp    %r15d,%ebx\n  jge    128b <func0+0x112>\n  add    $0x1,%ebx\n  lea    (%rbx,%rbx,2),%eax\n  cmp    %eax,0x8(%rsp)\n  jl     11da <func0+0x61>\n  mov    %rbp,(%rsp)\n  mov    $0x3,%edx\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   1080 <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\n  mov    $0x3,%r13d\n  cmpl   $0x0,0xc(%rsp)\n  je     126b <func0+0xf2>\n  movzbl 0x16(%rsp),%eax\n  movzbl 0x15(%rsp),%edx\n  mov    %dl,0x16(%rsp)\n  movzbl 0x14(%rsp),%edx\n  mov    %dl,0x15(%rsp)\n  mov    %al,0x14(%rsp)\n  jmp    1200 <func0+0x87>\n  movzbl 0x14(%rsp),%eax\n  movzbl 0x15(%rsp),%edx\n  mov    %dl,0x14(%rsp)\n  movzbl 0x16(%rsp),%edx\n  mov    %dl,0x15(%rsp)\n  mov    %al,0x16(%rsp)\n  jmp    1200 <func0+0x87>\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12aa <func0+0x131>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10a0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,0xc(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%r12\n  mov    %eax,0x8(%rsp)\n  lea    0x2(%rax),%eax\n  movslq %eax,%r15\n  imul   $0x55555556,%r15,%r15\n  shr    $0x20,%r15\n  sar    $0x1f,%eax\n  sub    %eax,%r15d\n  test   %r12d,%r12d\n  jle    L0\n  mov    $0x0,%ebx\n  lea    0x14(%rsp),%r14\n  jmp    L1\nL3:\n  movslq %r12d,%r13\n  mov    %rbp,(%rsp)\n  mov    $0x4,%ecx\n  mov    %r13,%rdx\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   <__strncpy_chk@plt>\n  movb   $0x0,0x14(%rsp,%r13,1)\n  cmp    $0x3,%r12d\n  je     L2\nL5:\n  mov    %r13,%rdx\n  mov    %r14,%rsi\n  mov    (%rsp),%rdi\n  call   <strncpy@plt>\n  add    $0x3,%rbp\n  sub    $0x3,%r12d\n  cmp    %r15d,%ebx\n  jge    L0\nL1:\n  add    $0x1,%ebx\n  lea    (%rbx,%rbx,2),%eax\n  cmp    %eax,0x8(%rsp)\n  jl     L3\n  mov    %rbp,(%rsp)\n  mov    $0x3,%edx\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\n  mov    $0x3,%r13d\nL2:\n  cmpl   $0x0,0xc(%rsp)\n  je     L4\n  movzbl 0x16(%rsp),%eax\n  movzbl 0x15(%rsp),%edx\n  mov    %dl,0x16(%rsp)\n  movzbl 0x14(%rsp),%edx\n  mov    %dl,0x15(%rsp)\n  mov    %al,0x14(%rsp)\n  jmp    L5\nL4:\n  movzbl 0x14(%rsp),%eax\n  movzbl 0x15(%rsp),%edx\n  mov    %dl,0x14(%rsp)\n  movzbl 0x16(%rsp),%edx\n  mov    %dl,0x15(%rsp)\n  mov    %al,0x16(%rsp)\n  jmp    L5\nL0:\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL6:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4747
        },
        "L1": {
          "label": "L1",
          "addr": 4636
        },
        "L2": {
          "label": "L2",
          "addr": 4679
        },
        "L3": {
          "label": "L3",
          "addr": 4570
        },
        "L4": {
          "label": "L4",
          "addr": 4715
        },
        "L5": {
          "label": "L5",
          "addr": 4608
        },
        "L6": {
          "label": "L6",
          "addr": 4778
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *src, int flag) {\n  int i;\n  int len = strlen(src);\n  char dst[4];\n  for (i = 0; i < (len + 2) / 3; i++) {\n    int n = len - 3 * i;\n    if (n > 3) {\n      strncpy(dst, src, 3);\n      dst[3] = '\\0';\n    } else {\n      __strncpy_chk(dst, src, n, __builtin_strlen(dst));\n      dst[n] = '\\0';\n    }\n    if (flag) {\n      char tmp = dst[0];\n      dst[0] = dst[1];\n      dst[1] = dst[2];\n      dst[2] = tmp;\n    } else {\n      char tmp = dst[0];\n      dst[0] = dst[2];\n      dst[2] = dst[1];\n      dst[1] = tmp;\n    }\n    strncpy(src, dst, n);\n    src += 3;\n    len -= 3;\n  }\n}"
    },
    {
      "task_id": 42,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1144 <func0+0x4b>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1111 <func0+0x18>\n  nop\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L1\n  nop\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4420
        },
        "L1": {
          "label": "L1",
          "addr": 4369
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n) {\n  int i;\n#pragma omp target teams distribute parallel for simd\n  for (i = 0; i < n; i++)\n    x[i]++;\n}"
    },
    {
      "task_id": 40,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1157 <func0+0x57>\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\n  cmp    %r9,%r10\n  je     1157 <func0+0x57>\n  mov    %r9,%r8\n  cmp    %r8d,%esi\n  jle    1151 <func0+0x51>\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  add    -0x8(%rdi,%r9,4),%edx\n  jmp    1138 <func0+0x38>\n  xchg   %ax,%ax\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1148 <func0+0x48>\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    1130 <func0+0x30>\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\n  add    $0x1,%r8\n  cmp    %r8d,%esi\n  jg     111f <func0+0x1f>\n  add    $0x1,%r9\n  jmp    1112 <func0+0x12>\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\nL6:\n  cmp    %r9,%r10\n  je     L0\n  mov    %r9,%r8\n  cmp    %r8d,%esi\n  jle    L1\nL5:\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  add    -0x8(%rdi,%r9,4),%edx\n  jmp    L2\n  xchg   %ax,%ax\nL4:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L3\nL2:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    L4\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\nL3:\n  add    $0x1,%r8\n  cmp    %r8d,%esi\n  jg     L5\nL1:\n  add    $0x1,%r9\n  jmp    L6\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4439
        },
        "L1": {
          "label": "L1",
          "addr": 4433
        },
        "L2": {
          "label": "L2",
          "addr": 4408
        },
        "L3": {
          "label": "L3",
          "addr": 4424
        },
        "L4": {
          "label": "L4",
          "addr": 4400
        },
        "L5": {
          "label": "L5",
          "addr": 4383
        },
        "L6": {
          "label": "L6",
          "addr": 4370
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int y) {\n  int i, j, k;\n  for (i = 0; i < y; i++)\n    for (j = i + 1; j < y; j++)\n      for (k = j + 1; k < y; k++)\n        if (x[i] + x[j] + x[k] == 0)\n          return 1;\n  return 0;\n}"
    },
    {
      "task_id": 43,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1141 <func0+0x41>\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  cmp    %r9,%r8\n  je     1141 <func0+0x41>\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  jmp    1128 <func0+0x28>\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1138 <func0+0x38>\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\n  add    $0x1,%r8\n  cmp    %r9,%r8\n  jne    1116 <func0+0x16>\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  cmp    %r9,%r8\n  je     L0\nL4:\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  jmp    L1\nL3:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L2\nL1:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    L3\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\nL2:\n  add    $0x1,%r8\n  cmp    %r9,%r8\n  jne    L4\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4417
        },
        "L1": {
          "label": "L1",
          "addr": 4392
        },
        "L2": {
          "label": "L2",
          "addr": 4408
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4374
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, j;\n  for (i = 0; i < len; i++)\n    for (j = i + 1; j < len; j++)\n      if (arr[i] + arr[j] == 0)\n        return 1;\n  return 0;\n}"
    },
    {
      "task_id": 42,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1173 <func0+0x73>\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    1179 <func0+0x79>\n  mov    %esi,%edx\n  movdqa 0xee6(%rip),%xmm1        # 2000 <_fini+0xe80>\n  mov    %rdi,%rax\n  shr    $0x2,%edx\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%rdi,%rdx,1),%rdx\n  nopl   0x0(%rax)\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  paddd  %xmm1,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rdx,%rax\n  jne    1130 <func0+0x30>\n  mov    %esi,%edx\n  and    $0xfffffffc,%edx\n  test   $0x3,%sil\n  je     1178 <func0+0x78>\n  movslq %edx,%rax\n  lea    0x1(%rdx),%ecx\n  shl    $0x2,%rax\n  addl   $0x1,(%rdi,%rax,1)\n  cmp    %ecx,%esi\n  jle    1173 <func0+0x73>\n  add    $0x2,%edx\n  addl   $0x1,0x4(%rdi,%rax,1)\n  cmp    %edx,%esi\n  jle    1173 <func0+0x73>\n  addl   $0x1,0x8(%rdi,%rax,1)\n  ret\n  nopl   0x0(%rax)\n  ret\n  xor    %edx,%edx\n  jmp    1150 <func0+0x50>",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    L1\n  mov    %esi,%edx\n  movdqa D0(%rip),%xmm1\n  mov    %rdi,%rax\n  shr    $0x2,%edx\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%rdi,%rdx,1),%rdx\n  nopl   0x0(%rax)\nL2:\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  paddd  %xmm1,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rdx,%rax\n  jne    L2\n  mov    %esi,%edx\n  and    $0xfffffffc,%edx\n  test   $0x3,%sil\n  je     L3\nL4:\n  movslq %edx,%rax\n  lea    0x1(%rdx),%ecx\n  shl    $0x2,%rax\n  addl   $0x1,(%rdi,%rax,1)\n  cmp    %ecx,%esi\n  jle    L0\n  add    $0x2,%edx\n  addl   $0x1,0x4(%rdi,%rax,1)\n  cmp    %edx,%esi\n  jle    L0\n  addl   $0x1,0x8(%rdi,%rax,1)\nL0:\n  ret\n  nopl   0x0(%rax)\nL3:\n  ret\nL1:\n  xor    %edx,%edx\n  jmp    L4",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3814
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4467
        },
        "L1": {
          "label": "L1",
          "addr": 4473
        },
        "L2": {
          "label": "L2",
          "addr": 4400
        },
        "L3": {
          "label": "L3",
          "addr": 4472
        },
        "L4": {
          "label": "L4",
          "addr": 4432
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "01000000010000000100000001000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *ary, int size) {\n  int i;\n  for (i = 0; i < size; ++i)\n    ary[i] += 1;\n}"
    },
    {
      "task_id": 43,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    112c <func0+0x33>\n  mov    %esi,%r9d\n  mov    $0x1,%r8d\n  cmp    %r9,%r8\n  je     1132 <func0+0x39>\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  je     1138 <func0+0x3f>\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     1117 <func0+0x1e>\n  add    $0x1,%r8\n  jmp    110a <func0+0x11>\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%r9d\n  mov    $0x1,%r8d\nL4:\n  cmp    %r9,%r8\n  je     L1\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\nL3:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  je     L2\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L3\n  add    $0x1,%r8\n  jmp    L4\nL0:\n  mov    $0x0,%eax\n  ret\nL1:\n  mov    $0x0,%eax\n  ret\nL2:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4396
        },
        "L1": {
          "label": "L1",
          "addr": 4402
        },
        "L2": {
          "label": "L2",
          "addr": 4408
        },
        "L3": {
          "label": "L3",
          "addr": 4375
        },
        "L4": {
          "label": "L4",
          "addr": 4362
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, j;\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      if (arr[i] + arr[j] == 0)\n        return 1;\n    }\n  }\n  return 0;\n}"
    },
    {
      "task_id": 38,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %esi,%r15d\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1090 <strlen@plt>\n  mov    %rax,%rbp\n  mov    %eax,%r13d\n  add    $0x2,%eax\n  movslq %eax,%r12\n  sar    $0x1f,%eax\n  imul   $0x55555556,%r12,%r12\n  shr    $0x20,%r12\n  sub    %eax,%r12d\n  test   %ebp,%ebp\n  jle    1268 <func0+0xe8>\n  test   %r15d,%r15d\n  jne    1290 <func0+0x110>\n  lea    0x14(%rsp),%r14\n  jmp    122c <func0+0xac>\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x3,%edx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  call   1080 <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\n  movzbl 0x14(%rsp),%eax\n  movzwl 0x15(%rsp),%edx\n  mov    %al,0x16(%rsp)\n  mov    %dx,0x14(%rsp)\n  mov    $0x3,%edx\n  mov    %rbx,%rdi\n  mov    %r14,%rsi\n  add    $0x3,%rbx\n  sub    $0x3,%ebp\n  call   1080 <strncpy@plt>\n  cmp    %r15d,%r12d\n  jle    1268 <func0+0xe8>\n  add    $0x1,%r15d\n  lea    (%r15,%r15,2),%eax\n  cmp    %eax,%r13d\n  jge    11e8 <func0+0x68>\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  call   10b0 <__strncpy_chk@plt>\n  mov    0x8(%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    1215 <func0+0x95>\n  jmp    11fd <func0+0x7d>\n  nopw   0x0(%rax,%rax,1)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1323 <func0+0x1a3>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %r15d,%r15d\n  lea    0x14(%rsp),%r14\n  jmp    12ed <func0+0x16d>\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x3,%edx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  call   1080 <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\n  xor    %eax,%eax\n  mov    0x16(%rsp),%al\n  mov    0x14(%rsp),%ah\n  movzbl 0x15(%rsp),%edx\n  mov    %ax,0x14(%rsp)\n  mov    %dl,0x16(%rsp)\n  mov    $0x3,%edx\n  mov    %rbx,%rdi\n  mov    %r14,%rsi\n  add    $0x3,%rbx\n  sub    $0x3,%ebp\n  call   1080 <strncpy@plt>\n  cmp    %r12d,%r15d\n  jge    1268 <func0+0xe8>\n  add    $0x1,%r15d\n  lea    (%r15,%r15,2),%eax\n  cmp    %eax,%r13d\n  jge    12a0 <func0+0x120>\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  call   10b0 <__strncpy_chk@plt>\n  mov    0x8(%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    12d2 <func0+0x152>\n  jmp    12b5 <func0+0x135>\n  call   10a0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %esi,%r15d\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  mov    %eax,%r13d\n  add    $0x2,%eax\n  movslq %eax,%r12\n  sar    $0x1f,%eax\n  imul   $0x55555556,%r12,%r12\n  shr    $0x20,%r12\n  sub    %eax,%r12d\n  test   %ebp,%ebp\n  jle    L0\n  test   %r15d,%r15d\n  jne    L1\n  lea    0x14(%rsp),%r14\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL3:\n  mov    $0x3,%edx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\nL5:\n  movzbl 0x14(%rsp),%eax\n  movzwl 0x15(%rsp),%edx\n  mov    %al,0x16(%rsp)\n  mov    %dx,0x14(%rsp)\n  mov    $0x3,%edx\nL4:\n  mov    %rbx,%rdi\n  mov    %r14,%rsi\n  add    $0x3,%rbx\n  sub    $0x3,%ebp\n  call   <strncpy@plt>\n  cmp    %r15d,%r12d\n  jle    L0\nL2:\n  add    $0x1,%r15d\n  lea    (%r15,%r15,2),%eax\n  cmp    %eax,%r13d\n  jge    L3\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  call   <__strncpy_chk@plt>\n  mov    0x8(%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    L4\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %r15d,%r15d\n  lea    0x14(%rsp),%r14\n  jmp    L7\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    $0x3,%edx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\nL10:\n  xor    %eax,%eax\n  mov    0x16(%rsp),%al\n  mov    0x14(%rsp),%ah\n  movzbl 0x15(%rsp),%edx\n  mov    %ax,0x14(%rsp)\n  mov    %dl,0x16(%rsp)\n  mov    $0x3,%edx\nL9:\n  mov    %rbx,%rdi\n  mov    %r14,%rsi\n  add    $0x3,%rbx\n  sub    $0x3,%ebp\n  call   <strncpy@plt>\n  cmp    %r12d,%r15d\n  jge    L0\nL7:\n  add    $0x1,%r15d\n  lea    (%r15,%r15,2),%eax\n  cmp    %eax,%r13d\n  jge    L8\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  call   <__strncpy_chk@plt>\n  mov    0x8(%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    L9\n  jmp    L10\nL6:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4712
        },
        "L1": {
          "label": "L1",
          "addr": 4752
        },
        "L2": {
          "label": "L2",
          "addr": 4652
        },
        "L3": {
          "label": "L3",
          "addr": 4584
        },
        "L4": {
          "label": "L4",
          "addr": 4629
        },
        "L5": {
          "label": "L5",
          "addr": 4605
        },
        "L6": {
          "label": "L6",
          "addr": 4899
        },
        "L7": {
          "label": "L7",
          "addr": 4845
        },
        "L8": {
          "label": "L8",
          "addr": 4768
        },
        "L9": {
          "label": "L9",
          "addr": 4818
        },
        "L10": {
          "label": "L10",
          "addr": 4789
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " void func0(char *a0, int a1) {\n  char c[4];\n  int i, len, n;\n  len = __builtin_strlen(a0);\n  n = (len + 2) / 3;\n  for (i = 0; i < len; i += 3) {\n    if (i + 3 > len) {\n      __builtin_strncpy_chk(c, a0 + i, len - i, __builtin_strlen(c));\n      c[len - i] = 0;\n      if (len - i == 3) {\n        c[1] = c[0];\n        c[0] = c[2];\n        c[2] = 0;\n      }\n    } else {\n      __builtin_strncpy(c, a0 + i, 3);\n      c[3] = 0;\n    }\n    __builtin_strncpy(a0 + i, c, 3);\n    if (a1 == 0) {\n      c[2] = c[0];\n      c[0] = c[1];\n      c[1] = c[2];\n    }\n    if (i >= n)\n      break;\n  }\n}"
    },
    {
      "task_id": 43,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1165 <func0+0x6c>\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    1159 <func0+0x60>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  test   %eax,%eax\n  jne    1155 <func0+0x5c>\n  mov    $0x1,%eax\n  jmp    1172 <func0+0x79>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111c <func0+0x23>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1111 <func0+0x18>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL5:\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    L1\nL4:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  test   %eax,%eax\n  jne    L2\n  mov    $0x1,%eax\n  jmp    L3\nL2:\n  addl   $0x1,-0x4(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    $0x0,%eax\nL3:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4453
        },
        "L1": {
          "label": "L1",
          "addr": 4441
        },
        "L2": {
          "label": "L2",
          "addr": 4437
        },
        "L3": {
          "label": "L3",
          "addr": 4466
        },
        "L4": {
          "label": "L4",
          "addr": 4380
        },
        "L5": {
          "label": "L5",
          "addr": 4369
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int n) {\n  int i, j;\n  for (i = 0; i < n; i++) {\n    for (j = i + 1; j < n; j++) {\n      if (arr[i] + arr[j] == 0) {\n        return 1;\n      }\n    }\n  }\n  return 0;\n}"
    },
    {
      "task_id": 43,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1141 <func0+0x41>\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  cmp    %r8,%r9\n  je     1141 <func0+0x41>\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  jmp    1128 <func0+0x28>\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1138 <func0+0x38>\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\n  add    $0x1,%r8\n  cmp    %r8,%r9\n  jne    1116 <func0+0x16>\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  cmp    %r8,%r9\n  je     L0\nL4:\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  jmp    L1\nL3:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L2\nL1:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    L3\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\nL2:\n  add    $0x1,%r8\n  cmp    %r8,%r9\n  jne    L4\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4417
        },
        "L1": {
          "label": "L1",
          "addr": 4392
        },
        "L2": {
          "label": "L2",
          "addr": 4408
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4374
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, j;\n  for (i = 0; i < len; i++)\n    for (j = i + 1; j < len; j++)\n      if (arr[i] + arr[j] == 0)\n        return 1;\n  return 0;\n}"
    },
    {
      "task_id": 45,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  -0x8(%rbp),%xmm1\n  movss  0xee0(%rip),%xmm0        # 2000 <_fini+0xed8>\n  mulss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  -0x8(%rbp),%xmm1\n  movss  D0(%rip),%xmm0\n  mulss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3808
          ]
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000003f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f32",
            "value": 0.5
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float x, float y) {\n  float a = 0.5;\n  return a * x * y;\n}"
    },
    {
      "task_id": 45,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  0xef7(%rip),%xmm0        # 2000 <_fini+0xef4>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  D0(%rip),%xmm0\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3831
          ]
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000003f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f32",
            "value": 0.5
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float a, float b) {\n  float c = a * b;\n  return c / 2.0f;\n}"
    },
    {
      "task_id": 44,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rdx\n  mov    %rdx,0x28(%rsp)\n  xor    %edx,%edx\n  test   %edi,%edi\n  jle    1196 <func0+0x76>\n  mov    %edi,%eax\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r8\n  nopl   0x0(%rax,%rax,1)\n  cltd\n  mov    %ecx,%edi\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rcx,1)\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     1150 <func0+0x30>\n  mov    %rsp,%rax\n  movslq %edi,%r8\n  lea    -0x1(%rdi),%ecx\n  lea    -0x1(%rax,%r8,1),%rdx\n  lea    0x1(%r9,%rcx,1),%rsi\n  mov    %r9,%rax\n  nopw   0x0(%rax,%rax,1)\n  movzbl (%rdx),%ecx\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  mov    %cl,-0x1(%rax)\n  cmp    %rax,%rsi\n  jne    1180 <func0+0x60>\n  add    %r8,%r9\n  movb   $0x0,(%r9)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11af <func0+0x8f>\n  add    $0x38,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rdx\n  mov    %rdx,0x28(%rsp)\n  xor    %edx,%edx\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%eax\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r8\n  nopl   0x0(%rax,%rax,1)\nL1:\n  cltd\n  mov    %ecx,%edi\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rcx,1)\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     L1\n  mov    %rsp,%rax\n  movslq %edi,%r8\n  lea    -0x1(%rdi),%ecx\n  lea    -0x1(%rax,%r8,1),%rdx\n  lea    0x1(%r9,%rcx,1),%rsi\n  mov    %r9,%rax\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movzbl (%rdx),%ecx\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  mov    %cl,-0x1(%rax)\n  cmp    %rax,%rsi\n  jne    L2\n  add    %r8,%r9\nL0:\n  movb   $0x0,(%r9)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  add    $0x38,%rsp\n  ret\nL3:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4502
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        },
        "L2": {
          "label": "L2",
          "addr": 4480
        },
        "L3": {
          "label": "L3",
          "addr": 4527
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b, char *c) {\n  char d[32];\n  int i = 0;\n  while (a > 0) {\n    d[i++] = a % b + '0';\n    a /= b;\n  }\n  while (i > 0)\n    *c++ = d[--i];\n  *c = 0;\n}"
    },
    {
      "task_id": 45,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  0xef0(%rip),%xmm0        # 2000 <_fini+0xeec>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  D0(%rip),%xmm0\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3824
          ]
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000003f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f32",
            "value": 0.5
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float a, float b) {\n  float c = a * b;\n  return c / 2.0f;\n}"
    },
    {
      "task_id": 44,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rdx\n  mov    %rdx,0x28(%rsp)\n  xor    %edx,%edx\n  test   %edi,%edi\n  jle    1196 <func0+0x76>\n  mov    %edi,%eax\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r8\n  nopl   0x0(%rax,%rax,1)\n  cltd\n  mov    %ecx,%edi\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rcx,1)\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     1150 <func0+0x30>\n  movslq %edi,%r8\n  lea    -0x1(%rdi),%esi\n  mov    %r9,%rax\n  lea    (%rsp,%r8,1),%rcx\n  add    %r9,%rsi\n  jmp    1188 <func0+0x68>\n  cs nopw 0x0(%rax,%rax,1)\n  movzbl -0x1(%rcx),%edx\n  add    $0x1,%rax\n  mov    %dl,(%rax)\n  sub    $0x1,%rcx\n  cmp    %rsi,%rax\n  jne    1180 <func0+0x60>\n  add    %r8,%r9\n  movb   $0x0,(%r9)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11af <func0+0x8f>\n  add    $0x38,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rdx\n  mov    %rdx,0x28(%rsp)\n  xor    %edx,%edx\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%eax\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r8\n  nopl   0x0(%rax,%rax,1)\nL1:\n  cltd\n  mov    %ecx,%edi\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rcx,1)\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     L1\n  movslq %edi,%r8\n  lea    -0x1(%rdi),%esi\n  mov    %r9,%rax\n  lea    (%rsp,%r8,1),%rcx\n  add    %r9,%rsi\n  jmp    L2\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  movzbl -0x1(%rcx),%edx\n  add    $0x1,%rax\nL2:\n  mov    %dl,(%rax)\n  sub    $0x1,%rcx\n  cmp    %rsi,%rax\n  jne    L3\n  add    %r8,%r9\nL0:\n  movb   $0x0,(%r9)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L4\n  add    $0x38,%rsp\n  ret\nL4:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4502
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        },
        "L2": {
          "label": "L2",
          "addr": 4488
        },
        "L3": {
          "label": "L3",
          "addr": 4480
        },
        "L4": {
          "label": "L4",
          "addr": 4527
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int n, int r, char *p) {\n  char a[32];\n  int i;\n  for (i = 0; n > 0; i++) {\n    a[i] = n % r + '0';\n    n /= r;\n  }\n  for (i--; i >= 0; i--)\n    *p++ = a[i];\n  *p = '\\0';\n}"
    },
    {
      "task_id": 44,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %edi,-0x44(%rbp)\n  mov    %esi,-0x48(%rbp)\n  mov    %rdx,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x38(%rbp)\n  jmp    116e <func0+0x55>\n  mov    -0x44(%rbp),%eax\n  cltd\n  idivl  -0x48(%rbp)\n  mov    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  mov    %ecx,%edx\n  cltq\n  mov    %dl,-0x30(%rbp,%rax,1)\n  mov    -0x44(%rbp),%eax\n  cltd\n  idivl  -0x48(%rbp)\n  mov    %eax,-0x44(%rbp)\n  cmpl   $0x0,-0x44(%rbp)\n  jg     1147 <func0+0x2e>\n  movl   $0x0,-0x34(%rbp)\n  jmp    11a0 <func0+0x87>\n  subl   $0x1,-0x38(%rbp)\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movslq %eax,%rdx\n  mov    -0x50(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%eax\n  cltq\n  movzbl -0x30(%rbp,%rax,1),%eax\n  mov    %al,(%rdx)\n  cmpl   $0x0,-0x38(%rbp)\n  jg     117d <func0+0x64>\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x50(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     11cb <func0+0xb2>\n  call   1050 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %edi,-0x44(%rbp)\n  mov    %esi,-0x48(%rbp)\n  mov    %rdx,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x38(%rbp)\n  jmp    L0\nL1:\n  mov    -0x44(%rbp),%eax\n  cltd\n  idivl  -0x48(%rbp)\n  mov    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  mov    %ecx,%edx\n  cltq\n  mov    %dl,-0x30(%rbp,%rax,1)\n  mov    -0x44(%rbp),%eax\n  cltd\n  idivl  -0x48(%rbp)\n  mov    %eax,-0x44(%rbp)\nL0:\n  cmpl   $0x0,-0x44(%rbp)\n  jg     L1\n  movl   $0x0,-0x34(%rbp)\n  jmp    L2\nL3:\n  subl   $0x1,-0x38(%rbp)\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movslq %eax,%rdx\n  mov    -0x50(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%eax\n  cltq\n  movzbl -0x30(%rbp,%rax,1),%eax\n  mov    %al,(%rdx)\nL2:\n  cmpl   $0x0,-0x38(%rbp)\n  jg     L3\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x50(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     L4\n  call   <__stack_chk_fail@plt>\nL4:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4462
        },
        "L1": {
          "label": "L1",
          "addr": 4423
        },
        "L2": {
          "label": "L2",
          "addr": 4512
        },
        "L3": {
          "label": "L3",
          "addr": 4477
        },
        "L4": {
          "label": "L4",
          "addr": 4555
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b, char *c) {\n  char s[32];\n  int i = 0;\n  while (a > 0) {\n    s[i++] = a % b + '0';\n    a /= b;\n  }\n  int j = 0;\n  while (i > 0) {\n    c[j++] = s[--i];\n  }\n  c[j] = 0;\n}"
    },
    {
      "task_id": 32,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movsd  (%rdi),%xmm7\n  mov    %rdi,%r8\n  mov    %esi,%r9d\n  cmp    $0x1,%esi\n  jle    1279 <func0+0x179>\n  movslq %esi,%rcx\n  movapd %xmm7,%xmm3\n  pxor   %xmm6,%xmm6\n  mov    $0x1,%edx\n  movsd  0xed1(%rip),%xmm1        # 2000 <_fini+0xd78>\n  nop\n  xor    %eax,%eax\n  movapd %xmm1,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\n  mulsd  %xmm6,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    1140 <func0+0x40>\n  mulsd  (%r8,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%rcx\n  jne    1130 <func0+0x30>\n  movq   0xea9(%rip),%xmm9        # 2010 <_fini+0xd88>\n  movapd %xmm3,%xmm0\n  movapd %xmm6,%xmm1\n  movsd  0xe90(%rip),%xmm8        # 2008 <_fini+0xd80>\n  movsd  0xe80(%rip),%xmm5        # 2000 <_fini+0xd78>\n  movslq %r9d,%r10\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  jbe    1252 <func0+0x152>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x1,%r9d\n  jle    1257 <func0+0x157>\n  lea    0x8(%r8),%rdi\n  movapd %xmm6,%xmm4\n  mov    $0x1,%ecx\n  movapd %xmm5,%xmm0\n  nopl   0x0(%rax,%rax,1)\n  pxor   %xmm2,%xmm2\n  lea    0x1(%rcx),%esi\n  cvtsi2sd %ecx,%xmm2\n  mulsd  (%rdi),%xmm2\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  cmp    %esi,%r9d\n  je     11f8 <func0+0xf8>\n  mov    $0x1,%eax\n  movapd %xmm5,%xmm0\n  nopl   (%rax)\n  mulsd  %xmm1,%xmm0\n  mov    %eax,%edx\n  add    $0x1,%eax\n  cmp    %ecx,%edx\n  jne    11e0 <func0+0xe0>\n  add    $0x8,%rdi\n  mov    %esi,%ecx\n  jmp    11b8 <func0+0xb8>\n  nopl   (%rax)\n  divsd  %xmm4,%xmm3\n  mov    $0x1,%edx\n  subsd  %xmm3,%xmm1\n  movapd %xmm7,%xmm3\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    1220 <func0+0x120>\n  mulsd  (%r8,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%r10\n  jne    1210 <func0+0x110>\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     1198 <func0+0x98>\n  movapd %xmm1,%xmm0\n  ret\n  divsd  %xmm6,%xmm3\n  subsd  %xmm3,%xmm1\n  movapd %xmm7,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     1198 <func0+0x98>\n  jmp    1252 <func0+0x152>\n  movapd %xmm7,%xmm3\n  pxor   %xmm6,%xmm6\n  jmp    115e <func0+0x5e>",
      "asm_labeled": "<func0>:\n  endbr64\n  movsd  (%rdi),%xmm7\n  mov    %rdi,%r8\n  mov    %esi,%r9d\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rcx\n  movapd %xmm7,%xmm3\n  pxor   %xmm6,%xmm6\n  mov    $0x1,%edx\n  movsd  D0(%rip),%xmm1\n  nop\nL2:\n  xor    %eax,%eax\n  movapd %xmm1,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  mulsd  %xmm6,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L1\n  mulsd  (%r8,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%rcx\n  jne    L2\nL11:\n  movq   D1(%rip),%xmm9\n  movapd %xmm3,%xmm0\n  movapd %xmm6,%xmm1\n  movsd  D2(%rip),%xmm8\n  movsd  D0(%rip),%xmm5\n  movslq %r9d,%r10\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  jbe    L3\n  nopl   0x0(%rax,%rax,1)\nL10:\n  cmp    $0x1,%r9d\n  jle    L4\n  lea    0x8(%r8),%rdi\n  movapd %xmm6,%xmm4\n  mov    $0x1,%ecx\n  movapd %xmm5,%xmm0\n  nopl   0x0(%rax,%rax,1)\nL7:\n  pxor   %xmm2,%xmm2\n  lea    0x1(%rcx),%esi\n  cvtsi2sd %ecx,%xmm2\n  mulsd  (%rdi),%xmm2\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  cmp    %esi,%r9d\n  je     L5\n  mov    $0x1,%eax\n  movapd %xmm5,%xmm0\n  nopl   (%rax)\nL6:\n  mulsd  %xmm1,%xmm0\n  mov    %eax,%edx\n  add    $0x1,%eax\n  cmp    %ecx,%edx\n  jne    L6\n  add    $0x8,%rdi\n  mov    %esi,%ecx\n  jmp    L7\n  nopl   (%rax)\nL5:\n  divsd  %xmm4,%xmm3\n  mov    $0x1,%edx\n  subsd  %xmm3,%xmm1\n  movapd %xmm7,%xmm3\n  nopl   0x0(%rax)\nL9:\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\nL8:\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L8\n  mulsd  (%r8,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%r10\n  jne    L9\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     L10\nL3:\n  movapd %xmm1,%xmm0\n  ret\nL4:\n  divsd  %xmm6,%xmm3\n  subsd  %xmm3,%xmm1\n  movapd %xmm7,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     L10\n  jmp    L3\nL0:\n  movapd %xmm7,%xmm3\n  pxor   %xmm6,%xmm6\n  jmp    L11",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3793,
            3712
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3753
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3728
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4729
        },
        "L1": {
          "label": "L1",
          "addr": 4416
        },
        "L2": {
          "label": "L2",
          "addr": 4400
        },
        "L3": {
          "label": "L3",
          "addr": 4690
        },
        "L4": {
          "label": "L4",
          "addr": 4695
        },
        "L5": {
          "label": "L5",
          "addr": 4600
        },
        "L6": {
          "label": "L6",
          "addr": 4576
        },
        "L7": {
          "label": "L7",
          "addr": 4536
        },
        "L8": {
          "label": "L8",
          "addr": 4640
        },
        "L9": {
          "label": "L9",
          "addr": 4624
        },
        "L10": {
          "label": "L10",
          "addr": 4504
        },
        "L11": {
          "label": "L11",
          "addr": 4446
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000000000000f03f8dedb5a0f7c6b03effffffffffffff7f0000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f64",
            "value": 1.0
          },
          "0x2010": {
            "type": "qword",
            "value": 9223372036854775807
          },
          "0x2008": {
            "type": "byte[8]",
            "value": [
              141,
              237,
              181,
              160,
              247,
              198,
              176,
              62
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " double func0(double *x, int n) {\n  double f, fp, fpp, t, t0, t1, t2, t3, t4, t5, t6, t7, t8, t9;\n  int i, j, k;\n  f = x[0];\n  t0 = 1.0;\n  t1 = 0.0;\n  for (i = 1; i < n; i++) {\n    t2 = t0;\n    t3 = t1;\n    t4 = i;\n    t5 = 1;\n    for (j = 0; j < i; j++) {\n      t6 = t5;\n      t7 = t3;\n      t8 = t2;\n      t9 = t8 * t7;\n      t1 = t1 + t9 * x[i];\n      t5 = t6 * t4;\n    }\n    t0 = t2 * t5;\n  }\n  fp = t0;\n  if (fabs(fp) > 1.0e-12) {\n    t0 = 1.0;\n    t1 = 0.0;\n    for (i = 1; i < n; i++) {\n      t2 = t0;\n      t3 = t1;\n      t4 = i;\n      t5 = 1;\n      for (j = 0; j < i; j++) {\n        t6 = t5;\n        t7 = t3;\n        t8 = t2;\n        t9 = t8 * t7;\n        t1 = t1 + t9 * x[i];\n        t5 = t6 * t4;\n      }\n      t0 = t2 * t5;\n    }\n    fpp = t0;\n    t = fp / fpp;\n    t0 = 1.0;\n    t1 = t - t;\n    for (i = 1; i < n; i++) {\n      t2 = t0;\n      t3 = t1;\n      t4 = i;\n      t5 = 1;\n      for (j = 0; j < i; j++) {\n        t6 = t5;\n        t7 = t3;\n        t8 = t2;\n        t9 = t8 * t7;\n        t1 = t1 + t9 * x[i];\n        t5 = t6 * t4;\n      }\n      t0 = t2 * t5;\n    }\n    f = t0;\n  }\n  return f;\n}"
    },
    {
      "task_id": 45,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  0xef0(%rip),%xmm0        # 2000 <_fini+0xeec>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  D0(%rip),%xmm0\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3824
          ]
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000003f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f32",
            "value": 0.5
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float a, float b) {\n  float c = a * b;\n  return c / 2.0f;\n}"
    },
    {
      "task_id": 44,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    11a6 <func0+0x8d>\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r11\n  mov    %ecx,%r8d\n  mov    %edi,%eax\n  cltd\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r11,%rcx,1)\n  mov    %eax,%edi\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     1142 <func0+0x29>\n  test   %r8d,%r8d\n  jle    11ae <func0+0x95>\n  movslq %r8d,%rcx\n  lea    (%rsp,%rcx,1),%rax\n  mov    %r9,%rdx\n  lea    -0x1(%rsp,%rcx,1),%rsi\n  lea    -0x1(%r8),%ecx\n  sub    %rcx,%rsi\n  movzbl -0x1(%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    1176 <func0+0x5d>\n  movslq %r8d,%r8\n  movb   $0x0,(%r9,%r8,1)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11b6 <func0+0x9d>\n  add    $0x38,%rsp\n  ret\n  mov    $0x0,%r8d\n  jmp    1189 <func0+0x70>\n  mov    $0x0,%r8d\n  jmp    1189 <func0+0x70>\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    L0\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r11\nL1:\n  mov    %ecx,%r8d\n  mov    %edi,%eax\n  cltd\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r11,%rcx,1)\n  mov    %eax,%edi\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     L1\n  test   %r8d,%r8d\n  jle    L2\n  movslq %r8d,%rcx\n  lea    (%rsp,%rcx,1),%rax\n  mov    %r9,%rdx\n  lea    -0x1(%rsp,%rcx,1),%rsi\n  lea    -0x1(%r8),%ecx\n  sub    %rcx,%rsi\nL3:\n  movzbl -0x1(%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    L3\nL5:\n  movslq %r8d,%r8\n  movb   $0x0,(%r9,%r8,1)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L4\n  add    $0x38,%rsp\n  ret\nL0:\n  mov    $0x0,%r8d\n  jmp    L5\nL2:\n  mov    $0x0,%r8d\n  jmp    L5\nL4:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4518
        },
        "L1": {
          "label": "L1",
          "addr": 4418
        },
        "L2": {
          "label": "L2",
          "addr": 4526
        },
        "L3": {
          "label": "L3",
          "addr": 4470
        },
        "L4": {
          "label": "L4",
          "addr": 4534
        },
        "L5": {
          "label": "L5",
          "addr": 4489
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b, char *c) {\n  char d[32];\n  int i = 0;\n  while (a > 0) {\n    d[i] = a % b + '0';\n    a = a / b;\n    i++;\n  }\n  int j = 0;\n  while (i > 0) {\n    c[j] = d[i - 1];\n    i--;\n    j++;\n  }\n  c[j] = '\\0';\n}"
    },
    {
      "task_id": 46,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x1c0,%rsp\n  mov    %edi,-0x1b4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x1a0(%rbp)\n  movl   $0x0,-0x19c(%rbp)\n  movl   $0x2,-0x198(%rbp)\n  movl   $0x0,-0x194(%rbp)\n  movl   $0x4,-0x1a4(%rbp)\n  jmp    11d5 <func0+0xbc>\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x3,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x4,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  cltq\n  mov    %edx,-0x1a0(%rbp,%rax,4)\n  addl   $0x1,-0x1a4(%rbp)\n  mov    -0x1a4(%rbp),%eax\n  cmp    -0x1b4(%rbp),%eax\n  jle    1171 <func0+0x58>\n  mov    -0x1b4(%rbp),%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     1206 <func0+0xed>\n  call   1050 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x1c0,%rsp\n  mov    %edi,-0x1b4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x1a0(%rbp)\n  movl   $0x0,-0x19c(%rbp)\n  movl   $0x2,-0x198(%rbp)\n  movl   $0x0,-0x194(%rbp)\n  movl   $0x4,-0x1a4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x3,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x4,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  cltq\n  mov    %edx,-0x1a0(%rbp,%rax,4)\n  addl   $0x1,-0x1a4(%rbp)\nL0:\n  mov    -0x1a4(%rbp),%eax\n  cmp    -0x1b4(%rbp),%eax\n  jle    L1\n  mov    -0x1b4(%rbp),%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L2\n  call   <__stack_chk_fail@plt>\nL2:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4565
        },
        "L1": {
          "label": "L1",
          "addr": 4465
        },
        "L2": {
          "label": "L2",
          "addr": 4614
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[100];\n  arr[0] = 0;\n  arr[1] = 0;\n  arr[2] = 2;\n  arr[3] = 0;\n  int i;\n  for (i = 4; i <= n; i++)\n    arr[i] = arr[i - 1] + arr[i - 2] + arr[i - 3] + arr[i - 4];\n  return arr[n];\n}"
    },
    {
      "task_id": 46,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,(%rsp)\n  movq   $0x2,0x8(%rsp)\n  cmp    $0x3,%edi\n  jle    118f <func0+0x6f>\n  lea    -0x4(%rdi),%eax\n  lea    0x4(%rsp),%rdx\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  lea    0x8(%rsp,%rax,4),%r9\n  mov    $0x2,%ecx\n  xor    %eax,%eax\n  jmp    117c <func0+0x5c>\n  nop\n  mov    0x8(%rdx),%eax\n  mov    0x4(%rdx),%ecx\n  mov    (%rdx),%esi\n  mov    -0x4(%rdx),%r8d\n  add    %ecx,%eax\n  add    $0x4,%rdx\n  add    %esi,%eax\n  add    %r8d,%eax\n  mov    %eax,0x8(%rdx)\n  cmp    %rdx,%r9\n  jne    1170 <func0+0x50>\n  movslq %edi,%rdi\n  mov    (%rsp,%rdi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    11b0 <func0+0x90>\n  add    $0x1a8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,(%rsp)\n  movq   $0x2,0x8(%rsp)\n  cmp    $0x3,%edi\n  jle    L0\n  lea    -0x4(%rdi),%eax\n  lea    0x4(%rsp),%rdx\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  lea    0x8(%rsp,%rax,4),%r9\n  mov    $0x2,%ecx\n  xor    %eax,%eax\n  jmp    L1\n  nop\nL2:\n  mov    0x8(%rdx),%eax\n  mov    0x4(%rdx),%ecx\n  mov    (%rdx),%esi\n  mov    -0x4(%rdx),%r8d\nL1:\n  add    %ecx,%eax\n  add    $0x4,%rdx\n  add    %esi,%eax\n  add    %r8d,%eax\n  mov    %eax,0x8(%rdx)\n  cmp    %rdx,%r9\n  jne    L2\nL0:\n  movslq %edi,%rdi\n  mov    (%rsp,%rdi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L3\n  add    $0x1a8,%rsp\n  ret\nL3:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4495
        },
        "L1": {
          "label": "L1",
          "addr": 4476
        },
        "L2": {
          "label": "L2",
          "addr": 4464
        },
        "L3": {
          "label": "L3",
          "addr": 4528
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[100];\n  int i;\n  arr[0] = 0;\n  arr[1] = 2;\n  for (i = 2; i < n; i++)\n    arr[i] = arr[i - 1] + arr[i - 2] + arr[i - 3] + arr[i - 4];\n  return arr[n];\n}"
    },
    {
      "task_id": 49,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1127 <func0+0x2e>\n  mov    -0x8(%rbp),%eax\n  add    %eax,%eax\n  cltd\n  idivl  -0x18(%rbp)\n  mov    %edx,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     1117 <func0+0x1e>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x8(%rbp),%eax\n  add    %eax,%eax\n  cltd\n  idivl  -0x18(%rbp)\n  mov    %edx,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L1\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4391
        },
        "L1": {
          "label": "L1",
          "addr": 4375
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n, int p) {\n  int i, ret = 1;\n  for (i = 0; i < n; i++)\n    ret = (ret * 2) % p;\n  return ret;\n}"
    },
    {
      "task_id": 48,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1176 <func0+0x5d>\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x8(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     1172 <func0+0x59>\n  mov    $0x0,%eax\n  jmp    118c <func0+0x73>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x8(%rbp)\n  jl     1141 <func0+0x28>\n  mov    $0x1,%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL3:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x8(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     L1\n  mov    $0x0,%eax\n  jmp    L2\nL1:\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x8(%rbp)\n  jl     L3\n  mov    $0x1,%eax\nL2:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4470
        },
        "L1": {
          "label": "L1",
          "addr": 4466
        },
        "L2": {
          "label": "L2",
          "addr": 4492
        },
        "L3": {
          "label": "L3",
          "addr": 4417
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str) {\n  int i;\n  int len = strlen(str);\n  for (i = 0; i < len / 2; i++) {\n    if (str[i] != str[len - 1 - i]) {\n      return 0;\n    }\n  }\n  return 1;\n}"
    },
    {
      "task_id": 46,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movl   $0x0,(%rsp)\n  movl   $0x0,0x4(%rsp)\n  movl   $0x2,0x8(%rsp)\n  movl   $0x0,0xc(%rsp)\n  cmp    $0x3,%edi\n  jle    117d <func0+0x64>\n  mov    %rsp,%rax\n  lea    -0x4(%rdi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\n  mov    0x8(%rax),%edx\n  add    0xc(%rax),%edx\n  add    0x4(%rax),%edx\n  add    (%rax),%edx\n  mov    %edx,0x10(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    1166 <func0+0x4d>\n  movslq %edi,%rdi\n  mov    (%rsp,%rdi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    119e <func0+0x85>\n  add    $0x1a8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movl   $0x0,(%rsp)\n  movl   $0x0,0x4(%rsp)\n  movl   $0x2,0x8(%rsp)\n  movl   $0x0,0xc(%rsp)\n  cmp    $0x3,%edi\n  jle    L0\n  mov    %rsp,%rax\n  lea    -0x4(%rdi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\nL1:\n  mov    0x8(%rax),%edx\n  add    0xc(%rax),%edx\n  add    0x4(%rax),%edx\n  add    (%rax),%edx\n  mov    %edx,0x10(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L1\nL0:\n  movslq %edi,%rdi\n  mov    (%rsp,%rdi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L2\n  add    $0x1a8,%rsp\n  ret\nL2:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4477
        },
        "L1": {
          "label": "L1",
          "addr": 4454
        },
        "L2": {
          "label": "L2",
          "addr": 4510
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[100];\n  arr[0] = 0;\n  arr[1] = 0;\n  arr[2] = 2;\n  arr[3] = 0;\n  for (int i = 4; i < n; i++)\n    arr[i] = arr[i - 1] + arr[i - 2] + arr[i - 3] + arr[i - 4];\n  return arr[n];\n}"
    },
    {
      "task_id": 32,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movsd  (%rdi),%xmm10\n  mov    %esi,%r9d\n  cmp    $0x1,%esi\n  jle    1279 <func0+0x179>\n  movsd  0xee3(%rip),%xmm5        # 2000 <_fini+0xd78>\n  movslq %esi,%r8\n  movapd %xmm10,%xmm3\n  mov    $0x1,%edx\n  pxor   %xmm7,%xmm7\n  xchg   %ax,%ax\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\n  mulsd  %xmm7,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    1140 <func0+0x40>\n  mulsd  (%rdi,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%r8\n  jne    1130 <func0+0x30>\n  movq   0xeaa(%rip),%xmm9        # 2010 <_fini+0xd88>\n  movapd %xmm3,%xmm0\n  movapd %xmm7,%xmm1\n  movsd  0xe91(%rip),%xmm8        # 2008 <_fini+0xd80>\n  movsd  0xe81(%rip),%xmm6        # 2000 <_fini+0xd78>\n  movslq %r9d,%r10\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  jbe    1251 <func0+0x151>\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x1,%r9d\n  jle    1256 <func0+0x156>\n  movsd  0x8(%rdi),%xmm4\n  mov    $0x2,%r8d\n  movapd %xmm6,%xmm5\n  addsd  %xmm7,%xmm4\n  cmp    $0x2,%r9d\n  je     1201 <func0+0x101>\n  mov    %r10,%r8\n  mov    $0x2,%ecx\n  nopl   0x0(%rax,%rax,1)\n  mov    %ecx,%esi\n  mov    %ecx,%edx\n  movapd %xmm6,%xmm0\n  mov    $0x1,%eax\n  nopl   (%rax)\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    11d8 <func0+0xd8>\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %esi,%xmm2\n  mulsd  (%rdi,%rcx,8),%xmm2\n  add    $0x1,%rcx\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  cmp    %rcx,%r10\n  jne    11c8 <func0+0xc8>\n  divsd  %xmm4,%xmm3\n  mov    $0x1,%edx\n  subsd  %xmm3,%xmm1\n  movapd %xmm10,%xmm3\n  nopl   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  xchg   %ax,%ax\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    1220 <func0+0x120>\n  mulsd  (%rdi,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %r8,%rdx\n  jne    1218 <func0+0x118>\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     1198 <func0+0x98>\n  movapd %xmm1,%xmm0\n  ret\n  divsd  %xmm7,%xmm3\n  subsd  %xmm3,%xmm1\n  movapd %xmm10,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     1198 <func0+0x98>\n  jmp    1251 <func0+0x151>\n  movapd %xmm10,%xmm3\n  pxor   %xmm7,%xmm7\n  jmp    115d <func0+0x5d>",
      "asm_labeled": "<func0>:\n  endbr64\n  movsd  (%rdi),%xmm10\n  mov    %esi,%r9d\n  cmp    $0x1,%esi\n  jle    L0\n  movsd  D0(%rip),%xmm5\n  movslq %esi,%r8\n  movapd %xmm10,%xmm3\n  mov    $0x1,%edx\n  pxor   %xmm7,%xmm7\n  xchg   %ax,%ax\nL2:\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  mulsd  %xmm7,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L1\n  mulsd  (%rdi,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%r8\n  jne    L2\nL11:\n  movq   D1(%rip),%xmm9\n  movapd %xmm3,%xmm0\n  movapd %xmm7,%xmm1\n  movsd  D2(%rip),%xmm8\n  movsd  D0(%rip),%xmm6\n  movslq %r9d,%r10\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  jbe    L3\n  nopw   0x0(%rax,%rax,1)\nL10:\n  cmp    $0x1,%r9d\n  jle    L4\n  movsd  0x8(%rdi),%xmm4\n  mov    $0x2,%r8d\n  movapd %xmm6,%xmm5\n  addsd  %xmm7,%xmm4\n  cmp    $0x2,%r9d\n  je     L5\n  mov    %r10,%r8\n  mov    $0x2,%ecx\n  nopl   0x0(%rax,%rax,1)\nL7:\n  mov    %ecx,%esi\n  mov    %ecx,%edx\n  movapd %xmm6,%xmm0\n  mov    $0x1,%eax\n  nopl   (%rax)\nL6:\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L6\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %esi,%xmm2\n  mulsd  (%rdi,%rcx,8),%xmm2\n  add    $0x1,%rcx\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  cmp    %rcx,%r10\n  jne    L7\nL5:\n  divsd  %xmm4,%xmm3\n  mov    $0x1,%edx\n  subsd  %xmm3,%xmm1\n  movapd %xmm10,%xmm3\n  nopl   0x0(%rax,%rax,1)\nL9:\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  xchg   %ax,%ax\nL8:\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L8\n  mulsd  (%rdi,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %r8,%rdx\n  jne    L9\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     L10\nL3:\n  movapd %xmm1,%xmm0\n  ret\nL4:\n  divsd  %xmm7,%xmm3\n  subsd  %xmm3,%xmm1\n  movapd %xmm10,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     L10\n  jmp    L3\nL0:\n  movapd %xmm10,%xmm3\n  pxor   %xmm7,%xmm7\n  jmp    L11",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3811,
            3713
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3754
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3729
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4729
        },
        "L1": {
          "label": "L1",
          "addr": 4416
        },
        "L2": {
          "label": "L2",
          "addr": 4400
        },
        "L3": {
          "label": "L3",
          "addr": 4689
        },
        "L4": {
          "label": "L4",
          "addr": 4694
        },
        "L5": {
          "label": "L5",
          "addr": 4609
        },
        "L6": {
          "label": "L6",
          "addr": 4568
        },
        "L7": {
          "label": "L7",
          "addr": 4552
        },
        "L8": {
          "label": "L8",
          "addr": 4640
        },
        "L9": {
          "label": "L9",
          "addr": 4632
        },
        "L10": {
          "label": "L10",
          "addr": 4504
        },
        "L11": {
          "label": "L11",
          "addr": 4445
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000000000000f03f8dedb5a0f7c6b03effffffffffffff7f0000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f64",
            "value": 1.0
          },
          "0x2010": {
            "type": "qword",
            "value": 9223372036854775807
          },
          "0x2008": {
            "type": "byte[8]",
            "value": [
              141,
              237,
              181,
              160,
              247,
              198,
              176,
              62
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " double func0(double *x, int N) {\n  double f, fp, t, h, hh, h6;\n  int i, j;\n  f = x[0];\n  h = hh = 1.0;\n  for (i = 1; i < N; i++) {\n    h *= hh;\n    f += h * x[i];\n  }\n  fp = f;\n  h = 1.0;\n  h6 = h * h * h * h * h * h;\n  while (fabs(fp) > 1.0e-12) {\n    t = x[1];\n    for (i = 2; i < N; i++) {\n      h *= hh;\n      for (j = 1; j < i; j++)\n        h *= hh;\n      t += i * h * x[i];\n    }\n    f -= fp / t;\n    h = h6;\n    fp = f;\n    hh = h;\n    for (i = 1; i < N; i++) {\n      h *= hh;\n      f += h * x[i];\n    }\n  }\n  return f;\n}"
    },
    {
      "task_id": 49,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    111b <func0+0x22>\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\n  lea    (%rdx,%rdx,1),%eax\n  cltd\n  idiv   %esi\n  add    $0x1,%ecx\n  cmp    %ecx,%edi\n  jne    110b <func0+0x12>\n  mov    %edx,%eax\n  ret\n  mov    $0x1,%edx\n  jmp    1118 <func0+0x1f>",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\nL1:\n  lea    (%rdx,%rdx,1),%eax\n  cltd\n  idiv   %esi\n  add    $0x1,%ecx\n  cmp    %ecx,%edi\n  jne    L1\nL2:\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x1,%edx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4379
        },
        "L1": {
          "label": "L1",
          "addr": 4363
        },
        "L2": {
          "label": "L2",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x, int y) {\n  int result = 1;\n  for (int i = 0; i < x; i++) {\n    result *= 2;\n    result %= y;\n  }\n  return result;\n}"
    },
    {
      "task_id": 48,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    115c <func0+0x43>\n  cltq\n  lea    -0x1(%rbx,%rax,1),%rdx\n  mov    $0x0,%eax\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rbx,%rax,1)\n  jne    1163 <func0+0x4a>\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     1140 <func0+0x27>\n  mov    $0x1,%eax\n  jmp    1168 <func0+0x4f>\n  mov    $0x1,%eax\n  jmp    1168 <func0+0x4f>\n  mov    $0x0,%eax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    L0\n  cltq\n  lea    -0x1(%rbx,%rax,1),%rdx\n  mov    $0x0,%eax\nL2:\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rbx,%rax,1)\n  jne    L1\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     L2\n  mov    $0x1,%eax\n  jmp    L3\nL0:\n  mov    $0x1,%eax\n  jmp    L3\nL1:\n  mov    $0x0,%eax\nL3:\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4444
        },
        "L1": {
          "label": "L1",
          "addr": 4451
        },
        "L2": {
          "label": "L2",
          "addr": 4416
        },
        "L3": {
          "label": "L3",
          "addr": 4456
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str) {\n  int i;\n  int len = strlen(str);\n  for (i = 0; i < len / 2; i++) {\n    if (str[i] != str[len - i - 1]) {\n      return 0;\n    }\n  }\n  return 1;\n}"
    },
    {
      "task_id": 48,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    1170 <func0+0x50>\n  sub    $0x1,%eax\n  xor    %edx,%edx\n  cltq\n  add    %rbx,%rax\n  jmp    115c <func0+0x3c>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%ecx\n  jle    1170 <func0+0x50>\n  movzbl (%rax),%esi\n  cmp    %sil,(%rbx,%rdx,1)\n  je     1150 <func0+0x30>\n  xor    %eax,%eax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\n  mov    $0x1,%eax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    L0\n  sub    $0x1,%eax\n  xor    %edx,%edx\n  cltq\n  add    %rbx,%rax\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL2:\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%ecx\n  jle    L0\nL1:\n  movzbl (%rax),%esi\n  cmp    %sil,(%rbx,%rdx,1)\n  je     L2\n  xor    %eax,%eax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x1,%eax\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4464
        },
        "L1": {
          "label": "L1",
          "addr": 4444
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str) {\n  int i;\n  int len = strlen(str);\n  for (i = 0; i < len / 2; i++) {\n    if (str[i] != str[len - 1 - i]) {\n      return 0;\n    }\n  }\n  return 1;\n}"
    },
    {
      "task_id": 32,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  mov    %esi,%r9d\n  movsd  (%rdi),%xmm5\n  cmp    $0x1,%esi\n  jle    1150 <func0+0x57>\n  mov    %esi,%esi\n  movapd %xmm5,%xmm3\n  mov    $0x1,%ecx\n  pxor   %xmm1,%xmm1\n  jmp    113b <func0+0x42>\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    111d <func0+0x24>\n  mulsd  (%r8,%rcx,8),%xmm0\n  addsd  %xmm0,%xmm3\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  je     1154 <func0+0x5b>\n  mov    %ecx,%edx\n  mov    $0x0,%eax\n  movsd  0xeb6(%rip),%xmm0        # 2000 <_fini+0xd94>\n  test   %ecx,%ecx\n  jg     111d <func0+0x24>\n  jmp    1128 <func0+0x2f>\n  movapd %xmm5,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  0xeb0(%rip),%xmm0        # 2010 <_fini+0xda4>\n  pxor   %xmm1,%xmm1\n  comisd 0xe9c(%rip),%xmm0        # 2008 <_fini+0xd9c>\n  jbe    1189 <func0+0x90>\n  mov    $0x1,%r10d\n  movq   0xe94(%rip),%xmm7        # 2010 <_fini+0xda4>\n  movsd  0xe84(%rip),%xmm6        # 2008 <_fini+0xd9c>\n  jmp    1236 <func0+0x13d>\n  pxor   %xmm1,%xmm1\n  movapd %xmm1,%xmm0\n  ret\n  mov    $0x1,%eax\n  movsd  0xe61(%rip),%xmm0        # 2000 <_fini+0xd94>\n  mulsd  %xmm1,%xmm0\n  mov    %eax,%edx\n  add    $0x1,%eax\n  cmp    %edx,%ecx\n  jne    119f <func0+0xa6>\n  add    $0x8,%rdi\n  mov    %esi,%ecx\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %ecx,%xmm2\n  mulsd  (%rdi),%xmm2\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  lea    0x1(%rcx),%esi\n  cmp    %esi,%r9d\n  je     1254 <func0+0x15b>\n  cmp    $0x1,%esi\n  jg     1192 <func0+0x99>\n  movsd  0xe21(%rip),%xmm0        # 2000 <_fini+0xd94>\n  jmp    11ac <func0+0xb3>\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %eax,%edx\n  jne    11e1 <func0+0xe8>\n  mulsd  (%r8,%rcx,8),%xmm0\n  addsd  %xmm0,%xmm3\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  je     1224 <func0+0x12b>\n  mov    %ecx,%edx\n  mov    $0x0,%eax\n  movsd  0xdf2(%rip),%xmm0        # 2000 <_fini+0xd94>\n  test   %ecx,%ecx\n  jg     11e1 <func0+0xe8>\n  jmp    11ec <func0+0xf3>\n  divsd  0xdfc(%rip),%xmm3        # 2018 <_fini+0xdac>\n  subsd  %xmm3,%xmm1\n  movapd %xmm5,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  %xmm7,%xmm0\n  comisd %xmm6,%xmm0\n  jbe    118d <func0+0x94>\n  cmp    $0x1,%r9d\n  jle    1214 <func0+0x11b>\n  lea    0x8(%r8),%rdi\n  mov    %r10d,%ecx\n  pxor   %xmm4,%xmm4\n  movsd  0xdb1(%rip),%xmm0        # 2000 <_fini+0xd94>\n  jmp    11b2 <func0+0xb9>\n  divsd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  lea    0x1(%rcx),%esi\n  movapd %xmm5,%xmm3\n  mov    $0x1,%ecx\n  jmp    11ff <func0+0x106>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  mov    %esi,%r9d\n  movsd  (%rdi),%xmm5\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %esi,%esi\n  movapd %xmm5,%xmm3\n  mov    $0x1,%ecx\n  pxor   %xmm1,%xmm1\n  jmp    L1\nL2:\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L2\nL4:\n  mulsd  (%r8,%rcx,8),%xmm0\n  addsd  %xmm0,%xmm3\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  je     L3\nL1:\n  mov    %ecx,%edx\n  mov    $0x0,%eax\n  movsd  D0(%rip),%xmm0\n  test   %ecx,%ecx\n  jg     L2\n  jmp    L4\nL0:\n  movapd %xmm5,%xmm3\nL3:\n  movapd %xmm3,%xmm0\n  andpd  D1(%rip),%xmm0\n  pxor   %xmm1,%xmm1\n  comisd D2(%rip),%xmm0\n  jbe    L5\n  mov    $0x1,%r10d\n  movq   D1(%rip),%xmm7\n  movsd  D2(%rip),%xmm6\n  jmp    L6\nL5:\n  pxor   %xmm1,%xmm1\nL14:\n  movapd %xmm1,%xmm0\n  ret\nL9:\n  mov    $0x1,%eax\n  movsd  D0(%rip),%xmm0\nL7:\n  mulsd  %xmm1,%xmm0\n  mov    %eax,%edx\n  add    $0x1,%eax\n  cmp    %edx,%ecx\n  jne    L7\nL10:\n  add    $0x8,%rdi\n  mov    %esi,%ecx\nL16:\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %ecx,%xmm2\n  mulsd  (%rdi),%xmm2\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  lea    0x1(%rcx),%esi\n  cmp    %esi,%r9d\n  je     L8\n  cmp    $0x1,%esi\n  jg     L9\n  movsd  D0(%rip),%xmm0\n  jmp    L10\nL11:\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %eax,%edx\n  jne    L11\nL13:\n  mulsd  (%r8,%rcx,8),%xmm0\n  addsd  %xmm0,%xmm3\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  je     L12\nL17:\n  mov    %ecx,%edx\n  mov    $0x0,%eax\n  movsd  D0(%rip),%xmm0\n  test   %ecx,%ecx\n  jg     L11\n  jmp    L13\nL15:\n  divsd  D3(%rip),%xmm3\n  subsd  %xmm3,%xmm1\n  movapd %xmm5,%xmm3\nL12:\n  movapd %xmm3,%xmm0\n  andpd  %xmm7,%xmm0\n  comisd %xmm6,%xmm0\n  jbe    L14\nL6:\n  cmp    $0x1,%r9d\n  jle    L15\n  lea    0x8(%r8),%rdi\n  mov    %r10d,%ecx\n  pxor   %xmm4,%xmm4\n  movsd  D0(%rip),%xmm0\n  jmp    L16\nL8:\n  divsd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  lea    0x1(%rcx),%esi\n  movapd %xmm5,%xmm3\n  mov    $0x1,%ecx\n  jmp    L17",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3766,
            3681,
            3617,
            3570,
            3505
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3760,
            3732
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3740,
            3716
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8216,
          "bias": [
            3580
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4432
        },
        "L1": {
          "label": "L1",
          "addr": 4411
        },
        "L2": {
          "label": "L2",
          "addr": 4381
        },
        "L3": {
          "label": "L3",
          "addr": 4436
        },
        "L4": {
          "label": "L4",
          "addr": 4392
        },
        "L5": {
          "label": "L5",
          "addr": 4489
        },
        "L6": {
          "label": "L6",
          "addr": 4662
        },
        "L7": {
          "label": "L7",
          "addr": 4511
        },
        "L8": {
          "label": "L8",
          "addr": 4692
        },
        "L9": {
          "label": "L9",
          "addr": 4498
        },
        "L10": {
          "label": "L10",
          "addr": 4524
        },
        "L11": {
          "label": "L11",
          "addr": 4577
        },
        "L12": {
          "label": "L12",
          "addr": 4644
        },
        "L13": {
          "label": "L13",
          "addr": 4588
        },
        "L14": {
          "label": "L14",
          "addr": 4493
        },
        "L15": {
          "label": "L15",
          "addr": 4628
        },
        "L16": {
          "label": "L16",
          "addr": 4530
        },
        "L17": {
          "label": "L17",
          "addr": 4607
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000000000000f03f8dedb5a0f7c6b03effffffffffffff7f0000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f64",
            "value": 1.0
          },
          "0x2010": {
            "type": "qword[2]",
            "value": [
              9223372036854775807,
              0
            ]
          },
          "0x2018": {
            "type": "f64",
            "value": 0.0
          },
          "0x2008": {
            "type": "byte[16]",
            "value": [
              141,
              237,
              181,
              160,
              247,
              198,
              176,
              62,
              255,
              255,
              255,
              255,
              255,
              255,
              255,
              127
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " double func0(double *x, int N) {\n  double f, fp, fpp, h, hh, hhp, temp;\n  int i, j, k;\n  f = x[0];\n  for (i = 1; i < N; i++) {\n    h = 1.0;\n    for (j = 0; j < i; j++)\n      h *= x[i];\n    f += h * x[i];\n  }\n  if (fabs(f) > 0.000001) {\n    fp = 0.0;\n    do {\n      fpp = 0.0;\n      for (i = 1; i < N; i++) {\n        h = 1.0;\n        for (j = 0; j < i; j++)\n          h *= x[i];\n        fp += h * i * x[i];\n        hh = 1.0;\n        for (k = 0; k < i; k++)\n          hh *= x[i];\n        fpp += hh * i * (i - 1) * x[i];\n      }\n      fp /= fpp;\n      temp = f;\n      f -= fp;\n    } while (fabs(f) > 0.000001);\n  }\n  return fp;\n}"
    },
    {
      "task_id": 48,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    1170 <func0+0x50>\n  sub    $0x1,%eax\n  xor    %edx,%edx\n  cltq\n  add    %rbx,%rax\n  jmp    115c <func0+0x3c>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%ecx\n  jle    1170 <func0+0x50>\n  movzbl (%rax),%esi\n  cmp    %sil,(%rbx,%rdx,1)\n  je     1150 <func0+0x30>\n  xor    %eax,%eax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\n  mov    $0x1,%eax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    L0\n  sub    $0x1,%eax\n  xor    %edx,%edx\n  cltq\n  add    %rbx,%rax\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL2:\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%ecx\n  jle    L0\nL1:\n  movzbl (%rax),%esi\n  cmp    %sil,(%rbx,%rdx,1)\n  je     L2\n  xor    %eax,%eax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x1,%eax\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4464
        },
        "L1": {
          "label": "L1",
          "addr": 4444
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str) {\n  int i;\n  int len = strlen(str);\n  for (i = 0; i < len / 2; i++) {\n    if (str[i] != str[len - 1 - i]) {\n      return 0;\n    }\n  }\n  return 1;\n}"
    },
    {
      "task_id": 49,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1120 <func0+0x20>\n  xor    %ecx,%ecx\n  mov    $0x1,%edx\n  nop\n  lea    (%rdx,%rdx,1),%eax\n  add    $0x1,%ecx\n  cltd\n  idiv   %esi\n  cmp    %ecx,%edi\n  jne    1110 <func0+0x10>\n  mov    %edx,%eax\n  ret\n  mov    $0x1,%edx\n  mov    %edx,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %ecx,%ecx\n  mov    $0x1,%edx\n  nop\nL1:\n  lea    (%rdx,%rdx,1),%eax\n  add    $0x1,%ecx\n  cltd\n  idiv   %esi\n  cmp    %ecx,%edi\n  jne    L1\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x1,%edx\n  mov    %edx,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4384
        },
        "L1": {
          "label": "L1",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x, int y) {\n  int result = 1;\n  for (int i = 0; i < x; i++) {\n    result *= 2;\n    result %= y;\n  }\n  return result;\n}"
    },
    {
      "task_id": 49,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1120 <func0+0x20>\n  xor    %ecx,%ecx\n  mov    $0x1,%edx\n  nop\n  lea    (%rdx,%rdx,1),%eax\n  add    $0x1,%ecx\n  cltd\n  idiv   %esi\n  cmp    %ecx,%edi\n  jne    1110 <func0+0x10>\n  mov    %edx,%eax\n  ret\n  mov    $0x1,%edx\n  mov    %edx,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %ecx,%ecx\n  mov    $0x1,%edx\n  nop\nL1:\n  lea    (%rdx,%rdx,1),%eax\n  add    $0x1,%ecx\n  cltd\n  idiv   %esi\n  cmp    %ecx,%edi\n  jne    L1\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x1,%edx\n  mov    %edx,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4384
        },
        "L1": {
          "label": "L1",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x, int y) {\n  int result = 1;\n  for (int i = 0; i < x; i++) {\n    result *= 2;\n    result %= y;\n  }\n  return result;\n}"
    },
    {
      "task_id": 52,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    113a <func0+0x41>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x20(%rbp)\n  jg     1136 <func0+0x3d>\n  mov    $0x0,%eax\n  jmp    1147 <func0+0x4e>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1114 <func0+0x1b>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x20(%rbp)\n  jg     L1\n  mov    $0x0,%eax\n  jmp    L2\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  mov    $0x1,%eax\nL2:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4410
        },
        "L1": {
          "label": "L1",
          "addr": 4406
        },
        "L2": {
          "label": "L2",
          "addr": 4423
        },
        "L3": {
          "label": "L3",
          "addr": 4372
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n, int m) {\n  int i;\n  for (i = 0; i < n; i++)\n    if (x[i] >= m)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 47,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11d5 <func0+0xdc>\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    11c5 <func0+0xcc>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    11c1 <func0+0xc8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  -0x4(%rbp),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1122 <func0+0x29>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1114 <func0+0x1b>\n  mov    -0x1c(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1217 <func0+0x11e>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  jmp    1269 <func0+0x170>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  addss  %xmm0,%xmm1\n  movss  0xd9b(%rip),%xmm0        # 2000 <_fini+0xd94>\n  mulss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL4:\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    L1\nL3:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L2\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  -0x4(%rbp),%xmm0\n  movss  %xmm0,(%rax)\nL2:\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  mov    -0x1c(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L5\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  jmp    L6\nL5:\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  addss  %xmm0,%xmm1\n  movss  D0(%rip),%xmm0\n  mulss  %xmm1,%xmm0\nL6:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3483
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4565
        },
        "L1": {
          "label": "L1",
          "addr": 4549
        },
        "L2": {
          "label": "L2",
          "addr": 4545
        },
        "L3": {
          "label": "L3",
          "addr": 4386
        },
        "L4": {
          "label": "L4",
          "addr": 4372
        },
        "L5": {
          "label": "L5",
          "addr": 4631
        },
        "L6": {
          "label": "L6",
          "addr": 4713
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000003f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f32",
            "value": 0.5
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float *a, int n) {\n  int i, j;\n  float tmp;\n  for (i = 0; i < n; i++)\n    for (j = i + 1; j < n; j++)\n      if (a[i] > a[j]) {\n        tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n      }\n  if (n % 2 == 1)\n    return a[n / 2];\n  else\n    return (a[n / 2] + a[n / 2 - 1]) / 2.0;\n}"
    },
    {
      "task_id": 47,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r11\n  mov    %esi,%edi\n  test   %esi,%esi\n  jle    1175 <func0+0x75>\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r8d\n  mov    $0x1,%esi\n  lea    0x4(%r11),%rdx\n  lea    0x8(%r11),%r9\n  cmp    %r8,%rsi\n  je     1175 <func0+0x75>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    %r10d,%eax\n  sub    %esi,%eax\n  lea    -0x1(%rsi,%rax,1),%rax\n  lea    (%r9,%rax,4),%rcx\n  mov    %rdx,%rax\n  nopl   0x0(%rax)\n  movss  -0x4(%rdx),%xmm0\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    115f <func0+0x5f>\n  movss  %xmm1,-0x4(%rdx)\n  movss  %xmm0,(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    1148 <func0+0x48>\n  add    $0x1,%rsi\n  add    $0x4,%rdx\n  cmp    %r8,%rsi\n  jne    1130 <func0+0x30>\n  mov    %edi,%edx\n  shr    $0x1f,%edx\n  lea    (%rdi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     11a8 <func0+0xa8>\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%r11,%rax,4),%xmm0\n  addss  (%r11,%rax,4),%xmm0\n  mulss  0xe59(%rip),%xmm0        # 2000 <_fini+0xe4c>\n  ret\n  sar    %edi\n  movslq %edi,%rax\n  movss  (%r11,%rax,4),%xmm0\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r11\n  mov    %esi,%edi\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r8d\n  mov    $0x1,%esi\n  lea    0x4(%r11),%rdx\n  lea    0x8(%r11),%r9\n  cmp    %r8,%rsi\n  je     L0\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    %r10d,%eax\n  sub    %esi,%eax\n  lea    -0x1(%rsi,%rax,1),%rax\n  lea    (%r9,%rax,4),%rcx\n  mov    %rdx,%rax\n  nopl   0x0(%rax)\nL2:\n  movss  -0x4(%rdx),%xmm0\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L1\n  movss  %xmm1,-0x4(%rdx)\n  movss  %xmm0,(%rax)\nL1:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L2\n  add    $0x1,%rsi\n  add    $0x4,%rdx\n  cmp    %r8,%rsi\n  jne    L3\nL0:\n  mov    %edi,%edx\n  shr    $0x1f,%edx\n  lea    (%rdi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     L4\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%r11,%rax,4),%xmm0\n  addss  (%r11,%rax,4),%xmm0\n  mulss  D0(%rip),%xmm0\n  ret\nL4:\n  sar    %edi\n  movslq %edi,%rax\n  movss  (%r11,%rax,4),%xmm0\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3673
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4469
        },
        "L1": {
          "label": "L1",
          "addr": 4447
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        },
        "L3": {
          "label": "L3",
          "addr": 4400
        },
        "L4": {
          "label": "L4",
          "addr": 4520
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000003f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f32",
            "value": 0.5
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float *a, int n) {\n  int i, j;\n  float tmp;\n  for (i = 0; i < n; i++)\n    for (j = i + 1; j < n; j++)\n      if (a[i] > a[j]) {\n        tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n      }\n  if (n % 2 == 1)\n    return a[n / 2];\n  else\n    return (a[n / 2] + a[n / 2 - 1]) / 2.0f;\n}"
    },
    {
      "task_id": 50,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  cmpl   $0x0,-0x2c(%rbp)\n  je     1139 <func0+0x20>\n  mov    $0x5,%eax\n  jmp    113e <func0+0x25>\n  mov    $0x15,%eax\n  mov    %eax,-0x18(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %rax,-0x8(%rbp)\n  movq   $0x0,-0x10(%rbp)\n  jmp    11ae <func0+0x95>\n  mov    -0x28(%rbp),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  lea    -0x61(%rax),%edx\n  mov    -0x18(%rbp),%eax\n  add    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x3,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x61,%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x28(%rbp),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x14(%rbp),%edx\n  mov    %dl,(%rax)\n  addq   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  cmp    -0x8(%rbp),%rax\n  jb     115b <func0+0x42>\n  nop\n  nop\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  cmpl   $0x0,-0x2c(%rbp)\n  je     L0\n  mov    $0x5,%eax\n  jmp    L1\nL0:\n  mov    $0x15,%eax\nL1:\n  mov    %eax,-0x18(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x8(%rbp)\n  movq   $0x0,-0x10(%rbp)\n  jmp    L2\nL3:\n  mov    -0x28(%rbp),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  lea    -0x61(%rax),%edx\n  mov    -0x18(%rbp),%eax\n  add    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x3,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x61,%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x28(%rbp),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x14(%rbp),%edx\n  mov    %dl,(%rax)\n  addq   $0x1,-0x10(%rbp)\nL2:\n  mov    -0x10(%rbp),%rax\n  cmp    -0x8(%rbp),%rax\n  jb     L3\n  nop\n  nop\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4409
        },
        "L1": {
          "label": "L1",
          "addr": 4414
        },
        "L2": {
          "label": "L2",
          "addr": 4526
        },
        "L3": {
          "label": "L3",
          "addr": 4443
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, int flag) {\n  int i, j, k;\n  int key = (flag ? 5 : 21);\n  size_t len = strlen(a);\n  for (i = 0; i < len; i++) {\n    j = (a[i] - 'a' + key) % 26;\n    a[i] = 'a' + j;\n  }\n}"
    },
    {
      "task_id": 47,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r11\n  mov    %esi,%edi\n  test   %esi,%esi\n  jle    115e <func0+0x65>\n  lea    0x4(%r11),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r8d\n  mov    $0x1,%esi\n  lea    0x8(%r11),%r9\n  jmp    1146 <func0+0x4d>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     113e <func0+0x45>\n  movss  -0x4(%rdx),%xmm0\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    111c <func0+0x23>\n  movss  %xmm1,-0x4(%rdx)\n  movss  %xmm0,(%rax)\n  jmp    111c <func0+0x23>\n  add    $0x1,%rsi\n  add    $0x4,%rdx\n  cmp    %r8,%rsi\n  je     115e <func0+0x65>\n  mov    %r10d,%eax\n  sub    %esi,%eax\n  lea    -0x1(%rsi,%rax,1),%rax\n  lea    (%r9,%rax,4),%rcx\n  mov    %rdx,%rax\n  jmp    1125 <func0+0x2c>\n  mov    %edi,%edx\n  shr    $0x1f,%edx\n  lea    (%rdi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     1191 <func0+0x98>\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%r11,%rax,4),%xmm0\n  addss  (%r11,%rax,4),%xmm0\n  mulss  0xe70(%rip),%xmm0        # 2000 <_fini+0xe60>\n  ret\n  mov    %edx,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  (%r11,%rax,4),%xmm0\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r11\n  mov    %esi,%edi\n  test   %esi,%esi\n  jle    L0\n  lea    0x4(%r11),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r8d\n  mov    $0x1,%esi\n  lea    0x8(%r11),%r9\n  jmp    L1\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L2\nL4:\n  movss  -0x4(%rdx),%xmm0\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L3\n  movss  %xmm1,-0x4(%rdx)\n  movss  %xmm0,(%rax)\n  jmp    L3\nL2:\n  add    $0x1,%rsi\n  add    $0x4,%rdx\nL1:\n  cmp    %r8,%rsi\n  je     L0\n  mov    %r10d,%eax\n  sub    %esi,%eax\n  lea    -0x1(%rsi,%rax,1),%rax\n  lea    (%r9,%rax,4),%rcx\n  mov    %rdx,%rax\n  jmp    L4\nL0:\n  mov    %edi,%edx\n  shr    $0x1f,%edx\n  lea    (%rdi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     L5\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%r11,%rax,4),%xmm0\n  addss  (%r11,%rax,4),%xmm0\n  mulss  D0(%rip),%xmm0\n  ret\nL5:\n  mov    %edx,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  (%r11,%rax,4),%xmm0\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3696
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4446
        },
        "L1": {
          "label": "L1",
          "addr": 4422
        },
        "L2": {
          "label": "L2",
          "addr": 4414
        },
        "L3": {
          "label": "L3",
          "addr": 4380
        },
        "L4": {
          "label": "L4",
          "addr": 4389
        },
        "L5": {
          "label": "L5",
          "addr": 4497
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000003f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f32",
            "value": 0.5
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " float func0(float *a, int n) {\n  int i, j;\n  float tmp;\n  for (i = 0; i < n; i++)\n    for (j = i + 1; j < n; j++)\n      if (a[i] > a[j]) {\n        tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n      }\n  if (n % 2 == 1)\n    return a[(n + n % 2) / 2];\n  else\n    return (a[n / 2] + a[n / 2 - 1]) / 2.0f;\n}"
    },
    {
      "task_id": 50,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  cmp    $0x1,%esi\n  sbb    %ebp,%ebp\n  and    $0x10,%ebp\n  add    $0x5,%ebp\n  call   1050 <strlen@plt>\n  test   %rax,%rax\n  je     1180 <func0+0x60>\n  mov    %rbx,%rdi\n  add    %rbx,%rax\n  nopl   0x0(%rax,%rax,1)\n  movsbl (%rdi),%edx\n  add    $0x1,%rdi\n  lea    -0x61(%rbp,%rdx,1),%ecx\n  movslq %ecx,%rdx\n  mov    %ecx,%esi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%esi\n  sar    $0x23,%rdx\n  sub    %esi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%ecx\n  add    $0x61,%ecx\n  mov    %cl,-0x1(%rdi)\n  cmp    %rdi,%rax\n  jne    1150 <func0+0x30>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  cmp    $0x1,%esi\n  sbb    %ebp,%ebp\n  and    $0x10,%ebp\n  add    $0x5,%ebp\n  call   <strlen@plt>\n  test   %rax,%rax\n  je     L0\n  mov    %rbx,%rdi\n  add    %rbx,%rax\n  nopl   0x0(%rax,%rax,1)\nL1:\n  movsbl (%rdi),%edx\n  add    $0x1,%rdi\n  lea    -0x61(%rbp,%rdx,1),%ecx\n  movslq %ecx,%rdx\n  mov    %ecx,%esi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%esi\n  sar    $0x23,%rdx\n  sub    %esi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%ecx\n  add    $0x61,%ecx\n  mov    %cl,-0x1(%rdi)\n  cmp    %rdi,%rax\n  jne    L1\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4480
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, int flag) {\n  int i, j, len;\n  len = strlen(a);\n  if (flag)\n    j = 5;\n  else\n    j = 10;\n  for (i = 0; i < len; i++)\n    a[i] = (a[i] - 'a' + j) % 26 + 'a';\n}"
    },
    {
      "task_id": 50,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  cmp    $0x1,%esi\n  sbb    %ebx,%ebx\n  and    $0x10,%ebx\n  add    $0x5,%ebx\n  call   1050 <strlen@plt>\n  test   %rax,%rax\n  je     1172 <func0+0x59>\n  mov    %rbp,%rcx\n  lea    0x0(%rbp,%rax,1),%rdi\n  movsbl (%rcx),%eax\n  lea    -0x61(%rbx,%rax,1),%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x23,%rax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%edx\n  add    $0x61,%edx\n  mov    %dl,(%rcx)\n  add    $0x1,%rcx\n  cmp    %rdi,%rcx\n  jne    1143 <func0+0x2a>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  cmp    $0x1,%esi\n  sbb    %ebx,%ebx\n  and    $0x10,%ebx\n  add    $0x5,%ebx\n  call   <strlen@plt>\n  test   %rax,%rax\n  je     L0\n  mov    %rbp,%rcx\n  lea    0x0(%rbp,%rax,1),%rdi\nL1:\n  movsbl (%rcx),%eax\n  lea    -0x61(%rbx,%rax,1),%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x23,%rax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%edx\n  add    $0x61,%edx\n  mov    %dl,(%rcx)\n  add    $0x1,%rcx\n  cmp    %rdi,%rcx\n  jne    L1\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4466
        },
        "L1": {
          "label": "L1",
          "addr": 4419
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, int flag) {\n  int i, j, len;\n  len = strlen(a);\n  if (flag)\n    j = 5;\n  else\n    j = 10;\n  for (i = 0; i < len; i++)\n    a[i] = (a[i] - 'a' + j) % 26 + 'a';\n}"
    },
    {
      "task_id": 47,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  cmp    $0x1,%esi\n  jle    1154 <func0+0x54>\n  mov    %rdi,%rdx\n  movslq %esi,%r8\n  mov    $0x1,%edi\n  nopw   0x0(%rax,%rax,1)\n  mov    %rdi,%rax\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rdx),%xmm0\n  movss  (%rcx,%rax,4),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    113f <func0+0x3f>\n  movss  %xmm1,(%rdx)\n  movss  %xmm0,(%rcx,%rax,4)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     1128 <func0+0x28>\n  add    $0x1,%rdi\n  add    $0x4,%rdx\n  cmp    %r8,%rdi\n  jne    1120 <func0+0x20>\n  mov    %esi,%edx\n  shr    $0x1f,%edx\n  lea    (%rsi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     1185 <func0+0x85>\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %esi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%rcx,%rax,4),%xmm0\n  addss  (%rcx,%rax,4),%xmm0\n  mulss  0xe7c(%rip),%xmm0        # 2000 <_fini+0xe70>\n  ret\n  sar    %esi\n  movslq %esi,%rax\n  movss  (%rcx,%rax,4),%xmm0\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %rdi,%rdx\n  movslq %esi,%r8\n  mov    $0x1,%edi\n  nopw   0x0(%rax,%rax,1)\nL3:\n  mov    %rdi,%rax\n  nopl   0x0(%rax,%rax,1)\nL2:\n  movss  (%rdx),%xmm0\n  movss  (%rcx,%rax,4),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L1\n  movss  %xmm1,(%rdx)\n  movss  %xmm0,(%rcx,%rax,4)\nL1:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L2\n  add    $0x1,%rdi\n  add    $0x4,%rdx\n  cmp    %r8,%rdi\n  jne    L3\nL0:\n  mov    %esi,%edx\n  shr    $0x1f,%edx\n  lea    (%rsi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     L4\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %esi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%rcx,%rax,4),%xmm0\n  addss  (%rcx,%rax,4),%xmm0\n  mulss  D0(%rip),%xmm0\n  ret\nL4:\n  sar    %esi\n  movslq %esi,%rax\n  movss  (%rcx,%rax,4),%xmm0\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3708
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4436
        },
        "L1": {
          "label": "L1",
          "addr": 4415
        },
        "L2": {
          "label": "L2",
          "addr": 4392
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4485
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000003f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f32",
            "value": 0.5
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float *p, int n) {\n  int i, j;\n  float tmp;\n  for (i = 0; i < n - 1; i++)\n    for (j = i + 1; j < n; j++)\n      if (p[i] > p[j]) {\n        tmp = p[i];\n        p[i] = p[j];\n        p[j] = tmp;\n      }\n  if (n % 2 == 1)\n    return p[n / 2];\n  else\n    return (p[n / 2 - 1] + p[n / 2]) / 2.0f;\n}"
    },
    {
      "task_id": 52,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1130 <func0+0x30>\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\n  jmp    1121 <func0+0x21>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  je     1130 <func0+0x30>\n  cmp    %edx,(%rdi)\n  jl     1118 <func0+0x18>\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL2:\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  je     L0\nL1:\n  cmp    %edx,(%rdi)\n  jl     L2\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4400
        },
        "L1": {
          "label": "L1",
          "addr": 4385
        },
        "L2": {
          "label": "L2",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n, int y) {\n  int i;\n  for (i = 0; i < n; ++i)\n    if (x[i] >= y)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 52,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    111f <func0+0x26>\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%ecx\n  lea    0x4(%rdi,%rcx,4),%rcx\n  cmp    %edx,(%rax)\n  jge    1125 <func0+0x2c>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    110c <func0+0x13>\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%ecx\n  lea    0x4(%rdi,%rcx,4),%rcx\nL2:\n  cmp    %edx,(%rax)\n  jge    L1\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L2\n  mov    $0x1,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret\nL1:\n  mov    $0x0,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4383
        },
        "L1": {
          "label": "L1",
          "addr": 4389
        },
        "L2": {
          "label": "L2",
          "addr": 4364
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n, int m) {\n  int i;\n  for (i = 0; i < n; ++i)\n    if (x[i] >= m)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 51,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  lea    0xed0(%rip),%rax        # 2000 <_fini+0xe74>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  jmp    1175 <func0+0x5c>\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1050 <strchr@plt>\n  test   %rax,%rax\n  jne    1170 <func0+0x57>\n  mov    -0x10(%rbp),%rax\n  lea    0x1(%rax),%rdx\n  mov    %rdx,-0x10(%rbp)\n  mov    -0x18(%rbp),%rdx\n  movzbl (%rdx),%edx\n  mov    %dl,(%rax)\n  addq   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    113e <func0+0x25>\n  mov    -0x10(%rbp),%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  jmp    L0\nL2:\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L1\n  mov    -0x10(%rbp),%rax\n  lea    0x1(%rax),%rdx\n  mov    %rdx,-0x10(%rbp)\n  mov    -0x18(%rbp),%rdx\n  movzbl (%rdx),%edx\n  mov    %dl,(%rax)\nL1:\n  addq   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\n  mov    -0x10(%rbp),%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3792
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4469
        },
        "L1": {
          "label": "L1",
          "addr": 4464
        },
        "L2": {
          "label": "L2",
          "addr": 4414
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f556165696f7500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOUaeiou\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s) {\n  char *t;\n  char *vowels = \"AEIOUaeiou\";\n  for (t = s; *s; s++) {\n    if (strchr(vowels, *s) == NULL)\n      *t++ = *s;\n  }\n  *t = '\\0';\n}"
    },
    {
      "task_id": 53,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x4(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x4(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b) {\n  int c;\n  c = a + b;\n  return c;\n}"
    },
    {
      "task_id": 51,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     1178 <func0+0x58>\n  mov    %rdi,%rbp\n  lea    0xebe(%rip),%r13        # 2000 <_fini+0xe78>\n  jmp    1154 <func0+0x34>\n  nopl   0x0(%rax)\n  movzbl 0x1(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  je     1178 <func0+0x58>\n  movsbl %bl,%esi\n  mov    %r13,%rdi\n  call   1050 <strchr@plt>\n  test   %rax,%rax\n  jne    1148 <func0+0x28>\n  add    $0x1,%rbp\n  mov    %bl,(%r12)\n  add    $0x1,%r12\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  jne    1154 <func0+0x34>\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  lea    D0(%rip),%r13\n  jmp    L1\n  nopl   0x0(%rax)\nL2:\n  movzbl 0x1(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  je     L0\nL1:\n  movsbl %bl,%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\n  add    $0x1,%rbp\n  mov    %bl,(%r12)\n  add    $0x1,%r12\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  jne    L1\nL0:\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3774
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4472
        },
        "L1": {
          "label": "L1",
          "addr": 4436
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f556165696f7500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOUaeiou\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s) {\n  char *p = s;\n  while (*p) {\n    if (strchr(\"AEIOUaeiou\", *p) == NULL) {\n      *s = *p;\n      s++;\n    }\n    p++;\n  }\n  *s = '\\0';\n}"
    },
    {
      "task_id": 53,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b) {\n  int tem0 = a + b;\n  return tem0;\n}"
    },
    {
      "task_id": 53,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b) {\n  int tem0 = a + b;\n  return tem0;\n}"
    },
    {
      "task_id": 53,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b) {\n  int tem0 = a + b;\n  return tem0;\n}"
    },
    {
      "task_id": 51,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  movzbl (%rdi),%ebp\n  test   %bpl,%bpl\n  je     1166 <func0+0x4d>\n  mov    %rdi,%r12\n  lea    0xec4(%rip),%r13        # 2000 <_fini+0xe84>\n  jmp    114a <func0+0x31>\n  add    $0x1,%rbx\n  movzbl (%rbx),%ebp\n  test   %bpl,%bpl\n  je     1169 <func0+0x50>\n  movsbl %bpl,%esi\n  mov    %r13,%rdi\n  call   1050 <strchr@plt>\n  test   %rax,%rax\n  jne    113e <func0+0x25>\n  mov    %bpl,(%r12)\n  lea    0x1(%r12),%r12\n  jmp    113e <func0+0x25>\n  mov    %rdi,%r12\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  movzbl (%rdi),%ebp\n  test   %bpl,%bpl\n  je     L0\n  mov    %rdi,%r12\n  lea    D0(%rip),%r13\n  jmp    L1\nL3:\n  add    $0x1,%rbx\n  movzbl (%rbx),%ebp\n  test   %bpl,%bpl\n  je     L2\nL1:\n  movsbl %bpl,%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L3\n  mov    %bpl,(%r12)\n  lea    0x1(%r12),%r12\n  jmp    L3\nL0:\n  mov    %rdi,%r12\nL2:\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3780
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4454
        },
        "L1": {
          "label": "L1",
          "addr": 4426
        },
        "L2": {
          "label": "L2",
          "addr": 4457
        },
        "L3": {
          "label": "L3",
          "addr": 4414
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f556165696f7500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOUaeiou\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s) {\n  char *p = s;\n  char *q = s;\n  char *t = s;\n  while (*p) {\n    if (strchr(\"AEIOUaeiou\", *p) == NULL) {\n      *q = *p;\n      q++;\n    }\n    p++;\n  }\n  *q = '\\0';\n}"
    },
    {
      "task_id": 51,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebp\n  test   %bpl,%bpl\n  je     1166 <func0+0x46>\n  lea    0xebd(%rip),%r13        # 2000 <_fini+0xe58>\n  nopl   0x0(%rax,%rax,1)\n  movsbl %bpl,%esi\n  mov    %r13,%rdi\n  call   1050 <strchr@plt>\n  test   %rax,%rax\n  je     1180 <func0+0x60>\n  movzbl 0x1(%rbx),%ebp\n  add    $0x1,%rbx\n  test   %bpl,%bpl\n  jne    1148 <func0+0x28>\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  add    $0x1,%rbx\n  mov    %bpl,(%r12)\n  lea    0x1(%r12),%rax\n  movzbl (%rbx),%ebp\n  mov    %rax,%r12\n  test   %bpl,%bpl\n  jne    1148 <func0+0x28>\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebp\n  test   %bpl,%bpl\n  je     L0\n  lea    D0(%rip),%r13\n  nopl   0x0(%rax,%rax,1)\nL2:\n  movsbl %bpl,%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\n  movzbl 0x1(%rbx),%ebp\n  add    $0x1,%rbx\n  test   %bpl,%bpl\n  jne    L2\nL0:\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  add    $0x1,%rbx\n  mov    %bpl,(%r12)\n  lea    0x1(%r12),%rax\n  movzbl (%rbx),%ebp\n  mov    %rax,%r12\n  test   %bpl,%bpl\n  jne    L2\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3773
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4454
        },
        "L1": {
          "label": "L1",
          "addr": 4480
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f556165696f7500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOUaeiou\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s) {\n  char *p = s;\n  char *q = s;\n  char c;\n  while ((c = *p) != '\\0') {\n    if (strchr(\"AEIOUaeiou\", c) == NULL) {\n      *q++ = c;\n    }\n    p++;\n  }\n  *q = '\\0';\n}"
    },
    {
      "task_id": 52,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1130 <func0+0x30>\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\n  jmp    1121 <func0+0x21>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  je     1130 <func0+0x30>\n  cmp    %edx,(%rdi)\n  jl     1118 <func0+0x18>\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL2:\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  je     L0\nL1:\n  cmp    %edx,(%rdi)\n  jl     L2\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4400
        },
        "L1": {
          "label": "L1",
          "addr": 4385
        },
        "L2": {
          "label": "L2",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n, int y) {\n  int i;\n  for (i = 0; i < n; ++i)\n    if (x[i] >= y)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 46,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movdqa 0xecd(%rip),%xmm0        # 2000 <_fini+0xdf8>\n  movslq %edi,%rsi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movaps %xmm0,(%rsp)\n  cmp    $0x3,%esi\n  jle    11da <func0+0xba>\n  lea    -0x1(%rsi),%r11d\n  cmp    $0x6,%esi\n  jle    11f8 <func0+0xd8>\n  mov    %rsp,%r10\n  xor    %r8d,%r8d\n  mov    $0x2,%edi\n  xor    %edx,%edx\n  mov    %r10,%rax\n  mov    $0x4,%ecx\n  lea    (%rdi,%r8,1),%r9d\n  add    $0xc,%rax\n  add    %r9d,%edx\n  add    -0xc(%rax),%edx\n  lea    (%rdx,%r8,1),%r9d\n  mov    %edx,0x4(%rax)\n  add    %r9d,%edi\n  add    -0x8(%rax),%edi\n  lea    (%rdx,%rdi,1),%r9d\n  mov    %edi,0x8(%rax)\n  add    %r9d,%r8d\n  mov    %ecx,%r9d\n  add    -0x4(%rax),%r8d\n  add    $0x3,%ecx\n  add    $0x4,%r9d\n  mov    %r8d,0xc(%rax)\n  cmp    %r9d,%r11d\n  jg     1178 <func0+0x58>\n  movslq %ecx,%rax\n  lea    (%r10,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\n  mov    -0x4(%rdx),%eax\n  add    $0x1,%ecx\n  add    -0x8(%rdx),%eax\n  add    $0x4,%rdx\n  add    -0x10(%rdx),%eax\n  add    -0x14(%rdx),%eax\n  mov    %eax,-0x4(%rdx)\n  cmp    %ecx,%esi\n  jge    11c0 <func0+0xa0>\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    1202 <func0+0xe2>\n  add    $0x1a8,%rsp\n  ret\n  mov    $0x4,%ecx\n  mov    %rsp,%r10\n  jmp    11b4 <func0+0x94>\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movdqa D0(%rip),%xmm0\n  movslq %edi,%rsi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movaps %xmm0,(%rsp)\n  cmp    $0x3,%esi\n  jle    L0\n  lea    -0x1(%rsi),%r11d\n  cmp    $0x6,%esi\n  jle    L1\n  mov    %rsp,%r10\n  xor    %r8d,%r8d\n  mov    $0x2,%edi\n  xor    %edx,%edx\n  mov    %r10,%rax\n  mov    $0x4,%ecx\nL2:\n  lea    (%rdi,%r8,1),%r9d\n  add    $0xc,%rax\n  add    %r9d,%edx\n  add    -0xc(%rax),%edx\n  lea    (%rdx,%r8,1),%r9d\n  mov    %edx,0x4(%rax)\n  add    %r9d,%edi\n  add    -0x8(%rax),%edi\n  lea    (%rdx,%rdi,1),%r9d\n  mov    %edi,0x8(%rax)\n  add    %r9d,%r8d\n  mov    %ecx,%r9d\n  add    -0x4(%rax),%r8d\n  add    $0x3,%ecx\n  add    $0x4,%r9d\n  mov    %r8d,0xc(%rax)\n  cmp    %r9d,%r11d\n  jg     L2\nL5:\n  movslq %ecx,%rax\n  lea    (%r10,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    -0x4(%rdx),%eax\n  add    $0x1,%ecx\n  add    -0x8(%rdx),%eax\n  add    $0x4,%rdx\n  add    -0x10(%rdx),%eax\n  add    -0x14(%rdx),%eax\n  mov    %eax,-0x4(%rdx)\n  cmp    %ecx,%esi\n  jge    L3\nL0:\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L4\n  add    $0x1a8,%rsp\n  ret\nL1:\n  mov    $0x4,%ecx\n  mov    %rsp,%r10\n  jmp    L5\nL4:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3789
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4570
        },
        "L1": {
          "label": "L1",
          "addr": 4600
        },
        "L2": {
          "label": "L2",
          "addr": 4472
        },
        "L3": {
          "label": "L3",
          "addr": 4544
        },
        "L4": {
          "label": "L4",
          "addr": 4610
        },
        "L5": {
          "label": "L5",
          "addr": 4532
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00000000000000000200000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              0,
              2,
              0,
              0,
              0,
              0,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[100];\n  int i;\n  arr[0] = 0;\n  arr[1] = 0;\n  arr[2] = 2;\n  for (i = 4; i < n; i += 4) {\n    arr[i] = arr[i - 4] + arr[i - 3] + arr[i - 2] + arr[i - 1];\n    arr[i + 1] = arr[i - 3] + arr[i - 2] + arr[i - 1] + arr[i];\n    arr[i + 2] = arr[i - 2] + arr[i - 1] + arr[i] + arr[i + 1];\n    arr[i + 3] = arr[i - 1] + arr[i] + arr[i + 1] + arr[i + 2];\n  }\n  for (i = 4; i <= n; i++)\n    arr[i] = arr[i - 1] + arr[i - 2] + arr[i - 3] + arr[i - 4];\n  return arr[n];\n}"
    },
    {
      "task_id": 55,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  mov    %edi,%esi\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x1f4,%ecx\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%esi\n  jle    116d <func0+0x54>\n  mov    %rsp,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\n  mov    (%rax),%edx\n  add    0x4(%rax),%edx\n  mov    %edx,0x8(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    115c <func0+0x43>\n  movslq %esi,%rsi\n  mov    (%rsp,%rsi,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    118e <func0+0x75>\n  add    $0xfb8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  mov    %edi,%esi\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x1f4,%ecx\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %rsp,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\nL1:\n  mov    (%rax),%edx\n  add    0x4(%rax),%edx\n  mov    %edx,0x8(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L1\nL0:\n  movslq %esi,%rsi\n  mov    (%rsp,%rsi,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L2\n  add    $0xfb8,%rsp\n  ret\nL2:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4461
        },
        "L1": {
          "label": "L1",
          "addr": 4444
        },
        "L2": {
          "label": "L2",
          "addr": 4494
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[1000] = {0, 1};\n  for (int i = 2; i <= n; i++)\n    arr[i] = arr[i - 1] + arr[i - 2];\n  return arr[n];\n}"
    },
    {
      "task_id": 55,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xfd0,%rsp\n  mov    %edi,-0xfc4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0xfb0(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x1f4,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0xfb0(%rbp)\n  movl   $0x1,-0xfac(%rbp)\n  movl   $0x2,-0xfb4(%rbp)\n  jmp    11b0 <func0+0x97>\n  mov    -0xfb4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%edx\n  mov    -0xfb4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0xfb4(%rbp),%eax\n  cltq\n  mov    %edx,-0xfb0(%rbp,%rax,4)\n  addl   $0x1,-0xfb4(%rbp)\n  mov    -0xfb4(%rbp),%eax\n  cmp    -0xfc4(%rbp),%eax\n  jle    1174 <func0+0x5b>\n  mov    -0xfc4(%rbp),%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     11e1 <func0+0xc8>\n  call   1050 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xfd0,%rsp\n  mov    %edi,-0xfc4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0xfb0(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x1f4,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0xfb0(%rbp)\n  movl   $0x1,-0xfac(%rbp)\n  movl   $0x2,-0xfb4(%rbp)\n  jmp    L0\nL1:\n  mov    -0xfb4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%edx\n  mov    -0xfb4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0xfb4(%rbp),%eax\n  cltq\n  mov    %edx,-0xfb0(%rbp,%rax,4)\n  addl   $0x1,-0xfb4(%rbp)\nL0:\n  mov    -0xfb4(%rbp),%eax\n  cmp    -0xfc4(%rbp),%eax\n  jle    L1\n  mov    -0xfc4(%rbp),%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L2\n  call   <__stack_chk_fail@plt>\nL2:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4528
        },
        "L1": {
          "label": "L1",
          "addr": 4468
        },
        "L2": {
          "label": "L2",
          "addr": 4577
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[1000] = {0, 1};\n  int i;\n  for (i = 2; i <= n; i++) {\n    arr[i] = arr[i - 1] + arr[i - 2];\n  }\n  return arr[n];\n}"
    },
    {
      "task_id": 55,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  movslq %edi,%r8\n  mov    $0x1f4,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%r8d\n  jle    1180 <func0+0x60>\n  lea    -0x2(%r8),%edx\n  lea    0x8(%rsp),%rax\n  lea    (%rax,%rdx,4),%rsi\n  mov    $0x1,%edx\n  jmp    1177 <func0+0x57>\n  xchg   %ax,%ax\n  mov    -0x4(%rax),%ecx\n  add    $0x4,%rax\n  add    %ecx,%edx\n  mov    %edx,(%rax)\n  cmp    %rsi,%rax\n  jne    1170 <func0+0x50>\n  mov    (%rsp,%r8,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    119f <func0+0x7f>\n  add    $0xfb8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  movslq %edi,%r8\n  mov    $0x1f4,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%r8d\n  jle    L0\n  lea    -0x2(%r8),%edx\n  lea    0x8(%rsp),%rax\n  lea    (%rax,%rdx,4),%rsi\n  mov    $0x1,%edx\n  jmp    L1\n  xchg   %ax,%ax\nL2:\n  mov    -0x4(%rax),%ecx\n  add    $0x4,%rax\nL1:\n  add    %ecx,%edx\n  mov    %edx,(%rax)\n  cmp    %rsi,%rax\n  jne    L2\nL0:\n  mov    (%rsp,%r8,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L3\n  add    $0xfb8,%rsp\n  ret\nL3:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4480
        },
        "L1": {
          "label": "L1",
          "addr": 4471
        },
        "L2": {
          "label": "L2",
          "addr": 4464
        },
        "L3": {
          "label": "L3",
          "addr": 4511
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[1000] = {0, 1};\n  int i;\n  for (i = 2; i <= n; i++)\n    arr[i] = arr[i - 1] + arr[i - 2];\n  return arr[n];\n}"
    },
    {
      "task_id": 55,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  movslq %edi,%rsi\n  mov    $0x1f4,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%esi\n  jle    11bc <func0+0x9c>\n  cmp    $0x3,%esi\n  jle    11da <func0+0xba>\n  lea    -0x4(%rsi),%eax\n  mov    $0x1,%r8d\n  xor    %edi,%edi\n  shr    %eax\n  lea    0x3(%rax),%r9d\n  mov    $0x4,%eax\n  add    %r9,%r9\n  add    %r8d,%edi\n  mov    %eax,%ecx\n  add    %edi,%r8d\n  movd   %edi,%xmm0\n  movd   %r8d,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,-0x8(%rdx,%rax,4)\n  add    $0x2,%rax\n  cmp    %rax,%r9\n  jne    117a <func0+0x5a>\n  movslq %ecx,%rax\n  lea    (%rdx,%rax,4),%rax\n  nopl   (%rax)\n  mov    -0x4(%rax),%edx\n  add    $0x1,%ecx\n  add    -0x8(%rax),%edx\n  add    $0x4,%rax\n  mov    %edx,-0x4(%rax)\n  cmp    %ecx,%esi\n  jge    11a8 <func0+0x88>\n  mov    (%rsp,%rsi,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    11e1 <func0+0xc1>\n  add    $0xfb8,%rsp\n  ret\n  mov    $0x2,%ecx\n  jmp    119e <func0+0x7e>\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  movslq %edi,%rsi\n  mov    $0x1f4,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%esi\n  jle    L0\n  cmp    $0x3,%esi\n  jle    L1\n  lea    -0x4(%rsi),%eax\n  mov    $0x1,%r8d\n  xor    %edi,%edi\n  shr    %eax\n  lea    0x3(%rax),%r9d\n  mov    $0x4,%eax\n  add    %r9,%r9\nL2:\n  add    %r8d,%edi\n  mov    %eax,%ecx\n  add    %edi,%r8d\n  movd   %edi,%xmm0\n  movd   %r8d,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,-0x8(%rdx,%rax,4)\n  add    $0x2,%rax\n  cmp    %rax,%r9\n  jne    L2\nL5:\n  movslq %ecx,%rax\n  lea    (%rdx,%rax,4),%rax\n  nopl   (%rax)\nL3:\n  mov    -0x4(%rax),%edx\n  add    $0x1,%ecx\n  add    -0x8(%rax),%edx\n  add    $0x4,%rax\n  mov    %edx,-0x4(%rax)\n  cmp    %ecx,%esi\n  jge    L3\nL0:\n  mov    (%rsp,%rsi,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L4\n  add    $0xfb8,%rsp\n  ret\nL1:\n  mov    $0x2,%ecx\n  jmp    L5\nL4:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4540
        },
        "L1": {
          "label": "L1",
          "addr": 4570
        },
        "L2": {
          "label": "L2",
          "addr": 4474
        },
        "L3": {
          "label": "L3",
          "addr": 4520
        },
        "L4": {
          "label": "L4",
          "addr": 4577
        },
        "L5": {
          "label": "L5",
          "addr": 4510
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[1000] = {0, 1};\n  int i = 2;\n  for (; i <= n; i++) {\n    arr[i] = arr[i - 1] + arr[i - 2];\n  }\n  return arr[n];\n}"
    },
    {
      "task_id": 50,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  cmp    $0x1,%esi\n  sbb    %ebp,%ebp\n  and    $0x10,%ebp\n  add    $0x5,%ebp\n  call   1050 <strlen@plt>\n  test   %rax,%rax\n  je     15e8 <func0+0x4c8>\n  mov    %rax,%rdx\n  lea    -0x1(%rax),%rax\n  cmp    $0xe,%rax\n  jbe    15ef <func0+0x4cf>\n  movd   %ebp,%xmm2\n  mov    %rdx,%rcx\n  movdqa 0xe9a(%rip),%xmm5        # 2000 <_fini+0xa08>\n  movdqa 0xea2(%rip),%xmm4        # 2010 <_fini+0xa18>\n  punpcklwd %xmm2,%xmm2\n  and    $0xfffffffffffffff0,%rcx\n  pxor   %xmm6,%xmm6\n  mov    %rbx,%rax\n  movdqa 0xe9b(%rip),%xmm3        # 2020 <_fini+0xa28>\n  movdqa 0xea3(%rip),%xmm7        # 2030 <_fini+0xa38>\n  pshufd $0x0,%xmm2,%xmm2\n  add    %rbx,%rcx\n  nopl   (%rax)\n  movdqu (%rax),%xmm1\n  movdqa %xmm6,%xmm9\n  add    $0x10,%rax\n  pcmpgtb %xmm1,%xmm9\n  movdqa %xmm1,%xmm8\n  movdqa %xmm1,%xmm0\n  punpcklbw %xmm9,%xmm8\n  punpckhbw %xmm9,%xmm0\n  paddw  %xmm5,%xmm8\n  paddw  %xmm5,%xmm0\n  paddw  %xmm2,%xmm8\n  paddw  %xmm2,%xmm0\n  movdqa %xmm8,%xmm9\n  movdqa %xmm8,%xmm1\n  pmulhw %xmm4,%xmm9\n  psraw  $0xf,%xmm1\n  psraw  $0x3,%xmm9\n  psubw  %xmm1,%xmm9\n  movdqa %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x2,%xmm1\n  paddw  %xmm9,%xmm1\n  movdqa %xmm0,%xmm9\n  pmulhw %xmm4,%xmm9\n  psllw  $0x1,%xmm1\n  psubw  %xmm1,%xmm8\n  movdqa %xmm0,%xmm1\n  psraw  $0xf,%xmm1\n  psraw  $0x3,%xmm9\n  psubw  %xmm1,%xmm9\n  movdqa %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x2,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  psubw  %xmm1,%xmm0\n  movdqa %xmm0,%xmm9\n  movdqa %xmm8,%xmm0\n  movdqa %xmm9,%xmm1\n  pand   %xmm3,%xmm0\n  pand   %xmm3,%xmm1\n  packuswb %xmm1,%xmm0\n  paddb  %xmm7,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rax,%rcx\n  jne    1198 <func0+0x78>\n  mov    %rdx,%rcx\n  and    $0xfffffffffffffff0,%rcx\n  test   $0xf,%dl\n  je     15e8 <func0+0x4c8>\n  lea    (%rbx,%rcx,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x1(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x2(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x3(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x4(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x5(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x6(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x7(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x8(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x9(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xa(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xb(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xc(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xd(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  add    $0xe,%rcx\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rcx,%rdx\n  jbe    15e8 <func0+0x4c8>\n  add    %rcx,%rbx\n  movsbl (%rbx),%eax\n  lea    -0x61(%rbp,%rax,1),%edx\n  movslq %edx,%rax\n  mov    %edx,%ecx\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%ecx\n  sar    $0x23,%rax\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%edx\n  add    $0x61,%edx\n  mov    %dl,(%rbx)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  xor    %ecx,%ecx\n  jmp    128d <func0+0x16d>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  cmp    $0x1,%esi\n  sbb    %ebp,%ebp\n  and    $0x10,%ebp\n  add    $0x5,%ebp\n  call   <strlen@plt>\n  test   %rax,%rax\n  je     L0\n  mov    %rax,%rdx\n  lea    -0x1(%rax),%rax\n  cmp    $0xe,%rax\n  jbe    L1\n  movd   %ebp,%xmm2\n  mov    %rdx,%rcx\n  movdqa D0(%rip),%xmm5\n  movdqa D1(%rip),%xmm4\n  punpcklwd %xmm2,%xmm2\n  and    $0xfffffffffffffff0,%rcx\n  pxor   %xmm6,%xmm6\n  mov    %rbx,%rax\n  movdqa D2(%rip),%xmm3\n  movdqa D3(%rip),%xmm7\n  pshufd $0x0,%xmm2,%xmm2\n  add    %rbx,%rcx\n  nopl   (%rax)\nL2:\n  movdqu (%rax),%xmm1\n  movdqa %xmm6,%xmm9\n  add    $0x10,%rax\n  pcmpgtb %xmm1,%xmm9\n  movdqa %xmm1,%xmm8\n  movdqa %xmm1,%xmm0\n  punpcklbw %xmm9,%xmm8\n  punpckhbw %xmm9,%xmm0\n  paddw  %xmm5,%xmm8\n  paddw  %xmm5,%xmm0\n  paddw  %xmm2,%xmm8\n  paddw  %xmm2,%xmm0\n  movdqa %xmm8,%xmm9\n  movdqa %xmm8,%xmm1\n  pmulhw %xmm4,%xmm9\n  psraw  $0xf,%xmm1\n  psraw  $0x3,%xmm9\n  psubw  %xmm1,%xmm9\n  movdqa %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x2,%xmm1\n  paddw  %xmm9,%xmm1\n  movdqa %xmm0,%xmm9\n  pmulhw %xmm4,%xmm9\n  psllw  $0x1,%xmm1\n  psubw  %xmm1,%xmm8\n  movdqa %xmm0,%xmm1\n  psraw  $0xf,%xmm1\n  psraw  $0x3,%xmm9\n  psubw  %xmm1,%xmm9\n  movdqa %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x2,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  psubw  %xmm1,%xmm0\n  movdqa %xmm0,%xmm9\n  movdqa %xmm8,%xmm0\n  movdqa %xmm9,%xmm1\n  pand   %xmm3,%xmm0\n  pand   %xmm3,%xmm1\n  packuswb %xmm1,%xmm0\n  paddb  %xmm7,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rax,%rcx\n  jne    L2\n  mov    %rdx,%rcx\n  and    $0xfffffffffffffff0,%rcx\n  test   $0xf,%dl\n  je     L0\nL3:\n  lea    (%rbx,%rcx,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x1(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x2(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x3(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x4(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x5(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x6(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x7(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x8(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x9(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xa(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xb(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xc(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xd(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  add    $0xe,%rcx\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rcx,%rdx\n  jbe    L0\n  add    %rcx,%rbx\n  movsbl (%rbx),%eax\n  lea    -0x61(%rbp,%rax,1),%edx\n  movslq %edx,%rax\n  mov    %edx,%ecx\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%ecx\n  sar    $0x23,%rax\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%edx\n  add    $0x61,%edx\n  mov    %dl,(%rbx)\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL1:\n  xor    %ecx,%ecx\n  jmp    L3",
      "num_missing": 4,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3738
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3746
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8224,
          "bias": [
            3739
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8240,
          "bias": [
            3747
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5608
        },
        "L1": {
          "label": "L1",
          "addr": 5615
        },
        "L2": {
          "label": "L2",
          "addr": 4504
        },
        "L3": {
          "label": "L3",
          "addr": 4749
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "9fff9fff9fff9fff9fff9fff9fff9fffc54ec54ec54ec54ec54ec54ec54ec54eff00ff00ff00ff00ff00ff00ff00ff0061616161616161616161616161616161",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              159,
              255,
              159,
              255,
              159,
              255,
              159,
              255,
              159,
              255,
              159,
              255,
              159,
              255,
              159,
              255
            ]
          },
          "0x2010": {
            "type": "byte[16]",
            "value": [
              197,
              78,
              197,
              78,
              197,
              78,
              197,
              78,
              197,
              78,
              197,
              78,
              197,
              78,
              197,
              78
            ]
          },
          "0x2020": {
            "type": "byte[16]",
            "value": [
              255,
              0,
              255,
              0,
              255,
              0,
              255,
              0,
              255,
              0,
              255,
              0,
              255,
              0,
              255,
              0
            ]
          },
          "0x2030": {
            "type": "byte[16]",
            "value": [
              97,
              97,
              97,
              97,
              97,
              97,
              97,
              97,
              97,
              97,
              97,
              97,
              97,
              97,
              97,
              97
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *ch, int flag) {\n  size_t i;\n  int j;\n  int base = (flag ? 5 : 17);\n  for (i = 0; i < strlen(ch); i++) {\n    j = (ch[i] - 'a' + base) % 26;\n    ch[i] = 'a' + j;\n  }\n}"
    },
    {
      "task_id": 56,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1156 <func0+0x5d>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3c,%al\n  jne    112d <func0+0x34>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3e,%al\n  jne    1145 <func0+0x4c>\n  subl   $0x1,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jns    1152 <func0+0x59>\n  mov    $0x0,%eax\n  jmp    117c <func0+0x83>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1115 <func0+0x1c>\n  cmpl   $0x0,-0x8(%rbp)\n  je     1177 <func0+0x7e>\n  mov    $0x0,%eax\n  jmp    117c <func0+0x83>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL5:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3c,%al\n  jne    L1\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3e,%al\n  jne    L2\n  subl   $0x1,-0x8(%rbp)\nL2:\n  cmpl   $0x0,-0x8(%rbp)\n  jns    L3\n  mov    $0x0,%eax\n  jmp    L4\nL3:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L5\n  cmpl   $0x0,-0x8(%rbp)\n  je     L6\n  mov    $0x0,%eax\n  jmp    L4\nL6:\n  mov    $0x1,%eax\nL4:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4438
        },
        "L1": {
          "label": "L1",
          "addr": 4397
        },
        "L2": {
          "label": "L2",
          "addr": 4421
        },
        "L3": {
          "label": "L3",
          "addr": 4434
        },
        "L4": {
          "label": "L4",
          "addr": 4476
        },
        "L5": {
          "label": "L5",
          "addr": 4373
        },
        "L6": {
          "label": "L6",
          "addr": 4471
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  int i;\n  int n;\n  n = 0;\n  i = 0;\n  while (s[i] != 0) {\n    if (s[i] == '<')\n      n++;\n    if (s[i] == '>')\n      n--;\n    if (n < 0)\n      return 0;\n    i++;\n  }\n  if (n != 0)\n    return 0;\n  return 1;\n}"
    },
    {
      "task_id": 56,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     114b <func0+0x4b>\n  add    $0x1,%rdi\n  xor    %edx,%edx\n  jmp    112c <func0+0x2c>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x3e,%al\n  jne    1121 <func0+0x21>\n  sub    $0x1,%edx\n  jb     1148 <func0+0x48>\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  je     113e <func0+0x3e>\n  cmp    $0x3c,%al\n  jne    1118 <func0+0x18>\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  add    $0x1,%edx\n  test   %al,%al\n  jne    112c <func0+0x2c>\n  test   %edx,%edx\n  sete   %al\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  xor    %edx,%edx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL5:\n  cmp    $0x3e,%al\n  jne    L2\n  sub    $0x1,%edx\n  jb     L3\nL2:\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  je     L4\nL1:\n  cmp    $0x3c,%al\n  jne    L5\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  add    $0x1,%edx\n  test   %al,%al\n  jne    L1\nL4:\n  test   %edx,%edx\n  sete   %al\n  ret\n  nopl   0x0(%rax)\nL3:\n  xor    %eax,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4427
        },
        "L1": {
          "label": "L1",
          "addr": 4396
        },
        "L2": {
          "label": "L2",
          "addr": 4385
        },
        "L3": {
          "label": "L3",
          "addr": 4424
        },
        "L4": {
          "label": "L4",
          "addr": 4414
        },
        "L5": {
          "label": "L5",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char func0(char *s) {\n  unsigned i = 0;\n  unsigned j = 0;\n  while (s[i]) {\n    if (s[i] == '<')\n      j++;\n    if (s[i] == '>') {\n      j--;\n      if (j < 0)\n        return 0;\n    }\n    i++;\n  }\n  if (j == 0)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 56,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     1132 <func0+0x39>\n  add    $0x1,%rdi\n  mov    $0x0,%edx\n  jmp    1122 <func0+0x29>\n  add    $0x1,%edx\n  test   %edx,%edx\n  js     113d <func0+0x44>\n  add    $0x1,%rdi\n  movzbl -0x1(%rdi),%eax\n  test   %al,%al\n  je     1137 <func0+0x3e>\n  cmp    $0x3c,%al\n  je     110f <func0+0x16>\n  cmp    $0x3e,%al\n  sete   %al\n  movzbl %al,%eax\n  sub    %eax,%edx\n  jmp    1112 <func0+0x19>\n  mov    $0x0,%edx\n  test   %edx,%edx\n  sete   %al\n  ret\n  mov    $0x0,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  mov    $0x0,%edx\n  jmp    L1\nL4:\n  add    $0x1,%edx\nL5:\n  test   %edx,%edx\n  js     L2\n  add    $0x1,%rdi\n  movzbl -0x1(%rdi),%eax\n  test   %al,%al\n  je     L3\nL1:\n  cmp    $0x3c,%al\n  je     L4\n  cmp    $0x3e,%al\n  sete   %al\n  movzbl %al,%eax\n  sub    %eax,%edx\n  jmp    L5\nL0:\n  mov    $0x0,%edx\nL3:\n  test   %edx,%edx\n  sete   %al\n  ret\nL2:\n  mov    $0x0,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4402
        },
        "L1": {
          "label": "L1",
          "addr": 4386
        },
        "L2": {
          "label": "L2",
          "addr": 4413
        },
        "L3": {
          "label": "L3",
          "addr": 4407
        },
        "L4": {
          "label": "L4",
          "addr": 4367
        },
        "L5": {
          "label": "L5",
          "addr": 4370
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char func0(char *input) {\n  int i = 0;\n  int level = 0;\n  while (input[i] != '\\0') {\n    if (input[i] == '<') {\n      level++;\n    } else if (input[i] == '>') {\n      level--;\n    }\n    if (level < 0) {\n      return 0;\n    }\n    i++;\n  }\n  if (level != 0) {\n    return 0;\n  }\n  return 1;\n}"
    },
    {
      "task_id": 57,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    119a <func0+0xa1>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    115a <func0+0x61>\n  movl   $0x1,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    1196 <func0+0x9d>\n  movl   $0x1,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111e <func0+0x25>\n  mov    -0xc(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  jne    11ba <func0+0xc1>\n  mov    $0x0,%eax\n  jmp    11bf <func0+0xc6>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L1\n  movl   $0x1,-0xc(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    L2\n  movl   $0x1,-0x8(%rbp)\nL2:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  mov    -0xc(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  jne    L4\n  mov    $0x0,%eax\n  jmp    L5\nL4:\n  mov    $0x1,%eax\nL5:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4506
        },
        "L1": {
          "label": "L1",
          "addr": 4442
        },
        "L2": {
          "label": "L2",
          "addr": 4502
        },
        "L3": {
          "label": "L3",
          "addr": 4382
        },
        "L4": {
          "label": "L4",
          "addr": 4538
        },
        "L5": {
          "label": "L5",
          "addr": 4543
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float *array, int n) {\n  int l = 0, u = 0;\n  for (int i = 1; i < n; i++) {\n    if (array[i] > array[i - 1])\n      l = 1;\n    if (array[i] < array[i - 1])\n      u = 1;\n  }\n  if (l + u == 2)\n    return 0;\n  return 1;\n}"
    },
    {
      "task_id": 57,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1143 <func0+0x4a>\n  mov    %rdi,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdi\n  mov    $0x0,%ecx\n  mov    $0x0,%edx\n  mov    $0x1,%esi\n  movss  0x4(%rax),%xmm0\n  movss  (%rax),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %esi,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %esi,%ecx\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    111c <func0+0x23>\n  add    %ecx,%edx\n  cmp    $0x2,%edx\n  setne  %al\n  ret\n  mov    $0x0,%ecx\n  mov    $0x0,%edx\n  jmp    113a <func0+0x41>",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdi\n  mov    $0x0,%ecx\n  mov    $0x0,%edx\n  mov    $0x1,%esi\nL1:\n  movss  0x4(%rax),%xmm0\n  movss  (%rax),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %esi,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %esi,%ecx\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    L1\nL2:\n  add    %ecx,%edx\n  cmp    $0x2,%edx\n  setne  %al\n  ret\nL0:\n  mov    $0x0,%ecx\n  mov    $0x0,%edx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4419
        },
        "L1": {
          "label": "L1",
          "addr": 4380
        },
        "L2": {
          "label": "L2",
          "addr": 4410
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " _Bool func0(float *x, int n) {\n  int i = 0;\n  int l0 = 0;\n  int l1 = 0;\n  while (i < n - 1) {\n    if (x[i + 1] > x[i])\n      l0 = 1;\n    if (x[i + 1] < x[i])\n      l1 = 1;\n    i++;\n  }\n  return l0 + l1 != 2;\n}"
    },
    {
      "task_id": 56,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     114b <func0+0x4b>\n  add    $0x1,%rdi\n  xor    %edx,%edx\n  jmp    112c <func0+0x2c>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x3e,%al\n  jne    1121 <func0+0x21>\n  sub    $0x1,%edx\n  jb     1148 <func0+0x48>\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  je     113e <func0+0x3e>\n  cmp    $0x3c,%al\n  jne    1118 <func0+0x18>\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  add    $0x1,%edx\n  test   %al,%al\n  jne    112c <func0+0x2c>\n  test   %edx,%edx\n  sete   %al\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  xor    %edx,%edx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL5:\n  cmp    $0x3e,%al\n  jne    L2\n  sub    $0x1,%edx\n  jb     L3\nL2:\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  je     L4\nL1:\n  cmp    $0x3c,%al\n  jne    L5\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  add    $0x1,%edx\n  test   %al,%al\n  jne    L1\nL4:\n  test   %edx,%edx\n  sete   %al\n  ret\n  nopl   0x0(%rax)\nL3:\n  xor    %eax,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4427
        },
        "L1": {
          "label": "L1",
          "addr": 4396
        },
        "L2": {
          "label": "L2",
          "addr": 4385
        },
        "L3": {
          "label": "L3",
          "addr": 4424
        },
        "L4": {
          "label": "L4",
          "addr": 4414
        },
        "L5": {
          "label": "L5",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char func0(char *s) {\n  unsigned i = 0;\n  unsigned j = 0;\n  while (s[i]) {\n    if (s[i] == '<')\n      j++;\n    if (s[i] == '>') {\n      j--;\n      if (j < 0)\n        return 0;\n    }\n    i++;\n  }\n  if (j == 0)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 60,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  add    $0x1,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  add    $0x1,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int a = x * (x + 1);\n  return a / 2;\n}"
    },
    {
      "task_id": 60,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int a = x * (x + 1);\n  return a / 2;\n}"
    },
    {
      "task_id": 57,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1150 <func0+0x50>\n  lea    -0x2(%rsi),%eax\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  lea    0x4(%rdi,%rax,4),%rsi\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\n  movss  0x4(%rdi),%xmm0\n  movss  (%rdi),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %ecx,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %ecx,%edx\n  add    $0x4,%rdi\n  cmp    %rdi,%rsi\n  jne    1120 <func0+0x20>\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%eax\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  lea    0x4(%rdi,%rax,4),%rsi\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\nL1:\n  movss  0x4(%rdi),%xmm0\n  movss  (%rdi),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %ecx,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %ecx,%edx\n  add    $0x4,%rdi\n  cmp    %rdi,%rsi\n  jne    L1\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4432
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " _Bool func0(_Bool *x, int n) {\n  int i, a, b;\n  for (i = 1, a = 0, b = 0; i < n; i++) {\n    if (x[i] < x[i - 1])\n      a = 1;\n    if (x[i] > x[i - 1])\n      b = 1;\n  }\n  return a + b != 2;\n}"
    },
    {
      "task_id": 54,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  mov    %rbx,%rdi\n  call   1050 <strlen@plt>\n  test   %r13d,%r13d\n  jle    1165 <func0+0x4c>\n  mov    %eax,%r8d\n  mov    %rbp,%rdi\n  lea    -0x1(%r13),%edx\n  lea    0x1(%rbp,%rdx,1),%r9\n  lea    -0x1(%rax),%edx\n  lea    0x1(%rbx,%rdx,1),%rsi\n  jmp    11c5 <func0+0xac>\n  mov    $0x0,%eax\n  jmp    11e2 <func0+0xc9>\n  test   %eax,%eax\n  jg     1170 <func0+0x57>\n  mov    $0x1,%eax\n  jmp    11e2 <func0+0xc9>\n  mov    %rbx,%rsi\n  lea    -0x1(%rax),%eax\n  lea    0x1(%rbx,%rax,1),%rdi\n  lea    -0x1(%r13),%eax\n  lea    0x1(%rbp,%rax,1),%rcx\n  jmp    1196 <func0+0x7d>\n  mov    $0x0,%eax\n  jmp    11e2 <func0+0xc9>\n  add    $0x1,%rsi\n  cmp    %rdi,%rsi\n  je     11b5 <func0+0x9c>\n  test   %r12d,%r12d\n  jle    1186 <func0+0x6d>\n  movzbl (%rsi),%edx\n  mov    %rbp,%rax\n  cmp    (%rax),%dl\n  je     118d <func0+0x74>\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    11a1 <func0+0x88>\n  mov    $0x0,%eax\n  jmp    11e2 <func0+0xc9>\n  mov    $0x1,%eax\n  jmp    11e2 <func0+0xc9>\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  je     1170 <func0+0x57>\n  test   %r8d,%r8d\n  jle    115e <func0+0x45>\n  movzbl (%rdi),%ecx\n  mov    %rbx,%rdx\n  cmp    (%rdx),%cl\n  je     11bc <func0+0xa3>\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    11d0 <func0+0xb7>\n  mov    $0x0,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  call   <strlen@plt>\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  test   %r13d,%r13d\n  jle    L0\n  mov    %eax,%r8d\n  mov    %rbp,%rdi\n  lea    -0x1(%r13),%edx\n  lea    0x1(%rbp,%rdx,1),%r9\n  lea    -0x1(%rax),%edx\n  lea    0x1(%rbx,%rdx,1),%rsi\n  jmp    L1\nL9:\n  mov    $0x0,%eax\n  jmp    L2\nL0:\n  test   %eax,%eax\n  jg     L3\n  mov    $0x1,%eax\n  jmp    L2\nL3:\n  mov    %rbx,%rsi\n  lea    -0x1(%rax),%eax\n  lea    0x1(%rbx,%rax,1),%rdi\n  lea    -0x1(%r13),%eax\n  lea    0x1(%rbp,%rax,1),%rcx\n  jmp    L4\nL6:\n  mov    $0x0,%eax\n  jmp    L2\nL7:\n  add    $0x1,%rsi\n  cmp    %rdi,%rsi\n  je     L5\nL4:\n  test   %r12d,%r12d\n  jle    L6\n  movzbl (%rsi),%edx\n  mov    %rbp,%rax\nL8:\n  cmp    (%rax),%dl\n  je     L7\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    L8\n  mov    $0x0,%eax\n  jmp    L2\nL5:\n  mov    $0x1,%eax\n  jmp    L2\nL10:\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  je     L3\nL1:\n  test   %r8d,%r8d\n  jle    L9\n  movzbl (%rdi),%ecx\n  mov    %rbx,%rdx\nL11:\n  cmp    (%rdx),%cl\n  je     L10\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    L11\n  mov    $0x0,%eax\nL2:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4453
        },
        "L1": {
          "label": "L1",
          "addr": 4549
        },
        "L2": {
          "label": "L2",
          "addr": 4578
        },
        "L3": {
          "label": "L3",
          "addr": 4464
        },
        "L4": {
          "label": "L4",
          "addr": 4502
        },
        "L5": {
          "label": "L5",
          "addr": 4533
        },
        "L6": {
          "label": "L6",
          "addr": 4486
        },
        "L7": {
          "label": "L7",
          "addr": 4493
        },
        "L8": {
          "label": "L8",
          "addr": 4513
        },
        "L9": {
          "label": "L9",
          "addr": 4446
        },
        "L10": {
          "label": "L10",
          "addr": 4540
        },
        "L11": {
          "label": "L11",
          "addr": 4560
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str0, char *str1) {\n  int i, j, k, len0, len1;\n  len0 = strlen(str0);\n  len1 = strlen(str1);\n  for (i = 0; i < len0; i++) {\n    for (j = 0; j < len1; j++) {\n      if (str0[i] == str1[j]) {\n        goto found;\n      }\n    }\n    return 0;\n  found:;\n  }\n  for (i = 0; i < len1; i++) {\n    for (j = 0; j < len0; j++) {\n      if (str1[i] == str0[j]) {\n        goto found2;\n      }\n    }\n    return 0;\n  found2:;\n  }\n  return 1;\n}"
    },
    {
      "task_id": 54,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   1050 <strlen@plt>\n  test   %r12d,%r12d\n  jle    11d7 <func0+0xb7>\n  lea    -0x1(%r12),%r9d\n  mov    %eax,%r8d\n  lea    0x1(%rbp),%rsi\n  sub    $0x1,%eax\n  mov    %r9,%r12\n  mov    %rbp,%rdi\n  lea    0x1(%rbx,%rax,1),%rcx\n  add    %rsi,%r9\n  nopl   0x0(%rax)\n  test   %r8d,%r8d\n  jle    11d0 <func0+0xb0>\n  movzbl (%rdi),%edx\n  mov    %rbx,%rax\n  jmp    1181 <func0+0x61>\n  nopl   (%rax)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     11d0 <func0+0xb0>\n  cmp    (%rax),%dl\n  jne    1178 <func0+0x58>\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  jne    1168 <func0+0x48>\n  xor    %edi,%edi\n  lea    (%rsi,%r12,1),%rcx\n  nopl   0x0(%rax)\n  movzbl (%rbx,%rdi,1),%edx\n  mov    %rbp,%rax\n  jmp    11b1 <func0+0x91>\n  nopl   0x0(%rax)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     11d0 <func0+0xb0>\n  cmp    (%rax),%dl\n  jne    11a8 <func0+0x88>\n  add    $0x1,%rdi\n  cmp    %edi,%r8d\n  jg     1198 <func0+0x78>\n  pop    %rbx\n  mov    $0x1,%eax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  test   %eax,%eax\n  setle  %al\n  jmp    11d2 <func0+0xb2>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strlen@plt>\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%r9d\n  mov    %eax,%r8d\n  lea    0x1(%rbp),%rsi\n  sub    $0x1,%eax\n  mov    %r9,%r12\n  mov    %rbp,%rdi\n  lea    0x1(%rbx,%rax,1),%rcx\n  add    %rsi,%r9\n  nopl   0x0(%rax)\nL4:\n  test   %r8d,%r8d\n  jle    L1\n  movzbl (%rdi),%edx\n  mov    %rbx,%rax\n  jmp    L2\n  nopl   (%rax)\nL3:\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    (%rax),%dl\n  jne    L3\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  jne    L4\n  xor    %edi,%edi\n  lea    (%rsi,%r12,1),%rcx\n  nopl   0x0(%rax)\nL7:\n  movzbl (%rbx,%rdi,1),%edx\n  mov    %rbp,%rax\n  jmp    L5\n  nopl   0x0(%rax)\nL6:\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     L1\nL5:\n  cmp    (%rax),%dl\n  jne    L6\n  add    $0x1,%rdi\n  cmp    %edi,%r8d\n  jg     L7\n  pop    %rbx\n  mov    $0x1,%eax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %eax,%eax\nL8:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL0:\n  test   %eax,%eax\n  setle  %al\n  jmp    L8",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4567
        },
        "L1": {
          "label": "L1",
          "addr": 4560
        },
        "L2": {
          "label": "L2",
          "addr": 4481
        },
        "L3": {
          "label": "L3",
          "addr": 4472
        },
        "L4": {
          "label": "L4",
          "addr": 4456
        },
        "L5": {
          "label": "L5",
          "addr": 4529
        },
        "L6": {
          "label": "L6",
          "addr": 4520
        },
        "L7": {
          "label": "L7",
          "addr": 4504
        },
        "L8": {
          "label": "L8",
          "addr": 4562
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *str0, char *str1) {\n  int i, j, k, len0, len1;\n  len0 = strlen(str0);\n  len1 = strlen(str1);\n  for (i = 0; i < len0; i++) {\n    for (j = 0; j < len1; j++) {\n      if (str0[i] == str1[j])\n        break;\n    }\n    if (j >= len1)\n      return 0;\n  }\n  for (i = 0; i < len1; i++) {\n    for (j = 0; j < len0; j++) {\n      if (str1[i] == str0[j])\n        break;\n    }\n    if (j >= len0)\n      return 1;\n  }\n  return 0;\n}"
    },
    {
      "task_id": 59,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    1130 <func0+0x37>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %eax,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    112c <func0+0x33>\n  mov    -0x14(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jg     110d <func0+0x14>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    1117 <func0+0x1e>\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %eax,-0x14(%rbp)\nL3:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x14(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jg     L2\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L3\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4400
        },
        "L1": {
          "label": "L1",
          "addr": 4396
        },
        "L2": {
          "label": "L2",
          "addr": 4365
        },
        "L3": {
          "label": "L3",
          "addr": 4375
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int i;\n  for (i = 2; i * i <= x; i++) {\n    while (x % i == 0 && x > i)\n      x /= i;\n  }\n  return x;\n}"
    },
    {
      "task_id": 54,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   1050 <strlen@plt>\n  test   %r12d,%r12d\n  jle    11d7 <func0+0xb7>\n  lea    -0x1(%r12),%r9d\n  mov    %eax,%r8d\n  lea    0x1(%rbp),%rsi\n  sub    $0x1,%eax\n  mov    %r9,%r12\n  mov    %rbp,%rdi\n  lea    0x1(%rbx,%rax,1),%rcx\n  add    %rsi,%r9\n  nopl   0x0(%rax)\n  test   %r8d,%r8d\n  jle    11d0 <func0+0xb0>\n  movzbl (%rdi),%edx\n  mov    %rbx,%rax\n  jmp    1181 <func0+0x61>\n  nopl   (%rax)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     11d0 <func0+0xb0>\n  cmp    (%rax),%dl\n  jne    1178 <func0+0x58>\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  jne    1168 <func0+0x48>\n  xor    %edi,%edi\n  lea    (%rsi,%r12,1),%rcx\n  nopl   0x0(%rax)\n  movzbl (%rbx,%rdi,1),%edx\n  mov    %rbp,%rax\n  jmp    11b1 <func0+0x91>\n  nopl   0x0(%rax)\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  je     11d0 <func0+0xb0>\n  cmp    (%rax),%dl\n  jne    11a8 <func0+0x88>\n  add    $0x1,%rdi\n  cmp    %edi,%r8d\n  jg     1198 <func0+0x78>\n  pop    %rbx\n  mov    $0x1,%eax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  test   %eax,%eax\n  setle  %al\n  jmp    11d2 <func0+0xb2>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strlen@plt>\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%r9d\n  mov    %eax,%r8d\n  lea    0x1(%rbp),%rsi\n  sub    $0x1,%eax\n  mov    %r9,%r12\n  mov    %rbp,%rdi\n  lea    0x1(%rbx,%rax,1),%rcx\n  add    %rsi,%r9\n  nopl   0x0(%rax)\nL4:\n  test   %r8d,%r8d\n  jle    L1\n  movzbl (%rdi),%edx\n  mov    %rbx,%rax\n  jmp    L2\n  nopl   (%rax)\nL3:\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    (%rax),%dl\n  jne    L3\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  jne    L4\n  xor    %edi,%edi\n  lea    (%rsi,%r12,1),%rcx\n  nopl   0x0(%rax)\nL7:\n  movzbl (%rbx,%rdi,1),%edx\n  mov    %rbp,%rax\n  jmp    L5\n  nopl   0x0(%rax)\nL6:\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  je     L1\nL5:\n  cmp    (%rax),%dl\n  jne    L6\n  add    $0x1,%rdi\n  cmp    %edi,%r8d\n  jg     L7\n  pop    %rbx\n  mov    $0x1,%eax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %eax,%eax\nL8:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL0:\n  test   %eax,%eax\n  setle  %al\n  jmp    L8",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4567
        },
        "L1": {
          "label": "L1",
          "addr": 4560
        },
        "L2": {
          "label": "L2",
          "addr": 4481
        },
        "L3": {
          "label": "L3",
          "addr": 4472
        },
        "L4": {
          "label": "L4",
          "addr": 4456
        },
        "L5": {
          "label": "L5",
          "addr": 4529
        },
        "L6": {
          "label": "L6",
          "addr": 4520
        },
        "L7": {
          "label": "L7",
          "addr": 4504
        },
        "L8": {
          "label": "L8",
          "addr": 4562
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *str0, char *str1) {\n  int i, j, k, len0, len1;\n  len0 = strlen(str0);\n  len1 = strlen(str1);\n  for (i = 0; i < len0; i++) {\n    for (j = 0; j < len1; j++) {\n      if (str0[i] == str1[j])\n        break;\n    }\n    if (j >= len1)\n      return 0;\n  }\n  for (i = 0; i < len1; i++) {\n    for (j = 0; j < len0; j++) {\n      if (str1[i] == str0[j])\n        break;\n    }\n    if (j >= len0)\n      return 1;\n  }\n  return 0;\n}"
    },
    {
      "task_id": 54,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    11ad <func0+0x94>\n  movb   $0x0,-0x1a(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    118f <func0+0x76>\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    118b <func0+0x72>\n  movb   $0x1,-0x1a(%rbp)\n  jmp    1197 <func0+0x7e>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     1161 <func0+0x48>\n  movzbl -0x1a(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     11a9 <func0+0x90>\n  mov    $0x0,%eax\n  jmp    1224 <func0+0x10b>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     1154 <func0+0x3b>\n  movl   $0x0,-0x10(%rbp)\n  jmp    1217 <func0+0xfe>\n  movb   $0x0,-0x19(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11f9 <func0+0xe0>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    11f5 <func0+0xdc>\n  movb   $0x1,-0x19(%rbp)\n  jmp    1201 <func0+0xe8>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     11cb <func0+0xb2>\n  movzbl -0x19(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     1213 <func0+0xfa>\n  mov    $0x0,%eax\n  jmp    1224 <func0+0x10b>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     11be <func0+0xa5>\n  mov    $0x1,%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    L0\nL7:\n  movb   $0x0,-0x1a(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L1\nL4:\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    L2\n  movb   $0x1,-0x1a(%rbp)\n  jmp    L3\nL2:\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L4\nL3:\n  movzbl -0x1a(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     L5\n  mov    $0x0,%eax\n  jmp    L6\nL5:\n  addl   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     L7\n  movl   $0x0,-0x10(%rbp)\n  jmp    L8\nL14:\n  movb   $0x0,-0x19(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L9\nL12:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    L10\n  movb   $0x1,-0x19(%rbp)\n  jmp    L11\nL10:\n  addl   $0x1,-0xc(%rbp)\nL9:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     L12\nL11:\n  movzbl -0x19(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     L13\n  mov    $0x0,%eax\n  jmp    L6\nL13:\n  addl   $0x1,-0x10(%rbp)\nL8:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L14\n  mov    $0x1,%eax\nL6:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4525
        },
        "L1": {
          "label": "L1",
          "addr": 4495
        },
        "L2": {
          "label": "L2",
          "addr": 4491
        },
        "L3": {
          "label": "L3",
          "addr": 4503
        },
        "L4": {
          "label": "L4",
          "addr": 4449
        },
        "L5": {
          "label": "L5",
          "addr": 4521
        },
        "L6": {
          "label": "L6",
          "addr": 4644
        },
        "L7": {
          "label": "L7",
          "addr": 4436
        },
        "L8": {
          "label": "L8",
          "addr": 4631
        },
        "L9": {
          "label": "L9",
          "addr": 4601
        },
        "L10": {
          "label": "L10",
          "addr": 4597
        },
        "L11": {
          "label": "L11",
          "addr": 4609
        },
        "L12": {
          "label": "L12",
          "addr": 4555
        },
        "L13": {
          "label": "L13",
          "addr": 4627
        },
        "L14": {
          "label": "L14",
          "addr": 4542
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str0, char *str1) {\n  int len0 = strlen(str0);\n  int len1 = strlen(str1);\n  for (int i = 0; i < len0; i++) {\n    char flag = 0;\n    for (int j = 0; j < len1; j++) {\n      if (str0[i] == str1[j]) {\n        flag = 1;\n        break;\n      }\n    }\n    if (flag == 0)\n      return 0;\n  }\n  for (int i = 0; i < len1; i++) {\n    char flag = 0;\n    for (int j = 0; j < len0; j++) {\n      if (str1[i] == str0[j]) {\n        flag = 1;\n        break;\n      }\n    }\n    if (flag == 0)\n      return 0;\n  }\n  return 1;\n}"
    },
    {
      "task_id": 59,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%r8d\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jle    114a <func0+0x4a>\n  nopl   0x0(%rax)\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1138 <func0+0x38>\n  jmp    113d <func0+0x3d>\n  nopl   0x0(%rax)\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%r8d\n  idiv   %ecx\n  test   %edx,%edx\n  jne    113d <func0+0x3d>\n  cmp    %ecx,%r8d\n  jg     1128 <func0+0x28>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%r8d\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jle    L0\n  nopl   0x0(%rax)\nL4:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L1\n  jmp    L2\n  nopl   0x0(%rax)\nL3:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%r8d\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\nL1:\n  cmp    %ecx,%r8d\n  jg     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    L4\nL0:\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4426
        },
        "L1": {
          "label": "L1",
          "addr": 4408
        },
        "L2": {
          "label": "L2",
          "addr": 4413
        },
        "L3": {
          "label": "L3",
          "addr": 4392
        },
        "L4": {
          "label": "L4",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int i;\n  for (i = 2; i * i <= x; i++) {\n    while (x % i == 0) {\n      x /= i;\n    }\n  }\n  return x;\n}"
    },
    {
      "task_id": 59,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%r8d\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jle    114a <func0+0x4a>\n  nopl   0x0(%rax)\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1138 <func0+0x38>\n  jmp    113d <func0+0x3d>\n  nopl   0x0(%rax)\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%r8d\n  idiv   %ecx\n  test   %edx,%edx\n  jne    113d <func0+0x3d>\n  cmp    %ecx,%r8d\n  jg     1128 <func0+0x28>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%r8d\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jle    L0\n  nopl   0x0(%rax)\nL4:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L1\n  jmp    L2\n  nopl   0x0(%rax)\nL3:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%r8d\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\nL1:\n  cmp    %ecx,%r8d\n  jg     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    L4\nL0:\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4426
        },
        "L1": {
          "label": "L1",
          "addr": 4408
        },
        "L2": {
          "label": "L2",
          "addr": 4413
        },
        "L3": {
          "label": "L3",
          "addr": 4392
        },
        "L4": {
          "label": "L4",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int i;\n  for (i = 2; i * i <= x; i++) {\n    while (x % i == 0) {\n      x /= i;\n    }\n  }\n  return x;\n}"
    },
    {
      "task_id": 60,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int a = x * (x + 1);\n  return a / 2;\n}"
    },
    {
      "task_id": 60,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int a = x * (x + 1);\n  return a / 2;\n}"
    },
    {
      "task_id": 59,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jg     1116 <func0+0x1d>\n  mov    %edi,%eax\n  ret\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     1107 <func0+0xe>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    110a <func0+0x11>\n  cmp    %ecx,%edi\n  jle    110a <func0+0x11>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%esi\n  mov    %eax,%edi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    110a <func0+0x11>\n  cmp    %ecx,%esi\n  jg     1123 <func0+0x2a>\n  jmp    110a <func0+0x11>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jg     L0\nL1:\n  mov    %edi,%eax\n  ret\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     L1\nL0:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\n  cmp    %ecx,%edi\n  jle    L2\nL3:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%esi\n  mov    %eax,%edi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\n  cmp    %ecx,%esi\n  jg     L3\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4374
        },
        "L1": {
          "label": "L1",
          "addr": 4359
        },
        "L2": {
          "label": "L2",
          "addr": 4362
        },
        "L3": {
          "label": "L3",
          "addr": 4387
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int i = 2;\n  while (i * i <= x) {\n    if (x % i == 0) {\n      while (x % i == 0 && x > i) {\n        x /= i;\n      }\n    }\n    i++;\n  }\n  return x;\n}"
    },
    {
      "task_id": 57,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1370 <func0+0x270>\n  lea    -0x2(%rsi),%eax\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%eax\n  jbe    1376 <func0+0x276>\n  mov    %r8d,%edx\n  pxor   %xmm1,%xmm1\n  movdqa 0xed1(%rip),%xmm2        # 2000 <_fini+0xc74>\n  mov    %rdi,%rax\n  shr    $0x2,%edx\n  movdqa %xmm1,%xmm4\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%rdi,%rdx,1),%rdx\n  nopl   (%rax)\n  movups 0x4(%rax),%xmm5\n  movups (%rax),%xmm0\n  movdqa %xmm2,%xmm3\n  add    $0x10,%rax\n  movups -0x10(%rax),%xmm6\n  cmpltps %xmm5,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm4,%xmm0\n  movdqa %xmm0,%xmm4\n  movaps %xmm5,%xmm0\n  cmpltps %xmm6,%xmm0\n  por    %xmm3,%xmm4\n  movdqa %xmm2,%xmm3\n  pand   %xmm0,%xmm3\n  pandn  %xmm1,%xmm0\n  movdqa %xmm0,%xmm1\n  por    %xmm3,%xmm1\n  cmp    %rdx,%rax\n  jne    1148 <func0+0x48>\n  movdqa %xmm1,%xmm2\n  mov    %r8d,%r9d\n  psrldq $0x8,%xmm2\n  and    $0xfffffffc,%r9d\n  movdqa %xmm2,%xmm0\n  lea    0x1(%r9),%edi\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm2\n  pandn  %xmm1,%xmm0\n  por    %xmm2,%xmm0\n  movdqa %xmm0,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm1\n  pcmpgtd %xmm0,%xmm1\n  pand   %xmm1,%xmm2\n  pandn  %xmm0,%xmm1\n  por    %xmm2,%xmm1\n  movd   %xmm1,%edx\n  movdqa %xmm4,%xmm1\n  psrldq $0x8,%xmm1\n  movdqa %xmm1,%xmm0\n  pcmpgtd %xmm4,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm4,%xmm0\n  por    %xmm1,%xmm0\n  movdqa %xmm0,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm1\n  pcmpgtd %xmm0,%xmm1\n  pand   %xmm1,%xmm2\n  pandn  %xmm0,%xmm1\n  por    %xmm2,%xmm1\n  movd   %xmm1,%eax\n  cmp    %r9d,%r8d\n  je     1360 <func0+0x260>\n  movslq %edi,%r10\n  lea    0x1(%rdi),%r11d\n  push   %rbx\n  shl    $0x2,%r10\n  lea    (%rcx,%r10,1),%r9\n  cmp    %r11d,%r8d\n  jle    1384 <func0+0x284>\n  cmp    %edi,%esi\n  jle    1384 <func0+0x284>\n  movss  (%r9),%xmm0\n  movss  -0x4(%r9),%xmm1\n  lea    0x3(%rdi),%ebx\n  lea    0x2(%rdi),%r11d\n  mov    $0x1,%r9d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0x4(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  cmp    %ebx,%r8d\n  jg     12f0 <func0+0x1f0>\n  movslq %r11d,%rdi\n  lea    0x1(%r11),%r9d\n  lea    0x0(,%rdi,4),%r8\n  movss  (%rcx,%rdi,4),%xmm0\n  mov    $0x1,%edi\n  movss  -0x4(%rcx,%r8,1),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%edx\n  cmp    %r9d,%esi\n  jle    12e0 <func0+0x1e0>\n  movss  0x4(%rcx,%r8,1),%xmm1\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%edx\n  add    $0x2,%r11d\n  cmp    %r11d,%esi\n  jle    12e0 <func0+0x1e0>\n  movss  0x8(%rcx,%r8,1),%xmm0\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%edx\n  add    %edx,%eax\n  pop    %rbx\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopw   0x0(%rax,%rax,1)\n  movss  0x8(%rcx,%r10,1),%xmm0\n  lea    0x5(%rdi),%ebx\n  lea    0x4(%rdi),%r11d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0xc(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  cmp    %ebx,%r8d\n  jle    1280 <func0+0x180>\n  movss  0x10(%rcx,%r10,1),%xmm0\n  lea    0x6(%rdi),%r11d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0x14(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  jmp    1280 <func0+0x180>\n  nopl   (%rax)\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopl   0x0(%rax)\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%edi\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    121f <func0+0x11f>\n  mov    %edi,%r11d\n  jmp    1280 <func0+0x180>",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%eax\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%eax\n  jbe    L1\n  mov    %r8d,%edx\n  pxor   %xmm1,%xmm1\n  movdqa D0(%rip),%xmm2\n  mov    %rdi,%rax\n  shr    $0x2,%edx\n  movdqa %xmm1,%xmm4\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%rdi,%rdx,1),%rdx\n  nopl   (%rax)\nL2:\n  movups 0x4(%rax),%xmm5\n  movups (%rax),%xmm0\n  movdqa %xmm2,%xmm3\n  add    $0x10,%rax\n  movups -0x10(%rax),%xmm6\n  cmpltps %xmm5,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm4,%xmm0\n  movdqa %xmm0,%xmm4\n  movaps %xmm5,%xmm0\n  cmpltps %xmm6,%xmm0\n  por    %xmm3,%xmm4\n  movdqa %xmm2,%xmm3\n  pand   %xmm0,%xmm3\n  pandn  %xmm1,%xmm0\n  movdqa %xmm0,%xmm1\n  por    %xmm3,%xmm1\n  cmp    %rdx,%rax\n  jne    L2\n  movdqa %xmm1,%xmm2\n  mov    %r8d,%r9d\n  psrldq $0x8,%xmm2\n  and    $0xfffffffc,%r9d\n  movdqa %xmm2,%xmm0\n  lea    0x1(%r9),%edi\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm2\n  pandn  %xmm1,%xmm0\n  por    %xmm2,%xmm0\n  movdqa %xmm0,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm1\n  pcmpgtd %xmm0,%xmm1\n  pand   %xmm1,%xmm2\n  pandn  %xmm0,%xmm1\n  por    %xmm2,%xmm1\n  movd   %xmm1,%edx\n  movdqa %xmm4,%xmm1\n  psrldq $0x8,%xmm1\n  movdqa %xmm1,%xmm0\n  pcmpgtd %xmm4,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm4,%xmm0\n  por    %xmm1,%xmm0\n  movdqa %xmm0,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm1\n  pcmpgtd %xmm0,%xmm1\n  pand   %xmm1,%xmm2\n  pandn  %xmm0,%xmm1\n  por    %xmm2,%xmm1\n  movd   %xmm1,%eax\n  cmp    %r9d,%r8d\n  je     L3\nL8:\n  movslq %edi,%r10\n  lea    0x1(%rdi),%r11d\n  push   %rbx\n  shl    $0x2,%r10\n  lea    (%rcx,%r10,1),%r9\n  cmp    %r11d,%r8d\n  jle    L4\n  cmp    %edi,%esi\n  jle    L4\n  movss  (%r9),%xmm0\n  movss  -0x4(%r9),%xmm1\n  lea    0x3(%rdi),%ebx\n  lea    0x2(%rdi),%r11d\n  mov    $0x1,%r9d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0x4(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  cmp    %ebx,%r8d\n  jg     L5\nL7:\n  movslq %r11d,%rdi\n  lea    0x1(%r11),%r9d\n  lea    0x0(,%rdi,4),%r8\n  movss  (%rcx,%rdi,4),%xmm0\n  mov    $0x1,%edi\n  movss  -0x4(%rcx,%r8,1),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%edx\n  cmp    %r9d,%esi\n  jle    L6\n  movss  0x4(%rcx,%r8,1),%xmm1\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%edx\n  add    $0x2,%r11d\n  cmp    %r11d,%esi\n  jle    L6\n  movss  0x8(%rcx,%r8,1),%xmm0\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%edx\nL6:\n  add    %edx,%eax\n  pop    %rbx\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopw   0x0(%rax,%rax,1)\nL5:\n  movss  0x8(%rcx,%r10,1),%xmm0\n  lea    0x5(%rdi),%ebx\n  lea    0x4(%rdi),%r11d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0xc(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  cmp    %ebx,%r8d\n  jle    L7\n  movss  0x10(%rcx,%r10,1),%xmm0\n  lea    0x6(%rdi),%r11d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0x14(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  jmp    L7\n  nopl   (%rax)\nL3:\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x1,%eax\n  ret\nL1:\n  mov    $0x1,%edi\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    L8\nL4:\n  mov    %edi,%r11d\n  jmp    L7",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3793
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4976
        },
        "L1": {
          "label": "L1",
          "addr": 4982
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        },
        "L3": {
          "label": "L3",
          "addr": 4960
        },
        "L4": {
          "label": "L4",
          "addr": 4996
        },
        "L5": {
          "label": "L5",
          "addr": 4848
        },
        "L6": {
          "label": "L6",
          "addr": 4832
        },
        "L7": {
          "label": "L7",
          "addr": 4736
        },
        "L8": {
          "label": "L8",
          "addr": 4639
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "01000000010000000100000001000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char func0(float *ptr, int n) {\n  char result = 0;\n  int i;\n  for (i = 1; i < n; i++) {\n    if (ptr[i] < ptr[i - 1])\n      result++;\n    if (ptr[i] < ptr[i + 1])\n      result++;\n  }\n  if (result != 2)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 62,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1125 <func0+0x2c>\n  mov    %esi,%esi\n  mov    $0x1,%eax\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rdi,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    1109 <func0+0x10>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %esi,%esi\n  mov    $0x1,%eax\nL1:\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rdi,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    L1\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4389
        },
        "L1": {
          "label": "L1",
          "addr": 4361
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(float *x, int n, float *y) {\n  int i;\n  for (i = 1; i < n; ++i)\n    y[i - 1] = i * x[i];\n}"
    },
    {
      "task_id": 62,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    1156 <func0+0x5d>\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x4(%rbp),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mulss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1115 <func0+0x1c>\n  nop\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    L0\nL1:\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x4(%rbp),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mulss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L1\n  nop\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4438
        },
        "L1": {
          "label": "L1",
          "addr": 4373
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(float *x, int n, float *y) {\n  int i;\n  for (i = 1; i < n; i++)\n    y[i - 1] = (float)i * x[i];\n}"
    },
    {
      "task_id": 62,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1134 <func0+0x34>\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rdi,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    1118 <func0+0x18>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\nL1:\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rdi,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    L1\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4404
        },
        "L1": {
          "label": "L1",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(float *a, int n, float *b) {\n  int i;\n  for (i = 1; i < n; i++)\n    b[i - 1] = i * a[i];\n}"
    },
    {
      "task_id": 61,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    117b <func0+0x62>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    1152 <func0+0x39>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    116a <func0+0x51>\n  subl   $0x1,-0x18(%rbp)\n  cmpl   $0x0,-0x18(%rbp)\n  jns    1177 <func0+0x5e>\n  mov    $0x0,%eax\n  jmp    1199 <func0+0x80>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     113a <func0+0x21>\n  cmpl   $0x0,-0x18(%rbp)\n  sete   %al\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL5:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    L1\n  addl   $0x1,-0x18(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    L2\n  subl   $0x1,-0x18(%rbp)\nL2:\n  cmpl   $0x0,-0x18(%rbp)\n  jns    L3\n  mov    $0x0,%eax\n  jmp    L4\nL3:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L5\n  cmpl   $0x0,-0x18(%rbp)\n  sete   %al\nL4:\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4475
        },
        "L1": {
          "label": "L1",
          "addr": 4434
        },
        "L2": {
          "label": "L2",
          "addr": 4458
        },
        "L3": {
          "label": "L3",
          "addr": 4471
        },
        "L4": {
          "label": "L4",
          "addr": 4505
        },
        "L5": {
          "label": "L5",
          "addr": 4410
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char func0(char *str) {\n  int i;\n  int count = 0;\n  for (i = 0; i < strlen(str); i++) {\n    if (str[i] == '(')\n      count++;\n    if (str[i] == ')')\n      count--;\n    if (count < 0)\n      return 0;\n  }\n  if (count == 0)\n    return 1;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 63,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x1c0,%rsp\n  mov    %edi,-0x1b4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0x1a0(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x32,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x19c(%rbp)\n  movl   $0x1,-0x198(%rbp)\n  movl   $0x3,-0x1a4(%rbp)\n  jmp    11c4 <func0+0xab>\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x3,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  cltq\n  mov    %edx,-0x1a0(%rbp,%rax,4)\n  addl   $0x1,-0x1a4(%rbp)\n  mov    -0x1a4(%rbp),%eax\n  cmp    -0x1b4(%rbp),%eax\n  jle    1174 <func0+0x5b>\n  mov    -0x1b4(%rbp),%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     11f5 <func0+0xdc>\n  call   1050 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x1c0,%rsp\n  mov    %edi,-0x1b4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0x1a0(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x32,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x19c(%rbp)\n  movl   $0x1,-0x198(%rbp)\n  movl   $0x3,-0x1a4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x3,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  cltq\n  mov    %edx,-0x1a0(%rbp,%rax,4)\n  addl   $0x1,-0x1a4(%rbp)\nL0:\n  mov    -0x1a4(%rbp),%eax\n  cmp    -0x1b4(%rbp),%eax\n  jle    L1\n  mov    -0x1b4(%rbp),%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L2\n  call   <__stack_chk_fail@plt>\nL2:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4548
        },
        "L1": {
          "label": "L1",
          "addr": 4468
        },
        "L2": {
          "label": "L2",
          "addr": 4597
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[100] = {0, 1, 3};\n  for (int i = 3; i <= n; i++)\n    arr[i] = arr[i - 1] + arr[i - 2] + arr[i - 3];\n  return arr[n];\n}"
    },
    {
      "task_id": 61,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rax,%rdi\n  mov    %rbx,%rax\n  add    %rbx,%rdi\n  mov    $0x0,%edx\n  jmp    1141 <func0+0x28>\n  add    $0x1,%edx\n  add    $0x1,%rax\n  test   %edx,%edx\n  js     1162 <func0+0x49>\n  cmp    %rdi,%rax\n  je     115b <func0+0x42>\n  movzbl (%rax),%ecx\n  cmp    $0x28,%cl\n  je     1136 <func0+0x1d>\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%edx\n  jmp    1139 <func0+0x20>\n  test   %edx,%edx\n  sete   %al\n  pop    %rbx\n  ret\n  mov    $0x0,%eax\n  jmp    1160 <func0+0x47>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rax,%rdi\n  mov    %rbx,%rax\n  add    %rbx,%rdi\n  mov    $0x0,%edx\n  jmp    L0\nL3:\n  add    $0x1,%edx\nL4:\n  add    $0x1,%rax\n  test   %edx,%edx\n  js     L1\nL0:\n  cmp    %rdi,%rax\n  je     L2\n  movzbl (%rax),%ecx\n  cmp    $0x28,%cl\n  je     L3\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%edx\n  jmp    L4\nL2:\n  test   %edx,%edx\n  sete   %al\nL5:\n  pop    %rbx\n  ret\nL1:\n  mov    $0x0,%eax\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4417
        },
        "L1": {
          "label": "L1",
          "addr": 4450
        },
        "L2": {
          "label": "L2",
          "addr": 4443
        },
        "L3": {
          "label": "L3",
          "addr": 4406
        },
        "L4": {
          "label": "L4",
          "addr": 4409
        },
        "L5": {
          "label": "L5",
          "addr": 4448
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char func0(char *s) {\n  int i = 0;\n  int j = 0;\n  for (i = 0; i < strlen(s); i++) {\n    if (s[i] == '(')\n      j++;\n    else if (s[i] == ')')\n      j--;\n  }\n  if (j == 0)\n    return 1;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 61,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  add    %rbx,%rax\n  jmp    114e <func0+0x2e>\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x29,%dl\n  jne    114a <func0+0x2a>\n  sub    $0x1,%ecx\n  jb     1170 <func0+0x50>\n  add    $0x1,%rdi\n  cmp    %rax,%rdi\n  je     1160 <func0+0x40>\n  movzbl (%rdi),%edx\n  cmp    $0x28,%dl\n  jne    1140 <func0+0x20>\n  add    $0x1,%ecx\n  jmp    114a <func0+0x2a>\n  test   %ecx,%ecx\n  pop    %rbx\n  sete   %al\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  add    %rbx,%rax\n  jmp    L0\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    $0x29,%dl\n  jne    L1\n  sub    $0x1,%ecx\n  jb     L2\nL1:\n  add    $0x1,%rdi\nL0:\n  cmp    %rax,%rdi\n  je     L3\n  movzbl (%rdi),%edx\n  cmp    $0x28,%dl\n  jne    L4\n  add    $0x1,%ecx\n  jmp    L1\nL3:\n  test   %ecx,%ecx\n  pop    %rbx\n  sete   %al\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4430
        },
        "L1": {
          "label": "L1",
          "addr": 4426
        },
        "L2": {
          "label": "L2",
          "addr": 4464
        },
        "L3": {
          "label": "L3",
          "addr": 4448
        },
        "L4": {
          "label": "L4",
          "addr": 4416
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char func0(char *s) {\n  int i = 0, j = 0;\n  for (i = 0; i < strlen(s); i++) {\n    if (s[i] == '(')\n      j++;\n    if (s[i] == ')')\n      j--;\n    if (j < 0)\n      return 0;\n  }\n  if (j == 0)\n    return 1;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 61,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  add    %rbx,%rax\n  jmp    114e <func0+0x2e>\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x29,%dl\n  jne    114a <func0+0x2a>\n  sub    $0x1,%ecx\n  jb     1170 <func0+0x50>\n  add    $0x1,%rdi\n  cmp    %rax,%rdi\n  je     1160 <func0+0x40>\n  movzbl (%rdi),%edx\n  cmp    $0x28,%dl\n  jne    1140 <func0+0x20>\n  add    $0x1,%ecx\n  jmp    114a <func0+0x2a>\n  test   %ecx,%ecx\n  pop    %rbx\n  sete   %al\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  add    %rbx,%rax\n  jmp    L0\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    $0x29,%dl\n  jne    L1\n  sub    $0x1,%ecx\n  jb     L2\nL1:\n  add    $0x1,%rdi\nL0:\n  cmp    %rax,%rdi\n  je     L3\n  movzbl (%rdi),%edx\n  cmp    $0x28,%dl\n  jne    L4\n  add    $0x1,%ecx\n  jmp    L1\nL3:\n  test   %ecx,%ecx\n  pop    %rbx\n  sete   %al\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4430
        },
        "L1": {
          "label": "L1",
          "addr": 4426
        },
        "L2": {
          "label": "L2",
          "addr": 4464
        },
        "L3": {
          "label": "L3",
          "addr": 4448
        },
        "L4": {
          "label": "L4",
          "addr": 4416
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char func0(char *s) {\n  int i = 0, j = 0;\n  for (i = 0; i < strlen(s); i++) {\n    if (s[i] == '(')\n      j++;\n    if (s[i] == ')')\n      j--;\n    if (j < 0)\n      return 0;\n  }\n  if (j == 0)\n    return 1;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 63,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %edi,%esi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x32,%ecx\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%esi\n  jle    1170 <func0+0x57>\n  mov    %rsp,%rax\n  lea    -0x3(%rsi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\n  mov    0x4(%rax),%edx\n  add    0x8(%rax),%edx\n  add    (%rax),%edx\n  mov    %edx,0xc(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    115c <func0+0x43>\n  movslq %esi,%rsi\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    1191 <func0+0x78>\n  add    $0x1a8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %edi,%esi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x32,%ecx\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%esi\n  jle    L0\n  mov    %rsp,%rax\n  lea    -0x3(%rsi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\nL1:\n  mov    0x4(%rax),%edx\n  add    0x8(%rax),%edx\n  add    (%rax),%edx\n  mov    %edx,0xc(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L1\nL0:\n  movslq %esi,%rsi\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L2\n  add    $0x1a8,%rsp\n  ret\nL2:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4464
        },
        "L1": {
          "label": "L1",
          "addr": 4444
        },
        "L2": {
          "label": "L2",
          "addr": 4497
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[100];\n  int i;\n  for (i = 0; i < 100; i++)\n    arr[i] = 0;\n  arr[1] = 1;\n  for (i = 2; i < n; i++)\n    arr[i] = arr[i - 1] + arr[i - 2] + arr[i - 3];\n  return arr[n];\n}"
    },
    {
      "task_id": 63,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movslq %edi,%rsi\n  mov    $0x32,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r9\n  mov    %r9,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%esi\n  jle    11d7 <func0+0xb7>\n  lea    -0x1(%rsi),%r11d\n  cmp    $0x5,%esi\n  jle    11f5 <func0+0xd5>\n  lea    0xc(%rsp),%r8\n  mov    $0x1,%edi\n  xor    %edx,%edx\n  mov    $0x3,%ecx\n  lea    (%rdx,%rdi,1),%r10d\n  add    $0xc,%r8\n  add    %r10d,%eax\n  lea    (%rax,%rdi,1),%r10d\n  movd   %eax,%xmm0\n  add    %r10d,%edx\n  lea    (%rax,%rdx,1),%r10d\n  movd   %edx,%xmm1\n  add    %r10d,%edi\n  mov    %ecx,%r10d\n  punpckldq %xmm1,%xmm0\n  add    $0x3,%ecx\n  add    $0x4,%r10d\n  movq   %xmm0,-0xc(%r8)\n  mov    %edi,-0x4(%r8)\n  cmp    %r10d,%r11d\n  jg     117a <func0+0x5a>\n  movslq %ecx,%rax\n  lea    (%r9,%rax,4),%rax\n  nop\n  mov    -0x4(%rax),%edx\n  add    $0x1,%ecx\n  add    -0x8(%rax),%edx\n  add    $0x4,%rax\n  add    -0x10(%rax),%edx\n  mov    %edx,-0x4(%rax)\n  cmp    %ecx,%esi\n  jge    11c0 <func0+0xa0>\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    11fc <func0+0xdc>\n  add    $0x1a8,%rsp\n  ret\n  mov    $0x3,%ecx\n  jmp    11b8 <func0+0x98>\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movslq %edi,%rsi\n  mov    $0x32,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r9\n  mov    %r9,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%esi\n  jle    L0\n  lea    -0x1(%rsi),%r11d\n  cmp    $0x5,%esi\n  jle    L1\n  lea    0xc(%rsp),%r8\n  mov    $0x1,%edi\n  xor    %edx,%edx\n  mov    $0x3,%ecx\nL2:\n  lea    (%rdx,%rdi,1),%r10d\n  add    $0xc,%r8\n  add    %r10d,%eax\n  lea    (%rax,%rdi,1),%r10d\n  movd   %eax,%xmm0\n  add    %r10d,%edx\n  lea    (%rax,%rdx,1),%r10d\n  movd   %edx,%xmm1\n  add    %r10d,%edi\n  mov    %ecx,%r10d\n  punpckldq %xmm1,%xmm0\n  add    $0x3,%ecx\n  add    $0x4,%r10d\n  movq   %xmm0,-0xc(%r8)\n  mov    %edi,-0x4(%r8)\n  cmp    %r10d,%r11d\n  jg     L2\nL5:\n  movslq %ecx,%rax\n  lea    (%r9,%rax,4),%rax\n  nop\nL3:\n  mov    -0x4(%rax),%edx\n  add    $0x1,%ecx\n  add    -0x8(%rax),%edx\n  add    $0x4,%rax\n  add    -0x10(%rax),%edx\n  mov    %edx,-0x4(%rax)\n  cmp    %ecx,%esi\n  jge    L3\nL0:\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L4\n  add    $0x1a8,%rsp\n  ret\nL1:\n  mov    $0x3,%ecx\n  jmp    L5\nL4:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4567
        },
        "L1": {
          "label": "L1",
          "addr": 4597
        },
        "L2": {
          "label": "L2",
          "addr": 4474
        },
        "L3": {
          "label": "L3",
          "addr": 4544
        },
        "L4": {
          "label": "L4",
          "addr": 4604
        },
        "L5": {
          "label": "L5",
          "addr": 4536
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[100] = {0, 1};\n  int i;\n  for (i = 3; i <= n; i++) {\n    arr[i] = arr[i - 3] + arr[i - 2] + arr[i - 1];\n  }\n  return arr[n];\n}"
    },
    {
      "task_id": 62,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
      "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  cmp    $0x1,%esi\n  jle    11e8 <func0+0xe8>\n  lea    0x8(%rdi),%rdi\n  mov    %rdx,%rax\n  sub    %rdi,%rax\n  cmp    $0x8,%rax\n  jbe    11f0 <func0+0xf0>\n  cmp    $0x2,%esi\n  je     11f0 <func0+0xf0>\n  lea    -0x2(%rsi),%eax\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%eax\n  jbe    121d <func0+0x11d>\n  mov    %r8d,%edi\n  movdqa 0xeb8(%rip),%xmm1        # 2000 <_fini+0xdd4>\n  movdqa 0xec0(%rip),%xmm2        # 2010 <_fini+0xde4>\n  xor    %eax,%eax\n  shr    $0x2,%edi\n  shl    $0x4,%rdi\n  nopl   0x0(%rax)\n  movups 0x4(%rcx,%rax,1),%xmm3\n  movdqa %xmm1,%xmm0\n  paddd  %xmm2,%xmm1\n  cvtdq2ps %xmm0,%xmm0\n  mulps  %xmm3,%xmm0\n  movups %xmm0,(%rdx,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rdi\n  jne    1160 <func0+0x60>\n  mov    %r8d,%r9d\n  and    $0xfffffffc,%r9d\n  lea    0x1(%r9),%edi\n  mov    %edi,%eax\n  cmp    %r9d,%r8d\n  je     11e8 <func0+0xe8>\n  sub    %r9d,%esi\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%esi\n  je     11cc <func0+0xcc>\n  mov    %edi,%esi\n  lea    0x1(%rax),%edi\n  movd   %eax,%xmm0\n  movq   (%rcx,%rsi,4),%xmm1\n  movd   %edi,%xmm4\n  punpckldq %xmm4,%xmm0\n  cvtdq2ps %xmm0,%xmm0\n  mulps  %xmm1,%xmm0\n  movlps %xmm0,-0x4(%rdx,%rsi,4)\n  mov    %r8d,%esi\n  and    $0xfffffffe,%esi\n  add    %esi,%eax\n  cmp    %esi,%r8d\n  je     11e8 <func0+0xe8>\n  movslq %eax,%rsi\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rcx,%rsi,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rsi,4)\n  ret\n  nopl   0x0(%rax,%rax,1)\n  ret\n  nopl   0x0(%rax)\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  nopl   0x0(%rax,%rax,1)\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rcx,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    1200 <func0+0x100>\n  ret\n  mov    $0x1,%eax\n  mov    $0x1,%edi\n  jmp    119e <func0+0x9e>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  cmp    $0x1,%esi\n  jle    L0\n  lea    0x8(%rdi),%rdi\n  mov    %rdx,%rax\n  sub    %rdi,%rax\n  cmp    $0x8,%rax\n  jbe    L1\n  cmp    $0x2,%esi\n  je     L1\n  lea    -0x2(%rsi),%eax\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%eax\n  jbe    L2\n  mov    %r8d,%edi\n  movdqa D0(%rip),%xmm1\n  movdqa D1(%rip),%xmm2\n  xor    %eax,%eax\n  shr    $0x2,%edi\n  shl    $0x4,%rdi\n  nopl   0x0(%rax)\nL3:\n  movups 0x4(%rcx,%rax,1),%xmm3\n  movdqa %xmm1,%xmm0\n  paddd  %xmm2,%xmm1\n  cvtdq2ps %xmm0,%xmm0\n  mulps  %xmm3,%xmm0\n  movups %xmm0,(%rdx,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rdi\n  jne    L3\n  mov    %r8d,%r9d\n  and    $0xfffffffc,%r9d\n  lea    0x1(%r9),%edi\n  mov    %edi,%eax\n  cmp    %r9d,%r8d\n  je     L0\n  sub    %r9d,%esi\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%esi\n  je     L4\nL6:\n  mov    %edi,%esi\n  lea    0x1(%rax),%edi\n  movd   %eax,%xmm0\n  movq   (%rcx,%rsi,4),%xmm1\n  movd   %edi,%xmm4\n  punpckldq %xmm4,%xmm0\n  cvtdq2ps %xmm0,%xmm0\n  mulps  %xmm1,%xmm0\n  movlps %xmm0,-0x4(%rdx,%rsi,4)\n  mov    %r8d,%esi\n  and    $0xfffffffe,%esi\n  add    %esi,%eax\n  cmp    %esi,%r8d\n  je     L0\nL4:\n  movslq %eax,%rsi\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rcx,%rsi,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rsi,4)\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  ret\n  nopl   0x0(%rax)\nL1:\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  nopl   0x0(%rax,%rax,1)\nL5:\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rcx,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    L5\n  ret\nL2:\n  mov    $0x1,%eax\n  mov    $0x1,%edi\n  jmp    L6",
      "num_missing": 2,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3768
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3776
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4584
        },
        "L1": {
          "label": "L1",
          "addr": 4592
        },
        "L2": {
          "label": "L2",
          "addr": 4637
        },
        "L3": {
          "label": "L3",
          "addr": 4448
        },
        "L4": {
          "label": "L4",
          "addr": 4556
        },
        "L5": {
          "label": "L5",
          "addr": 4608
        },
        "L6": {
          "label": "L6",
          "addr": 4510
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0100000002000000030000000400000004000000040000000400000004000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              1,
              0,
              0,
              0,
              2,
              0,
              0,
              0,
              3,
              0,
              0,
              0,
              4,
              0,
              0,
              0
            ]
          },
          "0x2010": {
            "type": "byte[16]",
            "value": [
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(float *x, int n, float *y) {\n  int i;\n  for (i = 1; i < n; i++)\n    y[i - 1] = i * x[i];\n}"
    },
    {
      "task_id": 63,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movslq %edi,%r8\n  mov    $0x32,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%r8d\n  jle    1190 <func0+0x70>\n  lea    -0x3(%r8),%edx\n  lea    0x4(%rsp),%rax\n  xor    %esi,%esi\n  lea    0x8(%rsp,%rdx,4),%rdi\n  mov    $0x1,%edx\n  jmp    1180 <func0+0x60>\n  nopl   0x0(%rax)\n  mov    0x4(%rax),%edx\n  mov    (%rax),%ecx\n  mov    -0x4(%rax),%esi\n  add    %ecx,%edx\n  add    $0x4,%rax\n  add    %esi,%edx\n  mov    %edx,0x4(%rax)\n  cmp    %rdi,%rax\n  jne    1178 <func0+0x58>\n  mov    (%rsp,%r8,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    11af <func0+0x8f>\n  add    $0x1a8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movslq %edi,%r8\n  mov    $0x32,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%r8d\n  jle    L0\n  lea    -0x3(%r8),%edx\n  lea    0x4(%rsp),%rax\n  xor    %esi,%esi\n  lea    0x8(%rsp,%rdx,4),%rdi\n  mov    $0x1,%edx\n  jmp    L1\n  nopl   0x0(%rax)\nL2:\n  mov    0x4(%rax),%edx\n  mov    (%rax),%ecx\n  mov    -0x4(%rax),%esi\nL1:\n  add    %ecx,%edx\n  add    $0x4,%rax\n  add    %esi,%edx\n  mov    %edx,0x4(%rax)\n  cmp    %rdi,%rax\n  jne    L2\nL0:\n  mov    (%rsp,%r8,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L3\n  add    $0x1a8,%rsp\n  ret\nL3:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4496
        },
        "L1": {
          "label": "L1",
          "addr": 4480
        },
        "L2": {
          "label": "L2",
          "addr": 4472
        },
        "L3": {
          "label": "L3",
          "addr": 4527
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int arr[100];\n  int i;\n  for (i = 0; i < 100; i++)\n    arr[i] = 0;\n  arr[1] = 1;\n  for (i = 2; i < n; i++)\n    arr[i] = arr[i - 1] + arr[i - 2] + arr[i - 3];\n  return arr[n];\n}"
    },
    {
      "task_id": 58,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %ecx,-0x30(%rbp)\n  mov    %r8,-0x40(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1238 <func0+0x11f>\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11ac <func0+0x93>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    11a8 <func0+0x8f>\n  movl   $0x1,-0x10(%rbp)\n  jmp    11b4 <func0+0x9b>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     116f <func0+0x56>\n  cmpl   $0x0,-0x10(%rbp)\n  jne    1234 <func0+0x11b>\n  movl   $0x0,-0x18(%rbp)\n  jmp    122c <func0+0x113>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    1228 <func0+0x10f>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  jmp    1234 <func0+0x11b>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     11c3 <func0+0xaa>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     115f <func0+0x46>\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1311 <func0+0x1f8>\n  movl   $0x0,-0x18(%rbp)\n  jmp    12fb <func0+0x1e2>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    12f7 <func0+0x1de>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     125c <func0+0x143>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x20(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     1250 <func0+0x137>\n  mov    -0x40(%rbp),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %ecx,-0x30(%rbp)\n  mov    %r8,-0x40(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL9:\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L1\nL4:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L2\n  movl   $0x1,-0x10(%rbp)\n  jmp    L3\nL2:\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     L4\nL3:\n  cmpl   $0x0,-0x10(%rbp)\n  jne    L5\n  movl   $0x0,-0x18(%rbp)\n  jmp    L6\nL8:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L7\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  jmp    L5\nL7:\n  addl   $0x1,-0x18(%rbp)\nL6:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L8\nL5:\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L9\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L10\nL14:\n  movl   $0x0,-0x18(%rbp)\n  jmp    L11\nL13:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L12\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\nL12:\n  addl   $0x1,-0x18(%rbp)\nL11:\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     L13\n  addl   $0x1,-0x1c(%rbp)\nL10:\n  mov    -0x20(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     L14\n  mov    -0x40(%rbp),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4664
        },
        "L1": {
          "label": "L1",
          "addr": 4524
        },
        "L2": {
          "label": "L2",
          "addr": 4520
        },
        "L3": {
          "label": "L3",
          "addr": 4532
        },
        "L4": {
          "label": "L4",
          "addr": 4463
        },
        "L5": {
          "label": "L5",
          "addr": 4660
        },
        "L6": {
          "label": "L6",
          "addr": 4652
        },
        "L7": {
          "label": "L7",
          "addr": 4648
        },
        "L8": {
          "label": "L8",
          "addr": 4547
        },
        "L9": {
          "label": "L9",
          "addr": 4447
        },
        "L10": {
          "label": "L10",
          "addr": 4881
        },
        "L11": {
          "label": "L11",
          "addr": 4859
        },
        "L12": {
          "label": "L12",
          "addr": 4855
        },
        "L13": {
          "label": "L13",
          "addr": 4700
        },
        "L14": {
          "label": "L14",
          "addr": 4688
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int m, int *y, int n, int *ret) {\n  int *a = malloc(m * sizeof(int));\n  int i, j, k, l, f;\n  l = 0;\n  for (i = 0; i < m; i++) {\n    f = 0;\n    for (j = 0; j < l; j++) {\n      if (a[j] == x[i]) {\n        f = 1;\n        break;\n      }\n    }\n    if (!f) {\n      for (k = 0; k < n; k++) {\n        if (x[i] == y[k]) {\n          a[l++] = x[i];\n          break;\n        }\n      }\n    }\n  }\n  for (i = 0; i < l - 1; i++) {\n    for (j = 0; j < l - i - 1; j++) {\n      if (a[j] > a[j + 1]) {\n        int tmp = a[j];\n        a[j] = a[j + 1];\n        a[j + 1] = tmp;\n      }\n    }\n  }\n  *ret = l;\n  return a;\n}"
    },
    {
      "task_id": 58,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %esi,%r13d\n  mov    %rdx,%r12\n  mov    %ecx,%ebp\n  mov    %r8,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r9\n  test   %r13d,%r13d\n  jle    11f2 <func0+0xd9>\n  mov    %r14,%rsi\n  lea    -0x1(%r13),%eax\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%rbp),%eax\n  lea    0x4(%r12,%rax,4),%rdi\n  mov    $0x0,%r8d\n  lea    0x4(%r9),%r11\n  jmp    117f <func0+0x66>\n  movslq %r8d,%rax\n  mov    %edx,(%r9,%rax,4)\n  lea    0x1(%r8),%r8d\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  je     11b6 <func0+0x9d>\n  test   %r8d,%r8d\n  jle    119e <func0+0x85>\n  mov    (%rsi),%edx\n  mov    %r9,%rax\n  lea    -0x1(%r8),%ecx\n  lea    (%r11,%rcx,4),%rcx\n  cmp    %edx,(%rax)\n  je     1176 <func0+0x5d>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    1191 <func0+0x78>\n  test   %ebp,%ebp\n  jle    1176 <func0+0x5d>\n  mov    (%rsi),%edx\n  mov    %r12,%rax\n  cmp    (%rax),%edx\n  je     116b <func0+0x52>\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    11a7 <func0+0x8e>\n  jmp    1176 <func0+0x5d>\n  lea    -0x1(%r8),%edi\n  test   %edi,%edi\n  jle    11f8 <func0+0xdf>\n  lea    0x4(%r9),%r10\n  jmp    11e2 <func0+0xc9>\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  je     11dd <func0+0xc4>\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11c4 <func0+0xab>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    11c4 <func0+0xab>\n  sub    $0x1,%edi\n  je     11f8 <func0+0xdf>\n  test   %edi,%edi\n  jle    11dd <func0+0xc4>\n  mov    %r9,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r10,%rdx,4),%rsi\n  jmp    11cd <func0+0xb4>\n  mov    $0x0,%r8d\n  mov    %r8d,(%rbx)\n  mov    %r9,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %esi,%r13d\n  mov    %rdx,%r12\n  mov    %ecx,%ebp\n  mov    %r8,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r9\n  test   %r13d,%r13d\n  jle    L0\n  mov    %r14,%rsi\n  lea    -0x1(%r13),%eax\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%rbp),%eax\n  lea    0x4(%r12,%rax,4),%rdi\n  mov    $0x0,%r8d\n  lea    0x4(%r9),%r11\n  jmp    L1\nL6:\n  movslq %r8d,%rax\n  mov    %edx,(%r9,%rax,4)\n  lea    0x1(%r8),%r8d\nL4:\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  je     L2\nL1:\n  test   %r8d,%r8d\n  jle    L3\n  mov    (%rsi),%edx\n  mov    %r9,%rax\n  lea    -0x1(%r8),%ecx\n  lea    (%r11,%rcx,4),%rcx\nL5:\n  cmp    %edx,(%rax)\n  je     L4\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L5\nL3:\n  test   %ebp,%ebp\n  jle    L4\n  mov    (%rsi),%edx\n  mov    %r12,%rax\nL7:\n  cmp    (%rax),%edx\n  je     L6\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    L7\n  jmp    L4\nL2:\n  lea    -0x1(%r8),%edi\n  test   %edi,%edi\n  jle    L8\n  lea    0x4(%r9),%r10\n  jmp    L9\nL11:\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  je     L10\nL12:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L11\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    L11\nL10:\n  sub    $0x1,%edi\n  je     L8\nL9:\n  test   %edi,%edi\n  jle    L10\n  mov    %r9,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r10,%rdx,4),%rsi\n  jmp    L12\nL0:\n  mov    $0x0,%r8d\nL8:\n  mov    %r8d,(%rbx)\n  mov    %r9,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4594
        },
        "L1": {
          "label": "L1",
          "addr": 4479
        },
        "L2": {
          "label": "L2",
          "addr": 4534
        },
        "L3": {
          "label": "L3",
          "addr": 4510
        },
        "L4": {
          "label": "L4",
          "addr": 4470
        },
        "L5": {
          "label": "L5",
          "addr": 4497
        },
        "L6": {
          "label": "L6",
          "addr": 4459
        },
        "L7": {
          "label": "L7",
          "addr": 4519
        },
        "L8": {
          "label": "L8",
          "addr": 4600
        },
        "L9": {
          "label": "L9",
          "addr": 4578
        },
        "L10": {
          "label": "L10",
          "addr": 4573
        },
        "L11": {
          "label": "L11",
          "addr": 4548
        },
        "L12": {
          "label": "L12",
          "addr": 4557
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int m, int *y, int n, int *ret) {\n  int i, j, k, *z;\n  z = (int *)malloc(m * sizeof(int));\n  k = 0;\n  for (i = 0; i < m; i++) {\n    for (j = 0; j < k; j++) {\n      if (z[j] == x[i])\n        goto L1;\n    }\n    for (j = 0; j < n; j++) {\n      if (x[i] == y[j]) {\n        z[k++] = x[i];\n        goto L1;\n      }\n    }\n  L1:;\n  }\n  for (i = k - 1; i > 0; i--) {\n    for (j = 0; j < i; j++) {\n      if (z[j] > z[j + 1]) {\n        k = z[j];\n        z[j] = z[j + 1];\n        z[j + 1] = k;\n      }\n    }\n  }\n  *ret = k;\n  return z;\n}"
    },
    {
      "task_id": 58,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rdi,%r14\n  movslq %esi,%rdi\n  push   %r13\n  mov    %rdi,%r13\n  shl    $0x2,%rdi\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %r8,%rbx\n  call   1050 <malloc@plt>\n  mov    %rax,%r8\n  test   %r13d,%r13d\n  jle    122a <func0+0x10a>\n  lea    -0x1(%r13),%eax\n  mov    %r14,%rsi\n  lea    0x4(%r8),%r11\n  xor    %r9d,%r9d\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%r12),%eax\n  lea    0x4(%rbp,%rax,4),%rdi\n  test   %r9d,%r9d\n  je     11f0 <func0+0xd0>\n  lea    -0x1(%r9),%ecx\n  mov    (%rsi),%edx\n  mov    %r8,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    1191 <func0+0x71>\n  nopl   0x0(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     11f0 <func0+0xd0>\n  cmp    %edx,(%rax)\n  jne    1188 <func0+0x68>\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  jne    1170 <func0+0x50>\n  lea    -0x1(%r9),%edx\n  test   %edx,%edx\n  jle    11dd <func0+0xbd>\n  lea    0x4(%r8),%r10\n  nopw   0x0(%rax,%rax,1)\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r10,%rdx,4),%rsi\n  nopl   (%rax)\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11ce <func0+0xae>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    11c0 <func0+0xa0>\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    11b0 <func0+0x90>\n  mov    %r9d,(%rbx)\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\n  test   %r12d,%r12d\n  jle    1195 <func0+0x75>\n  mov    (%rsi),%edx\n  mov    %rbp,%rax\n  jmp    1209 <func0+0xe9>\n  nopl   0x0(%rax)\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     1195 <func0+0x75>\n  cmp    (%rax),%edx\n  jne    1200 <func0+0xe0>\n  movslq %r9d,%rax\n  add    $0x4,%rsi\n  add    $0x1,%r9d\n  mov    %edx,(%r8,%rax,4)\n  cmp    %r10,%rsi\n  jne    1170 <func0+0x50>\n  jmp    119e <func0+0x7e>\n  xor    %r9d,%r9d\n  mov    %r8,%rax\n  mov    %r9d,(%rbx)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rdi,%r14\n  movslq %esi,%rdi\n  push   %r13\n  mov    %rdi,%r13\n  shl    $0x2,%rdi\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %r8,%rbx\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%eax\n  mov    %r14,%rsi\n  lea    0x4(%r8),%r11\n  xor    %r9d,%r9d\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%r12),%eax\n  lea    0x4(%rbp,%rax,4),%rdi\nL4:\n  test   %r9d,%r9d\n  je     L1\n  lea    -0x1(%r9),%ecx\n  mov    (%rsi),%edx\n  mov    %r8,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    L2\n  nopl   0x0(%rax)\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\nL9:\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  jne    L4\nL12:\n  lea    -0x1(%r9),%edx\n  test   %edx,%edx\n  jle    L5\n  lea    0x4(%r8),%r10\n  nopw   0x0(%rax,%rax,1)\nL8:\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r10,%rdx,4),%rsi\n  nopl   (%rax)\nL7:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L6\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\nL6:\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    L7\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    L8\nL5:\n  mov    %r9d,(%rbx)\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\nL1:\n  test   %r12d,%r12d\n  jle    L9\n  mov    (%rsi),%edx\n  mov    %rbp,%rax\n  jmp    L10\n  nopl   0x0(%rax)\nL11:\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     L9\nL10:\n  cmp    (%rax),%edx\n  jne    L11\n  movslq %r9d,%rax\n  add    $0x4,%rsi\n  add    $0x1,%r9d\n  mov    %edx,(%r8,%rax,4)\n  cmp    %r10,%rsi\n  jne    L4\n  jmp    L12\nL0:\n  xor    %r9d,%r9d\n  mov    %r8,%rax\n  mov    %r9d,(%rbx)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4650
        },
        "L1": {
          "label": "L1",
          "addr": 4592
        },
        "L2": {
          "label": "L2",
          "addr": 4497
        },
        "L3": {
          "label": "L3",
          "addr": 4488
        },
        "L4": {
          "label": "L4",
          "addr": 4464
        },
        "L5": {
          "label": "L5",
          "addr": 4573
        },
        "L6": {
          "label": "L6",
          "addr": 4558
        },
        "L7": {
          "label": "L7",
          "addr": 4544
        },
        "L8": {
          "label": "L8",
          "addr": 4528
        },
        "L9": {
          "label": "L9",
          "addr": 4501
        },
        "L10": {
          "label": "L10",
          "addr": 4617
        },
        "L11": {
          "label": "L11",
          "addr": 4608
        },
        "L12": {
          "label": "L12",
          "addr": 4510
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int *y, int m, int *ret) {\n  int i, j, k, *r;\n  r = (int *)malloc(n * sizeof(int));\n  k = 0;\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < k; j++) {\n      if (r[j] == x[i])\n        break;\n    }\n    if (j == k) {\n      for (j = 0; j < m; j++) {\n        if (y[j] == x[i]) {\n          r[k] = x[i];\n          k++;\n          break;\n        }\n      }\n    }\n  }\n  for (i = k - 1; i > 0; i--) {\n    for (j = 0; j < i; j++) {\n      if (r[j] > r[j + 1]) {\n        k = r[j];\n        r[j] = r[j + 1];\n        r[j + 1] = k;\n      }\n    }\n  }\n  *ret = k;\n  return r;\n}"
    },
    {
      "task_id": 58,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rdi,%r14\n  movslq %esi,%rdi\n  push   %r13\n  mov    %rdi,%r13\n  shl    $0x2,%rdi\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %r8,%rbx\n  call   1050 <malloc@plt>\n  mov    %rax,%r8\n  test   %r13d,%r13d\n  jle    1246 <func0+0x126>\n  lea    -0x1(%r13),%eax\n  mov    %r14,%rsi\n  lea    0x4(%r8),%r11\n  xor    %r9d,%r9d\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%r12),%eax\n  lea    0x4(%rbp,%rax,4),%rdi\n  test   %r9d,%r9d\n  je     1208 <func0+0xe8>\n  lea    -0x1(%r9),%ecx\n  mov    (%rsi),%edx\n  mov    %r8,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    1199 <func0+0x79>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     1208 <func0+0xe8>\n  cmp    %edx,(%rax)\n  jne    1190 <func0+0x70>\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  jne    1170 <func0+0x50>\n  lea    -0x1(%r9),%eax\n  test   %eax,%eax\n  jle    11f5 <func0+0xd5>\n  lea    0x4(%r8),%r10\n  nopw   0x0(%rax,%rax,1)\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%r10,%rax,4),%rsi\n  nopl   (%rax)\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    11e6 <func0+0xc6>\n  movq   %xmm1,(%rdx)\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    11c8 <func0+0xa8>\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    11b8 <func0+0x98>\n  mov    %r9d,(%rbx)\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\n  test   %r12d,%r12d\n  jle    119d <func0+0x7d>\n  mov    (%rsi),%edx\n  mov    %rbp,%rax\n  jmp    1225 <func0+0x105>\n  nopl   0x0(%rax)\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     119d <func0+0x7d>\n  cmp    (%rax),%edx\n  jne    1218 <func0+0xf8>\n  movslq %r9d,%rax\n  add    $0x4,%rsi\n  add    $0x1,%r9d\n  mov    %edx,(%r8,%rax,4)\n  cmp    %r10,%rsi\n  jne    1170 <func0+0x50>\n  jmp    11a6 <func0+0x86>\n  xor    %r9d,%r9d\n  mov    %r8,%rax\n  mov    %r9d,(%rbx)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rdi,%r14\n  movslq %esi,%rdi\n  push   %r13\n  mov    %rdi,%r13\n  shl    $0x2,%rdi\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %r8,%rbx\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%eax\n  mov    %r14,%rsi\n  lea    0x4(%r8),%r11\n  xor    %r9d,%r9d\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%r12),%eax\n  lea    0x4(%rbp,%rax,4),%rdi\nL4:\n  test   %r9d,%r9d\n  je     L1\n  lea    -0x1(%r9),%ecx\n  mov    (%rsi),%edx\n  mov    %r8,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\nL9:\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  jne    L4\nL12:\n  lea    -0x1(%r9),%eax\n  test   %eax,%eax\n  jle    L5\n  lea    0x4(%r8),%r10\n  nopw   0x0(%rax,%rax,1)\nL8:\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%r10,%rax,4),%rsi\n  nopl   (%rax)\nL7:\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    L6\n  movq   %xmm1,(%rdx)\nL6:\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    L7\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    L8\nL5:\n  mov    %r9d,(%rbx)\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\nL1:\n  test   %r12d,%r12d\n  jle    L9\n  mov    (%rsi),%edx\n  mov    %rbp,%rax\n  jmp    L10\n  nopl   0x0(%rax)\nL11:\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     L9\nL10:\n  cmp    (%rax),%edx\n  jne    L11\n  movslq %r9d,%rax\n  add    $0x4,%rsi\n  add    $0x1,%r9d\n  mov    %edx,(%r8,%rax,4)\n  cmp    %r10,%rsi\n  jne    L4\n  jmp    L12\nL0:\n  xor    %r9d,%r9d\n  mov    %r8,%rax\n  mov    %r9d,(%rbx)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4678
        },
        "L1": {
          "label": "L1",
          "addr": 4616
        },
        "L2": {
          "label": "L2",
          "addr": 4505
        },
        "L3": {
          "label": "L3",
          "addr": 4496
        },
        "L4": {
          "label": "L4",
          "addr": 4464
        },
        "L5": {
          "label": "L5",
          "addr": 4597
        },
        "L6": {
          "label": "L6",
          "addr": 4582
        },
        "L7": {
          "label": "L7",
          "addr": 4552
        },
        "L8": {
          "label": "L8",
          "addr": 4536
        },
        "L9": {
          "label": "L9",
          "addr": 4509
        },
        "L10": {
          "label": "L10",
          "addr": 4645
        },
        "L11": {
          "label": "L11",
          "addr": 4632
        },
        "L12": {
          "label": "L12",
          "addr": 4518
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int m, int *y, int n, int *ret) {\n  int i, j, k;\n  int *z;\n  z = (int *)malloc(m * sizeof(int));\n  k = 0;\n  for (i = 0; i < m; i++) {\n    for (j = 0; j < k; j++) {\n      if (z[j] == x[i])\n        break;\n    }\n    if (j == k) {\n      for (j = 0; j < n; j++) {\n        if (y[j] == x[i]) {\n          z[k] = x[i];\n          k++;\n          break;\n        }\n      }\n    }\n  }\n  for (i = 0; i < k - 1; i++) {\n    for (j = i + 1; j < k; j++) {\n      if (z[i] > z[j]) {\n        int tmp = z[i];\n        z[i] = z[j];\n        z[j] = tmp;\n      }\n    }\n  }\n  *ret = k;\n  return z;\n}"
    },
    {
      "task_id": 66,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1157 <func0+0x5e>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x40,%al\n  jle    1153 <func0+0x5a>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5a,%al\n  jg     1153 <func0+0x5a>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1115 <func0+0x1c>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x40,%al\n  jle    L1\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5a,%al\n  jg     L1\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  add    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4439
        },
        "L1": {
          "label": "L1",
          "addr": 4435
        },
        "L2": {
          "label": "L2",
          "addr": 4373
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *input) {\n  int result = 0;\n  for (int i = 0; input[i] != '\\0'; i++) {\n    if (input[i] >= 'A' && input[i] <= 'Z') {\n      result += input[i];\n    }\n  }\n  return result;\n}"
    },
    {
      "task_id": 66,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     112a <func0+0x31>\n  add    $0x1,%rdi\n  mov    $0x0,%edx\n  lea    -0x41(%rax),%ecx\n  movsbl %al,%eax\n  add    %edx,%eax\n  cmp    $0x1a,%cl\n  cmovb  %eax,%edx\n  add    $0x1,%rdi\n  movzbl -0x1(%rdi),%eax\n  test   %al,%al\n  jne    110d <func0+0x14>\n  mov    %edx,%eax\n  ret\n  mov    $0x0,%edx\n  jmp    1127 <func0+0x2e>",
      "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  mov    $0x0,%edx\nL1:\n  lea    -0x41(%rax),%ecx\n  movsbl %al,%eax\n  add    %edx,%eax\n  cmp    $0x1a,%cl\n  cmovb  %eax,%edx\n  add    $0x1,%rdi\n  movzbl -0x1(%rdi),%eax\n  test   %al,%al\n  jne    L1\nL2:\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x0,%edx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4394
        },
        "L1": {
          "label": "L1",
          "addr": 4365
        },
        "L2": {
          "label": "L2",
          "addr": 4391
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *input) {\n  int i, sum = 0;\n  for (i = 0; input[i] != '\\0'; i++) {\n    if (input[i] >= 'A' && input[i] <= 'Z') {\n      sum += input[i];\n    }\n  }\n  return sum;\n}"
    },
    {
      "task_id": 64,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r15\n  call   1060 <strlen@plt>\n  test   %eax,%eax\n  jle    11b3 <func0+0x7a>\n  mov    %rax,%r14\n  mov    %r15,%rbx\n  lea    -0x1(%rax),%eax\n  lea    0x1(%r15,%rax,1),%r13\n  mov    $0x0,%ebp\n  lea    0xe8f(%rip),%r12        # 2000 <_fini+0xe44>\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%ebp\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    1171 <func0+0x38>\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebp\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    $0x0,%ebp\n  jmp    11a2 <func0+0x69>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r15\n  call   <strlen@plt>\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r14\n  mov    %r15,%rbx\n  lea    -0x1(%rax),%eax\n  lea    0x1(%r15,%rax,1),%r13\n  mov    $0x0,%ebp\n  lea    D0(%rip),%r12\nL1:\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%ebp\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    L1\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebp\nL2:\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  mov    $0x0,%ebp\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3727
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4531
        },
        "L1": {
          "label": "L1",
          "addr": 4465
        },
        "L2": {
          "label": "L2",
          "addr": 4514
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  int i, j, len, count = 0;\n  len = strlen(s);\n  for (i = 0; i < len; i++) {\n    if (strchr(\"aeiouAEIOU\", s[i]))\n      count++;\n  }\n  if (s[len - 1] == 'y' || s[len - 1] == 'Y')\n    count++;\n  return count;\n}"
    },
    {
      "task_id": 64,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  test   %eax,%eax\n  jle    11c8 <func0+0x88>\n  mov    %rax,%r14\n  lea    -0x1(%rax),%eax\n  mov    %r15,%rbx\n  xor    %r12d,%r12d\n  lea    0x1(%r15,%rax,1),%r13\n  lea    0xe8a(%rip),%rbp        # 2000 <_fini+0xe30>\n  cs nopw 0x0(%rax,%rax,1)\n  movsbl (%rbx),%esi\n  mov    %rbp,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    1180 <func0+0x40>\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\n  xor    %r12d,%r12d\n  jmp    11b3 <func0+0x73>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r14\n  lea    -0x1(%rax),%eax\n  mov    %r15,%rbx\n  xor    %r12d,%r12d\n  lea    0x1(%r15,%rax,1),%r13\n  lea    D0(%rip),%rbp\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  movsbl (%rbx),%esi\n  mov    %rbp,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    L1\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\nL2:\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\nL0:\n  xor    %r12d,%r12d\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3722
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4552
        },
        "L1": {
          "label": "L1",
          "addr": 4480
        },
        "L2": {
          "label": "L2",
          "addr": 4531
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  int i, j, len, count = 0;\n  len = strlen(s);\n  for (i = 0; i < len; i++) {\n    if (strchr(\"aeiouAEIOU\", s[i]))\n      count++;\n  }\n  if (s[len - 1] == 'y' || s[len - 1] == 'Y')\n    count++;\n  return count;\n}"
    },
    {
      "task_id": 66,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  test   %al,%al\n  je     1138 <func0+0x38>\n  add    $0x1,%rdi\n  xor    %r8d,%r8d\n  nopw   0x0(%rax,%rax,1)\n  lea    -0x41(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0x1a,%dl\n  cmovb  %eax,%r8d\n  movsbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  jne    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  xor    %r8d,%r8d\n  nopw   0x0(%rax,%rax,1)\nL1:\n  lea    -0x41(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0x1a,%dl\n  cmovb  %eax,%r8d\n  movsbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *input) {\n  int i = 0;\n  int sum = 0;\n  while (input[i] != '\\0') {\n    if (input[i] >= 'A' && input[i] <= 'Z') {\n      sum += input[i];\n    }\n    i++;\n  }\n  return sum;\n}"
    },
    {
      "task_id": 66,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  test   %al,%al\n  je     1138 <func0+0x38>\n  add    $0x1,%rdi\n  xor    %r8d,%r8d\n  nopw   0x0(%rax,%rax,1)\n  lea    -0x41(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0x1a,%dl\n  cmovb  %eax,%r8d\n  movsbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  jne    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  xor    %r8d,%r8d\n  nopw   0x0(%rax,%rax,1)\nL1:\n  lea    -0x41(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0x1a,%dl\n  cmovb  %eax,%r8d\n  movsbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *input) {\n  int i = 0;\n  int sum = 0;\n  while (input[i] != '\\0') {\n    if (input[i] >= 'A' && input[i] <= 'Z') {\n      sum += input[i];\n    }\n    i++;\n  }\n  return sum;\n}"
    },
    {
      "task_id": 64,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  test   %eax,%eax\n  jle    11c8 <func0+0x88>\n  mov    %rax,%r14\n  lea    -0x1(%rax),%eax\n  mov    %r15,%rbx\n  xor    %r12d,%r12d\n  lea    0x1(%r15,%rax,1),%r13\n  lea    0xe8a(%rip),%rbp        # 2000 <_fini+0xe30>\n  cs nopw 0x0(%rax,%rax,1)\n  movsbl (%rbx),%esi\n  mov    %rbp,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    1180 <func0+0x40>\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\n  xor    %r12d,%r12d\n  jmp    11b3 <func0+0x73>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r14\n  lea    -0x1(%rax),%eax\n  mov    %r15,%rbx\n  xor    %r12d,%r12d\n  lea    0x1(%r15,%rax,1),%r13\n  lea    D0(%rip),%rbp\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  movsbl (%rbx),%esi\n  mov    %rbp,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    L1\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\nL2:\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\nL0:\n  xor    %r12d,%r12d\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3722
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4552
        },
        "L1": {
          "label": "L1",
          "addr": 4480
        },
        "L2": {
          "label": "L2",
          "addr": 4531
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  int i, j, len, count = 0;\n  len = strlen(s);\n  for (i = 0; i < len; i++) {\n    if (strchr(\"aeiouAEIOU\", s[i]))\n      count++;\n  }\n  if (s[len - 1] == 'y' || s[len - 1] == 'Y')\n    count++;\n  return count;\n}"
    },
    {
      "task_id": 64,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    0xeb0(%rip),%rax        # 2000 <_fini+0xe18>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11a1 <func0+0x68>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     119d <func0+0x64>\n  addl   $0x1,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     1173 <func0+0x3a>\n  cmpl   $0x0,-0xc(%rbp)\n  jle    11e1 <func0+0xa8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x79,%al\n  je     11dd <func0+0xa4>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x59,%al\n  jne    11e1 <func0+0xa8>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL2:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\n  addl   $0x1,-0x14(%rbp)\nL1:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L2\n  cmpl   $0x0,-0xc(%rbp)\n  jle    L3\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x79,%al\n  je     L4\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x59,%al\n  jne    L3\nL4:\n  addl   $0x1,-0x14(%rbp)\nL3:\n  mov    -0x14(%rbp),%eax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3760
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4513
        },
        "L1": {
          "label": "L1",
          "addr": 4509
        },
        "L2": {
          "label": "L2",
          "addr": 4467
        },
        "L3": {
          "label": "L3",
          "addr": 4577
        },
        "L4": {
          "label": "L4",
          "addr": 4573
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  char *vowels = \"aeiouAEIOU\";\n  int i, count = 0, len = strlen(s);\n  for (i = 0; i < len; i++) {\n    if (strchr(vowels, s[i]) != NULL) {\n      count++;\n    }\n  }\n  if (len > 0) {\n    if (s[len - 1] == 'y' || s[len - 1] == 'Y') {\n      count++;\n    }\n  }\n  return count;\n}"
    },
    {
      "task_id": 65,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x60,%rsp\n  mov    %edi,-0x54(%rbp)\n  mov    %esi,-0x58(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x54(%rbp),%eax\n  mov    %eax,%edx\n  lea    0xe3a(%rip),%rax        # 2000 <_fini+0xd10>\n  mov    %rax,%rsi\n  lea    0x2eb0(%rip),%rax        # 4080 <xs.0>\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   10d0 <sprintf@plt>\n  lea    0x2e9c(%rip),%rax        # 4080 <xs.0>\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,-0x44(%rbp)\n  mov    -0x44(%rbp),%eax\n  cmp    -0x58(%rbp),%eax\n  jge    1268 <func0+0xcf>\n  movl   $0x0,-0x48(%rbp)\n  jmp    1255 <func0+0xbc>\n  mov    -0x48(%rbp),%eax\n  cltq\n  lea    0x2e74(%rip),%rdx        # 4080 <xs.0>\n  movzbl (%rax,%rdx,1),%eax\n  mov    %al,-0x49(%rbp)\n  mov    -0x44(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x48(%rbp),%eax\n  cltq\n  lea    0x2e5b(%rip),%rdx        # 4080 <xs.0>\n  movzbl (%rax,%rdx,1),%edx\n  mov    -0x48(%rbp),%eax\n  cltq\n  lea    0x2e4b(%rip),%rcx        # 4080 <xs.0>\n  mov    %dl,(%rax,%rcx,1)\n  mov    -0x44(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x48(%rbp),%eax\n  cltq\n  lea    0x2e36(%rip),%rcx        # 4080 <xs.0>\n  movzbl -0x49(%rbp),%edx\n  mov    %dl,(%rax,%rcx,1)\n  addl   $0x1,-0x48(%rbp)\n  mov    -0x44(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x48(%rbp)\n  jl     1200 <func0+0x67>\n  jmp    12d2 <func0+0x139>\n  mov    -0x44(%rbp),%eax\n  cltq\n  mov    -0x58(%rbp),%edx\n  movslq %edx,%rdx\n  sub    %rdx,%rax\n  mov    %rax,%rcx\n  lea    0x2e00(%rip),%rax        # 4080 <xs.0>\n  lea    (%rcx,%rax,1),%rdx\n  lea    -0x40(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcpy@plt>\n  mov    -0x58(%rbp),%eax\n  cltq\n  movb   $0x0,-0x40(%rbp,%rax,1)\n  mov    -0x44(%rbp),%eax\n  sub    -0x58(%rbp),%eax\n  movslq %eax,%rdx\n  lea    -0x40(%rbp),%rax\n  lea    0x2dcf(%rip),%rcx        # 4080 <xs.0>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   10c0 <strncat@plt>\n  lea    -0x40(%rbp),%rax\n  mov    %rax,%rsi\n  lea    0x2db6(%rip),%rax        # 4080 <xs.0>\n  mov    %rax,%rdi\n  call   1090 <strcpy@plt>\n  lea    0x2da7(%rip),%rax        # 4080 <xs.0>\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     12ed <func0+0x154>\n  call   10b0 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x60,%rsp\n  mov    %edi,-0x54(%rbp)\n  mov    %esi,-0x58(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x54(%rbp),%eax\n  mov    %eax,%edx\n  lea    D0(%rip),%rax\n  mov    %rax,%rsi\n  lea    D1(%rip),%rax\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  lea    D1(%rip),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x44(%rbp)\n  mov    -0x44(%rbp),%eax\n  cmp    -0x58(%rbp),%eax\n  jge    L0\n  movl   $0x0,-0x48(%rbp)\n  jmp    L1\nL2:\n  mov    -0x48(%rbp),%eax\n  cltq\n  lea    D1(%rip),%rdx\n  movzbl (%rax,%rdx,1),%eax\n  mov    %al,-0x49(%rbp)\n  mov    -0x44(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x48(%rbp),%eax\n  cltq\n  lea    D1(%rip),%rdx\n  movzbl (%rax,%rdx,1),%edx\n  mov    -0x48(%rbp),%eax\n  cltq\n  lea    D1(%rip),%rcx\n  mov    %dl,(%rax,%rcx,1)\n  mov    -0x44(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x48(%rbp),%eax\n  cltq\n  lea    D1(%rip),%rcx\n  movzbl -0x49(%rbp),%edx\n  mov    %dl,(%rax,%rcx,1)\n  addl   $0x1,-0x48(%rbp)\nL1:\n  mov    -0x44(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x48(%rbp)\n  jl     L2\n  jmp    L3\nL0:\n  mov    -0x44(%rbp),%eax\n  cltq\n  mov    -0x58(%rbp),%edx\n  movslq %edx,%rdx\n  sub    %rdx,%rax\n  mov    %rax,%rcx\n  lea    D1(%rip),%rax\n  lea    (%rcx,%rax,1),%rdx\n  lea    -0x40(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  mov    -0x58(%rbp),%eax\n  cltq\n  movb   $0x0,-0x40(%rbp,%rax,1)\n  mov    -0x44(%rbp),%eax\n  sub    -0x58(%rbp),%eax\n  movslq %eax,%rdx\n  lea    -0x40(%rbp),%rax\n  lea    D1(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncat@plt>\n  lea    -0x40(%rbp),%rax\n  mov    %rax,%rsi\n  lea    D1(%rip),%rax\n  mov    %rax,%rdi\n  call   <strcpy@plt>\nL3:\n  lea    D1(%rip),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L4\n  call   <__stack_chk_fail@plt>\nL4:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3642
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 16512,
          "bias": [
            11952,
            11932,
            11892,
            11867,
            11851,
            11830,
            11776,
            11727,
            11702,
            11687
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4712
        },
        "L1": {
          "label": "L1",
          "addr": 4693
        },
        "L2": {
          "label": "L2",
          "addr": 4608
        },
        "L3": {
          "label": "L3",
          "addr": 4818
        },
        "L4": {
          "label": "L4",
          "addr": 4845
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(int x, int n) {\n  static char buf[100];\n  int i, len;\n  char c;\n  char tmp[40];\n  sprintf(buf, \"%d\", x);\n  len = strlen(buf);\n  if (len < n) {\n    for (i = 0; i < len / 2; i++) {\n      c = buf[i];\n      buf[i] = buf[len - 1 - i];\n      buf[len - 1 - i] = c;\n    }\n  } else {\n    strcpy(tmp, buf + len - n);\n    tmp[n] = '\\0';\n    strncat(tmp, buf, len - n);\n    strcpy(buf, tmp);\n  }\n  return buf;\n}"
    },
    {
      "task_id": 69,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   1070 <calloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0xffffffff,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    1221 <func0+0xe8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jl     121d <func0+0xe4>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    121d <func0+0xe4>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1178 <func0+0x3f>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <free@plt>\n  mov    -0x10(%rbp),%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   <calloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0xffffffff,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL2:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jl     L1\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    L1\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\nL1:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x10(%rbp),%eax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4641
        },
        "L1": {
          "label": "L1",
          "addr": 4637
        },
        "L2": {
          "label": "L2",
          "addr": 4472
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *nums, int numsSize) {\n  int *arr = (int *)calloc(numsSize + 1, sizeof(int));\n  int ret = -1;\n  for (int i = 0; i < numsSize; i++) {\n    arr[nums[i]]++;\n    if (arr[nums[i]] >= nums[i] && ret < nums[i]) {\n      ret = nums[i];\n    }\n  }\n  free(arr);\n  return ret;\n}"
    },
    {
      "task_id": 68,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1160 <func0+0x60>\n  movslq %esi,%rsi\n  xor    %ecx,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdi,%rcx,4),%r8d\n  mov    %ecx,%r9d\n  test   $0x1,%r8b\n  jne    113e <func0+0x3e>\n  cmp    $0xffffffff,%r10d\n  je     1138 <func0+0x38>\n  cmp    %eax,%r8d\n  jge    113e <func0+0x3e>\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  jne    1120 <func0+0x20>\n  cmp    $0xffffffff,%r10d\n  je     1160 <func0+0x60>\n  mov    %eax,(%rdx)\n  mov    %rdx,%rax\n  mov    %r10d,0x4(%rdx)\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rsi\n  xor    %ecx,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    (%rdi,%rcx,4),%r8d\n  mov    %ecx,%r9d\n  test   $0x1,%r8b\n  jne    L1\n  cmp    $0xffffffff,%r10d\n  je     L2\n  cmp    %eax,%r8d\n  jge    L1\nL2:\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\nL1:\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  jne    L3\n  cmp    $0xffffffff,%r10d\n  je     L0\n  mov    %eax,(%rdx)\n  mov    %rdx,%rax\n  mov    %r10d,0x4(%rdx)\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4448
        },
        "L1": {
          "label": "L1",
          "addr": 4414
        },
        "L2": {
          "label": "L2",
          "addr": 4408
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *arr, int size, int *dest) {\n  int min = -1, index = -1;\n  for (int i = 0; i < size; i++) {\n    if (arr[i] % 2 == 0) {\n      if (min == -1 || arr[i] < min) {\n        min = arr[i];\n        index = i;\n      }\n    }\n  }\n  if (index == -1)\n    return NULL;\n  dest[0] = min;\n  dest[1] = index;\n  return dest;\n}"
    },
    {
      "task_id": 69,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  lea    0x1(%rsi),%edi\n  movslq %edi,%rdi\n  mov    $0x4,%esi\n  call   1070 <calloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    11a7 <func0+0x6e>\n  mov    %rbp,%rsi\n  lea    -0x1(%rbx),%eax\n  lea    0x4(%rbp,%rax,4),%rax\n  mov    $0xffffffff,%ebx\n  mov    (%rsi),%ecx\n  movslq %ecx,%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    (%r8),%edx\n  add    $0x1,%edx\n  mov    %edx,(%r8)\n  cmp    %ecx,%ebx\n  mov    %ecx,%r8d\n  cmovge %ebx,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%ebx\n  add    $0x4,%rsi\n  cmp    %rax,%rsi\n  jne    116f <func0+0x36>\n  call   1060 <free@plt>\n  mov    %ebx,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  mov    $0xffffffff,%ebx\n  jmp    1199 <func0+0x60>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  lea    0x1(%rsi),%edi\n  movslq %edi,%rdi\n  mov    $0x4,%esi\n  call   <calloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    L0\n  mov    %rbp,%rsi\n  lea    -0x1(%rbx),%eax\n  lea    0x4(%rbp,%rax,4),%rax\n  mov    $0xffffffff,%ebx\nL1:\n  mov    (%rsi),%ecx\n  movslq %ecx,%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    (%r8),%edx\n  add    $0x1,%edx\n  mov    %edx,(%r8)\n  cmp    %ecx,%ebx\n  mov    %ecx,%r8d\n  cmovge %ebx,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%ebx\n  add    $0x4,%rsi\n  cmp    %rax,%rsi\n  jne    L1\nL2:\n  call   <free@plt>\n  mov    %ebx,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL0:\n  mov    $0xffffffff,%ebx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4519
        },
        "L1": {
          "label": "L1",
          "addr": 4463
        },
        "L2": {
          "label": "L2",
          "addr": 4505
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *nums, int numsSize) {\n  int *arr = (int *)calloc(numsSize + 1, sizeof(int));\n  int ret = -1;\n  for (int i = 0; i < numsSize; i++) {\n    arr[nums[i]]++;\n    if (arr[nums[i]] > nums[i])\n      ret = ret > nums[i] ? ret : nums[i];\n  }\n  free(arr);\n  return ret;\n}"
    },
    {
      "task_id": 65,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  lea    0x2ed3(%rip),%r13        # 4080 <xs.0>\n  mov    %edi,%r8d\n  lea    0xe49(%rip),%rcx        # 2000 <_fini+0xd64>\n  push   %r12\n  mov    %r13,%rdi\n  mov    $0x32,%edx\n  push   %rbx\n  movslq %esi,%rbx\n  mov    $0x1,%esi\n  sub    $0x40,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   10d0 <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   1090 <strlen@plt>\n  cmp    %ebx,%eax\n  jge    1250 <func0+0xb0>\n  mov    %eax,%ecx\n  sar    %ecx\n  je     122a <func0+0x8a>\n  lea    -0x1(%rcx),%edi\n  cltq\n  lea    0x1(%r13),%rcx\n  mov    %r13,%rdx\n  lea    -0x1(%r13,%rax,1),%rax\n  add    %rcx,%rdi\n  nopl   0x0(%rax)\n  movzbl (%rax),%esi\n  movzbl (%rdx),%ecx\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rdi,%rdx\n  jne    1210 <func0+0x70>\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1294 <func0+0xf4>\n  add    $0x40,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  sub    %rbx,%rax\n  mov    %rsp,%r8\n  mov    $0x32,%edx\n  mov    %r8,%rdi\n  lea    0x0(%r13,%rax,1),%rsi\n  mov    %rax,%r12\n  call   10b0 <__strcpy_chk@plt>\n  mov    %r12,%rdx\n  mov    %r13,%rsi\n  mov    $0x32,%ecx\n  mov    %rax,%rdi\n  movb   $0x0,(%rsp,%rbx,1)\n  call   10c0 <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  mov    %rax,%rsi\n  call   10b0 <__strcpy_chk@plt>\n  jmp    122a <func0+0x8a>\n  call   10a0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  lea    D0(%rip),%r13\n  mov    %edi,%r8d\n  lea    D1(%rip),%rcx\n  push   %r12\n  mov    %r13,%rdi\n  mov    $0x32,%edx\n  push   %rbx\n  movslq %esi,%rbx\n  mov    $0x1,%esi\n  sub    $0x40,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  cmp    %ebx,%eax\n  jge    L0\n  mov    %eax,%ecx\n  sar    %ecx\n  je     L1\n  lea    -0x1(%rcx),%edi\n  cltq\n  lea    0x1(%r13),%rcx\n  mov    %r13,%rdx\n  lea    -0x1(%r13,%rax,1),%rax\n  add    %rcx,%rdi\n  nopl   0x0(%rax)\nL2:\n  movzbl (%rax),%esi\n  movzbl (%rdx),%ecx\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rdi,%rdx\n  jne    L2\nL1:\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  add    $0x40,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  sub    %rbx,%rax\n  mov    %rsp,%r8\n  mov    $0x32,%edx\n  mov    %r8,%rdi\n  lea    0x0(%r13,%rax,1),%rsi\n  mov    %rax,%r12\n  call   <__strcpy_chk@plt>\n  mov    %r12,%rdx\n  mov    %r13,%rsi\n  mov    $0x32,%ecx\n  mov    %rax,%rdi\n  movb   $0x0,(%rsp,%rbx,1)\n  call   <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  mov    %rax,%rsi\n  call   <__strcpy_chk@plt>\n  jmp    L1\nL3:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 16512,
          "bias": [
            11987
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3657
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4688
        },
        "L1": {
          "label": "L1",
          "addr": 4650
        },
        "L2": {
          "label": "L2",
          "addr": 4624
        },
        "L3": {
          "label": "L3",
          "addr": 4756
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " char *func0(int a, int len) {\n  static char buf[50];\n  int i, j;\n  char tmp;\n  __sprintf_chk(buf, 1, 50, \"%d\", a);\n  i = strlen(buf);\n  if (i < len) {\n    for (j = 0; j < i / 2; j++) {\n      tmp = buf[j];\n      buf[j] = buf[i - j - 1];\n      buf[i - j - 1] = tmp;\n    }\n  } else {\n    char buf2[50];\n    __strcpy_chk(buf2, buf + i - len, 50);\n    buf2[len] = 0;\n    __strcpy_chk(buf, __strncat_chk(buf, buf2, 50), 50);\n  }\n  return buf;\n}"
    },
    {
      "task_id": 65,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  lea    0x2ed3(%rip),%r13        # 4080 <xs.0>\n  mov    %edi,%r8d\n  lea    0xe49(%rip),%rcx        # 2000 <_fini+0xd64>\n  push   %r12\n  mov    %r13,%rdi\n  mov    $0x32,%edx\n  push   %rbx\n  movslq %esi,%rbx\n  mov    $0x1,%esi\n  sub    $0x40,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   10d0 <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   1090 <strlen@plt>\n  cmp    %ebx,%eax\n  jge    1250 <func0+0xb0>\n  mov    %eax,%ecx\n  sar    %ecx\n  je     122a <func0+0x8a>\n  lea    -0x1(%rcx),%edi\n  cltq\n  lea    0x1(%r13),%rcx\n  mov    %r13,%rdx\n  lea    -0x1(%r13,%rax,1),%rax\n  add    %rcx,%rdi\n  nopl   0x0(%rax)\n  movzbl (%rax),%esi\n  movzbl (%rdx),%ecx\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rdi,%rdx\n  jne    1210 <func0+0x70>\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1294 <func0+0xf4>\n  add    $0x40,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  sub    %rbx,%rax\n  mov    %rsp,%r8\n  mov    $0x32,%edx\n  mov    %r8,%rdi\n  lea    0x0(%r13,%rax,1),%rsi\n  mov    %rax,%r12\n  call   10b0 <__strcpy_chk@plt>\n  mov    %r12,%rdx\n  mov    %r13,%rsi\n  mov    $0x32,%ecx\n  mov    %rax,%rdi\n  movb   $0x0,(%rsp,%rbx,1)\n  call   10c0 <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  mov    %rax,%rsi\n  call   10b0 <__strcpy_chk@plt>\n  jmp    122a <func0+0x8a>\n  call   10a0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  lea    D0(%rip),%r13\n  mov    %edi,%r8d\n  lea    D1(%rip),%rcx\n  push   %r12\n  mov    %r13,%rdi\n  mov    $0x32,%edx\n  push   %rbx\n  movslq %esi,%rbx\n  mov    $0x1,%esi\n  sub    $0x40,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  cmp    %ebx,%eax\n  jge    L0\n  mov    %eax,%ecx\n  sar    %ecx\n  je     L1\n  lea    -0x1(%rcx),%edi\n  cltq\n  lea    0x1(%r13),%rcx\n  mov    %r13,%rdx\n  lea    -0x1(%r13,%rax,1),%rax\n  add    %rcx,%rdi\n  nopl   0x0(%rax)\nL2:\n  movzbl (%rax),%esi\n  movzbl (%rdx),%ecx\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rdi,%rdx\n  jne    L2\nL1:\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  add    $0x40,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  sub    %rbx,%rax\n  mov    %rsp,%r8\n  mov    $0x32,%edx\n  mov    %r8,%rdi\n  lea    0x0(%r13,%rax,1),%rsi\n  mov    %rax,%r12\n  call   <__strcpy_chk@plt>\n  mov    %r12,%rdx\n  mov    %r13,%rsi\n  mov    $0x32,%ecx\n  mov    %rax,%rdi\n  movb   $0x0,(%rsp,%rbx,1)\n  call   <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  mov    %rax,%rsi\n  call   <__strcpy_chk@plt>\n  jmp    L1\nL3:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 16512,
          "bias": [
            11987
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3657
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4688
        },
        "L1": {
          "label": "L1",
          "addr": 4650
        },
        "L2": {
          "label": "L2",
          "addr": 4624
        },
        "L3": {
          "label": "L3",
          "addr": 4756
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " char *func0(int a, int len) {\n  static char buf[50];\n  int i, j;\n  char tmp;\n  __sprintf_chk(buf, 1, 50, \"%d\", a);\n  i = strlen(buf);\n  if (i < len) {\n    for (j = 0; j < i / 2; j++) {\n      tmp = buf[j];\n      buf[j] = buf[i - j - 1];\n      buf[i - j - 1] = tmp;\n    }\n  } else {\n    char buf2[50];\n    __strcpy_chk(buf2, buf + i - len, 50);\n    buf2[len] = 0;\n    __strcpy_chk(buf, __strncat_chk(buf, buf2, 50), 50);\n  }\n  return buf;\n}"
    },
    {
      "task_id": 68,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x7fffffff,-0xc(%rbp)\n  movl   $0xffffffff,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1184 <func0+0x8b>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    1180 <func0+0x87>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jg     1161 <func0+0x68>\n  cmpl   $0xffffffff,-0x8(%rbp)\n  jne    1180 <func0+0x87>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1123 <func0+0x2a>\n  cmpl   $0xffffffff,-0x8(%rbp)\n  jne    1199 <func0+0xa0>\n  mov    $0x0,%eax\n  jmp    11b3 <func0+0xba>\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x28(%rbp),%rax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x7fffffff,-0xc(%rbp)\n  movl   $0xffffffff,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jg     L2\n  cmpl   $0xffffffff,-0x8(%rbp)\n  jne    L1\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  cmpl   $0xffffffff,-0x8(%rbp)\n  jne    L4\n  mov    $0x0,%eax\n  jmp    L5\nL4:\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x28(%rbp),%rax\nL5:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4484
        },
        "L1": {
          "label": "L1",
          "addr": 4480
        },
        "L2": {
          "label": "L2",
          "addr": 4449
        },
        "L3": {
          "label": "L3",
          "addr": 4387
        },
        "L4": {
          "label": "L4",
          "addr": 4505
        },
        "L5": {
          "label": "L5",
          "addr": 4531
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *x, int n, int *y) {\n  int min = 0x7fffffff;\n  int index = -1;\n  for (int i = 0; i < n; i++) {\n    if (x[i] % 2 == 0) {\n      if (x[i] < min || index == -1) {\n        min = x[i];\n        index = i;\n      }\n    }\n  }\n  if (index == -1) {\n    return NULL;\n  }\n  y[0] = min;\n  y[1] = index;\n  return y;\n}"
    },
    {
      "task_id": 68,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1160 <func0+0x60>\n  movslq %esi,%rsi\n  xor    %ecx,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdi,%rcx,4),%r8d\n  mov    %ecx,%r9d\n  test   $0x1,%r8b\n  jne    113e <func0+0x3e>\n  cmp    $0xffffffff,%r10d\n  je     1138 <func0+0x38>\n  cmp    %r8d,%eax\n  jle    113e <func0+0x3e>\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  jne    1120 <func0+0x20>\n  cmp    $0xffffffff,%r10d\n  je     1160 <func0+0x60>\n  mov    %eax,(%rdx)\n  mov    %rdx,%rax\n  mov    %r10d,0x4(%rdx)\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rsi\n  xor    %ecx,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    (%rdi,%rcx,4),%r8d\n  mov    %ecx,%r9d\n  test   $0x1,%r8b\n  jne    L1\n  cmp    $0xffffffff,%r10d\n  je     L2\n  cmp    %r8d,%eax\n  jle    L1\nL2:\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\nL1:\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  jne    L3\n  cmp    $0xffffffff,%r10d\n  je     L0\n  mov    %eax,(%rdx)\n  mov    %rdx,%rax\n  mov    %r10d,0x4(%rdx)\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4448
        },
        "L1": {
          "label": "L1",
          "addr": 4414
        },
        "L2": {
          "label": "L2",
          "addr": 4408
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *arr, int size, int *dest) {\n  int min = -1;\n  int min_index = -1;\n  for (int i = 0; i < size; i++) {\n    if (arr[i] % 2 == 0) {\n      if (min == -1 || arr[i] < min) {\n        min = arr[i];\n        min_index = i;\n      }\n    }\n  }\n  if (min_index == -1) {\n    return NULL;\n  }\n  dest[0] = min;\n  dest[1] = min_index;\n  return dest;\n}"
    },
    {
      "task_id": 69,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x1(%rsi),%edi\n  mov    $0x4,%esi\n  movslq %edi,%rdi\n  sub    $0x8,%rsp\n  call   1070 <calloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    11c0 <func0+0x80>\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rsi\n  mov    $0xffffffff,%r12d\n  lea    0x4(%rbx,%rax,4),%rax\n  nopl   0x0(%rax)\n  movslq (%rsi),%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    %rdx,%rcx\n  mov    (%r8),%ebx\n  cmp    %ecx,%r12d\n  lea    0x1(%rbx),%edx\n  mov    %edx,(%r8)\n  mov    %ecx,%r8d\n  cmovge %r12d,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%r12d\n  add    $0x4,%rsi\n  cmp    %rsi,%rax\n  jne    1180 <func0+0x40>\n  call   1060 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret\n  nopl   0x0(%rax)\n  call   1060 <free@plt>\n  mov    $0xffffffff,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x1(%rsi),%edi\n  mov    $0x4,%esi\n  movslq %edi,%rdi\n  sub    $0x8,%rsp\n  call   <calloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rsi\n  mov    $0xffffffff,%r12d\n  lea    0x4(%rbx,%rax,4),%rax\n  nopl   0x0(%rax)\nL1:\n  movslq (%rsi),%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    %rdx,%rcx\n  mov    (%r8),%ebx\n  cmp    %ecx,%r12d\n  lea    0x1(%rbx),%edx\n  mov    %edx,(%r8)\n  mov    %ecx,%r8d\n  cmovge %r12d,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%r12d\n  add    $0x4,%rsi\n  cmp    %rsi,%rax\n  jne    L1\n  call   <free@plt>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret\n  nopl   0x0(%rax)\nL0:\n  call   <free@plt>\n  mov    $0xffffffff,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4544
        },
        "L1": {
          "label": "L1",
          "addr": 4480
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *nums, int numsSize) {\n  int *arr = (int *)calloc(numsSize + 1, sizeof(int));\n  int ret = -1;\n  for (int i = 0; i < numsSize; i++) {\n    arr[nums[i]]++;\n    if (arr[nums[i]] > nums[i])\n      ret = ret > nums[i] ? ret : nums[i];\n  }\n  free(arr);\n  return ret;\n}"
    },
    {
      "task_id": 69,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x1(%rsi),%edi\n  mov    $0x4,%esi\n  movslq %edi,%rdi\n  sub    $0x8,%rsp\n  call   1070 <calloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    11c0 <func0+0x80>\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rsi\n  mov    $0xffffffff,%r12d\n  lea    0x4(%rbx,%rax,4),%rax\n  nopl   0x0(%rax)\n  movslq (%rsi),%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    %rdx,%rcx\n  mov    (%r8),%ebx\n  cmp    %ecx,%r12d\n  lea    0x1(%rbx),%edx\n  mov    %edx,(%r8)\n  mov    %ecx,%r8d\n  cmovge %r12d,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%r12d\n  add    $0x4,%rsi\n  cmp    %rsi,%rax\n  jne    1180 <func0+0x40>\n  call   1060 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret\n  nopl   0x0(%rax)\n  call   1060 <free@plt>\n  mov    $0xffffffff,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x1(%rsi),%edi\n  mov    $0x4,%esi\n  movslq %edi,%rdi\n  sub    $0x8,%rsp\n  call   <calloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rsi\n  mov    $0xffffffff,%r12d\n  lea    0x4(%rbx,%rax,4),%rax\n  nopl   0x0(%rax)\nL1:\n  movslq (%rsi),%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    %rdx,%rcx\n  mov    (%r8),%ebx\n  cmp    %ecx,%r12d\n  lea    0x1(%rbx),%edx\n  mov    %edx,(%r8)\n  mov    %ecx,%r8d\n  cmovge %r12d,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%r12d\n  add    $0x4,%rsi\n  cmp    %rsi,%rax\n  jne    L1\n  call   <free@plt>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret\n  nopl   0x0(%rax)\nL0:\n  call   <free@plt>\n  mov    $0xffffffff,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4544
        },
        "L1": {
          "label": "L1",
          "addr": 4480
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *nums, int numsSize) {\n  int *arr = (int *)calloc(numsSize + 1, sizeof(int));\n  int ret = -1;\n  for (int i = 0; i < numsSize; i++) {\n    arr[nums[i]]++;\n    if (arr[nums[i]] > nums[i])\n      ret = ret > nums[i] ? ret : nums[i];\n  }\n  free(arr);\n  return ret;\n}"
    },
    {
      "task_id": 65,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %edi,%r8d\n  mov    %esi,%ebp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  lea    0xe3d(%rip),%rcx        # 2000 <_fini+0xd68>\n  mov    $0x32,%edx\n  mov    $0x1,%esi\n  lea    0x2eac(%rip),%rbx        # 4080 <xs.0>\n  mov    %rbx,%rdi\n  call   10d0 <__sprintf_chk@plt>\n  mov    %rbx,%rdi\n  call   1090 <strlen@plt>\n  cmp    %ebp,%eax\n  jge    1246 <func0+0xad>\n  mov    %eax,%r8d\n  shr    $0x1f,%r8d\n  add    %eax,%r8d\n  sar    %r8d\n  cmp    $0x1,%eax\n  jle    1224 <func0+0x8b>\n  cltq\n  add    %rbx,%rax\n  mov    $0x0,%edx\n  mov    %rbx,%rcx\n  movzbl (%rcx,%rdx,1),%esi\n  movzbl -0x1(%rax),%edi\n  mov    %dil,(%rcx,%rdx,1)\n  mov    %sil,-0x1(%rax)\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%r8d\n  jg     1207 <func0+0x6e>\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1293 <func0+0xfa>\n  lea    0x2e45(%rip),%rax        # 4080 <xs.0>\n  add    $0x48,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  movslq %eax,%rbx\n  movslq %ebp,%rbp\n  sub    %rbp,%rbx\n  lea    0x2e2a(%rip),%r12        # 4080 <xs.0>\n  lea    (%rbx,%r12,1),%rsi\n  mov    %rsp,%r13\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  call   10b0 <__strcpy_chk@plt>\n  movb   $0x0,(%rsp,%rbp,1)\n  mov    $0x32,%ecx\n  mov    %rbx,%rdx\n  mov    %r12,%rsi\n  mov    %r13,%rdi\n  call   10c0 <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rsi\n  mov    %r12,%rdi\n  call   10b0 <__strcpy_chk@plt>\n  jmp    1224 <func0+0x8b>\n  call   10a0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %edi,%r8d\n  mov    %esi,%ebp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rcx\n  mov    $0x32,%edx\n  mov    $0x1,%esi\n  lea    D1(%rip),%rbx\n  mov    %rbx,%rdi\n  call   <__sprintf_chk@plt>\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  cmp    %ebp,%eax\n  jge    L0\n  mov    %eax,%r8d\n  shr    $0x1f,%r8d\n  add    %eax,%r8d\n  sar    %r8d\n  cmp    $0x1,%eax\n  jle    L1\n  cltq\n  add    %rbx,%rax\n  mov    $0x0,%edx\n  mov    %rbx,%rcx\nL2:\n  movzbl (%rcx,%rdx,1),%esi\n  movzbl -0x1(%rax),%edi\n  mov    %dil,(%rcx,%rdx,1)\n  mov    %sil,-0x1(%rax)\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%r8d\n  jg     L2\nL1:\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  lea    D1(%rip),%rax\n  add    $0x48,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL0:\n  movslq %eax,%rbx\n  movslq %ebp,%rbp\n  sub    %rbp,%rbx\n  lea    D1(%rip),%r12\n  lea    (%rbx,%r12,1),%rsi\n  mov    %rsp,%r13\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  call   <__strcpy_chk@plt>\n  movb   $0x0,(%rsp,%rbp,1)\n  mov    $0x32,%ecx\n  mov    %rbx,%rdx\n  mov    %r12,%rsi\n  mov    %r13,%rdi\n  call   <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rsi\n  mov    %r12,%rdi\n  call   <__strcpy_chk@plt>\n  jmp    L1\nL3:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3645
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 16512,
          "bias": [
            11948,
            11845,
            11818
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4678
        },
        "L1": {
          "label": "L1",
          "addr": 4644
        },
        "L2": {
          "label": "L2",
          "addr": 4615
        },
        "L3": {
          "label": "L3",
          "addr": 4755
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(int a, int b) {\n  static char buf[50];\n  int i, j;\n  char c;\n  __sprintf_chk(buf, 1, 50, \"%d\", a);\n  i = strlen(buf);\n  if (i < b) {\n    for (j = 0; j < i / 2; j++) {\n      c = buf[j];\n      buf[j] = buf[i - j - 1];\n      buf[i - j - 1] = c;\n    }\n  } else {\n    char buf2[50];\n    __strcpy_chk(buf2, buf + i - b, 50);\n    buf2[b] = 0;\n    __strncat_chk(buf2, buf, i - b, 50);\n    __strcpy_chk(buf, buf2, 50);\n  }\n  return buf;\n}"
    },
    {
      "task_id": 67,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x18(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x2c(%rbp)\n  movw   $0x0,-0x24(%rbp)\n  movq   $0x0,-0x22(%rbp)\n  movw   $0x0,-0x1a(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    124b <func0+0xf2>\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x800,%eax\n  test   %eax,%eax\n  je     122d <func0+0xd4>\n  cmpl   $0x0,-0x38(%rbp)\n  jne    120b <func0+0xb2>\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x2c(%rbp,%rax,1)\n  jmp    1247 <func0+0xee>\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x22(%rbp,%rax,1)\n  jmp    1247 <func0+0xee>\n  cmpl   $0x0,-0x38(%rbp)\n  jne    1247 <func0+0xee>\n  cmpl   $0x0,-0x34(%rbp)\n  jle    1247 <func0+0xee>\n  movl   $0x1,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11b2 <func0+0x59>\n  lea    -0x2c(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <atoi@plt>\n  mov    %eax,%edx\n  mov    -0x4c(%rbp),%eax\n  sub    %edx,%eax\n  mov    %eax,%ebx\n  lea    -0x22(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <atoi@plt>\n  mov    %eax,%edx\n  mov    %ebx,%eax\n  sub    %edx,%eax\n  mov    -0x18(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     129e <func0+0x145>\n  call   1070 <__stack_chk_fail@plt>\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x18(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x2c(%rbp)\n  movw   $0x0,-0x24(%rbp)\n  movq   $0x0,-0x22(%rbp)\n  movw   $0x0,-0x1a(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    L0\nL4:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x800,%eax\n  test   %eax,%eax\n  je     L1\n  cmpl   $0x0,-0x38(%rbp)\n  jne    L2\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x2c(%rbp,%rax,1)\n  jmp    L3\nL2:\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x22(%rbp,%rax,1)\n  jmp    L3\nL1:\n  cmpl   $0x0,-0x38(%rbp)\n  jne    L3\n  cmpl   $0x0,-0x34(%rbp)\n  jle    L3\n  movl   $0x1,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\nL3:\n  addl   $0x1,-0x30(%rbp)\nL0:\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L4\n  lea    -0x2c(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,%edx\n  mov    -0x4c(%rbp),%eax\n  sub    %edx,%eax\n  mov    %eax,%ebx\n  lea    -0x22(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,%edx\n  mov    %ebx,%eax\n  sub    %edx,%eax\n  mov    -0x18(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L5\n  call   <__stack_chk_fail@plt>\nL5:\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4683
        },
        "L1": {
          "label": "L1",
          "addr": 4653
        },
        "L2": {
          "label": "L2",
          "addr": 4619
        },
        "L3": {
          "label": "L3",
          "addr": 4679
        },
        "L4": {
          "label": "L4",
          "addr": 4530
        },
        "L5": {
          "label": "L5",
          "addr": 4766
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *p, int n) {\n  int i, j, k;\n  char a[10] = {0};\n  char b[10] = {0};\n  j = 0;\n  k = 0;\n  for (i = 0; p[i] != '\\0'; i++) {\n    if (((*(const unsigned short *)(__ctype_b_loc() + p[i])) & 0x800) != 0) {\n      if (j == 0) {\n        a[k++] = p[i];\n      } else {\n        b[k++] = p[i];\n      }\n    } else {\n      if (j == 0 && k > 0) {\n        j = 1;\n        k = 0;\n      }\n    }\n  }\n  return n - atoi(a) - atoi(b);\n}"
    },
    {
      "task_id": 68,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    114e <func0+0x55>\n  mov    %esi,%esi\n  mov    $0x0,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  jmp    1124 <func0+0x2b>\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  je     113e <func0+0x45>\n  mov    %ecx,%r9d\n  mov    (%rdi,%rcx,4),%r8d\n  test   $0x1,%r8b\n  jne    111b <func0+0x22>\n  cmp    $0xffffffff,%r10d\n  je     1115 <func0+0x1c>\n  cmp    %eax,%r8d\n  jl     1115 <func0+0x1c>\n  jmp    111b <func0+0x22>\n  cmp    $0xffffffff,%r10d\n  je     1154 <func0+0x5b>\n  mov    %eax,(%rdx)\n  mov    %r10d,0x4(%rdx)\n  mov    %rdx,%rax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%esi\n  mov    $0x0,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  jmp    L1\nL4:\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\nL3:\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  je     L2\nL1:\n  mov    %ecx,%r9d\n  mov    (%rdi,%rcx,4),%r8d\n  test   $0x1,%r8b\n  jne    L3\n  cmp    $0xffffffff,%r10d\n  je     L4\n  cmp    %eax,%r8d\n  jl     L4\n  jmp    L3\nL2:\n  cmp    $0xffffffff,%r10d\n  je     L5\n  mov    %eax,(%rdx)\n  mov    %r10d,0x4(%rdx)\n  mov    %rdx,%rax\n  ret\nL0:\n  mov    $0x0,%eax\n  ret\nL5:\n  mov    $0x0,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4430
        },
        "L1": {
          "label": "L1",
          "addr": 4388
        },
        "L2": {
          "label": "L2",
          "addr": 4414
        },
        "L3": {
          "label": "L3",
          "addr": 4379
        },
        "L4": {
          "label": "L4",
          "addr": 4373
        },
        "L5": {
          "label": "L5",
          "addr": 4436
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int *arr, int size, int *buffer) {\n  int max = -1;\n  int min = -1;\n  int i = 0;\n  for (i = 0; i < size; i++) {\n    if (arr[i] % 2 == 0) {\n      if (min == -1) {\n        min = i;\n        max = arr[i];\n      } else {\n        if (arr[i] > max) {\n          max = arr[i];\n          min = i;\n        }\n      }\n    }\n  }\n  if (min == -1) {\n    return NULL;\n  }\n  buffer[0] = max;\n  buffer[1] = min;\n  return buffer;\n}"
    },
    {
      "task_id": 67,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  mov    %esi,%r12d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,0x4(%rsp)\n  movw   $0x0,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  movw   $0x0,0x16(%rsp)\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     120e <func0+0xb5>\n  mov    %rdi,%rbp\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdi\n  lea    0x1(%rbp),%rdx\n  mov    $0x0,%ecx\n  mov    $0x0,%eax\n  mov    $0x0,%r9d\n  mov    $0x1,%r8d\n  jmp    11f3 <func0+0x9a>\n  movslq %ecx,%rsi\n  mov    %bl,0xe(%rsp,%rsi,1)\n  lea    0x1(%rcx),%ecx\n  jmp    11e7 <func0+0x8e>\n  test   %eax,%eax\n  jne    11e7 <func0+0x8e>\n  test   %ecx,%ecx\n  setg   %sil\n  test   %sil,%sil\n  cmovne %r9d,%ecx\n  cmovne %r8d,%eax\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%ebx\n  test   %bl,%bl\n  je     120e <func0+0xb5>\n  movsbq %bl,%rsi\n  testb  $0x8,0x1(%rdi,%rsi,2)\n  je     11d2 <func0+0x79>\n  test   %eax,%eax\n  jne    11c6 <func0+0x6d>\n  movslq %ecx,%rsi\n  mov    %bl,0x4(%rsp,%rsi,1)\n  lea    0x1(%rcx),%ecx\n  jmp    11e7 <func0+0x8e>\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1080 <strtol@plt>\n  sub    %eax,%r12d\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1080 <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1258 <func0+0xff>\n  mov    %r12d,%eax\n  add    $0x20,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  mov    %esi,%r12d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,0x4(%rsp)\n  movw   $0x0,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  movw   $0x0,0x16(%rsp)\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdi\n  lea    0x1(%rbp),%rdx\n  mov    $0x0,%ecx\n  mov    $0x0,%eax\n  mov    $0x0,%r9d\n  mov    $0x1,%r8d\n  jmp    L1\nL4:\n  movslq %ecx,%rsi\n  mov    %bl,0xe(%rsp,%rsi,1)\n  lea    0x1(%rcx),%ecx\n  jmp    L2\nL3:\n  test   %eax,%eax\n  jne    L2\n  test   %ecx,%ecx\n  setg   %sil\n  test   %sil,%sil\n  cmovne %r9d,%ecx\n  cmovne %r8d,%eax\nL2:\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%ebx\n  test   %bl,%bl\n  je     L0\nL1:\n  movsbq %bl,%rsi\n  testb  $0x8,0x1(%rdi,%rsi,2)\n  je     L3\n  test   %eax,%eax\n  jne    L4\n  movslq %ecx,%rsi\n  mov    %bl,0x4(%rsp,%rsi,1)\n  lea    0x1(%rcx),%ecx\n  jmp    L2\nL0:\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  sub    %eax,%r12d\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  mov    %r12d,%eax\n  add    $0x20,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL5:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4622
        },
        "L1": {
          "label": "L1",
          "addr": 4595
        },
        "L2": {
          "label": "L2",
          "addr": 4583
        },
        "L3": {
          "label": "L3",
          "addr": 4562
        },
        "L4": {
          "label": "L4",
          "addr": 4550
        },
        "L5": {
          "label": "L5",
          "addr": 4696
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *p, int n) {\n  int i;\n  int flag = 0;\n  int ret = 0;\n  char *q;\n  char s0[10] = {0};\n  char s1[10] = {0};\n  for (i = 0; *(p + i) != '\\0'; i++) {\n    q = (char *)__ctype_b_loc();\n    if ((*(q + *(p + i) + 2) & 0x08) && flag == 0) {\n      s0[i] = *(p + i);\n    } else if ((*(q + *(p + i) + 2) & 0x08) && flag == 1) {\n      s1[i] = *(p + i);\n    } else if (flag == 0 && i > 0) {\n      flag = 1;\n    }\n  }\n  ret = n - strtol(s0, NULL, 10) - strtol(s1, NULL, 10);\n  return ret;\n}"
    },
    {
      "task_id": 73,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1156 <func0+0x5d>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  je     1152 <func0+0x59>\n  addl   $0x1,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x4(%rbp)\n  jl     1118 <func0+0x1f>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  je     L1\n  addl   $0x1,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x4(%rbp)\n  jl     L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4438
        },
        "L1": {
          "label": "L1",
          "addr": 4434
        },
        "L2": {
          "label": "L2",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  int c = 0;\n  for (int i = 0; i < n / 2; ++i)\n    if (x[i] != x[n - 1 - i])\n      ++c;\n  return c;\n}"
    },
    {
      "task_id": 72,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  mov    %esi,%r10d\n  mov    %edx,%r11d\n  mov    %esi,%r8d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    1162 <func0+0x69>\n  movslq %esi,%rax\n  lea    (%rdi,%rax,4),%rcx\n  mov    $0x0,%edx\n  mov    $0x0,%edi\n  mov    (%r9,%rdx,4),%eax\n  mov    -0x4(%rcx),%esi\n  cmp    %esi,%eax\n  jne    1172 <func0+0x79>\n  add    %esi,%eax\n  add    %eax,%edi\n  add    $0x1,%rdx\n  sub    $0x4,%rcx\n  cmp    %edx,%r8d\n  jg     1129 <func0+0x30>\n  mov    %r10d,%eax\n  shr    $0x1f,%eax\n  add    %eax,%r10d\n  and    $0x1,%r10d\n  sub    %eax,%r10d\n  cmp    $0x1,%r10d\n  je     1169 <func0+0x70>\n  cmp    %r11d,%edi\n  setle  %al\n  ret\n  mov    $0x0,%edi\n  jmp    1145 <func0+0x4c>\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  jmp    115b <func0+0x62>\n  mov    $0x0,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  mov    %esi,%r10d\n  mov    %edx,%r11d\n  mov    %esi,%r8d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rax\n  lea    (%rdi,%rax,4),%rcx\n  mov    $0x0,%edx\n  mov    $0x0,%edi\nL2:\n  mov    (%r9,%rdx,4),%eax\n  mov    -0x4(%rcx),%esi\n  cmp    %esi,%eax\n  jne    L1\n  add    %esi,%eax\n  add    %eax,%edi\n  add    $0x1,%rdx\n  sub    $0x4,%rcx\n  cmp    %edx,%r8d\n  jg     L2\nL4:\n  mov    %r10d,%eax\n  shr    $0x1f,%eax\n  add    %eax,%r10d\n  and    $0x1,%r10d\n  sub    %eax,%r10d\n  cmp    $0x1,%r10d\n  je     L3\nL5:\n  cmp    %r11d,%edi\n  setle  %al\n  ret\nL0:\n  mov    $0x0,%edi\n  jmp    L4\nL3:\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  jmp    L5\nL1:\n  mov    $0x0,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4450
        },
        "L1": {
          "label": "L1",
          "addr": 4466
        },
        "L2": {
          "label": "L2",
          "addr": 4393
        },
        "L3": {
          "label": "L3",
          "addr": 4457
        },
        "L4": {
          "label": "L4",
          "addr": 4421
        },
        "L5": {
          "label": "L5",
          "addr": 4443
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char func0(int *arr, int n, int k) {\n  int i, sum = 0;\n  for (i = 0; i < n / 2; i++) {\n    if (arr[i] != arr[n - i - 1])\n      return 0;\n    sum += arr[i] + arr[n - i - 1];\n  }\n  if (n % 2 == 1)\n    sum += arr[i];\n  return sum <= k;\n}"
    },
    {
      "task_id": 72,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1196 <func0+0x9d>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  je     115b <func0+0x62>\n  mov    $0x0,%eax\n  jmp    11e9 <func0+0xf0>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x4(%rbp)\n  jl     111b <func0+0x22>\n  mov    -0x1c(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    11e0 <func0+0xe7>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  setle  %al\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  je     L1\n  mov    $0x0,%eax\n  jmp    L2\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x4(%rbp)\n  jl     L3\n  mov    -0x1c(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L4\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\nL4:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  setle  %al\nL2:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4502
        },
        "L1": {
          "label": "L1",
          "addr": 4443
        },
        "L2": {
          "label": "L2",
          "addr": 4585
        },
        "L3": {
          "label": "L3",
          "addr": 4379
        },
        "L4": {
          "label": "L4",
          "addr": 4576
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char func0(int *arr, int len, int num) {\n  int sum = 0;\n  for (int i = 0; i < len / 2; i++) {\n    if (arr[i] != arr[len - 1 - i])\n      return 0;\n    sum += arr[i] + arr[len - 1 - i];\n  }\n  if (len % 2 == 1)\n    sum += arr[len / 2];\n  return sum <= num;\n}"
    },
    {
      "task_id": 67,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  xor    %edx,%edx\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  movzbl (%rdi),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  mov    %dx,0x16(%rsp)\n  movq   $0x0,0x4(%rsp)\n  mov    %ax,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  test   %bl,%bl\n  je     120e <func0+0xae>\n  mov    %rdi,%rbp\n  call   1090 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %edx,%edx\n  xor    %r9d,%r9d\n  mov    (%rax),%rsi\n  mov    $0x1,%r8d\n  xor    %eax,%eax\n  jmp    11e5 <func0+0x85>\n  nopl   0x0(%rax)\n  movslq %edx,%rcx\n  test   %eax,%eax\n  jne    1258 <func0+0xf8>\n  mov    %bl,0x4(%rsp,%rcx,1)\n  add    $0x1,%edx\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     120e <func0+0xae>\n  movsbq %bl,%rcx\n  testb  $0x8,0x1(%rsi,%rcx,2)\n  jne    11c8 <func0+0x68>\n  test   %eax,%eax\n  jne    11da <func0+0x7a>\n  test   %edx,%edx\n  setg   %cl\n  test   %cl,%cl\n  cmovne %r9d,%edx\n  cmovne %r8d,%eax\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    11e5 <func0+0x85>\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  call   1080 <strtol@plt>\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  sub    %eax,%r12d\n  call   1080 <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1264 <func0+0x104>\n  add    $0x20,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %bl,0xe(%rsp,%rcx,1)\n  add    $0x1,%edx\n  jmp    11da <func0+0x7a>\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  xor    %edx,%edx\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  movzbl (%rdi),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  mov    %dx,0x16(%rsp)\n  movq   $0x0,0x4(%rsp)\n  mov    %ax,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %edx,%edx\n  xor    %r9d,%r9d\n  mov    (%rax),%rsi\n  mov    $0x1,%r8d\n  xor    %eax,%eax\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  movslq %edx,%rcx\n  test   %eax,%eax\n  jne    L2\n  mov    %bl,0x4(%rsp,%rcx,1)\n  add    $0x1,%edx\nL4:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     L0\nL1:\n  movsbq %bl,%rcx\n  testb  $0x8,0x1(%rsi,%rcx,2)\n  jne    L3\n  test   %eax,%eax\n  jne    L4\n  test   %edx,%edx\n  setg   %cl\n  test   %cl,%cl\n  cmovne %r9d,%edx\n  cmovne %r8d,%eax\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    L1\nL0:\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  call   <strtol@plt>\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  sub    %eax,%r12d\n  call   <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  add    $0x20,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    %bl,0xe(%rsp,%rcx,1)\n  add    $0x1,%edx\n  jmp    L4\nL5:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4622
        },
        "L1": {
          "label": "L1",
          "addr": 4581
        },
        "L2": {
          "label": "L2",
          "addr": 4696
        },
        "L3": {
          "label": "L3",
          "addr": 4552
        },
        "L4": {
          "label": "L4",
          "addr": 4570
        },
        "L5": {
          "label": "L5",
          "addr": 4708
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *p, int n) {\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int flag = 0;\n  char *q;\n  char *r;\n  char s[10] = {0};\n  char t[10] = {0};\n  const unsigned short *map = __ctype_b_loc();\n  for (i = 0; *(p + i) != '\\0'; i++) {\n    if ((map[*(p + i)] & 0x08) == 0) {\n      if (flag == 0) {\n        if (j > 0) {\n          flag = 1;\n        }\n      } else {\n        if (flag == 1) {\n          t[k] = *(p + i);\n          k++;\n        }\n      }\n    } else {\n      if (flag == 0) {\n        s[j] = *(p + i);\n        j++;\n      } else {\n        if (flag == 1) {\n          t[k] = *(p + i);\n          k++;\n        }\n      }\n    }\n  }\n  q = s;\n  r = t;\n  n = n - strtol(q, NULL, 10) - strtol(r, NULL, 10);\n  return n;\n}"
    },
    {
      "task_id": 72,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  mov    %rdi,%r9\n  mov    %edx,%r10d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    114b <func0+0x4b>\n  lea    -0x1(%rsi),%eax\n  cltq\n  lea    (%rdi,%rax,4),%rdx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    1140 <func0+0x40>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  lea    (%rdi,%rcx,2),%edi\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jle    1150 <func0+0x50>\n  mov    (%r9,%rax,4),%ecx\n  cmp    (%rdx),%ecx\n  je     1130 <func0+0x30>\n  xor    %eax,%eax\n  ret\n  xor    %edi,%edi\n  nopl   (%rax)\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%esi\n  and    $0x1,%esi\n  sub    %eax,%esi\n  cmp    $0x1,%esi\n  je     1170 <func0+0x70>\n  cmp    %r10d,%edi\n  setle  %al\n  ret\n  nopl   0x0(%rax,%rax,1)\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  cmp    %r10d,%edi\n  setle  %al\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  mov    %rdi,%r9\n  mov    %edx,%r10d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cltq\n  lea    (%rdi,%rax,4),%rdx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  lea    (%rdi,%rcx,2),%edi\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jle    L2\nL1:\n  mov    (%r9,%rax,4),%ecx\n  cmp    (%rdx),%ecx\n  je     L3\n  xor    %eax,%eax\n  ret\nL0:\n  xor    %edi,%edi\n  nopl   (%rax)\nL2:\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%esi\n  and    $0x1,%esi\n  sub    %eax,%esi\n  cmp    $0x1,%esi\n  je     L4\n  cmp    %r10d,%edi\n  setle  %al\n  ret\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  cmp    %r10d,%edi\n  setle  %al\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4427
        },
        "L1": {
          "label": "L1",
          "addr": 4416
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4400
        },
        "L4": {
          "label": "L4",
          "addr": 4464
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char func0(int *src, int n, int k) {\n  int i, j, sum = 0;\n  for (i = 0, j = n - 1; i < n / 2; i++, j--) {\n    if (src[i] != src[j])\n      return 0;\n    sum += src[i] * 2;\n  }\n  if (n % 2 == 1)\n    sum += src[i];\n  if (sum > k)\n    return 0;\n  else\n    return 1;\n}"
    },
    {
      "task_id": 72,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  mov    %rdi,%r9\n  mov    %edx,%r10d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    114b <func0+0x4b>\n  lea    -0x1(%rsi),%eax\n  cltq\n  lea    (%rdi,%rax,4),%rdx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    1140 <func0+0x40>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  lea    (%rdi,%rcx,2),%edi\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jle    1150 <func0+0x50>\n  mov    (%r9,%rax,4),%ecx\n  cmp    (%rdx),%ecx\n  je     1130 <func0+0x30>\n  xor    %eax,%eax\n  ret\n  xor    %edi,%edi\n  nopl   (%rax)\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%esi\n  and    $0x1,%esi\n  sub    %eax,%esi\n  cmp    $0x1,%esi\n  je     1170 <func0+0x70>\n  cmp    %r10d,%edi\n  setle  %al\n  ret\n  nopl   0x0(%rax,%rax,1)\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  cmp    %r10d,%edi\n  setle  %al\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  mov    %rdi,%r9\n  mov    %edx,%r10d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cltq\n  lea    (%rdi,%rax,4),%rdx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  lea    (%rdi,%rcx,2),%edi\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jle    L2\nL1:\n  mov    (%r9,%rax,4),%ecx\n  cmp    (%rdx),%ecx\n  je     L3\n  xor    %eax,%eax\n  ret\nL0:\n  xor    %edi,%edi\n  nopl   (%rax)\nL2:\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%esi\n  and    $0x1,%esi\n  sub    %eax,%esi\n  cmp    $0x1,%esi\n  je     L4\n  cmp    %r10d,%edi\n  setle  %al\n  ret\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  cmp    %r10d,%edi\n  setle  %al\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4427
        },
        "L1": {
          "label": "L1",
          "addr": 4416
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4400
        },
        "L4": {
          "label": "L4",
          "addr": 4464
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char func0(int *src, int n, int k) {\n  int i, j, sum = 0;\n  for (i = 0, j = n - 1; i < n / 2; i++, j--) {\n    if (src[i] != src[j])\n      return 0;\n    sum += src[i] * 2;\n  }\n  if (n % 2 == 1)\n    sum += src[i];\n  if (sum > k)\n    return 0;\n  else\n    return 1;\n}"
    },
    {
      "task_id": 73,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    1140 <func0+0x47>\n  movslq %esi,%rsi\n  lea    (%rdi,%rsi,4),%rdx\n  mov    $0x0,%eax\n  mov    $0x0,%ecx\n  mov    -0x4(%rdx),%esi\n  cmp    %esi,(%rdi,%rax,4)\n  setne  %sil\n  movzbl %sil,%esi\n  add    %esi,%ecx\n  add    $0x1,%rax\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jg     1120 <func0+0x27>\n  mov    %ecx,%eax\n  ret\n  mov    $0x0,%ecx\n  jmp    113d <func0+0x44>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rsi\n  lea    (%rdi,%rsi,4),%rdx\n  mov    $0x0,%eax\n  mov    $0x0,%ecx\nL1:\n  mov    -0x4(%rdx),%esi\n  cmp    %esi,(%rdi,%rax,4)\n  setne  %sil\n  movzbl %sil,%esi\n  add    %esi,%ecx\n  add    $0x1,%rax\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jg     L1\nL2:\n  mov    %ecx,%eax\n  ret\nL0:\n  mov    $0x0,%ecx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        },
        "L2": {
          "label": "L2",
          "addr": 4413
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  int i, j, k;\n  k = 0;\n  for (i = 0, j = n; i < n / 2; i++, j--)\n    if (x[i] != x[j])\n      k++;\n  return k;\n}"
    },
    {
      "task_id": 67,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  xor    %edx,%edx\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  movzbl (%rdi),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  mov    %dx,0x16(%rsp)\n  movq   $0x0,0x4(%rsp)\n  mov    %ax,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  test   %bl,%bl\n  je     120e <func0+0xae>\n  mov    %rdi,%rbp\n  call   1090 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %edx,%edx\n  xor    %r9d,%r9d\n  mov    (%rax),%rsi\n  mov    $0x1,%r8d\n  xor    %eax,%eax\n  jmp    11e5 <func0+0x85>\n  nopl   0x0(%rax)\n  movslq %edx,%rcx\n  test   %eax,%eax\n  jne    1258 <func0+0xf8>\n  mov    %bl,0x4(%rsp,%rcx,1)\n  add    $0x1,%edx\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     120e <func0+0xae>\n  movsbq %bl,%rcx\n  testb  $0x8,0x1(%rsi,%rcx,2)\n  jne    11c8 <func0+0x68>\n  test   %eax,%eax\n  jne    11da <func0+0x7a>\n  test   %edx,%edx\n  setg   %cl\n  test   %cl,%cl\n  cmovne %r9d,%edx\n  cmovne %r8d,%eax\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    11e5 <func0+0x85>\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  call   1080 <strtol@plt>\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  sub    %eax,%r12d\n  call   1080 <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1264 <func0+0x104>\n  add    $0x20,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %bl,0xe(%rsp,%rcx,1)\n  add    $0x1,%edx\n  jmp    11da <func0+0x7a>\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  xor    %edx,%edx\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  movzbl (%rdi),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  mov    %dx,0x16(%rsp)\n  movq   $0x0,0x4(%rsp)\n  mov    %ax,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %edx,%edx\n  xor    %r9d,%r9d\n  mov    (%rax),%rsi\n  mov    $0x1,%r8d\n  xor    %eax,%eax\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  movslq %edx,%rcx\n  test   %eax,%eax\n  jne    L2\n  mov    %bl,0x4(%rsp,%rcx,1)\n  add    $0x1,%edx\nL4:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     L0\nL1:\n  movsbq %bl,%rcx\n  testb  $0x8,0x1(%rsi,%rcx,2)\n  jne    L3\n  test   %eax,%eax\n  jne    L4\n  test   %edx,%edx\n  setg   %cl\n  test   %cl,%cl\n  cmovne %r9d,%edx\n  cmovne %r8d,%eax\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    L1\nL0:\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  call   <strtol@plt>\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  sub    %eax,%r12d\n  call   <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  add    $0x20,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    %bl,0xe(%rsp,%rcx,1)\n  add    $0x1,%edx\n  jmp    L4\nL5:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4622
        },
        "L1": {
          "label": "L1",
          "addr": 4581
        },
        "L2": {
          "label": "L2",
          "addr": 4696
        },
        "L3": {
          "label": "L3",
          "addr": 4552
        },
        "L4": {
          "label": "L4",
          "addr": 4570
        },
        "L5": {
          "label": "L5",
          "addr": 4708
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *p, int n) {\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int flag = 0;\n  char *q;\n  char *r;\n  char s[10] = {0};\n  char t[10] = {0};\n  const unsigned short *map = __ctype_b_loc();\n  for (i = 0; *(p + i) != '\\0'; i++) {\n    if ((map[*(p + i)] & 0x08) == 0) {\n      if (flag == 0) {\n        if (j > 0) {\n          flag = 1;\n        }\n      } else {\n        if (flag == 1) {\n          t[k] = *(p + i);\n          k++;\n        }\n      }\n    } else {\n      if (flag == 0) {\n        s[j] = *(p + i);\n        j++;\n      } else {\n        if (flag == 1) {\n          t[k] = *(p + i);\n          k++;\n        }\n      }\n    }\n  }\n  q = s;\n  r = t;\n  n = n - strtol(q, NULL, 10) - strtol(r, NULL, 10);\n  return n;\n}"
    },
    {
      "task_id": 70,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  lea    -0x1(%rsi),%r9d\n  test   %r9d,%r9d\n  jle    116d <func0+0x74>\n  mov    %esi,%ebx\n  lea    0x4(%rdi),%rsi\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  mov    $0x1,%r8d\n  mov    %r9d,%r13d\n  lea    0x8(%rdi),%r12\n  jmp    1154 <func0+0x5b>\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     1147 <func0+0x4e>\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    112e <func0+0x35>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  jmp    112e <func0+0x35>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %rbp,%r8\n  je     116f <func0+0x76>\n  cmp    %r8d,%ebx\n  jle    1147 <func0+0x4e>\n  mov    %r13d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%r12,%rax,4),%rdi\n  mov    %rsi,%rax\n  jmp    1137 <func0+0x3e>\n  jne    11ab <func0+0xb2>\n  movslq %r9d,%rdx\n  mov    $0x0,%eax\n  jmp    1196 <func0+0x9d>\n  mov    (%r10,%rax,4),%ecx\n  mov    %ecx,(%r11,%rax,8)\n  mov    (%r10,%rdx,4),%ecx\n  mov    %ecx,0x4(%r11,%rax,8)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %edx,%eax\n  jg     11ab <func0+0xb2>\n  lea    (%rax,%rax,1),%ecx\n  cmp    %eax,%edx\n  jne    1179 <func0+0x80>\n  movslq %eax,%rsi\n  mov    (%r10,%rsi,4),%eax\n  movslq %ecx,%rcx\n  mov    %eax,(%r11,%rcx,4)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  lea    -0x1(%rsi),%r9d\n  test   %r9d,%r9d\n  jle    L0\n  mov    %esi,%ebx\n  lea    0x4(%rdi),%rsi\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  mov    $0x1,%r8d\n  mov    %r9d,%r13d\n  lea    0x8(%rdi),%r12\n  jmp    L1\nL3:\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     L2\nL5:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L3\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  jmp    L3\nL2:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %rbp,%r8\n  je     L4\nL1:\n  cmp    %r8d,%ebx\n  jle    L2\n  mov    %r13d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%r12,%rax,4),%rdi\n  mov    %rsi,%rax\n  jmp    L5\nL0:\n  jne    L6\nL4:\n  movslq %r9d,%rdx\n  mov    $0x0,%eax\n  jmp    L7\nL8:\n  mov    (%r10,%rax,4),%ecx\n  mov    %ecx,(%r11,%rax,8)\n  mov    (%r10,%rdx,4),%ecx\n  mov    %ecx,0x4(%r11,%rax,8)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %edx,%eax\n  jg     L6\nL7:\n  lea    (%rax,%rax,1),%ecx\n  cmp    %eax,%edx\n  jne    L8\n  movslq %eax,%rsi\n  mov    (%r10,%rsi,4),%eax\n  movslq %ecx,%rcx\n  mov    %eax,(%r11,%rcx,4)\nL6:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4461
        },
        "L1": {
          "label": "L1",
          "addr": 4436
        },
        "L2": {
          "label": "L2",
          "addr": 4423
        },
        "L3": {
          "label": "L3",
          "addr": 4398
        },
        "L4": {
          "label": "L4",
          "addr": 4463
        },
        "L5": {
          "label": "L5",
          "addr": 4407
        },
        "L6": {
          "label": "L6",
          "addr": 4523
        },
        "L7": {
          "label": "L7",
          "addr": 4502
        },
        "L8": {
          "label": "L8",
          "addr": 4473
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *a, int n, int *b) {\n  int i, j, t;\n  for (i = 0; i < n - 1; i++)\n    for (j = i + 1; j < n; j++)\n      if (a[i] > a[j]) {\n        t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n      }\n  for (i = 0; i < n - 1 - i; i++) {\n    b[2 * i] = a[i];\n    b[2 * i + 1] = a[n - 1 - i];\n  }\n  if (i == n - 1 - i)\n    b[2 * i] = a[i];\n}"
    },
    {
      "task_id": 70,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    11c9 <func0+0xd0>\n  mov    -0x18(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    11b9 <func0+0xc0>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    11b5 <func0+0xbc>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1126 <func0+0x2d>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     1118 <func0+0x1f>\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    12a9 <func0+0x1b0>\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jne    1237 <func0+0x13e>\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  jmp    12a9 <func0+0x1b0>\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jle    11f4 <func0+0xfb>\n  nop\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    L0\nL4:\n  mov    -0x18(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    L1\nL3:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L2\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L3\n  addl   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     L4\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L5\nL7:\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jne    L6\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  jmp    L5\nL6:\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\nL5:\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jle    L7\n  nop\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4553
        },
        "L1": {
          "label": "L1",
          "addr": 4537
        },
        "L2": {
          "label": "L2",
          "addr": 4533
        },
        "L3": {
          "label": "L3",
          "addr": 4390
        },
        "L4": {
          "label": "L4",
          "addr": 4376
        },
        "L5": {
          "label": "L5",
          "addr": 4777
        },
        "L6": {
          "label": "L6",
          "addr": 4663
        },
        "L7": {
          "label": "L7",
          "addr": 4596
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *a, int n, int *b) {\n  int i, j, t;\n  for (i = 0; i < n - 1; i++)\n    for (j = i + 1; j < n; j++)\n      if (a[i] > a[j]) {\n        t = a[i];\n        a[i] = a[j];\n        a[j] = t;\n      }\n  int l = 0, r = n - 1, k = 0;\n  while (l <= r) {\n    if (l == r)\n      b[k++] = a[l++];\n    else {\n      b[k++] = a[l++];\n      b[k++] = a[r--];\n    }\n  }\n}"
    },
    {
      "task_id": 70,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  push   %r12\n  lea    -0x1(%rsi),%r12d\n  push   %rbp\n  mov    %r12d,%r9d\n  push   %rbx\n  test   %r12d,%r12d\n  jle    11d9 <func0+0xd9>\n  mov    %esi,%ebx\n  lea    0x8(%rdi),%r13\n  lea    0x4(%rdi),%rsi\n  mov    $0x1,%r8d\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  nopw   0x0(%rax,%rax,1)\n  cmp    %r8d,%ebx\n  jle    1177 <func0+0x77>\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopl   0x0(%rax,%rax,1)\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    116e <func0+0x6e>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    1160 <func0+0x60>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %rbp,%r8\n  jne    1140 <func0+0x40>\n  xor    %eax,%eax\n  xor    %ecx,%ecx\n  jmp    11ac <func0+0xac>\n  nopw   0x0(%rax,%rax,1)\n  movslq %r9d,%rsi\n  add    $0x1,%rax\n  sub    $0x1,%r9d\n  add    $0x2,%ecx\n  mov    (%r10,%rsi,4),%esi\n  mov    %esi,0x4(%r11,%rdx,1)\n  cmp    %eax,%r9d\n  jl     11d2 <func0+0xd2>\n  movslq %ecx,%rdx\n  mov    (%r10,%rax,4),%edi\n  lea    0x1(%rcx),%r8d\n  shl    $0x2,%rdx\n  lea    (%r11,%rdx,1),%rsi\n  mov    %edi,(%rsi)\n  cmp    %eax,%r9d\n  jne    1190 <func0+0x90>\n  add    $0x1,%rax\n  mov    %r8d,%ecx\n  cmp    %eax,%r9d\n  jge    11ac <func0+0xac>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  test   %r12d,%r12d\n  je     1184 <func0+0x84>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  push   %r12\n  lea    -0x1(%rsi),%r12d\n  push   %rbp\n  mov    %r12d,%r9d\n  push   %rbx\n  test   %r12d,%r12d\n  jle    L0\n  mov    %esi,%ebx\n  lea    0x8(%rdi),%r13\n  lea    0x4(%rdi),%rsi\n  mov    $0x1,%r8d\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    %r8d,%ebx\n  jle    L1\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L2\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\nL2:\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    L3\nL1:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %rbp,%r8\n  jne    L4\nL8:\n  xor    %eax,%eax\n  xor    %ecx,%ecx\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL7:\n  movslq %r9d,%rsi\n  add    $0x1,%rax\n  sub    $0x1,%r9d\n  add    $0x2,%ecx\n  mov    (%r10,%rsi,4),%esi\n  mov    %esi,0x4(%r11,%rdx,1)\n  cmp    %eax,%r9d\n  jl     L6\nL5:\n  movslq %ecx,%rdx\n  mov    (%r10,%rax,4),%edi\n  lea    0x1(%rcx),%r8d\n  shl    $0x2,%rdx\n  lea    (%r11,%rdx,1),%rsi\n  mov    %edi,(%rsi)\n  cmp    %eax,%r9d\n  jne    L7\n  add    $0x1,%rax\n  mov    %r8d,%ecx\n  cmp    %eax,%r9d\n  jge    L5\nL6:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL0:\n  test   %r12d,%r12d\n  je     L8\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4569
        },
        "L1": {
          "label": "L1",
          "addr": 4471
        },
        "L2": {
          "label": "L2",
          "addr": 4462
        },
        "L3": {
          "label": "L3",
          "addr": 4448
        },
        "L4": {
          "label": "L4",
          "addr": 4416
        },
        "L5": {
          "label": "L5",
          "addr": 4524
        },
        "L6": {
          "label": "L6",
          "addr": 4562
        },
        "L7": {
          "label": "L7",
          "addr": 4496
        },
        "L8": {
          "label": "L8",
          "addr": 4484
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *p, int n, int *q) {\n  int i, j, t;\n  for (i = 0; i < n - 1; i++)\n    for (j = i + 1; j < n; j++)\n      if (p[i] > p[j]) {\n        t = p[i];\n        p[i] = p[j];\n        p[j] = t;\n      }\n  for (i = 0, j = n - 1; i <= j;) {\n    q[i++] = p[i];\n    if (i == j)\n      continue;\n    q[i++] = p[j--];\n  }\n}"
    },
    {
      "task_id": 70,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  push   %r12\n  lea    -0x1(%rsi),%r12d\n  push   %rbp\n  movslq %r12d,%r9\n  push   %rbx\n  test   %r12d,%r12d\n  jle    11de <func0+0xde>\n  mov    %esi,%ebx\n  lea    0x8(%rdi),%r13\n  lea    0x4(%rdi),%rsi\n  mov    $0x1,%r8d\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  nopw   0x0(%rax,%rax,1)\n  cmp    %r8d,%ebx\n  jle    1177 <func0+0x77>\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopl   0x0(%rax,%rax,1)\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    116e <func0+0x6e>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    1160 <func0+0x60>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r8,%rbp\n  jne    1140 <func0+0x40>\n  xor    %eax,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\n  movslq %ecx,%rdx\n  mov    (%r10,%rax,4),%edi\n  lea    0x1(%rcx),%r8d\n  shl    $0x2,%rdx\n  lea    (%r11,%rdx,1),%rsi\n  mov    %edi,(%rsi)\n  cmp    %eax,%r9d\n  je     11d0 <func0+0xd0>\n  mov    (%r10,%r9,4),%edi\n  lea    -0x1(%r9),%esi\n  add    $0x1,%rax\n  add    $0x2,%ecx\n  mov    %edi,0x4(%r11,%rdx,1)\n  cmp    %eax,%esi\n  jl     11e3 <func0+0xe3>\n  movslq %esi,%r9\n  jmp    1190 <func0+0x90>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  cmp    %eax,%r9d\n  jl     11e3 <func0+0xe3>\n  mov    %r8d,%ecx\n  jmp    1190 <func0+0x90>\n  test   %r9d,%r9d\n  je     1184 <func0+0x84>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  push   %r12\n  lea    -0x1(%rsi),%r12d\n  push   %rbp\n  movslq %r12d,%r9\n  push   %rbx\n  test   %r12d,%r12d\n  jle    L0\n  mov    %esi,%ebx\n  lea    0x8(%rdi),%r13\n  lea    0x4(%rdi),%rsi\n  mov    $0x1,%r8d\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    %r8d,%ebx\n  jle    L1\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L2\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\nL2:\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    L3\nL1:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r8,%rbp\n  jne    L4\nL8:\n  xor    %eax,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\nL7:\n  movslq %ecx,%rdx\n  mov    (%r10,%rax,4),%edi\n  lea    0x1(%rcx),%r8d\n  shl    $0x2,%rdx\n  lea    (%r11,%rdx,1),%rsi\n  mov    %edi,(%rsi)\n  cmp    %eax,%r9d\n  je     L5\n  mov    (%r10,%r9,4),%edi\n  lea    -0x1(%r9),%esi\n  add    $0x1,%rax\n  add    $0x2,%ecx\n  mov    %edi,0x4(%r11,%rdx,1)\n  cmp    %eax,%esi\n  jl     L6\n  movslq %esi,%r9\n  jmp    L7\n  nopw   0x0(%rax,%rax,1)\nL5:\n  add    $0x1,%rax\n  cmp    %eax,%r9d\n  jl     L6\n  mov    %r8d,%ecx\n  jmp    L7\nL0:\n  test   %r9d,%r9d\n  je     L8\nL6:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4574
        },
        "L1": {
          "label": "L1",
          "addr": 4471
        },
        "L2": {
          "label": "L2",
          "addr": 4462
        },
        "L3": {
          "label": "L3",
          "addr": 4448
        },
        "L4": {
          "label": "L4",
          "addr": 4416
        },
        "L5": {
          "label": "L5",
          "addr": 4560
        },
        "L6": {
          "label": "L6",
          "addr": 4579
        },
        "L7": {
          "label": "L7",
          "addr": 4496
        },
        "L8": {
          "label": "L8",
          "addr": 4484
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *p, int n, int *q) {\n  int i, j, tmp;\n  for (i = 0; i < n - 1; i++)\n    for (j = i + 1; j < n; j++)\n      if (p[i] > p[j]) {\n        tmp = p[i];\n        p[i] = p[j];\n        p[j] = tmp;\n      }\n  for (i = 0; i <= n - 1; i++) {\n    q[2 * i] = p[i];\n    if (i == n - 1)\n      continue;\n    q[2 * i + 1] = p[n - 1];\n  }\n}"
    },
    {
      "task_id": 73,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %esi,%r9d\n  shr    $0x1f,%r9d\n  add    %esi,%r9d\n  sar    %r9d\n  cmp    $0x1,%esi\n  jle    1150 <func0+0x50>\n  sub    $0x1,%esi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  movslq %esi,%rsi\n  lea    (%rdi,%rsi,4),%rdx\n  nopl   (%rax)\n  mov    (%rdx),%esi\n  xor    %ecx,%ecx\n  cmp    %esi,(%rdi,%rax,4)\n  setne  %cl\n  add    $0x1,%rax\n  sub    $0x4,%rdx\n  add    %ecx,%r8d\n  cmp    %eax,%r9d\n  jg     1128 <func0+0x28>\n  mov    %r8d,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%r9d\n  shr    $0x1f,%r9d\n  add    %esi,%r9d\n  sar    %r9d\n  cmp    $0x1,%esi\n  jle    L0\n  sub    $0x1,%esi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  movslq %esi,%rsi\n  lea    (%rdi,%rsi,4),%rdx\n  nopl   (%rax)\nL1:\n  mov    (%rdx),%esi\n  xor    %ecx,%ecx\n  cmp    %esi,(%rdi,%rax,4)\n  setne  %cl\n  add    $0x1,%rax\n  sub    $0x4,%rdx\n  add    %ecx,%r8d\n  cmp    %eax,%r9d\n  jg     L1\n  mov    %r8d,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4432
        },
        "L1": {
          "label": "L1",
          "addr": 4392
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  int i, j, k;\n  k = 0;\n  for (i = 0, j = n - 1; i < n / 2; i++, j--)\n    if (x[i] != x[j])\n      k++;\n  return k;\n}"
    },
    {
      "task_id": 71,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
      "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    11cd <func0+0x94>\n  movaps %xmm0,%xmm3\n  movss  0xea8(%rip),%xmm0        # 2000 <_fini+0xe28>\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    1170 <func0+0x37>\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jb     1171 <func0+0x38>\n  ret\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  0xe83(%rip),%xmm4        # 2004 <_fini+0xe2c>\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  mulss  %xmm3,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm4,%xmm0\n  pxor   %xmm1,%xmm1\n  ucomiss %xmm0,%xmm1\n  ja     11c6 <func0+0x8d>\n  sqrtss %xmm0,%xmm0\n  mulss  0xe54(%rip),%xmm0        # 2008 <_fini+0xe30>\n  call   1070 <roundf@plt>\n  divss  0xe47(%rip),%xmm0        # 2008 <_fini+0xe30>\n  add    $0x8,%rsp\n  ret\n  call   1060 <sqrtf@plt>\n  jmp    11ac <func0+0x73>\n  movss  0xe2b(%rip),%xmm0        # 2000 <_fini+0xe28>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    L0\n  movaps %xmm0,%xmm3\n  movss  D0(%rip),%xmm0\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    L1\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jb     L2\nL1:\n  ret\nL2:\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  D1(%rip),%xmm4\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  mulss  %xmm3,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm4,%xmm0\n  pxor   %xmm1,%xmm1\n  ucomiss %xmm0,%xmm1\n  ja     L3\n  sqrtss %xmm0,%xmm0\nL4:\n  mulss  D2(%rip),%xmm0\n  call   <roundf@plt>\n  divss  D2(%rip),%xmm0\n  add    $0x8,%rsp\n  ret\nL3:\n  call   <sqrtf@plt>\n  jmp    L4\nL0:\n  movss  D0(%rip),%xmm0\n  ret",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3752,
            3627
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3715
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3668,
            3655
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4557
        },
        "L1": {
          "label": "L1",
          "addr": 4464
        },
        "L2": {
          "label": "L2",
          "addr": 4465
        },
        "L3": {
          "label": "L3",
          "addr": 4550
        },
        "L4": {
          "label": "L4",
          "addr": 4524
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000080bf0000003f0000c842",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              128,
              191
            ]
          },
          "0x2004": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              0,
              63
            ]
          },
          "0x2008": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              200,
              66
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " float func0(float a, float b, float c) {\n  float s = (a + b + c) / 2;\n  float t = sqrtf(s * (s - a) * (s - b) * (s - c)) * 1000;\n  return roundf(t) / 1000;\n}"
    },
    {
      "task_id": 73,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  cmp    $0x1,%esi\n  jle    1200 <func0+0x100>\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x7,%esi\n  jle    1209 <func0+0x109>\n  movslq %esi,%rsi\n  pxor   %xmm1,%xmm1\n  mov    %rcx,%rax\n  lea    -0x10(%rcx,%rsi,4),%rdx\n  mov    %edi,%esi\n  movdqa %xmm1,%xmm2\n  shr    $0x2,%esi\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  lea    0x10(%rcx,%rsi,1),%rsi\n  nopw   0x0(%rax,%rax,1)\n  movdqu (%rdx),%xmm3\n  movdqu (%rax),%xmm4\n  add    $0x10,%rax\n  sub    $0x10,%rdx\n  pshufd $0x1b,%xmm3,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pcmpeqd %xmm2,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%rsi\n  jne    1150 <func0+0x50>\n  movdqa %xmm1,%xmm0\n  mov    %edi,%edx\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%edx\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%dil\n  je     1208 <func0+0x108>\n  mov    %r8d,%esi\n  movslq %edx,%r9\n  sub    %edx,%esi\n  lea    0x0(,%r9,4),%r10\n  movslq %esi,%rsi\n  mov    (%rcx,%rsi,4),%esi\n  cmp    %esi,(%rcx,%r9,4)\n  je     11be <func0+0xbe>\n  add    $0x1,%eax\n  lea    0x1(%rdx),%r9d\n  cmp    %edi,%r9d\n  jge    1202 <func0+0x102>\n  mov    %r8d,%esi\n  mov    0x4(%rcx,%r10,1),%r11d\n  sub    %r9d,%esi\n  movslq %esi,%rsi\n  cmp    %r11d,(%rcx,%rsi,4)\n  je     11de <func0+0xde>\n  add    $0x1,%eax\n  add    $0x2,%edx\n  cmp    %edi,%edx\n  jge    1202 <func0+0x102>\n  sub    %edx,%r8d\n  movslq %r8d,%r8\n  mov    (%rcx,%r8,4),%edi\n  cmp    %edi,0x8(%rcx,%r10,1)\n  je     1202 <func0+0x102>\n  add    $0x1,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  ret\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    119f <func0+0x9f>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x7,%esi\n  jle    L1\n  movslq %esi,%rsi\n  pxor   %xmm1,%xmm1\n  mov    %rcx,%rax\n  lea    -0x10(%rcx,%rsi,4),%rdx\n  mov    %edi,%esi\n  movdqa %xmm1,%xmm2\n  shr    $0x2,%esi\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  lea    0x10(%rcx,%rsi,1),%rsi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movdqu (%rdx),%xmm3\n  movdqu (%rax),%xmm4\n  add    $0x10,%rax\n  sub    $0x10,%rdx\n  pshufd $0x1b,%xmm3,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pcmpeqd %xmm2,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%rsi\n  jne    L2\n  movdqa %xmm1,%xmm0\n  mov    %edi,%edx\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%edx\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%dil\n  je     L3\nL7:\n  mov    %r8d,%esi\n  movslq %edx,%r9\n  sub    %edx,%esi\n  lea    0x0(,%r9,4),%r10\n  movslq %esi,%rsi\n  mov    (%rcx,%rsi,4),%esi\n  cmp    %esi,(%rcx,%r9,4)\n  je     L4\n  add    $0x1,%eax\nL4:\n  lea    0x1(%rdx),%r9d\n  cmp    %edi,%r9d\n  jge    L5\n  mov    %r8d,%esi\n  mov    0x4(%rcx,%r10,1),%r11d\n  sub    %r9d,%esi\n  movslq %esi,%rsi\n  cmp    %r11d,(%rcx,%rsi,4)\n  je     L6\n  add    $0x1,%eax\nL6:\n  add    $0x2,%edx\n  cmp    %edi,%edx\n  jge    L5\n  sub    %edx,%r8d\n  movslq %r8d,%r8\n  mov    (%rcx,%r8,4),%edi\n  cmp    %edi,0x8(%rcx,%r10,1)\n  je     L5\n  add    $0x1,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\nL5:\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  ret\nL1:\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    L7",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4608
        },
        "L1": {
          "label": "L1",
          "addr": 4617
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4616
        },
        "L4": {
          "label": "L4",
          "addr": 4542
        },
        "L5": {
          "label": "L5",
          "addr": 4610
        },
        "L6": {
          "label": "L6",
          "addr": 4574
        },
        "L7": {
          "label": "L7",
          "addr": 4511
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i;\n  int count = 0;\n  for (i = 0; i < len / 2; i++) {\n    if (arr[i] != arr[len - 1 - i]) {\n      count++;\n    }\n  }\n  return count;\n}"
    },
    {
      "task_id": 71,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
      "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    11d8 <func0+0x98>\n  movaps %xmm0,%xmm3\n  movss  0xea1(%rip),%xmm0        # 2000 <_fini+0xe18>\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    11d0 <func0+0x90>\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jae    11d0 <func0+0x90>\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  0xe7d(%rip),%xmm4        # 2004 <_fini+0xe1c>\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  pxor   %xmm1,%xmm1\n  mulss  %xmm4,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  ucomiss %xmm0,%xmm1\n  ja     11e1 <func0+0xa1>\n  sqrtss %xmm0,%xmm0\n  mulss  0xe4e(%rip),%xmm0        # 2008 <_fini+0xe20>\n  call   1070 <roundf@plt>\n  divss  0xe41(%rip),%xmm0        # 2008 <_fini+0xe20>\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax)\n  ret\n  nopl   0x0(%rax)\n  movss  0xe20(%rip),%xmm0        # 2000 <_fini+0xe18>\n  ret\n  call   1060 <sqrtf@plt>\n  jmp    11b2 <func0+0x72>",
      "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    L0\n  movaps %xmm0,%xmm3\n  movss  D0(%rip),%xmm0\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    L1\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jae    L1\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  D1(%rip),%xmm4\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  pxor   %xmm1,%xmm1\n  mulss  %xmm4,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  ucomiss %xmm0,%xmm1\n  ja     L2\n  sqrtss %xmm0,%xmm0\nL3:\n  mulss  D2(%rip),%xmm0\n  call   <roundf@plt>\n  divss  D2(%rip),%xmm0\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax)\nL1:\n  ret\n  nopl   0x0(%rax)\nL0:\n  movss  D0(%rip),%xmm0\n  ret\nL2:\n  call   <sqrtf@plt>\n  jmp    L3",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3745,
            3616
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3709
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3662,
            3649
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4568
        },
        "L1": {
          "label": "L1",
          "addr": 4560
        },
        "L2": {
          "label": "L2",
          "addr": 4577
        },
        "L3": {
          "label": "L3",
          "addr": 4530
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000080bf0000003f0000c842",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              128,
              191
            ]
          },
          "0x2004": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              0,
              63
            ]
          },
          "0x2008": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              200,
              66
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float a, float b, float c) {\n  float s = (a + b + c) / 2;\n  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  return roundf(sqrtf((s * (s - a) * (s - b) * (s - c))) * 100) / 100;\n}"
    },
    {
      "task_id": 71,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
      "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    11d8 <func0+0x98>\n  movaps %xmm0,%xmm3\n  movss  0xea1(%rip),%xmm0        # 2000 <_fini+0xe18>\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    11d0 <func0+0x90>\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jae    11d0 <func0+0x90>\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  0xe7d(%rip),%xmm4        # 2004 <_fini+0xe1c>\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  pxor   %xmm1,%xmm1\n  mulss  %xmm4,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  ucomiss %xmm0,%xmm1\n  ja     11e1 <func0+0xa1>\n  sqrtss %xmm0,%xmm0\n  mulss  0xe4e(%rip),%xmm0        # 2008 <_fini+0xe20>\n  call   1070 <roundf@plt>\n  divss  0xe41(%rip),%xmm0        # 2008 <_fini+0xe20>\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax)\n  ret\n  nopl   0x0(%rax)\n  movss  0xe20(%rip),%xmm0        # 2000 <_fini+0xe18>\n  ret\n  call   1060 <sqrtf@plt>\n  jmp    11b2 <func0+0x72>",
      "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    L0\n  movaps %xmm0,%xmm3\n  movss  D0(%rip),%xmm0\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    L1\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jae    L1\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  D1(%rip),%xmm4\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  pxor   %xmm1,%xmm1\n  mulss  %xmm4,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  ucomiss %xmm0,%xmm1\n  ja     L2\n  sqrtss %xmm0,%xmm0\nL3:\n  mulss  D2(%rip),%xmm0\n  call   <roundf@plt>\n  divss  D2(%rip),%xmm0\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax)\nL1:\n  ret\n  nopl   0x0(%rax)\nL0:\n  movss  D0(%rip),%xmm0\n  ret\nL2:\n  call   <sqrtf@plt>\n  jmp    L3",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3745,
            3616
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3709
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3662,
            3649
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4568
        },
        "L1": {
          "label": "L1",
          "addr": 4560
        },
        "L2": {
          "label": "L2",
          "addr": 4577
        },
        "L3": {
          "label": "L3",
          "addr": 4530
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000080bf0000003f0000c842",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              128,
              191
            ]
          },
          "0x2004": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              0,
              63
            ]
          },
          "0x2008": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              200,
              66
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " float func0(float a, float b, float c) {\n  float s = (a + b + c) / 2;\n  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  return roundf(sqrtf((s * (s - a) * (s - b) * (s - c))) * 100) / 100;\n}"
    },
    {
      "task_id": 71,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
      "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  movss  %xmm0,-0x14(%rbp)\n  movss  %xmm1,-0x18(%rbp)\n  movss  %xmm2,-0x1c(%rbp)\n  movss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x18(%rbp),%xmm1\n  movss  -0x1c(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jae    1199 <func0+0x60>\n  movss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x1c(%rbp),%xmm1\n  movss  -0x18(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jae    1199 <func0+0x60>\n  movss  -0x18(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x1c(%rbp),%xmm1\n  movss  -0x14(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jb     11a6 <func0+0x6d>\n  movss  0xe5f(%rip),%xmm0        # 2000 <_fini+0xdc4>\n  jmp    123a <func0+0x101>\n  movss  -0x14(%rbp),%xmm0\n  addss  -0x18(%rbp),%xmm0\n  addss  -0x1c(%rbp),%xmm0\n  movss  0xe47(%rip),%xmm1        # 2004 <_fini+0xdc8>\n  divss  %xmm1,%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  -0x8(%rbp),%xmm1\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x18(%rbp),%xmm0\n  mulss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x1c(%rbp),%xmm0\n  mulss  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  movd   %eax,%xmm0\n  call   1060 <sqrtf@plt>\n  movd   %xmm0,%eax\n  mov    %eax,-0x4(%rbp)\n  movss  -0x4(%rbp),%xmm1\n  movss  0xdf3(%rip),%xmm0        # 2008 <_fini+0xdcc>\n  mulss  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  movd   %eax,%xmm0\n  call   1070 <roundf@plt>\n  movd   %xmm0,%eax\n  movss  0xdd6(%rip),%xmm1        # 2008 <_fini+0xdcc>\n  movd   %eax,%xmm0\n  divss  %xmm1,%xmm0\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  movss  %xmm0,-0x14(%rbp)\n  movss  %xmm1,-0x18(%rbp)\n  movss  %xmm2,-0x1c(%rbp)\n  movss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x18(%rbp),%xmm1\n  movss  -0x1c(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jae    L0\n  movss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x1c(%rbp),%xmm1\n  movss  -0x18(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jae    L0\n  movss  -0x18(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x1c(%rbp),%xmm1\n  movss  -0x14(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jb     L1\nL0:\n  movss  D0(%rip),%xmm0\n  jmp    L2\nL1:\n  movss  -0x14(%rbp),%xmm0\n  addss  -0x18(%rbp),%xmm0\n  addss  -0x1c(%rbp),%xmm0\n  movss  D1(%rip),%xmm1\n  divss  %xmm1,%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  -0x8(%rbp),%xmm1\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x18(%rbp),%xmm0\n  mulss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x1c(%rbp),%xmm0\n  mulss  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  movd   %eax,%xmm0\n  call   <sqrtf@plt>\n  movd   %xmm0,%eax\n  mov    %eax,-0x4(%rbp)\n  movss  -0x4(%rbp),%xmm1\n  movss  D2(%rip),%xmm0\n  mulss  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  movd   %eax,%xmm0\n  call   <roundf@plt>\n  movd   %xmm0,%eax\n  movss  D2(%rip),%xmm1\n  movd   %eax,%xmm0\n  divss  %xmm1,%xmm0\nL2:\n  leave\n  ret",
      "num_missing": 2,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3679
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3655
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3571,
            3542
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4505
        },
        "L1": {
          "label": "L1",
          "addr": 4518
        },
        "L2": {
          "label": "L2",
          "addr": 4666
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000080bf000000400000c842",
      "rodata_parsed": {
        "func0": {
          "0x2004": {
            "type": "f32",
            "value": 2.0
          },
          "0x2000": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              128,
              191
            ]
          },
          "0x2008": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              200,
              66
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " float func0(float a, float b, float c) {\n  float s, p, sqrtf();\n  if (a + b <= c || a + c <= b || b + c <= a)\n    return -1;\n  p = (a + b + c) / 2;\n  s = sqrtf(p * (p - a) * (p - b) * (p - c));\n  return roundf(s * 100) / 100;\n}"
    },
    {
      "task_id": 76,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1134 <func0+0x3b>\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    1126 <func0+0x2d>\n  mov    $0x1,%eax\n  jmp    1147 <func0+0x4e>\n  mov    -0x8(%rbp),%eax\n  imul   -0x18(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jg     1142 <func0+0x49>\n  cmpl   $0x63,-0x4(%rbp)\n  jle    1117 <func0+0x1e>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL4:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    L1\n  mov    $0x1,%eax\n  jmp    L2\nL1:\n  mov    -0x8(%rbp),%eax\n  imul   -0x18(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jg     L3\n  cmpl   $0x63,-0x4(%rbp)\n  jle    L4\nL3:\n  mov    $0x0,%eax\nL2:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4404
        },
        "L1": {
          "label": "L1",
          "addr": 4390
        },
        "L2": {
          "label": "L2",
          "addr": 4423
        },
        "L3": {
          "label": "L3",
          "addr": 4418
        },
        "L4": {
          "label": "L4",
          "addr": 4375
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x, int y) {\n  int a = 1;\n  int b = 0;\n  while (a <= x && b < 100) {\n    if (a == x)\n      return 1;\n    a = a * y;\n    b = b + 1;\n  }\n  return 0;\n}"
    },
    {
      "task_id": 75,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  cmpl   $0x1,-0x14(%rbp)\n  jg     1111 <func0+0x18>\n  mov    $0x0,%eax\n  jmp    115f <func0+0x66>\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    1140 <func0+0x47>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %eax,-0x14(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  je     1121 <func0+0x28>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    112f <func0+0x36>\n  cmpl   $0x1,-0x14(%rbp)\n  jle    1155 <func0+0x5c>\n  addl   $0x1,-0x8(%rbp)\n  cmpl   $0x3,-0x8(%rbp)\n  sete   %al\n  movzbl %al,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  cmpl   $0x1,-0x14(%rbp)\n  jg     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    L2\nL3:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %eax,-0x14(%rbp)\n  addl   $0x1,-0x8(%rbp)\nL4:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  je     L3\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L4\n  cmpl   $0x1,-0x14(%rbp)\n  jle    L5\n  addl   $0x1,-0x8(%rbp)\nL5:\n  cmpl   $0x3,-0x8(%rbp)\n  sete   %al\n  movzbl %al,%eax\nL1:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4369
        },
        "L1": {
          "label": "L1",
          "addr": 4447
        },
        "L2": {
          "label": "L2",
          "addr": 4416
        },
        "L3": {
          "label": "L3",
          "addr": 4385
        },
        "L4": {
          "label": "L4",
          "addr": 4399
        },
        "L5": {
          "label": "L5",
          "addr": 4437
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  if (x < 2)\n    return 0;\n  int c = 0;\n  int i = 2;\n  while (i * i <= x) {\n    while (x % i == 0) {\n      x /= i;\n      c++;\n    }\n    i++;\n  }\n  if (x > 1)\n    c++;\n  return c == 3;\n}"
    },
    {
      "task_id": 75,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  cmp    $0x1,%edi\n  jle    1151 <func0+0x58>\n  mov    $0x2,%ecx\n  mov    $0x0,%esi\n  cmp    $0x3,%edi\n  jg     1135 <func0+0x3c>\n  jmp    1145 <func0+0x4c>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%edi\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1118 <func0+0x1f>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     1140 <func0+0x47>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1118 <func0+0x1f>\n  jmp    1129 <func0+0x30>\n  cmp    $0x1,%edi\n  jle    1148 <func0+0x4f>\n  add    $0x1,%esi\n  cmp    $0x3,%esi\n  sete   %al\n  movzbl %al,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  cmp    $0x1,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  mov    $0x0,%esi\n  cmp    $0x3,%edi\n  jg     L1\n  jmp    L2\nL3:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%edi\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL5:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     L4\nL1:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\n  jmp    L5\nL4:\n  cmp    $0x1,%edi\n  jle    L6\nL2:\n  add    $0x1,%esi\nL6:\n  cmp    $0x3,%esi\n  sete   %al\n  movzbl %al,%eax\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4433
        },
        "L1": {
          "label": "L1",
          "addr": 4405
        },
        "L2": {
          "label": "L2",
          "addr": 4421
        },
        "L3": {
          "label": "L3",
          "addr": 4376
        },
        "L4": {
          "label": "L4",
          "addr": 4416
        },
        "L5": {
          "label": "L5",
          "addr": 4393
        },
        "L6": {
          "label": "L6",
          "addr": 4424
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int c = 0;\n  int i;\n  if (n < 2)\n    return 0;\n  for (i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      n /= i;\n      c++;\n    }\n  }\n  if (n > 1)\n    c++;\n  return c == 3;\n}"
    },
    {
      "task_id": 74,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
      "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    11a0 <func0+0x80>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r15\n  nopl   0x0(%rax)\n  mov    (%rbx),%rdi\n  add    $0x8,%rbx\n  call   1050 <strlen@plt>\n  add    %eax,%ebp\n  cmp    %rbx,%r15\n  jne    1150 <func0+0x30>\n  test   %r12d,%r12d\n  jle    11b0 <func0+0x90>\n  xor    %ebx,%ebx\n  xor    %r15d,%r15d\n  nopl   (%rax)\n  mov    0x0(%r13,%rbx,8),%rdi\n  add    $0x1,%rbx\n  call   1050 <strlen@plt>\n  add    %eax,%r15d\n  cmp    %ebx,%r12d\n  jg     1170 <func0+0x50>\n  cmp    %r15d,%ebp\n  mov    %r13,%rax\n  cmovle %r14,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nop\n  xor    %ebp,%ebp\n  test   %ecx,%ecx\n  jg     1168 <func0+0x48>\n  mov    %rdi,%rax\n  jmp    1190 <func0+0x70>\n  nopl   0x0(%rax,%rax,1)\n  xor    %r15d,%r15d\n  jmp    1186 <func0+0x66>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r15\n  nopl   0x0(%rax)\nL1:\n  mov    (%rbx),%rdi\n  add    $0x8,%rbx\n  call   <strlen@plt>\n  add    %eax,%ebp\n  cmp    %rbx,%r15\n  jne    L1\n  test   %r12d,%r12d\n  jle    L2\nL4:\n  xor    %ebx,%ebx\n  xor    %r15d,%r15d\n  nopl   (%rax)\nL3:\n  mov    0x0(%r13,%rbx,8),%rdi\n  add    $0x1,%rbx\n  call   <strlen@plt>\n  add    %eax,%r15d\n  cmp    %ebx,%r12d\n  jg     L3\nL6:\n  cmp    %r15d,%ebp\n  mov    %r13,%rax\n  cmovle %r14,%rax\nL5:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nop\nL0:\n  xor    %ebp,%ebp\n  test   %ecx,%ecx\n  jg     L4\n  mov    %rdi,%rax\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL2:\n  xor    %r15d,%r15d\n  jmp    L6",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4512
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        },
        "L2": {
          "label": "L2",
          "addr": 4528
        },
        "L3": {
          "label": "L3",
          "addr": 4464
        },
        "L4": {
          "label": "L4",
          "addr": 4456
        },
        "L5": {
          "label": "L5",
          "addr": 4496
        },
        "L6": {
          "label": "L6",
          "addr": 4486
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **s, int n, char **w, int m) {\n  int i, j, sum1 = 0, sum2 = 0;\n  for (i = 0; i < n; i++)\n    sum1 += strlen(s[i]);\n  for (j = 0; j < m; j++)\n    sum2 += strlen(w[j]);\n  if (sum1 > sum2)\n    return s;\n  else\n    return w;\n}"
    },
    {
      "task_id": 74,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
      "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    11a0 <func0+0x80>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r15\n  nopl   0x0(%rax)\n  mov    (%rbx),%rdi\n  add    $0x8,%rbx\n  call   1050 <strlen@plt>\n  add    %eax,%ebp\n  cmp    %rbx,%r15\n  jne    1150 <func0+0x30>\n  test   %r12d,%r12d\n  jle    11b0 <func0+0x90>\n  xor    %ebx,%ebx\n  xor    %r15d,%r15d\n  nopl   (%rax)\n  mov    0x0(%r13,%rbx,8),%rdi\n  add    $0x1,%rbx\n  call   1050 <strlen@plt>\n  add    %eax,%r15d\n  cmp    %ebx,%r12d\n  jg     1170 <func0+0x50>\n  cmp    %r15d,%ebp\n  mov    %r13,%rax\n  cmovle %r14,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nop\n  xor    %ebp,%ebp\n  test   %ecx,%ecx\n  jg     1168 <func0+0x48>\n  mov    %rdi,%rax\n  jmp    1190 <func0+0x70>\n  nopl   0x0(%rax,%rax,1)\n  xor    %r15d,%r15d\n  jmp    1186 <func0+0x66>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r15\n  nopl   0x0(%rax)\nL1:\n  mov    (%rbx),%rdi\n  add    $0x8,%rbx\n  call   <strlen@plt>\n  add    %eax,%ebp\n  cmp    %rbx,%r15\n  jne    L1\n  test   %r12d,%r12d\n  jle    L2\nL4:\n  xor    %ebx,%ebx\n  xor    %r15d,%r15d\n  nopl   (%rax)\nL3:\n  mov    0x0(%r13,%rbx,8),%rdi\n  add    $0x1,%rbx\n  call   <strlen@plt>\n  add    %eax,%r15d\n  cmp    %ebx,%r12d\n  jg     L3\nL6:\n  cmp    %r15d,%ebp\n  mov    %r13,%rax\n  cmovle %r14,%rax\nL5:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nop\nL0:\n  xor    %ebp,%ebp\n  test   %ecx,%ecx\n  jg     L4\n  mov    %rdi,%rax\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL2:\n  xor    %r15d,%r15d\n  jmp    L6",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4512
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        },
        "L2": {
          "label": "L2",
          "addr": 4528
        },
        "L3": {
          "label": "L3",
          "addr": 4464
        },
        "L4": {
          "label": "L4",
          "addr": 4456
        },
        "L5": {
          "label": "L5",
          "addr": 4496
        },
        "L6": {
          "label": "L6",
          "addr": 4486
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **s, int n, char **w, int m) {\n  int i, j, sum1 = 0, sum2 = 0;\n  for (i = 0; i < n; i++)\n    sum1 += strlen(s[i]);\n  for (j = 0; j < m; j++)\n    sum2 += strlen(w[j]);\n  if (sum1 > sum2)\n    return s;\n  else\n    return w;\n}"
    },
    {
      "task_id": 76,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    112f <func0+0x36>\n  cmp    $0x1,%edi\n  je     1135 <func0+0x3c>\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\n  imul   %esi,%edx\n  add    $0x1,%ecx\n  cmp    %edx,%edi\n  jl     1129 <func0+0x30>\n  cmp    $0x63,%ecx\n  jg     1129 <func0+0x30>\n  cmp    %edx,%edi\n  jne    1110 <func0+0x17>\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    %edi,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  cmp    $0x1,%edi\n  je     L1\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\nL3:\n  imul   %esi,%edx\n  add    $0x1,%ecx\n  cmp    %edx,%edi\n  jl     L2\n  cmp    $0x63,%ecx\n  jg     L2\n  cmp    %edx,%edi\n  jne    L3\n  mov    $0x1,%eax\n  ret\nL2:\n  mov    $0x0,%eax\n  ret\nL0:\n  mov    $0x0,%eax\n  ret\nL1:\n  mov    %edi,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4399
        },
        "L1": {
          "label": "L1",
          "addr": 4405
        },
        "L2": {
          "label": "L2",
          "addr": 4393
        },
        "L3": {
          "label": "L3",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n, int a) {\n  int i = 0;\n  int j = 1;\n  while (i < n && j <= n && i < 100) {\n    j = j * a;\n    i++;\n  }\n  if (j == n)\n    return 1;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 74,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
      "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    1177 <func0+0x5e>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     114a <func0+0x31>\n  movl   $0x0,-0xc(%rbp)\n  jmp    11b5 <func0+0x9c>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x4(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x4(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     1188 <func0+0x6f>\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jge    11cb <func0+0xb2>\n  mov    -0x18(%rbp),%rax\n  jmp    11dd <func0+0xc4>\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jle    11d9 <func0+0xc0>\n  mov    -0x28(%rbp),%rax\n  jmp    11dd <func0+0xc4>\n  mov    -0x18(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL1:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L1\n  movl   $0x0,-0xc(%rbp)\n  jmp    L2\nL3:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x4(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x4(%rbp)\n  addl   $0x1,-0xc(%rbp)\nL2:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     L3\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jge    L4\n  mov    -0x18(%rbp),%rax\n  jmp    L5\nL4:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jle    L6\n  mov    -0x28(%rbp),%rax\n  jmp    L5\nL6:\n  mov    -0x18(%rbp),%rax\nL5:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4471
        },
        "L1": {
          "label": "L1",
          "addr": 4426
        },
        "L2": {
          "label": "L2",
          "addr": 4533
        },
        "L3": {
          "label": "L3",
          "addr": 4488
        },
        "L4": {
          "label": "L4",
          "addr": 4555
        },
        "L5": {
          "label": "L5",
          "addr": 4573
        },
        "L6": {
          "label": "L6",
          "addr": 4569
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **x, int n, char **y, int m) {\n  int i, len0, len1;\n  len0 = 0;\n  len1 = 0;\n  for (i = 0; i < n; i++)\n    len0 += strlen(x[i]);\n  for (i = 0; i < m; i++)\n    len1 += strlen(y[i]);\n  if (len0 < len1)\n    return x;\n  else if (len0 > len1)\n    return y;\n  else\n    return x;\n}"
    },
    {
      "task_id": 75,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%edi\n  jle    115a <func0+0x5a>\n  mov    $0x2,%ecx\n  xor    %esi,%esi\n  cmp    $0x3,%edi\n  jle    1164 <func0+0x64>\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    1141 <func0+0x41>\n  nopl   0x0(%rax)\n  mov    %edi,%eax\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%edi\n  idiv   %ecx\n  test   %edx,%edx\n  je     1130 <func0+0x30>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1120 <func0+0x20>\n  cmp    $0x1,%edi\n  jle    115b <func0+0x5b>\n  xor    %eax,%eax\n  cmp    $0x2,%esi\n  sete   %al\n  ret\n  xor    %eax,%eax\n  cmp    $0x3,%esi\n  sete   %al\n  ret\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  xor    %esi,%esi\n  cmp    $0x3,%edi\n  jle    L1\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\n  nopl   0x0(%rax)\nL3:\n  mov    %edi,%eax\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%edi\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L4\n  cmp    $0x1,%edi\n  jle    L5\n  xor    %eax,%eax\n  cmp    $0x2,%esi\n  sete   %al\nL0:\n  ret\nL5:\n  xor    %eax,%eax\n  cmp    $0x3,%esi\n  sete   %al\n  ret\nL1:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4442
        },
        "L1": {
          "label": "L1",
          "addr": 4452
        },
        "L2": {
          "label": "L2",
          "addr": 4417
        },
        "L3": {
          "label": "L3",
          "addr": 4400
        },
        "L4": {
          "label": "L4",
          "addr": 4384
        },
        "L5": {
          "label": "L5",
          "addr": 4443
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int c = 0;\n  int i;\n  for (i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      c++;\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    c++;\n  }\n  return c == 2;\n}"
    },
    {
      "task_id": 75,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%edi\n  jle    115a <func0+0x5a>\n  mov    $0x2,%ecx\n  xor    %esi,%esi\n  cmp    $0x3,%edi\n  jle    1164 <func0+0x64>\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    1141 <func0+0x41>\n  nopl   0x0(%rax)\n  mov    %edi,%eax\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%edi\n  idiv   %ecx\n  test   %edx,%edx\n  je     1130 <func0+0x30>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1120 <func0+0x20>\n  cmp    $0x1,%edi\n  jle    115b <func0+0x5b>\n  xor    %eax,%eax\n  cmp    $0x2,%esi\n  sete   %al\n  ret\n  xor    %eax,%eax\n  cmp    $0x3,%esi\n  sete   %al\n  ret\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  xor    %esi,%esi\n  cmp    $0x3,%edi\n  jle    L1\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\n  nopl   0x0(%rax)\nL3:\n  mov    %edi,%eax\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%edi\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L4\n  cmp    $0x1,%edi\n  jle    L5\n  xor    %eax,%eax\n  cmp    $0x2,%esi\n  sete   %al\nL0:\n  ret\nL5:\n  xor    %eax,%eax\n  cmp    $0x3,%esi\n  sete   %al\n  ret\nL1:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4442
        },
        "L1": {
          "label": "L1",
          "addr": 4452
        },
        "L2": {
          "label": "L2",
          "addr": 4417
        },
        "L3": {
          "label": "L3",
          "addr": 4400
        },
        "L4": {
          "label": "L4",
          "addr": 4384
        },
        "L5": {
          "label": "L5",
          "addr": 4443
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int c = 0;\n  int i;\n  for (i = 2; i * i <= n; i++) {\n    while (n % i == 0) {\n      c++;\n      n /= i;\n    }\n  }\n  if (n > 1) {\n    c++;\n  }\n  return c == 2;\n}"
    },
    {
      "task_id": 77,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1132 <func0+0x39>\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  cmp    %eax,%edx\n  jne    112e <func0+0x35>\n  mov    $0x1,%eax\n  jmp    1151 <func0+0x58>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  cmp    %eax,%edx\n  jle    110d <func0+0x14>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  cmp    %eax,%edx\n  jne    L1\n  mov    $0x1,%eax\n  jmp    L2\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  cmp    %eax,%edx\n  jle    L3\n  mov    $0x0,%eax\nL2:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4402
        },
        "L1": {
          "label": "L1",
          "addr": 4398
        },
        "L2": {
          "label": "L2",
          "addr": 4433
        },
        "L3": {
          "label": "L3",
          "addr": 4365
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x) {\n  int i;\n  for (i = 0; i * i * i <= abs(x); i++)\n    if (i * i * i == abs(x))\n      return 1;\n  return 0;\n}"
    },
    {
      "task_id": 74,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
      "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %rdx,%r12\n  mov    %ecx,%r13d\n  test   %esi,%esi\n  jle    11a1 <func0+0x88>\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r15\n  mov    $0x0,%ebp\n  mov    (%rbx),%rdi\n  call   1050 <strlen@plt>\n  add    %eax,%ebp\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    1148 <func0+0x2f>\n  test   %r13d,%r13d\n  jle    1199 <func0+0x80>\n  mov    $0x0,%ebx\n  mov    $0x0,%r15d\n  mov    (%r12,%rbx,8),%rdi\n  call   1050 <strlen@plt>\n  add    %eax,%r15d\n  add    $0x1,%rbx\n  cmp    %ebx,%r13d\n  jg     116b <func0+0x52>\n  cmp    %r15d,%ebp\n  cmovle %r14,%r12\n  mov    %r12,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    $0x0,%r15d\n  jmp    1180 <func0+0x67>\n  mov    $0x0,%ebp\n  test   %ecx,%ecx\n  jg     1160 <func0+0x47>\n  mov    %rdi,%r12\n  jmp    1187 <func0+0x6e>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %rdx,%r12\n  mov    %ecx,%r13d\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r15\n  mov    $0x0,%ebp\nL1:\n  mov    (%rbx),%rdi\n  call   <strlen@plt>\n  add    %eax,%ebp\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    L1\n  test   %r13d,%r13d\n  jle    L2\nL5:\n  mov    $0x0,%ebx\n  mov    $0x0,%r15d\nL3:\n  mov    (%r12,%rbx,8),%rdi\n  call   <strlen@plt>\n  add    %eax,%r15d\n  add    $0x1,%rbx\n  cmp    %ebx,%r13d\n  jg     L3\nL4:\n  cmp    %r15d,%ebp\n  cmovle %r14,%r12\nL6:\n  mov    %r12,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL2:\n  mov    $0x0,%r15d\n  jmp    L4\nL0:\n  mov    $0x0,%ebp\n  test   %ecx,%ecx\n  jg     L5\n  mov    %rdi,%r12\n  jmp    L6",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4513
        },
        "L1": {
          "label": "L1",
          "addr": 4424
        },
        "L2": {
          "label": "L2",
          "addr": 4505
        },
        "L3": {
          "label": "L3",
          "addr": 4459
        },
        "L4": {
          "label": "L4",
          "addr": 4480
        },
        "L5": {
          "label": "L5",
          "addr": 4448
        },
        "L6": {
          "label": "L6",
          "addr": 4487
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **s, int s_sz, char **w, int w_sz) {\n  int i;\n  int s_len = 0;\n  int w_len = 0;\n  for (i = 0; i < s_sz; i++) {\n    s_len += strlen(s[i]);\n  }\n  for (i = 0; i < w_sz; i++) {\n    w_len += strlen(w[i]);\n  }\n  if (w_len > s_len) {\n    return w;\n  } else {\n    return s;\n  }\n}"
    },
    {
      "task_id": 76,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1138 <func0+0x38>\n  cmp    $0x1,%edi\n  je     112b <func0+0x2b>\n  xor    %edx,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\n  imul   %esi,%eax\n  add    $0x1,%edx\n  cmp    %eax,%edi\n  jl     1138 <func0+0x38>\n  cmp    $0x63,%edx\n  jg     1138 <func0+0x38>\n  cmp    %eax,%edi\n  jne    1118 <func0+0x18>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  cmp    $0x1,%edi\n  je     L1\n  xor    %edx,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\nL2:\n  imul   %esi,%eax\n  add    $0x1,%edx\n  cmp    %eax,%edi\n  jl     L0\n  cmp    $0x63,%edx\n  jg     L0\n  cmp    %eax,%edi\n  jne    L2\nL1:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4395
        },
        "L2": {
          "label": "L2",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n, int a) {\n  int i = 0, j = 1;\n  while (j <= n && i < 100) {\n    j = j * a;\n    i = i + 1;\n  }\n  if (j > n)\n    return 0;\n  else\n    return 1;\n}"
    },
    {
      "task_id": 76,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1138 <func0+0x38>\n  cmp    $0x1,%edi\n  je     112b <func0+0x2b>\n  xor    %edx,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\n  imul   %esi,%eax\n  add    $0x1,%edx\n  cmp    %eax,%edi\n  jl     1138 <func0+0x38>\n  cmp    $0x63,%edx\n  jg     1138 <func0+0x38>\n  cmp    %eax,%edi\n  jne    1118 <func0+0x18>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  cmp    $0x1,%edi\n  je     L1\n  xor    %edx,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\nL2:\n  imul   %esi,%eax\n  add    $0x1,%edx\n  cmp    %eax,%edi\n  jl     L0\n  cmp    $0x63,%edx\n  jg     L0\n  cmp    %eax,%edi\n  jne    L2\nL1:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4395
        },
        "L2": {
          "label": "L2",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n, int a) {\n  int i = 0, j = 1;\n  while (j <= n && i < 100) {\n    j = j * a;\n    i = i + 1;\n  }\n  if (j > n)\n    return 0;\n  else\n    return 1;\n}"
    },
    {
      "task_id": 77,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     1140 <func0+0x40>\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\n  cmp    %eax,%ecx\n  je     1140 <func0+0x40>\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    1120 <func0+0x20>\n  xor    %eax,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     L0\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\nL1:\n  cmp    %eax,%ecx\n  je     L0\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    L1\n  xor    %eax,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, j;\n  if (n < 0)\n    n = -n;\n  if (n == 0)\n    return 1;\n  for (i = 1; i * i * i <= n; i++)\n    if (i * i * i == n)\n      return 1;\n  return 0;\n}"
    },
    {
      "task_id": 77,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     1140 <func0+0x40>\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\n  cmp    %eax,%ecx\n  je     1140 <func0+0x40>\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    1120 <func0+0x20>\n  xor    %eax,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     L0\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\nL1:\n  cmp    %eax,%ecx\n  je     L0\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    L1\n  xor    %eax,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, j;\n  if (n < 0)\n    n = -n;\n  if (n == 0)\n    return 1;\n  for (i = 1; i * i * i <= n; i++)\n    if (i * i * i == n)\n      return 1;\n  return 0;\n}"
    },
    {
      "task_id": 77,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     112b <func0+0x32>\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  cmp    %eax,%ecx\n  je     1131 <func0+0x38>\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    1112 <func0+0x19>\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     L0\n  mov    $0x1,%edx\n  mov    $0x1,%eax\nL2:\n  cmp    %eax,%ecx\n  je     L1\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    L2\n  mov    $0x0,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret\nL1:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4395
        },
        "L1": {
          "label": "L1",
          "addr": 4401
        },
        "L2": {
          "label": "L2",
          "addr": 4370
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, j;\n  i = 1;\n  j = 1;\n  while (i * i * i <= (n > 0 ? n : -n)) {\n    if (i * i * i == (n > 0 ? n : -n))\n      return 1;\n    i = i + 1;\n    j = j + 1;\n  }\n  return 0;\n}"
    },
    {
      "task_id": 80,
      "type": "O0",
      "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  cmp    $0x2,%rax\n  ja     1143 <func0+0x2a>\n  mov    $0x0,%eax\n  jmp    11c1 <func0+0xa8>\n  movl   $0x2,-0x14(%rbp)\n  jmp    11a5 <func0+0x8c>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     119a <func0+0x81>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x2(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    11a1 <func0+0x88>\n  mov    $0x0,%eax\n  jmp    11c1 <func0+0xa8>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     114c <func0+0x33>\n  mov    $0x1,%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    $0x2,%rax\n  ja     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x2,-0x14(%rbp)\n  jmp    L2\nL5:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     L3\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x2(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    L4\nL3:\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  addl   $0x1,-0x14(%rbp)\nL2:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L5\n  mov    $0x1,%eax\nL1:\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4419
        },
        "L1": {
          "label": "L1",
          "addr": 4545
        },
        "L2": {
          "label": "L2",
          "addr": 4517
        },
        "L3": {
          "label": "L3",
          "addr": 4506
        },
        "L4": {
          "label": "L4",
          "addr": 4513
        },
        "L5": {
          "label": "L5",
          "addr": 4428
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *input) {\n  if (strlen(input) < 3)\n    return 0;\n  for (int i = 2; i < strlen(input); i++) {\n    if (input[i] == input[i - 1] || input[i] == input[i - 2])\n      return 0;\n  }\n  return 1;\n}"
    },
    {
      "task_id": 78,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    0xeaf(%rip),%rax        # 2000 <_fini+0xe4c>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1193 <func0+0x5a>\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     118f <func0+0x56>\n  addl   $0x1,-0x20(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     1165 <func0+0x2c>\n  mov    -0x20(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL2:\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\n  addl   $0x1,-0x20(%rbp)\nL1:\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L2\n  mov    -0x20(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3759
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4499
        },
        "L1": {
          "label": "L1",
          "addr": 4495
        },
        "L2": {
          "label": "L2",
          "addr": 4453
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "32333537424400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"2357BD\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *p) {\n  char *q = \"2357BD\";\n  int c = 0;\n  for (int i = 0; i < strlen(p); i++)\n    if (strchr(q, p[i]))\n      c++;\n  return c;\n}"
    },
    {
      "task_id": 78,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  test   %rax,%rax\n  je     11a0 <func0+0x60>\n  lea    (%rbx,%rax,1),%rbp\n  xor    %r12d,%r12d\n  lea    0xe97(%rip),%r13        # 2000 <_fini+0xe4c>\n  nopl   0x0(%rax)\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %rbp,%rbx\n  jne    1170 <func0+0x30>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  test   %rax,%rax\n  je     L0\n  lea    (%rbx,%rax,1),%rbp\n  xor    %r12d,%r12d\n  lea    D0(%rip),%r13\n  nopl   0x0(%rax)\nL1:\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %rbp,%rbx\n  jne    L1\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3735
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4512
        },
        "L1": {
          "label": "L1",
          "addr": 4464
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "32333537424400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"2357BD\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *p) {\n  int count = 0;\n  size_t i;\n  for (i = 0; i < strlen(p); i++)\n    if (strchr(\"2357BD\", p[i]))\n      count++;\n  return count;\n}"
    },
    {
      "task_id": 78,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r12\n  call   1060 <strlen@plt>\n  mov    %r12,%rbx\n  add    %rax,%r12\n  mov    $0x0,%ebp\n  lea    0xe9f(%rip),%r13        # 2000 <_fini+0xe74>\n  jmp    1179 <func0+0x40>\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%ebp\n  add    $0x1,%rbx\n  cmp    %r12,%rbx\n  jne    1163 <func0+0x2a>\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r12\n  call   <strlen@plt>\n  mov    %r12,%rbx\n  add    %rax,%r12\n  mov    $0x0,%ebp\n  lea    D0(%rip),%r13\n  jmp    L0\nL1:\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%ebp\n  add    $0x1,%rbx\nL0:\n  cmp    %r12,%rbx\n  jne    L1\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3743
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4473
        },
        "L1": {
          "label": "L1",
          "addr": 4451
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "32333537424400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"2357BD\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *p) {\n  int i, cnt = 0;\n  size_t len = strlen(p);\n  for (i = 0; i < len; i++)\n    if (strchr(\"2357BD\", p[i]))\n      cnt++;\n  return cnt;\n}"
    },
    {
      "task_id": 80,
      "type": "O2",
      "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x2,%rax\n  jbe    1159 <func0+0x39>\n  mov    %rbx,%rdi\n  lea    -0x2(%rbx,%rax,1),%rdx\n  jmp    114d <func0+0x2d>\n  cmp    (%rdi),%al\n  je     1156 <func0+0x36>\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  je     1160 <func0+0x40>\n  movzbl 0x2(%rdi),%eax\n  cmp    0x1(%rdi),%al\n  jne    1140 <func0+0x20>\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  ret\n  xchg   %ax,%ax\n  mov    $0x1,%r8d\n  pop    %rbx\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x2,%rax\n  jbe    L0\n  mov    %rbx,%rdi\n  lea    -0x2(%rbx,%rax,1),%rdx\n  jmp    L1\nL4:\n  cmp    (%rdi),%al\n  je     L2\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  je     L3\nL1:\n  movzbl 0x2(%rdi),%eax\n  cmp    0x1(%rdi),%al\n  jne    L4\nL2:\n  xor    %r8d,%r8d\nL0:\n  mov    %r8d,%eax\n  pop    %rbx\n  ret\n  xchg   %ax,%ax\nL3:\n  mov    $0x1,%r8d\n  pop    %rbx\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4441
        },
        "L1": {
          "label": "L1",
          "addr": 4429
        },
        "L2": {
          "label": "L2",
          "addr": 4438
        },
        "L3": {
          "label": "L3",
          "addr": 4448
        },
        "L4": {
          "label": "L4",
          "addr": 4416
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const char *s) {\n  size_t len = strlen(s);\n  for (int i = 0; i < len - 2; i++) {\n    if (s[i + 2] == s[i + 1] || s[i + 2] == s[i]) {\n      return 0;\n    }\n  }\n  return 1;\n}"
    },
    {
      "task_id": 78,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  lea    0xeb3(%rip),%r13        # 2000 <_fini+0xe64>\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  lea    (%rbx,%rax,1),%rbp\n  jmp    1187 <func0+0x47>\n  cs nopw 0x0(%rax,%rax,1)\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %rbp,%rbx\n  jne    1170 <func0+0x30>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  lea    D0(%rip),%r13\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  lea    (%rbx,%rax,1),%rbp\n  jmp    L0\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\nL0:\n  cmp    %rbp,%rbx\n  jne    L1\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3763
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4487
        },
        "L1": {
          "label": "L1",
          "addr": 4464
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "32333537424400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"2357BD\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *p) {\n  int i = 0;\n  size_t len = strlen(p);\n  for (i = 0; i < len; i++) {\n    if (strchr(\"2357BD\", p[i])) {\n      i++;\n    }\n  }\n  return i;\n}"
    },
    {
      "task_id": 80,
      "type": "O1",
      "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    $0x0,%edx\n  cmp    $0x2,%rax\n  jbe    115b <func0+0x42>\n  mov    %rbx,%rdx\n  lea    -0x2(%rbx,%rax,1),%rcx\n  movzbl 0x2(%rdx),%eax\n  cmp    0x1(%rdx),%al\n  je     1156 <func0+0x3d>\n  cmp    (%rdx),%al\n  je     115f <func0+0x46>\n  add    $0x1,%rdx\n  cmp    %rcx,%rdx\n  jne    1139 <func0+0x20>\n  mov    $0x1,%edx\n  jmp    115b <func0+0x42>\n  mov    $0x0,%edx\n  mov    %edx,%eax\n  pop    %rbx\n  ret\n  mov    $0x0,%edx\n  jmp    115b <func0+0x42>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    $0x0,%edx\n  cmp    $0x2,%rax\n  jbe    L0\n  mov    %rbx,%rdx\n  lea    -0x2(%rbx,%rax,1),%rcx\nL3:\n  movzbl 0x2(%rdx),%eax\n  cmp    0x1(%rdx),%al\n  je     L1\n  cmp    (%rdx),%al\n  je     L2\n  add    $0x1,%rdx\n  cmp    %rcx,%rdx\n  jne    L3\n  mov    $0x1,%edx\n  jmp    L0\nL1:\n  mov    $0x0,%edx\nL0:\n  mov    %edx,%eax\n  pop    %rbx\n  ret\nL2:\n  mov    $0x0,%edx\n  jmp    L0",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4443
        },
        "L1": {
          "label": "L1",
          "addr": 4438
        },
        "L2": {
          "label": "L2",
          "addr": 4447
        },
        "L3": {
          "label": "L3",
          "addr": 4409
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const char *s) {\n  size_t len = strlen(s);\n  for (size_t i = 0; i < len - 2; ++i) {\n    if (s[i + 2] == s[i + 1])\n      return 0;\n    if (s[i + 2] == s[i])\n      return 0;\n  }\n  return 1;\n}"
    },
    {
      "task_id": 80,
      "type": "O3",
      "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x2,%rax\n  jbe    1159 <func0+0x39>\n  mov    %rbx,%rdi\n  lea    -0x2(%rbx,%rax,1),%rdx\n  jmp    114d <func0+0x2d>\n  cmp    (%rdi),%al\n  je     1156 <func0+0x36>\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  je     1160 <func0+0x40>\n  movzbl 0x2(%rdi),%eax\n  cmp    0x1(%rdi),%al\n  jne    1140 <func0+0x20>\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  ret\n  xchg   %ax,%ax\n  mov    $0x1,%r8d\n  pop    %rbx\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x2,%rax\n  jbe    L0\n  mov    %rbx,%rdi\n  lea    -0x2(%rbx,%rax,1),%rdx\n  jmp    L1\nL4:\n  cmp    (%rdi),%al\n  je     L2\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  je     L3\nL1:\n  movzbl 0x2(%rdi),%eax\n  cmp    0x1(%rdi),%al\n  jne    L4\nL2:\n  xor    %r8d,%r8d\nL0:\n  mov    %r8d,%eax\n  pop    %rbx\n  ret\n  xchg   %ax,%ax\nL3:\n  mov    $0x1,%r8d\n  pop    %rbx\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4441
        },
        "L1": {
          "label": "L1",
          "addr": 4429
        },
        "L2": {
          "label": "L2",
          "addr": 4438
        },
        "L3": {
          "label": "L3",
          "addr": 4448
        },
        "L4": {
          "label": "L4",
          "addr": 4416
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const char *s) {\n  size_t len = strlen(s);\n  for (int i = 0; i < len - 2; i++) {\n    if (s[i + 2] == s[i + 1] || s[i + 2] == s[i]) {\n      return 0;\n    }\n  }\n  return 1;\n}"
    },
    {
      "task_id": 82,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jg     1145 <func0+0x2c>\n  mov    $0x0,%eax\n  jmp    1176 <func0+0x5d>\n  movl   $0x2,-0x8(%rbp)\n  jmp    1166 <func0+0x4d>\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1162 <func0+0x49>\n  mov    $0x0,%eax\n  jmp    1176 <func0+0x5d>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    114e <func0+0x35>\n  mov    $0x1,%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jg     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x2,-0x8(%rbp)\n  jmp    L2\nL4:\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L3\n  mov    $0x0,%eax\n  jmp    L1\nL3:\n  addl   $0x1,-0x8(%rbp)\nL2:\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    L4\n  mov    $0x1,%eax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4421
        },
        "L1": {
          "label": "L1",
          "addr": 4470
        },
        "L2": {
          "label": "L2",
          "addr": 4454
        },
        "L3": {
          "label": "L3",
          "addr": 4450
        },
        "L4": {
          "label": "L4",
          "addr": 4430
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str) {\n  int i, len;\n  len = strlen(str);\n  if (len < 2)\n    return 0;\n  for (i = 2; i * i <= len; i++)\n    if (len % i == 0)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 82,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  mov    $0x0,%edx\n  cmp    $0x1,%eax\n  jle    1161 <func0+0x48>\n  mov    %eax,%esi\n  cmp    $0x3,%eax\n  jle    1168 <func0+0x4f>\n  test   $0x1,%al\n  je     116f <func0+0x56>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     115c <func0+0x43>\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    1140 <func0+0x27>\n  mov    $0x0,%edx\n  jmp    1161 <func0+0x48>\n  mov    $0x1,%edx\n  mov    %edx,%eax\n  add    $0x8,%rsp\n  ret\n  mov    $0x1,%edx\n  jmp    1161 <func0+0x48>\n  mov    $0x0,%edx\n  jmp    1161 <func0+0x48>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    $0x0,%edx\n  cmp    $0x1,%eax\n  jle    L0\n  mov    %eax,%esi\n  cmp    $0x3,%eax\n  jle    L1\n  test   $0x1,%al\n  je     L2\n  mov    $0x2,%ecx\nL4:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     L3\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L4\n  mov    $0x0,%edx\n  jmp    L0\nL3:\n  mov    $0x1,%edx\nL0:\n  mov    %edx,%eax\n  add    $0x8,%rsp\n  ret\nL1:\n  mov    $0x1,%edx\n  jmp    L0\nL2:\n  mov    $0x0,%edx\n  jmp    L0",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4449
        },
        "L1": {
          "label": "L1",
          "addr": 4456
        },
        "L2": {
          "label": "L2",
          "addr": 4463
        },
        "L3": {
          "label": "L3",
          "addr": 4444
        },
        "L4": {
          "label": "L4",
          "addr": 4416
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  int i, len;\n  len = strlen(s);\n  if (len < 2)\n    return 0;\n  for (i = 2; i * i <= len; i++)\n    if (len % i == 0)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 82,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x1,%eax\n  jle    116b <func0+0x4b>\n  cmp    $0x3,%eax\n  jle    1165 <func0+0x45>\n  test   $0x1,%al\n  je     116b <func0+0x4b>\n  mov    %eax,%esi\n  mov    $0x2,%ecx\n  jmp    1159 <func0+0x39>\n  nopw   0x0(%rax,%rax,1)\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1178 <func0+0x58>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    1150 <func0+0x30>\n  mov    $0x1,%r8d\n  mov    %r8d,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x1,%eax\n  jle    L0\n  cmp    $0x3,%eax\n  jle    L1\n  test   $0x1,%al\n  je     L0\n  mov    %eax,%esi\n  mov    $0x2,%ecx\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    L4\nL1:\n  mov    $0x1,%r8d\nL0:\n  mov    %r8d,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  xor    %r8d,%r8d\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4459
        },
        "L1": {
          "label": "L1",
          "addr": 4453
        },
        "L2": {
          "label": "L2",
          "addr": 4441
        },
        "L3": {
          "label": "L3",
          "addr": 4472
        },
        "L4": {
          "label": "L4",
          "addr": 4432
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  int len = strlen(s);\n  if (len < 2)\n    return 0;\n  int i;\n  for (i = 2; i * i <= len; i++)\n    if (len % i == 0)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 82,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x1,%eax\n  jle    116b <func0+0x4b>\n  cmp    $0x3,%eax\n  jle    1165 <func0+0x45>\n  test   $0x1,%al\n  je     116b <func0+0x4b>\n  mov    %eax,%esi\n  mov    $0x2,%ecx\n  jmp    1159 <func0+0x39>\n  nopw   0x0(%rax,%rax,1)\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1178 <func0+0x58>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    1150 <func0+0x30>\n  mov    $0x1,%r8d\n  mov    %r8d,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x1,%eax\n  jle    L0\n  cmp    $0x3,%eax\n  jle    L1\n  test   $0x1,%al\n  je     L0\n  mov    %eax,%esi\n  mov    $0x2,%ecx\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    L4\nL1:\n  mov    $0x1,%r8d\nL0:\n  mov    %r8d,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  xor    %r8d,%r8d\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4459
        },
        "L1": {
          "label": "L1",
          "addr": 4453
        },
        "L2": {
          "label": "L2",
          "addr": 4441
        },
        "L3": {
          "label": "L3",
          "addr": 4472
        },
        "L4": {
          "label": "L4",
          "addr": 4432
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  int len = strlen(s);\n  if (len < 2)\n    return 0;\n  int i;\n  for (i = 2; i * i <= len; i++)\n    if (len % i == 0)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 83,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     1111 <func0+0x18>\n  mov    $0x0,%eax\n  jmp    114c <func0+0x53>\n  cmpl   $0x1,-0x14(%rbp)\n  jne    111e <func0+0x25>\n  mov    $0x1,%eax\n  jmp    114c <func0+0x53>\n  movl   $0x12,-0x8(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    1141 <func0+0x48>\n  mov    -0x8(%rbp),%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     112e <func0+0x35>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  cmpl   $0x1,-0x14(%rbp)\n  jne    L2\n  mov    $0x1,%eax\n  jmp    L1\nL2:\n  movl   $0x12,-0x8(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    L3\nL4:\n  mov    -0x8(%rbp),%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL3:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L4\n  mov    -0x8(%rbp),%eax\nL1:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4369
        },
        "L1": {
          "label": "L1",
          "addr": 4428
        },
        "L2": {
          "label": "L2",
          "addr": 4382
        },
        "L3": {
          "label": "L3",
          "addr": 4417
        },
        "L4": {
          "label": "L4",
          "addr": 4398
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, j;\n  if (n <= 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  j = 18;\n  for (i = 2; i < n; i++)\n    j *= 10;\n  return j;\n}"
    },
    {
      "task_id": 83,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    113d <func0+0x3d>\n  mov    $0x1,%eax\n  cmp    $0x1,%edi\n  je     113d <func0+0x3d>\n  cmp    $0x2,%edi\n  je     1138 <func0+0x38>\n  mov    $0x2,%edx\n  mov    $0x12,%eax\n  nopl   0x0(%rax,%rax,1)\n  lea    (%rax,%rax,4),%eax\n  add    $0x1,%edx\n  add    %eax,%eax\n  cmp    %edx,%edi\n  jne    1128 <func0+0x28>\n  ret\n  nopl   (%rax)\n  mov    $0x12,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    L0\n  mov    $0x1,%eax\n  cmp    $0x1,%edi\n  je     L0\n  cmp    $0x2,%edi\n  je     L1\n  mov    $0x2,%edx\n  mov    $0x12,%eax\n  nopl   0x0(%rax,%rax,1)\nL2:\n  lea    (%rax,%rax,4),%eax\n  add    $0x1,%edx\n  add    %eax,%eax\n  cmp    %edx,%edi\n  jne    L2\n  ret\n  nopl   (%rax)\nL1:\n  mov    $0x12,%eax\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4413
        },
        "L1": {
          "label": "L1",
          "addr": 4408
        },
        "L2": {
          "label": "L2",
          "addr": 4392
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, sum = 18;\n  if (n <= 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  for (i = 2; i < n; i++)\n    sum *= 10;\n  return sum;\n}"
    },
    {
      "task_id": 83,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  test   %edi,%edi\n  jle    112e <func0+0x35>\n  mov    %edi,%eax\n  cmp    $0x1,%edi\n  je     112e <func0+0x35>\n  cmp    $0x2,%edi\n  jle    1129 <func0+0x30>\n  mov    $0x2,%edx\n  mov    $0x12,%eax\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  add    $0x1,%edx\n  cmp    %edx,%edi\n  jne    111c <func0+0x23>\n  ret\n  mov    $0x12,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%eax\n  cmp    $0x1,%edi\n  je     L0\n  cmp    $0x2,%edi\n  jle    L1\n  mov    $0x2,%edx\n  mov    $0x12,%eax\nL2:\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  add    $0x1,%edx\n  cmp    %edx,%edi\n  jne    L2\n  ret\nL1:\n  mov    $0x12,%eax\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4398
        },
        "L1": {
          "label": "L1",
          "addr": 4393
        },
        "L2": {
          "label": "L2",
          "addr": 4380
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, sum = 18;\n  if (n <= 0)\n    return 0;\n  if (n == 1)\n    return 18;\n  for (i = 2; i < n; i++)\n    sum *= 10;\n  return sum;\n}"
    },
    {
      "task_id": 79,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  call   10b0 <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     124a <func0+0xd1>\n  movb   $0x0,0x3f(%rax)\n  test   %ebx,%ebx\n  je     11db <func0+0x62>\n  mov    $0x3d,%edx\n  mov    $0x3e,%esi\n  jle    11e4 <func0+0x6b>\n  mov    %edx,%esi\n  mov    %ebx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  add    $0x30,%eax\n  mov    %al,0x1(%rbp,%rdx,1)\n  mov    %ebx,%ecx\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  sub    $0x1,%rdx\n  cmp    $0x1,%ecx\n  jg     11ad <func0+0x34>\n  jmp    11e4 <func0+0x6b>\n  movb   $0x30,0x3e(%rax)\n  mov    $0x3d,%esi\n  lea    -0x1(%rsi),%eax\n  movslq %esi,%rsi\n  movb   $0x62,0x0(%rbp,%rsi,1)\n  movslq %eax,%r12\n  add    %rbp,%r12\n  movb   $0x64,(%r12)\n  mov    $0x41,%edi\n  sub    %eax,%edi\n  movslq %edi,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%rbx\n  test   %rax,%rax\n  je     1240 <func0+0xc7>\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcpy@plt>\n  mov    %rbx,%rdi\n  call   10a0 <strlen@plt>\n  add    %rbx,%rax\n  movw   $0x6264,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  mov    %rbx,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  jmp    1238 <func0+0xbf>\n  mov    %rax,%rbx\n  jmp    1238 <func0+0xbf>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     L0\n  movb   $0x0,0x3f(%rax)\n  test   %ebx,%ebx\n  je     L1\n  mov    $0x3d,%edx\n  mov    $0x3e,%esi\n  jle    L2\nL3:\n  mov    %edx,%esi\n  mov    %ebx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  add    $0x30,%eax\n  mov    %al,0x1(%rbp,%rdx,1)\n  mov    %ebx,%ecx\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  sub    $0x1,%rdx\n  cmp    $0x1,%ecx\n  jg     L3\n  jmp    L2\nL1:\n  movb   $0x30,0x3e(%rax)\n  mov    $0x3d,%esi\nL2:\n  lea    -0x1(%rsi),%eax\n  movslq %esi,%rsi\n  movb   $0x62,0x0(%rbp,%rsi,1)\n  movslq %eax,%r12\n  add    %rbp,%r12\n  movb   $0x64,(%r12)\n  mov    $0x41,%edi\n  sub    %eax,%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbx\n  test   %rax,%rax\n  je     L4\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  add    %rbx,%rax\n  movw   $0x6264,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    %rbp,%rdi\n  call   <free@plt>\nL5:\n  mov    %rbx,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL4:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  jmp    L5\nL0:\n  mov    %rax,%rbx\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4682
        },
        "L1": {
          "label": "L1",
          "addr": 4571
        },
        "L2": {
          "label": "L2",
          "addr": 4580
        },
        "L3": {
          "label": "L3",
          "addr": 4525
        },
        "L4": {
          "label": "L4",
          "addr": 4672
        },
        "L5": {
          "label": "L5",
          "addr": 4664
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int a) {\n  char *p = malloc(64);\n  if (p == NULL)\n    return NULL;\n  p[63] = 0;\n  int i = 62;\n  if (a == 0) {\n    p[62] = '0';\n    i--;\n  }\n  while (a > 0) {\n    p[i--] = (a % 2) + '0';\n    a /= 2;\n  }\n  p[i--] = 'b';\n  p[i] = 'd';\n  char *ret = malloc(65 - i);\n  if (ret == NULL) {\n    free(p);\n    return NULL;\n  }\n  strcpy(ret, p + i + 1);\n  strcat(ret, \"bd\");\n  free(p);\n  return ret;\n}"
    },
    {
      "task_id": 79,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  sub    $0x8,%rsp\n  call   1090 <malloc@plt>\n  test   %rax,%rax\n  je     1245 <func0+0xe5>\n  movb   $0x0,0x3f(%rax)\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jne    11f0 <func0+0x90>\n  movb   $0x30,0x3e(%rax)\n  mov    $0x5,%edi\n  mov    $0x3c,%r13d\n  mov    $0x3d,%eax\n  add    %rbp,%r13\n  movb   $0x62,0x0(%rbp,%rax,1)\n  movb   $0x64,0x0(%r13)\n  call   1090 <malloc@plt>\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     11d3 <func0+0x73>\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   1080 <stpcpy@plt>\n  mov    $0x6264,%edx\n  mov    %dx,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\n  mov    $0x3d,%eax\n  jle    1230 <func0+0xd0>\n  nopw   0x0(%rax,%rax,1)\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rbp,%rax,1)\n  sub    $0x1,%rax\n  sar    %ebx\n  jne    1200 <func0+0xa0>\n  movslq %ecx,%rax\n  mov    $0x41,%edi\n  sub    $0x1,%ecx\n  sub    %ecx,%edi\n  movslq %ecx,%r13\n  movslq %edi,%rdi\n  jmp    11a2 <func0+0x42>\n  xchg   %ax,%ax\n  mov    $0x4,%edi\n  mov    $0x3d,%r13d\n  mov    $0x3e,%eax\n  jmp    11a2 <func0+0x42>\n  xor    %r12d,%r12d\n  jmp    11db <func0+0x7b>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L0\n  movb   $0x0,0x3f(%rax)\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jne    L1\n  movb   $0x30,0x3e(%rax)\n  mov    $0x5,%edi\n  mov    $0x3c,%r13d\n  mov    $0x3d,%eax\nL5:\n  add    %rbp,%r13\n  movb   $0x62,0x0(%rbp,%rax,1)\n  movb   $0x64,0x0(%r13)\n  call   <malloc@plt>\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     L2\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   <stpcpy@plt>\n  mov    $0x6264,%edx\n  mov    %dx,(%rax)\n  movb   $0x0,0x2(%rax)\nL2:\n  mov    %rbp,%rdi\n  call   <free@plt>\nL6:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    $0x3d,%eax\n  jle    L3\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rbp,%rax,1)\n  sub    $0x1,%rax\n  sar    %ebx\n  jne    L4\n  movslq %ecx,%rax\n  mov    $0x41,%edi\n  sub    $0x1,%ecx\n  sub    %ecx,%edi\n  movslq %ecx,%r13\n  movslq %edi,%rdi\n  jmp    L5\n  xchg   %ax,%ax\nL3:\n  mov    $0x4,%edi\n  mov    $0x3d,%r13d\n  mov    $0x3e,%eax\n  jmp    L5\nL0:\n  xor    %r12d,%r12d\n  jmp    L6",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4677
        },
        "L1": {
          "label": "L1",
          "addr": 4592
        },
        "L2": {
          "label": "L2",
          "addr": 4563
        },
        "L3": {
          "label": "L3",
          "addr": 4656
        },
        "L4": {
          "label": "L4",
          "addr": 4608
        },
        "L5": {
          "label": "L5",
          "addr": 4514
        },
        "L6": {
          "label": "L6",
          "addr": 4571
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int x) {\n  char *buf = malloc(64);\n  if (!buf)\n    return NULL;\n  buf[63] = 0;\n  int i = 62;\n  if (x == 0)\n    buf[62] = '0';\n  else\n    while (x) {\n      buf[i--] = (x % 2) + '0';\n      x /= 2;\n    }\n  buf[i--] = 'b';\n  buf[i] = 'd';\n  char *ret = malloc(5);\n  if (!ret) {\n    free(buf);\n    return NULL;\n  }\n  ret = stpcpy(ret, buf + i);\n  ret[0] = 'b';\n  ret[1] = 'd';\n  ret[2] = 0;\n  free(buf);\n  return ret;\n}"
    },
    {
      "task_id": 79,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  sub    $0x8,%rsp\n  call   1090 <malloc@plt>\n  test   %rax,%rax\n  je     1245 <func0+0xe5>\n  movb   $0x0,0x3f(%rax)\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jne    11f0 <func0+0x90>\n  movb   $0x30,0x3e(%rax)\n  mov    $0x5,%edi\n  mov    $0x3c,%r13d\n  mov    $0x3d,%eax\n  add    %rbp,%r13\n  movb   $0x62,0x0(%rbp,%rax,1)\n  movb   $0x64,0x0(%r13)\n  call   1090 <malloc@plt>\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     11d3 <func0+0x73>\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   1080 <stpcpy@plt>\n  mov    $0x6264,%edx\n  mov    %dx,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\n  mov    $0x3d,%eax\n  jle    1230 <func0+0xd0>\n  nopw   0x0(%rax,%rax,1)\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rbp,%rax,1)\n  sub    $0x1,%rax\n  sar    %ebx\n  jne    1200 <func0+0xa0>\n  movslq %ecx,%rax\n  mov    $0x41,%edi\n  sub    $0x1,%ecx\n  sub    %ecx,%edi\n  movslq %ecx,%r13\n  movslq %edi,%rdi\n  jmp    11a2 <func0+0x42>\n  xchg   %ax,%ax\n  mov    $0x4,%edi\n  mov    $0x3d,%r13d\n  mov    $0x3e,%eax\n  jmp    11a2 <func0+0x42>\n  xor    %r12d,%r12d\n  jmp    11db <func0+0x7b>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L0\n  movb   $0x0,0x3f(%rax)\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jne    L1\n  movb   $0x30,0x3e(%rax)\n  mov    $0x5,%edi\n  mov    $0x3c,%r13d\n  mov    $0x3d,%eax\nL5:\n  add    %rbp,%r13\n  movb   $0x62,0x0(%rbp,%rax,1)\n  movb   $0x64,0x0(%r13)\n  call   <malloc@plt>\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     L2\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   <stpcpy@plt>\n  mov    $0x6264,%edx\n  mov    %dx,(%rax)\n  movb   $0x0,0x2(%rax)\nL2:\n  mov    %rbp,%rdi\n  call   <free@plt>\nL6:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    $0x3d,%eax\n  jle    L3\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rbp,%rax,1)\n  sub    $0x1,%rax\n  sar    %ebx\n  jne    L4\n  movslq %ecx,%rax\n  mov    $0x41,%edi\n  sub    $0x1,%ecx\n  sub    %ecx,%edi\n  movslq %ecx,%r13\n  movslq %edi,%rdi\n  jmp    L5\n  xchg   %ax,%ax\nL3:\n  mov    $0x4,%edi\n  mov    $0x3d,%r13d\n  mov    $0x3e,%eax\n  jmp    L5\nL0:\n  xor    %r12d,%r12d\n  jmp    L6",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4677
        },
        "L1": {
          "label": "L1",
          "addr": 4592
        },
        "L2": {
          "label": "L2",
          "addr": 4563
        },
        "L3": {
          "label": "L3",
          "addr": 4656
        },
        "L4": {
          "label": "L4",
          "addr": 4608
        },
        "L5": {
          "label": "L5",
          "addr": 4514
        },
        "L6": {
          "label": "L6",
          "addr": 4571
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int x) {\n  char *buf = malloc(64);\n  if (!buf)\n    return NULL;\n  buf[63] = 0;\n  int i = 62;\n  if (x == 0)\n    buf[62] = '0';\n  else\n    while (x) {\n      buf[i--] = (x % 2) + '0';\n      x /= 2;\n    }\n  buf[i--] = 'b';\n  buf[i] = 'd';\n  char *ret = malloc(5);\n  if (!ret) {\n    free(buf);\n    return NULL;\n  }\n  ret = stpcpy(ret, buf + i);\n  ret[0] = 'b';\n  ret[1] = 'd';\n  ret[2] = 0;\n  free(buf);\n  return ret;\n}"
    },
    {
      "task_id": 79,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    $0x40,%edi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x10(%rbp)\n  cmpq   $0x0,-0x10(%rbp)\n  jne    11a7 <func0+0x2e>\n  mov    $0x0,%eax\n  jmp    12cd <func0+0x154>\n  movl   $0x3e,-0x1c(%rbp)\n  mov    -0x10(%rbp),%rax\n  add    $0x3f,%rax\n  movb   $0x0,(%rax)\n  cmpl   $0x0,-0x24(%rbp)\n  jne    120e <func0+0x95>\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x30,(%rax)\n  jmp    1214 <func0+0x9b>\n  mov    -0x24(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x24(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x24(%rbp)\n  cmpl   $0x0,-0x24(%rbp)\n  jg     11d7 <func0+0x5e>\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x62,(%rax)\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x64,(%rax)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x18(%rbp)\n  mov    $0x3e,%eax\n  sub    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  add    $0x3,%eax\n  cltq\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    1282 <func0+0x109>\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    $0x0,%eax\n  jmp    12cd <func0+0x154>\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcpy@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movw   $0x6264,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    $0x40,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x10(%rbp)\n  cmpq   $0x0,-0x10(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x3e,-0x1c(%rbp)\n  mov    -0x10(%rbp),%rax\n  add    $0x3f,%rax\n  movb   $0x0,(%rax)\n  cmpl   $0x0,-0x24(%rbp)\n  jne    L2\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x30,(%rax)\n  jmp    L3\nL4:\n  mov    -0x24(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x24(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x24(%rbp)\nL2:\n  cmpl   $0x0,-0x24(%rbp)\n  jg     L4\nL3:\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x62,(%rax)\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x64,(%rax)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x18(%rbp)\n  mov    $0x3e,%eax\n  sub    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  add    $0x3,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L5\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    $0x0,%eax\n  jmp    L1\nL5:\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movw   $0x6264,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4519
        },
        "L1": {
          "label": "L1",
          "addr": 4813
        },
        "L2": {
          "label": "L2",
          "addr": 4622
        },
        "L3": {
          "label": "L3",
          "addr": 4628
        },
        "L4": {
          "label": "L4",
          "addr": 4567
        },
        "L5": {
          "label": "L5",
          "addr": 4738
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int n) {\n  char *buf = malloc(64);\n  if (buf == NULL)\n    return NULL;\n  int i = 62;\n  buf[63] = '\\0';\n  if (n == 0)\n    buf[i--] = '0';\n  else\n    while (n > 0) {\n      buf[i--] = (n % 2) + '0';\n      n /= 2;\n    }\n  buf[i--] = 'b';\n  buf[i--] = 'd';\n  int len = 62 - i + 1;\n  int len2 = 62 - (i + 1) + 3;\n  char *buf2 = malloc(len2);\n  if (buf2 == NULL) {\n    free(buf);\n    return NULL;\n  }\n  strcpy(buf2, buf + len);\n  strcat(buf2, \"bd\");\n  free(buf);\n  return buf2;\n}"
    },
    {
      "task_id": 83,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    1175 <func0+0x75>\n  mov    $0x1,%eax\n  cmp    $0x1,%edi\n  je     1175 <func0+0x75>\n  cmp    $0x2,%edi\n  je     1170 <func0+0x70>\n  lea    -0x2(%rdi),%ecx\n  cmp    $0x3,%edi\n  je     1176 <func0+0x76>\n  movq   0xed7(%rip),%xmm0        # 2000 <_fini+0xe7c>\n  mov    %ecx,%edx\n  xor    %eax,%eax\n  shr    %edx\n  nop\n  movdqa %xmm0,%xmm1\n  add    $0x1,%eax\n  pslld  $0x2,%xmm1\n  paddd  %xmm1,%xmm0\n  pslld  $0x1,%xmm0\n  cmp    %eax,%edx\n  jne    1130 <func0+0x30>\n  movd   %xmm0,%edx\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm2,%eax\n  imul   %edx,%eax\n  lea    (%rax,%rax,8),%eax\n  add    %eax,%eax\n  and    $0x1,%ecx\n  je     1180 <func0+0x80>\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  ret\n  nopl   0x0(%rax)\n  mov    $0x12,%eax\n  ret\n  mov    $0x12,%eax\n  jmp    1163 <func0+0x63>\n  nopl   (%rax)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    L0\n  mov    $0x1,%eax\n  cmp    $0x1,%edi\n  je     L0\n  cmp    $0x2,%edi\n  je     L1\n  lea    -0x2(%rdi),%ecx\n  cmp    $0x3,%edi\n  je     L2\n  movq   D0(%rip),%xmm0\n  mov    %ecx,%edx\n  xor    %eax,%eax\n  shr    %edx\n  nop\nL3:\n  movdqa %xmm0,%xmm1\n  add    $0x1,%eax\n  pslld  $0x2,%xmm1\n  paddd  %xmm1,%xmm0\n  pslld  $0x1,%xmm0\n  cmp    %eax,%edx\n  jne    L3\n  movd   %xmm0,%edx\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm2,%eax\n  imul   %edx,%eax\n  lea    (%rax,%rax,8),%eax\n  add    %eax,%eax\n  and    $0x1,%ecx\n  je     L4\nL5:\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    $0x12,%eax\nL0:\n  ret\nL2:\n  mov    $0x12,%eax\n  jmp    L5\n  nopl   (%rax)\nL4:\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3799
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4469
        },
        "L1": {
          "label": "L1",
          "addr": 4464
        },
        "L2": {
          "label": "L2",
          "addr": 4470
        },
        "L3": {
          "label": "L3",
          "addr": 4400
        },
        "L4": {
          "label": "L4",
          "addr": 4480
        },
        "L5": {
          "label": "L5",
          "addr": 4451
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0100000001000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[8]",
            "value": [
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i, sum = 0;\n  if (n <= 0)\n    return 0;\n  if (n == 1)\n    return 1;\n  if (n == 2)\n    return 18;\n  for (i = 0; i < n - 2; i++)\n    sum += 10 * i;\n  return sum;\n}"
    },
    {
      "task_id": 85,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    112e <func0+0x35>\n  lea    0x4(%rdi),%rax\n  sub    $0x2,%esi\n  shr    %esi\n  mov    %esi,%esi\n  lea    0xc(%rdi,%rsi,8),%rdi\n  mov    $0x0,%edx\n  mov    (%rax),%ecx\n  lea    (%rdx,%rcx,1),%esi\n  test   $0x1,%cl\n  cmove  %esi,%edx\n  add    $0x8,%rax\n  cmp    %rdi,%rax\n  jne    1117 <func0+0x1e>\n  mov    %edx,%eax\n  ret\n  mov    $0x0,%edx\n  jmp    112b <func0+0x32>",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    0x4(%rdi),%rax\n  sub    $0x2,%esi\n  shr    %esi\n  mov    %esi,%esi\n  lea    0xc(%rdi,%rsi,8),%rdi\n  mov    $0x0,%edx\nL1:\n  mov    (%rax),%ecx\n  lea    (%rdx,%rcx,1),%esi\n  test   $0x1,%cl\n  cmove  %esi,%edx\n  add    $0x8,%rax\n  cmp    %rdi,%rax\n  jne    L1\nL2:\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x0,%edx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4398
        },
        "L1": {
          "label": "L1",
          "addr": 4375
        },
        "L2": {
          "label": "L2",
          "addr": 4395
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i;\n  int sum = 0;\n  for (i = 1; i < len; i += 2) {\n    if (arr[i] % 2 == 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}"
    },
    {
      "task_id": 85,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1140 <func0+0x40>\n  sub    $0x2,%esi\n  lea    0x4(%rdi),%rax\n  xor    %r8d,%r8d\n  shr    %esi\n  lea    0xc(%rdi,%rsi,8),%rsi\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rax),%edx\n  lea    (%r8,%rdx,1),%ecx\n  and    $0x1,%edx\n  cmove  %ecx,%r8d\n  add    $0x8,%rax\n  cmp    %rsi,%rax\n  jne    1120 <func0+0x20>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  sub    $0x2,%esi\n  lea    0x4(%rdi),%rax\n  xor    %r8d,%r8d\n  shr    %esi\n  lea    0xc(%rdi,%rsi,8),%rsi\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    (%rax),%edx\n  lea    (%r8,%rdx,1),%ecx\n  and    $0x1,%edx\n  cmove  %ecx,%r8d\n  add    $0x8,%rax\n  cmp    %rsi,%rax\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i;\n  int sum = 0;\n  for (i = 1; i < len; i += 2) {\n    if (arr[i] % 2 == 0) {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}"
    },
    {
      "task_id": 85,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    115e <func0+0x65>\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    115a <func0+0x61>\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jg     1118 <func0+0x1f>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jg     L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4446
        },
        "L1": {
          "label": "L1",
          "addr": 4442
        },
        "L2": {
          "label": "L2",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int sum = 0;\n  for (int i = 0; i * 2 + 1 < len; i++) {\n    if (arr[i * 2 + 1] % 2 == 0) {\n      sum += arr[i * 2 + 1];\n    }\n  }\n  return sum;\n}"
    },
    {
      "task_id": 85,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rdx\n  mov    %esi,%ecx\n  cmp    $0x1,%esi\n  jle    1200 <func0+0x100>\n  lea    -0x2(%rsi),%esi\n  cmp    $0x7,%esi\n  jbe    1203 <func0+0x103>\n  shr    $0x3,%esi\n  lea    0x4(%rdi),%rax\n  pxor   %xmm2,%xmm2\n  movdqa 0xecf(%rip),%xmm4        # 2000 <_fini+0xdf0>\n  lea    -0x1(%rsi),%edi\n  movdqa %xmm2,%xmm3\n  shl    $0x5,%rdi\n  lea    0x24(%rdx,%rdi,1),%rdi\n  nopl   0x0(%rax)\n  movdqu (%rax),%xmm1\n  movdqu 0x10(%rax),%xmm5\n  add    $0x20,%rax\n  shufps $0x88,%xmm5,%xmm1\n  movdqa %xmm1,%xmm0\n  pand   %xmm4,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  pand   %xmm1,%xmm0\n  paddd  %xmm0,%xmm2\n  cmp    %rax,%rdi\n  jne    1148 <func0+0x48>\n  movdqa %xmm2,%xmm0\n  lea    0x0(,%rsi,4),%edi\n  lea    0x1(,%rsi,8),%esi\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%eax\n  movslq %esi,%rsi\n  mov    (%rdx,%rsi,4),%esi\n  lea    (%rax,%rsi,1),%r8d\n  and    $0x1,%esi\n  lea    0x2(%rdi,%rdi,1),%esi\n  lea    0x1(%rsi),%edi\n  cmove  %r8d,%eax\n  cmp    %edi,%ecx\n  jle    1202 <func0+0x102>\n  movslq %edi,%rdi\n  mov    (%rdx,%rdi,4),%edi\n  lea    (%rax,%rdi,1),%r8d\n  and    $0x1,%edi\n  lea    0x3(%rsi),%edi\n  cmove  %r8d,%eax\n  cmp    %edi,%ecx\n  jle    1202 <func0+0x102>\n  movslq %edi,%rdi\n  mov    (%rdx,%rdi,4),%edi\n  lea    (%rax,%rdi,1),%r8d\n  and    $0x1,%edi\n  cmove  %r8d,%eax\n  add    $0x5,%esi\n  cmp    %esi,%ecx\n  jle    1202 <func0+0x102>\n  movslq %esi,%rsi\n  mov    (%rdx,%rsi,4),%edx\n  lea    (%rax,%rdx,1),%ecx\n  and    $0x1,%edx\n  cmove  %ecx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret\n  xor    %edi,%edi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  jmp    119e <func0+0x9e>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rdx\n  mov    %esi,%ecx\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%esi\n  cmp    $0x7,%esi\n  jbe    L1\n  shr    $0x3,%esi\n  lea    0x4(%rdi),%rax\n  pxor   %xmm2,%xmm2\n  movdqa D0(%rip),%xmm4\n  lea    -0x1(%rsi),%edi\n  movdqa %xmm2,%xmm3\n  shl    $0x5,%rdi\n  lea    0x24(%rdx,%rdi,1),%rdi\n  nopl   0x0(%rax)\nL2:\n  movdqu (%rax),%xmm1\n  movdqu 0x10(%rax),%xmm5\n  add    $0x20,%rax\n  shufps $0x88,%xmm5,%xmm1\n  movdqa %xmm1,%xmm0\n  pand   %xmm4,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  pand   %xmm1,%xmm0\n  paddd  %xmm0,%xmm2\n  cmp    %rax,%rdi\n  jne    L2\n  movdqa %xmm2,%xmm0\n  lea    0x0(,%rsi,4),%edi\n  lea    0x1(,%rsi,8),%esi\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%eax\nL4:\n  movslq %esi,%rsi\n  mov    (%rdx,%rsi,4),%esi\n  lea    (%rax,%rsi,1),%r8d\n  and    $0x1,%esi\n  lea    0x2(%rdi,%rdi,1),%esi\n  lea    0x1(%rsi),%edi\n  cmove  %r8d,%eax\n  cmp    %edi,%ecx\n  jle    L3\n  movslq %edi,%rdi\n  mov    (%rdx,%rdi,4),%edi\n  lea    (%rax,%rdi,1),%r8d\n  and    $0x1,%edi\n  lea    0x3(%rsi),%edi\n  cmove  %r8d,%eax\n  cmp    %edi,%ecx\n  jle    L3\n  movslq %edi,%rdi\n  mov    (%rdx,%rdi,4),%edi\n  lea    (%rax,%rdi,1),%r8d\n  and    $0x1,%edi\n  cmove  %r8d,%eax\n  add    $0x5,%esi\n  cmp    %esi,%ecx\n  jle    L3\n  movslq %esi,%rsi\n  mov    (%rdx,%rsi,4),%edx\n  lea    (%rax,%rdx,1),%ecx\n  and    $0x1,%edx\n  cmove  %ecx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\nL3:\n  ret\nL1:\n  xor    %edi,%edi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  jmp    L4",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3791
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4608
        },
        "L1": {
          "label": "L1",
          "addr": 4611
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        },
        "L3": {
          "label": "L3",
          "addr": 4610
        },
        "L4": {
          "label": "L4",
          "addr": 4510
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "01000000010000000100000001000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, sum = 0;\n  for (i = 1; i < len; i++) {\n    if (arr[i] % 2 == 0)\n      sum += arr[i];\n    else\n      break;\n  }\n  return sum;\n}"
    },
    {
      "task_id": 84,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %edi,-0x34(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x34(%rbp),%edx\n  lea    -0xe(%rbp),%rax\n  lea    0xe7b(%rip),%rcx        # 2000 <_fini+0xd2c>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1090 <sprintf@plt>\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    11bc <func0+0x63>\n  mov    -0x24(%rbp),%eax\n  cltq\n  movzbl -0xe(%rbp,%rax,1),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x28(%rbp)\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  movzbl -0xe(%rbp,%rax,1),%eax\n  test   %al,%al\n  jne    11a5 <func0+0x4c>\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  cmpl   $0x0,-0x28(%rbp)\n  jne    1234 <func0+0xdb>\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x30,(%rax)\n  jmp    123a <func0+0xe1>\n  mov    -0x28(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x28(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x28(%rbp)\n  cmpl   $0x0,-0x28(%rbp)\n  jg     11fd <func0+0xa4>\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    12a8 <func0+0x14f>\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x29(%rbp)\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x29(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x20(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     1253 <func0+0xfa>\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     12d1 <func0+0x178>\n  call   1070 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %edi,-0x34(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x34(%rbp),%edx\n  lea    -0xe(%rbp),%rax\n  lea    D0(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L0\nL1:\n  mov    -0x24(%rbp),%eax\n  cltq\n  movzbl -0xe(%rbp,%rax,1),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x28(%rbp)\n  addl   $0x1,-0x24(%rbp)\nL0:\n  mov    -0x24(%rbp),%eax\n  cltq\n  movzbl -0xe(%rbp,%rax,1),%eax\n  test   %al,%al\n  jne    L1\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  cmpl   $0x0,-0x28(%rbp)\n  jne    L2\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x30,(%rax)\n  jmp    L3\nL4:\n  mov    -0x28(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x28(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x28(%rbp)\nL2:\n  cmpl   $0x0,-0x28(%rbp)\n  jg     L4\nL3:\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L5\nL6:\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x29(%rbp)\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x29(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\nL5:\n  mov    -0x20(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     L6\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L7\n  call   <__stack_chk_fail@plt>\nL7:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3707
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4540
        },
        "L1": {
          "label": "L1",
          "addr": 4517
        },
        "L2": {
          "label": "L2",
          "addr": 4660
        },
        "L3": {
          "label": "L3",
          "addr": 4666
        },
        "L4": {
          "label": "L4",
          "addr": 4605
        },
        "L5": {
          "label": "L5",
          "addr": 4776
        },
        "L6": {
          "label": "L6",
          "addr": 4691
        },
        "L7": {
          "label": "L7",
          "addr": 4817
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(int x) {\n  char str[10];\n  sprintf(str, \"%d\", x);\n  int sum = 0;\n  for (int i = 0; str[i] != '\\0'; i++) {\n    sum += str[i] - '0';\n  }\n  char *ret = (char *)malloc(sizeof(char) * 33);\n  int index = 0;\n  if (sum == 0) {\n    ret[index++] = '0';\n  } else {\n    while (sum > 0) {\n      ret[index++] = sum % 2 + '0';\n      sum /= 2;\n    }\n  }\n  ret[index] = '\\0';\n  for (int i = 0; i < index / 2; i++) {\n    char tmp = ret[i];\n    ret[i] = ret[index - i - 1];\n    ret[index - i - 1] = tmp;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 87,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    %ecx,-0x40(%rbp)\n  mov    %r8,-0x50(%rbp)\n  mov    $0x320,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  jmp    1218 <func0+0xff>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x1c(%rbp)\n  jmp    120a <func0+0xf1>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x40(%rbp)\n  jne    1206 <func0+0xed>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x24(%rbp)\n  subl   $0x1,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jns    117a <func0+0x61>\n  addl   $0x1,-0x20(%rbp)\n  mov    -0x20(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     1159 <func0+0x40>\n  mov    -0x50(%rbp),%rax\n  mov    -0x24(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    %ecx,-0x40(%rbp)\n  mov    %r8,-0x50(%rbp)\n  mov    $0x320,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  jmp    L0\nL4:\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x1c(%rbp)\n  jmp    L1\nL3:\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x40(%rbp)\n  jne    L2\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x24(%rbp)\nL2:\n  subl   $0x1,-0x1c(%rbp)\nL1:\n  cmpl   $0x0,-0x1c(%rbp)\n  jns    L3\n  addl   $0x1,-0x20(%rbp)\nL0:\n  mov    -0x20(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L4\n  mov    -0x50(%rbp),%rax\n  mov    -0x24(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4632
        },
        "L1": {
          "label": "L1",
          "addr": 4618
        },
        "L2": {
          "label": "L2",
          "addr": 4614
        },
        "L3": {
          "label": "L3",
          "addr": 4474
        },
        "L4": {
          "label": "L4",
          "addr": 4441
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int **func0(int **ptr, int n, int *m, int val, int *nn) {\n  int **arr = (int **)malloc(100 * sizeof(int *));\n  int i, j, k = 0;\n  for (i = 0; i < n; i++) {\n    for (j = m[i] - 1; j >= 0; j--) {\n      if (ptr[i][j] == val) {\n        arr[k] = (int *)malloc(2 * sizeof(int));\n        arr[k][0] = i;\n        arr[k][1] = j;\n        k++;\n      }\n    }\n  }\n  *nn = k;\n  return arr;\n}"
    },
    {
      "task_id": 87,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%r12\n  mov    %esi,%ebx\n  mov    %rdx,0x18(%rsp)\n  mov    %ecx,%r13d\n  mov    %r8,0x28(%rsp)\n  mov    $0x320,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  test   %ebx,%ebx\n  jle    11d5 <func0+0xbc>\n  mov    %ebx,%eax\n  mov    %rax,0x20(%rsp)\n  mov    $0x0,%r15d\n  mov    $0x0,%r14d\n  jmp    11b3 <func0+0x9a>\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  movslq %r14d,%rdx\n  mov    0x10(%rsp),%rcx\n  mov    %rax,(%rcx,%rdx,8)\n  mov    0x8(%rsp),%esi\n  mov    %esi,(%rax)\n  mov    %ebx,0x4(%rax)\n  add    $0x1,%r14d\n  sub    $0x1,%ebx\n  sub    $0x4,%rbp\n  cmp    $0xffffffff,%ebx\n  je     11a4 <func0+0x8b>\n  mov    (%r12),%rax\n  cmp    %r13d,(%rax,%rbp,1)\n  jne    118c <func0+0x73>\n  jmp    1169 <func0+0x50>\n  add    $0x1,%r15\n  add    $0x8,%r12\n  cmp    0x20(%rsp),%r15\n  je     11db <func0+0xc2>\n  mov    %r15d,0x8(%rsp)\n  mov    0x18(%rsp),%rax\n  mov    (%rax,%r15,4),%eax\n  mov    %eax,0xc(%rsp)\n  mov    %eax,%ebx\n  sub    $0x1,%ebx\n  js     11a4 <func0+0x8b>\n  movslq %ebx,%rbp\n  shl    $0x2,%rbp\n  jmp    1198 <func0+0x7f>\n  mov    $0x0,%r14d\n  mov    0x28(%rsp),%rax\n  mov    %r14d,(%rax)\n  mov    0x10(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%r12\n  mov    %esi,%ebx\n  mov    %rdx,0x18(%rsp)\n  mov    %ecx,%r13d\n  mov    %r8,0x28(%rsp)\n  mov    $0x320,%edi\n  call   <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  test   %ebx,%ebx\n  jle    L0\n  mov    %ebx,%eax\n  mov    %rax,0x20(%rsp)\n  mov    $0x0,%r15d\n  mov    $0x0,%r14d\n  jmp    L1\nL4:\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  movslq %r14d,%rdx\n  mov    0x10(%rsp),%rcx\n  mov    %rax,(%rcx,%rdx,8)\n  mov    0x8(%rsp),%esi\n  mov    %esi,(%rax)\n  mov    %ebx,0x4(%rax)\n  add    $0x1,%r14d\nL3:\n  sub    $0x1,%ebx\n  sub    $0x4,%rbp\n  cmp    $0xffffffff,%ebx\n  je     L2\nL6:\n  mov    (%r12),%rax\n  cmp    %r13d,(%rax,%rbp,1)\n  jne    L3\n  jmp    L4\nL2:\n  add    $0x1,%r15\n  add    $0x8,%r12\n  cmp    0x20(%rsp),%r15\n  je     L5\nL1:\n  mov    %r15d,0x8(%rsp)\n  mov    0x18(%rsp),%rax\n  mov    (%rax,%r15,4),%eax\n  mov    %eax,0xc(%rsp)\n  mov    %eax,%ebx\n  sub    $0x1,%ebx\n  js     L2\n  movslq %ebx,%rbp\n  shl    $0x2,%rbp\n  jmp    L6\nL0:\n  mov    $0x0,%r14d\nL5:\n  mov    0x28(%rsp),%rax\n  mov    %r14d,(%rax)\n  mov    0x10(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4565
        },
        "L1": {
          "label": "L1",
          "addr": 4531
        },
        "L2": {
          "label": "L2",
          "addr": 4516
        },
        "L3": {
          "label": "L3",
          "addr": 4492
        },
        "L4": {
          "label": "L4",
          "addr": 4457
        },
        "L5": {
          "label": "L5",
          "addr": 4571
        },
        "L6": {
          "label": "L6",
          "addr": 4504
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int **func0(int **ptr, int rows, int *lengths, int val, int *ret_length) {\n  int **ret = malloc(sizeof(int *) * 100);\n  int i, j, k = 0;\n  for (i = 0; i < rows; i++) {\n    for (j = lengths[i] - 1; j >= 0; j--) {\n      if (ptr[i][j] == val) {\n        ret[k] = malloc(sizeof(int) * 2);\n        ret[k][0] = i;\n        ret[k][1] = j;\n        k++;\n      }\n    }\n  }\n  *ret_length = k;\n  return ret;\n}"
    },
    {
      "task_id": 84,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  sub    $0x10,%rsp\n  mov    %edi,%r8d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rdi\n  lea    0xe7f(%rip),%rcx        # 2000 <_fini+0xd7c>\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  call   1090 <__sprintf_chk@plt>\n  movzbl 0x2(%rsp),%eax\n  test   %al,%al\n  je     1261 <func0+0x108>\n  lea    0x2(%rsp),%rdx\n  mov    $0x0,%ebx\n  movsbl %al,%eax\n  lea    -0x30(%rbx,%rax,1),%ebx\n  add    $0x1,%rdx\n  movzbl (%rdx),%eax\n  test   %al,%al\n  jne    11a7 <func0+0x4e>\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%rcx\n  test   %ebx,%ebx\n  je     126e <func0+0x115>\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  jle    1276 <func0+0x11d>\n  mov    %edx,%edi\n  mov    %ebx,%esi\n  shr    $0x1f,%esi\n  lea    (%rbx,%rsi,1),%eax\n  and    $0x1,%eax\n  sub    %esi,%eax\n  add    $0x30,%eax\n  mov    %al,-0x1(%rcx,%rdx,1)\n  mov    %ebx,%esi\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  add    $0x1,%rdx\n  cmp    $0x1,%esi\n  jg     11de <func0+0x85>\n  movslq %edi,%rax\n  movb   $0x0,(%rcx,%rax,1)\n  mov    %edi,%r8d\n  shr    $0x1f,%r8d\n  add    %edi,%r8d\n  sar    %r8d\n  cmp    $0x1,%edi\n  jle    1248 <func0+0xef>\n  lea    -0x1(%rcx,%rax,1),%rdx\n  mov    $0x0,%eax\n  movzbl (%rcx,%rax,1),%esi\n  movzbl (%rdx),%edi\n  mov    %dil,(%rcx,%rax,1)\n  mov    %sil,(%rdx)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%r8d\n  jg     122d <func0+0xd4>\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    127e <func0+0x125>\n  mov    %rcx,%rax\n  add    $0x10,%rsp\n  pop    %rbx\n  ret\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%rcx\n  movb   $0x30,(%rcx)\n  mov    $0x1,%eax\n  cltq\n  movb   $0x0,(%rcx,%rax,1)\n  jmp    1248 <func0+0xef>\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  sub    $0x10,%rsp\n  mov    %edi,%r8d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rdi\n  lea    D0(%rip),%rcx\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  call   <__sprintf_chk@plt>\n  movzbl 0x2(%rsp),%eax\n  test   %al,%al\n  je     L0\n  lea    0x2(%rsp),%rdx\n  mov    $0x0,%ebx\nL1:\n  movsbl %al,%eax\n  lea    -0x30(%rbx,%rax,1),%ebx\n  add    $0x1,%rdx\n  movzbl (%rdx),%eax\n  test   %al,%al\n  jne    L1\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%rcx\n  test   %ebx,%ebx\n  je     L2\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  jle    L3\nL4:\n  mov    %edx,%edi\n  mov    %ebx,%esi\n  shr    $0x1f,%esi\n  lea    (%rbx,%rsi,1),%eax\n  and    $0x1,%eax\n  sub    %esi,%eax\n  add    $0x30,%eax\n  mov    %al,-0x1(%rcx,%rdx,1)\n  mov    %ebx,%esi\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  add    $0x1,%rdx\n  cmp    $0x1,%esi\n  jg     L4\n  movslq %edi,%rax\n  movb   $0x0,(%rcx,%rax,1)\n  mov    %edi,%r8d\n  shr    $0x1f,%r8d\n  add    %edi,%r8d\n  sar    %r8d\n  cmp    $0x1,%edi\n  jle    L5\n  lea    -0x1(%rcx,%rax,1),%rdx\n  mov    $0x0,%eax\nL6:\n  movzbl (%rcx,%rax,1),%esi\n  movzbl (%rdx),%edi\n  mov    %dil,(%rcx,%rax,1)\n  mov    %sil,(%rdx)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%r8d\n  jg     L6\nL5:\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  mov    %rcx,%rax\n  add    $0x10,%rsp\n  pop    %rbx\n  ret\nL0:\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%rcx\nL2:\n  movb   $0x30,(%rcx)\n  mov    $0x1,%eax\nL3:\n  cltq\n  movb   $0x0,(%rcx,%rax,1)\n  jmp    L5\nL7:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3711
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4705
        },
        "L1": {
          "label": "L1",
          "addr": 4519
        },
        "L2": {
          "label": "L2",
          "addr": 4718
        },
        "L3": {
          "label": "L3",
          "addr": 4726
        },
        "L4": {
          "label": "L4",
          "addr": 4574
        },
        "L5": {
          "label": "L5",
          "addr": 4680
        },
        "L6": {
          "label": "L6",
          "addr": 4653
        },
        "L7": {
          "label": "L7",
          "addr": 4734
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int x) {\n  char *buf;\n  char *p;\n  int i;\n  int j;\n  int k;\n  __sprintf_chk(buf, 1, 6, \"%d\", x);\n  for (i = 0; buf[i] != '\\0'; i++) {\n    k += buf[i] - '0';\n  }\n  p = malloc(33);\n  if (k == 0) {\n    p[0] = '0';\n    p[1] = '\\0';\n    return p;\n  }\n  for (j = 0; k > 0; j++) {\n    p[j] = k % 2 + '0';\n    k /= 2;\n  }\n  p[j] = '\\0';\n  for (i = 0; i < j / 2; i++) {\n    k = p[i];\n    p[i] = p[j - i - 1];\n    p[j - i - 1] = k;\n  }\n  return p;\n}"
    },
    {
      "task_id": 86,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  add    $0xffffffffffffff80,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x78(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %eax,-0x4c(%rbp)\n  mov    -0x4c(%rbp),%eax\n  add    $0x2,%eax\n  cltq\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x48(%rbp)\n  movl   $0x0,-0x64(%rbp)\n  movl   $0x0,-0x60(%rbp)\n  movl   $0x0,-0x5c(%rbp)\n  jmp    12d2 <func0+0x179>\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     11e1 <func0+0x88>\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    12ae <func0+0x155>\n  movl   $0x0,-0x58(%rbp)\n  jmp    124a <func0+0xf1>\n  mov    -0x58(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x54(%rbp)\n  jmp    123e <func0+0xe5>\n  mov    -0x58(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%edx\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  cmp    %al,%dl\n  jle    123a <func0+0xe1>\n  mov    -0x58(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  mov    %al,-0x65(%rbp)\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%edx\n  mov    -0x58(%rbp),%eax\n  cltq\n  mov    %dl,-0x40(%rbp,%rax,1)\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x65(%rbp),%edx\n  mov    %dl,-0x40(%rbp,%rax,1)\n  addl   $0x1,-0x54(%rbp)\n  mov    -0x54(%rbp),%eax\n  cmp    -0x60(%rbp),%eax\n  jl     11f5 <func0+0x9c>\n  addl   $0x1,-0x58(%rbp)\n  mov    -0x60(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x58(%rbp)\n  jl     11ea <func0+0x91>\n  cmpl   $0x0,-0x64(%rbp)\n  jle    1271 <func0+0x118>\n  mov    -0x64(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x64(%rbp)\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\n  movl   $0x0,-0x50(%rbp)\n  jmp    129d <func0+0x144>\n  mov    -0x64(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x64(%rbp)\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x50(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x50(%rbp)\n  mov    -0x50(%rbp),%eax\n  cmp    -0x60(%rbp),%eax\n  jl     127a <func0+0x121>\n  movl   $0x0,-0x60(%rbp)\n  jmp    12ce <func0+0x175>\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x60(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x60(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x40(%rbp,%rax,1)\n  addl   $0x1,-0x5c(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jle    11b5 <func0+0x5c>\n  mov    -0x64(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x48(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     1306 <func0+0x1ad>\n  call   1080 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  add    $0xffffffffffffff80,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x78(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4c(%rbp)\n  mov    -0x4c(%rbp),%eax\n  add    $0x2,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x48(%rbp)\n  movl   $0x0,-0x64(%rbp)\n  movl   $0x0,-0x60(%rbp)\n  movl   $0x0,-0x5c(%rbp)\n  jmp    L0\nL12:\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L1\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\nL1:\n  movl   $0x0,-0x58(%rbp)\n  jmp    L3\nL7:\n  mov    -0x58(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x54(%rbp)\n  jmp    L4\nL6:\n  mov    -0x58(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%edx\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  cmp    %al,%dl\n  jle    L5\n  mov    -0x58(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  mov    %al,-0x65(%rbp)\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%edx\n  mov    -0x58(%rbp),%eax\n  cltq\n  mov    %dl,-0x40(%rbp,%rax,1)\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x65(%rbp),%edx\n  mov    %dl,-0x40(%rbp,%rax,1)\nL5:\n  addl   $0x1,-0x54(%rbp)\nL4:\n  mov    -0x54(%rbp),%eax\n  cmp    -0x60(%rbp),%eax\n  jl     L6\n  addl   $0x1,-0x58(%rbp)\nL3:\n  mov    -0x60(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x58(%rbp)\n  jl     L7\n  cmpl   $0x0,-0x64(%rbp)\n  jle    L8\n  mov    -0x64(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x64(%rbp)\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\nL8:\n  movl   $0x0,-0x50(%rbp)\n  jmp    L9\nL10:\n  mov    -0x64(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x64(%rbp)\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x50(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x50(%rbp)\nL9:\n  mov    -0x50(%rbp),%eax\n  cmp    -0x60(%rbp),%eax\n  jl     L10\n  movl   $0x0,-0x60(%rbp)\n  jmp    L11\nL2:\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x60(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x60(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x40(%rbp,%rax,1)\nL11:\n  addl   $0x1,-0x5c(%rbp)\nL0:\n  mov    -0x5c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jle    L12\n  mov    -0x64(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x48(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L13\n  call   <__stack_chk_fail@plt>\nL13:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4818
        },
        "L1": {
          "label": "L1",
          "addr": 4577
        },
        "L2": {
          "label": "L2",
          "addr": 4782
        },
        "L3": {
          "label": "L3",
          "addr": 4682
        },
        "L4": {
          "label": "L4",
          "addr": 4670
        },
        "L5": {
          "label": "L5",
          "addr": 4666
        },
        "L6": {
          "label": "L6",
          "addr": 4597
        },
        "L7": {
          "label": "L7",
          "addr": 4586
        },
        "L8": {
          "label": "L8",
          "addr": 4721
        },
        "L9": {
          "label": "L9",
          "addr": 4765
        },
        "L10": {
          "label": "L10",
          "addr": 4730
        },
        "L11": {
          "label": "L11",
          "addr": 4814
        },
        "L12": {
          "label": "L12",
          "addr": 4533
        },
        "L13": {
          "label": "L13",
          "addr": 4870
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *s) {\n  int len = strlen(s);\n  char *ret = malloc(len + 2);\n  char tmp[20];\n  int i, j, k, l = 0, m = 0;\n  for (i = 0; i <= len; i++) {\n    if (s[i] == ' ' || s[i] == '\\0') {\n      for (j = 0; j < m - 1; j++) {\n        for (k = j + 1; k < m; k++) {\n          if (tmp[j] > tmp[k]) {\n            char c = tmp[j];\n            tmp[j] = tmp[k];\n            tmp[k] = c;\n          }\n        }\n      }\n      if (l > 0)\n        ret[l++] = ' ';\n      for (j = 0; j < m; j++)\n        ret[l++] = tmp[j];\n      m = 0;\n    } else\n      tmp[m++] = s[i];\n  }\n  ret[l] = '\\0';\n  return ret;\n}"
    },
    {
      "task_id": 84,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%r8d\n  lea    0xe91(%rip),%rcx        # 2000 <_fini+0xd64>\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  sub    $0x10,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rdi\n  call   1090 <__sprintf_chk@plt>\n  movsbl 0x2(%rsp),%ebx\n  test   %bl,%bl\n  je     1278 <func0+0x118>\n  movsbl 0x3(%rsp),%eax\n  sub    $0x30,%ebx\n  test   %al,%al\n  je     11db <func0+0x7b>\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x4(%rsp),%eax\n  test   %al,%al\n  je     11db <func0+0x7b>\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x5(%rsp),%eax\n  test   %al,%al\n  je     11db <func0+0x7b>\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x6(%rsp),%eax\n  test   %al,%al\n  je     11db <func0+0x7b>\n  lea    -0x30(%rbx,%rax,1),%ebx\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %ebx,%ebx\n  je     1285 <func0+0x125>\n  mov    $0x1,%eax\n  jle    1292 <func0+0x132>\n  nopl   0x0(%rax,%rax,1)\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,-0x1(%r8,%rax,1)\n  add    $0x1,%rax\n  sar    %ebx\n  jne    1200 <func0+0xa0>\n  movslq %ecx,%rsi\n  sar    %ecx\n  movb   $0x0,(%r8,%rsi,1)\n  je     125a <func0+0xfa>\n  lea    -0x2(%r8,%rsi,1),%rdi\n  sub    $0x1,%ecx\n  lea    -0x1(%r8,%rsi,1),%rax\n  mov    %r8,%rdx\n  sub    %rcx,%rdi\n  cs nopw 0x0(%rax,%rax,1)\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    1240 <func0+0xe0>\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1297 <func0+0x137>\n  add    $0x10,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  movb   $0x30,(%r8)\n  lea    0x1(%r8),%rax\n  movb   $0x0,(%rax)\n  jmp    125a <func0+0xfa>\n  mov    %r8,%rax\n  jmp    128d <func0+0x12d>\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%r8d\n  lea    D0(%rip),%rcx\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  sub    $0x10,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rdi\n  call   <__sprintf_chk@plt>\n  movsbl 0x2(%rsp),%ebx\n  test   %bl,%bl\n  je     L0\n  movsbl 0x3(%rsp),%eax\n  sub    $0x30,%ebx\n  test   %al,%al\n  je     L1\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x4(%rsp),%eax\n  test   %al,%al\n  je     L1\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x5(%rsp),%eax\n  test   %al,%al\n  je     L1\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x6(%rsp),%eax\n  test   %al,%al\n  je     L1\n  lea    -0x30(%rbx,%rax,1),%ebx\nL1:\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %ebx,%ebx\n  je     L2\n  mov    $0x1,%eax\n  jle    L3\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,-0x1(%r8,%rax,1)\n  add    $0x1,%rax\n  sar    %ebx\n  jne    L4\n  movslq %ecx,%rsi\n  sar    %ecx\n  movb   $0x0,(%r8,%rsi,1)\n  je     L5\n  lea    -0x2(%r8,%rsi,1),%rdi\n  sub    $0x1,%ecx\n  lea    -0x1(%r8,%rsi,1),%rax\n  mov    %r8,%rdx\n  sub    %rcx,%rdi\n  cs nopw 0x0(%rax,%rax,1)\nL6:\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    L6\nL5:\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  add    $0x10,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\nL2:\n  movb   $0x30,(%r8)\n  lea    0x1(%r8),%rax\nL8:\n  movb   $0x0,(%rax)\n  jmp    L5\nL3:\n  mov    %r8,%rax\n  jmp    L8\nL7:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3729
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4728
        },
        "L1": {
          "label": "L1",
          "addr": 4571
        },
        "L2": {
          "label": "L2",
          "addr": 4741
        },
        "L3": {
          "label": "L3",
          "addr": 4754
        },
        "L4": {
          "label": "L4",
          "addr": 4608
        },
        "L5": {
          "label": "L5",
          "addr": 4698
        },
        "L6": {
          "label": "L6",
          "addr": 4672
        },
        "L7": {
          "label": "L7",
          "addr": 4759
        },
        "L8": {
          "label": "L8",
          "addr": 4749
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(int x) {\n  char buf[6];\n  __sprintf_chk(buf, 1, 6, \"%d\", x);\n  int i;\n  int sum = 0;\n  for (i = 0; buf[i] != '\\0'; i++) {\n    sum += buf[i] - '0';\n  }\n  char *ret = (char *)malloc(sizeof(buf) + 1);\n  if (sum == 0) {\n    ret[0] = '0';\n    ret[1] = '\\0';\n    return ret;\n  }\n  int j = 0;\n  while (sum != 0) {\n    ret[j++] = sum % 2 + '0';\n    sum /= 2;\n  }\n  ret[j] = '\\0';\n  for (i = 0; i < j / 2; i++) {\n    char tmp = ret[i];\n    ret[i] = ret[j - i - 1];\n    ret[j - i - 1] = tmp;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 87,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %ecx,%r14d\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x20(%rsp)\n  mov    $0x320,%edi\n  mov    %rdx,0x10(%rsp)\n  mov    %r8,0x28(%rsp)\n  call   1050 <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  test   %ebp,%ebp\n  jle    11ff <func0+0xdf>\n  movslq %ebp,%rax\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  mov    %rax,0x18(%rsp)\n  nopw   0x0(%rax,%rax,1)\n  mov    0x10(%rsp),%rax\n  mov    %ebp,%ebx\n  mov    (%rax,%rbp,4),%eax\n  mov    %eax,%edx\n  mov    %eax,0x4(%rsp)\n  sub    $0x1,%edx\n  js     11d8 <func0+0xb8>\n  mov    0x20(%rsp),%rax\n  movslq %edx,%r12\n  mov    (%rax,%rbp,8),%r13\n  jmp    11a1 <func0+0x81>\n  nopl   0x0(%rax,%rax,1)\n  sub    $0x1,%r12\n  test   %r12d,%r12d\n  js     11d8 <func0+0xb8>\n  cmp    %r14d,0x0(%r13,%r12,4)\n  jne    1198 <func0+0x78>\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  mov    0x8(%rsp),%rcx\n  movslq %r15d,%rdi\n  add    $0x1,%r15d\n  mov    %r12d,0x4(%rax)\n  sub    $0x1,%r12\n  mov    %rax,(%rcx,%rdi,8)\n  mov    %ebx,(%rax)\n  test   %r12d,%r12d\n  jns    11a1 <func0+0x81>\n  nopl   0x0(%rax)\n  add    $0x1,%rbp\n  cmp    0x18(%rsp),%rbp\n  jne    1170 <func0+0x50>\n  mov    0x28(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x8(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xor    %r15d,%r15d\n  jmp    11e3 <func0+0xc3>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %ecx,%r14d\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x20(%rsp)\n  mov    $0x320,%edi\n  mov    %rdx,0x10(%rsp)\n  mov    %r8,0x28(%rsp)\n  call   <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  test   %ebp,%ebp\n  jle    L0\n  movslq %ebp,%rax\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  mov    %rax,0x18(%rsp)\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    0x10(%rsp),%rax\n  mov    %ebp,%ebx\n  mov    (%rax,%rbp,4),%eax\n  mov    %eax,%edx\n  mov    %eax,0x4(%rsp)\n  sub    $0x1,%edx\n  js     L1\n  mov    0x20(%rsp),%rax\n  movslq %edx,%r12\n  mov    (%rax,%rbp,8),%r13\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  sub    $0x1,%r12\n  test   %r12d,%r12d\n  js     L1\nL2:\n  cmp    %r14d,0x0(%r13,%r12,4)\n  jne    L3\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    0x8(%rsp),%rcx\n  movslq %r15d,%rdi\n  add    $0x1,%r15d\n  mov    %r12d,0x4(%rax)\n  sub    $0x1,%r12\n  mov    %rax,(%rcx,%rdi,8)\n  mov    %ebx,(%rax)\n  test   %r12d,%r12d\n  jns    L2\n  nopl   0x0(%rax)\nL1:\n  add    $0x1,%rbp\n  cmp    0x18(%rsp),%rbp\n  jne    L4\nL5:\n  mov    0x28(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x8(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  xor    %r15d,%r15d\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4607
        },
        "L1": {
          "label": "L1",
          "addr": 4568
        },
        "L2": {
          "label": "L2",
          "addr": 4513
        },
        "L3": {
          "label": "L3",
          "addr": 4504
        },
        "L4": {
          "label": "L4",
          "addr": 4464
        },
        "L5": {
          "label": "L5",
          "addr": 4579
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int **func0(int **ptr, int s0, int *s1, int s2, int *s3) {\n  int i, j, k;\n  int **new_ptr = (int **)malloc(sizeof(int *) * 100);\n  k = 0;\n  for (i = 0; i < s0; i++) {\n    for (j = s1[i] - 1; j >= 0; j--) {\n      if (ptr[i][j] == s2) {\n        new_ptr[k] = (int *)malloc(sizeof(int) * 2);\n        new_ptr[k][1] = j;\n        new_ptr[k][0] = i;\n        k++;\n      }\n    }\n  }\n  *s3 = k;\n  return new_ptr;\n}"
    },
    {
      "task_id": 84,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%r8d\n  lea    0xe91(%rip),%rcx        # 2000 <_fini+0xd84>\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  sub    $0x10,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rbx\n  mov    %rbx,%rdi\n  call   1090 <__sprintf_chk@plt>\n  movsbl 0x2(%rsp),%eax\n  test   %al,%al\n  je     1258 <func0+0xf8>\n  mov    %rbx,%rdx\n  xor    %ebx,%ebx\n  nopl   0x0(%rax)\n  add    $0x1,%rdx\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl (%rdx),%eax\n  test   %al,%al\n  jne    11b0 <func0+0x50>\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %ebx,%ebx\n  je     1265 <func0+0x105>\n  mov    $0x1,%eax\n  jle    1272 <func0+0x112>\n  nop\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,-0x1(%r8,%rax,1)\n  add    $0x1,%rax\n  sar    %ebx\n  jne    11e0 <func0+0x80>\n  movslq %ecx,%rsi\n  sar    %ecx\n  movb   $0x0,(%r8,%rsi,1)\n  je     123a <func0+0xda>\n  lea    -0x2(%r8,%rsi,1),%rdi\n  sub    $0x1,%ecx\n  lea    -0x1(%r8,%rsi,1),%rax\n  mov    %r8,%rdx\n  sub    %rcx,%rdi\n  cs nopw 0x0(%rax,%rax,1)\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    1220 <func0+0xc0>\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1277 <func0+0x117>\n  add    $0x10,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  movb   $0x30,(%r8)\n  lea    0x1(%r8),%rax\n  movb   $0x0,(%rax)\n  jmp    123a <func0+0xda>\n  mov    %r8,%rax\n  jmp    126d <func0+0x10d>\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%r8d\n  lea    D0(%rip),%rcx\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  sub    $0x10,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rbx\n  mov    %rbx,%rdi\n  call   <__sprintf_chk@plt>\n  movsbl 0x2(%rsp),%eax\n  test   %al,%al\n  je     L0\n  mov    %rbx,%rdx\n  xor    %ebx,%ebx\n  nopl   0x0(%rax)\nL1:\n  add    $0x1,%rdx\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl (%rdx),%eax\n  test   %al,%al\n  jne    L1\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %ebx,%ebx\n  je     L2\n  mov    $0x1,%eax\n  jle    L3\n  nop\nL4:\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,-0x1(%r8,%rax,1)\n  add    $0x1,%rax\n  sar    %ebx\n  jne    L4\n  movslq %ecx,%rsi\n  sar    %ecx\n  movb   $0x0,(%r8,%rsi,1)\n  je     L5\n  lea    -0x2(%r8,%rsi,1),%rdi\n  sub    $0x1,%ecx\n  lea    -0x1(%r8,%rsi,1),%rax\n  mov    %r8,%rdx\n  sub    %rcx,%rdi\n  cs nopw 0x0(%rax,%rax,1)\nL6:\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    L6\nL5:\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  add    $0x10,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\nL2:\n  movb   $0x30,(%r8)\n  lea    0x1(%r8),%rax\nL8:\n  movb   $0x0,(%rax)\n  jmp    L5\nL3:\n  mov    %r8,%rax\n  jmp    L8\nL7:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3729
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4696
        },
        "L1": {
          "label": "L1",
          "addr": 4528
        },
        "L2": {
          "label": "L2",
          "addr": 4709
        },
        "L3": {
          "label": "L3",
          "addr": 4722
        },
        "L4": {
          "label": "L4",
          "addr": 4576
        },
        "L5": {
          "label": "L5",
          "addr": 4666
        },
        "L6": {
          "label": "L6",
          "addr": 4640
        },
        "L7": {
          "label": "L7",
          "addr": 4727
        },
        "L8": {
          "label": "L8",
          "addr": 4717
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(int x) {\n  char *ret;\n  char *p;\n  int i;\n  int t;\n  char *q;\n  char *r;\n  char buf[6];\n  __sprintf_chk(buf, 1, 6, \"%d\", x);\n  p = buf;\n  t = 0;\n  while (*p) {\n    t += *p - '0';\n    p++;\n  }\n  ret = malloc(33);\n  if (t == 0) {\n    ret[0] = '0';\n    ret[1] = '\\0';\n    return ret;\n  }\n  i = 0;\n  while (t > 0) {\n    ret[i] = t % 2 + '0';\n    t /= 2;\n    i++;\n  }\n  ret[i] = '\\0';\n  q = ret;\n  r = ret + i - 1;\n  while (q < r) {\n    char tmp;\n    tmp = *q;\n    *q = *r;\n    *r = tmp;\n    q++;\n    r--;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 87,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %ecx,%r14d\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x20(%rsp)\n  mov    $0x320,%edi\n  mov    %r8,0x28(%rsp)\n  call   1050 <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  test   %ebp,%ebp\n  jle    121b <func0+0xfb>\n  movslq %ebp,%rax\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  mov    %rax,0x18(%rsp)\n  nopl   0x0(%rax,%rax,1)\n  mov    0x0(%r13,%rbp,4),%ebx\n  movd   %ebp,%xmm1\n  sub    $0x1,%ebx\n  js     11f0 <func0+0xd0>\n  mov    0x20(%rsp),%rax\n  movslq %ebx,%rbx\n  mov    (%rax,%rbp,8),%r12\n  jmp    1198 <func0+0x78>\n  nopl   0x0(%rax)\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     11f0 <func0+0xd0>\n  movdqa %xmm1,%xmm0\n  movd   %ebx,%xmm2\n  punpckldq %xmm2,%xmm0\n  cmp    %r14d,(%r12,%rbx,4)\n  jne    1190 <func0+0x70>\n  mov    $0x8,%edi\n  movq   %xmm0,0x8(%rsp)\n  sub    $0x1,%rbx\n  movd   %xmm1,0x4(%rsp)\n  call   1050 <malloc@plt>\n  mov    0x10(%rsp),%rdx\n  movslq %r15d,%rdi\n  movq   0x8(%rsp),%xmm0\n  movd   0x4(%rsp),%xmm1\n  add    $0x1,%r15d\n  mov    %rax,(%rdx,%rdi,8)\n  movq   %xmm0,(%rax)\n  test   %ebx,%ebx\n  jns    1198 <func0+0x78>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rbp\n  cmp    %rbp,0x18(%rsp)\n  jne    1170 <func0+0x50>\n  mov    0x28(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x10(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xor    %r15d,%r15d\n  jmp    11ff <func0+0xdf>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %ecx,%r14d\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x20(%rsp)\n  mov    $0x320,%edi\n  mov    %r8,0x28(%rsp)\n  call   <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  test   %ebp,%ebp\n  jle    L0\n  movslq %ebp,%rax\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  mov    %rax,0x18(%rsp)\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    0x0(%r13,%rbp,4),%ebx\n  movd   %ebp,%xmm1\n  sub    $0x1,%ebx\n  js     L1\n  mov    0x20(%rsp),%rax\n  movslq %ebx,%rbx\n  mov    (%rax,%rbp,8),%r12\n  jmp    L2\n  nopl   0x0(%rax)\nL3:\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     L1\nL2:\n  movdqa %xmm1,%xmm0\n  movd   %ebx,%xmm2\n  punpckldq %xmm2,%xmm0\n  cmp    %r14d,(%r12,%rbx,4)\n  jne    L3\n  mov    $0x8,%edi\n  movq   %xmm0,0x8(%rsp)\n  sub    $0x1,%rbx\n  movd   %xmm1,0x4(%rsp)\n  call   <malloc@plt>\n  mov    0x10(%rsp),%rdx\n  movslq %r15d,%rdi\n  movq   0x8(%rsp),%xmm0\n  movd   0x4(%rsp),%xmm1\n  add    $0x1,%r15d\n  mov    %rax,(%rdx,%rdi,8)\n  movq   %xmm0,(%rax)\n  test   %ebx,%ebx\n  jns    L2\n  nopl   0x0(%rax,%rax,1)\nL1:\n  add    $0x1,%rbp\n  cmp    %rbp,0x18(%rsp)\n  jne    L4\nL5:\n  mov    0x28(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x10(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  xor    %r15d,%r15d\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4635
        },
        "L1": {
          "label": "L1",
          "addr": 4592
        },
        "L2": {
          "label": "L2",
          "addr": 4504
        },
        "L3": {
          "label": "L3",
          "addr": 4496
        },
        "L4": {
          "label": "L4",
          "addr": 4464
        },
        "L5": {
          "label": "L5",
          "addr": 4607
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int **func0(int **ptr, int n, int *len, int val, int *nval) {\n  int **newptr = malloc(100 * sizeof(int *));\n  int i, j, k = 0;\n  for (i = 0; i < n; i++) {\n    for (j = len[i] - 1; j >= 0; j--) {\n      if (ptr[i][j] == val) {\n        newptr[k] = malloc(2 * sizeof(int));\n        newptr[k][0] = i;\n        newptr[k][1] = j;\n        k++;\n      }\n    }\n  }\n  *nval = k;\n  return newptr;\n}"
    },
    {
      "task_id": 86,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x40,%rsp\n  mov    %rdi,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   1070 <strlen@plt>\n  mov    %rax,%rbx\n  lea    0x2(%rax),%edi\n  movslq %edi,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r11\n  test   %ebx,%ebx\n  js     1274 <func0+0x11b>\n  mov    %rbp,%r10\n  mov    %ebx,%ebx\n  lea    0x1(%rbp,%rbx,1),%rbp\n  mov    $0x0,%r9d\n  mov    $0x0,%ebx\n  mov    $0x0,%r12d\n  mov    %rsp,%r13\n  jmp    1257 <func0+0xfe>\n  cmp    $0x1,%r9d\n  jle    120f <func0+0xb6>\n  mov    %rsp,%rsi\n  lea    -0x1(%r9),%r14d\n  mov    $0x0,%r8d\n  jmp    11f6 <func0+0x9d>\n  add    $0x1,%rax\n  cmp    %rdi,%rax\n  je     11ed <func0+0x94>\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    11d2 <func0+0x79>\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\n  jmp    11d2 <func0+0x79>\n  add    $0x1,%rsi\n  cmp    %r14d,%r8d\n  je     120f <func0+0xb6>\n  add    $0x1,%r8d\n  cmp    %r9d,%r8d\n  jge    11ed <func0+0x94>\n  mov    %r14d,%eax\n  sub    %r8d,%eax\n  lea    0x1(%rsi,%rax,1),%rdi\n  mov    %rsi,%rax\n  jmp    11db <func0+0x82>\n  test   %ebx,%ebx\n  jle    121e <func0+0xc5>\n  movslq %ebx,%rax\n  movb   $0x20,(%r11,%rax,1)\n  lea    0x1(%rbx),%ebx\n  test   %r9d,%r9d\n  jle    126f <func0+0x116>\n  movslq %ebx,%rdx\n  mov    %r9d,%edi\n  mov    %r9d,%ecx\n  add    %rdx,%rcx\n  mov    %rdx,%rax\n  mov    %r13,%rsi\n  sub    %rdx,%rsi\n  movzbl (%rsi,%rax,1),%edx\n  mov    %dl,(%r11,%rax,1)\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  jne    1238 <func0+0xdf>\n  add    %edi,%ebx\n  mov    %r12d,%r9d\n  add    $0x1,%r10\n  cmp    %rbp,%r10\n  je     1279 <func0+0x120>\n  movzbl (%r10),%eax\n  test   $0xdf,%al\n  je     11bd <func0+0x64>\n  movslq %r9d,%rdx\n  mov    %al,(%rsp,%rdx,1)\n  lea    0x1(%r9),%r9d\n  jmp    124e <func0+0xf5>\n  mov    %r12d,%r9d\n  jmp    124e <func0+0xf5>\n  mov    $0x0,%ebx\n  movslq %ebx,%rbx\n  movb   $0x0,(%r11,%rbx,1)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12a1 <func0+0x148>\n  mov    %r11,%rax\n  add    $0x40,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  call   1080 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x40,%rsp\n  mov    %rdi,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%rbx\n  lea    0x2(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r11\n  test   %ebx,%ebx\n  js     L0\n  mov    %rbp,%r10\n  mov    %ebx,%ebx\n  lea    0x1(%rbp,%rbx,1),%rbp\n  mov    $0x0,%r9d\n  mov    $0x0,%ebx\n  mov    $0x0,%r12d\n  mov    %rsp,%r13\n  jmp    L1\nL11:\n  cmp    $0x1,%r9d\n  jle    L2\n  mov    %rsp,%rsi\n  lea    -0x1(%r9),%r14d\n  mov    $0x0,%r8d\n  jmp    L3\nL5:\n  add    $0x1,%rax\n  cmp    %rdi,%rax\n  je     L4\nL6:\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    L5\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\n  jmp    L5\nL4:\n  add    $0x1,%rsi\n  cmp    %r14d,%r8d\n  je     L2\nL3:\n  add    $0x1,%r8d\n  cmp    %r9d,%r8d\n  jge    L4\n  mov    %r14d,%eax\n  sub    %r8d,%eax\n  lea    0x1(%rsi,%rax,1),%rdi\n  mov    %rsi,%rax\n  jmp    L6\nL2:\n  test   %ebx,%ebx\n  jle    L7\n  movslq %ebx,%rax\n  movb   $0x20,(%r11,%rax,1)\n  lea    0x1(%rbx),%ebx\nL7:\n  test   %r9d,%r9d\n  jle    L8\n  movslq %ebx,%rdx\n  mov    %r9d,%edi\n  mov    %r9d,%ecx\n  add    %rdx,%rcx\n  mov    %rdx,%rax\n  mov    %r13,%rsi\n  sub    %rdx,%rsi\nL9:\n  movzbl (%rsi,%rax,1),%edx\n  mov    %dl,(%r11,%rax,1)\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  jne    L9\n  add    %edi,%ebx\n  mov    %r12d,%r9d\nL12:\n  add    $0x1,%r10\n  cmp    %rbp,%r10\n  je     L10\nL1:\n  movzbl (%r10),%eax\n  test   $0xdf,%al\n  je     L11\n  movslq %r9d,%rdx\n  mov    %al,(%rsp,%rdx,1)\n  lea    0x1(%r9),%r9d\n  jmp    L12\nL8:\n  mov    %r12d,%r9d\n  jmp    L12\nL0:\n  mov    $0x0,%ebx\nL10:\n  movslq %ebx,%rbx\n  movb   $0x0,(%r11,%rbx,1)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L13\n  mov    %r11,%rax\n  add    $0x40,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL13:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4724
        },
        "L1": {
          "label": "L1",
          "addr": 4695
        },
        "L2": {
          "label": "L2",
          "addr": 4623
        },
        "L3": {
          "label": "L3",
          "addr": 4598
        },
        "L4": {
          "label": "L4",
          "addr": 4589
        },
        "L5": {
          "label": "L5",
          "addr": 4562
        },
        "L6": {
          "label": "L6",
          "addr": 4571
        },
        "L7": {
          "label": "L7",
          "addr": 4638
        },
        "L8": {
          "label": "L8",
          "addr": 4719
        },
        "L9": {
          "label": "L9",
          "addr": 4664
        },
        "L10": {
          "label": "L10",
          "addr": 4729
        },
        "L11": {
          "label": "L11",
          "addr": 4541
        },
        "L12": {
          "label": "L12",
          "addr": 4686
        },
        "L13": {
          "label": "L13",
          "addr": 4769
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s) {\n  long int len = strlen(s);\n  char *ret = malloc(len + 2);\n  char tmp[50];\n  int tmp_i = 0;\n  int i, j, k;\n  int ret_i = 0;\n  for (i = 0; i <= len; i++) {\n    if (s[i] == ' ' || s[i] == '\\0') {\n      for (j = 0; j < tmp_i - 1; j++) {\n        for (k = j + 1; k < tmp_i; k++) {\n          if (tmp[j] > tmp[k]) {\n            char c = tmp[j];\n            tmp[j] = tmp[k];\n            tmp[k] = c;\n          }\n        }\n      }\n      if (ret_i > 0) {\n        ret[ret_i++] = ' ';\n      }\n      for (j = 0; j < tmp_i; j++) {\n        ret[ret_i++] = tmp[j];\n      }\n      tmp_i = 0;\n    } else {\n      tmp[tmp_i++] = s[i];\n    }\n  }\n  ret[ret_i] = '\\0';\n  return ret;\n}"
    },
    {
      "task_id": 86,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   1080 <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r14\n  test   %ebx,%ebx\n  js     1287 <func0+0x107>\n  mov    %ebx,%ebx\n  xor    %r12d,%r12d\n  mov    %rsp,%r15\n  lea    0x1(%rbp,%rbx,1),%r13\n  xor    %ebx,%ebx\n  jmp    11ee <func0+0x6e>\n  nopl   0x0(%rax)\n  movslq %ebx,%rdx\n  add    $0x1,%ebx\n  mov    %al,(%rsp,%rdx,1)\n  add    $0x1,%rbp\n  cmp    %r13,%rbp\n  je     1281 <func0+0x101>\n  movzbl 0x0(%rbp),%eax\n  test   $0xdf,%al\n  jne    11d8 <func0+0x58>\n  lea    -0x1(%rbx),%r10d\n  mov    %r15,%rsi\n  xor    %r8d,%r8d\n  test   %r10d,%r10d\n  jle    1249 <func0+0xc9>\n  nopl   (%rax)\n  add    $0x1,%r8d\n  cmp    %ebx,%r8d\n  jge    12b0 <func0+0x130>\n  mov    %r10d,%edi\n  lea    0x1(%rsi),%r9\n  mov    %rsi,%rax\n  sub    %r8d,%edi\n  add    %r9,%rdi\n  nopl   (%rax)\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    1238 <func0+0xb8>\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\n  add    $0x1,%rax\n  cmp    %rax,%rdi\n  jne    1228 <func0+0xa8>\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    1208 <func0+0x88>\n  test   %r12d,%r12d\n  je     125a <func0+0xda>\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  movb   $0x20,(%r14,%rax,1)\n  test   %ebx,%ebx\n  je     11e1 <func0+0x61>\n  movslq %r12d,%rdi\n  movslq %ebx,%rdx\n  mov    %r15,%rsi\n  add    $0x1,%rbp\n  add    %r14,%rdi\n  add    %ebx,%r12d\n  xor    %ebx,%ebx\n  call   10a0 <memcpy@plt>\n  cmp    %r13,%rbp\n  jne    11ee <func0+0x6e>\n  movslq %r12d,%rax\n  add    %r14,%rax\n  movb   $0x0,(%rax)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12c2 <func0+0x142>\n  add    $0x48,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  lea    0x1(%rsi),%r9\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    1208 <func0+0x88>\n  jmp    1249 <func0+0xc9>\n  call   1090 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %ebx,%ebx\n  js     L0\n  mov    %ebx,%ebx\n  xor    %r12d,%r12d\n  mov    %rsp,%r15\n  lea    0x1(%rbp,%rbx,1),%r13\n  xor    %ebx,%ebx\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  movslq %ebx,%rdx\n  add    $0x1,%ebx\n  mov    %al,(%rsp,%rdx,1)\nL10:\n  add    $0x1,%rbp\n  cmp    %r13,%rbp\n  je     L2\nL1:\n  movzbl 0x0(%rbp),%eax\n  test   $0xdf,%al\n  jne    L3\n  lea    -0x1(%rbx),%r10d\n  mov    %r15,%rsi\n  xor    %r8d,%r8d\n  test   %r10d,%r10d\n  jle    L4\n  nopl   (%rax)\nL8:\n  add    $0x1,%r8d\n  cmp    %ebx,%r8d\n  jge    L5\n  mov    %r10d,%edi\n  lea    0x1(%rsi),%r9\n  mov    %rsi,%rax\n  sub    %r8d,%edi\n  add    %r9,%rdi\n  nopl   (%rax)\nL7:\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    L6\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\nL6:\n  add    $0x1,%rax\n  cmp    %rax,%rdi\n  jne    L7\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    L8\nL4:\n  test   %r12d,%r12d\n  je     L9\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  movb   $0x20,(%r14,%rax,1)\nL9:\n  test   %ebx,%ebx\n  je     L10\n  movslq %r12d,%rdi\n  movslq %ebx,%rdx\n  mov    %r15,%rsi\n  add    $0x1,%rbp\n  add    %r14,%rdi\n  add    %ebx,%r12d\n  xor    %ebx,%ebx\n  call   <memcpy@plt>\n  cmp    %r13,%rbp\n  jne    L1\nL2:\n  movslq %r12d,%rax\n  add    %r14,%rax\nL0:\n  movb   $0x0,(%rax)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L11\n  add    $0x48,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL5:\n  lea    0x1(%rsi),%r9\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    L8\n  jmp    L4\nL11:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4743
        },
        "L1": {
          "label": "L1",
          "addr": 4590
        },
        "L2": {
          "label": "L2",
          "addr": 4737
        },
        "L3": {
          "label": "L3",
          "addr": 4568
        },
        "L4": {
          "label": "L4",
          "addr": 4681
        },
        "L5": {
          "label": "L5",
          "addr": 4784
        },
        "L6": {
          "label": "L6",
          "addr": 4664
        },
        "L7": {
          "label": "L7",
          "addr": 4648
        },
        "L8": {
          "label": "L8",
          "addr": 4616
        },
        "L9": {
          "label": "L9",
          "addr": 4698
        },
        "L10": {
          "label": "L10",
          "addr": 4577
        },
        "L11": {
          "label": "L11",
          "addr": 4802
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *src) {\n  int src_len = strlen(src);\n  char *dst = malloc(src_len + 2);\n  char tmp[50];\n  int tmp_len = 0;\n  int dst_len = 0;\n  int i, j, k;\n  char c;\n  for (i = 0; i <= src_len; i++) {\n    c = src[i];\n    if (c == ' ' || c == '\\0') {\n      for (j = 0; j < tmp_len - 1; j++) {\n        for (k = j + 1; k < tmp_len; k++) {\n          if (tmp[j] > tmp[k]) {\n            c = tmp[j];\n            tmp[j] = tmp[k];\n            tmp[k] = c;\n          }\n        }\n      }\n      if (dst_len != 0)\n        dst[dst_len++] = ' ';\n      for (j = 0; j < tmp_len; j++)\n        dst[dst_len++] = tmp[j];\n      tmp_len = 0;\n    } else {\n      tmp[tmp_len++] = c;\n    }\n  }\n  dst[dst_len] = '\\0';\n  return dst;\n}"
    },
    {
      "task_id": 89,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1163 <func0+0x6a>\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  lea    -0x5d(%rax),%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x3,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x61,%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x4(%rbp),%edx\n  mov    %dl,(%rax)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1112 <func0+0x19>\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL1:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  lea    -0x5d(%rax),%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x3,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x61,%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x4(%rbp),%edx\n  mov    %dl,(%rax)\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L1\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4451
        },
        "L1": {
          "label": "L1",
          "addr": 4370
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char a[], char b[]) {\n  int i = 0;\n  while (a[i] != '\\0') {\n    int j = (a[i] - 'A' + 3) % 26 + 'a';\n    b[i] = j;\n    i++;\n  }\n  b[i] = '\\0';\n}"
    },
    {
      "task_id": 86,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   1080 <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r14\n  test   %ebx,%ebx\n  js     1287 <func0+0x107>\n  mov    %ebx,%ebx\n  xor    %r12d,%r12d\n  mov    %rsp,%r15\n  lea    0x1(%rbp,%rbx,1),%r13\n  xor    %ebx,%ebx\n  jmp    11ee <func0+0x6e>\n  nopl   0x0(%rax)\n  movslq %ebx,%rdx\n  add    $0x1,%ebx\n  mov    %al,(%rsp,%rdx,1)\n  add    $0x1,%rbp\n  cmp    %r13,%rbp\n  je     1281 <func0+0x101>\n  movzbl 0x0(%rbp),%eax\n  test   $0xdf,%al\n  jne    11d8 <func0+0x58>\n  lea    -0x1(%rbx),%r10d\n  mov    %r15,%rsi\n  xor    %r8d,%r8d\n  test   %r10d,%r10d\n  jle    1249 <func0+0xc9>\n  nopl   (%rax)\n  add    $0x1,%r8d\n  cmp    %ebx,%r8d\n  jge    12b0 <func0+0x130>\n  mov    %r10d,%edi\n  lea    0x1(%rsi),%r9\n  mov    %rsi,%rax\n  sub    %r8d,%edi\n  add    %r9,%rdi\n  nopl   (%rax)\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    1238 <func0+0xb8>\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\n  add    $0x1,%rax\n  cmp    %rax,%rdi\n  jne    1228 <func0+0xa8>\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    1208 <func0+0x88>\n  test   %r12d,%r12d\n  je     125a <func0+0xda>\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  movb   $0x20,(%r14,%rax,1)\n  test   %ebx,%ebx\n  je     11e1 <func0+0x61>\n  movslq %r12d,%rdi\n  movslq %ebx,%rdx\n  mov    %r15,%rsi\n  add    $0x1,%rbp\n  add    %r14,%rdi\n  add    %ebx,%r12d\n  xor    %ebx,%ebx\n  call   10a0 <memcpy@plt>\n  cmp    %r13,%rbp\n  jne    11ee <func0+0x6e>\n  movslq %r12d,%rax\n  add    %r14,%rax\n  movb   $0x0,(%rax)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12c2 <func0+0x142>\n  add    $0x48,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  lea    0x1(%rsi),%r9\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    1208 <func0+0x88>\n  jmp    1249 <func0+0xc9>\n  call   1090 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %ebx,%ebx\n  js     L0\n  mov    %ebx,%ebx\n  xor    %r12d,%r12d\n  mov    %rsp,%r15\n  lea    0x1(%rbp,%rbx,1),%r13\n  xor    %ebx,%ebx\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  movslq %ebx,%rdx\n  add    $0x1,%ebx\n  mov    %al,(%rsp,%rdx,1)\nL10:\n  add    $0x1,%rbp\n  cmp    %r13,%rbp\n  je     L2\nL1:\n  movzbl 0x0(%rbp),%eax\n  test   $0xdf,%al\n  jne    L3\n  lea    -0x1(%rbx),%r10d\n  mov    %r15,%rsi\n  xor    %r8d,%r8d\n  test   %r10d,%r10d\n  jle    L4\n  nopl   (%rax)\nL8:\n  add    $0x1,%r8d\n  cmp    %ebx,%r8d\n  jge    L5\n  mov    %r10d,%edi\n  lea    0x1(%rsi),%r9\n  mov    %rsi,%rax\n  sub    %r8d,%edi\n  add    %r9,%rdi\n  nopl   (%rax)\nL7:\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    L6\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\nL6:\n  add    $0x1,%rax\n  cmp    %rax,%rdi\n  jne    L7\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    L8\nL4:\n  test   %r12d,%r12d\n  je     L9\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  movb   $0x20,(%r14,%rax,1)\nL9:\n  test   %ebx,%ebx\n  je     L10\n  movslq %r12d,%rdi\n  movslq %ebx,%rdx\n  mov    %r15,%rsi\n  add    $0x1,%rbp\n  add    %r14,%rdi\n  add    %ebx,%r12d\n  xor    %ebx,%ebx\n  call   <memcpy@plt>\n  cmp    %r13,%rbp\n  jne    L1\nL2:\n  movslq %r12d,%rax\n  add    %r14,%rax\nL0:\n  movb   $0x0,(%rax)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L11\n  add    $0x48,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL5:\n  lea    0x1(%rsi),%r9\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    L8\n  jmp    L4\nL11:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4743
        },
        "L1": {
          "label": "L1",
          "addr": 4590
        },
        "L2": {
          "label": "L2",
          "addr": 4737
        },
        "L3": {
          "label": "L3",
          "addr": 4568
        },
        "L4": {
          "label": "L4",
          "addr": 4681
        },
        "L5": {
          "label": "L5",
          "addr": 4784
        },
        "L6": {
          "label": "L6",
          "addr": 4664
        },
        "L7": {
          "label": "L7",
          "addr": 4648
        },
        "L8": {
          "label": "L8",
          "addr": 4616
        },
        "L9": {
          "label": "L9",
          "addr": 4698
        },
        "L10": {
          "label": "L10",
          "addr": 4577
        },
        "L11": {
          "label": "L11",
          "addr": 4802
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *src) {\n  int src_len = strlen(src);\n  char *dst = malloc(src_len + 2);\n  char tmp[50];\n  int tmp_len = 0;\n  int dst_len = 0;\n  int i, j, k;\n  char c;\n  for (i = 0; i <= src_len; i++) {\n    c = src[i];\n    if (c == ' ' || c == '\\0') {\n      for (j = 0; j < tmp_len - 1; j++) {\n        for (k = j + 1; k < tmp_len; k++) {\n          if (tmp[j] > tmp[k]) {\n            c = tmp[j];\n            tmp[j] = tmp[k];\n            tmp[k] = c;\n          }\n        }\n      }\n      if (dst_len != 0)\n        dst[dst_len++] = ' ';\n      for (j = 0; j < tmp_len; j++)\n        dst[dst_len++] = tmp[j];\n      tmp_len = 0;\n    } else {\n      tmp[tmp_len++] = c;\n    }\n  }\n  dst[dst_len] = '\\0';\n  return dst;\n}"
    },
    {
      "task_id": 89,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  mov    %rdi,%r8\n  test   %al,%al\n  je     1143 <func0+0x43>\n  xor    %ecx,%ecx\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  mov    %eax,%edi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%edi\n  sar    $0x23,%rdx\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movsbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    1110 <func0+0x10>\n  add    %rcx,%rsi\n  movb   $0x0,(%rsi)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  mov    %rdi,%r8\n  test   %al,%al\n  je     L0\n  xor    %ecx,%ecx\nL1:\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  mov    %eax,%edi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%edi\n  sar    $0x23,%rdx\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movsbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    L1\n  add    %rcx,%rsi\nL0:\n  movb   $0x0,(%rsi)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4419
        },
        "L1": {
          "label": "L1",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, char *b) {\n  int i = 0;\n  while (a[i]) {\n    b[i] = (a[i] - '[' + 26) % 26 + 'a';\n    i++;\n  }\n  b[i] = 0;\n}"
    },
    {
      "task_id": 89,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  mov    %rdi,%r8\n  test   %al,%al\n  je     1143 <func0+0x43>\n  xor    %ecx,%ecx\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  mov    %eax,%edi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%edi\n  sar    $0x23,%rdx\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movsbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    1110 <func0+0x10>\n  add    %rcx,%rsi\n  movb   $0x0,(%rsi)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  mov    %rdi,%r8\n  test   %al,%al\n  je     L0\n  xor    %ecx,%ecx\nL1:\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  mov    %eax,%edi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%edi\n  sar    $0x23,%rdx\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movsbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    L1\n  add    %rcx,%rsi\nL0:\n  movb   $0x0,(%rsi)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4419
        },
        "L1": {
          "label": "L1",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, char *b) {\n  int i = 0;\n  while (a[i]) {\n    b[i] = (a[i] - '[' + 26) % 26 + 'a';\n    i++;\n  }\n  b[i] = 0;\n}"
    },
    {
      "task_id": 89,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     1144 <func0+0x4b>\n  mov    $0x0,%ecx\n  movsbl %al,%eax\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x23,%rdx\n  mov    %eax,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movzbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    110c <func0+0x13>\n  movb   $0x0,(%rsi,%rcx,1)\n  ret\n  mov    $0x0,%ecx\n  jmp    113f <func0+0x46>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  mov    $0x0,%ecx\nL1:\n  movsbl %al,%eax\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x23,%rdx\n  mov    %eax,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movzbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    L1\nL2:\n  movb   $0x0,(%rsi,%rcx,1)\n  ret\nL0:\n  mov    $0x0,%ecx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4420
        },
        "L1": {
          "label": "L1",
          "addr": 4364
        },
        "L2": {
          "label": "L2",
          "addr": 4415
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, char *b) {\n  int i;\n  for (i = 0; a[i] != '\\0'; i++)\n    b[i] = (a[i] - 'a' + 3) % 26 + 'a';\n  b[i] = '\\0';\n}"
    },
    {
      "task_id": 90,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x1,-0x1c(%rbp)\n  jg     1118 <func0+0x1f>\n  mov    $0xffffffff,%eax\n  jmp    11e0 <func0+0xe7>\n  movl   $0x7fffffff,-0xc(%rbp)\n  movl   $0x7fffffff,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    11c1 <func0+0xc8>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    116e <func0+0x75>\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    11bd <func0+0xc4>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x8(%rbp)\n  jle    11bd <func0+0xc4>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  je     11bd <func0+0xc4>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1132 <func0+0x39>\n  cmpl   $0x7fffffff,-0x8(%rbp)\n  jne    11dd <func0+0xe4>\n  mov    $0xffffffff,%eax\n  jmp    11e0 <func0+0xe7>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x1,-0x1c(%rbp)\n  jg     L0\n  mov    $0xffffffff,%eax\n  jmp    L1\nL0:\n  movl   $0x7fffffff,-0xc(%rbp)\n  movl   $0x7fffffff,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L2\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L3\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    L4\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x8(%rbp)\n  jle    L4\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  je     L4\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\nL4:\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  cmpl   $0x7fffffff,-0x8(%rbp)\n  jne    L6\n  mov    $0xffffffff,%eax\n  jmp    L1\nL6:\n  mov    -0x8(%rbp),%eax\nL1:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4376
        },
        "L1": {
          "label": "L1",
          "addr": 4576
        },
        "L2": {
          "label": "L2",
          "addr": 4545
        },
        "L3": {
          "label": "L3",
          "addr": 4462
        },
        "L4": {
          "label": "L4",
          "addr": 4541
        },
        "L5": {
          "label": "L5",
          "addr": 4402
        },
        "L6": {
          "label": "L6",
          "addr": 4573
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *nums, int numsSize) {\n  if (numsSize < 2)\n    return -1;\n  int first = 0x7fffffff, second = 0x7fffffff;\n  for (int i = 0; i < numsSize; i++) {\n    if (nums[i] < first) {\n      second = first;\n      first = nums[i];\n    } else if (nums[i] < second && nums[i] != first)\n      second = nums[i];\n  }\n  return second == 0x7fffffff ? -1 : second;\n}"
    },
    {
      "task_id": 90,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    114a <func0+0x51>\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rdi\n  mov    $0x7fffffff,%eax\n  mov    $0x7fffffff,%esi\n  jmp    1126 <func0+0x2d>\n  mov    %esi,%eax\n  mov    %edx,%esi\n  add    $0x4,%rcx\n  cmp    %rdi,%rcx\n  je     113c <func0+0x43>\n  mov    (%rcx),%edx\n  cmp    %esi,%edx\n  jl     1119 <func0+0x20>\n  mov    %eax,%r8d\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  cmp    %esi,%edx\n  cmove  %r8d,%eax\n  jmp    111d <func0+0x24>\n  cmp    $0x7fffffff,%eax\n  je     1144 <func0+0x4b>\n  ret\n  mov    $0xffffffff,%eax\n  ret\n  mov    $0xffffffff,%eax\n  jmp    1143 <func0+0x4a>",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rdi\n  mov    $0x7fffffff,%eax\n  mov    $0x7fffffff,%esi\n  jmp    L1\nL3:\n  mov    %esi,%eax\n  mov    %edx,%esi\nL4:\n  add    $0x4,%rcx\n  cmp    %rdi,%rcx\n  je     L2\nL1:\n  mov    (%rcx),%edx\n  cmp    %esi,%edx\n  jl     L3\n  mov    %eax,%r8d\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  cmp    %esi,%edx\n  cmove  %r8d,%eax\n  jmp    L4\nL2:\n  cmp    $0x7fffffff,%eax\n  je     L5\nL6:\n  ret\nL5:\n  mov    $0xffffffff,%eax\n  ret\nL0:\n  mov    $0xffffffff,%eax\n  jmp    L6",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4426
        },
        "L1": {
          "label": "L1",
          "addr": 4390
        },
        "L2": {
          "label": "L2",
          "addr": 4412
        },
        "L3": {
          "label": "L3",
          "addr": 4377
        },
        "L4": {
          "label": "L4",
          "addr": 4381
        },
        "L5": {
          "label": "L5",
          "addr": 4420
        },
        "L6": {
          "label": "L6",
          "addr": 4419
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int max_val = 0x7FFFFFFF;\n  int sec_max_val = 0x7FFFFFFF;\n  for (int i = 0; i < len; i++) {\n    if (arr[i] < max_val) {\n      sec_max_val = max_val;\n      max_val = arr[i];\n    } else if (arr[i] > max_val && arr[i] <= sec_max_val) {\n      sec_max_val = arr[i];\n    }\n  }\n  if (sec_max_val == 0x7FFFFFFF) {\n    return -1;\n  }\n  return sec_max_val;\n}"
    },
    {
      "task_id": 90,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1153 <func0+0x53>\n  lea    -0x1(%rsi),%eax\n  mov    $0x7fffffff,%r8d\n  mov    $0x7fffffff,%edx\n  lea    0x4(%rdi,%rax,4),%rcx\n  jmp    1132 <func0+0x32>\n  xchg   %ax,%ax\n  je     1129 <func0+0x29>\n  cmp    %r8d,%eax\n  cmovle %eax,%r8d\n  add    $0x4,%rdi\n  cmp    %rcx,%rdi\n  je     1146 <func0+0x46>\n  mov    (%rdi),%eax\n  cmp    %edx,%eax\n  jge    1120 <func0+0x20>\n  add    $0x4,%rdi\n  mov    %edx,%r8d\n  mov    %eax,%edx\n  cmp    %rcx,%rdi\n  jne    1132 <func0+0x32>\n  cmp    $0x7fffffff,%r8d\n  je     1153 <func0+0x53>\n  mov    %r8d,%eax\n  ret\n  mov    $0xffffffff,%r8d\n  jmp    114f <func0+0x4f>",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    $0x7fffffff,%r8d\n  mov    $0x7fffffff,%edx\n  lea    0x4(%rdi,%rax,4),%rcx\n  jmp    L1\n  xchg   %ax,%ax\nL4:\n  je     L2\n  cmp    %r8d,%eax\n  cmovle %eax,%r8d\nL2:\n  add    $0x4,%rdi\n  cmp    %rcx,%rdi\n  je     L3\nL1:\n  mov    (%rdi),%eax\n  cmp    %edx,%eax\n  jge    L4\n  add    $0x4,%rdi\n  mov    %edx,%r8d\n  mov    %eax,%edx\n  cmp    %rcx,%rdi\n  jne    L1\nL3:\n  cmp    $0x7fffffff,%r8d\n  je     L0\nL5:\n  mov    %r8d,%eax\n  ret\nL0:\n  mov    $0xffffffff,%r8d\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4435
        },
        "L1": {
          "label": "L1",
          "addr": 4402
        },
        "L2": {
          "label": "L2",
          "addr": 4393
        },
        "L3": {
          "label": "L3",
          "addr": 4422
        },
        "L4": {
          "label": "L4",
          "addr": 4384
        },
        "L5": {
          "label": "L5",
          "addr": 4431
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int first = 0x7fffffff;\n  int second = 0x7fffffff;\n  int i;\n  for (i = 0; i < len; i++) {\n    if (arr[i] < first) {\n      second = first;\n      first = arr[i];\n    } else if (arr[i] != first && arr[i] < second) {\n      second = arr[i];\n    }\n  }\n  if (second == 0x7fffffff)\n    return -1;\n  return second;\n}"
    },
    {
      "task_id": 88,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    1190 <func0+0x30>\n  movq   $0x0,(%rdx)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\n  movslq %esi,%r13\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  shl    $0x2,%r13\n  mov    %r13,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,(%r12)\n  mov    %rax,%r10\n  test   %rax,%rax\n  je     1268 <func0+0x108>\n  test   %ebx,%ebx\n  jle    11c9 <func0+0x69>\n  mov    %r13,%rdx\n  mov    %rbp,%rsi\n  mov    %rax,%rdi\n  call   1070 <memcpy@plt>\n  mov    %rax,%r10\n  mov    0x0(%rbp),%eax\n  add    -0x4(%rbp,%r13,1),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%edi\n  and    $0x1,%edi\n  sub    %edx,%edi\n  cmp    $0x1,%ebx\n  jle    117e <func0+0x1e>\n  lea    -0x2(%rbx),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r9d\n  add    $0x8,%r10\n  add    $0x2,%r11\n  lea    -0x1(%rbx),%ebp\n  nopl   0x0(%rax)\n  cmp    %r9d,%ebx\n  jle    1250 <func0+0xf0>\n  mov    %ebp,%eax\n  sub    %r9d,%eax\n  lea    -0x1(%r9,%rax,1),%rax\n  lea    (%r10,%rax,4),%r8\n  mov    %rsi,%rax\n  jmp    1232 <func0+0xd2>\n  nopl   0x0(%rax,%rax,1)\n  cmp    %ecx,%edx\n  jge    1229 <func0+0xc9>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%r8\n  je     1250 <func0+0xf0>\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    $0x1,%edi\n  jne    1220 <func0+0xc0>\n  cmp    %ecx,%edx\n  jg     1224 <func0+0xc4>\n  add    $0x4,%rax\n  cmp    %rax,%r8\n  jne    1232 <func0+0xd2>\n  nopl   0x0(%rax)\n  add    $0x1,%r9\n  add    $0x4,%rsi\n  cmp    %r11,%r9\n  jne    1200 <func0+0xa0>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  mov    $0x1,%edi\n  call   1090 <exit@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    L0\n  movq   $0x0,(%rdx)\nL3:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\nL0:\n  movslq %esi,%r13\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  shl    $0x2,%r13\n  mov    %r13,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%r12)\n  mov    %rax,%r10\n  test   %rax,%rax\n  je     L1\n  test   %ebx,%ebx\n  jle    L2\n  mov    %r13,%rdx\n  mov    %rbp,%rsi\n  mov    %rax,%rdi\n  call   <memcpy@plt>\n  mov    %rax,%r10\nL2:\n  mov    0x0(%rbp),%eax\n  add    -0x4(%rbp,%r13,1),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%edi\n  and    $0x1,%edi\n  sub    %edx,%edi\n  cmp    $0x1,%ebx\n  jle    L3\n  lea    -0x2(%rbx),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r9d\n  add    $0x8,%r10\n  add    $0x2,%r11\n  lea    -0x1(%rbx),%ebp\n  nopl   0x0(%rax)\nL9:\n  cmp    %r9d,%ebx\n  jle    L4\n  mov    %ebp,%eax\n  sub    %r9d,%eax\n  lea    -0x1(%r9,%rax,1),%rax\n  lea    (%r10,%rax,4),%r8\n  mov    %rsi,%rax\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL7:\n  cmp    %ecx,%edx\n  jge    L6\nL8:\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\nL6:\n  add    $0x4,%rax\n  cmp    %rax,%r8\n  je     L4\nL5:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    $0x1,%edi\n  jne    L7\n  cmp    %ecx,%edx\n  jg     L8\n  add    $0x4,%rax\n  cmp    %rax,%r8\n  jne    L5\n  nopl   0x0(%rax)\nL4:\n  add    $0x1,%r9\n  add    $0x4,%rsi\n  cmp    %r11,%r9\n  jne    L9\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL1:\n  mov    $0x1,%edi\n  call   <exit@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4496
        },
        "L1": {
          "label": "L1",
          "addr": 4712
        },
        "L2": {
          "label": "L2",
          "addr": 4553
        },
        "L3": {
          "label": "L3",
          "addr": 4478
        },
        "L4": {
          "label": "L4",
          "addr": 4688
        },
        "L5": {
          "label": "L5",
          "addr": 4658
        },
        "L6": {
          "label": "L6",
          "addr": 4649
        },
        "L7": {
          "label": "L7",
          "addr": 4640
        },
        "L8": {
          "label": "L8",
          "addr": 4644
        },
        "L9": {
          "label": "L9",
          "addr": 4608
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int **ret, int *ret_size) {\n  int i, j, tmp;\n  *ret_size = n;\n  if (n == 0) {\n    *ret = NULL;\n    return;\n  }\n  *ret = (int *)malloc(n * sizeof(int));\n  if (*ret == NULL)\n    exit(1);\n  for (i = 0; i < n; i++)\n    (*ret)[i] = x[i];\n  if ((x[0] + x[n - 1]) % 2 == 0)\n    return;\n  for (i = 0; i < n - 1; i++) {\n    for (j = i + 1; j < n; j++) {\n      if ((x[i] + x[j]) % 2 == 1) {\n        tmp = x[i];\n        x[i] = x[j];\n        x[j] = tmp;\n      }\n    }\n  }\n}"
    },
    {
      "task_id": 90,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1153 <func0+0x53>\n  lea    -0x1(%rsi),%eax\n  mov    $0x7fffffff,%r8d\n  mov    $0x7fffffff,%edx\n  lea    0x4(%rdi,%rax,4),%rcx\n  jmp    1132 <func0+0x32>\n  xchg   %ax,%ax\n  je     1129 <func0+0x29>\n  cmp    %r8d,%eax\n  cmovle %eax,%r8d\n  add    $0x4,%rdi\n  cmp    %rdi,%rcx\n  je     1146 <func0+0x46>\n  mov    (%rdi),%eax\n  cmp    %eax,%edx\n  jle    1120 <func0+0x20>\n  add    $0x4,%rdi\n  mov    %edx,%r8d\n  mov    %eax,%edx\n  cmp    %rdi,%rcx\n  jne    1132 <func0+0x32>\n  cmp    $0x7fffffff,%r8d\n  je     1153 <func0+0x53>\n  mov    %r8d,%eax\n  ret\n  mov    $0xffffffff,%r8d\n  jmp    114f <func0+0x4f>",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    $0x7fffffff,%r8d\n  mov    $0x7fffffff,%edx\n  lea    0x4(%rdi,%rax,4),%rcx\n  jmp    L1\n  xchg   %ax,%ax\nL4:\n  je     L2\n  cmp    %r8d,%eax\n  cmovle %eax,%r8d\nL2:\n  add    $0x4,%rdi\n  cmp    %rdi,%rcx\n  je     L3\nL1:\n  mov    (%rdi),%eax\n  cmp    %eax,%edx\n  jle    L4\n  add    $0x4,%rdi\n  mov    %edx,%r8d\n  mov    %eax,%edx\n  cmp    %rdi,%rcx\n  jne    L1\nL3:\n  cmp    $0x7fffffff,%r8d\n  je     L0\nL5:\n  mov    %r8d,%eax\n  ret\nL0:\n  mov    $0xffffffff,%r8d\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4435
        },
        "L1": {
          "label": "L1",
          "addr": 4402
        },
        "L2": {
          "label": "L2",
          "addr": 4393
        },
        "L3": {
          "label": "L3",
          "addr": 4422
        },
        "L4": {
          "label": "L4",
          "addr": 4384
        },
        "L5": {
          "label": "L5",
          "addr": 4431
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int first = 0x7fffffff;\n  int second = 0x7fffffff;\n  int i;\n  for (i = 0; i < len; i++) {\n    if (arr[i] < first) {\n      second = first;\n      first = arr[i];\n    } else if (arr[i] != first) {\n      if (arr[i] < second)\n        second = arr[i];\n    }\n  }\n  if (second == 0x7fffffff)\n    return -1;\n  return second;\n}"
    },
    {
      "task_id": 88,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdx,%rbx\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    1162 <func0+0x29>\n  movq   $0x0,(%rdx)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  movslq %esi,%r13\n  shl    $0x2,%r13\n  mov    %r13,%rdi\n  call   1060 <malloc@plt>\n  mov    %rax,(%rbx)\n  test   %rax,%rax\n  je     11d5 <func0+0x9c>\n  mov    %ebp,%esi\n  shl    $0x2,%rsi\n  mov    $0x0,%eax\n  test   %ebp,%ebp\n  jle    11a0 <func0+0x67>\n  mov    (%r12,%rax,1),%ecx\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  jne    118d <func0+0x54>\n  mov    (%r12),%eax\n  add    -0x4(%r12,%r13,1),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%r9d\n  and    $0x1,%r9d\n  sub    %edx,%r9d\n  cmp    $0x1,%ebp\n  jle    1157 <func0+0x1e>\n  lea    -0x1(%rbp),%r12d\n  mov    $0x0,%edi\n  mov    $0x0,%r11d\n  mov    $0x0,%r10d\n  jmp    1231 <func0+0xf8>\n  mov    $0x1,%edi\n  call   1070 <exit@plt>\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rdi,1),%rsi\n  mov    (%rsi),%ecx\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%ecx\n  jle    11f7 <func0+0xbe>\n  mov    %edx,(%rsi)\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  je     1220 <func0+0xe7>\n  cmp    $0x1,%r9d\n  je     11df <func0+0xa6>\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rdi,1),%rsi\n  mov    (%rsi),%ecx\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%ecx\n  jge    11f7 <func0+0xbe>\n  mov    %edx,(%rsi)\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\n  jmp    11f7 <func0+0xbe>\n  add    $0x1,%r11\n  add    $0x4,%rdi\n  cmp    %r12d,%r10d\n  je     1157 <func0+0x1e>\n  add    $0x1,%r10d\n  cmp    %r10d,%ebp\n  jle    1220 <func0+0xe7>\n  lea    0x4(%rdi),%rax\n  mov    %r12d,%edx\n  sub    %r10d,%edx\n  lea    0x2(%r11,%rdx,1),%r8\n  shl    $0x2,%r8\n  jmp    1200 <func0+0xc7>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdx,%rbx\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    L0\n  movq   $0x0,(%rdx)\nL4:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL0:\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  movslq %esi,%r13\n  shl    $0x2,%r13\n  mov    %r13,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  test   %rax,%rax\n  je     L1\n  mov    %ebp,%esi\n  shl    $0x2,%rsi\n  mov    $0x0,%eax\n  test   %ebp,%ebp\n  jle    L2\nL3:\n  mov    (%r12,%rax,1),%ecx\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  jne    L3\nL2:\n  mov    (%r12),%eax\n  add    -0x4(%r12,%r13,1),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%r9d\n  and    $0x1,%r9d\n  sub    %edx,%r9d\n  cmp    $0x1,%ebp\n  jle    L4\n  lea    -0x1(%rbp),%r12d\n  mov    $0x0,%edi\n  mov    $0x0,%r11d\n  mov    $0x0,%r10d\n  jmp    L5\nL1:\n  mov    $0x1,%edi\n  call   <exit@plt>\nL8:\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rdi,1),%rsi\n  mov    (%rsi),%ecx\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%ecx\n  jle    L6\n  mov    %edx,(%rsi)\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\nL6:\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  je     L7\nL9:\n  cmp    $0x1,%r9d\n  je     L8\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rdi,1),%rsi\n  mov    (%rsi),%ecx\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%ecx\n  jge    L6\n  mov    %edx,(%rsi)\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\n  jmp    L6\nL7:\n  add    $0x1,%r11\n  add    $0x4,%rdi\n  cmp    %r12d,%r10d\n  je     L4\nL5:\n  add    $0x1,%r10d\n  cmp    %r10d,%ebp\n  jle    L7\n  lea    0x4(%rdi),%rax\n  mov    %r12d,%edx\n  sub    %r10d,%edx\n  lea    0x2(%r11,%rdx,1),%r8\n  shl    $0x2,%r8\n  jmp    L9",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4450
        },
        "L1": {
          "label": "L1",
          "addr": 4565
        },
        "L2": {
          "label": "L2",
          "addr": 4512
        },
        "L3": {
          "label": "L3",
          "addr": 4493
        },
        "L4": {
          "label": "L4",
          "addr": 4439
        },
        "L5": {
          "label": "L5",
          "addr": 4657
        },
        "L6": {
          "label": "L6",
          "addr": 4599
        },
        "L7": {
          "label": "L7",
          "addr": 4640
        },
        "L8": {
          "label": "L8",
          "addr": 4575
        },
        "L9": {
          "label": "L9",
          "addr": 4608
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int **y, int *m) {\n  int i, j, t, sum;\n  *m = n;\n  if (n == 0) {\n    *y = NULL;\n    return;\n  }\n  *y = (int *)malloc(n * sizeof(int));\n  if (*y == NULL)\n    exit(1);\n  for (i = 0; i < n; i++)\n    (*y)[i] = x[i];\n  sum = x[0] + x[n - 1];\n  for (i = 0; i < n - 1; i++) {\n    for (j = i + 1; j < n; j++) {\n      if (sum % 2 == 1) {\n        if ((*y)[i] > (*y)[j]) {\n          t = (*y)[i];\n          (*y)[i] = (*y)[j];\n          (*y)[j] = t;\n        }\n      } else {\n        if ((*y)[i] < (*y)[j]) {\n          t = (*y)[i];\n          (*y)[i] = (*y)[j];\n          (*y)[j] = t;\n        }\n      }\n    }\n  }\n}"
    },
    {
      "task_id": 88,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %rcx,-0x40(%rbp)\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  cmpl   $0x0,-0x2c(%rbp)\n  jne    1173 <func0+0x3a>\n  mov    -0x38(%rbp),%rax\n  movq   $0x0,(%rax)\n  jmp    137c <func0+0x243>\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1060 <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rax\n  test   %rax,%rax\n  jne    11a4 <func0+0x6b>\n  mov    $0x1,%edi\n  call   1070 <exit@plt>\n  movl   $0x0,-0x18(%rbp)\n  jmp    11dd <func0+0xa4>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     11ad <func0+0x74>\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%edx\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    136d <func0+0x234>\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    135d <func0+0x224>\n  cmpl   $0x0,-0xc(%rbp)\n  je     12d0 <func0+0x197>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    1359 <func0+0x220>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    1359 <func0+0x220>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    1359 <func0+0x220>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1234 <func0+0xfb>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     1226 <func0+0xed>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %rcx,-0x40(%rbp)\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  cmpl   $0x0,-0x2c(%rbp)\n  jne    L0\n  mov    -0x38(%rbp),%rax\n  movq   $0x0,(%rax)\n  jmp    L1\nL0:\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rax\n  test   %rax,%rax\n  jne    L2\n  mov    $0x1,%edi\n  call   <exit@plt>\nL2:\n  movl   $0x0,-0x18(%rbp)\n  jmp    L3\nL4:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x18(%rbp)\nL3:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L4\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%edx\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L5\nL10:\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    L6\nL9:\n  cmpl   $0x0,-0xc(%rbp)\n  je     L7\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L8\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    L8\nL7:\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L8\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\nL8:\n  addl   $0x1,-0x10(%rbp)\nL6:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L9\n  addl   $0x1,-0x14(%rbp)\nL5:\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     L10\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4467
        },
        "L1": {
          "label": "L1",
          "addr": 4988
        },
        "L2": {
          "label": "L2",
          "addr": 4516
        },
        "L3": {
          "label": "L3",
          "addr": 4573
        },
        "L4": {
          "label": "L4",
          "addr": 4525
        },
        "L5": {
          "label": "L5",
          "addr": 4973
        },
        "L6": {
          "label": "L6",
          "addr": 4957
        },
        "L7": {
          "label": "L7",
          "addr": 4816
        },
        "L8": {
          "label": "L8",
          "addr": 4953
        },
        "L9": {
          "label": "L9",
          "addr": 4660
        },
        "L10": {
          "label": "L10",
          "addr": 4646
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *p, int n, int **q, int *m) {\n  int i, j, k, l, f;\n  *m = n;\n  if (n == 0) {\n    *q = NULL;\n    return;\n  }\n  *q = (int *)malloc(n * sizeof(int));\n  if (*q == NULL)\n    exit(1);\n  for (i = 0; i < n; i++)\n    (*q)[i] = p[i];\n  f = ((p[0] + p[n - 1]) % 2 == 1);\n  for (i = 0; i < n - 1; i++) {\n    for (j = i + 1; j < n; j++) {\n      if (f) {\n        if ((*q)[i] > (*q)[j]) {\n          k = (*q)[i];\n          (*q)[i] = (*q)[j];\n          (*q)[j] = k;\n        }\n      } else {\n        if ((*q)[i] < (*q)[j]) {\n          l = (*q)[i];\n          (*q)[i] = (*q)[j];\n          (*q)[j] = l;\n        }\n      }\n    }\n  }\n}"
    },
    {
      "task_id": 88,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    1188 <func0+0x28>\n  movq   $0x0,(%rdx)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   (%rax)\n  movslq %esi,%r14\n  mov    %rdi,%r12\n  mov    %esi,%ebx\n  shl    $0x2,%r14\n  mov    %r14,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,0x0(%r13)\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     1269 <func0+0x109>\n  test   %ebx,%ebx\n  jle    11be <func0+0x5e>\n  mov    %r14,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  call   1070 <memcpy@plt>\n  mov    (%r12),%eax\n  add    -0x4(%r12,%r14,1),%eax\n  lea    -0x1(%rbx),%r12d\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%r11d\n  and    $0x1,%r11d\n  sub    %edx,%r11d\n  test   %r12d,%r12d\n  jle    117c <func0+0x1c>\n  lea    0x4(%rbp),%rdx\n  lea    -0x2(%rbx),%r10d\n  xor    %r9d,%r9d\n  xor    %r8d,%r8d\n  add    $0x8,%rbp\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jle    122f <func0+0xcf>\n  mov    %r10d,%eax\n  add    %r9,%rax\n  lea    0x0(%rbp,%rax,4),%rdi\n  mov    %rdx,%rax\n  cmp    $0x1,%r11d\n  je     1250 <func0+0xf0>\n  nopl   (%rax)\n  mov    -0x4(%rdx),%ecx\n  mov    (%rax),%esi\n  cmp    %ecx,%esi\n  jle    1226 <func0+0xc6>\n  mov    %esi,-0x4(%rdx)\n  mov    %ecx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    1218 <func0+0xb8>\n  add    $0x1,%r9\n  add    $0x4,%rdx\n  sub    $0x1,%r10d\n  cmp    %r12d,%r8d\n  jne    11f8 <func0+0x98>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\n  mov    -0x4(%rdx),%ecx\n  mov    (%rax),%esi\n  cmp    %esi,%ecx\n  jle    125e <func0+0xfe>\n  mov    %esi,-0x4(%rdx)\n  mov    %ecx,(%rax)\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    1250 <func0+0xf0>\n  jmp    122f <func0+0xcf>\n  mov    $0x1,%edi\n  call   1090 <exit@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    L0\n  movq   $0x0,(%rdx)\nL3:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   (%rax)\nL0:\n  movslq %esi,%r14\n  mov    %rdi,%r12\n  mov    %esi,%ebx\n  shl    $0x2,%r14\n  mov    %r14,%rdi\n  call   <malloc@plt>\n  mov    %rax,0x0(%r13)\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     L1\n  test   %ebx,%ebx\n  jle    L2\n  mov    %r14,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  call   <memcpy@plt>\nL2:\n  mov    (%r12),%eax\n  add    -0x4(%r12,%r14,1),%eax\n  lea    -0x1(%rbx),%r12d\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%r11d\n  and    $0x1,%r11d\n  sub    %edx,%r11d\n  test   %r12d,%r12d\n  jle    L3\n  lea    0x4(%rbp),%rdx\n  lea    -0x2(%rbx),%r10d\n  xor    %r9d,%r9d\n  xor    %r8d,%r8d\n  add    $0x8,%rbp\n  nopw   0x0(%rax,%rax,1)\nL8:\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jle    L4\n  mov    %r10d,%eax\n  add    %r9,%rax\n  lea    0x0(%rbp,%rax,4),%rdi\n  mov    %rdx,%rax\n  cmp    $0x1,%r11d\n  je     L5\n  nopl   (%rax)\nL7:\n  mov    -0x4(%rdx),%ecx\n  mov    (%rax),%esi\n  cmp    %ecx,%esi\n  jle    L6\n  mov    %esi,-0x4(%rdx)\n  mov    %ecx,(%rax)\nL6:\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    L7\nL4:\n  add    $0x1,%r9\n  add    $0x4,%rdx\n  sub    $0x1,%r10d\n  cmp    %r12d,%r8d\n  jne    L8\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\nL5:\n  mov    -0x4(%rdx),%ecx\n  mov    (%rax),%esi\n  cmp    %esi,%ecx\n  jle    L9\n  mov    %esi,-0x4(%rdx)\n  mov    %ecx,(%rax)\nL9:\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    L5\n  jmp    L4\nL1:\n  mov    $0x1,%edi\n  call   <exit@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4488
        },
        "L1": {
          "label": "L1",
          "addr": 4713
        },
        "L2": {
          "label": "L2",
          "addr": 4542
        },
        "L3": {
          "label": "L3",
          "addr": 4476
        },
        "L4": {
          "label": "L4",
          "addr": 4655
        },
        "L5": {
          "label": "L5",
          "addr": 4688
        },
        "L6": {
          "label": "L6",
          "addr": 4646
        },
        "L7": {
          "label": "L7",
          "addr": 4632
        },
        "L8": {
          "label": "L8",
          "addr": 4600
        },
        "L9": {
          "label": "L9",
          "addr": 4702
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int **ret, int *ret_size) {\n  *ret_size = n;\n  if (n == 0) {\n    *ret = NULL;\n    return;\n  }\n  *ret = malloc(n * sizeof(int));\n  if (*ret == NULL)\n    exit(1);\n  for (int i = 0; i < n; i++)\n    (*ret)[i] = x[i];\n  int odd = (x[0] + x[n - 1]) % 2;\n  for (int i = 0; i < n - 1; i++) {\n    for (int j = i + 1; j < n; j++) {\n      if (odd == 1) {\n        if ((*ret)[i] > (*ret)[j]) {\n          int tmp = (*ret)[i];\n          (*ret)[i] = (*ret)[j];\n          (*ret)[j] = tmp;\n        }\n      } else {\n        if ((*ret)[i] < (*ret)[j]) {\n          int tmp = (*ret)[i];\n          (*ret)[i] = (*ret)[j];\n          (*ret)[j] = tmp;\n        }\n      }\n    }\n  }\n}"
    },
    {
      "task_id": 92,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x10,%rsp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  %xmm2,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  movd   %eax,%xmm0\n  call   1050 <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm3\n  ucomiss -0x4(%rbp),%xmm3\n  jp     1158 <func0+0x3f>\n  movd   %eax,%xmm4\n  ucomiss -0x4(%rbp),%xmm4\n  je     1162 <func0+0x49>\n  mov    $0x0,%eax\n  jmp    1206 <func0+0xed>\n  mov    -0x8(%rbp),%eax\n  movd   %eax,%xmm0\n  call   1050 <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm5\n  ucomiss -0x8(%rbp),%xmm5\n  jp     1186 <func0+0x6d>\n  movd   %eax,%xmm6\n  ucomiss -0x8(%rbp),%xmm6\n  je     118d <func0+0x74>\n  mov    $0x0,%eax\n  jmp    1206 <func0+0xed>\n  mov    -0xc(%rbp),%eax\n  movd   %eax,%xmm0\n  call   1050 <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm7\n  ucomiss -0xc(%rbp),%xmm7\n  jp     11b1 <func0+0x98>\n  movd   %eax,%xmm1\n  ucomiss -0xc(%rbp),%xmm1\n  je     11b8 <func0+0x9f>\n  mov    $0x0,%eax\n  jmp    1206 <func0+0xed>\n  movss  -0x4(%rbp),%xmm0\n  addss  -0x8(%rbp),%xmm0\n  ucomiss -0xc(%rbp),%xmm0\n  jp     11ce <func0+0xb5>\n  ucomiss -0xc(%rbp),%xmm0\n  je     11fa <func0+0xe1>\n  movss  -0x4(%rbp),%xmm0\n  addss  -0xc(%rbp),%xmm0\n  ucomiss -0x8(%rbp),%xmm0\n  jp     11e4 <func0+0xcb>\n  ucomiss -0x8(%rbp),%xmm0\n  je     11fa <func0+0xe1>\n  movss  -0x8(%rbp),%xmm0\n  addss  -0xc(%rbp),%xmm0\n  ucomiss -0x4(%rbp),%xmm0\n  jp     1201 <func0+0xe8>\n  ucomiss -0x4(%rbp),%xmm0\n  jne    1201 <func0+0xe8>\n  mov    $0x1,%eax\n  jmp    1206 <func0+0xed>\n  mov    $0x0,%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x10,%rsp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  %xmm2,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  movd   %eax,%xmm0\n  call   <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm3\n  ucomiss -0x4(%rbp),%xmm3\n  jp     L0\n  movd   %eax,%xmm4\n  ucomiss -0x4(%rbp),%xmm4\n  je     L1\nL0:\n  mov    $0x0,%eax\n  jmp    L2\nL1:\n  mov    -0x8(%rbp),%eax\n  movd   %eax,%xmm0\n  call   <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm5\n  ucomiss -0x8(%rbp),%xmm5\n  jp     L3\n  movd   %eax,%xmm6\n  ucomiss -0x8(%rbp),%xmm6\n  je     L4\nL3:\n  mov    $0x0,%eax\n  jmp    L2\nL4:\n  mov    -0xc(%rbp),%eax\n  movd   %eax,%xmm0\n  call   <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm7\n  ucomiss -0xc(%rbp),%xmm7\n  jp     L5\n  movd   %eax,%xmm1\n  ucomiss -0xc(%rbp),%xmm1\n  je     L6\nL5:\n  mov    $0x0,%eax\n  jmp    L2\nL6:\n  movss  -0x4(%rbp),%xmm0\n  addss  -0x8(%rbp),%xmm0\n  ucomiss -0xc(%rbp),%xmm0\n  jp     L7\n  ucomiss -0xc(%rbp),%xmm0\n  je     L8\nL7:\n  movss  -0x4(%rbp),%xmm0\n  addss  -0xc(%rbp),%xmm0\n  ucomiss -0x8(%rbp),%xmm0\n  jp     L9\n  ucomiss -0x8(%rbp),%xmm0\n  je     L8\nL9:\n  movss  -0x8(%rbp),%xmm0\n  addss  -0xc(%rbp),%xmm0\n  ucomiss -0x4(%rbp),%xmm0\n  jp     L10\n  ucomiss -0x4(%rbp),%xmm0\n  jne    L10\nL8:\n  mov    $0x1,%eax\n  jmp    L2\nL10:\n  mov    $0x0,%eax\nL2:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4440
        },
        "L1": {
          "label": "L1",
          "addr": 4450
        },
        "L2": {
          "label": "L2",
          "addr": 4614
        },
        "L3": {
          "label": "L3",
          "addr": 4486
        },
        "L4": {
          "label": "L4",
          "addr": 4493
        },
        "L5": {
          "label": "L5",
          "addr": 4529
        },
        "L6": {
          "label": "L6",
          "addr": 4536
        },
        "L7": {
          "label": "L7",
          "addr": 4558
        },
        "L8": {
          "label": "L8",
          "addr": 4602
        },
        "L9": {
          "label": "L9",
          "addr": 4580
        },
        "L10": {
          "label": "L10",
          "addr": 4609
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float a, float b, float c) {\n  if (roundf(a) != a)\n    return 0;\n  if (roundf(b) != b)\n    return 0;\n  if (roundf(c) != c)\n    return 0;\n  if (a + b == c || a + c == b || b + c == a)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 91,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  mov    $0x0,%ebp\n  test   %bl,%bl\n  je     11d6 <func0+0xbd>\n  mov    %rdi,%rbp\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%r9\n  movsbq %bl,%rax\n  movzwl (%r9,%rax,2),%eax\n  and    $0x2000,%ax\n  lea    0x1(%rbp),%rsi\n  mov    $0x1,%edx\n  mov    $0x0,%ebp\n  mov    $0x0,%edi\n  mov    $0x0,%r8d\n  movabs $0x8000400200000000,%r11\n  mov    $0x1,%r10d\n  jmp    117a <func0+0x61>\n  add    $0x1,%rsi\n  test   %edx,%edx\n  je     1183 <func0+0x6a>\n  cmp    $0x49,%bl\n  je     11c8 <func0+0xaf>\n  test   %ax,%ax\n  cmove  %r8d,%edi\n  cmove  %r8d,%edx\n  cmp    $0x3f,%bl\n  ja     11a1 <func0+0x88>\n  mov    %r11,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r10d,%edx\n  movzbl (%rsi),%ebx\n  test   %bl,%bl\n  je     11d6 <func0+0xbd>\n  movsbq %bl,%rax\n  movzwl (%r9,%rax,2),%eax\n  and    $0x2000,%ax\n  test   %edi,%edi\n  je     1176 <func0+0x5d>\n  test   %ax,%ax\n  je     1176 <func0+0x5d>\n  add    $0x1,%ebp\n  mov    $0x0,%edi\n  jmp    1176 <func0+0x5d>\n  mov    $0x1,%edi\n  test   %ax,%ax\n  cmove  %r8d,%edx\n  jmp    11a1 <func0+0x88>\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  mov    $0x0,%ebp\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%r9\n  movsbq %bl,%rax\n  movzwl (%r9,%rax,2),%eax\n  and    $0x2000,%ax\n  lea    0x1(%rbp),%rsi\n  mov    $0x1,%edx\n  mov    $0x0,%ebp\n  mov    $0x0,%edi\n  mov    $0x0,%r8d\n  movabs $0x8000400200000000,%r11\n  mov    $0x1,%r10d\n  jmp    L1\nL5:\n  add    $0x1,%rsi\nL1:\n  test   %edx,%edx\n  je     L2\n  cmp    $0x49,%bl\n  je     L3\nL2:\n  test   %ax,%ax\n  cmove  %r8d,%edi\n  cmove  %r8d,%edx\n  cmp    $0x3f,%bl\n  ja     L4\n  mov    %r11,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r10d,%edx\nL4:\n  movzbl (%rsi),%ebx\n  test   %bl,%bl\n  je     L0\n  movsbq %bl,%rax\n  movzwl (%r9,%rax,2),%eax\n  and    $0x2000,%ax\n  test   %edi,%edi\n  je     L5\n  test   %ax,%ax\n  je     L5\n  add    $0x1,%ebp\n  mov    $0x0,%edi\n  jmp    L5\nL3:\n  mov    $0x1,%edi\n  test   %ax,%ax\n  cmove  %r8d,%edx\n  jmp    L4\nL0:\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4566
        },
        "L1": {
          "label": "L1",
          "addr": 4474
        },
        "L2": {
          "label": "L2",
          "addr": 4483
        },
        "L3": {
          "label": "L3",
          "addr": 4552
        },
        "L4": {
          "label": "L4",
          "addr": 4513
        },
        "L5": {
          "label": "L5",
          "addr": 4470
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(const char *s) {\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int l = 0;\n  unsigned short tmp;\n  unsigned short *p;\n  unsigned char c;\n  while (c = *s) {\n    p = (unsigned short *)__ctype_b_loc();\n    tmp = p[c];\n    if (l && tmp & 0x2000) {\n      j++;\n      l = 0;\n    }\n    if (tmp & 0x2000)\n      k = 0;\n    if (k)\n      i++;\n    if (c == 'I')\n      l = 1;\n    if (c == 'J')\n      k = 0;\n    if (c == '?' || c == '!' || c == '.')\n      k = 1;\n    s++;\n  }\n  return j;\n}"
    },
    {
      "task_id": 92,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x4(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x8(%rsp)\n  call   1050 <roundf@plt>\n  ucomiss 0x8(%rsp),%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0x4(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  ucomiss 0x4(%rsp),%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0xc(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0x8(%rsp),%xmm0\n  addss  0x4(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     1194 <func0+0x74>\n  mov    $0x1,%eax\n  je     11da <func0+0xba>\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  jp     11ae <func0+0x8e>\n  mov    $0x1,%eax\n  je     11da <func0+0xba>\n  movss  0x4(%rsp),%xmm0\n  xor    %eax,%eax\n  mov    $0x0,%edx\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x8(%rsp),%xmm0\n  setnp  %al\n  cmovne %edx,%eax\n  add    $0x18,%rsp\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  add    $0x18,%rsp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x4(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x8(%rsp)\n  call   <roundf@plt>\n  ucomiss 0x8(%rsp),%xmm0\n  jp     L0\n  jne    L0\n  movss  0x4(%rsp),%xmm0\n  call   <roundf@plt>\n  ucomiss 0x4(%rsp),%xmm0\n  jp     L0\n  jne    L0\n  movss  0xc(%rsp),%xmm0\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     L0\n  jne    L0\n  movss  0x8(%rsp),%xmm0\n  addss  0x4(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     L1\n  mov    $0x1,%eax\n  je     L2\nL1:\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  jp     L3\n  mov    $0x1,%eax\n  je     L2\nL3:\n  movss  0x4(%rsp),%xmm0\n  xor    %eax,%eax\n  mov    $0x0,%edx\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x8(%rsp),%xmm0\n  setnp  %al\n  cmovne %edx,%eax\n  add    $0x18,%rsp\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\nL2:\n  add    $0x18,%rsp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4568
        },
        "L1": {
          "label": "L1",
          "addr": 4500
        },
        "L2": {
          "label": "L2",
          "addr": 4570
        },
        "L3": {
          "label": "L3",
          "addr": 4526
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float a, float b, float c) {\n  if (roundf(a) != a)\n    return 0;\n  if (roundf(b) != b)\n    return 0;\n  if (roundf(c) != c)\n    return 0;\n  if (a + b == c)\n    return 1;\n  if (a + c == b)\n    return 1;\n  if (b + c == a)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 91,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     11d0 <func0+0xb0>\n  mov    %rdi,%rbp\n  call   1050 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  mov    (%rax),%r9\n  mov    $0x1,%edx\n  mov    $0x1,%r11d\n  movabs $0x8000400200000000,%r10\n  jmp    118b <func0+0x6b>\n  cmp    $0x1,%esi\n  sbb    $0xffffffff,%r8d\n  test   %al,%al\n  jne    11c0 <func0+0xa0>\n  xor    %esi,%esi\n  cmp    $0x3f,%bl\n  ja     1180 <func0+0x60>\n  mov    %r10,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r11d,%edx\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     11b5 <func0+0x95>\n  cmp    $0x49,%bl\n  movsbq %bl,%rcx\n  sete   %al\n  and    %edx,%eax\n  testb  $0x20,0x1(%r9,%rcx,2)\n  jne    1160 <func0+0x40>\n  xor    %edx,%edx\n  test   %al,%al\n  je     116b <func0+0x4b>\n  mov    $0x1,%esi\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    118b <func0+0x6b>\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nop\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  jmp    11aa <func0+0x8a>\n  nopl   0x0(%rax)\n  add    $0x8,%rsp\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  mov    (%rax),%r9\n  mov    $0x1,%edx\n  mov    $0x1,%r11d\n  movabs $0x8000400200000000,%r10\n  jmp    L1\nL5:\n  cmp    $0x1,%esi\n  sbb    $0xffffffff,%r8d\n  test   %al,%al\n  jne    L2\nL6:\n  xor    %esi,%esi\n  cmp    $0x3f,%bl\n  ja     L3\n  mov    %r10,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r11d,%edx\nL3:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     L4\nL1:\n  cmp    $0x49,%bl\n  movsbq %bl,%rcx\n  sete   %al\n  and    %edx,%eax\n  testb  $0x20,0x1(%r9,%rcx,2)\n  jne    L5\n  xor    %edx,%edx\n  test   %al,%al\n  je     L6\n  mov    $0x1,%esi\nL7:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    L1\nL4:\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nop\nL2:\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  jmp    L7\n  nopl   0x0(%rax)\nL0:\n  add    $0x8,%rsp\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4560
        },
        "L1": {
          "label": "L1",
          "addr": 4491
        },
        "L2": {
          "label": "L2",
          "addr": 4544
        },
        "L3": {
          "label": "L3",
          "addr": 4480
        },
        "L4": {
          "label": "L4",
          "addr": 4533
        },
        "L5": {
          "label": "L5",
          "addr": 4448
        },
        "L6": {
          "label": "L6",
          "addr": 4459
        },
        "L7": {
          "label": "L7",
          "addr": 4522
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(const char *s) {\n  int state = 0;\n  int count = 0;\n  const unsigned char *_s = (const unsigned char *)s;\n  unsigned char c;\n  unsigned int *__L = __ctype_b_loc();\n  unsigned int __I = *__L;\n  while ((c = *_s++)) {\n    if ((((__I[c] >> 4) & 1) && state == 0) || ((__I[c] & 32) && state == 1)) {\n      state = 1;\n      count++;\n    } else if (state == 1 && ((c) == 'I')) {\n      state = 0;\n    } else {\n      state = 0;\n    }\n    switch (c) {\n    case ' ':\n    case '\\t':\n    case '\\n':\n    case '\\f':\n    case '\\r':\n    case '\\v':\n    case 0x7f:\n    case ',':\n    case ';':\n      state = 0;\n    }\n  }\n  return count;\n}"
    },
    {
      "task_id": 92,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x8(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x4(%rsp)\n  call   1050 <roundf@plt>\n  movss  0x4(%rsp),%xmm3\n  ucomiss %xmm3,%xmm0\n  jp     11d4 <func0+0xbb>\n  jne    11d4 <func0+0xbb>\n  movss  0x8(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  movss  0x8(%rsp),%xmm4\n  ucomiss %xmm4,%xmm0\n  jp     11de <func0+0xc5>\n  jne    11de <func0+0xc5>\n  movss  0xc(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     11e5 <func0+0xcc>\n  jne    11e5 <func0+0xcc>\n  movss  0x4(%rsp),%xmm0\n  addss  0x8(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     1195 <func0+0x7c>\n  mov    $0x1,%eax\n  je     11d9 <func0+0xc0>\n  movss  0x4(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  movss  0x8(%rsp),%xmm6\n  ucomiss %xmm6,%xmm0\n  jp     11b3 <func0+0x9a>\n  mov    $0x1,%eax\n  je     11d9 <func0+0xc0>\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  setnp  %al\n  movzbl %al,%eax\n  mov    $0x0,%edx\n  cmovne %edx,%eax\n  jmp    11d9 <func0+0xc0>\n  mov    $0x0,%eax\n  add    $0x18,%rsp\n  ret\n  mov    $0x0,%eax\n  jmp    11d9 <func0+0xc0>\n  mov    $0x0,%eax\n  jmp    11d9 <func0+0xc0>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x8(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x4(%rsp)\n  call   <roundf@plt>\n  movss  0x4(%rsp),%xmm3\n  ucomiss %xmm3,%xmm0\n  jp     L0\n  jne    L0\n  movss  0x8(%rsp),%xmm0\n  call   <roundf@plt>\n  movss  0x8(%rsp),%xmm4\n  ucomiss %xmm4,%xmm0\n  jp     L1\n  jne    L1\n  movss  0xc(%rsp),%xmm0\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     L2\n  jne    L2\n  movss  0x4(%rsp),%xmm0\n  addss  0x8(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     L3\n  mov    $0x1,%eax\n  je     L4\nL3:\n  movss  0x4(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  movss  0x8(%rsp),%xmm6\n  ucomiss %xmm6,%xmm0\n  jp     L5\n  mov    $0x1,%eax\n  je     L4\nL5:\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  setnp  %al\n  movzbl %al,%eax\n  mov    $0x0,%edx\n  cmovne %edx,%eax\n  jmp    L4\nL0:\n  mov    $0x0,%eax\nL4:\n  add    $0x18,%rsp\n  ret\nL1:\n  mov    $0x0,%eax\n  jmp    L4\nL2:\n  mov    $0x0,%eax\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4564
        },
        "L1": {
          "label": "L1",
          "addr": 4574
        },
        "L2": {
          "label": "L2",
          "addr": 4581
        },
        "L3": {
          "label": "L3",
          "addr": 4501
        },
        "L4": {
          "label": "L4",
          "addr": 4569
        },
        "L5": {
          "label": "L5",
          "addr": 4531
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float a, float b, float c) {\n  if (roundf(a) != a)\n    return 0;\n  if (roundf(b) != b)\n    return 0;\n  if (roundf(c) != c)\n    return 0;\n  if (a + b == c)\n    return 1;\n  if (a + c == b)\n    return 1;\n  if (b + c == a)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 92,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x4(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x8(%rsp)\n  call   1050 <roundf@plt>\n  ucomiss 0x8(%rsp),%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0x4(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  ucomiss 0x4(%rsp),%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0xc(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0x8(%rsp),%xmm0\n  addss  0x4(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     1194 <func0+0x74>\n  mov    $0x1,%eax\n  je     11da <func0+0xba>\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  jp     11ae <func0+0x8e>\n  mov    $0x1,%eax\n  je     11da <func0+0xba>\n  movss  0x4(%rsp),%xmm0\n  xor    %eax,%eax\n  mov    $0x0,%edx\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x8(%rsp),%xmm0\n  setnp  %al\n  cmovne %edx,%eax\n  add    $0x18,%rsp\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  add    $0x18,%rsp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x4(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x8(%rsp)\n  call   <roundf@plt>\n  ucomiss 0x8(%rsp),%xmm0\n  jp     L0\n  jne    L0\n  movss  0x4(%rsp),%xmm0\n  call   <roundf@plt>\n  ucomiss 0x4(%rsp),%xmm0\n  jp     L0\n  jne    L0\n  movss  0xc(%rsp),%xmm0\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     L0\n  jne    L0\n  movss  0x8(%rsp),%xmm0\n  addss  0x4(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     L1\n  mov    $0x1,%eax\n  je     L2\nL1:\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  jp     L3\n  mov    $0x1,%eax\n  je     L2\nL3:\n  movss  0x4(%rsp),%xmm0\n  xor    %eax,%eax\n  mov    $0x0,%edx\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x8(%rsp),%xmm0\n  setnp  %al\n  cmovne %edx,%eax\n  add    $0x18,%rsp\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\nL2:\n  add    $0x18,%rsp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4568
        },
        "L1": {
          "label": "L1",
          "addr": 4500
        },
        "L2": {
          "label": "L2",
          "addr": 4570
        },
        "L3": {
          "label": "L3",
          "addr": 4526
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float a, float b, float c) {\n  if (roundf(a) != a)\n    return 0;\n  if (roundf(b) != b)\n    return 0;\n  if (roundf(c) != c)\n    return 0;\n  if (a + b == c)\n    return 1;\n  if (a + c == b)\n    return 1;\n  if (b + c == a)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 91,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1266 <func0+0x14d>\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  je     118c <func0+0x73>\n  cmpl   $0x0,-0xc(%rbp)\n  je     118c <func0+0x73>\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x49,%al\n  jne    11af <func0+0x96>\n  cmpl   $0x0,-0x10(%rbp)\n  je     11af <func0+0x96>\n  movl   $0x1,-0xc(%rbp)\n  jmp    11e7 <func0+0xce>\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    11e7 <func0+0xce>\n  movl   $0x0,-0xc(%rbp)\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    121f <func0+0x106>\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2e,%al\n  je     125b <func0+0x142>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3f,%al\n  je     125b <func0+0x142>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x21,%al\n  jne    1262 <func0+0x149>\n  movl   $0x1,-0x10(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    114a <func0+0x31>\n  mov    -0x8(%rbp),%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL7:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  je     L1\n  cmpl   $0x0,-0xc(%rbp)\n  je     L1\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x49,%al\n  jne    L2\n  cmpl   $0x0,-0x10(%rbp)\n  je     L2\n  movl   $0x1,-0xc(%rbp)\n  jmp    L3\nL2:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    L3\n  movl   $0x0,-0xc(%rbp)\nL3:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    L4\n  movl   $0x0,-0x10(%rbp)\nL4:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2e,%al\n  je     L5\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3f,%al\n  je     L5\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x21,%al\n  jne    L6\nL5:\n  movl   $0x1,-0x10(%rbp)\nL6:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L7\n  mov    -0x8(%rbp),%eax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4710
        },
        "L1": {
          "label": "L1",
          "addr": 4492
        },
        "L2": {
          "label": "L2",
          "addr": 4527
        },
        "L3": {
          "label": "L3",
          "addr": 4583
        },
        "L4": {
          "label": "L4",
          "addr": 4639
        },
        "L5": {
          "label": "L5",
          "addr": 4699
        },
        "L6": {
          "label": "L6",
          "addr": 4706
        },
        "L7": {
          "label": "L7",
          "addr": 4426
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  int i, j, k, len;\n  i = 1;\n  j = 0;\n  len = 0;\n  for (k = 0; s[k] != '\\0'; k++) {\n    if (((*((unsigned short *)(__ctype_b_loc() + s[k] * 2 + 1))) & 0x2000) && j) {\n      j = 0;\n      len++;\n    }\n    if (s[k] == 'I' && i)\n      j = 1;\n    else if (!((*((unsigned short *)(__ctype_b_loc() + s[k] * 2 + 1))) & 0x2000))\n      j = 0;\n    if (!((*((unsigned short *)(__ctype_b_loc() + s[k] * 2 + 1))) & 0x2000))\n      i = 0;\n    if (s[k] == '.' || s[k] == '?' || s[k] == '!')\n      i = 1;\n  }\n  return len;\n}"
    },
    {
      "task_id": 94,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    118b <func0+0x92>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jle    1187 <func0+0x8e>\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    1168 <func0+0x6f>\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1164 <func0+0x6b>\n  movl   $0x0,-0xc(%rbp)\n  jmp    1173 <func0+0x7a>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    114e <func0+0x55>\n  cmpl   $0x0,-0xc(%rbp)\n  je     1187 <func0+0x8e>\n  mov    -0x18(%rbp),%edx\n  mov    -0x4(%rbp),%eax\n  cmp    %eax,%edx\n  cmovge %edx,%eax\n  mov    %eax,-0x18(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     111f <func0+0x26>\n  jmp    11e2 <func0+0xe9>\n  mov    -0x18(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  add    %edx,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x18(%rbp)\n  cmpl   $0x0,-0x18(%rbp)\n  jg     1195 <func0+0x9c>\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL6:\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jle    L1\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    L2\nL5:\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L3\n  movl   $0x0,-0xc(%rbp)\n  jmp    L4\nL3:\n  addl   $0x1,-0x8(%rbp)\nL2:\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    L5\nL4:\n  cmpl   $0x0,-0xc(%rbp)\n  je     L1\n  mov    -0x18(%rbp),%edx\n  mov    -0x4(%rbp),%eax\n  cmp    %eax,%edx\n  cmovge %edx,%eax\n  mov    %eax,-0x18(%rbp)\nL1:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L6\n  jmp    L7\nL8:\n  mov    -0x18(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  add    %edx,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x18(%rbp)\nL7:\n  cmpl   $0x0,-0x18(%rbp)\n  jg     L8\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4491
        },
        "L1": {
          "label": "L1",
          "addr": 4487
        },
        "L2": {
          "label": "L2",
          "addr": 4456
        },
        "L3": {
          "label": "L3",
          "addr": 4452
        },
        "L4": {
          "label": "L4",
          "addr": 4467
        },
        "L5": {
          "label": "L5",
          "addr": 4430
        },
        "L6": {
          "label": "L6",
          "addr": 4383
        },
        "L7": {
          "label": "L7",
          "addr": 4578
        },
        "L8": {
          "label": "L8",
          "addr": 4501
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *nums, int numsSize) {\n  int max = 0;\n  int sum = 0;\n  for (int i = 0; i < numsSize; i++) {\n    int n = nums[i];\n    if (n > 1) {\n      int flag = 1;\n      for (int j = 2; j * j <= n; j++) {\n        if (n % j == 0) {\n          flag = 0;\n          break;\n        }\n      }\n      if (flag) {\n        max = max > n ? max : n;\n      }\n    }\n  }\n  while (max > 0) {\n    sum += max % 10;\n    max /= 10;\n  }\n  return sum;\n}"
    },
    {
      "task_id": 93,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  lea    0xe8c(%rip),%rax        # 2000 <_fini+0xd78>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    125b <func0+0x102>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x11(%rbp)\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movsbq -0x11(%rbp),%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     11c9 <func0+0x70>\n  movsbl -0x11(%rbp),%eax\n  mov    %eax,%edi\n  call   1070 <toupper@plt>\n  mov    %al,-0x11(%rbp)\n  jmp    11f9 <func0+0xa0>\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movsbq -0x11(%rbp),%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     11f9 <func0+0xa0>\n  movsbl -0x11(%rbp),%eax\n  mov    %eax,%edi\n  call   1080 <tolower@plt>\n  mov    %al,-0x11(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    122d <func0+0xd4>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,-0x11(%rbp)\n  jne    1229 <func0+0xd0>\n  cmpl   $0x9,-0xc(%rbp)\n  jg     1243 <func0+0xea>\n  movzbl -0x11(%rbp),%eax\n  add    $0x2,%eax\n  mov    %al,-0x11(%rbp)\n  jmp    1243 <func0+0xea>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1202 <func0+0xa9>\n  jmp    1244 <func0+0xeb>\n  nop\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x11(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1184 <func0+0x2b>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL8:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x11(%rbp)\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movsbq -0x11(%rbp),%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     L1\n  movsbl -0x11(%rbp),%eax\n  mov    %eax,%edi\n  call   <toupper@plt>\n  mov    %al,-0x11(%rbp)\n  jmp    L2\nL1:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movsbq -0x11(%rbp),%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     L2\n  movsbl -0x11(%rbp),%eax\n  mov    %eax,%edi\n  call   <tolower@plt>\n  mov    %al,-0x11(%rbp)\nL2:\n  movl   $0x0,-0xc(%rbp)\n  jmp    L3\nL6:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,-0x11(%rbp)\n  jne    L4\n  cmpl   $0x9,-0xc(%rbp)\n  jg     L5\n  movzbl -0x11(%rbp),%eax\n  add    $0x2,%eax\n  mov    %al,-0x11(%rbp)\n  jmp    L5\nL4:\n  addl   $0x1,-0xc(%rbp)\nL3:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L6\n  jmp    L7\nL5:\n  nop\nL7:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x11(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L8\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3724
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4699
        },
        "L1": {
          "label": "L1",
          "addr": 4553
        },
        "L2": {
          "label": "L2",
          "addr": 4601
        },
        "L3": {
          "label": "L3",
          "addr": 4653
        },
        "L4": {
          "label": "L4",
          "addr": 4649
        },
        "L5": {
          "label": "L5",
          "addr": 4675
        },
        "L6": {
          "label": "L6",
          "addr": 4610
        },
        "L7": {
          "label": "L7",
          "addr": 4676
        },
        "L8": {
          "label": "L8",
          "addr": 4484
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(const char *s, char *buf) {\n  int i, j;\n  char c;\n  const char *vowels = \"aeiouAEIOU\";\n  for (i = 0; s[i]; i++) {\n    c = s[i];\n    if (((*(const short *)(__ctype_b_loc() + c * 2 + 1)) & 512))\n      c = toupper(c);\n    else if (((*(const short *)(__ctype_b_loc() + c * 2 + 1)) & 256))\n      c = tolower(c);\n    for (j = 0; vowels[j]; j++)\n      if (c == vowels[j]) {\n        if (j < 10)\n          c += 2;\n        break;\n      }\n    buf[i] = c;\n  }\n  buf[i] = 0;\n}"
    },
    {
      "task_id": 94,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1148 <func0+0x4f>\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%edi\n  jmp    1164 <func0+0x6b>\n  test   %edi,%edi\n  jle    114f <func0+0x56>\n  mov    $0x0,%ecx\n  movslq %edi,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edi,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  mov    %edi,%esi\n  sub    %edx,%esi\n  add    %esi,%ecx\n  mov    %edi,%edx\n  mov    %eax,%edi\n  cmp    $0x9,%edx\n  jg     111c <func0+0x23>\n  mov    %ecx,%eax\n  ret\n  mov    $0x0,%ecx\n  jmp    1145 <func0+0x4c>\n  mov    $0x0,%ecx\n  jmp    1145 <func0+0x4c>\n  cmp    %esi,%edi\n  cmovl  %esi,%edi\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  je     1113 <func0+0x1a>\n  mov    (%r8),%esi\n  cmp    $0x1,%esi\n  jle    115b <func0+0x62>\n  cmp    $0x3,%esi\n  jle    1156 <func0+0x5d>\n  test   $0x1,%sil\n  je     115b <func0+0x62>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     1156 <func0+0x5d>\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    117c <func0+0x83>\n  jmp    115b <func0+0x62>",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%edi\n  jmp    L1\nL5:\n  test   %edi,%edi\n  jle    L2\n  mov    $0x0,%ecx\nL3:\n  movslq %edi,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edi,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  mov    %edi,%esi\n  sub    %edx,%esi\n  add    %esi,%ecx\n  mov    %edi,%edx\n  mov    %eax,%edi\n  cmp    $0x9,%edx\n  jg     L3\nL4:\n  mov    %ecx,%eax\n  ret\nL0:\n  mov    $0x0,%ecx\n  jmp    L4\nL2:\n  mov    $0x0,%ecx\n  jmp    L4\nL7:\n  cmp    %esi,%edi\n  cmovl  %esi,%edi\nL6:\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  je     L5\nL1:\n  mov    (%r8),%esi\n  cmp    $0x1,%esi\n  jle    L6\n  cmp    $0x3,%esi\n  jle    L7\n  test   $0x1,%sil\n  je     L6\n  mov    $0x2,%ecx\nL8:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     L7\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L8\n  jmp    L6",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4424
        },
        "L1": {
          "label": "L1",
          "addr": 4452
        },
        "L2": {
          "label": "L2",
          "addr": 4431
        },
        "L3": {
          "label": "L3",
          "addr": 4380
        },
        "L4": {
          "label": "L4",
          "addr": 4421
        },
        "L5": {
          "label": "L5",
          "addr": 4371
        },
        "L6": {
          "label": "L6",
          "addr": 4443
        },
        "L7": {
          "label": "L7",
          "addr": 4438
        },
        "L8": {
          "label": "L8",
          "addr": 4476
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, j, ret = 0;\n  for (i = 0; i < len; i++) {\n    if (arr[i] < 2)\n      continue;\n    if (arr[i] > 3) {\n      if (arr[i] & 1) {\n        for (j = 2; j * j <= arr[i]; j++) {\n          if (arr[i] % j == 0)\n            break;\n        }\n        if (j * j > arr[i])\n          ret = (ret > arr[i]) ? ret : arr[i];\n      }\n    }\n  }\n  for (i = 0; i > 0; i = i / 10)\n    ret += i % 10;\n  return ret;\n}"
    },
    {
      "task_id": 94,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    11a1 <func0+0xa1>\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%r9\n  jmp    1129 <func0+0x29>\n  nopl   0x0(%rax)\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  je     1170 <func0+0x70>\n  mov    (%rdi),%esi\n  cmp    $0x1,%esi\n  jle    1120 <func0+0x20>\n  cmp    $0x3,%esi\n  jle    115d <func0+0x5d>\n  test   $0x1,%sil\n  je     1120 <func0+0x20>\n  mov    $0x2,%ecx\n  jmp    1151 <func0+0x51>\n  nopw   0x0(%rax,%rax,1)\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1120 <func0+0x20>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    1148 <func0+0x48>\n  cmp    %esi,%r8d\n  cmovl  %esi,%r8d\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    1129 <func0+0x29>\n  nopl   (%rax)\n  xor    %r9d,%r9d\n  test   %r8d,%r8d\n  je     119d <func0+0x9d>\n  mov    $0xcccccccd,%ecx\n  nopl   (%rax)\n  mov    %r8d,%eax\n  imul   %rcx,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  sub    %edx,%r8d\n  add    %r8d,%r9d\n  mov    %eax,%r8d\n  test   %eax,%eax\n  jne    1180 <func0+0x80>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%r9\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  je     L2\nL1:\n  mov    (%rdi),%esi\n  cmp    $0x1,%esi\n  jle    L3\n  cmp    $0x3,%esi\n  jle    L4\n  test   $0x1,%sil\n  je     L3\n  mov    $0x2,%ecx\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL6:\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL5:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    L6\nL4:\n  cmp    %esi,%r8d\n  cmovl  %esi,%r8d\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    L1\n  nopl   (%rax)\nL2:\n  xor    %r9d,%r9d\n  test   %r8d,%r8d\n  je     L7\n  mov    $0xcccccccd,%ecx\n  nopl   (%rax)\nL8:\n  mov    %r8d,%eax\n  imul   %rcx,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  sub    %edx,%r8d\n  add    %r8d,%r9d\n  mov    %eax,%r8d\n  test   %eax,%eax\n  jne    L8\nL7:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4513
        },
        "L1": {
          "label": "L1",
          "addr": 4393
        },
        "L2": {
          "label": "L2",
          "addr": 4464
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4445
        },
        "L5": {
          "label": "L5",
          "addr": 4433
        },
        "L6": {
          "label": "L6",
          "addr": 4424
        },
        "L7": {
          "label": "L7",
          "addr": 4509
        },
        "L8": {
          "label": "L8",
          "addr": 4480
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *nums, int numsSize) {\n  int i, j, max = 0, sum = 0;\n  for (i = 0; i < numsSize; i++) {\n    if (nums[i] > 1) {\n      for (j = 2; j * j <= nums[i]; j++) {\n        if (nums[i] % j == 0)\n          goto end;\n      }\n      if (nums[i] > max)\n        max = nums[i];\n    }\n  end:;\n  }\n  while (max) {\n    sum += max % 10;\n    max /= 10;\n  }\n  return sum;\n}"
    },
    {
      "task_id": 94,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    11a1 <func0+0xa1>\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%r9\n  jmp    1129 <func0+0x29>\n  nopl   0x0(%rax)\n  add    $0x4,%rdi\n  cmp    %rdi,%r9\n  je     1170 <func0+0x70>\n  mov    (%rdi),%esi\n  cmp    $0x1,%esi\n  jle    1120 <func0+0x20>\n  cmp    $0x3,%esi\n  jle    115d <func0+0x5d>\n  test   $0x1,%sil\n  je     1120 <func0+0x20>\n  mov    $0x2,%ecx\n  jmp    1151 <func0+0x51>\n  nopw   0x0(%rax,%rax,1)\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1120 <func0+0x20>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    1148 <func0+0x48>\n  cmp    %esi,%r8d\n  cmovl  %esi,%r8d\n  add    $0x4,%rdi\n  cmp    %rdi,%r9\n  jne    1129 <func0+0x29>\n  nopl   (%rax)\n  xor    %r9d,%r9d\n  test   %r8d,%r8d\n  je     119d <func0+0x9d>\n  mov    $0xcccccccd,%ecx\n  nopl   (%rax)\n  mov    %r8d,%eax\n  imul   %rcx,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  sub    %edx,%r8d\n  add    %r8d,%r9d\n  mov    %eax,%r8d\n  test   %eax,%eax\n  jne    1180 <func0+0x80>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%r9\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  add    $0x4,%rdi\n  cmp    %rdi,%r9\n  je     L2\nL1:\n  mov    (%rdi),%esi\n  cmp    $0x1,%esi\n  jle    L3\n  cmp    $0x3,%esi\n  jle    L4\n  test   $0x1,%sil\n  je     L3\n  mov    $0x2,%ecx\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL6:\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL5:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    L6\nL4:\n  cmp    %esi,%r8d\n  cmovl  %esi,%r8d\n  add    $0x4,%rdi\n  cmp    %rdi,%r9\n  jne    L1\n  nopl   (%rax)\nL2:\n  xor    %r9d,%r9d\n  test   %r8d,%r8d\n  je     L7\n  mov    $0xcccccccd,%ecx\n  nopl   (%rax)\nL8:\n  mov    %r8d,%eax\n  imul   %rcx,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  sub    %edx,%r8d\n  add    %r8d,%r9d\n  mov    %eax,%r8d\n  test   %eax,%eax\n  jne    L8\nL7:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4513
        },
        "L1": {
          "label": "L1",
          "addr": 4393
        },
        "L2": {
          "label": "L2",
          "addr": 4464
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4445
        },
        "L5": {
          "label": "L5",
          "addr": 4433
        },
        "L6": {
          "label": "L6",
          "addr": 4424
        },
        "L7": {
          "label": "L7",
          "addr": 4509
        },
        "L8": {
          "label": "L8",
          "addr": 4480
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *nums, int numsSize) {\n  int i, j, max = 0, sum = 0;\n  for (i = 0; i < numsSize; i++) {\n    if (nums[i] > 1) {\n      for (j = 2; j * j <= nums[i]; j++) {\n        if (nums[i] % j == 0)\n          goto end;\n      }\n      if (nums[i] > max)\n        max = nums[i];\n    }\n  end:;\n  }\n  while (max) {\n    sum += max % 10;\n    max /= 10;\n  }\n  return sum;\n}"
    },
    {
      "task_id": 95,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  cmpl   $0x0,-0x2c(%rbp)\n  jne    113c <func0+0x23>\n  mov    $0x0,%eax\n  jmp    1269 <func0+0x150>\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    1258 <func0+0x13f>\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x4,%rax\n  mov    %rax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    123c <func0+0x123>\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  jne    11b6 <func0+0x9d>\n  mov    $0x0,%eax\n  jmp    1269 <func0+0x150>\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     11ed <func0+0xd4>\n  movl   $0x1,-0x14(%rbp)\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     1224 <func0+0x10b>\n  movl   $0x1,-0x18(%rbp)\n  mov    -0x14(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  jne    1238 <func0+0x11f>\n  mov    $0x0,%eax\n  jmp    1269 <func0+0x150>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    117c <func0+0x63>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1156 <func0+0x3d>\n  mov    $0x1,%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  cmpl   $0x0,-0x2c(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L2\nL9:\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x4,%rax\n  mov    %rax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L3\nL8:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  jne    L4\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     L5\n  movl   $0x1,-0x14(%rbp)\nL5:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     L6\n  movl   $0x1,-0x18(%rbp)\nL6:\n  mov    -0x14(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  jne    L7\n  mov    $0x0,%eax\n  jmp    L1\nL7:\n  addl   $0x1,-0xc(%rbp)\nL3:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L8\n  addl   $0x1,-0x10(%rbp)\nL2:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L9\n  mov    $0x1,%eax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4412
        },
        "L1": {
          "label": "L1",
          "addr": 4713
        },
        "L2": {
          "label": "L2",
          "addr": 4696
        },
        "L3": {
          "label": "L3",
          "addr": 4668
        },
        "L4": {
          "label": "L4",
          "addr": 4534
        },
        "L5": {
          "label": "L5",
          "addr": 4589
        },
        "L6": {
          "label": "L6",
          "addr": 4644
        },
        "L7": {
          "label": "L7",
          "addr": 4664
        },
        "L8": {
          "label": "L8",
          "addr": 4476
        },
        "L9": {
          "label": "L9",
          "addr": 4438
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(char *const *pargv, int argc) {\n  if (!argc)\n    return 0;\n  int a = 0, b = 0;\n  for (int i = 0; i < argc; i++) {\n    char *arg = pargv[i];\n    for (int j = 0; arg[j]; j++) {\n      if (!(__ctype_b_loc()[(unsigned char)arg[j]] & (1 << 10)))\n        return 0;\n      if (__ctype_b_loc()[(unsigned char)arg[j]] & (1 << 8))\n        b = 1;\n      if (__ctype_b_loc()[(unsigned char)arg[j]] & (1 << 9))\n        a = 1;\n      if (b + a == 2)\n        return 0;\n    }\n  }\n  return 1;\n}"
    },
    {
      "task_id": 93,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rdi,0x8(%rsp)\n  test   %bl,%bl\n  je     11f7 <func0+0x97>\n  call   1090 <__ctype_b_loc@plt>\n  xor    %r14d,%r14d\n  lea    0xe70(%rip),%r13        # 2000 <_fini+0xddc>\n  mov    %rax,%r12\n  nopl   0x0(%rax,%rax,1)\n  mov    (%r12),%rax\n  movsbq %bl,%r15\n  movzwl (%rax,%r15,2),%eax\n  test   $0x2,%ah\n  je     1210 <func0+0xb0>\n  call   1070 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  xor    %eax,%eax\n  mov    $0x61,%edx\n  jmp    11ce <func0+0x6e>\n  add    $0x1,%rax\n  movzbl 0x0(%r13,%rax,1),%edx\n  test   %dl,%dl\n  je     11dd <func0+0x7d>\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  jne    11c0 <func0+0x60>\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\n  mov    0x8(%rsp),%rax\n  mov    %bl,0x0(%rbp,%r14,1)\n  add    $0x1,%r14\n  movzbl (%rax,%r14,1),%ebx\n  test   %bl,%bl\n  jne    1198 <func0+0x38>\n  add    %r14,%rbp\n  movb   $0x0,0x0(%rbp)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  test   $0x1,%ah\n  je     11b7 <func0+0x57>\n  call   1080 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  jmp    11b7 <func0+0x57>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rdi,0x8(%rsp)\n  test   %bl,%bl\n  je     L0\n  call   <__ctype_b_loc@plt>\n  xor    %r14d,%r14d\n  lea    D0(%rip),%r13\n  mov    %rax,%r12\n  nopl   0x0(%rax,%rax,1)\nL5:\n  mov    (%r12),%rax\n  movsbq %bl,%r15\n  movzwl (%rax,%r15,2),%eax\n  test   $0x2,%ah\n  je     L1\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\nL6:\n  xor    %eax,%eax\n  mov    $0x61,%edx\n  jmp    L2\nL4:\n  add    $0x1,%rax\n  movzbl 0x0(%r13,%rax,1),%edx\n  test   %dl,%dl\n  je     L3\nL2:\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  jne    L4\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\nL3:\n  mov    0x8(%rsp),%rax\n  mov    %bl,0x0(%rbp,%r14,1)\n  add    $0x1,%r14\n  movzbl (%rax,%r14,1),%ebx\n  test   %bl,%bl\n  jne    L5\n  add    %r14,%rbp\nL0:\n  movb   $0x0,0x0(%rbp)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  test   $0x1,%ah\n  je     L6\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  jmp    L6",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3696
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4599
        },
        "L1": {
          "label": "L1",
          "addr": 4624
        },
        "L2": {
          "label": "L2",
          "addr": 4558
        },
        "L3": {
          "label": "L3",
          "addr": 4573
        },
        "L4": {
          "label": "L4",
          "addr": 4544
        },
        "L5": {
          "label": "L5",
          "addr": 4504
        },
        "L6": {
          "label": "L6",
          "addr": 4535
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " void func0(const char *src, char *dst) {\n  int i = 0;\n  int j = 0;\n  char ch = *src;\n  const unsigned short *map;\n  while (ch) {\n    map = __ctype_b_loc();\n    if ((map[ch] & 0x200) != 0) {\n      map = __ctype_toupper_loc();\n      ch = map[0][ch];\n    } else if ((map[ch] & 0x100) != 0) {\n      map = __ctype_tolower_loc();\n      ch = map[0][ch];\n    }\n    for (i = 0, j = 0; \"aeiouAEIOU\"[i] != '\\0'; i++) {\n      if (\"aeiouAEIOU\"[i] == ch) {\n        if (i < 10)\n          ch += 2;\n        break;\n      }\n    }\n    dst[j++] = ch;\n    ch = *(src + j);\n  }\n  dst[j] = '\\0';\n}"
    },
    {
      "task_id": 95,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  test   %esi,%esi\n  je     11e7 <func0+0xce>\n  jle    1188 <func0+0x6f>\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r15\n  lea    -0x1(%rsi),%eax\n  shl    $0x4,%rax\n  lea    0x10(%rdi,%rax,1),%rax\n  mov    %rax,0x8(%rsp)\n  mov    $0x0,%r13d\n  mov    $0x0,%r12d\n  mov    $0x1,%r14d\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     1176 <func0+0x5d>\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  add    $0x1,%rbp\n  jmp    11cd <func0+0xb4>\n  add    $0x10,%r15\n  cmp    0x8(%rsp),%r15\n  jne    115d <func0+0x44>\n  mov    $0x1,%eax\n  jmp    1193 <func0+0x7a>\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    $0x0,%eax\n  jmp    1193 <func0+0x7a>\n  mov    $0x0,%eax\n  jmp    1193 <func0+0x7a>\n  test   $0x2,%ah\n  jne    11a9 <func0+0x90>\n  mov    %r14d,%r13d\n  lea    (%r12,%r13,1),%eax\n  cmp    $0x2,%eax\n  je     11a2 <func0+0x89>\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     1176 <func0+0x5d>\n  movzbl %bl,%ebx\n  movzwl (%rdx,%rbx,2),%eax\n  test   $0x4,%ah\n  je     118e <func0+0x75>\n  test   $0x1,%ah\n  jne    11b0 <func0+0x97>\n  test   $0x2,%ah\n  cmovne %r14d,%r12d\n  jmp    11b8 <func0+0x9f>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r15\n  lea    -0x1(%rsi),%eax\n  shl    $0x4,%rax\n  lea    0x10(%rdi,%rax,1),%rax\n  mov    %rax,0x8(%rsp)\n  mov    $0x0,%r13d\n  mov    $0x0,%r12d\n  mov    $0x1,%r14d\nL4:\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  add    $0x1,%rbp\n  jmp    L3\nL2:\n  add    $0x10,%r15\n  cmp    0x8(%rsp),%r15\n  jne    L4\n  mov    $0x1,%eax\n  jmp    L5\nL1:\n  mov    $0x1,%eax\n  ret\nL8:\n  mov    $0x0,%eax\nL5:\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL7:\n  mov    $0x0,%eax\n  jmp    L5\nL6:\n  mov    $0x0,%eax\n  jmp    L5\nL9:\n  test   $0x2,%ah\n  jne    L6\n  mov    %r14d,%r13d\nL10:\n  lea    (%r12,%r13,1),%eax\n  cmp    $0x2,%eax\n  je     L7\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\nL3:\n  movzbl %bl,%ebx\n  movzwl (%rdx,%rbx,2),%eax\n  test   $0x4,%ah\n  je     L8\n  test   $0x1,%ah\n  jne    L9\n  test   $0x2,%ah\n  cmovne %r14d,%r12d\n  jmp    L10\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4583
        },
        "L1": {
          "label": "L1",
          "addr": 4488
        },
        "L2": {
          "label": "L2",
          "addr": 4470
        },
        "L3": {
          "label": "L3",
          "addr": 4557
        },
        "L4": {
          "label": "L4",
          "addr": 4445
        },
        "L5": {
          "label": "L5",
          "addr": 4499
        },
        "L6": {
          "label": "L6",
          "addr": 4521
        },
        "L7": {
          "label": "L7",
          "addr": 4514
        },
        "L8": {
          "label": "L8",
          "addr": 4494
        },
        "L9": {
          "label": "L9",
          "addr": 4528
        },
        "L10": {
          "label": "L10",
          "addr": 4536
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const unsigned char *__restrict p, int n) {\n  int i, j, k, l;\n  if (n == 0)\n    return 0;\n  for (i = 0; i < n; i++) {\n    const unsigned char *q = p[i];\n    const unsigned short *r = *__ctype_b_loc();\n    for (j = 0; q[j]; j++) {\n      k = r[q[j]];\n      if (!(k & 0x1000))\n        return 0;\n      if (k & 0x2000) {\n        if (k & 0x0100)\n          return 0;\n        if (k & 0x0200)\n          l = 1;\n        else\n          l = 0;\n      } else\n        l = 1;\n      if (j + l == 2)\n        return 0;\n    }\n  }\n  return 1;\n}"
    },
    {
      "task_id": 93,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rdi,0x8(%rsp)\n  test   %bl,%bl\n  je     11f7 <func0+0x97>\n  call   1090 <__ctype_b_loc@plt>\n  xor    %r14d,%r14d\n  lea    0xe70(%rip),%r13        # 2000 <_fini+0xddc>\n  mov    %rax,%r12\n  nopl   0x0(%rax,%rax,1)\n  mov    (%r12),%rax\n  movsbq %bl,%r15\n  movzwl (%rax,%r15,2),%eax\n  test   $0x2,%ah\n  je     1210 <func0+0xb0>\n  call   1070 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  xor    %eax,%eax\n  mov    $0x61,%edx\n  jmp    11ce <func0+0x6e>\n  add    $0x1,%rax\n  movzbl 0x0(%r13,%rax,1),%edx\n  test   %dl,%dl\n  je     11dd <func0+0x7d>\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  jne    11c0 <func0+0x60>\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\n  mov    0x8(%rsp),%rax\n  mov    %bl,0x0(%rbp,%r14,1)\n  add    $0x1,%r14\n  movzbl (%rax,%r14,1),%ebx\n  test   %bl,%bl\n  jne    1198 <func0+0x38>\n  add    %r14,%rbp\n  movb   $0x0,0x0(%rbp)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  test   $0x1,%ah\n  je     11b7 <func0+0x57>\n  call   1080 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  jmp    11b7 <func0+0x57>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rdi,0x8(%rsp)\n  test   %bl,%bl\n  je     L0\n  call   <__ctype_b_loc@plt>\n  xor    %r14d,%r14d\n  lea    D0(%rip),%r13\n  mov    %rax,%r12\n  nopl   0x0(%rax,%rax,1)\nL5:\n  mov    (%r12),%rax\n  movsbq %bl,%r15\n  movzwl (%rax,%r15,2),%eax\n  test   $0x2,%ah\n  je     L1\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\nL6:\n  xor    %eax,%eax\n  mov    $0x61,%edx\n  jmp    L2\nL4:\n  add    $0x1,%rax\n  movzbl 0x0(%r13,%rax,1),%edx\n  test   %dl,%dl\n  je     L3\nL2:\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  jne    L4\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\nL3:\n  mov    0x8(%rsp),%rax\n  mov    %bl,0x0(%rbp,%r14,1)\n  add    $0x1,%r14\n  movzbl (%rax,%r14,1),%ebx\n  test   %bl,%bl\n  jne    L5\n  add    %r14,%rbp\nL0:\n  movb   $0x0,0x0(%rbp)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  test   $0x1,%ah\n  je     L6\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  jmp    L6",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3696
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4599
        },
        "L1": {
          "label": "L1",
          "addr": 4624
        },
        "L2": {
          "label": "L2",
          "addr": 4558
        },
        "L3": {
          "label": "L3",
          "addr": 4573
        },
        "L4": {
          "label": "L4",
          "addr": 4544
        },
        "L5": {
          "label": "L5",
          "addr": 4504
        },
        "L6": {
          "label": "L6",
          "addr": 4535
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " void func0(const char *src, char *dst) {\n  int i = 0;\n  int j = 0;\n  char ch = *src;\n  const unsigned short *map;\n  while (ch) {\n    map = __ctype_b_loc();\n    if ((map[ch] & 0x200) != 0) {\n      map = __ctype_toupper_loc();\n      ch = map[0][ch];\n    } else if ((map[ch] & 0x100) != 0) {\n      map = __ctype_tolower_loc();\n      ch = map[0][ch];\n    }\n    for (i = 0, j = 0; \"aeiouAEIOU\"[i] != '\\0'; i++) {\n      if (\"aeiouAEIOU\"[i] == ch) {\n        if (i < 10)\n          ch += 2;\n        break;\n      }\n    }\n    dst[j++] = ch;\n    ch = *(src + j);\n  }\n  dst[j] = '\\0';\n}"
    },
    {
      "task_id": 93,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     1205 <func0+0xac>\n  mov    %rdi,%r14\n  call   1090 <__ctype_b_loc@plt>\n  mov    %rax,%r15\n  mov    $0x0,%r12d\n  lea    0xe6d(%rip),%rbp        # 2000 <_fini+0xddc>\n  jmp    11c8 <func0+0x6f>\n  test   $0x1,%ah\n  je     11e6 <func0+0x8d>\n  call   1080 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r13,4),%ebx\n  jmp    11e6 <func0+0x8d>\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\n  mov    0x8(%rsp),%rax\n  mov    %bl,(%rax,%r12,1)\n  add    $0x1,%r12\n  movzbl (%r14,%r12,1),%ebx\n  test   %bl,%bl\n  je     120b <func0+0xb2>\n  movsbq %bl,%r13\n  mov    (%r15),%rax\n  movzwl (%rax,%r13,2),%eax\n  test   $0x2,%ah\n  je     1195 <func0+0x3c>\n  call   1070 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r13,4),%ebx\n  mov    $0x0,%eax\n  mov    $0x61,%edx\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  je     11a9 <func0+0x50>\n  add    $0x1,%rax\n  movzbl 0x0(%rbp,%rax,1),%edx\n  test   %dl,%dl\n  jne    11f0 <func0+0x97>\n  jmp    11b2 <func0+0x59>\n  mov    $0x0,%r12d\n  mov    0x8(%rsp),%rax\n  movb   $0x0,(%rax,%r12,1)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%r14\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r15\n  mov    $0x0,%r12d\n  lea    D0(%rip),%rbp\n  jmp    L1\nL4:\n  test   $0x1,%ah\n  je     L2\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r13,4),%ebx\n  jmp    L2\nL5:\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\nL7:\n  mov    0x8(%rsp),%rax\n  mov    %bl,(%rax,%r12,1)\n  add    $0x1,%r12\n  movzbl (%r14,%r12,1),%ebx\n  test   %bl,%bl\n  je     L3\nL1:\n  movsbq %bl,%r13\n  mov    (%r15),%rax\n  movzwl (%rax,%r13,2),%eax\n  test   $0x2,%ah\n  je     L4\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r13,4),%ebx\nL2:\n  mov    $0x0,%eax\n  mov    $0x61,%edx\nL6:\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  je     L5\n  add    $0x1,%rax\n  movzbl 0x0(%rbp,%rax,1),%edx\n  test   %dl,%dl\n  jne    L6\n  jmp    L7\nL0:\n  mov    $0x0,%r12d\nL3:\n  mov    0x8(%rsp),%rax\n  movb   $0x0,(%rax,%r12,1)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3693
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4613
        },
        "L1": {
          "label": "L1",
          "addr": 4552
        },
        "L2": {
          "label": "L2",
          "addr": 4582
        },
        "L3": {
          "label": "L3",
          "addr": 4619
        },
        "L4": {
          "label": "L4",
          "addr": 4501
        },
        "L5": {
          "label": "L5",
          "addr": 4521
        },
        "L6": {
          "label": "L6",
          "addr": 4592
        },
        "L7": {
          "label": "L7",
          "addr": 4530
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " void func0(const char *src, char *dst) {\n  int i = 0;\n  int j = 0;\n  char ch = src[i];\n  while (ch != '\\0') {\n    if (((*(const int *)__ctype_b_loc()) + (unsigned short)ch) & 0x200) {\n      ch = ((*(const int *(*)(void))__ctype_toupper_loc()) + (unsigned short)ch)[0];\n    } else if (((*(const int *)__ctype_b_loc()) + (unsigned short)ch) & 0x100) {\n      ch = ((*(const int *(*)(void))__ctype_tolower_loc()) + (unsigned short)ch)[0];\n    }\n    for (j = 0; \"aeiouAEIOU\"[j] != '\\0'; j++) {\n      if (ch == \"aeiouAEIOU\"[j]) {\n        if (j < 10) {\n          ch = ch + 2;\n        }\n        break;\n      }\n    }\n    dst[i] = ch;\n    i++;\n    ch = src[i];\n  }\n  dst[i] = '\\0';\n}"
    },
    {
      "task_id": 97,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  mov    %edx,%ecx\n  sub    %eax,%ecx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,%esi\n  movslq %esi,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %esi,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%esi\n  mov    %esi,%edx\n  mov    %ecx,%eax\n  imul   %edx,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  mov    %edx,%ecx\n  sub    %eax,%ecx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,%esi\n  movslq %esi,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %esi,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%esi\n  mov    %esi,%edx\n  mov    %ecx,%eax\n  imul   %edx,%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x, int y) {\n  if (x < 0)\n    x = -x;\n  if (y < 0)\n    y = -y;\n  return (x % 10) * (y % 10);\n}"
    },
    {
      "task_id": 97,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  sar    $0x22,%rdx\n  mov    %eax,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%edx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%ecx\n  neg    %ecx\n  cmovs  %esi,%ecx\n  movslq %ecx,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  sar    $0x22,%rdx\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%edx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%ecx\n  imul   %ecx,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  sar    $0x22,%rdx\n  mov    %eax,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%edx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%ecx\n  neg    %ecx\n  cmovs  %esi,%ecx\n  movslq %ecx,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  sar    $0x22,%rdx\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%edx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%ecx\n  imul   %ecx,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x, int y) {\n  int res;\n  res = (abs(x) % 10) * (abs(y) % 10);\n  return res;\n}"
    },
    {
      "task_id": 97,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  mov    $0xcccccccd,%edi\n  mov    %eax,%edx\n  imul   %rdi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%edx\n  neg    %edx\n  cmovs  %esi,%edx\n  mov    %edx,%ecx\n  imul   %rdi,%rcx\n  shr    $0x23,%rcx\n  lea    (%rcx,%rcx,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  imul   %edx,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  mov    $0xcccccccd,%edi\n  mov    %eax,%edx\n  imul   %rdi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%edx\n  neg    %edx\n  cmovs  %esi,%edx\n  mov    %edx,%ecx\n  imul   %rdi,%rcx\n  shr    $0x23,%rcx\n  lea    (%rcx,%rcx,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  imul   %edx,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int x, int y) {\n  int a = x % 10;\n  int b = y % 10;\n  return a * b;\n}"
    },
    {
      "task_id": 97,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  mov    $0xcccccccd,%edi\n  mov    %eax,%edx\n  imul   %rdi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%edx\n  neg    %edx\n  cmovs  %esi,%edx\n  mov    %edx,%ecx\n  imul   %rdi,%rcx\n  shr    $0x23,%rcx\n  lea    (%rcx,%rcx,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  imul   %edx,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  mov    $0xcccccccd,%edi\n  mov    %eax,%edx\n  imul   %rdi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%edx\n  neg    %edx\n  cmovs  %esi,%edx\n  mov    %edx,%ecx\n  imul   %rdi,%rcx\n  shr    $0x23,%rcx\n  lea    (%rcx,%rcx,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  imul   %edx,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int x, int y) {\n  int a = x % 10;\n  int b = y % 10;\n  return a * b;\n}"
    },
    {
      "task_id": 96,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %edi,%ebp\n  mov    %rsi,%rbx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r10\n  movl   $0x0,(%rbx)\n  mov    $0x2,%edi\n  cmp    $0x2,%ebp\n  jg     1166 <func0+0x4d>\n  mov    %r10,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  movslq %r9d,%rax\n  mov    %edi,(%r10,%rax,4)\n  add    $0x1,%r9d\n  mov    %r9d,(%rbx)\n  add    $0x1,%edi\n  cmp    %edi,%ebp\n  je     1147 <func0+0x2e>\n  mov    (%rbx),%r9d\n  mov    %r10,%rsi\n  mov    %r9d,%eax\n  lea    (%r10,%rax,4),%r8\n  test   %r9d,%r9d\n  jle    1151 <func0+0x38>\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     1151 <func0+0x38>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     115f <func0+0x46>\n  add    $0x4,%rsi\n  cmp    %r8,%rsi\n  jne    1178 <func0+0x5f>\n  jmp    1151 <func0+0x38>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %edi,%ebp\n  mov    %rsi,%rbx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  movl   $0x0,(%rbx)\n  mov    $0x2,%edi\n  cmp    $0x2,%ebp\n  jg     L0\nL1:\n  mov    %r10,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL2:\n  movslq %r9d,%rax\n  mov    %edi,(%r10,%rax,4)\n  add    $0x1,%r9d\n  mov    %r9d,(%rbx)\nL3:\n  add    $0x1,%edi\n  cmp    %edi,%ebp\n  je     L1\nL0:\n  mov    (%rbx),%r9d\n  mov    %r10,%rsi\n  mov    %r9d,%eax\n  lea    (%r10,%rax,4),%r8\n  test   %r9d,%r9d\n  jle    L2\nL4:\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     L2\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\n  add    $0x4,%rsi\n  cmp    %r8,%rsi\n  jne    L4\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4454
        },
        "L1": {
          "label": "L1",
          "addr": 4423
        },
        "L2": {
          "label": "L2",
          "addr": 4433
        },
        "L3": {
          "label": "L3",
          "addr": 4447
        },
        "L4": {
          "label": "L4",
          "addr": 4472
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int n, int *ret_sz) {\n  int *ret = malloc(n * sizeof(int));\n  int i, j;\n  *ret_sz = 0;\n  for (i = 2; i < n; i++) {\n    for (j = 0; j < *ret_sz; j++) {\n      if (i % ret[j] == 0)\n        goto cont;\n    }\n    ret[(*ret_sz)++] = i;\n  cont:;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 96,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  movslq %edi,%rdi\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  xor    %r9d,%r9d\n  mov    $0x2,%edi\n  mov    %rax,%r10\n  lea    0x4(%rax),%r11\n  cmp    $0x2,%ebx\n  jle    11b8 <func0+0x98>\n  nopw   0x0(%rax,%rax,1)\n  test   %r9d,%r9d\n  jle    1195 <func0+0x75>\n  lea    -0x1(%r9),%eax\n  mov    %r10,%rsi\n  lea    (%r11,%rax,4),%r8\n  jmp    118a <func0+0x6a>\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     11a4 <func0+0x84>\n  add    $0x4,%rsi\n  cmp    %r8,%rsi\n  je     1195 <func0+0x75>\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1178 <func0+0x58>\n  movslq %r9d,%rax\n  add    $0x1,%r9d\n  mov    %edi,(%r10,%rax,4)\n  mov    %r9d,0x0(%rbp)\n  add    $0x1,%edi\n  cmp    %edi,%ebx\n  je     11b8 <func0+0x98>\n  mov    0x0(%rbp),%r9d\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax)\n  add    $0x8,%rsp\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  movslq %edi,%rdi\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  xor    %r9d,%r9d\n  mov    $0x2,%edi\n  mov    %rax,%r10\n  lea    0x4(%rax),%r11\n  cmp    $0x2,%ebx\n  jle    L0\n  nopw   0x0(%rax,%rax,1)\nL5:\n  test   %r9d,%r9d\n  jle    L1\n  lea    -0x1(%r9),%eax\n  mov    %r10,%rsi\n  lea    (%r11,%rax,4),%r8\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\n  add    $0x4,%rsi\n  cmp    %r8,%rsi\n  je     L1\nL2:\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L4\nL1:\n  movslq %r9d,%rax\n  add    $0x1,%r9d\n  mov    %edi,(%r10,%rax,4)\n  mov    %r9d,0x0(%rbp)\nL3:\n  add    $0x1,%edi\n  cmp    %edi,%ebx\n  je     L0\n  mov    0x0(%rbp),%r9d\n  jmp    L5\n  nopl   0x0(%rax)\nL0:\n  add    $0x8,%rsp\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4536
        },
        "L1": {
          "label": "L1",
          "addr": 4501
        },
        "L2": {
          "label": "L2",
          "addr": 4490
        },
        "L3": {
          "label": "L3",
          "addr": 4516
        },
        "L4": {
          "label": "L4",
          "addr": 4472
        },
        "L5": {
          "label": "L5",
          "addr": 4448
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int n, int *pn) {\n  int *a = (int *)malloc(n * sizeof(int));\n  int i, j;\n  *pn = 0;\n  for (i = 2; i < n; i++) {\n    for (j = 0; j < *pn; j++) {\n      if (a[j] * a[j] > i)\n        break;\n      if (i % a[j] == 0)\n        goto cont;\n    }\n    a[(*pn)++] = i;\n  cont:;\n  }\n  return a;\n}"
    },
    {
      "task_id": 96,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  movslq %edi,%rdi\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  xor    %r9d,%r9d\n  mov    $0x2,%edi\n  mov    %rax,%r10\n  lea    0x4(%rax),%r11\n  cmp    $0x2,%ebx\n  jle    11ab <func0+0x8b>\n  nopw   0x0(%rax,%rax,1)\n  test   %r9d,%r9d\n  je     1195 <func0+0x75>\n  lea    -0x1(%r9),%eax\n  mov    %r10,%rsi\n  lea    (%r11,%rax,4),%r8\n  jmp    118a <func0+0x6a>\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     11a4 <func0+0x84>\n  add    $0x4,%rsi\n  cmp    %rsi,%r8\n  je     1195 <func0+0x75>\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1178 <func0+0x58>\n  movslq %r9d,%rax\n  add    $0x1,%r9d\n  mov    %edi,(%r10,%rax,4)\n  mov    %r9d,0x0(%rbp)\n  add    $0x1,%edi\n  cmp    %edi,%ebx\n  jne    1160 <func0+0x40>\n  add    $0x8,%rsp\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  movslq %edi,%rdi\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  xor    %r9d,%r9d\n  mov    $0x2,%edi\n  mov    %rax,%r10\n  lea    0x4(%rax),%r11\n  cmp    $0x2,%ebx\n  jle    L0\n  nopw   0x0(%rax,%rax,1)\nL5:\n  test   %r9d,%r9d\n  je     L1\n  lea    -0x1(%r9),%eax\n  mov    %r10,%rsi\n  lea    (%r11,%rax,4),%r8\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\n  add    $0x4,%rsi\n  cmp    %rsi,%r8\n  je     L1\nL2:\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L4\nL1:\n  movslq %r9d,%rax\n  add    $0x1,%r9d\n  mov    %edi,(%r10,%rax,4)\n  mov    %r9d,0x0(%rbp)\nL3:\n  add    $0x1,%edi\n  cmp    %edi,%ebx\n  jne    L5\nL0:\n  add    $0x8,%rsp\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4523
        },
        "L1": {
          "label": "L1",
          "addr": 4501
        },
        "L2": {
          "label": "L2",
          "addr": 4490
        },
        "L3": {
          "label": "L3",
          "addr": 4516
        },
        "L4": {
          "label": "L4",
          "addr": 4472
        },
        "L5": {
          "label": "L5",
          "addr": 4448
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int m, int *len) {\n  int *buff = malloc(m * sizeof(int));\n  int i, j;\n  *len = 0;\n  for (i = 2; i < m; i++) {\n    for (j = 0; j < *len; j++) {\n      if (i % buff[j] == 0)\n        break;\n      if (buff[j] * buff[j] > i)\n        break;\n    }\n    if (j == *len) {\n      buff[*len] = i;\n      (*len)++;\n    }\n  }\n  return buff;\n}"
    },
    {
      "task_id": 96,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x2,-0x18(%rbp)\n  jmp    11e8 <func0+0xcf>\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11a5 <func0+0x8c>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     11b2 <func0+0x99>\n  mov    -0x18(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    11a1 <func0+0x88>\n  movl   $0x0,-0x10(%rbp)\n  jmp    11b3 <func0+0x9a>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     1167 <func0+0x4e>\n  jmp    11b3 <func0+0x9a>\n  nop\n  cmpl   $0x0,-0x10(%rbp)\n  je     11e4 <func0+0xcb>\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x30(%rbp),%rax\n  mov    %edx,(%rax)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     1157 <func0+0x3e>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x2,-0x18(%rbp)\n  jmp    L0\nL7:\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L1\nL5:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     L2\n  mov    -0x18(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L3\n  movl   $0x0,-0x10(%rbp)\n  jmp    L4\nL3:\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     L5\n  jmp    L4\nL2:\n  nop\nL4:\n  cmpl   $0x0,-0x10(%rbp)\n  je     L6\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x30(%rbp),%rax\n  mov    %edx,(%rax)\nL6:\n  addl   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     L7\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4584
        },
        "L1": {
          "label": "L1",
          "addr": 4517
        },
        "L2": {
          "label": "L2",
          "addr": 4530
        },
        "L3": {
          "label": "L3",
          "addr": 4513
        },
        "L4": {
          "label": "L4",
          "addr": 4531
        },
        "L5": {
          "label": "L5",
          "addr": 4455
        },
        "L6": {
          "label": "L6",
          "addr": 4580
        },
        "L7": {
          "label": "L7",
          "addr": 4439
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int n, int *ret_sz) {\n  int *ret = malloc(n * sizeof(int));\n  *ret_sz = 0;\n  for (int i = 2; i < n; i++) {\n    int ok = 1;\n    for (int j = 0; j < *ret_sz; j++) {\n      int p = ret[j];\n      if (p * p > i)\n        break;\n      if (i % p == 0) {\n        ok = 0;\n        break;\n      }\n    }\n    if (ok) {\n      ret[*ret_sz] = i;\n      (*ret_sz)++;\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 81,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %esi,%ebp\n  movslq %esi,%rdi\n  shl    $0x3,%rdi\n  call   1050 <malloc@plt>\n  test   %ebp,%ebp\n  jle    1296 <func0+0x17d>\n  mov    %rbx,%rcx\n  mov    %rax,%rdx\n  mov    %ebp,%ebp\n  lea    (%rax,%rbp,8),%rsi\n  movsd  0xed8(%rip),%xmm1        # 2028 <_fini+0xd88>\n  movsd  0xed8(%rip),%xmm2        # 2030 <_fini+0xd90>\n  movsd  0xed8(%rip),%xmm3        # 2038 <_fini+0xd98>\n  jmp    1183 <func0+0x6a>\n  comisd %xmm2,%xmm0\n  jbe    119d <func0+0x84>\n  lea    0xe94(%rip),%rdi        # 2003 <_fini+0xd63>\n  mov    %rdi,(%rdx)\n  add    $0x4,%rcx\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  je     1296 <func0+0x17d>\n  pxor   %xmm0,%xmm0\n  cvtss2sd (%rcx),%xmm0\n  comisd %xmm1,%xmm0\n  jb     1162 <func0+0x49>\n  lea    0xe68(%rip),%rbx        # 2000 <_fini+0xd60>\n  mov    %rbx,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd %xmm3,%xmm0\n  jbe    11af <func0+0x96>\n  lea    0xe5b(%rip),%rbx        # 2005 <_fini+0xd65>\n  mov    %rbx,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe89(%rip),%xmm0        # 2040 <_fini+0xda0>\n  jbe    11c5 <func0+0xac>\n  lea    0xe48(%rip),%rbx        # 2008 <_fini+0xd68>\n  mov    %rbx,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe7b(%rip),%xmm0        # 2048 <_fini+0xda8>\n  jbe    11db <func0+0xc2>\n  lea    0xe35(%rip),%rdi        # 200b <_fini+0xd6b>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe6d(%rip),%xmm0        # 2050 <_fini+0xdb0>\n  jbe    11f1 <func0+0xd8>\n  lea    0xe21(%rip),%rdi        # 200d <_fini+0xd6d>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe5f(%rip),%xmm0        # 2058 <_fini+0xdb8>\n  jbe    120a <func0+0xf1>\n  lea    0xe0e(%rip),%rdi        # 2010 <_fini+0xd70>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe4e(%rip),%xmm0        # 2060 <_fini+0xdc0>\n  jbe    1223 <func0+0x10a>\n  lea    0xdf8(%rip),%rdi        # 2013 <_fini+0xd73>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe3d(%rip),%xmm0        # 2068 <_fini+0xdc8>\n  jbe    123c <func0+0x123>\n  lea    0xde1(%rip),%rdi        # 2015 <_fini+0xd75>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe2c(%rip),%xmm0        # 2070 <_fini+0xdd0>\n  jbe    1255 <func0+0x13c>\n  lea    0xdcb(%rip),%rdi        # 2018 <_fini+0xd78>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe1b(%rip),%xmm0        # 2078 <_fini+0xdd8>\n  jbe    126e <func0+0x155>\n  lea    0xdb5(%rip),%rdi        # 201b <_fini+0xd7b>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe0a(%rip),%xmm0        # 2080 <_fini+0xde0>\n  jbe    1287 <func0+0x16e>\n  lea    0xd9e(%rip),%rbx        # 201d <_fini+0xd7d>\n  mov    %rbx,(%rdx)\n  jmp    1172 <func0+0x59>\n  lea    0xd92(%rip),%rdi        # 2020 <_fini+0xd80>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %esi,%ebp\n  movslq %esi,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  test   %ebp,%ebp\n  jle    L0\n  mov    %rbx,%rcx\n  mov    %rax,%rdx\n  mov    %ebp,%ebp\n  lea    (%rax,%rbp,8),%rsi\n  movsd  D0(%rip),%xmm1\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  jmp    L1\nL3:\n  comisd %xmm2,%xmm0\n  jbe    L2\n  lea    D3(%rip),%rdi\n  mov    %rdi,(%rdx)\nL4:\n  add    $0x4,%rcx\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  je     L0\nL1:\n  pxor   %xmm0,%xmm0\n  cvtss2sd (%rcx),%xmm0\n  comisd %xmm1,%xmm0\n  jb     L3\n  lea    D4(%rip),%rbx\n  mov    %rbx,(%rdx)\n  jmp    L4\nL2:\n  comisd %xmm3,%xmm0\n  jbe    L5\n  lea    D5(%rip),%rbx\n  mov    %rbx,(%rdx)\n  jmp    L4\nL5:\n  comisd D6(%rip),%xmm0\n  jbe    L6\n  lea    D7(%rip),%rbx\n  mov    %rbx,(%rdx)\n  jmp    L4\nL6:\n  comisd D8(%rip),%xmm0\n  jbe    L7\n  lea    D9(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL7:\n  comisd D10(%rip),%xmm0\n  jbe    L8\n  lea    D11(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL8:\n  comisd D12(%rip),%xmm0\n  jbe    L9\n  lea    D13(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL9:\n  comisd D14(%rip),%xmm0\n  jbe    L10\n  lea    D15(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL10:\n  comisd D16(%rip),%xmm0\n  jbe    L11\n  lea    D17(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL11:\n  comisd D18(%rip),%xmm0\n  jbe    L12\n  lea    D19(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL12:\n  comisd D20(%rip),%xmm0\n  jbe    L13\n  lea    D21(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL13:\n  comisd D22(%rip),%xmm0\n  jbe    L14\n  lea    D23(%rip),%rbx\n  mov    %rbx,(%rdx)\n  jmp    L4\nL14:\n  lea    D24(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8232,
          "bias": [
            3800
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8240,
          "bias": [
            3800
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8248,
          "bias": [
            3800
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8195,
          "bias": [
            3732
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8192,
          "bias": [
            3688
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8197,
          "bias": [
            3675
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8256,
          "bias": [
            3721
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8200,
          "bias": [
            3656
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8264,
          "bias": [
            3707
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8203,
          "bias": [
            3637
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 8272,
          "bias": [
            3693
          ]
        },
        "D11": {
          "label": "D11",
          "addr": 8205,
          "bias": [
            3617
          ]
        },
        "D12": {
          "label": "D12",
          "addr": 8280,
          "bias": [
            3679
          ]
        },
        "D13": {
          "label": "D13",
          "addr": 8208,
          "bias": [
            3598
          ]
        },
        "D14": {
          "label": "D14",
          "addr": 8288,
          "bias": [
            3662
          ]
        },
        "D15": {
          "label": "D15",
          "addr": 8211,
          "bias": [
            3576
          ]
        },
        "D16": {
          "label": "D16",
          "addr": 8296,
          "bias": [
            3645
          ]
        },
        "D17": {
          "label": "D17",
          "addr": 8213,
          "bias": [
            3553
          ]
        },
        "D18": {
          "label": "D18",
          "addr": 8304,
          "bias": [
            3628
          ]
        },
        "D19": {
          "label": "D19",
          "addr": 8216,
          "bias": [
            3531
          ]
        },
        "D20": {
          "label": "D20",
          "addr": 8312,
          "bias": [
            3611
          ]
        },
        "D21": {
          "label": "D21",
          "addr": 8219,
          "bias": [
            3509
          ]
        },
        "D22": {
          "label": "D22",
          "addr": 8320,
          "bias": [
            3594
          ]
        },
        "D23": {
          "label": "D23",
          "addr": 8221,
          "bias": [
            3486
          ]
        },
        "D24": {
          "label": "D24",
          "addr": 8224,
          "bias": [
            3474
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4758
        },
        "L1": {
          "label": "L1",
          "addr": 4483
        },
        "L2": {
          "label": "L2",
          "addr": 4509
        },
        "L3": {
          "label": "L3",
          "addr": 4450
        },
        "L4": {
          "label": "L4",
          "addr": 4466
        },
        "L5": {
          "label": "L5",
          "addr": 4527
        },
        "L6": {
          "label": "L6",
          "addr": 4549
        },
        "L7": {
          "label": "L7",
          "addr": 4571
        },
        "L8": {
          "label": "L8",
          "addr": 4593
        },
        "L9": {
          "label": "L9",
          "addr": 4618
        },
        "L10": {
          "label": "L10",
          "addr": 4643
        },
        "L11": {
          "label": "L11",
          "addr": 4668
        },
        "L12": {
          "label": "L12",
          "addr": 4693
        },
        "L13": {
          "label": "L13",
          "addr": 4718
        },
        "L14": {
          "label": "L14",
          "addr": 4743
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "412b004100412d00422b004200422d00432b004300432d00442b004400442d004500000000000000c7293a92cbff0f40d26f5f07ce990d409f3c2cd49a660a4039d6c56d34000840d26f5f07ce9905409f3c2cd49a66024039d6c56d34000040a4dfbe0e9c33fb3f3e7958a835cdf43f71ac8bdb6800f03f48bf7d1d3867e63f2d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2028": {
            "type": "f64",
            "value": 3.9999
          },
          "0x2030": {
            "type": "f64",
            "value": 3.7001
          },
          "0x2038": {
            "type": "f64",
            "value": 3.3001
          },
          "0x2040": {
            "type": "f64[2]",
            "value": [
              3.0001,
              2.7001
            ]
          },
          "0x2048": {
            "type": "f64[2]",
            "value": [
              2.7001,
              2.3001
            ]
          },
          "0x2050": {
            "type": "f64[2]",
            "value": [
              2.3001,
              2.0001
            ]
          },
          "0x2058": {
            "type": "f64[2]",
            "value": [
              2.0001,
              1.7001
            ]
          },
          "0x2060": {
            "type": "f64[2]",
            "value": [
              1.7001,
              1.3001
            ]
          },
          "0x2068": {
            "type": "f64[2]",
            "value": [
              1.3001,
              1.0001
            ]
          },
          "0x2070": {
            "type": "f64[2]",
            "value": [
              1.0001,
              0.7001
            ]
          },
          "0x2078": {
            "type": "f64[2]",
            "value": [
              0.7001,
              0.0001
            ]
          },
          "0x2080": {
            "type": "f64",
            "value": 0.0001
          },
          "0x2000": {
            "type": "string",
            "value": "\"A+\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"A\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"A-\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"B+\""
          },
          "0x200b": {
            "type": "string",
            "value": "\"B\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"B-\""
          },
          "0x2010": {
            "type": "string",
            "value": "\"C+\""
          },
          "0x2013": {
            "type": "string",
            "value": "\"C\""
          },
          "0x2015": {
            "type": "string",
            "value": "\"C-\""
          },
          "0x2018": {
            "type": "string",
            "value": "\"D+\""
          },
          "0x201b": {
            "type": "string",
            "value": "\"D\""
          },
          "0x201d": {
            "type": "string",
            "value": "\"D-\""
          },
          "0x2020": {
            "type": "string",
            "value": "\"E\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(float *array, int n) {\n  char **arr = malloc(n * sizeof(char *));\n  int i;\n  for (i = 0; i < n; i++) {\n    if (array[i] >= 4.0000)\n      arr[i] = \"A+\";\n    else if (array[i] >= 3.7001)\n      arr[i] = \"A\";\n    else if (array[i] >= 3.3001)\n      arr[i] = \"A-\";\n    else if (array[i] >= 3.0001)\n      arr[i] = \"B+\";\n    else if (array[i] >= 2.7001)\n      arr[i] = \"B\";\n    else if (array[i] >= 2.3001)\n      arr[i] = \"B-\";\n    else if (array[i] >= 2.0001)\n      arr[i] = \"C+\";\n    else if (array[i] >= 1.7001)\n      arr[i] = \"C\";\n    else if (array[i] >= 1.3001)\n      arr[i] = \"C-\";\n    else if (array[i] >= 1.0001)\n      arr[i] = \"D+\";\n    else if (array[i] >= 0.7001)\n      arr[i] = \"D\";\n    else if (array[i] >= 0.0001)\n      arr[i] = \"D-\";\n    else\n      arr[i] = \"E\";\n  }\n  return arr;\n}"
    },
    {
      "task_id": 81,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    14d5 <func0+0x3bc>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xeb7(%rip),%xmm0        # 2028 <_fini+0xb40>\n  jb     1196 <func0+0x7d>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xe72(%rip),%rdx        # 2000 <_fini+0xb18>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xe76(%rip),%xmm0        # 2030 <_fini+0xb48>\n  jbe    11df <func0+0xc6>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xe2c(%rip),%rdx        # 2003 <_fini+0xb1b>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xe35(%rip),%xmm0        # 2038 <_fini+0xb50>\n  jbe    1228 <func0+0x10f>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xde5(%rip),%rdx        # 2005 <_fini+0xb1d>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xdf4(%rip),%xmm0        # 2040 <_fini+0xb58>\n  jbe    1271 <func0+0x158>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xd9f(%rip),%rdx        # 2008 <_fini+0xb20>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xdb3(%rip),%xmm0        # 2048 <_fini+0xb60>\n  jbe    12ba <func0+0x1a1>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xd59(%rip),%rdx        # 200b <_fini+0xb23>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xd72(%rip),%xmm0        # 2050 <_fini+0xb68>\n  jbe    1303 <func0+0x1ea>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xd12(%rip),%rdx        # 200d <_fini+0xb25>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xd31(%rip),%xmm0        # 2058 <_fini+0xb70>\n  jbe    134c <func0+0x233>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xccc(%rip),%rdx        # 2010 <_fini+0xb28>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xcf0(%rip),%xmm0        # 2060 <_fini+0xb78>\n  jbe    1395 <func0+0x27c>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xc86(%rip),%rdx        # 2013 <_fini+0xb2b>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xcaf(%rip),%xmm0        # 2068 <_fini+0xb80>\n  jbe    13de <func0+0x2c5>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xc3f(%rip),%rdx        # 2015 <_fini+0xb2d>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xc6e(%rip),%xmm0        # 2070 <_fini+0xb88>\n  jbe    1427 <func0+0x30e>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xbf9(%rip),%rdx        # 2018 <_fini+0xb30>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xc2d(%rip),%xmm0        # 2078 <_fini+0xb90>\n  jbe    146d <func0+0x354>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xbb3(%rip),%rdx        # 201b <_fini+0xb33>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xbef(%rip),%xmm0        # 2080 <_fini+0xb98>\n  jbe    14b3 <func0+0x39a>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xb6f(%rip),%rdx        # 201d <_fini+0xb35>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xb52(%rip),%rdx        # 2020 <_fini+0xb38>\n  mov    %rdx,(%rax)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     114d <func0+0x34>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL14:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D0(%rip),%xmm0\n  jb     L1\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL1:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D2(%rip),%xmm0\n  jbe    L3\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D3(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL3:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D4(%rip),%xmm0\n  jbe    L4\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D5(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL4:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D6(%rip),%xmm0\n  jbe    L5\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D7(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL5:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D8(%rip),%xmm0\n  jbe    L6\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D9(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL6:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D10(%rip),%xmm0\n  jbe    L7\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D11(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL7:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D12(%rip),%xmm0\n  jbe    L8\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D13(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL8:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D14(%rip),%xmm0\n  jbe    L9\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D15(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL9:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D16(%rip),%xmm0\n  jbe    L10\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D17(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL10:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D18(%rip),%xmm0\n  jbe    L11\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D19(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL11:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D20(%rip),%xmm0\n  jbe    L12\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D21(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL12:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D22(%rip),%xmm0\n  jbe    L13\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D23(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL13:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D24(%rip),%rdx\n  mov    %rdx,(%rax)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L14\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8232,
          "bias": [
            3767
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3698
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8240,
          "bias": [
            3702
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8195,
          "bias": [
            3628
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8248,
          "bias": [
            3637
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8197,
          "bias": [
            3557
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8256,
          "bias": [
            3572
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8200,
          "bias": [
            3487
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8264,
          "bias": [
            3507
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8203,
          "bias": [
            3417
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 8272,
          "bias": [
            3442
          ]
        },
        "D11": {
          "label": "D11",
          "addr": 8205,
          "bias": [
            3346
          ]
        },
        "D12": {
          "label": "D12",
          "addr": 8280,
          "bias": [
            3377
          ]
        },
        "D13": {
          "label": "D13",
          "addr": 8208,
          "bias": [
            3276
          ]
        },
        "D14": {
          "label": "D14",
          "addr": 8288,
          "bias": [
            3312
          ]
        },
        "D15": {
          "label": "D15",
          "addr": 8211,
          "bias": [
            3206
          ]
        },
        "D16": {
          "label": "D16",
          "addr": 8296,
          "bias": [
            3247
          ]
        },
        "D17": {
          "label": "D17",
          "addr": 8213,
          "bias": [
            3135
          ]
        },
        "D18": {
          "label": "D18",
          "addr": 8304,
          "bias": [
            3182
          ]
        },
        "D19": {
          "label": "D19",
          "addr": 8216,
          "bias": [
            3065
          ]
        },
        "D20": {
          "label": "D20",
          "addr": 8312,
          "bias": [
            3117
          ]
        },
        "D21": {
          "label": "D21",
          "addr": 8219,
          "bias": [
            2995
          ]
        },
        "D22": {
          "label": "D22",
          "addr": 8320,
          "bias": [
            3055
          ]
        },
        "D23": {
          "label": "D23",
          "addr": 8221,
          "bias": [
            2927
          ]
        },
        "D24": {
          "label": "D24",
          "addr": 8224,
          "bias": [
            2898
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5333
        },
        "L1": {
          "label": "L1",
          "addr": 4502
        },
        "L2": {
          "label": "L2",
          "addr": 5329
        },
        "L3": {
          "label": "L3",
          "addr": 4575
        },
        "L4": {
          "label": "L4",
          "addr": 4648
        },
        "L5": {
          "label": "L5",
          "addr": 4721
        },
        "L6": {
          "label": "L6",
          "addr": 4794
        },
        "L7": {
          "label": "L7",
          "addr": 4867
        },
        "L8": {
          "label": "L8",
          "addr": 4940
        },
        "L9": {
          "label": "L9",
          "addr": 5013
        },
        "L10": {
          "label": "L10",
          "addr": 5086
        },
        "L11": {
          "label": "L11",
          "addr": 5159
        },
        "L12": {
          "label": "L12",
          "addr": 5229
        },
        "L13": {
          "label": "L13",
          "addr": 5299
        },
        "L14": {
          "label": "L14",
          "addr": 4429
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "412b004100412d00422b004200422d00432b004300432d00442b004400442d004500000000000000c7293a92cbff0f40d26f5f07ce990d409f3c2cd49a660a4039d6c56d34000840d26f5f07ce9905409f3c2cd49a66024039d6c56d34000040a4dfbe0e9c33fb3f3e7958a835cdf43f71ac8bdb6800f03f48bf7d1d3867e63f2d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2028": {
            "type": "f64[2]",
            "value": [
              3.9999,
              3.7001
            ]
          },
          "0x2030": {
            "type": "f64[2]",
            "value": [
              3.7001,
              3.3001
            ]
          },
          "0x2038": {
            "type": "f64[2]",
            "value": [
              3.3001,
              3.0001
            ]
          },
          "0x2040": {
            "type": "f64[2]",
            "value": [
              3.0001,
              2.7001
            ]
          },
          "0x2048": {
            "type": "f64[2]",
            "value": [
              2.7001,
              2.3001
            ]
          },
          "0x2050": {
            "type": "f64[2]",
            "value": [
              2.3001,
              2.0001
            ]
          },
          "0x2058": {
            "type": "f64[2]",
            "value": [
              2.0001,
              1.7001
            ]
          },
          "0x2060": {
            "type": "f64[2]",
            "value": [
              1.7001,
              1.3001
            ]
          },
          "0x2068": {
            "type": "f64[2]",
            "value": [
              1.3001,
              1.0001
            ]
          },
          "0x2070": {
            "type": "f64[2]",
            "value": [
              1.0001,
              0.7001
            ]
          },
          "0x2078": {
            "type": "f64[2]",
            "value": [
              0.7001,
              0.0001
            ]
          },
          "0x2080": {
            "type": "f64",
            "value": 0.0001
          },
          "0x2000": {
            "type": "string",
            "value": "\"A+\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"A\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"A-\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"B+\""
          },
          "0x200b": {
            "type": "string",
            "value": "\"B\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"B-\""
          },
          "0x2010": {
            "type": "string",
            "value": "\"C+\""
          },
          "0x2013": {
            "type": "string",
            "value": "\"C\""
          },
          "0x2015": {
            "type": "string",
            "value": "\"C-\""
          },
          "0x2018": {
            "type": "string",
            "value": "\"D+\""
          },
          "0x201b": {
            "type": "string",
            "value": "\"D\""
          },
          "0x201d": {
            "type": "string",
            "value": "\"D-\""
          },
          "0x2020": {
            "type": "string",
            "value": "\"E\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(float *array, int size) {\n  char **result = malloc(size * sizeof(char *));\n  for (int i = 0; i < size; i++) {\n    if (array[i] >= 3.9999) {\n      result[i] = \"A+\";\n    } else if (array[i] > 3.7001) {\n      result[i] = \"A\";\n    } else if (array[i] > 3.3001) {\n      result[i] = \"A-\";\n    } else if (array[i] > 3.0001) {\n      result[i] = \"B+\";\n    } else if (array[i] > 2.7001) {\n      result[i] = \"B\";\n    } else if (array[i] > 2.3001) {\n      result[i] = \"B-\";\n    } else if (array[i] > 2.0001) {\n      result[i] = \"C+\";\n    } else if (array[i] > 1.7001) {\n      result[i] = \"C\";\n    } else if (array[i] > 1.3001) {\n      result[i] = \"C-\";\n    } else if (array[i] > 1.0001) {\n      result[i] = \"D+\";\n    } else if (array[i] > 0.7001) {\n      result[i] = \"D\";\n    } else if (array[i] > 0.0001) {\n      result[i] = \"D-\";\n    } else {\n      result[i] = \"E\";\n    }\n  }\n  return result;\n}"
    },
    {
      "task_id": 98,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    0xeaf(%rip),%rax        # 2000 <_fini+0xe34>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1195 <func0+0x5c>\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     1191 <func0+0x58>\n  addl   $0x1,-0x20(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     11c2 <func0+0x89>\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     1165 <func0+0x2c>\n  mov    -0x20(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL3:\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\n  addl   $0x1,-0x20(%rbp)\nL1:\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L2\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L3\nL2:\n  mov    -0x20(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3759
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4501
        },
        "L1": {
          "label": "L1",
          "addr": 4497
        },
        "L2": {
          "label": "L2",
          "addr": 4546
        },
        "L3": {
          "label": "L3",
          "addr": 4453
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOU\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  const char *vowels = \"AEIOU\";\n  int count = 0;\n  for (int i = 0; s[i] && i * 2 < strlen(s); i++)\n    if (strchr(vowels, s[i * 2]))\n      count++;\n  return count;\n}"
    },
    {
      "task_id": 81,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  call   1050 <malloc@plt>\n  movsd  0xee5(%rip),%xmm1        # 2028 <_fini+0xdc8>\n  test   %ebp,%ebp\n  jle    11cd <func0+0xad>\n  xor    %edx,%edx\n  movsd  0xedb(%rip),%xmm2        # 2030 <_fini+0xdd0>\n  movsd  0xedb(%rip),%xmm3        # 2038 <_fini+0xdd8>\n  lea    0xe9c(%rip),%rsi        # 2000 <_fini+0xda0>\n  lea    0xe98(%rip),%rdi        # 2003 <_fini+0xda3>\n  lea    0xe93(%rip),%r8        # 2005 <_fini+0xda5>\n  lea    0xe8f(%rip),%r9        # 2008 <_fini+0xda8>\n  lea    0xe8b(%rip),%r10        # 200b <_fini+0xdab>\n  pxor   %xmm0,%xmm0\n  mov    %rsi,%rcx\n  cvtss2sd (%rbx,%rdx,4),%xmm0\n  comisd %xmm1,%xmm0\n  jae    11c0 <func0+0xa0>\n  comisd %xmm2,%xmm0\n  mov    %rdi,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd %xmm3,%xmm0\n  mov    %r8,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd 0xe94(%rip),%xmm0        # 2040 <_fini+0xde0>\n  mov    %r9,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd 0xe8f(%rip),%xmm0        # 2048 <_fini+0xde8>\n  mov    %r10,%rcx\n  jbe    11d8 <func0+0xb8>\n  xchg   %ax,%ax\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rbp,%rdx\n  jne    1180 <func0+0x60>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  comisd 0xe70(%rip),%xmm0        # 2050 <_fini+0xdf0>\n  lea    0xe26(%rip),%rcx        # 200d <_fini+0xdad>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe67(%rip),%xmm0        # 2058 <_fini+0xdf8>\n  lea    0xe18(%rip),%rcx        # 2010 <_fini+0xdb0>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe5e(%rip),%xmm0        # 2060 <_fini+0xe00>\n  lea    0xe0a(%rip),%rcx        # 2013 <_fini+0xdb3>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe55(%rip),%xmm0        # 2068 <_fini+0xe08>\n  lea    0xdfb(%rip),%rcx        # 2015 <_fini+0xdb5>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe4c(%rip),%xmm0        # 2070 <_fini+0xe10>\n  lea    0xded(%rip),%rcx        # 2018 <_fini+0xdb8>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe43(%rip),%xmm0        # 2078 <_fini+0xe18>\n  lea    0xddf(%rip),%rcx        # 201b <_fini+0xdbb>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe3a(%rip),%xmm0        # 2080 <_fini+0xe20>\n  lea    0xdd0(%rip),%rcx        # 201d <_fini+0xdbd>\n  lea    0xdcc(%rip),%r11        # 2020 <_fini+0xdc0>\n  cmovbe %r11,%rcx\n  jmp    11c0 <func0+0xa0>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  call   <malloc@plt>\n  movsd  D0(%rip),%xmm1\n  test   %ebp,%ebp\n  jle    L0\n  xor    %edx,%edx\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  lea    D3(%rip),%rsi\n  lea    D4(%rip),%rdi\n  lea    D5(%rip),%r8\n  lea    D6(%rip),%r9\n  lea    D7(%rip),%r10\nL3:\n  pxor   %xmm0,%xmm0\n  mov    %rsi,%rcx\n  cvtss2sd (%rbx,%rdx,4),%xmm0\n  comisd %xmm1,%xmm0\n  jae    L1\n  comisd %xmm2,%xmm0\n  mov    %rdi,%rcx\n  ja     L1\n  comisd %xmm3,%xmm0\n  mov    %r8,%rcx\n  ja     L1\n  comisd D8(%rip),%xmm0\n  mov    %r9,%rcx\n  ja     L1\n  comisd D9(%rip),%xmm0\n  mov    %r10,%rcx\n  jbe    L2\n  xchg   %ax,%ax\nL1:\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rbp,%rdx\n  jne    L3\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  comisd D10(%rip),%xmm0\n  lea    D11(%rip),%rcx\n  ja     L1\n  comisd D12(%rip),%xmm0\n  lea    D13(%rip),%rcx\n  ja     L1\n  comisd D14(%rip),%xmm0\n  lea    D15(%rip),%rcx\n  ja     L1\n  comisd D16(%rip),%xmm0\n  lea    D17(%rip),%rcx\n  ja     L1\n  comisd D18(%rip),%xmm0\n  lea    D19(%rip),%rcx\n  ja     L1\n  comisd D20(%rip),%xmm0\n  lea    D21(%rip),%rcx\n  ja     L1\n  comisd D22(%rip),%xmm0\n  lea    D23(%rip),%rcx\n  lea    D24(%rip),%r11\n  cmovbe %r11,%rcx\n  jmp    L1",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8232,
          "bias": [
            3813
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8240,
          "bias": [
            3803
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8248,
          "bias": [
            3803
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8192,
          "bias": [
            3740
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8195,
          "bias": [
            3736
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8197,
          "bias": [
            3731
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8200,
          "bias": [
            3727
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8203,
          "bias": [
            3723
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8256,
          "bias": [
            3732
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8264,
          "bias": [
            3727
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 8272,
          "bias": [
            3696
          ]
        },
        "D11": {
          "label": "D11",
          "addr": 8205,
          "bias": [
            3622
          ]
        },
        "D12": {
          "label": "D12",
          "addr": 8280,
          "bias": [
            3687
          ]
        },
        "D13": {
          "label": "D13",
          "addr": 8208,
          "bias": [
            3608
          ]
        },
        "D14": {
          "label": "D14",
          "addr": 8288,
          "bias": [
            3678
          ]
        },
        "D15": {
          "label": "D15",
          "addr": 8211,
          "bias": [
            3594
          ]
        },
        "D16": {
          "label": "D16",
          "addr": 8296,
          "bias": [
            3669
          ]
        },
        "D17": {
          "label": "D17",
          "addr": 8213,
          "bias": [
            3579
          ]
        },
        "D18": {
          "label": "D18",
          "addr": 8304,
          "bias": [
            3660
          ]
        },
        "D19": {
          "label": "D19",
          "addr": 8216,
          "bias": [
            3565
          ]
        },
        "D20": {
          "label": "D20",
          "addr": 8312,
          "bias": [
            3651
          ]
        },
        "D21": {
          "label": "D21",
          "addr": 8219,
          "bias": [
            3551
          ]
        },
        "D22": {
          "label": "D22",
          "addr": 8320,
          "bias": [
            3642
          ]
        },
        "D23": {
          "label": "D23",
          "addr": 8221,
          "bias": [
            3536
          ]
        },
        "D24": {
          "label": "D24",
          "addr": 8224,
          "bias": [
            3532
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4557
        },
        "L1": {
          "label": "L1",
          "addr": 4544
        },
        "L2": {
          "label": "L2",
          "addr": 4568
        },
        "L3": {
          "label": "L3",
          "addr": 4480
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "412b004100412d00422b004200422d00432b004300432d00442b004400442d004500000000000000c7293a92cbff0f40d26f5f07ce990d409f3c2cd49a660a4039d6c56d34000840d26f5f07ce9905409f3c2cd49a66024039d6c56d34000040a4dfbe0e9c33fb3f3e7958a835cdf43f71ac8bdb6800f03f48bf7d1d3867e63f2d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2028": {
            "type": "f64",
            "value": 3.9999
          },
          "0x2030": {
            "type": "f64",
            "value": 3.7001
          },
          "0x2038": {
            "type": "f64",
            "value": 3.3001
          },
          "0x2040": {
            "type": "f64[2]",
            "value": [
              3.0001,
              2.7001
            ]
          },
          "0x2048": {
            "type": "f64[2]",
            "value": [
              2.7001,
              2.3001
            ]
          },
          "0x2050": {
            "type": "f64[2]",
            "value": [
              2.3001,
              2.0001
            ]
          },
          "0x2058": {
            "type": "f64[2]",
            "value": [
              2.0001,
              1.7001
            ]
          },
          "0x2060": {
            "type": "f64[2]",
            "value": [
              1.7001,
              1.3001
            ]
          },
          "0x2068": {
            "type": "f64[2]",
            "value": [
              1.3001,
              1.0001
            ]
          },
          "0x2070": {
            "type": "f64[2]",
            "value": [
              1.0001,
              0.7001
            ]
          },
          "0x2078": {
            "type": "f64[2]",
            "value": [
              0.7001,
              0.0001
            ]
          },
          "0x2080": {
            "type": "f64",
            "value": 0.0001
          },
          "0x2000": {
            "type": "string",
            "value": "\"A+\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"A\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"A-\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"B+\""
          },
          "0x200b": {
            "type": "string",
            "value": "\"B\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"B-\""
          },
          "0x2010": {
            "type": "string",
            "value": "\"C+\""
          },
          "0x2013": {
            "type": "string",
            "value": "\"C\""
          },
          "0x2015": {
            "type": "string",
            "value": "\"C-\""
          },
          "0x2018": {
            "type": "string",
            "value": "\"D+\""
          },
          "0x201b": {
            "type": "string",
            "value": "\"D\""
          },
          "0x201d": {
            "type": "string",
            "value": "\"D-\""
          },
          "0x2020": {
            "type": "string",
            "value": "\"E\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(float *array, int size) {\n  char **result = malloc(size * sizeof(char *));\n  int i;\n  for (i = 0; i < size; i++) {\n    if (array[i] >= 3.9999)\n      result[i] = \"A+\";\n    else if (array[i] > 3.7001)\n      result[i] = \"A\";\n    else if (array[i] > 3.3001)\n      result[i] = \"A-\";\n    else if (array[i] > 3.0001)\n      result[i] = \"B+\";\n    else if (array[i] > 2.7001)\n      result[i] = \"B\";\n    else if (array[i] > 2.3001)\n      result[i] = \"B-\";\n    else if (array[i] > 2.0001)\n      result[i] = \"C+\";\n    else if (array[i] > 1.7001)\n      result[i] = \"C\";\n    else if (array[i] > 1.3001)\n      result[i] = \"C-\";\n    else if (array[i] > 1.0001)\n      result[i] = \"D+\";\n    else if (array[i] > 0.7001)\n      result[i] = \"D\";\n    else if (array[i] > 0.0001)\n      result[i] = \"D-\";\n    else\n      result[i] = \"E\";\n  }\n  return result;\n}"
    },
    {
      "task_id": 81,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  call   1050 <malloc@plt>\n  movsd  0xee5(%rip),%xmm1        # 2028 <_fini+0xdc8>\n  test   %ebp,%ebp\n  jle    11cd <func0+0xad>\n  xor    %edx,%edx\n  movsd  0xedb(%rip),%xmm2        # 2030 <_fini+0xdd0>\n  movsd  0xedb(%rip),%xmm3        # 2038 <_fini+0xdd8>\n  lea    0xe9c(%rip),%rsi        # 2000 <_fini+0xda0>\n  lea    0xe98(%rip),%rdi        # 2003 <_fini+0xda3>\n  lea    0xe93(%rip),%r8        # 2005 <_fini+0xda5>\n  lea    0xe8f(%rip),%r9        # 2008 <_fini+0xda8>\n  lea    0xe8b(%rip),%r10        # 200b <_fini+0xdab>\n  pxor   %xmm0,%xmm0\n  mov    %rsi,%rcx\n  cvtss2sd (%rbx,%rdx,4),%xmm0\n  comisd %xmm1,%xmm0\n  jae    11c0 <func0+0xa0>\n  comisd %xmm2,%xmm0\n  mov    %rdi,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd %xmm3,%xmm0\n  mov    %r8,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd 0xe94(%rip),%xmm0        # 2040 <_fini+0xde0>\n  mov    %r9,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd 0xe8f(%rip),%xmm0        # 2048 <_fini+0xde8>\n  mov    %r10,%rcx\n  jbe    11d8 <func0+0xb8>\n  xchg   %ax,%ax\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rbp,%rdx\n  jne    1180 <func0+0x60>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  comisd 0xe70(%rip),%xmm0        # 2050 <_fini+0xdf0>\n  lea    0xe26(%rip),%rcx        # 200d <_fini+0xdad>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe67(%rip),%xmm0        # 2058 <_fini+0xdf8>\n  lea    0xe18(%rip),%rcx        # 2010 <_fini+0xdb0>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe5e(%rip),%xmm0        # 2060 <_fini+0xe00>\n  lea    0xe0a(%rip),%rcx        # 2013 <_fini+0xdb3>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe55(%rip),%xmm0        # 2068 <_fini+0xe08>\n  lea    0xdfb(%rip),%rcx        # 2015 <_fini+0xdb5>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe4c(%rip),%xmm0        # 2070 <_fini+0xe10>\n  lea    0xded(%rip),%rcx        # 2018 <_fini+0xdb8>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe43(%rip),%xmm0        # 2078 <_fini+0xe18>\n  lea    0xddf(%rip),%rcx        # 201b <_fini+0xdbb>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe3a(%rip),%xmm0        # 2080 <_fini+0xe20>\n  lea    0xdd0(%rip),%rcx        # 201d <_fini+0xdbd>\n  lea    0xdcc(%rip),%r11        # 2020 <_fini+0xdc0>\n  cmovbe %r11,%rcx\n  jmp    11c0 <func0+0xa0>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  call   <malloc@plt>\n  movsd  D0(%rip),%xmm1\n  test   %ebp,%ebp\n  jle    L0\n  xor    %edx,%edx\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  lea    D3(%rip),%rsi\n  lea    D4(%rip),%rdi\n  lea    D5(%rip),%r8\n  lea    D6(%rip),%r9\n  lea    D7(%rip),%r10\nL3:\n  pxor   %xmm0,%xmm0\n  mov    %rsi,%rcx\n  cvtss2sd (%rbx,%rdx,4),%xmm0\n  comisd %xmm1,%xmm0\n  jae    L1\n  comisd %xmm2,%xmm0\n  mov    %rdi,%rcx\n  ja     L1\n  comisd %xmm3,%xmm0\n  mov    %r8,%rcx\n  ja     L1\n  comisd D8(%rip),%xmm0\n  mov    %r9,%rcx\n  ja     L1\n  comisd D9(%rip),%xmm0\n  mov    %r10,%rcx\n  jbe    L2\n  xchg   %ax,%ax\nL1:\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rbp,%rdx\n  jne    L3\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  comisd D10(%rip),%xmm0\n  lea    D11(%rip),%rcx\n  ja     L1\n  comisd D12(%rip),%xmm0\n  lea    D13(%rip),%rcx\n  ja     L1\n  comisd D14(%rip),%xmm0\n  lea    D15(%rip),%rcx\n  ja     L1\n  comisd D16(%rip),%xmm0\n  lea    D17(%rip),%rcx\n  ja     L1\n  comisd D18(%rip),%xmm0\n  lea    D19(%rip),%rcx\n  ja     L1\n  comisd D20(%rip),%xmm0\n  lea    D21(%rip),%rcx\n  ja     L1\n  comisd D22(%rip),%xmm0\n  lea    D23(%rip),%rcx\n  lea    D24(%rip),%r11\n  cmovbe %r11,%rcx\n  jmp    L1",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8232,
          "bias": [
            3813
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8240,
          "bias": [
            3803
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8248,
          "bias": [
            3803
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8192,
          "bias": [
            3740
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8195,
          "bias": [
            3736
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8197,
          "bias": [
            3731
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8200,
          "bias": [
            3727
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8203,
          "bias": [
            3723
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8256,
          "bias": [
            3732
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8264,
          "bias": [
            3727
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 8272,
          "bias": [
            3696
          ]
        },
        "D11": {
          "label": "D11",
          "addr": 8205,
          "bias": [
            3622
          ]
        },
        "D12": {
          "label": "D12",
          "addr": 8280,
          "bias": [
            3687
          ]
        },
        "D13": {
          "label": "D13",
          "addr": 8208,
          "bias": [
            3608
          ]
        },
        "D14": {
          "label": "D14",
          "addr": 8288,
          "bias": [
            3678
          ]
        },
        "D15": {
          "label": "D15",
          "addr": 8211,
          "bias": [
            3594
          ]
        },
        "D16": {
          "label": "D16",
          "addr": 8296,
          "bias": [
            3669
          ]
        },
        "D17": {
          "label": "D17",
          "addr": 8213,
          "bias": [
            3579
          ]
        },
        "D18": {
          "label": "D18",
          "addr": 8304,
          "bias": [
            3660
          ]
        },
        "D19": {
          "label": "D19",
          "addr": 8216,
          "bias": [
            3565
          ]
        },
        "D20": {
          "label": "D20",
          "addr": 8312,
          "bias": [
            3651
          ]
        },
        "D21": {
          "label": "D21",
          "addr": 8219,
          "bias": [
            3551
          ]
        },
        "D22": {
          "label": "D22",
          "addr": 8320,
          "bias": [
            3642
          ]
        },
        "D23": {
          "label": "D23",
          "addr": 8221,
          "bias": [
            3536
          ]
        },
        "D24": {
          "label": "D24",
          "addr": 8224,
          "bias": [
            3532
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4557
        },
        "L1": {
          "label": "L1",
          "addr": 4544
        },
        "L2": {
          "label": "L2",
          "addr": 4568
        },
        "L3": {
          "label": "L3",
          "addr": 4480
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "412b004100412d00422b004200422d00432b004300432d00442b004400442d004500000000000000c7293a92cbff0f40d26f5f07ce990d409f3c2cd49a660a4039d6c56d34000840d26f5f07ce9905409f3c2cd49a66024039d6c56d34000040a4dfbe0e9c33fb3f3e7958a835cdf43f71ac8bdb6800f03f48bf7d1d3867e63f2d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2028": {
            "type": "f64",
            "value": 3.9999
          },
          "0x2030": {
            "type": "f64",
            "value": 3.7001
          },
          "0x2038": {
            "type": "f64",
            "value": 3.3001
          },
          "0x2040": {
            "type": "f64[2]",
            "value": [
              3.0001,
              2.7001
            ]
          },
          "0x2048": {
            "type": "f64[2]",
            "value": [
              2.7001,
              2.3001
            ]
          },
          "0x2050": {
            "type": "f64[2]",
            "value": [
              2.3001,
              2.0001
            ]
          },
          "0x2058": {
            "type": "f64[2]",
            "value": [
              2.0001,
              1.7001
            ]
          },
          "0x2060": {
            "type": "f64[2]",
            "value": [
              1.7001,
              1.3001
            ]
          },
          "0x2068": {
            "type": "f64[2]",
            "value": [
              1.3001,
              1.0001
            ]
          },
          "0x2070": {
            "type": "f64[2]",
            "value": [
              1.0001,
              0.7001
            ]
          },
          "0x2078": {
            "type": "f64[2]",
            "value": [
              0.7001,
              0.0001
            ]
          },
          "0x2080": {
            "type": "f64",
            "value": 0.0001
          },
          "0x2000": {
            "type": "string",
            "value": "\"A+\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"A\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"A-\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"B+\""
          },
          "0x200b": {
            "type": "string",
            "value": "\"B\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"B-\""
          },
          "0x2010": {
            "type": "string",
            "value": "\"C+\""
          },
          "0x2013": {
            "type": "string",
            "value": "\"C\""
          },
          "0x2015": {
            "type": "string",
            "value": "\"C-\""
          },
          "0x2018": {
            "type": "string",
            "value": "\"D+\""
          },
          "0x201b": {
            "type": "string",
            "value": "\"D\""
          },
          "0x201d": {
            "type": "string",
            "value": "\"D-\""
          },
          "0x2020": {
            "type": "string",
            "value": "\"E\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(float *array, int size) {\n  char **result = malloc(size * sizeof(char *));\n  int i;\n  for (i = 0; i < size; i++) {\n    if (array[i] >= 3.9999)\n      result[i] = \"A+\";\n    else if (array[i] > 3.7001)\n      result[i] = \"A\";\n    else if (array[i] > 3.3001)\n      result[i] = \"A-\";\n    else if (array[i] > 3.0001)\n      result[i] = \"B+\";\n    else if (array[i] > 2.7001)\n      result[i] = \"B\";\n    else if (array[i] > 2.3001)\n      result[i] = \"B-\";\n    else if (array[i] > 2.0001)\n      result[i] = \"C+\";\n    else if (array[i] > 1.7001)\n      result[i] = \"C\";\n    else if (array[i] > 1.3001)\n      result[i] = \"C-\";\n    else if (array[i] > 1.0001)\n      result[i] = \"D+\";\n    else if (array[i] > 0.7001)\n      result[i] = \"D\";\n    else if (array[i] > 0.0001)\n      result[i] = \"D-\";\n    else\n      result[i] = \"E\";\n  }\n  return result;\n}"
    },
    {
      "task_id": 99,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <atof@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x8(%rbp)\n  pxor   %xmm0,%xmm0\n  comisd -0x8(%rbp),%xmm0\n  jbe    11af <func0+0x56>\n  movsd  -0x8(%rbp),%xmm0\n  movsd  0xe6a(%rip),%xmm1        # 2000 <_fini+0xe28>\n  subsd  %xmm1,%xmm0\n  movq   %xmm0,%rax\n  movq   %rax,%xmm0\n  call   1080 <ceil@plt>\n  cvttsd2si %xmm0,%eax\n  jmp    11d3 <func0+0x7a>\n  movsd  -0x8(%rbp),%xmm1\n  movsd  0xe44(%rip),%xmm0        # 2000 <_fini+0xe28>\n  addsd  %xmm0,%xmm1\n  movq   %xmm1,%rax\n  movq   %rax,%xmm0\n  call   1090 <floor@plt>\n  cvttsd2si %xmm0,%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atof@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x8(%rbp)\n  pxor   %xmm0,%xmm0\n  comisd -0x8(%rbp),%xmm0\n  jbe    L0\n  movsd  -0x8(%rbp),%xmm0\n  movsd  D0(%rip),%xmm1\n  subsd  %xmm1,%xmm0\n  movq   %xmm0,%rax\n  movq   %rax,%xmm0\n  call   <ceil@plt>\n  cvttsd2si %xmm0,%eax\n  jmp    L1\nL0:\n  movsd  -0x8(%rbp),%xmm1\n  movsd  D0(%rip),%xmm0\n  addsd  %xmm0,%xmm1\n  movq   %xmm1,%rax\n  movq   %rax,%xmm0\n  call   <floor@plt>\n  cvttsd2si %xmm0,%eax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3690,
            3652
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4527
        },
        "L1": {
          "label": "L1",
          "addr": 4563
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000000000000e03f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f64",
            "value": 0.5
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  double x = atof(s);\n  if (x < 0.0)\n    return (int)ceil(x - 0.5);\n  else\n    return (int)floor(x + 0.5);\n}"
    },
    {
      "task_id": 100,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  mov    -0x14(%rbp),%edx\n  mov    %edx,(%rax)\n  movl   $0x1,-0xc(%rbp)\n  jmp    1182 <func0+0x69>\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x2,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     114f <func0+0x36>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  mov    -0x14(%rbp),%edx\n  mov    %edx,(%rax)\n  movl   $0x1,-0xc(%rbp)\n  jmp    L0\nL1:\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x2,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L1\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4482
        },
        "L1": {
          "label": "L1",
          "addr": 4431
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = (int *)malloc(n * sizeof(int));\n  a[0] = n;\n  for (int i = 1; i < n; i++)\n    a[i] = a[i - 1] + 2;\n  return a;\n}"
    },
    {
      "task_id": 98,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     119c <func0+0x63>\n  mov    %rdi,%rbp\n  call   1060 <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  mov    $0x0,%ebx\n  mov    $0x0,%r12d\n  lea    0xe95(%rip),%r14        # 2000 <_fini+0xe5c>\n  cmp    %r13,%rbx\n  je     1190 <func0+0x57>\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  jne    116b <func0+0x32>\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x0,%r12d\n  jmp    1190 <func0+0x57>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    %rdi,%rbp\n  call   <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  mov    $0x0,%ebx\n  mov    $0x0,%r12d\n  lea    D0(%rip),%r14\nL2:\n  cmp    %r13,%rbx\n  je     L1\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  jne    L2\nL1:\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  mov    $0x0,%r12d\n  jmp    L1",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3733
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4508
        },
        "L1": {
          "label": "L1",
          "addr": 4496
        },
        "L2": {
          "label": "L2",
          "addr": 4459
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOU\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  int i, cnt = 0;\n  for (i = 0; s[i]; i++) {\n    if (i == strlen(s) + 1)\n      break;\n    if (strchr(\"AEIOU\", s[i]) && strchr(\"AEIOU\", s[i + 1]))\n      cnt++;\n  }\n  return cnt;\n}"
    },
    {
      "task_id": 98,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     11a1 <func0+0x61>\n  mov    %rdi,%rbp\n  xor    %ebx,%ebx\n  lea    0xea3(%rip),%r14        # 2000 <_fini+0xe58>\n  xor    %r12d,%r12d\n  call   1060 <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  jmp    1190 <func0+0x50>\n  xchg   %ax,%ax\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  je     1195 <func0+0x55>\n  cmp    %r13,%rbx\n  jne    1170 <func0+0x30>\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r12d,%r12d\n  jmp    1195 <func0+0x55>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    %rdi,%rbp\n  xor    %ebx,%ebx\n  lea    D0(%rip),%r14\n  xor    %r12d,%r12d\n  call   <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  jmp    L1\n  xchg   %ax,%ax\nL3:\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  je     L2\nL1:\n  cmp    %r13,%rbx\n  jne    L3\nL2:\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  xor    %r12d,%r12d\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3747
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4513
        },
        "L1": {
          "label": "L1",
          "addr": 4496
        },
        "L2": {
          "label": "L2",
          "addr": 4501
        },
        "L3": {
          "label": "L3",
          "addr": 4464
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOU\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  int i, j, k, len, count = 0;\n  char *vowels = \"AEIOU\";\n  for (i = 0; s[i] != '\\0'; i++) {\n    if (i >= strlen(s) / 2)\n      break;\n    if (strchr(vowels, s[i]) != NULL)\n      count++;\n  }\n  return count;\n}"
    },
    {
      "task_id": 98,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     11a1 <func0+0x61>\n  mov    %rdi,%rbp\n  xor    %ebx,%ebx\n  lea    0xea3(%rip),%r14        # 2000 <_fini+0xe58>\n  xor    %r12d,%r12d\n  call   1060 <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  jmp    1190 <func0+0x50>\n  xchg   %ax,%ax\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  je     1195 <func0+0x55>\n  cmp    %rbx,%r13\n  jne    1170 <func0+0x30>\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r12d,%r12d\n  jmp    1195 <func0+0x55>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    %rdi,%rbp\n  xor    %ebx,%ebx\n  lea    D0(%rip),%r14\n  xor    %r12d,%r12d\n  call   <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  jmp    L1\n  xchg   %ax,%ax\nL3:\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  je     L2\nL1:\n  cmp    %rbx,%r13\n  jne    L3\nL2:\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  xor    %r12d,%r12d\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3747
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4513
        },
        "L1": {
          "label": "L1",
          "addr": 4496
        },
        "L2": {
          "label": "L2",
          "addr": 4501
        },
        "L3": {
          "label": "L3",
          "addr": 4464
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOU\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  int i, j, k, len, count = 0;\n  char *vowels = \"AEIOU\";\n  for (i = 0; s[i] != '\\0'; i++) {\n    if (i >= strlen(s) / 2)\n      break;\n    if (strchr(vowels, s[i]) != NULL)\n      count++;\n  }\n  return count;\n}"
    },
    {
      "task_id": 100,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    114e <func0+0x35>\n  mov    %rax,%rdx\n  lea    -0x1(%rbx),%ecx\n  lea    (%rax,%rcx,4),%rsi\n  mov    (%rdx),%ebx\n  lea    0x2(%rbx),%ecx\n  mov    %ecx,0x4(%rdx)\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    113d <func0+0x24>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  mov    %rax,%rdx\n  lea    -0x1(%rbx),%ecx\n  lea    (%rax,%rcx,4),%rsi\nL1:\n  mov    (%rdx),%ebx\n  lea    0x2(%rbx),%ecx\n  mov    %ecx,0x4(%rdx)\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4430
        },
        "L1": {
          "label": "L1",
          "addr": 4413
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = (int *)malloc(n * sizeof(int));\n  a[0] = n;\n  for (int i = 1; i < n; i++)\n    a[i] = a[i - 1] + 2;\n  return a;\n}"
    },
    {
      "task_id": 100,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    115e <func0+0x3e>\n  lea    -0x1(%rbx),%ecx\n  lea    0x4(%rax),%rdx\n  lea    (%rax,%rcx,4),%rcx\n  jmp    1154 <func0+0x34>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x4,%rdx\n  add    $0x2,%ebx\n  mov    %ebx,(%rdx)\n  cmp    %rcx,%rdx\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  lea    -0x1(%rbx),%ecx\n  lea    0x4(%rax),%rdx\n  lea    (%rax,%rcx,4),%rcx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL2:\n  add    $0x4,%rdx\nL1:\n  add    $0x2,%ebx\n  mov    %ebx,(%rdx)\n  cmp    %rcx,%rdx\n  jne    L2\nL0:\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4446
        },
        "L1": {
          "label": "L1",
          "addr": 4436
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = (int *)malloc(n * sizeof(int));\n  int i;\n  a[0] = n;\n  for (i = 1; i < n; i++)\n    a[i] = 2 * i + n;\n  return a;\n}"
    },
    {
      "task_id": 100,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    115f <func0+0x3f>\n  lea    -0x2(%rbx),%ecx\n  lea    0x4(%rax),%rdx\n  lea    0x8(%rax,%rcx,4),%rcx\n  nopw   0x0(%rax,%rax,1)\n  add    $0x2,%ebx\n  add    $0x4,%rdx\n  mov    %ebx,-0x4(%rdx)\n  cmp    %rdx,%rcx\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  lea    -0x2(%rbx),%ecx\n  lea    0x4(%rax),%rdx\n  lea    0x8(%rax,%rcx,4),%rcx\n  nopw   0x0(%rax,%rax,1)\nL1:\n  add    $0x2,%ebx\n  add    $0x4,%rdx\n  mov    %ebx,-0x4(%rdx)\n  cmp    %rdx,%rcx\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4447
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = (int *)malloc(n * sizeof(int));\n  a[0] = n;\n  for (int i = 1; i < n; i++)\n    a[i] = a[i - 1] + 2;\n  return a;\n}"
    },
    {
      "task_id": 102,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jge    1116 <func0+0x1d>\n  mov    $0xffffffff,%eax\n  jmp    1156 <func0+0x5d>\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jne    1138 <func0+0x3f>\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1138 <func0+0x3f>\n  mov    $0xffffffff,%eax\n  jmp    1156 <func0+0x5d>\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1153 <func0+0x5a>\n  mov    -0x8(%rbp),%eax\n  sub    $0x1,%eax\n  jmp    1156 <func0+0x5d>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jge    L0\n  mov    $0xffffffff,%eax\n  jmp    L1\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jne    L2\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L2\n  mov    $0xffffffff,%eax\n  jmp    L1\nL2:\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L3\n  mov    -0x8(%rbp),%eax\n  sub    $0x1,%eax\n  jmp    L1\nL3:\n  mov    -0x8(%rbp),%eax\nL1:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4374
        },
        "L1": {
          "label": "L1",
          "addr": 4438
        },
        "L2": {
          "label": "L2",
          "addr": 4408
        },
        "L3": {
          "label": "L3",
          "addr": 4435
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b) {\n  if (b < a)\n    return -1;\n  if (b == a && b % 2 == 1)\n    return -1;\n  if (b % 2 == 1)\n    return b - 1;\n  return b;\n}"
    },
    {
      "task_id": 99,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  mov    $0x0,%esi\n  call   1050 <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     119b <func0+0x82>\n  addsd  0xec3(%rip),%xmm0        # 2000 <_fini+0xe08>\n  movapd %xmm0,%xmm3\n  movsd  0xed7(%rip),%xmm2        # 2020 <_fini+0xe28>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  movsd  0xeaf(%rip),%xmm4        # 2008 <_fini+0xe10>\n  ucomisd %xmm1,%xmm4\n  jbe    1192 <func0+0x79>\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  movsd  0xe92(%rip),%xmm4        # 2010 <_fini+0xe18>\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  andnpd %xmm0,%xmm2\n  movapd %xmm1,%xmm3\n  orpd   %xmm2,%xmm3\n  cvttsd2si %xmm3,%eax\n  add    $0x8,%rsp\n  ret\n  subsd  0xe5d(%rip),%xmm0        # 2000 <_fini+0xe08>\n  movapd %xmm0,%xmm3\n  movsd  0xe71(%rip),%xmm2        # 2020 <_fini+0xe28>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  movsd  0xe49(%rip),%xmm4        # 2008 <_fini+0xe10>\n  ucomisd %xmm1,%xmm4\n  jbe    11f0 <func0+0xd7>\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  movsd  0xe30(%rip),%xmm4        # 2010 <_fini+0xe18>\n  andpd  %xmm4,%xmm3\n  addsd  %xmm1,%xmm3\n  andnpd %xmm0,%xmm2\n  orpd   %xmm2,%xmm3\n  cvttsd2si %xmm3,%eax\n  jmp    1196 <func0+0x7d>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  mov    $0x0,%esi\n  call   <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     L0\n  addsd  D0(%rip),%xmm0\n  movapd %xmm0,%xmm3\n  movsd  D1(%rip),%xmm2\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  movsd  D2(%rip),%xmm4\n  ucomisd %xmm1,%xmm4\n  jbe    L1\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  movsd  D3(%rip),%xmm4\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  andnpd %xmm0,%xmm2\n  movapd %xmm1,%xmm3\n  orpd   %xmm2,%xmm3\nL1:\n  cvttsd2si %xmm3,%eax\nL3:\n  add    $0x8,%rsp\n  ret\nL0:\n  subsd  D0(%rip),%xmm0\n  movapd %xmm0,%xmm3\n  movsd  D1(%rip),%xmm2\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  movsd  D2(%rip),%xmm4\n  ucomisd %xmm1,%xmm4\n  jbe    L2\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  movsd  D3(%rip),%xmm4\n  andpd  %xmm4,%xmm3\n  addsd  %xmm1,%xmm3\n  andnpd %xmm0,%xmm2\n  orpd   %xmm2,%xmm3\nL2:\n  cvttsd2si %xmm3,%eax\n  jmp    L3",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3779,
            3677
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8224,
          "bias": [
            3799,
            3697
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3759,
            3657
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8208,
          "bias": [
            3730,
            3632
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4507
        },
        "L1": {
          "label": "L1",
          "addr": 4498
        },
        "L2": {
          "label": "L2",
          "addr": 4592
        },
        "L3": {
          "label": "L3",
          "addr": 4502
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000000000000e03f0000000000003043000000000000f03f0000000000000000ffffffffffffff7f0000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f64",
            "value": 0.5
          },
          "0x2020": {
            "type": "byte[8]",
            "value": [
              255,
              255,
              255,
              255,
              255,
              255,
              255,
              127
            ]
          },
          "0x2008": {
            "type": "byte[8]",
            "value": [
              0,
              0,
              0,
              0,
              0,
              0,
              48,
              67
            ]
          },
          "0x2010": {
            "type": "byte[8]",
            "value": [
              0,
              0,
              0,
              0,
              0,
              0,
              240,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  double d = strtod(s, NULL);\n  if (d < 0)\n    return (int)floor(d - 0.5);\n  return (int)floor(d + 0.5);\n}"
    },
    {
      "task_id": 99,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  xor    %esi,%esi\n  call   1050 <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     11b0 <func0+0x90>\n  addsd  0xebf(%rip),%xmm0        # 2000 <_fini+0xdec>\n  movsd  0xed7(%rip),%xmm2        # 2020 <_fini+0xe0c>\n  movsd  0xeb7(%rip),%xmm3        # 2008 <_fini+0xdf4>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  ja     1170 <func0+0x50>\n  cvttsd2si %xmm0,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movsd  0xe8f(%rip),%xmm4        # 2010 <_fini+0xdfc>\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret\n  nopl   0x0(%rax)\n  subsd  0xe48(%rip),%xmm0        # 2000 <_fini+0xdec>\n  movsd  0xe60(%rip),%xmm2        # 2020 <_fini+0xe0c>\n  movsd  0xe40(%rip),%xmm3        # 2008 <_fini+0xdf4>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  jbe    115f <func0+0x3f>\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movapd %xmm0,%xmm3\n  movsd  0xe25(%rip),%xmm4        # 2010 <_fini+0xdfc>\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  andpd  %xmm4,%xmm3\n  addsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  xor    %esi,%esi\n  call   <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     L0\n  addsd  D0(%rip),%xmm0\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  ja     L1\nL2:\n  cvttsd2si %xmm0,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movsd  D3(%rip),%xmm4\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  subsd  D0(%rip),%xmm0\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  jbe    L2\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movapd %xmm0,%xmm3\n  movsd  D3(%rip),%xmm4\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  andpd  %xmm4,%xmm3\n  addsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3775,
            3656
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8224,
          "bias": [
            3799,
            3680
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3767,
            3648
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8208,
          "bias": [
            3727,
            3621
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4528
        },
        "L1": {
          "label": "L1",
          "addr": 4464
        },
        "L2": {
          "label": "L2",
          "addr": 4447
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000000000000e03f0000000000003043000000000000f03f0000000000000000ffffffffffffff7f0000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f64",
            "value": 0.5
          },
          "0x2020": {
            "type": "byte[8]",
            "value": [
              255,
              255,
              255,
              255,
              255,
              255,
              255,
              127
            ]
          },
          "0x2008": {
            "type": "byte[8]",
            "value": [
              0,
              0,
              0,
              0,
              0,
              0,
              48,
              67
            ]
          },
          "0x2010": {
            "type": "byte[8]",
            "value": [
              0,
              0,
              0,
              0,
              0,
              0,
              240,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  double d = strtod(s, NULL);\n  if (d < 0)\n    return (int)floor(d - 0.5);\n  return (int)floor(d + 0.5);\n}"
    },
    {
      "task_id": 102,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     1137 <func0+0x3e>\n  je     111e <func0+0x25>\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\n  mov    $0xffffffff,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     L0\n  je     L1\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\nL1:\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\nL0:\n  mov    $0xffffffff,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4407
        },
        "L1": {
          "label": "L1",
          "addr": 4382
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x, int y) {\n  if (y < x)\n    return -1;\n  if (y == x)\n    return (y % 2 == 1) ? -1 : y;\n  if (y % 2 == 1)\n    return y - 1;\n  return y;\n}"
    },
    {
      "task_id": 99,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  xor    %esi,%esi\n  call   1050 <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     11b0 <func0+0x90>\n  addsd  0xebf(%rip),%xmm0        # 2000 <_fini+0xdec>\n  movsd  0xed7(%rip),%xmm2        # 2020 <_fini+0xe0c>\n  movsd  0xeb7(%rip),%xmm3        # 2008 <_fini+0xdf4>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  ja     1170 <func0+0x50>\n  cvttsd2si %xmm0,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movsd  0xe8f(%rip),%xmm4        # 2010 <_fini+0xdfc>\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret\n  nopl   0x0(%rax)\n  subsd  0xe48(%rip),%xmm0        # 2000 <_fini+0xdec>\n  movsd  0xe60(%rip),%xmm2        # 2020 <_fini+0xe0c>\n  movsd  0xe40(%rip),%xmm3        # 2008 <_fini+0xdf4>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  jbe    115f <func0+0x3f>\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movapd %xmm0,%xmm3\n  movsd  0xe25(%rip),%xmm4        # 2010 <_fini+0xdfc>\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  andpd  %xmm4,%xmm3\n  addsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  xor    %esi,%esi\n  call   <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     L0\n  addsd  D0(%rip),%xmm0\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  ja     L1\nL2:\n  cvttsd2si %xmm0,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movsd  D3(%rip),%xmm4\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  subsd  D0(%rip),%xmm0\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  jbe    L2\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movapd %xmm0,%xmm3\n  movsd  D3(%rip),%xmm4\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  andpd  %xmm4,%xmm3\n  addsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3775,
            3656
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8224,
          "bias": [
            3799,
            3680
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3767,
            3648
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8208,
          "bias": [
            3727,
            3621
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4528
        },
        "L1": {
          "label": "L1",
          "addr": 4464
        },
        "L2": {
          "label": "L2",
          "addr": 4447
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "000000000000e03f0000000000003043000000000000f03f0000000000000000ffffffffffffff7f0000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "f64",
            "value": 0.5
          },
          "0x2020": {
            "type": "byte[8]",
            "value": [
              255,
              255,
              255,
              255,
              255,
              255,
              255,
              127
            ]
          },
          "0x2008": {
            "type": "byte[8]",
            "value": [
              0,
              0,
              0,
              0,
              0,
              0,
              48,
              67
            ]
          },
          "0x2010": {
            "type": "byte[8]",
            "value": [
              0,
              0,
              0,
              0,
              0,
              0,
              240,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *s) {\n  double d = strtod(s, NULL);\n  if (d < 0)\n    return (int)floor(d - 0.5);\n  return (int)floor(d + 0.5);\n}"
    },
    {
      "task_id": 102,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     1140 <func0+0x40>\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    %edi,%esi\n  je     1130 <func0+0x30>\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\n  nopl   0x0(%rax)\n  mov    $0xffffffff,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     L0\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    %edi,%esi\n  je     L1\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0xffffffff,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4400
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b) {\n  if (b < a)\n    return -1;\n  if (b == a) {\n    if (b % 2 == 1)\n      return -1;\n    else\n      return b;\n  }\n  if (b % 2 == 1)\n    return b - 1;\n  return b;\n}"
    },
    {
      "task_id": 102,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     1140 <func0+0x40>\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    %edi,%esi\n  je     1130 <func0+0x30>\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\n  nopl   0x0(%rax)\n  mov    $0xffffffff,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     L0\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    %edi,%esi\n  je     L1\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0xffffffff,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4400
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b) {\n  if (b < a)\n    return -1;\n  if (b == a) {\n    if (b % 2 == 1)\n      return -1;\n    else\n      return b;\n  }\n  if (b % 2 == 1)\n    return b - 1;\n  return b;\n}"
    },
    {
      "task_id": 95,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %esi,%esi\n  je     11f0 <func0+0xd0>\n  jle    11f1 <func0+0xd1>\n  push   %r15\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%r15\n  push   %r14\n  shl    $0x4,%rax\n  xor    %r14d,%r14d\n  push   %r13\n  lea    0x10(%rdi,%rax,1),%rax\n  xor    %r13d,%r13d\n  push   %r12\n  mov    $0x1,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rax,0x8(%rsp)\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     11d8 <func0+0xb8>\n  call   1050 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdx\n  mov    (%rax),%rsi\n  jmp    119c <func0+0x7c>\n  nopl   0x0(%rax,%rax,1)\n  test   %cx,%cx\n  cmovne %r12d,%r13d\n  lea    0x0(%r13,%r14,1),%eax\n  cmp    $0x2,%eax\n  je     11c0 <func0+0xa0>\n  movzbl (%rdx),%ebx\n  add    $0x1,%rdx\n  test   %bl,%bl\n  je     11d8 <func0+0xb8>\n  movzwl (%rsi,%rbx,2),%eax\n  test   $0x4,%ah\n  je     11c0 <func0+0xa0>\n  mov    %eax,%ecx\n  and    $0x200,%cx\n  test   $0x1,%ah\n  je     1180 <func0+0x60>\n  test   %cx,%cx\n  jne    11c0 <func0+0xa0>\n  mov    $0x1,%r14d\n  jmp    1187 <func0+0x67>\n  xchg   %ax,%ax\n  xor    %eax,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  add    $0x10,%r15\n  cmp    %r15,0x8(%rsp)\n  jne    1162 <func0+0x42>\n  mov    $0x1,%eax\n  jmp    11c2 <func0+0xa2>\n  xchg   %ax,%ax\n  ret\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  push   %r15\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%r15\n  push   %r14\n  shl    $0x4,%rax\n  xor    %r14d,%r14d\n  push   %r13\n  lea    0x10(%rdi,%rax,1),%rax\n  xor    %r13d,%r13d\n  push   %r12\n  mov    $0x1,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rax,0x8(%rsp)\nL7:\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdx\n  mov    (%rax),%rsi\n  jmp    L3\n  nopl   0x0(%rax,%rax,1)\nL5:\n  test   %cx,%cx\n  cmovne %r12d,%r13d\nL6:\n  lea    0x0(%r13,%r14,1),%eax\n  cmp    $0x2,%eax\n  je     L4\n  movzbl (%rdx),%ebx\n  add    $0x1,%rdx\n  test   %bl,%bl\n  je     L2\nL3:\n  movzwl (%rsi,%rbx,2),%eax\n  test   $0x4,%ah\n  je     L4\n  mov    %eax,%ecx\n  and    $0x200,%cx\n  test   $0x1,%ah\n  je     L5\n  test   %cx,%cx\n  jne    L4\n  mov    $0x1,%r14d\n  jmp    L6\n  xchg   %ax,%ax\nL4:\n  xor    %eax,%eax\nL8:\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL2:\n  add    $0x10,%r15\n  cmp    %r15,0x8(%rsp)\n  jne    L7\n  mov    $0x1,%eax\n  jmp    L8\n  xchg   %ax,%ax\nL0:\n  ret\nL1:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4592
        },
        "L1": {
          "label": "L1",
          "addr": 4593
        },
        "L2": {
          "label": "L2",
          "addr": 4568
        },
        "L3": {
          "label": "L3",
          "addr": 4508
        },
        "L4": {
          "label": "L4",
          "addr": 4544
        },
        "L5": {
          "label": "L5",
          "addr": 4480
        },
        "L6": {
          "label": "L6",
          "addr": 4487
        },
        "L7": {
          "label": "L7",
          "addr": 4450
        },
        "L8": {
          "label": "L8",
          "addr": 4546
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(char *const *pargv, int n) {\n  int i;\n  int j;\n  int k;\n  int l;\n  int m;\n  int res;\n  if (n == 0)\n    return 0;\n  i = 0;\n  j = 0;\n  k = 0;\n  l = 0;\n  m = 0;\n  res = 0;\n  while (i < n) {\n    j = 0;\n    while ((((unsigned char *)pargv[i])[j]) != (char)0) {\n      if ((((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 2048) != 0) && ((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 512) != 0) && ((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 1024) != 0)) {\n        k = 1;\n        break;\n      }\n      if ((((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 2048) != 0) && ((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 512) != 0) && ((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 1024) == 0)) {\n        l = 1;\n      }\n      if (k == 1)\n        break;\n      if (l == 1)\n        break;\n      j++;\n    }\n    if (k == 1)\n      break;\n    if (l == 1)\n      break;\n    i++;\n  }\n  if (k == 1)\n    res = 1;\n  else\n    res = 0;\n  return res;\n}"
    },
    {
      "task_id": 103,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  lea    0xedc(%rip),%r8        # 2000 <_fini+0xe80>\n  cmp    %esi,%edi\n  jle    112c <func0+0x13>\n  mov    %r8,%rax\n  ret\n  push   %rbx\n  add    %esi,%edi\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  sar    %ebx\n  mov    $0x21,%edi\n  call   1050 <malloc@plt>\n  movb   $0x0,(%rax)\n  movb   $0x0,0x20(%rax)\n  add    $0x1f,%rax\n  mov    %rax,%r8\n  mov    %ebx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,(%rax)\n  mov    %ebx,%ecx\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  add    %ebx,%edx\n  mov    %edx,%ebx\n  sar    %ebx\n  sub    $0x1,%rax\n  cmp    $0x1,%ecx\n  jg     114d <func0+0x34>\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  lea    D0(%rip),%r8\n  cmp    %esi,%edi\n  jle    L0\n  mov    %r8,%rax\n  ret\nL0:\n  push   %rbx\n  add    %esi,%edi\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  sar    %ebx\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  movb   $0x0,(%rax)\n  movb   $0x0,0x20(%rax)\n  add    $0x1f,%rax\nL1:\n  mov    %rax,%r8\n  mov    %ebx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,(%rax)\n  mov    %ebx,%ecx\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  add    %ebx,%edx\n  mov    %edx,%ebx\n  sar    %ebx\n  sub    $0x1,%rax\n  cmp    $0x1,%ecx\n  jg     L1\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3804
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4396
        },
        "L1": {
          "label": "L1",
          "addr": 4429
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "2d3100",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"-1\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int x, int y) {\n  if (x > y)\n    return \"-1\";\n  int z = (x + y) / 2;\n  char *buf = malloc(33);\n  buf[0] = '\\0';\n  buf[32] = '\\0';\n  for (int i = 31; i >= 0; i--) {\n    buf[i] = (z % 2) + '0';\n    z /= 2;\n  }\n  return buf;\n}"
    },
    {
      "task_id": 103,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    113f <func0+0x26>\n  lea    0xec6(%rip),%rax        # 2000 <_fini+0xe2c>\n  jmp    11d2 <func0+0xb9>\n  mov    -0x18(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x10(%rbp)\n  mov    $0x21,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x20,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x10(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x10(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x10(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jg     1185 <func0+0x6c>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x1(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    L0\n  lea    D0(%rip),%rax\n  jmp    L1\nL0:\n  mov    -0x18(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x10(%rbp)\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x20,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\nL2:\n  mov    -0x10(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x10(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x10(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jg     L2\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x1(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3782
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4415
        },
        "L1": {
          "label": "L1",
          "addr": 4562
        },
        "L2": {
          "label": "L2",
          "addr": 4485
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "2d3100",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"-1\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(int x, int y) {\n  if (x > y) {\n    return \"-1\";\n  }\n  int z = (x + y) / 2;\n  char *buf = malloc(33);\n  buf[0] = '\\0';\n  int i = 32;\n  buf[i--] = '\\0';\n  do {\n    buf[i--] = '0' + z % 2;\n    z /= 2;\n  } while (z > 0);\n  return buf + i + 1;\n}"
    },
    {
      "task_id": 95,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %esi,%esi\n  je     11f0 <func0+0xd0>\n  jle    11f1 <func0+0xd1>\n  push   %r15\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%r15\n  push   %r14\n  shl    $0x4,%rax\n  xor    %r14d,%r14d\n  push   %r13\n  lea    0x10(%rdi,%rax,1),%rax\n  xor    %r13d,%r13d\n  push   %r12\n  mov    $0x1,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rax,0x8(%rsp)\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     11d8 <func0+0xb8>\n  call   1050 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdx\n  mov    (%rax),%rsi\n  jmp    119c <func0+0x7c>\n  nopl   0x0(%rax,%rax,1)\n  test   %cx,%cx\n  cmovne %r12d,%r13d\n  lea    0x0(%r13,%r14,1),%eax\n  cmp    $0x2,%eax\n  je     11c0 <func0+0xa0>\n  movzbl (%rdx),%ebx\n  add    $0x1,%rdx\n  test   %bl,%bl\n  je     11d8 <func0+0xb8>\n  movzwl (%rsi,%rbx,2),%eax\n  test   $0x4,%ah\n  je     11c0 <func0+0xa0>\n  mov    %eax,%ecx\n  and    $0x200,%cx\n  test   $0x1,%ah\n  je     1180 <func0+0x60>\n  test   %cx,%cx\n  jne    11c0 <func0+0xa0>\n  mov    $0x1,%r14d\n  jmp    1187 <func0+0x67>\n  xchg   %ax,%ax\n  xor    %eax,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  add    $0x10,%r15\n  cmp    %r15,0x8(%rsp)\n  jne    1162 <func0+0x42>\n  mov    $0x1,%eax\n  jmp    11c2 <func0+0xa2>\n  xchg   %ax,%ax\n  ret\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  push   %r15\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%r15\n  push   %r14\n  shl    $0x4,%rax\n  xor    %r14d,%r14d\n  push   %r13\n  lea    0x10(%rdi,%rax,1),%rax\n  xor    %r13d,%r13d\n  push   %r12\n  mov    $0x1,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rax,0x8(%rsp)\nL7:\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdx\n  mov    (%rax),%rsi\n  jmp    L3\n  nopl   0x0(%rax,%rax,1)\nL5:\n  test   %cx,%cx\n  cmovne %r12d,%r13d\nL6:\n  lea    0x0(%r13,%r14,1),%eax\n  cmp    $0x2,%eax\n  je     L4\n  movzbl (%rdx),%ebx\n  add    $0x1,%rdx\n  test   %bl,%bl\n  je     L2\nL3:\n  movzwl (%rsi,%rbx,2),%eax\n  test   $0x4,%ah\n  je     L4\n  mov    %eax,%ecx\n  and    $0x200,%cx\n  test   $0x1,%ah\n  je     L5\n  test   %cx,%cx\n  jne    L4\n  mov    $0x1,%r14d\n  jmp    L6\n  xchg   %ax,%ax\nL4:\n  xor    %eax,%eax\nL8:\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL2:\n  add    $0x10,%r15\n  cmp    %r15,0x8(%rsp)\n  jne    L7\n  mov    $0x1,%eax\n  jmp    L8\n  xchg   %ax,%ax\nL0:\n  ret\nL1:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4592
        },
        "L1": {
          "label": "L1",
          "addr": 4593
        },
        "L2": {
          "label": "L2",
          "addr": 4568
        },
        "L3": {
          "label": "L3",
          "addr": 4508
        },
        "L4": {
          "label": "L4",
          "addr": 4544
        },
        "L5": {
          "label": "L5",
          "addr": 4480
        },
        "L6": {
          "label": "L6",
          "addr": 4487
        },
        "L7": {
          "label": "L7",
          "addr": 4450
        },
        "L8": {
          "label": "L8",
          "addr": 4546
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(char *const *pargv, int n) {\n  int i;\n  int j;\n  int k;\n  int l;\n  int m;\n  int res;\n  if (n == 0)\n    return 0;\n  i = 0;\n  j = 0;\n  k = 0;\n  l = 0;\n  m = 0;\n  res = 0;\n  while (i < n) {\n    j = 0;\n    while ((((unsigned char *)pargv[i])[j]) != (char)0) {\n      if ((((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 2048) != 0) && ((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 512) != 0) && ((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 1024) != 0)) {\n        k = 1;\n        break;\n      }\n      if ((((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 2048) != 0) && ((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 512) != 0) && ((((unsigned short *)((unsigned char *)__ctype_b_loc()))[((unsigned char)(pargv[i])[j])] & 1024) == 0)) {\n        l = 1;\n      }\n      if (k == 1)\n        break;\n      if (l == 1)\n        break;\n      j++;\n    }\n    if (k == 1)\n      break;\n    if (l == 1)\n      break;\n    i++;\n  }\n  if (k == 1)\n    res = 1;\n  else\n    res = 0;\n  return res;\n}"
    },
    {
      "task_id": 101,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    $0x50,%edi\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  call   10b0 <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r14\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     12b0 <func0+0x110>\n  add    $0x1,%rbx\n  xor    %ebp,%ebp\n  xor    %r15d,%r15d\n  mov    $0xa,%r13d\n  jmp    1215 <func0+0x75>\n  nopw   0x0(%rax,%rax,1)\n  movslq %ebp,%rdx\n  add    $0x1,%ebp\n  mov    %al,(%r14,%rdx,1)\n  movzbl (%rbx),%eax\n  add    $0x1,%rbx\n  test   %al,%al\n  je     1268 <func0+0xc8>\n  cmp    $0x20,%al\n  je     121d <func0+0x7d>\n  cmp    $0x2c,%al\n  jne    1200 <func0+0x60>\n  test   %ebp,%ebp\n  je     120a <func0+0x6a>\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  movb   $0x0,(%r14,%rbp,1)\n  lea    0x1(%r15),%ebp\n  call   10d0 <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  movslq %ebp,%r15\n  xor    %ebp,%ebp\n  cmp    %r13d,%r15d\n  jl     120a <func0+0x6a>\n  add    %r13d,%r13d\n  mov    %r12,%rdi\n  add    $0x1,%rbx\n  movslq %r13d,%rsi\n  shl    $0x3,%rsi\n  call   10c0 <realloc@plt>\n  mov    %rax,%r12\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  jne    1215 <func0+0x75>\n  nopl   0x0(%rax)\n  test   %ebp,%ebp\n  jne    1290 <func0+0xf0>\n  mov    %r14,%rdi\n  call   1090 <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  lea    0x1(%r15),%ebx\n  movb   $0x0,(%r14,%rbp,1)\n  call   10d0 <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  mov    %ebx,%r15d\n  jmp    126c <func0+0xcc>\n  nopl   (%rax)\n  xor    %r15d,%r15d\n  jmp    126c <func0+0xcc>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    $0x50,%edi\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  call   <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rbx\n  xor    %ebp,%ebp\n  xor    %r15d,%r15d\n  mov    $0xa,%r13d\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL4:\n  movslq %ebp,%rdx\n  add    $0x1,%ebp\n  mov    %al,(%r14,%rdx,1)\nL5:\n  movzbl (%rbx),%eax\n  add    $0x1,%rbx\n  test   %al,%al\n  je     L2\nL1:\n  cmp    $0x20,%al\n  je     L3\n  cmp    $0x2c,%al\n  jne    L4\nL3:\n  test   %ebp,%ebp\n  je     L5\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  movb   $0x0,(%r14,%rbp,1)\n  lea    0x1(%r15),%ebp\n  call   <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  movslq %ebp,%r15\n  xor    %ebp,%ebp\n  cmp    %r13d,%r15d\n  jl     L5\n  add    %r13d,%r13d\n  mov    %r12,%rdi\n  add    $0x1,%rbx\n  movslq %r13d,%rsi\n  shl    $0x3,%rsi\n  call   <realloc@plt>\n  mov    %rax,%r12\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  jne    L1\n  nopl   0x0(%rax)\nL2:\n  test   %ebp,%ebp\n  jne    L6\nL7:\n  mov    %r14,%rdi\n  call   <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\nL6:\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  lea    0x1(%r15),%ebx\n  movb   $0x0,(%r14,%rbp,1)\n  call   <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  mov    %ebx,%r15d\n  jmp    L7\n  nopl   (%rax)\nL0:\n  xor    %r15d,%r15d\n  jmp    L7",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4784
        },
        "L1": {
          "label": "L1",
          "addr": 4629
        },
        "L2": {
          "label": "L2",
          "addr": 4712
        },
        "L3": {
          "label": "L3",
          "addr": 4637
        },
        "L4": {
          "label": "L4",
          "addr": 4608
        },
        "L5": {
          "label": "L5",
          "addr": 4618
        },
        "L6": {
          "label": "L6",
          "addr": 4752
        },
        "L7": {
          "label": "L7",
          "addr": 4716
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(const char *str, int *argcp) {\n  char **argv = malloc(10 * sizeof(char *));\n  char *tmp = malloc(strlen(str) + 1);\n  int i = 0, j = 0, k = 0, n = 10;\n  for (; str[i]; i++) {\n    if (str[i] == ' ' || str[i] == ',') {\n      if (j) {\n        tmp[j] = '\\0';\n        argv[k++] = strdup(tmp);\n        j = 0;\n        if (k >= n) {\n          n *= 2;\n          argv = realloc(argv, n * sizeof(char *));\n        }\n      }\n    } else {\n      tmp[j++] = str[i];\n    }\n  }\n  if (j) {\n    tmp[j] = '\\0';\n    argv[k++] = strdup(tmp);\n  }\n  free(tmp);\n  *argcp = k;\n  return argv;\n}"
    },
    {
      "task_id": 103,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    %esi,%edi\n  jle    1138 <func0+0x18>\n  lea    0xed1(%rip),%r8        # 2000 <_fini+0xe74>\n  mov    %r8,%rax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  add    %esi,%edi\n  push   %rbx\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  mov    $0x21,%edi\n  call   1050 <malloc@plt>\n  sar    %ebx\n  movb   $0x0,(%rax)\n  add    $0x1f,%rax\n  movb   $0x0,0x1(%rax)\n  nopl   0x0(%rax)\n  mov    %ebx,%ecx\n  mov    %rax,%r8\n  sub    $0x1,%rax\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rax)\n  mov    %ebx,%edx\n  mov    %ecx,%ebx\n  add    %edx,%ebx\n  sar    %ebx\n  cmp    $0x1,%edx\n  jg     1160 <func0+0x40>\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    %esi,%edi\n  jle    L0\n  lea    D0(%rip),%r8\n  mov    %r8,%rax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  add    %esi,%edi\n  push   %rbx\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  sar    %ebx\n  movb   $0x0,(%rax)\n  add    $0x1f,%rax\n  movb   $0x0,0x1(%rax)\n  nopl   0x0(%rax)\nL1:\n  mov    %ebx,%ecx\n  mov    %rax,%r8\n  sub    $0x1,%rax\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rax)\n  mov    %ebx,%edx\n  mov    %ecx,%ebx\n  add    %edx,%ebx\n  sar    %ebx\n  cmp    $0x1,%edx\n  jg     L1\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3793
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4448
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "2d3100",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"-1\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int x, int y) {\n  if (x > y) {\n    return \"-1\";\n  }\n  int z = x + y;\n  char *buf = malloc(33);\n  buf[0] = '\\0';\n  buf[32] = '\\0';\n  int i = 31;\n  while (z > 1) {\n    buf[i--] = '0' + z % 2;\n    z /= 2;\n  }\n  return buf;\n}"
    },
    {
      "task_id": 101,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  movl   $0xa,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  add    $0x1,%rax\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    12cd <func0+0x134>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     1228 <func0+0x8f>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    12a0 <func0+0x107>\n  cmpl   $0x0,-0x28(%rbp)\n  jle    12c8 <func0+0x12f>\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strdup@plt>\n  mov    %rax,(%rbx)\n  movl   $0x0,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     12c8 <func0+0x12f>\n  shll   -0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10c0 <realloc@plt>\n  mov    %rax,-0x20(%rbp)\n  jmp    12c8 <func0+0x12f>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x28(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x28(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  jmp    12c9 <func0+0x130>\n  nop\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1200 <func0+0x67>\n  cmpl   $0x0,-0x28(%rbp)\n  jle    1325 <func0+0x18c>\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strdup@plt>\n  mov    %rax,(%rbx)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  movl   $0xa,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  add    $0x1,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L0\nL5:\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L1\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    L2\nL1:\n  cmpl   $0x0,-0x28(%rbp)\n  jle    L3\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,(%rbx)\n  movl   $0x0,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L3\n  shll   -0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x20(%rbp)\n  jmp    L3\nL2:\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x28(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x28(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  jmp    L4\nL3:\n  nop\nL4:\n  addl   $0x1,-0x24(%rbp)\nL0:\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L5\n  cmpl   $0x0,-0x28(%rbp)\n  jle    L6\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,(%rbx)\nL6:\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4813
        },
        "L1": {
          "label": "L1",
          "addr": 4648
        },
        "L2": {
          "label": "L2",
          "addr": 4768
        },
        "L3": {
          "label": "L3",
          "addr": 4808
        },
        "L4": {
          "label": "L4",
          "addr": 4809
        },
        "L5": {
          "label": "L5",
          "addr": 4608
        },
        "L6": {
          "label": "L6",
          "addr": 4901
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char *str, int *argcp) {\n  int argc = 10;\n  char **argv = malloc(argc * sizeof(char *));\n  char *tmp = malloc(strlen(str) + 1);\n  int tmpi = 0;\n  int i = 0;\n  for (int j = 0; str[j] != '\\0'; j++) {\n    if (str[j] == ' ' || str[j] == ',') {\n      if (i > 0) {\n        tmp[i] = '\\0';\n        argv[tmpi++] = strdup(tmp);\n        i = 0;\n        if (tmpi >= argc) {\n          argc *= 2;\n          argv = realloc(argv, argc * sizeof(char *));\n        }\n      }\n      continue;\n    }\n    tmp[i++] = str[j];\n  }\n  if (i > 0) {\n    tmp[i] = '\\0';\n    argv[tmpi++] = strdup(tmp);\n  }\n  free(tmp);\n  *argcp = tmpi;\n  return argv;\n}"
    },
    {
      "task_id": 103,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    %esi,%edi\n  jle    1138 <func0+0x18>\n  lea    0xed1(%rip),%r8        # 2000 <_fini+0xe74>\n  mov    %r8,%rax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  add    %esi,%edi\n  push   %rbx\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  mov    $0x21,%edi\n  call   1050 <malloc@plt>\n  sar    %ebx\n  movb   $0x0,(%rax)\n  add    $0x1f,%rax\n  movb   $0x0,0x1(%rax)\n  nopl   0x0(%rax)\n  mov    %ebx,%ecx\n  mov    %rax,%r8\n  sub    $0x1,%rax\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rax)\n  mov    %ebx,%edx\n  mov    %ecx,%ebx\n  add    %edx,%ebx\n  sar    %ebx\n  cmp    $0x1,%edx\n  jg     1160 <func0+0x40>\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    %esi,%edi\n  jle    L0\n  lea    D0(%rip),%r8\n  mov    %r8,%rax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  add    %esi,%edi\n  push   %rbx\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  sar    %ebx\n  movb   $0x0,(%rax)\n  add    $0x1f,%rax\n  movb   $0x0,0x1(%rax)\n  nopl   0x0(%rax)\nL1:\n  mov    %ebx,%ecx\n  mov    %rax,%r8\n  sub    $0x1,%rax\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rax)\n  mov    %ebx,%edx\n  mov    %ecx,%ebx\n  add    %edx,%ebx\n  sar    %ebx\n  cmp    $0x1,%edx\n  jg     L1\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3793
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4448
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "2d3100",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"-1\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int x, int y) {\n  if (x > y) {\n    return \"-1\";\n  }\n  int z = x + y;\n  char *buf = malloc(33);\n  buf[0] = '\\0';\n  buf[32] = '\\0';\n  int i = 31;\n  while (z > 1) {\n    buf[i--] = '0' + z % 2;\n    z /= 2;\n  }\n  return buf;\n}"
    },
    {
      "task_id": 101,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    $0x50,%edi\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  call   10b0 <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r14\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     12b0 <func0+0x110>\n  add    $0x1,%rbx\n  xor    %ebp,%ebp\n  xor    %r15d,%r15d\n  mov    $0xa,%r13d\n  jmp    1215 <func0+0x75>\n  nopw   0x0(%rax,%rax,1)\n  movslq %ebp,%rdx\n  add    $0x1,%ebp\n  mov    %al,(%r14,%rdx,1)\n  movzbl (%rbx),%eax\n  add    $0x1,%rbx\n  test   %al,%al\n  je     1268 <func0+0xc8>\n  cmp    $0x20,%al\n  je     121d <func0+0x7d>\n  cmp    $0x2c,%al\n  jne    1200 <func0+0x60>\n  test   %ebp,%ebp\n  je     120a <func0+0x6a>\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  movb   $0x0,(%r14,%rbp,1)\n  lea    0x1(%r15),%ebp\n  call   10d0 <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  movslq %ebp,%r15\n  xor    %ebp,%ebp\n  cmp    %r13d,%r15d\n  jl     120a <func0+0x6a>\n  add    %r13d,%r13d\n  mov    %r12,%rdi\n  add    $0x1,%rbx\n  movslq %r13d,%rsi\n  shl    $0x3,%rsi\n  call   10c0 <realloc@plt>\n  mov    %rax,%r12\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  jne    1215 <func0+0x75>\n  nopl   0x0(%rax)\n  test   %ebp,%ebp\n  jne    1290 <func0+0xf0>\n  mov    %r14,%rdi\n  call   1090 <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  lea    0x1(%r15),%ebx\n  movb   $0x0,(%r14,%rbp,1)\n  call   10d0 <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  mov    %ebx,%r15d\n  jmp    126c <func0+0xcc>\n  nopl   (%rax)\n  xor    %r15d,%r15d\n  jmp    126c <func0+0xcc>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    $0x50,%edi\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  call   <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rbx\n  xor    %ebp,%ebp\n  xor    %r15d,%r15d\n  mov    $0xa,%r13d\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL4:\n  movslq %ebp,%rdx\n  add    $0x1,%ebp\n  mov    %al,(%r14,%rdx,1)\nL5:\n  movzbl (%rbx),%eax\n  add    $0x1,%rbx\n  test   %al,%al\n  je     L2\nL1:\n  cmp    $0x20,%al\n  je     L3\n  cmp    $0x2c,%al\n  jne    L4\nL3:\n  test   %ebp,%ebp\n  je     L5\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  movb   $0x0,(%r14,%rbp,1)\n  lea    0x1(%r15),%ebp\n  call   <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  movslq %ebp,%r15\n  xor    %ebp,%ebp\n  cmp    %r13d,%r15d\n  jl     L5\n  add    %r13d,%r13d\n  mov    %r12,%rdi\n  add    $0x1,%rbx\n  movslq %r13d,%rsi\n  shl    $0x3,%rsi\n  call   <realloc@plt>\n  mov    %rax,%r12\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  jne    L1\n  nopl   0x0(%rax)\nL2:\n  test   %ebp,%ebp\n  jne    L6\nL7:\n  mov    %r14,%rdi\n  call   <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\nL6:\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  lea    0x1(%r15),%ebx\n  movb   $0x0,(%r14,%rbp,1)\n  call   <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  mov    %ebx,%r15d\n  jmp    L7\n  nopl   (%rax)\nL0:\n  xor    %r15d,%r15d\n  jmp    L7",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4784
        },
        "L1": {
          "label": "L1",
          "addr": 4629
        },
        "L2": {
          "label": "L2",
          "addr": 4712
        },
        "L3": {
          "label": "L3",
          "addr": 4637
        },
        "L4": {
          "label": "L4",
          "addr": 4608
        },
        "L5": {
          "label": "L5",
          "addr": 4618
        },
        "L6": {
          "label": "L6",
          "addr": 4752
        },
        "L7": {
          "label": "L7",
          "addr": 4716
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(const char *str, int *argcp) {\n  char **argv = malloc(10 * sizeof(char *));\n  char *tmp = malloc(strlen(str) + 1);\n  int i = 0, j = 0, k = 0, n = 10;\n  for (; str[i]; i++) {\n    if (str[i] == ' ' || str[i] == ',') {\n      if (j) {\n        tmp[j] = '\\0';\n        argv[k++] = strdup(tmp);\n        j = 0;\n        if (k >= n) {\n          n *= 2;\n          argv = realloc(argv, n * sizeof(char *));\n        }\n      }\n    } else {\n      tmp[j++] = str[i];\n    }\n  }\n  if (j) {\n    tmp[j] = '\\0';\n    argv[k++] = strdup(tmp);\n  }\n  free(tmp);\n  *argcp = k;\n  return argv;\n}"
    },
    {
      "task_id": 101,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,0x8(%rsp)\n  mov    $0x50,%edi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r13\n  mov    %rbx,%rdi\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r12\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     12a0 <func0+0x107>\n  add    $0x1,%rbx\n  mov    $0x0,%edx\n  mov    $0x0,%ebp\n  mov    $0xa,%r15d\n  jmp    120b <func0+0x72>\n  movslq %edx,%rcx\n  mov    %al,(%r12,%rcx,1)\n  lea    0x1(%rdx),%edx\n  add    $0x1,%rbx\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  je     125c <func0+0xc3>\n  cmp    $0x20,%al\n  je     1213 <func0+0x7a>\n  cmp    $0x2c,%al\n  jne    11f5 <func0+0x5c>\n  test   %edx,%edx\n  jle    11ff <func0+0x66>\n  movslq %edx,%rdx\n  movb   $0x0,(%r12,%rdx,1)\n  lea    0x1(%rbp),%r14d\n  mov    %r12,%rdi\n  call   10d0 <strdup@plt>\n  movslq %ebp,%rbp\n  mov    %rax,0x0(%r13,%rbp,8)\n  mov    %r14d,%ebp\n  mov    $0x0,%edx\n  cmp    %r15d,%r14d\n  jl     11ff <func0+0x66>\n  add    %r15d,%r15d\n  movslq %r15d,%rsi\n  shl    $0x3,%rsi\n  mov    %r13,%rdi\n  call   10c0 <realloc@plt>\n  mov    %rax,%r13\n  mov    $0x0,%edx\n  jmp    11ff <func0+0x66>\n  test   %edx,%edx\n  jg     1281 <func0+0xe8>\n  mov    %r12,%rdi\n  call   1090 <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %ebp,(%rax)\n  mov    %r13,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  movslq %edx,%rdx\n  movb   $0x0,(%r12,%rdx,1)\n  lea    0x1(%rbp),%ebx\n  mov    %r12,%rdi\n  call   10d0 <strdup@plt>\n  movslq %ebp,%rbp\n  mov    %rax,0x0(%r13,%rbp,8)\n  mov    %ebx,%ebp\n  jmp    1260 <func0+0xc7>\n  mov    $0x0,%ebp\n  jmp    1260 <func0+0xc7>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,0x8(%rsp)\n  mov    $0x50,%edi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r12\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rbx\n  mov    $0x0,%edx\n  mov    $0x0,%ebp\n  mov    $0xa,%r15d\n  jmp    L1\nL4:\n  movslq %edx,%rcx\n  mov    %al,(%r12,%rcx,1)\n  lea    0x1(%rdx),%edx\nL5:\n  add    $0x1,%rbx\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  je     L2\nL1:\n  cmp    $0x20,%al\n  je     L3\n  cmp    $0x2c,%al\n  jne    L4\nL3:\n  test   %edx,%edx\n  jle    L5\n  movslq %edx,%rdx\n  movb   $0x0,(%r12,%rdx,1)\n  lea    0x1(%rbp),%r14d\n  mov    %r12,%rdi\n  call   <strdup@plt>\n  movslq %ebp,%rbp\n  mov    %rax,0x0(%r13,%rbp,8)\n  mov    %r14d,%ebp\n  mov    $0x0,%edx\n  cmp    %r15d,%r14d\n  jl     L5\n  add    %r15d,%r15d\n  movslq %r15d,%rsi\n  shl    $0x3,%rsi\n  mov    %r13,%rdi\n  call   <realloc@plt>\n  mov    %rax,%r13\n  mov    $0x0,%edx\n  jmp    L5\nL2:\n  test   %edx,%edx\n  jg     L6\nL7:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %ebp,(%rax)\n  mov    %r13,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL6:\n  movslq %edx,%rdx\n  movb   $0x0,(%r12,%rdx,1)\n  lea    0x1(%rbp),%ebx\n  mov    %r12,%rdi\n  call   <strdup@plt>\n  movslq %ebp,%rbp\n  mov    %rax,0x0(%r13,%rbp,8)\n  mov    %ebx,%ebp\n  jmp    L7\nL0:\n  mov    $0x0,%ebp\n  jmp    L7",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4768
        },
        "L1": {
          "label": "L1",
          "addr": 4619
        },
        "L2": {
          "label": "L2",
          "addr": 4700
        },
        "L3": {
          "label": "L3",
          "addr": 4627
        },
        "L4": {
          "label": "L4",
          "addr": 4597
        },
        "L5": {
          "label": "L5",
          "addr": 4607
        },
        "L6": {
          "label": "L6",
          "addr": 4737
        },
        "L7": {
          "label": "L7",
          "addr": 4704
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char *str, int *argcp) {\n  char **argv = malloc(10 * sizeof(char *));\n  char *buf = malloc(strlen(str) + 1);\n  int argc = 0;\n  int buf_len = 0;\n  int buf_max = 10;\n  int i;\n  for (i = 0; str[i]; i++) {\n    if (str[i] == ' ' || str[i] == ',') {\n      if (buf_len > 0) {\n        buf[buf_len] = '\\0';\n        argv[argc++] = strdup(buf);\n        if (argc >= buf_max) {\n          buf_max *= 2;\n          argv = realloc(argv, buf_max * sizeof(char *));\n        }\n      }\n      buf_len = 0;\n    } else {\n      buf[buf_len++] = str[i];\n    }\n  }\n  if (buf_len > 0) {\n    buf[buf_len] = '\\0';\n    argv[argc++] = strdup(buf);\n  }\n  free(buf);\n  *argcp = argc;\n  return argv;\n}"
    },
    {
      "task_id": 91,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     11d0 <func0+0xb0>\n  mov    %rdi,%rbp\n  call   1050 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  mov    (%rax),%r9\n  mov    $0x1,%edx\n  movabs $0x8000400200000000,%r11\n  mov    $0x1,%r10d\n  jmp    118b <func0+0x6b>\n  cmp    $0x1,%esi\n  sbb    $0xffffffff,%r8d\n  test   %al,%al\n  jne    11c0 <func0+0xa0>\n  xor    %esi,%esi\n  cmp    $0x3f,%bl\n  ja     1180 <func0+0x60>\n  mov    %r11,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r10d,%edx\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     11b5 <func0+0x95>\n  cmp    $0x49,%bl\n  movsbq %bl,%rcx\n  sete   %al\n  and    %edx,%eax\n  testb  $0x20,0x1(%r9,%rcx,2)\n  jne    1160 <func0+0x40>\n  xor    %edx,%edx\n  test   %al,%al\n  je     116b <func0+0x4b>\n  mov    $0x1,%esi\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    118b <func0+0x6b>\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nop\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  jmp    11aa <func0+0x8a>\n  nopl   0x0(%rax)\n  add    $0x8,%rsp\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  mov    (%rax),%r9\n  mov    $0x1,%edx\n  movabs $0x8000400200000000,%r11\n  mov    $0x1,%r10d\n  jmp    L1\nL5:\n  cmp    $0x1,%esi\n  sbb    $0xffffffff,%r8d\n  test   %al,%al\n  jne    L2\nL6:\n  xor    %esi,%esi\n  cmp    $0x3f,%bl\n  ja     L3\n  mov    %r11,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r10d,%edx\nL3:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     L4\nL1:\n  cmp    $0x49,%bl\n  movsbq %bl,%rcx\n  sete   %al\n  and    %edx,%eax\n  testb  $0x20,0x1(%r9,%rcx,2)\n  jne    L5\n  xor    %edx,%edx\n  test   %al,%al\n  je     L6\n  mov    $0x1,%esi\nL7:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    L1\nL4:\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nop\nL2:\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  jmp    L7\n  nopl   0x0(%rax)\nL0:\n  add    $0x8,%rsp\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4560
        },
        "L1": {
          "label": "L1",
          "addr": 4491
        },
        "L2": {
          "label": "L2",
          "addr": 4544
        },
        "L3": {
          "label": "L3",
          "addr": 4480
        },
        "L4": {
          "label": "L4",
          "addr": 4533
        },
        "L5": {
          "label": "L5",
          "addr": 4448
        },
        "L6": {
          "label": "L6",
          "addr": 4459
        },
        "L7": {
          "label": "L7",
          "addr": 4522
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(const char *s) {\n  int state = 0;\n  int count = 0;\n  const unsigned char *_s = (const unsigned char *)s;\n  unsigned char c;\n  unsigned int i;\n  unsigned int __cil_tmp3;\n  unsigned int __cil_tmp4;\n  unsigned int __cil_tmp5;\n  unsigned int __cil_tmp6;\n  unsigned int __cil_tmp7;\n  unsigned int __cil_tmp8;\n  unsigned int __cil_tmp9;\n  unsigned int __cil_tmp10;\n  unsigned int __cil_tmp11;\n  unsigned int __cil_tmp12;\n  unsigned int __cil_tmp13;\n  unsigned int __cil_tmp14;\n  unsigned int __cil_tmp15;\n  unsigned int __cil_tmp16;\n  unsigned int __cil_tmp17;\n  unsigned int __cil_tmp18;\n  unsigned int __cil_tmp19;\n  unsigned int __cil_tmp20;\n  unsigned int __cil_tmp21;\n  unsigned int __cil_tmp22;\n  unsigned int __cil_tmp23;\n  unsigned int __cil_tmp24;\n  unsigned int __cil_tmp25;\n  unsigned int __cil_tmp26;\n  unsigned int __cil_tmp27;\n  unsigned int __cil_tmp28;\n  unsigned int __cil_tmp29;\n  unsigned int __cil_tmp30;\n  unsigned int __cil_tmp31;\n  unsigned int __cil_tmp32;\n  unsigned int __cil_tmp33;\n  unsigned int __cil_tmp34;\n  unsigned int __cil_tmp35;\n  unsigned int __cil_tmp36;\n  unsigned int __cil_tmp37;\n  unsigned int __cil_tmp38;\n  unsigned int __cil_tmp39;\n  unsigned int __cil_tmp40;\n  unsigned int __cil_tmp41;\n  unsigned int __cil_tmp42;\n  unsigned int __cil_tmp43;\n  unsigned int __cil_tmp44;\n  unsigned int __cil_tmp45;\n  unsigned int __cil_tmp46;\n  unsigned int __cil_tmp47;\n  unsigned int __cil_tmp48;\n  unsigned int __cil_tmp49;\n  unsigned int __cil_tmp50;\n  unsigned int __cil_tmp51;\n  unsigned int __cil_tmp52;\n  unsigned int __cil_tmp53;\n  unsigned int __cil_tmp54;\n  unsigned int __cil_tmp55;\n  unsigned int __cil_tmp56;\n  unsigned int __cil_tmp57;\n  unsigned int __cil_tmp58;\n  unsigned int __cil_tmp59;\n  unsigned int __cil_tmp60;\n  unsigned int __cil_tmp61;\n  unsigned int __cil_tmp62;\n  unsigned int __cil_tmp63;\n  unsigned int __cil_tmp64;\n  unsigned int __cil_tmp65;\n  unsigned int __cil_tmp66;\n  unsigned int __cil_tmp67;\n  unsigned int __cil_tmp68;\n  unsigned int __cil_tmp69;\n  unsigned int __cil_tmp70;\n  unsigned int __cil_tmp71;\n  unsigned int __cil_tmp72;\n  unsigned int __cil_tmp73;\n  unsigned int __cil_tmp74;\n  unsigned int __cil_tmp75;\n  unsigned int __cil_tmp76;\n  unsigned int __cil_tmp77;\n  unsigned int __cil_tmp78;\n  unsigned int __cil_tmp79;\n  unsigned int __cil_tmp80;\n  unsigned int __cil_tmp81;\n  unsigned int __cil_tmp82;\n  unsigned int __cil_tmp83;\n  unsigned int __cil"
    },
    {
      "task_id": 106,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  jmp    11a6 <func0+0x8d>\n  mov    -0xc(%rbp),%eax\n  add    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  imul   -0xc(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    1189 <func0+0x70>\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x10(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    11a2 <func0+0x89>\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    1154 <func0+0x3b>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  jmp    L0\nL3:\n  mov    -0xc(%rbp),%eax\n  add    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  imul   -0xc(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x10(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    L2\nL1:\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    L3\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4518
        },
        "L1": {
          "label": "L1",
          "addr": 4489
        },
        "L2": {
          "label": "L2",
          "addr": 4514
        },
        "L3": {
          "label": "L3",
          "addr": 4436
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = malloc(n * sizeof(int));\n  int i, s0 = 0, s1 = 1;\n  for (i = 1; i <= n; i++) {\n    s0 += i;\n    s1 *= i;\n    if (i % 2 == 0)\n      a[i - 1] = s1;\n    else\n      a[i - 1] = s0;\n  }\n  return a;\n}"
    },
    {
      "task_id": 104,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r13\n  mov    %esi,%r12d\n  mov    %rdx,%rbx\n  mov    %rcx,%rbp\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,(%rbx)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    1208 <func0+0xef>\n  mov    %r13,%rsi\n  lea    -0x1(%r12),%eax\n  lea    0x4(%r13,%rax,4),%r8\n  jmp    118b <func0+0x72>\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    1197 <func0+0x7e>\n  mov    %eax,%edx\n  test   $0x1,%dl\n  jne    1161 <func0+0x48>\n  add    $0x4,%rsi\n  cmp    %rsi,%r8\n  je     11a7 <func0+0x8e>\n  mov    (%rsi),%edi\n  test   %edi,%edi\n  jle    1195 <func0+0x7c>\n  mov    %edi,%edx\n  jmp    117d <func0+0x64>\n  je     1182 <func0+0x69>\n  movslq 0x0(%rbp),%rdx\n  mov    (%rbx),%rax\n  mov    %edi,(%rax,%rdx,4)\n  addl   $0x1,0x0(%rbp)\n  jmp    1182 <func0+0x69>\n  cmpl   $0x1,0x0(%rbp)\n  jle    1208 <func0+0xef>\n  mov    $0x0,%r8d\n  jmp    11f1 <func0+0xd8>\n  add    $0x1,%ecx\n  mov    %r8d,%edx\n  not    %edx\n  add    0x0(%rbp),%edx\n  cmp    %ecx,%edx\n  jle    11e2 <func0+0xc9>\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rax,1),%rdi\n  mov    (%rdi),%esi\n  add    $0x4,%rax\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%esi\n  jle    11b5 <func0+0x9c>\n  mov    %edx,(%rdi)\n  mov    (%rbx),%rdx\n  mov    %esi,(%rdx,%rax,1)\n  jmp    11b5 <func0+0x9c>\n  add    $0x1,%r8d\n  mov    0x0(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %r8d,%eax\n  jle    1208 <func0+0xef>\n  mov    0x0(%rbp),%edx\n  sub    %r8d,%edx\n  mov    $0x0,%eax\n  mov    $0x0,%ecx\n  cmp    $0x1,%edx\n  jg     11c4 <func0+0xab>\n  jmp    11e2 <func0+0xc9>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r13\n  mov    %esi,%r12d\n  mov    %rdx,%rbx\n  mov    %rcx,%rbp\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    L0\n  mov    %r13,%rsi\n  lea    -0x1(%r12),%eax\n  lea    0x4(%r13,%rax,4),%r8\n  jmp    L1\nL3:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    L2\n  mov    %eax,%edx\nL6:\n  test   $0x1,%dl\n  jne    L3\nL7:\n  add    $0x4,%rsi\n  cmp    %rsi,%r8\n  je     L4\nL1:\n  mov    (%rsi),%edi\n  test   %edi,%edi\n  jle    L5\n  mov    %edi,%edx\n  jmp    L6\nL5:\n  je     L7\nL2:\n  movslq 0x0(%rbp),%rdx\n  mov    (%rbx),%rax\n  mov    %edi,(%rax,%rdx,4)\n  addl   $0x1,0x0(%rbp)\n  jmp    L7\nL4:\n  cmpl   $0x1,0x0(%rbp)\n  jle    L0\n  mov    $0x0,%r8d\n  jmp    L8\nL10:\n  add    $0x1,%ecx\n  mov    %r8d,%edx\n  not    %edx\n  add    0x0(%rbp),%edx\n  cmp    %ecx,%edx\n  jle    L9\nL11:\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rax,1),%rdi\n  mov    (%rdi),%esi\n  add    $0x4,%rax\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%esi\n  jle    L10\n  mov    %edx,(%rdi)\n  mov    (%rbx),%rdx\n  mov    %esi,(%rdx,%rax,1)\n  jmp    L10\nL9:\n  add    $0x1,%r8d\n  mov    0x0(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %r8d,%eax\n  jle    L0\nL8:\n  mov    0x0(%rbp),%edx\n  sub    %r8d,%edx\n  mov    $0x0,%eax\n  mov    $0x0,%ecx\n  cmp    $0x1,%edx\n  jg     L11\n  jmp    L9\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4616
        },
        "L1": {
          "label": "L1",
          "addr": 4491
        },
        "L2": {
          "label": "L2",
          "addr": 4503
        },
        "L3": {
          "label": "L3",
          "addr": 4449
        },
        "L4": {
          "label": "L4",
          "addr": 4519
        },
        "L5": {
          "label": "L5",
          "addr": 4501
        },
        "L6": {
          "label": "L6",
          "addr": 4477
        },
        "L7": {
          "label": "L7",
          "addr": 4482
        },
        "L8": {
          "label": "L8",
          "addr": 4593
        },
        "L9": {
          "label": "L9",
          "addr": 4578
        },
        "L10": {
          "label": "L10",
          "addr": 4533
        },
        "L11": {
          "label": "L11",
          "addr": 4548
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int **ret, int *ret_size) {\n  *ret = (int *)malloc(n * sizeof(int));\n  *ret_size = 0;\n  for (int i = 0; i < n; i++) {\n    int t = x[i];\n    while (t > 0) {\n      if (t % 10 == 0) {\n        (*ret)[(*ret_size)] = x[i];\n        (*ret_size)++;\n        break;\n      }\n      t /= 10;\n    }\n  }\n  for (int i = 0; i < *ret_size - 1; i++) {\n    for (int j = 0; j < *ret_size - i - 1; j++) {\n      if ((*ret)[j] > (*ret)[j + 1]) {\n        int t = (*ret)[j];\n        (*ret)[j] = (*ret)[j + 1];\n        (*ret)[j + 1] = t;\n      }\n    }\n  }\n}"
    },
    {
      "task_id": 106,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  test   %ebx,%ebx\n  jle    115d <func0+0x44>\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%ecx\n  add    %edx,%ecx\n  imul   %edx,%esi\n  test   $0x1,%dl\n  mov    %esi,%edi\n  cmovne %ecx,%edi\n  mov    %edi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %r8,%rdx\n  jne    1143 <func0+0x2a>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%ecx\nL1:\n  add    %edx,%ecx\n  imul   %edx,%esi\n  test   $0x1,%dl\n  mov    %esi,%edi\n  cmovne %ecx,%edi\n  mov    %edi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %r8,%rdx\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4445
        },
        "L1": {
          "label": "L1",
          "addr": 4419
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = malloc(n * sizeof(int));\n  int i = 0;\n  int j = 1;\n  for (i = 0; i < n; i++) {\n    if (i % 2)\n      a[i] = i + j;\n    else\n      a[i] = i * j;\n  }\n  return a;\n}"
    },
    {
      "task_id": 104,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %rcx,-0x40(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x40(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x14(%rbp)\n  jmp    121a <func0+0x101>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  movb   $0x0,-0x15(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jne    11bc <func0+0xa3>\n  movb   $0x1,-0x15(%rbp)\n  jmp    11bc <func0+0xa3>\n  mov    -0x10(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    119c <func0+0x83>\n  movb   $0x1,-0x15(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x10(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jle    11cd <func0+0xb4>\n  movzbl -0x15(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  jne    118e <func0+0x75>\n  movzbl -0x15(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     1216 <func0+0xfd>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x40(%rbp),%rax\n  mov    %edx,(%rax)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1165 <func0+0x4c>\n  movl   $0x0,-0xc(%rbp)\n  jmp    12f0 <func0+0x1d7>\n  movl   $0x0,-0x8(%rbp)\n  jmp    12d7 <func0+0x1be>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    12d3 <func0+0x1ba>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  sub    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x8(%rbp)\n  jl     123e <func0+0x125>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     1232 <func0+0x119>\n  nop\n  nop\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %rcx,-0x40(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x40(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL6:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  movb   $0x0,-0x15(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jne    L1\n  movb   $0x1,-0x15(%rbp)\n  jmp    L1\nL4:\n  mov    -0x10(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L2\n  movb   $0x1,-0x15(%rbp)\nL2:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x10(%rbp)\nL1:\n  cmpl   $0x0,-0x10(%rbp)\n  jle    L3\n  movzbl -0x15(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  jne    L4\nL3:\n  movzbl -0x15(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     L5\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x40(%rbp),%rax\n  mov    %edx,(%rax)\nL5:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L6\n  movl   $0x0,-0xc(%rbp)\n  jmp    L7\nL11:\n  movl   $0x0,-0x8(%rbp)\n  jmp    L8\nL10:\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L9\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\nL9:\n  addl   $0x1,-0x8(%rbp)\nL8:\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  sub    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x8(%rbp)\n  jl     L10\n  addl   $0x1,-0xc(%rbp)\nL7:\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     L11\n  nop\n  nop\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4634
        },
        "L1": {
          "label": "L1",
          "addr": 4540
        },
        "L2": {
          "label": "L2",
          "addr": 4508
        },
        "L3": {
          "label": "L3",
          "addr": 4557
        },
        "L4": {
          "label": "L4",
          "addr": 4494
        },
        "L5": {
          "label": "L5",
          "addr": 4630
        },
        "L6": {
          "label": "L6",
          "addr": 4453
        },
        "L7": {
          "label": "L7",
          "addr": 4848
        },
        "L8": {
          "label": "L8",
          "addr": 4823
        },
        "L9": {
          "label": "L9",
          "addr": 4819
        },
        "L10": {
          "label": "L10",
          "addr": 4670
        },
        "L11": {
          "label": "L11",
          "addr": 4658
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int **y, int *m) {\n  *y = (int *)malloc(n * sizeof(int));\n  *m = 0;\n  for (int i = 0; i < n; i++) {\n    int tmp = x[i];\n    char flag = 0;\n    if (tmp == 0)\n      flag = 1;\n    while (tmp > 0 && flag == 0) {\n      if (tmp % 2 == 0)\n        flag = 1;\n      tmp /= 10;\n    }\n    if (flag == 0) {\n      (*y)[*m] = x[i];\n      (*m)++;\n    }\n  }\n  for (int i = 0; i < *m - 1; i++)\n    for (int j = 0; j < *m - i - 1; j++)\n      if ((*y)[j] > (*y)[j + 1]) {\n        int tmp = (*y)[j];\n        (*y)[j] = (*y)[j + 1];\n        (*y)[j + 1] = tmp;\n      }\n}"
    },
    {
      "task_id": 106,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  test   %ebx,%ebx\n  jle    116a <func0+0x4a>\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\n  imul   %edx,%esi\n  add    %edx,%ecx\n  test   $0x1,%dl\n  mov    %esi,%edi\n  cmovne %ecx,%edi\n  mov    %edi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%r8\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\nL1:\n  imul   %edx,%esi\n  add    %edx,%ecx\n  test   $0x1,%dl\n  mov    %esi,%edi\n  cmovne %ecx,%edi\n  mov    %edi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%r8\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4458
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int i;\n  int *a = (int *)malloc(n * sizeof(int));\n  int sum = 0;\n  for (i = 0; i < n; i++) {\n    sum += i;\n    if (i % 2)\n      a[i] = sum;\n    else\n      a[i] = a[i] * i;\n  }\n  return a;\n}"
    },
    {
      "task_id": 104,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  mov    %rax,0x0(%r13)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    11f5 <func0+0xd5>\n  mov    %rax,%r8\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%r9\n  xor    %esi,%esi\n  lea    0x4(%rbx,%rax,4),%r11\n  mov    $0xcccccccd,%edi\n  nopl   0x0(%rax)\n  mov    (%r9),%r10d\n  test   %r10d,%r10d\n  je     11ad <func0+0x8d>\n  jle    1204 <func0+0xe4>\n  mov    %r10d,%eax\n  nopl   0x0(%rax)\n  mov    %eax,%edx\n  mov    %eax,%eax\n  mov    %rax,%rcx\n  imul   %rdi,%rax\n  not    %edx\n  and    $0x1,%edx\n  shr    $0x23,%rax\n  cmp    $0x9,%ecx\n  jle    1200 <func0+0xe0>\n  test   %dl,%dl\n  je     1190 <func0+0x70>\n  add    $0x4,%r9\n  cmp    %r11,%r9\n  jne    1178 <func0+0x58>\n  lea    -0x1(%rsi),%edx\n  test   %edx,%edx\n  jle    11f5 <func0+0xd5>\n  lea    0x4(%r8),%r9\n  nopl   0x0(%rax)\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r9,%rdx,4),%rsi\n  nopl   (%rax)\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11e6 <func0+0xc6>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    11d8 <func0+0xb8>\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    11c8 <func0+0xa8>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  test   %dl,%dl\n  jne    11ad <func0+0x8d>\n  movslq %esi,%rax\n  add    $0x4,%r9\n  add    $0x1,%esi\n  mov    %r10d,(%r8,%rax,4)\n  mov    %esi,0x0(%rbp)\n  cmp    %r11,%r9\n  jne    1178 <func0+0x58>\n  jmp    11b6 <func0+0x96>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %rax,0x0(%r13)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    L0\n  mov    %rax,%r8\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%r9\n  xor    %esi,%esi\n  lea    0x4(%rbx,%rax,4),%r11\n  mov    $0xcccccccd,%edi\n  nopl   0x0(%rax)\nL5:\n  mov    (%r9),%r10d\n  test   %r10d,%r10d\n  je     L1\n  jle    L2\n  mov    %r10d,%eax\n  nopl   0x0(%rax)\nL4:\n  mov    %eax,%edx\n  mov    %eax,%eax\n  mov    %rax,%rcx\n  imul   %rdi,%rax\n  not    %edx\n  and    $0x1,%edx\n  shr    $0x23,%rax\n  cmp    $0x9,%ecx\n  jle    L3\n  test   %dl,%dl\n  je     L4\nL1:\n  add    $0x4,%r9\n  cmp    %r11,%r9\n  jne    L5\nL9:\n  lea    -0x1(%rsi),%edx\n  test   %edx,%edx\n  jle    L0\n  lea    0x4(%r8),%r9\n  nopl   0x0(%rax)\nL8:\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r9,%rdx,4),%rsi\n  nopl   (%rax)\nL7:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L6\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\nL6:\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    L7\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    L8\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL3:\n  test   %dl,%dl\n  jne    L1\nL2:\n  movslq %esi,%rax\n  add    $0x4,%r9\n  add    $0x1,%esi\n  mov    %r10d,(%r8,%rax,4)\n  mov    %esi,0x0(%rbp)\n  cmp    %r11,%r9\n  jne    L5\n  jmp    L9",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4597
        },
        "L1": {
          "label": "L1",
          "addr": 4525
        },
        "L2": {
          "label": "L2",
          "addr": 4612
        },
        "L3": {
          "label": "L3",
          "addr": 4608
        },
        "L4": {
          "label": "L4",
          "addr": 4496
        },
        "L5": {
          "label": "L5",
          "addr": 4472
        },
        "L6": {
          "label": "L6",
          "addr": 4582
        },
        "L7": {
          "label": "L7",
          "addr": 4568
        },
        "L8": {
          "label": "L8",
          "addr": 4552
        },
        "L9": {
          "label": "L9",
          "addr": 4534
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int **y, int *m) {\n  int i, j, k, tmp;\n  *y = malloc(n * sizeof(int));\n  *m = 0;\n  for (i = 0; i < n; i++) {\n    if (x[i] != 0) {\n      k = x[i];\n      while (k > 0 && k % 10 == 0)\n        k /= 10;\n      if (k <= 9) {\n        (*y)[*m] = x[i];\n        (*m)++;\n      }\n    }\n  }\n  for (i = *m - 1; i > 0; i--) {\n    for (j = 0; j < i; j++) {\n      if ((*y)[j] > (*y)[j + 1]) {\n        tmp = (*y)[j];\n        (*y)[j] = (*y)[j + 1];\n        (*y)[j + 1] = tmp;\n      }\n    }\n  }\n}"
    },
    {
      "task_id": 106,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  test   %ebx,%ebx\n  jle    1167 <func0+0x47>\n  lea    0x1(%rbx),%edi\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  xor    %ecx,%ecx\n  nopw   0x0(%rax,%rax,1)\n  imul   %edx,%esi\n  add    %edx,%ecx\n  test   $0x1,%dl\n  je     1170 <func0+0x50>\n  mov    %ecx,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rdi\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\n  mov    %esi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rdi\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%edi\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  xor    %ecx,%ecx\n  nopw   0x0(%rax,%rax,1)\nL2:\n  imul   %edx,%esi\n  add    %edx,%ecx\n  test   $0x1,%dl\n  je     L1\n  mov    %ecx,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rdi\n  jne    L2\nL0:\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    %esi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rdi\n  jne    L2\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4455
        },
        "L1": {
          "label": "L1",
          "addr": 4464
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = (int *)malloc(n * sizeof(int));\n  int i = 0;\n  int j = 1;\n  int k = 0;\n  while (i < n) {\n    j *= i;\n    if (i % 2) {\n      a[i - 1] = k + i;\n      k += i;\n    } else {\n      a[i - 1] = j;\n    }\n    i++;\n  }\n  return a;\n}"
    },
    {
      "task_id": 104,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  mov    %rax,0x0(%r13)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    1205 <func0+0xe5>\n  mov    %rax,%r8\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%r9\n  xor    %esi,%esi\n  lea    0x4(%rbx,%rax,4),%r11\n  mov    $0xcccccccd,%edi\n  nopl   0x0(%rax)\n  mov    (%r9),%r10d\n  test   %r10d,%r10d\n  je     11ad <func0+0x8d>\n  jle    1214 <func0+0xf4>\n  mov    %r10d,%eax\n  nopl   0x0(%rax)\n  mov    %eax,%edx\n  mov    %eax,%eax\n  mov    %rax,%rcx\n  imul   %rdi,%rax\n  not    %edx\n  and    $0x1,%edx\n  shr    $0x23,%rax\n  cmp    $0x9,%ecx\n  jle    1210 <func0+0xf0>\n  test   %dl,%dl\n  je     1190 <func0+0x70>\n  add    $0x4,%r9\n  cmp    %r9,%r11\n  jne    1178 <func0+0x58>\n  lea    -0x1(%rsi),%eax\n  test   %eax,%eax\n  jle    1205 <func0+0xe5>\n  lea    0x4(%r8),%r9\n  nopl   0x0(%rax)\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%r9,%rax,4),%rsi\n  nopl   (%rax)\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    11f6 <func0+0xd6>\n  movq   %xmm1,(%rdx)\n  add    $0x4,%rdx\n  cmp    %rdx,%rsi\n  jne    11d8 <func0+0xb8>\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    11c8 <func0+0xa8>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  test   %dl,%dl\n  jne    11ad <func0+0x8d>\n  movslq %esi,%rax\n  add    $0x4,%r9\n  add    $0x1,%esi\n  mov    %r10d,(%r8,%rax,4)\n  mov    %esi,0x0(%rbp)\n  cmp    %r9,%r11\n  jne    1178 <func0+0x58>\n  jmp    11b6 <func0+0x96>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %rax,0x0(%r13)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    L0\n  mov    %rax,%r8\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%r9\n  xor    %esi,%esi\n  lea    0x4(%rbx,%rax,4),%r11\n  mov    $0xcccccccd,%edi\n  nopl   0x0(%rax)\nL5:\n  mov    (%r9),%r10d\n  test   %r10d,%r10d\n  je     L1\n  jle    L2\n  mov    %r10d,%eax\n  nopl   0x0(%rax)\nL4:\n  mov    %eax,%edx\n  mov    %eax,%eax\n  mov    %rax,%rcx\n  imul   %rdi,%rax\n  not    %edx\n  and    $0x1,%edx\n  shr    $0x23,%rax\n  cmp    $0x9,%ecx\n  jle    L3\n  test   %dl,%dl\n  je     L4\nL1:\n  add    $0x4,%r9\n  cmp    %r9,%r11\n  jne    L5\nL9:\n  lea    -0x1(%rsi),%eax\n  test   %eax,%eax\n  jle    L0\n  lea    0x4(%r8),%r9\n  nopl   0x0(%rax)\nL8:\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%r9,%rax,4),%rsi\n  nopl   (%rax)\nL7:\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    L6\n  movq   %xmm1,(%rdx)\nL6:\n  add    $0x4,%rdx\n  cmp    %rdx,%rsi\n  jne    L7\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    L8\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL3:\n  test   %dl,%dl\n  jne    L1\nL2:\n  movslq %esi,%rax\n  add    $0x4,%r9\n  add    $0x1,%esi\n  mov    %r10d,(%r8,%rax,4)\n  mov    %esi,0x0(%rbp)\n  cmp    %r9,%r11\n  jne    L5\n  jmp    L9",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4613
        },
        "L1": {
          "label": "L1",
          "addr": 4525
        },
        "L2": {
          "label": "L2",
          "addr": 4628
        },
        "L3": {
          "label": "L3",
          "addr": 4624
        },
        "L4": {
          "label": "L4",
          "addr": 4496
        },
        "L5": {
          "label": "L5",
          "addr": 4472
        },
        "L6": {
          "label": "L6",
          "addr": 4598
        },
        "L7": {
          "label": "L7",
          "addr": 4568
        },
        "L8": {
          "label": "L8",
          "addr": 4552
        },
        "L9": {
          "label": "L9",
          "addr": 4534
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int **p, int *nn) {\n  int i, j, k, m;\n  *p = (int *)malloc(n * sizeof(int));\n  *nn = 0;\n  for (i = 0; i < n; ++i) {\n    if (x[i] != 0) {\n      m = x[i];\n      while (m > 0) {\n        k = m % 10;\n        m /= 10;\n        if (k % 2 == 0)\n          break;\n      }\n      if (m == 0) {\n        (*p)[*nn] = x[i];\n        (*nn)++;\n      }\n    }\n  }\n  for (i = 0; i < *nn - 1; ++i) {\n    for (j = 0; j < *nn - i - 1; ++j) {\n      if ((*p)[j] > (*p)[j + 1]) {\n        k = (*p)[j];\n        (*p)[j] = (*p)[j + 1];\n        (*p)[j + 1] = k;\n      }\n    }\n  }\n}"
    },
    {
      "task_id": 107,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x0,(%rax)\n  movl   $0x1,-0x18(%rbp)\n  jmp    1209 <func0+0xf0>\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    11cd <func0+0xb4>\n  mov    -0x14(%rbp),%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  mov    %eax,%edi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  mov    %edx,%ecx\n  sub    %eax,%ecx\n  lea    (%rdi,%rcx,1),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x10(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jne    116f <func0+0x56>\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    1205 <func0+0xec>\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    11f6 <func0+0xdd>\n  mov    -0x8(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,(%rax)\n  jmp    1205 <func0+0xec>\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  mov    (%rax),%edx\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    115a <func0+0x41>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x0,(%rax)\n  movl   $0x1,-0x18(%rbp)\n  jmp    L0\nL5:\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    L1\nL2:\n  mov    -0x14(%rbp),%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  mov    %eax,%edi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  mov    %edx,%ecx\n  sub    %eax,%ecx\n  lea    (%rdi,%rcx,1),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x10(%rbp)\nL1:\n  cmpl   $0x0,-0x10(%rbp)\n  jne    L2\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    L3\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L4\n  mov    -0x8(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,(%rax)\n  jmp    L3\nL4:\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  mov    (%rax),%edx\n  add    $0x1,%edx\n  mov    %edx,(%rax)\nL3:\n  addl   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    L5\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4617
        },
        "L1": {
          "label": "L1",
          "addr": 4557
        },
        "L2": {
          "label": "L2",
          "addr": 4463
        },
        "L3": {
          "label": "L3",
          "addr": 4613
        },
        "L4": {
          "label": "L4",
          "addr": 4598
        },
        "L5": {
          "label": "L5",
          "addr": 4442
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int m) {\n  int *a = (int *)malloc(2 * sizeof(int));\n  a[0] = 0;\n  a[1] = 0;\n  int i, j, k, t, rev;\n  for (i = 1; i <= m; i++) {\n    rev = 0;\n    t = i;\n    j = i;\n    while (j) {\n      rev = rev * 10 + j % 10;\n      j /= 10;\n    }\n    if (rev == t) {\n      if (t % 2 == 0)\n        a[0]++;\n      else\n        a[1]++;\n    }\n  }\n  return a;\n}"
    },
    {
      "task_id": 107,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,%r9\n  movl   $0x0,(%rax)\n  movl   $0x0,0x4(%rax)\n  test   %ebx,%ebx\n  jle    119d <func0+0x84>\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edi\n  mov    $0x0,%r10d\n  jmp    115b <func0+0x42>\n  addl   $0x1,(%r9)\n  add    $0x1,%edi\n  cmp    %edi,%r8d\n  je     119d <func0+0x84>\n  mov    %edi,%edx\n  mov    %r10d,%ecx\n  test   %edi,%edi\n  je     114f <func0+0x36>\n  lea    (%rcx,%rcx,4),%esi\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  lea    (%rdx,%rsi,2),%ecx\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    1164 <func0+0x4b>\n  cmp    %edi,%ecx\n  jne    1153 <func0+0x3a>\n  test   $0x1,%dil\n  je     114f <func0+0x36>\n  addl   $0x1,0x4(%r9)\n  jmp    1153 <func0+0x3a>\n  mov    %r9,%rax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    %rax,%r9\n  movl   $0x0,(%rax)\n  movl   $0x0,0x4(%rax)\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edi\n  mov    $0x0,%r10d\n  jmp    L1\nL2:\n  addl   $0x1,(%r9)\nL4:\n  add    $0x1,%edi\n  cmp    %edi,%r8d\n  je     L0\nL1:\n  mov    %edi,%edx\n  mov    %r10d,%ecx\n  test   %edi,%edi\n  je     L2\nL3:\n  lea    (%rcx,%rcx,4),%esi\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  lea    (%rdx,%rsi,2),%ecx\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    L3\n  cmp    %edi,%ecx\n  jne    L4\n  test   $0x1,%dil\n  je     L2\n  addl   $0x1,0x4(%r9)\n  jmp    L4\nL0:\n  mov    %r9,%rax\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4509
        },
        "L1": {
          "label": "L1",
          "addr": 4443
        },
        "L2": {
          "label": "L2",
          "addr": 4431
        },
        "L3": {
          "label": "L3",
          "addr": 4452
        },
        "L4": {
          "label": "L4",
          "addr": 4435
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = malloc(2 * sizeof(int));\n  a[0] = 0;\n  a[1] = 0;\n  int i, j, k;\n  for (i = 1; i <= n; i++) {\n    j = i;\n    k = 0;\n    while (j != 0) {\n      k = k * 10 + j % 10;\n      j /= 10;\n    }\n    if (k == i) {\n      if (i % 2 == 0)\n        a[0]++;\n      else\n        a[1]++;\n    }\n  }\n  return a;\n}"
    },
    {
      "task_id": 109,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    $0x1,%eax\n  test   %esi,%esi\n  je     1148 <func0+0x4f>\n  cmp    $0x1,%esi\n  jle    1149 <func0+0x50>\n  mov    %rdi,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%r8\n  mov    $0x0,%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,0x4(%rax)\n  setl   %cl\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  jne    111b <func0+0x22>\n  movslq %esi,%rsi\n  mov    (%rdi),%eax\n  cmp    %eax,-0x4(%rdi,%rsi,4)\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%edx\n  cmp    $0x1,%edx\n  setle  %al\n  ret\n  mov    $0x0,%edx\n  jmp    1131 <func0+0x38>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x1,%eax\n  test   %esi,%esi\n  je     L0\n  cmp    $0x1,%esi\n  jle    L1\n  mov    %rdi,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%r8\n  mov    $0x0,%edx\nL2:\n  mov    (%rax),%ecx\n  cmp    %ecx,0x4(%rax)\n  setl   %cl\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  jne    L2\nL3:\n  movslq %esi,%rsi\n  mov    (%rdi),%eax\n  cmp    %eax,-0x4(%rdi,%rsi,4)\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%edx\n  cmp    $0x1,%edx\n  setle  %al\nL0:\n  ret\nL1:\n  mov    $0x0,%edx\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4424
        },
        "L1": {
          "label": "L1",
          "addr": 4425
        },
        "L2": {
          "label": "L2",
          "addr": 4379
        },
        "L3": {
          "label": "L3",
          "addr": 4401
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int a) {\n  int b = 0;\n  if (a == 0)\n    return 1;\n  for (int i = 1; i < a; i++)\n    if (x[i] < x[i - 1])\n      b++;\n  if (x[a - 1] > x[0])\n    b++;\n  return b <= 1;\n}"
    },
    {
      "task_id": 109,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    111c <func0+0x23>\n  mov    $0x1,%eax\n  jmp    119b <func0+0xa2>\n  movl   $0x1,-0x4(%rbp)\n  jmp    115d <func0+0x64>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    1159 <func0+0x60>\n  addl   $0x1,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1125 <func0+0x2c>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    1189 <func0+0x90>\n  addl   $0x1,-0x8(%rbp)\n  cmpl   $0x1,-0x8(%rbp)\n  jg     1196 <func0+0x9d>\n  mov    $0x1,%eax\n  jmp    119b <func0+0xa2>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    L0\n  mov    $0x1,%eax\n  jmp    L1\nL0:\n  movl   $0x1,-0x4(%rbp)\n  jmp    L2\nL4:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L3\n  addl   $0x1,-0x8(%rbp)\nL3:\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L5\n  addl   $0x1,-0x8(%rbp)\nL5:\n  cmpl   $0x1,-0x8(%rbp)\n  jg     L6\n  mov    $0x1,%eax\n  jmp    L1\nL6:\n  mov    $0x0,%eax\nL1:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4380
        },
        "L1": {
          "label": "L1",
          "addr": 4507
        },
        "L2": {
          "label": "L2",
          "addr": 4445
        },
        "L3": {
          "label": "L3",
          "addr": 4441
        },
        "L4": {
          "label": "L4",
          "addr": 4389
        },
        "L5": {
          "label": "L5",
          "addr": 4489
        },
        "L6": {
          "label": "L6",
          "addr": 4502
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, count = 0;\n  if (len == 0)\n    return 1;\n  for (i = 1; i < len; i++)\n    if (arr[i] < arr[i - 1])\n      count++;\n  if (arr[len - 1] > arr[0])\n    count++;\n  if (count <= 1)\n    return 1;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 107,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  movq   $0x0,(%rax)\n  test   %ebx,%ebx\n  jle    1183 <func0+0x63>\n  lea    0x1(%rbx),%r10d\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%r8d\n  nopl   0x0(%rax)\n  mov    %r9d,%ecx\n  xor    %esi,%esi\n  nopl   (%rax)\n  mov    %ecx,%edx\n  lea    (%rsi,%rsi,4),%edi\n  imul   %r8,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%esi\n  add    %esi,%esi\n  sub    %esi,%ecx\n  lea    (%rcx,%rdi,2),%esi\n  mov    %edx,%ecx\n  test   %edx,%edx\n  jne    1158 <func0+0x38>\n  cmp    %esi,%r9d\n  je     1188 <func0+0x68>\n  add    $0x1,%r9d\n  cmp    %r10d,%r9d\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret\n  nopl   (%rax)\n  test   $0x1,%r9b\n  jne    1198 <func0+0x78>\n  addl   $0x1,(%rax)\n  jmp    117a <func0+0x5a>\n  nopl   0x0(%rax,%rax,1)\n  addl   $0x1,0x4(%rax)\n  jmp    117a <func0+0x5a>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  movq   $0x0,(%rax)\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r10d\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%r8d\n  nopl   0x0(%rax)\nL3:\n  mov    %r9d,%ecx\n  xor    %esi,%esi\n  nopl   (%rax)\nL1:\n  mov    %ecx,%edx\n  lea    (%rsi,%rsi,4),%edi\n  imul   %r8,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%esi\n  add    %esi,%esi\n  sub    %esi,%ecx\n  lea    (%rcx,%rdi,2),%esi\n  mov    %edx,%ecx\n  test   %edx,%edx\n  jne    L1\n  cmp    %esi,%r9d\n  je     L2\nL5:\n  add    $0x1,%r9d\n  cmp    %r10d,%r9d\n  jne    L3\nL0:\n  pop    %rbx\n  ret\n  nopl   (%rax)\nL2:\n  test   $0x1,%r9b\n  jne    L4\n  addl   $0x1,(%rax)\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL4:\n  addl   $0x1,0x4(%rax)\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4483
        },
        "L1": {
          "label": "L1",
          "addr": 4440
        },
        "L2": {
          "label": "L2",
          "addr": 4488
        },
        "L3": {
          "label": "L3",
          "addr": 4432
        },
        "L4": {
          "label": "L4",
          "addr": 4504
        },
        "L5": {
          "label": "L5",
          "addr": 4474
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void *func0(void *arg) {\n  int *ret = malloc(sizeof(int) * 2);\n  ret[0] = 0;\n  ret[1] = 0;\n  int i;\n  for (i = 1; i <= (int)arg; i++) {\n    int j = i;\n    int sum = 0;\n    while (j) {\n      sum += j % 10;\n      j /= 10;\n    }\n    if (sum == i) {\n      if (i % 2 == 0) {\n        ret[0]++;\n      } else {\n        ret[1]++;\n      }\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 109,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    $0x1,%eax\n  test   %esi,%esi\n  je     114d <func0+0x4d>\n  cmp    $0x1,%esi\n  jle    1150 <func0+0x50>\n  lea    -0x2(%rsi),%edx\n  mov    %rdi,%rax\n  lea    0x4(%rdi,%rdx,4),%r8\n  xor    %edx,%edx\n  nop\n  mov    (%rax),%ecx\n  cmp    %ecx,0x4(%rax)\n  setl   %cl\n  add    $0x4,%rax\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  cmp    %r8,%rax\n  jne    1120 <func0+0x20>\n  movslq %esi,%rsi\n  mov    (%rdi),%eax\n  cmp    %eax,-0x4(%rdi,%rsi,4)\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%edx\n  cmp    $0x1,%edx\n  setle  %al\n  ret\n  xchg   %ax,%ax\n  xor    %edx,%edx\n  jmp    1136 <func0+0x36>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x1,%eax\n  test   %esi,%esi\n  je     L0\n  cmp    $0x1,%esi\n  jle    L1\n  lea    -0x2(%rsi),%edx\n  mov    %rdi,%rax\n  lea    0x4(%rdi,%rdx,4),%r8\n  xor    %edx,%edx\n  nop\nL2:\n  mov    (%rax),%ecx\n  cmp    %ecx,0x4(%rax)\n  setl   %cl\n  add    $0x4,%rax\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  cmp    %r8,%rax\n  jne    L2\nL3:\n  movslq %esi,%rsi\n  mov    (%rdi),%eax\n  cmp    %eax,-0x4(%rdi,%rsi,4)\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%edx\n  cmp    $0x1,%edx\n  setle  %al\nL0:\n  ret\n  xchg   %ax,%ax\nL1:\n  xor    %edx,%edx\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4429
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        },
        "L2": {
          "label": "L2",
          "addr": 4384
        },
        "L3": {
          "label": "L3",
          "addr": 4406
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  int i, j;\n  if (n == 0)\n    return 1;\n  for (i = 0, j = 0; i < n - 1; ++i)\n    if (x[i + 1] < x[i])\n      ++j;\n  if (x[n - 1] > x[0])\n    ++j;\n  return j <= 1;\n}"
    },
    {
      "task_id": 108,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1178 <func0+0x78>\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%r10d\n  lea    0x4(%rdi,%rax,4),%r11\n  jmp    112d <func0+0x2d>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%r9d\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  je     1174 <func0+0x74>\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  jg     1120 <func0+0x20>\n  mov    %eax,%edx\n  neg    %edx\n  cmp    $0xfffffff7,%eax\n  jge    1124 <func0+0x24>\n  xor    %esi,%esi\n  xchg   %ax,%ax\n  mov    %edx,%eax\n  mov    %edx,%r8d\n  imul   %r10,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%r8d\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  add    %r8d,%esi\n  cmp    $0x63,%ecx\n  jg     1140 <func0+0x40>\n  xor    %eax,%eax\n  cmp    %edx,%esi\n  setg   %al\n  add    $0x4,%rdi\n  add    %eax,%r9d\n  cmp    %r11,%rdi\n  jne    112d <func0+0x2d>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%r10d\n  lea    0x4(%rdi,%rax,4),%r11\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%r9d\nL4:\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  je     L2\nL1:\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  jg     L3\n  mov    %eax,%edx\n  neg    %edx\n  cmp    $0xfffffff7,%eax\n  jge    L4\n  xor    %esi,%esi\n  xchg   %ax,%ax\nL5:\n  mov    %edx,%eax\n  mov    %edx,%r8d\n  imul   %r10,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%r8d\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  add    %r8d,%esi\n  cmp    $0x63,%ecx\n  jg     L5\n  xor    %eax,%eax\n  cmp    %edx,%esi\n  setg   %al\n  add    $0x4,%rdi\n  add    %eax,%r9d\n  cmp    %r11,%rdi\n  jne    L1\nL2:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4472
        },
        "L1": {
          "label": "L1",
          "addr": 4397
        },
        "L2": {
          "label": "L2",
          "addr": 4468
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4388
        },
        "L5": {
          "label": "L5",
          "addr": 4416
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  int i, j, k, ret = 0;\n  for (i = 0; i < n; i++) {\n    if (x[i] > 0) {\n      ret++;\n    } else {\n      j = -x[i];\n      k = 0;\n      while (j >= 10) {\n        k += j % 10;\n        j /= 10;\n      }\n      if (j > k)\n        ret++;\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 108,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1178 <func0+0x78>\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%r10d\n  lea    0x4(%rdi,%rax,4),%r11\n  jmp    112d <func0+0x2d>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%r9d\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  je     1174 <func0+0x74>\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  jg     1120 <func0+0x20>\n  mov    %eax,%edx\n  neg    %edx\n  cmp    $0xfffffff7,%eax\n  jge    1124 <func0+0x24>\n  xor    %esi,%esi\n  xchg   %ax,%ax\n  mov    %edx,%eax\n  mov    %edx,%r8d\n  imul   %r10,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%r8d\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  add    %r8d,%esi\n  cmp    $0x63,%ecx\n  jg     1140 <func0+0x40>\n  xor    %eax,%eax\n  cmp    %edx,%esi\n  setg   %al\n  add    $0x4,%rdi\n  add    %eax,%r9d\n  cmp    %r11,%rdi\n  jne    112d <func0+0x2d>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%r10d\n  lea    0x4(%rdi,%rax,4),%r11\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%r9d\nL4:\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  je     L2\nL1:\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  jg     L3\n  mov    %eax,%edx\n  neg    %edx\n  cmp    $0xfffffff7,%eax\n  jge    L4\n  xor    %esi,%esi\n  xchg   %ax,%ax\nL5:\n  mov    %edx,%eax\n  mov    %edx,%r8d\n  imul   %r10,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%r8d\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  add    %r8d,%esi\n  cmp    $0x63,%ecx\n  jg     L5\n  xor    %eax,%eax\n  cmp    %edx,%esi\n  setg   %al\n  add    $0x4,%rdi\n  add    %eax,%r9d\n  cmp    %r11,%rdi\n  jne    L1\nL2:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4472
        },
        "L1": {
          "label": "L1",
          "addr": 4397
        },
        "L2": {
          "label": "L2",
          "addr": 4468
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4388
        },
        "L5": {
          "label": "L5",
          "addr": 4416
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  int i, j, k, ret = 0;\n  for (i = 0; i < n; i++) {\n    if (x[i] > 0) {\n      ret++;\n    } else {\n      j = -x[i];\n      k = 0;\n      while (j >= 10) {\n        k += j % 10;\n        j /= 10;\n      }\n      if (j > k)\n        ret++;\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 108,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    116f <func0+0x76>\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r10\n  mov    $0x0,%r9d\n  jmp    1162 <func0+0x69>\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  cmp    $0x9,%edx\n  jle    1159 <func0+0x60>\n  mov    $0x0,%esi\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  mov    %edx,%edi\n  sub    %ecx,%edi\n  add    %edi,%esi\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  cmp    $0x63,%ecx\n  jg     1125 <func0+0x2c>\n  cmp    %eax,%esi\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%r9d\n  add    $0x4,%r8\n  cmp    %r10,%r8\n  je     1175 <func0+0x7c>\n  mov    (%r8),%eax\n  test   %eax,%eax\n  jle    1114 <func0+0x1b>\n  add    $0x1,%r9d\n  jmp    1159 <func0+0x60>\n  mov    $0x0,%r9d\n  mov    %r9d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r10\n  mov    $0x0,%r9d\n  jmp    L1\nL5:\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  cmp    $0x9,%edx\n  jle    L2\n  mov    $0x0,%esi\nL3:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  mov    %edx,%edi\n  sub    %ecx,%edi\n  add    %edi,%esi\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  cmp    $0x63,%ecx\n  jg     L3\n  cmp    %eax,%esi\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%r9d\nL2:\n  add    $0x4,%r8\n  cmp    %r10,%r8\n  je     L4\nL1:\n  mov    (%r8),%eax\n  test   %eax,%eax\n  jle    L5\n  add    $0x1,%r9d\n  jmp    L2\nL0:\n  mov    $0x0,%r9d\nL4:\n  mov    %r9d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4463
        },
        "L1": {
          "label": "L1",
          "addr": 4450
        },
        "L2": {
          "label": "L2",
          "addr": 4441
        },
        "L3": {
          "label": "L3",
          "addr": 4389
        },
        "L4": {
          "label": "L4",
          "addr": 4469
        },
        "L5": {
          "label": "L5",
          "addr": 4372
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *a, int n) {\n  int i, j, k, count = 0;\n  for (i = 0; i < n; i++) {\n    if (a[i] > 0)\n      count++;\n    else {\n      k = a[i];\n      if (k < 0)\n        k = -k;\n      j = 0;\n      while (k > 9) {\n        j += k % 10;\n        k /= 10;\n      }\n      if (k > j)\n        count++;\n    }\n  }\n  return count;\n}"
    },
    {
      "task_id": 108,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11ce <func0+0xd5>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    113e <func0+0x45>\n  addl   $0x1,-0x10(%rbp)\n  jmp    11ca <func0+0xd1>\n  movl   $0x0,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    11b4 <func0+0xbb>\n  mov    -0x4(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  add    %edx,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x9,-0x4(%rbp)\n  jg     1167 <func0+0x6e>\n  mov    -0x4(%rbp),%eax\n  sub    %eax,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jle    11ca <func0+0xd1>\n  addl   $0x1,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111b <func0+0x22>\n  mov    -0x10(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL5:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    L1\n  addl   $0x1,-0x10(%rbp)\n  jmp    L2\nL1:\n  movl   $0x0,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    L3\nL4:\n  mov    -0x4(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  add    %edx,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x4(%rbp)\nL3:\n  cmpl   $0x9,-0x4(%rbp)\n  jg     L4\n  mov    -0x4(%rbp),%eax\n  sub    %eax,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jle    L2\n  addl   $0x1,-0x10(%rbp)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    -0x10(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4558
        },
        "L1": {
          "label": "L1",
          "addr": 4414
        },
        "L2": {
          "label": "L2",
          "addr": 4554
        },
        "L3": {
          "label": "L3",
          "addr": 4532
        },
        "L4": {
          "label": "L4",
          "addr": 4455
        },
        "L5": {
          "label": "L5",
          "addr": 4379
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  int c = 0;\n  for (int i = 0; i < n; i++) {\n    if (x[i] > 0) {\n      c++;\n    } else {\n      int a = 0;\n      int b = ((x[i]) > 0 ? (x[i]) : -(x[i]));\n      while (b >= 10) {\n        a += b % 10;\n        b /= 10;\n      }\n      a -= b;\n      if (a > 0) {\n        c++;\n      }\n    }\n  }\n  return c;\n}"
    },
    {
      "task_id": 109,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movslq %esi,%rdx\n  mov    %rdi,%r8\n  mov    $0x1,%eax\n  test   %edx,%edx\n  je     1291 <func0+0x191>\n  cmp    $0x1,%edx\n  jle    12a0 <func0+0x1a0>\n  lea    -0x2(%rdx),%eax\n  lea    -0x1(%rdx),%esi\n  cmp    $0x2,%eax\n  jbe    12a4 <func0+0x1a4>\n  mov    %esi,%ecx\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  shr    $0x2,%ecx\n  sub    $0x1,%ecx\n  shl    $0x4,%rcx\n  lea    0x10(%rdi,%rcx,1),%rcx\n  nopw   0x0(%rax,%rax,1)\n  movdqu (%rax),%xmm0\n  movdqu 0x4(%rax),%xmm2\n  add    $0x10,%rax\n  pcmpgtd %xmm2,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rcx,%rax\n  jne    1150 <func0+0x50>\n  movdqa %xmm1,%xmm0\n  mov    %esi,%edi\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%edi\n  paddd  %xmm0,%xmm1\n  lea    0x1(%rdi),%ecx\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  cmp    %edi,%esi\n  je     127b <func0+0x17b>\n  movslq %ecx,%rdi\n  lea    0x1(%rcx),%r10d\n  shl    $0x2,%rdi\n  lea    (%r8,%rdi,1),%r9\n  cmp    %esi,%r10d\n  jge    12b0 <func0+0x1b0>\n  cmp    %ecx,%edx\n  jle    12b0 <func0+0x1b0>\n  mov    (%r9),%r10d\n  cmp    %r10d,-0x4(%r9)\n  setg   %r9b\n  mov    0x4(%r8,%rdi,1),%r11d\n  movzbl %r9b,%r9d\n  add    %r9d,%eax\n  xor    %r9d,%r9d\n  cmp    %r11d,%r10d\n  setg   %r9b\n  lea    0x3(%rcx),%r10d\n  add    %r9d,%eax\n  lea    0x2(%rcx),%r9d\n  cmp    %r10d,%esi\n  jle    123b <func0+0x13b>\n  mov    0x8(%r8,%rdi,1),%r9d\n  xor    %r10d,%r10d\n  cmp    %r9d,%r11d\n  lea    0x5(%rcx),%r11d\n  setg   %r10b\n  add    %r10d,%eax\n  mov    0xc(%r8,%rdi,1),%r10d\n  cmp    %r10d,%r9d\n  setg   %r9b\n  movzbl %r9b,%r9d\n  add    %r9d,%eax\n  lea    0x4(%rcx),%r9d\n  cmp    %r11d,%esi\n  jle    123b <func0+0x13b>\n  mov    0x10(%r8,%rdi,1),%esi\n  xor    %r9d,%r9d\n  cmp    %r10d,%esi\n  setl   %r9b\n  add    %r9d,%eax\n  cmp    0x14(%r8,%rdi,1),%esi\n  jle    1237 <func0+0x137>\n  add    $0x1,%eax\n  lea    0x6(%rcx),%r9d\n  movslq %r9d,%rcx\n  mov    (%r8,%rcx,4),%edi\n  lea    0x0(,%rcx,4),%rsi\n  cmp    -0x4(%r8,%rcx,4),%edi\n  jl     1298 <func0+0x198>\n  lea    0x1(%r9),%ecx\n  cmp    %ecx,%edx\n  jle    127b <func0+0x17b>\n  cmp    0x4(%r8,%rsi,1),%edi\n  jle    1263 <func0+0x163>\n  add    $0x1,%eax\n  add    $0x2,%r9d\n  cmp    %r9d,%edx\n  jle    127b <func0+0x17b>\n  mov    0x8(%r8,%rsi,1),%edi\n  cmp    %edi,0x4(%r8,%rsi,1)\n  jle    127b <func0+0x17b>\n  add    $0x1,%eax\n  mov    (%r8),%esi\n  cmp    %esi,-0x4(%r8,%rdx,4)\n  setg   %dl\n  movzbl %dl,%edx\n  add    %edx,%eax\n  cmp    $0x1,%eax\n  setle  %al\n  ret\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    1251 <func0+0x151>\n  nopl   (%rax)\n  xor    %eax,%eax\n  jmp    127b <func0+0x17b>\n  mov    $0x1,%ecx\n  xor    %eax,%eax\n  jmp    1198 <func0+0x98>\n  mov    %ecx,%r9d\n  jmp    123b <func0+0x13b>",
      "asm_labeled": "<func0>:\n  endbr64\n  movslq %esi,%rdx\n  mov    %rdi,%r8\n  mov    $0x1,%eax\n  test   %edx,%edx\n  je     L0\n  cmp    $0x1,%edx\n  jle    L1\n  lea    -0x2(%rdx),%eax\n  lea    -0x1(%rdx),%esi\n  cmp    $0x2,%eax\n  jbe    L2\n  mov    %esi,%ecx\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  shr    $0x2,%ecx\n  sub    $0x1,%ecx\n  shl    $0x4,%rcx\n  lea    0x10(%rdi,%rcx,1),%rcx\n  nopw   0x0(%rax,%rax,1)\nL3:\n  movdqu (%rax),%xmm0\n  movdqu 0x4(%rax),%xmm2\n  add    $0x10,%rax\n  pcmpgtd %xmm2,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rcx,%rax\n  jne    L3\n  movdqa %xmm1,%xmm0\n  mov    %esi,%edi\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%edi\n  paddd  %xmm0,%xmm1\n  lea    0x1(%rdi),%ecx\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  cmp    %edi,%esi\n  je     L4\nL11:\n  movslq %ecx,%rdi\n  lea    0x1(%rcx),%r10d\n  shl    $0x2,%rdi\n  lea    (%r8,%rdi,1),%r9\n  cmp    %esi,%r10d\n  jge    L5\n  cmp    %ecx,%edx\n  jle    L5\n  mov    (%r9),%r10d\n  cmp    %r10d,-0x4(%r9)\n  setg   %r9b\n  mov    0x4(%r8,%rdi,1),%r11d\n  movzbl %r9b,%r9d\n  add    %r9d,%eax\n  xor    %r9d,%r9d\n  cmp    %r11d,%r10d\n  setg   %r9b\n  lea    0x3(%rcx),%r10d\n  add    %r9d,%eax\n  lea    0x2(%rcx),%r9d\n  cmp    %r10d,%esi\n  jle    L6\n  mov    0x8(%r8,%rdi,1),%r9d\n  xor    %r10d,%r10d\n  cmp    %r9d,%r11d\n  lea    0x5(%rcx),%r11d\n  setg   %r10b\n  add    %r10d,%eax\n  mov    0xc(%r8,%rdi,1),%r10d\n  cmp    %r10d,%r9d\n  setg   %r9b\n  movzbl %r9b,%r9d\n  add    %r9d,%eax\n  lea    0x4(%rcx),%r9d\n  cmp    %r11d,%esi\n  jle    L6\n  mov    0x10(%r8,%rdi,1),%esi\n  xor    %r9d,%r9d\n  cmp    %r10d,%esi\n  setl   %r9b\n  add    %r9d,%eax\n  cmp    0x14(%r8,%rdi,1),%esi\n  jle    L7\n  add    $0x1,%eax\nL7:\n  lea    0x6(%rcx),%r9d\nL6:\n  movslq %r9d,%rcx\n  mov    (%r8,%rcx,4),%edi\n  lea    0x0(,%rcx,4),%rsi\n  cmp    -0x4(%r8,%rcx,4),%edi\n  jl     L8\nL10:\n  lea    0x1(%r9),%ecx\n  cmp    %ecx,%edx\n  jle    L4\n  cmp    0x4(%r8,%rsi,1),%edi\n  jle    L9\n  add    $0x1,%eax\nL9:\n  add    $0x2,%r9d\n  cmp    %r9d,%edx\n  jle    L4\n  mov    0x8(%r8,%rsi,1),%edi\n  cmp    %edi,0x4(%r8,%rsi,1)\n  jle    L4\n  add    $0x1,%eax\nL4:\n  mov    (%r8),%esi\n  cmp    %esi,-0x4(%r8,%rdx,4)\n  setg   %dl\n  movzbl %dl,%edx\n  add    %edx,%eax\n  cmp    $0x1,%eax\n  setle  %al\nL0:\n  ret\n  nopw   0x0(%rax,%rax,1)\nL8:\n  add    $0x1,%eax\n  jmp    L10\n  nopl   (%rax)\nL1:\n  xor    %eax,%eax\n  jmp    L4\nL2:\n  mov    $0x1,%ecx\n  xor    %eax,%eax\n  jmp    L11\nL5:\n  mov    %ecx,%r9d\n  jmp    L6",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4753
        },
        "L1": {
          "label": "L1",
          "addr": 4768
        },
        "L2": {
          "label": "L2",
          "addr": 4772
        },
        "L3": {
          "label": "L3",
          "addr": 4432
        },
        "L4": {
          "label": "L4",
          "addr": 4731
        },
        "L5": {
          "label": "L5",
          "addr": 4784
        },
        "L6": {
          "label": "L6",
          "addr": 4667
        },
        "L7": {
          "label": "L7",
          "addr": 4663
        },
        "L8": {
          "label": "L8",
          "addr": 4760
        },
        "L9": {
          "label": "L9",
          "addr": 4707
        },
        "L10": {
          "label": "L10",
          "addr": 4689
        },
        "L11": {
          "label": "L11",
          "addr": 4504
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  int i, j, k;\n  if (n == 0)\n    return 1;\n  k = 0;\n  for (i = 0; i < n - 1; i++)\n    if (x[i] > x[i + 1])\n      k++;\n  if (x[n - 1] > x[0])\n    k++;\n  if (k <= 1)\n    return 1;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 110,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1144 <func0+0x4b>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    1140 <func0+0x47>\n  addl   $0x1,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111f <func0+0x26>\n  movl   $0x0,-0x4(%rbp)\n  jmp    117a <func0+0x81>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    1176 <func0+0x7d>\n  addl   $0x1,-0xc(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     1155 <func0+0x5c>\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1193 <func0+0x9a>\n  lea    0xe6f(%rip),%rax        # 2000 <_fini+0xe64>\n  jmp    119a <func0+0xa1>\n  lea    0xe6a(%rip),%rax        # 2004 <_fini+0xe68>\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL2:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L1\n  addl   $0x1,-0xc(%rbp)\nL1:\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  movl   $0x0,-0x4(%rbp)\n  jmp    L3\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L4\n  addl   $0x1,-0xc(%rbp)\nL4:\n  addl   $0x1,-0x4(%rbp)\nL3:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     L5\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L6\n  lea    D0(%rip),%rax\n  jmp    L7\nL6:\n  lea    D1(%rip),%rax\nL7:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3695
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3690
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4420
        },
        "L1": {
          "label": "L1",
          "addr": 4416
        },
        "L2": {
          "label": "L2",
          "addr": 4383
        },
        "L3": {
          "label": "L3",
          "addr": 4474
        },
        "L4": {
          "label": "L4",
          "addr": 4470
        },
        "L5": {
          "label": "L5",
          "addr": 4437
        },
        "L6": {
          "label": "L6",
          "addr": 4499
        },
        "L7": {
          "label": "L7",
          "addr": 4506
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "594553004e4f00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"YES\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"NO\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(int *a, int n, int *b, int m) {\n  int i, j, k = 0;\n  for (i = 0; i < n; i++)\n    if (a[i] % 2 == 0)\n      k++;\n  for (j = 0; j < m; j++)\n    if (b[j] % 2 == 0)\n      k++;\n  if (k >= n)\n    return \"YES\";\n  else\n    return \"NO\";\n}"
    },
    {
      "task_id": 110,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    115b <func0+0x62>\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%eax\n  mov    (%r8),%edi\n  and    $0x1,%edi\n  cmp    $0x1,%edi\n  adc    $0x0,%eax\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  jne    1111 <func0+0x18>\n  test   %ecx,%ecx\n  jle    1146 <func0+0x4d>\n  mov    $0x0,%edi\n  mov    (%rdx,%rdi,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x1,%rdi\n  cmp    %edi,%ecx\n  jg     112f <func0+0x36>\n  cmp    %eax,%esi\n  lea    0xeb5(%rip),%rax        # 2004 <_fini+0xe98>\n  lea    0xeaa(%rip),%rdx        # 2000 <_fini+0xe94>\n  cmovle %rdx,%rax\n  ret\n  mov    $0x0,%eax\n  test   %ecx,%ecx\n  jg     112a <func0+0x31>\n  lea    0xe95(%rip),%rax        # 2000 <_fini+0xe94>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%eax\nL1:\n  mov    (%r8),%edi\n  and    $0x1,%edi\n  cmp    $0x1,%edi\n  adc    $0x0,%eax\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  jne    L1\n  test   %ecx,%ecx\n  jle    L2\nL4:\n  mov    $0x0,%edi\nL3:\n  mov    (%rdx,%rdi,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x1,%rdi\n  cmp    %edi,%ecx\n  jg     L3\nL2:\n  cmp    %eax,%esi\n  lea    D0(%rip),%rax\n  lea    D1(%rip),%rdx\n  cmovle %rdx,%rax\n  ret\nL0:\n  mov    $0x0,%eax\n  test   %ecx,%ecx\n  jg     L4\n  lea    D1(%rip),%rax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8196,
          "bias": [
            3765
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3754,
            3733
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4443
        },
        "L1": {
          "label": "L1",
          "addr": 4369
        },
        "L2": {
          "label": "L2",
          "addr": 4422
        },
        "L3": {
          "label": "L3",
          "addr": 4399
        },
        "L4": {
          "label": "L4",
          "addr": 4394
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "594553004e4f00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"YES\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"NO\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int *a, int n, int *b, int m) {\n  int i, cnt = 0;\n  for (i = 0; i < n; i++)\n    if (a[i] % 2 == 0)\n      cnt++;\n  for (i = 0; i < m; i++)\n    if (b[i] % 2 == 0)\n      cnt++;\n  if (cnt >= n)\n    return \"NO\";\n  else\n    return \"YES\";\n}"
    },
    {
      "task_id": 110,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1168 <func0+0x68>\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rdi),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    1118 <func0+0x18>\n  test   %ecx,%ecx\n  jle    114f <func0+0x4f>\n  xor    %edi,%edi\n  nopl   (%rax)\n  mov    (%rdx,%rdi,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x1,%rdi\n  cmp    %edi,%ecx\n  jg     1138 <func0+0x38>\n  cmp    %eax,%esi\n  lea    0xeac(%rip),%rdx        # 2004 <_fini+0xe8c>\n  lea    0xea1(%rip),%rax        # 2000 <_fini+0xe88>\n  cmovg  %rdx,%rax\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  test   %ecx,%ecx\n  jg     1133 <func0+0x33>\n  lea    0xe8b(%rip),%rax        # 2000 <_fini+0xe88>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    (%rdi),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    L1\n  test   %ecx,%ecx\n  jle    L2\nL4:\n  xor    %edi,%edi\n  nopl   (%rax)\nL3:\n  mov    (%rdx,%rdi,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x1,%rdi\n  cmp    %edi,%ecx\n  jg     L3\nL2:\n  cmp    %eax,%esi\n  lea    D0(%rip),%rdx\n  lea    D1(%rip),%rax\n  cmovg  %rdx,%rax\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\n  test   %ecx,%ecx\n  jg     L4\n  lea    D1(%rip),%rax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8196,
          "bias": [
            3756
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3745,
            3723
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4456
        },
        "L1": {
          "label": "L1",
          "addr": 4376
        },
        "L2": {
          "label": "L2",
          "addr": 4431
        },
        "L3": {
          "label": "L3",
          "addr": 4408
        },
        "L4": {
          "label": "L4",
          "addr": 4403
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "594553004e4f00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"YES\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"NO\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int *a, int n, int *b, int m) {\n  int i, j, k = 0;\n  for (i = 0; i < n; i++)\n    if (a[i] % 2 == 0)\n      k++;\n  for (j = 0; j < m; j++)\n    if (b[j] % 2 == 0)\n      k++;\n  if (k > n)\n    return \"NO\";\n  else\n    return \"YES\";\n}"
    },
    {
      "task_id": 111,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r11\n  mov    %rsi,%r8\n  mov    %rdx,%r10\n  mov    %rcx,%r9\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0xd,%ecx\n  rep stos %rax,%es:(%rdi)\n  movzbl (%r11),%eax\n  test   %al,%al\n  jne    1183 <func0+0x6a>\n  mov    $0x0,%ecx\n  mov    $0x0,%eax\n  mov    $0x0,%esi\n  jmp    1193 <func0+0x7a>\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  mov    %edx,(%rsp,%rax,4)\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%r11\n  movzbl (%r11),%eax\n  test   %al,%al\n  je     1155 <func0+0x3c>\n  cmp    $0x20,%al\n  jne    1161 <func0+0x48>\n  jmp    1177 <func0+0x5e>\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  je     11ad <func0+0x94>\n  mov    (%rsp,%rax,4),%edx\n  mov    %edx,(%r8,%rax,4)\n  cmp    %ecx,%edx\n  jne    1189 <func0+0x70>\n  movslq %esi,%rdx\n  lea    0x61(%rax),%edi\n  mov    %dil,(%r9,%rdx,1)\n  lea    0x1(%rsi),%esi\n  jmp    1189 <func0+0x70>\n  mov    %ecx,(%r10)\n  movslq %esi,%rsi\n  movb   $0x0,(%r9,%rsi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11cd <func0+0xb4>\n  add    $0x78,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r11\n  mov    %rsi,%r8\n  mov    %rdx,%r10\n  mov    %rcx,%r9\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0xd,%ecx\n  rep stos %rax,%es:(%rdi)\n  movzbl (%r11),%eax\n  test   %al,%al\n  jne    L0\n  mov    $0x0,%ecx\nL2:\n  mov    $0x0,%eax\n  mov    $0x0,%esi\n  jmp    L1\nL3:\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  mov    %edx,(%rsp,%rax,4)\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\nL4:\n  add    $0x1,%r11\n  movzbl (%r11),%eax\n  test   %al,%al\n  je     L2\nL0:\n  cmp    $0x20,%al\n  jne    L3\n  jmp    L4\nL6:\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  je     L5\nL1:\n  mov    (%rsp,%rax,4),%edx\n  mov    %edx,(%r8,%rax,4)\n  cmp    %ecx,%edx\n  jne    L6\n  movslq %esi,%rdx\n  lea    0x61(%rax),%edi\n  mov    %dil,(%r9,%rdx,1)\n  lea    0x1(%rsi),%esi\n  jmp    L6\nL5:\n  mov    %ecx,(%r10)\n  movslq %esi,%rsi\n  movb   $0x0,(%r9,%rsi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  add    $0x78,%rsp\n  ret\nL7:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4483
        },
        "L1": {
          "label": "L1",
          "addr": 4499
        },
        "L2": {
          "label": "L2",
          "addr": 4437
        },
        "L3": {
          "label": "L3",
          "addr": 4449
        },
        "L4": {
          "label": "L4",
          "addr": 4471
        },
        "L5": {
          "label": "L5",
          "addr": 4525
        },
        "L6": {
          "label": "L6",
          "addr": 4489
        },
        "L7": {
          "label": "L7",
          "addr": 4557
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s, int *a, int *max, char *c) {\n  int i, j, m = 0, b[26] = {0};\n  for (i = 0; s[i] != '\\0'; i++) {\n    if (s[i] == ' ')\n      continue;\n    j = s[i] - 'a';\n    b[j]++;\n    if (b[j] > m)\n      m = b[j];\n  }\n  for (i = 0; i < 26; i++) {\n    a[i] = b[i];\n    if (a[i] == m)\n      c[j++] = i + 'a';\n  }\n  *max = m;\n  c[j] = '\\0';\n}"
    },
    {
      "task_id": 110,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  mov    %rdx,%rdi\n  test   %esi,%esi\n  jle    12c8 <func0+0x1c8>\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    12da <func0+0x1da>\n  mov    %esi,%edx\n  pxor   %xmm1,%xmm1\n  movdqa 0xee4(%rip),%xmm2        # 2010 <_fini+0xd24>\n  mov    %r8,%rax\n  shr    $0x2,%edx\n  movdqa %xmm1,%xmm3\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%r8,%rdx,1),%rdx\n  nopw   0x0(%rax,%rax,1)\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%rdx\n  jne    1148 <func0+0x48>\n  movdqa %xmm1,%xmm0\n  mov    %esi,%eax\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%eax\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%edx\n  test   $0x3,%sil\n  je     11d2 <func0+0xd2>\n  movslq %eax,%r9\n  lea    0x0(,%r9,4),%r10\n  mov    (%r8,%r9,4),%r9d\n  and    $0x1,%r9d\n  cmp    $0x1,%r9d\n  lea    0x1(%rax),%r9d\n  adc    $0x0,%edx\n  cmp    %r9d,%esi\n  jle    11d2 <func0+0xd2>\n  mov    0x4(%r8,%r10,1),%r9d\n  and    $0x1,%r9d\n  cmp    $0x1,%r9d\n  adc    $0x0,%edx\n  add    $0x2,%eax\n  cmp    %esi,%eax\n  jge    11d2 <func0+0xd2>\n  mov    0x8(%r8,%r10,1),%eax\n  and    $0x1,%eax\n  cmp    $0x1,%eax\n  adc    $0x0,%edx\n  test   %ecx,%ecx\n  jle    12ad <func0+0x1ad>\n  test   %ecx,%ecx\n  mov    $0x1,%r9d\n  cmovg  %ecx,%r9d\n  cmp    $0x3,%ecx\n  jle    12e3 <func0+0x1e3>\n  mov    %r9d,%r8d\n  pxor   %xmm1,%xmm1\n  movdqa 0xe12(%rip),%xmm2        # 2010 <_fini+0xd24>\n  mov    %rdi,%rax\n  shr    $0x2,%r8d\n  movdqa %xmm1,%xmm3\n  sub    $0x1,%r8d\n  shl    $0x4,%r8\n  lea    0x10(%rdi,%r8,1),%r8\n  cs nopw 0x0(%rax,%rax,1)\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%r8\n  jne    1220 <func0+0x120>\n  movdqa %xmm1,%xmm0\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  add    %eax,%edx\n  mov    %r9d,%eax\n  and    $0xfffffffc,%eax\n  and    $0x3,%r9d\n  je     12ad <func0+0x1ad>\n  movslq %eax,%r8\n  lea    0x0(,%r8,4),%r9\n  mov    (%rdi,%r8,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  lea    0x1(%rax),%r8d\n  adc    $0x0,%edx\n  cmp    %r8d,%ecx\n  jle    12ad <func0+0x1ad>\n  mov    0x4(%rdi,%r9,1),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%edx\n  add    $0x2,%eax\n  cmp    %eax,%ecx\n  jle    12ad <func0+0x1ad>\n  mov    0x8(%rdi,%r9,1),%eax\n  and    $0x1,%eax\n  cmp    $0x1,%eax\n  adc    $0x0,%edx\n  cmp    %edx,%esi\n  lea    0xd4a(%rip),%rax        # 2000 <_fini+0xd14>\n  lea    0xd47(%rip),%rdx        # 2004 <_fini+0xd18>\n  cmovg  %rdx,%rax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %edx,%edx\n  test   %ecx,%ecx\n  jg     11da <func0+0xda>\n  lea    0xd27(%rip),%rax        # 2000 <_fini+0xd14>\n  ret\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    118a <func0+0x8a>\n  xor    %eax,%eax\n  jmp    1265 <func0+0x165>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  mov    %rdx,%rdi\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    L1\n  mov    %esi,%edx\n  pxor   %xmm1,%xmm1\n  movdqa D0(%rip),%xmm2\n  mov    %r8,%rax\n  shr    $0x2,%edx\n  movdqa %xmm1,%xmm3\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%r8,%rdx,1),%rdx\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%rdx\n  jne    L2\n  movdqa %xmm1,%xmm0\n  mov    %esi,%eax\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%eax\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%edx\n  test   $0x3,%sil\n  je     L3\nL8:\n  movslq %eax,%r9\n  lea    0x0(,%r9,4),%r10\n  mov    (%r8,%r9,4),%r9d\n  and    $0x1,%r9d\n  cmp    $0x1,%r9d\n  lea    0x1(%rax),%r9d\n  adc    $0x0,%edx\n  cmp    %r9d,%esi\n  jle    L3\n  mov    0x4(%r8,%r10,1),%r9d\n  and    $0x1,%r9d\n  cmp    $0x1,%r9d\n  adc    $0x0,%edx\n  add    $0x2,%eax\n  cmp    %esi,%eax\n  jge    L3\n  mov    0x8(%r8,%r10,1),%eax\n  and    $0x1,%eax\n  cmp    $0x1,%eax\n  adc    $0x0,%edx\nL3:\n  test   %ecx,%ecx\n  jle    L4\nL7:\n  test   %ecx,%ecx\n  mov    $0x1,%r9d\n  cmovg  %ecx,%r9d\n  cmp    $0x3,%ecx\n  jle    L5\n  mov    %r9d,%r8d\n  pxor   %xmm1,%xmm1\n  movdqa D0(%rip),%xmm2\n  mov    %rdi,%rax\n  shr    $0x2,%r8d\n  movdqa %xmm1,%xmm3\n  sub    $0x1,%r8d\n  shl    $0x4,%r8\n  lea    0x10(%rdi,%r8,1),%r8\n  cs nopw 0x0(%rax,%rax,1)\nL6:\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%r8\n  jne    L6\n  movdqa %xmm1,%xmm0\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  add    %eax,%edx\n  mov    %r9d,%eax\n  and    $0xfffffffc,%eax\n  and    $0x3,%r9d\n  je     L4\nL9:\n  movslq %eax,%r8\n  lea    0x0(,%r8,4),%r9\n  mov    (%rdi,%r8,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  lea    0x1(%rax),%r8d\n  adc    $0x0,%edx\n  cmp    %r8d,%ecx\n  jle    L4\n  mov    0x4(%rdi,%r9,1),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%edx\n  add    $0x2,%eax\n  cmp    %eax,%ecx\n  jle    L4\n  mov    0x8(%rdi,%r9,1),%eax\n  and    $0x1,%eax\n  cmp    $0x1,%eax\n  adc    $0x0,%edx\nL4:\n  cmp    %edx,%esi\n  lea    D1(%rip),%rax\n  lea    D2(%rip),%rdx\n  cmovg  %rdx,%rax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %edx,%edx\n  test   %ecx,%ecx\n  jg     L7\n  lea    D1(%rip),%rax\n  ret\nL1:\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    L8\nL5:\n  xor    %eax,%eax\n  jmp    L9",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8208,
          "bias": [
            3812,
            3602
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3402,
            3367
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8196,
          "bias": [
            3399
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4808
        },
        "L1": {
          "label": "L1",
          "addr": 4826
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        },
        "L3": {
          "label": "L3",
          "addr": 4562
        },
        "L4": {
          "label": "L4",
          "addr": 4781
        },
        "L5": {
          "label": "L5",
          "addr": 4835
        },
        "L6": {
          "label": "L6",
          "addr": 4640
        },
        "L7": {
          "label": "L7",
          "addr": 4570
        },
        "L8": {
          "label": "L8",
          "addr": 4490
        },
        "L9": {
          "label": "L9",
          "addr": 4709
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "594553004e4f0000000000000000000001000000010000000100000001000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"YES\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"NO\""
          },
          "0x2010": {
            "type": "byte[16]",
            "value": [
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(int *a, int n, int *b, int m) {\n  int i, cnt = 0;\n  for (i = 0; i < n; i++)\n    if (a[i] % 2 == 0)\n      cnt++;\n  for (i = 0; i < m; i++)\n    if (b[i] % 2 == 0)\n      cnt++;\n  if (cnt >= n)\n    return \"YES\";\n  else\n    return \"NO\";\n}"
    },
    {
      "task_id": 105,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x90,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %esi,-0x7c(%rbp)\n  mov    %rdx,-0x88(%rbp)\n  mov    %rcx,-0x90(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    0xe8d(%rip),%rax        # 2000 <_fini+0xc00>\n  mov    %rax,-0x60(%rbp)\n  lea    0xe83(%rip),%rax        # 2001 <_fini+0xc01>\n  mov    %rax,-0x58(%rbp)\n  lea    0xe7c(%rip),%rax        # 2005 <_fini+0xc05>\n  mov    %rax,-0x50(%rbp)\n  lea    0xe75(%rip),%rax        # 2009 <_fini+0xc09>\n  mov    %rax,-0x48(%rbp)\n  lea    0xe70(%rip),%rax        # 200f <_fini+0xc0f>\n  mov    %rax,-0x40(%rbp)\n  lea    0xe6a(%rip),%rax        # 2014 <_fini+0xc14>\n  mov    %rax,-0x38(%rbp)\n  lea    0xe64(%rip),%rax        # 2019 <_fini+0xc19>\n  mov    %rax,-0x30(%rbp)\n  lea    0xe5d(%rip),%rax        # 201d <_fini+0xc1d>\n  mov    %rax,-0x28(%rbp)\n  lea    0xe58(%rip),%rax        # 2023 <_fini+0xc23>\n  mov    %rax,-0x20(%rbp)\n  lea    0xe53(%rip),%rax        # 2029 <_fini+0xc29>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x6c(%rbp)\n  jmp    12a7 <func0+0x16e>\n  movl   $0x0,-0x68(%rbp)\n  jmp    1291 <func0+0x158>\n  mov    -0x68(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x78(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    128d <func0+0x154>\n  mov    -0x68(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x64(%rbp)\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x68(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x78(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x64(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x68(%rbp)\n  mov    -0x7c(%rbp),%eax\n  sub    -0x6c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x68(%rbp)\n  jl     11f2 <func0+0xb9>\n  addl   $0x1,-0x6c(%rbp)\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x6c(%rbp)\n  jl     11e6 <func0+0xad>\n  mov    -0x90(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x6c(%rbp)\n  jmp    131c <func0+0x1e3>\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    1318 <func0+0x1df>\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x9,%eax\n  jg     1318 <func0+0x1df>\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x90(%rbp),%rax\n  mov    %edx,(%rax)\n  subl   $0x1,-0x6c(%rbp)\n  cmpl   $0x0,-0x6c(%rbp)\n  jns    12ce <func0+0x195>\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x88(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x6c(%rbp)\n  movl   $0x0,-0x68(%rbp)\n  jmp    13cf <func0+0x296>\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    13cb <func0+0x292>\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x9,%eax\n  jg     13cb <func0+0x292>\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%rsi\n  mov    -0x68(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x68(%rbp)\n  cltq\n  shl    $0x3,%rax\n  lea    (%rsi,%rax,1),%rdx\n  movslq %ecx,%rax\n  mov    -0x60(%rbp,%rax,8),%rax\n  mov    %rax,(%rdx)\n  subl   $0x1,-0x6c(%rbp)\n  cmpl   $0x0,-0x6c(%rbp)\n  js     13e7 <func0+0x2ae>\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x68(%rbp)\n  jl     1358 <func0+0x21f>\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     13fc <func0+0x2c3>\n  call   1060 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x90,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %esi,-0x7c(%rbp)\n  mov    %rdx,-0x88(%rbp)\n  mov    %rcx,-0x90(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,-0x60(%rbp)\n  lea    D1(%rip),%rax\n  mov    %rax,-0x58(%rbp)\n  lea    D2(%rip),%rax\n  mov    %rax,-0x50(%rbp)\n  lea    D3(%rip),%rax\n  mov    %rax,-0x48(%rbp)\n  lea    D4(%rip),%rax\n  mov    %rax,-0x40(%rbp)\n  lea    D5(%rip),%rax\n  mov    %rax,-0x38(%rbp)\n  lea    D6(%rip),%rax\n  mov    %rax,-0x30(%rbp)\n  lea    D7(%rip),%rax\n  mov    %rax,-0x28(%rbp)\n  lea    D8(%rip),%rax\n  mov    %rax,-0x20(%rbp)\n  lea    D9(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x6c(%rbp)\n  jmp    L0\nL4:\n  movl   $0x0,-0x68(%rbp)\n  jmp    L1\nL3:\n  mov    -0x68(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x78(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L2\n  mov    -0x68(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x64(%rbp)\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x68(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x78(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x64(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  addl   $0x1,-0x68(%rbp)\nL1:\n  mov    -0x7c(%rbp),%eax\n  sub    -0x6c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x68(%rbp)\n  jl     L3\n  addl   $0x1,-0x6c(%rbp)\nL0:\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x6c(%rbp)\n  jl     L4\n  mov    -0x90(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x6c(%rbp)\n  jmp    L5\nL7:\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    L6\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x9,%eax\n  jg     L6\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x90(%rbp),%rax\n  mov    %edx,(%rax)\nL6:\n  subl   $0x1,-0x6c(%rbp)\nL5:\n  cmpl   $0x0,-0x6c(%rbp)\n  jns    L7\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x88(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x6c(%rbp)\n  movl   $0x0,-0x68(%rbp)\n  jmp    L8\nL11:\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    L9\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x9,%eax\n  jg     L9\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%rsi\n  mov    -0x68(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x68(%rbp)\n  cltq\n  shl    $0x3,%rax\n  lea    (%rsi,%rax,1),%rdx\n  movslq %ecx,%rax\n  mov    -0x60(%rbp,%rax,8),%rax\n  mov    %rax,(%rdx)\nL9:\n  subl   $0x1,-0x6c(%rbp)\nL8:\n  cmpl   $0x0,-0x6c(%rbp)\n  js     L10\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x68(%rbp)\n  jl     L11\nL10:\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     L12\n  call   <__stack_chk_fail@plt>\nL12:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3725
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8193,
          "bias": [
            3715
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8197,
          "bias": [
            3708
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8201,
          "bias": [
            3701
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8207,
          "bias": [
            3696
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8212,
          "bias": [
            3690
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8217,
          "bias": [
            3684
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8221,
          "bias": [
            3677
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8227,
          "bias": [
            3672
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8233,
          "bias": [
            3667
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4775
        },
        "L1": {
          "label": "L1",
          "addr": 4753
        },
        "L2": {
          "label": "L2",
          "addr": 4749
        },
        "L3": {
          "label": "L3",
          "addr": 4594
        },
        "L4": {
          "label": "L4",
          "addr": 4582
        },
        "L5": {
          "label": "L5",
          "addr": 4892
        },
        "L6": {
          "label": "L6",
          "addr": 4888
        },
        "L7": {
          "label": "L7",
          "addr": 4814
        },
        "L8": {
          "label": "L8",
          "addr": 5071
        },
        "L9": {
          "label": "L9",
          "addr": 5067
        },
        "L10": {
          "label": "L10",
          "addr": 5095
        },
        "L11": {
          "label": "L11",
          "addr": 4952
        },
        "L12": {
          "label": "L12",
          "addr": 5116
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "004f6e650054776f00546872656500466f757200466976650053697800536576656e004569676874004e696e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"\""
          },
          "0x2001": {
            "type": "string",
            "value": "\"One\""
          },
          "0x2023": {
            "type": "string",
            "value": "\"Eight\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"Two\""
          },
          "0x2009": {
            "type": "string",
            "value": "\"Three\""
          },
          "0x2029": {
            "type": "string",
            "value": "\"Nine\""
          },
          "0x200f": {
            "type": "string",
            "value": "\"Four\""
          },
          "0x2014": {
            "type": "string",
            "value": "\"Five\""
          },
          "0x2019": {
            "type": "string",
            "value": "\"Six\""
          },
          "0x201d": {
            "type": "string",
            "value": "\"Seven\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *a, int n, char ***p, int *sz) {\n  int i, j, t;\n  char *b[10] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n  for (i = 0; i < n - 1; i++)\n    for (j = 0; j < n - i - 1; j++)\n      if (a[j] > a[j + 1]) {\n        t = a[j];\n        a[j] = a[j + 1];\n        a[j + 1] = t;\n      }\n  *sz = 0;\n  for (i = n - 1; i >= 0; i--)\n    if (a[i] > 0 && a[i] < 10)\n      (*sz)++;\n  *p = (char **)malloc((*sz) * sizeof(char *));\n  for (i = n - 1, j = 0; i >= 0 && j < *sz; i--)\n    if (a[i] > 0 && a[i] < 10)\n      (*p)[j++] = b[a[i]];\n}"
    },
    {
      "task_id": 111,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xb0,%rsp\n  mov    %rdi,-0x98(%rbp)\n  mov    %rsi,-0xa0(%rbp)\n  mov    %rdx,-0xa8(%rbp)\n  mov    %rcx,-0xb0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0x70(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0xd,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x88(%rbp)\n  mov    -0x98(%rbp),%rax\n  mov    %rax,-0x78(%rbp)\n  movl   $0x0,-0x84(%rbp)\n  jmp    11dd <func0+0xc4>\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     11d8 <func0+0xbf>\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  mov    %eax,-0x7c(%rbp)\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    %edx,-0x70(%rbp,%rax,4)\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  cmp    %eax,-0x88(%rbp)\n  jge    11d8 <func0+0xbf>\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  mov    %eax,-0x88(%rbp)\n  addq   $0x1,-0x78(%rbp)\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1188 <func0+0x6f>\n  movl   $0x0,-0x80(%rbp)\n  jmp    124e <func0+0x135>\n  mov    -0x80(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0xa0(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x80(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  mov    %eax,(%rdx)\n  mov    -0x80(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  cmp    %eax,-0x88(%rbp)\n  jne    124a <func0+0x131>\n  mov    -0x80(%rbp),%eax\n  lea    0x61(%rax),%ecx\n  mov    -0x84(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x84(%rbp)\n  movslq %eax,%rdx\n  mov    -0xb0(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  addl   $0x1,-0x80(%rbp)\n  cmpl   $0x19,-0x80(%rbp)\n  jle    11f1 <func0+0xd8>\n  mov    -0xa8(%rbp),%rax\n  mov    -0x88(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x84(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xb0(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     128e <func0+0x175>\n  call   1050 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xb0,%rsp\n  mov    %rdi,-0x98(%rbp)\n  mov    %rsi,-0xa0(%rbp)\n  mov    %rdx,-0xa8(%rbp)\n  mov    %rcx,-0xb0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0x70(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0xd,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x88(%rbp)\n  mov    -0x98(%rbp),%rax\n  mov    %rax,-0x78(%rbp)\n  movl   $0x0,-0x84(%rbp)\n  jmp    L0\nL2:\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L1\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  mov    %eax,-0x7c(%rbp)\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    %edx,-0x70(%rbp,%rax,4)\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  cmp    %eax,-0x88(%rbp)\n  jge    L1\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  mov    %eax,-0x88(%rbp)\nL1:\n  addq   $0x1,-0x78(%rbp)\nL0:\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\n  movl   $0x0,-0x80(%rbp)\n  jmp    L3\nL5:\n  mov    -0x80(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0xa0(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x80(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  mov    %eax,(%rdx)\n  mov    -0x80(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  cmp    %eax,-0x88(%rbp)\n  jne    L4\n  mov    -0x80(%rbp),%eax\n  lea    0x61(%rax),%ecx\n  mov    -0x84(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x84(%rbp)\n  movslq %eax,%rdx\n  mov    -0xb0(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\nL4:\n  addl   $0x1,-0x80(%rbp)\nL3:\n  cmpl   $0x19,-0x80(%rbp)\n  jle    L5\n  mov    -0xa8(%rbp),%rax\n  mov    -0x88(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x84(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xb0(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     L6\n  call   <__stack_chk_fail@plt>\nL6:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4573
        },
        "L1": {
          "label": "L1",
          "addr": 4568
        },
        "L2": {
          "label": "L2",
          "addr": 4488
        },
        "L3": {
          "label": "L3",
          "addr": 4686
        },
        "L4": {
          "label": "L4",
          "addr": 4682
        },
        "L5": {
          "label": "L5",
          "addr": 4593
        },
        "L6": {
          "label": "L6",
          "addr": 4750
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s, int *a, int *max, char *c) {\n  int i, j, m, n;\n  int b[26] = {0};\n  m = 0;\n  for (n = 0, i = 0; *(s + i) != '\\0'; i++) {\n    if (*(s + i) != ' ') {\n      j = *(s + i) - 'a';\n      b[j]++;\n      if (b[j] > m)\n        m = b[j];\n    }\n  }\n  for (j = 0; j < 26; j++) {\n    a[j] = b[j];\n    if (b[j] == m)\n      c[n++] = j + 'a';\n  }\n  *max = m;\n  c[n] = '\\0';\n}"
    },
    {
      "task_id": 107,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  movq   $0x0,(%rax)\n  test   %ebx,%ebx\n  jle    1183 <func0+0x63>\n  lea    0x1(%rbx),%r10d\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%r8d\n  nopl   0x0(%rax)\n  mov    %r9d,%ecx\n  xor    %esi,%esi\n  nopl   (%rax)\n  mov    %ecx,%edx\n  lea    (%rsi,%rsi,4),%edi\n  imul   %r8,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%esi\n  add    %esi,%esi\n  sub    %esi,%ecx\n  lea    (%rcx,%rdi,2),%esi\n  mov    %edx,%ecx\n  test   %edx,%edx\n  jne    1158 <func0+0x38>\n  cmp    %esi,%r9d\n  je     1188 <func0+0x68>\n  add    $0x1,%r9d\n  cmp    %r9d,%r10d\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret\n  nopl   (%rax)\n  test   $0x1,%r9b\n  jne    1198 <func0+0x78>\n  addl   $0x1,(%rax)\n  jmp    117a <func0+0x5a>\n  nopl   0x0(%rax,%rax,1)\n  addl   $0x1,0x4(%rax)\n  jmp    117a <func0+0x5a>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  movq   $0x0,(%rax)\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r10d\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%r8d\n  nopl   0x0(%rax)\nL3:\n  mov    %r9d,%ecx\n  xor    %esi,%esi\n  nopl   (%rax)\nL1:\n  mov    %ecx,%edx\n  lea    (%rsi,%rsi,4),%edi\n  imul   %r8,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%esi\n  add    %esi,%esi\n  sub    %esi,%ecx\n  lea    (%rcx,%rdi,2),%esi\n  mov    %edx,%ecx\n  test   %edx,%edx\n  jne    L1\n  cmp    %esi,%r9d\n  je     L2\nL5:\n  add    $0x1,%r9d\n  cmp    %r9d,%r10d\n  jne    L3\nL0:\n  pop    %rbx\n  ret\n  nopl   (%rax)\nL2:\n  test   $0x1,%r9b\n  jne    L4\n  addl   $0x1,(%rax)\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL4:\n  addl   $0x1,0x4(%rax)\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4483
        },
        "L1": {
          "label": "L1",
          "addr": 4440
        },
        "L2": {
          "label": "L2",
          "addr": 4488
        },
        "L3": {
          "label": "L3",
          "addr": 4432
        },
        "L4": {
          "label": "L4",
          "addr": 4504
        },
        "L5": {
          "label": "L5",
          "addr": 4474
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void *func0(void *arg) {\n  int *ret = malloc(sizeof(int) * 2);\n  ret[0] = 0;\n  ret[1] = 0;\n  int i, j;\n  for (i = 1; i <= (int)arg; i++) {\n    int tmp = i;\n    int sum = 0;\n    while (tmp) {\n      sum += tmp % 10;\n      tmp /= 10;\n      tmp *= 10;\n    }\n    if (sum == i) {\n      if (i % 2 == 0)\n        ret[0]++;\n      else\n        ret[1]++;\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 111,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r9\n  mov    %rcx,%r10\n  mov    $0xd,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r8\n  mov    %rdx,%r11\n  mov    %r8,%rdi\n  rep stos %rax,%es:(%rdi)\n  movsbl (%r9),%eax\n  test   %al,%al\n  je     11eb <func0+0xcb>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x20,%al\n  je     11d8 <func0+0xb8>\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  cmp    %edx,%ecx\n  mov    %edx,(%rsp,%rax,4)\n  cmovl  %edx,%ecx\n  movsbl 0x1(%r9),%eax\n  add    $0x1,%r9\n  test   %al,%al\n  jne    1160 <func0+0x40>\n  xor    %eax,%eax\n  xor    %edi,%edi\n  nopl   0x0(%rax,%rax,1)\n  mov    (%r8,%rax,4),%edx\n  mov    %edx,(%rsi,%rax,4)\n  cmp    %ecx,%edx\n  jne    11a9 <func0+0x89>\n  movslq %edi,%rdx\n  lea    0x61(%rax),%r9d\n  add    $0x1,%edi\n  mov    %r9b,(%r10,%rdx,1)\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  jne    1190 <func0+0x70>\n  movslq %edi,%rdi\n  mov    %ecx,(%r11)\n  movb   $0x0,(%r10,%rdi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11ef <func0+0xcf>\n  add    $0x78,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\n  movsbl 0x1(%r9),%eax\n  add    $0x1,%r9\n  test   %al,%al\n  jne    1160 <func0+0x40>\n  jmp    1184 <func0+0x64>\n  xor    %ecx,%ecx\n  jmp    1184 <func0+0x64>\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r9\n  mov    %rcx,%r10\n  mov    $0xd,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r8\n  mov    %rdx,%r11\n  mov    %r8,%rdi\n  rep stos %rax,%es:(%rdi)\n  movsbl (%r9),%eax\n  test   %al,%al\n  je     L0\n  nopl   0x0(%rax,%rax,1)\nL2:\n  cmp    $0x20,%al\n  je     L1\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  cmp    %edx,%ecx\n  mov    %edx,(%rsp,%rax,4)\n  cmovl  %edx,%ecx\n  movsbl 0x1(%r9),%eax\n  add    $0x1,%r9\n  test   %al,%al\n  jne    L2\nL6:\n  xor    %eax,%eax\n  xor    %edi,%edi\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    (%r8,%rax,4),%edx\n  mov    %edx,(%rsi,%rax,4)\n  cmp    %ecx,%edx\n  jne    L3\n  movslq %edi,%rdx\n  lea    0x61(%rax),%r9d\n  add    $0x1,%edi\n  mov    %r9b,(%r10,%rdx,1)\nL3:\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  jne    L4\n  movslq %edi,%rdi\n  mov    %ecx,(%r11)\n  movb   $0x0,(%r10,%rdi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  add    $0x78,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  movsbl 0x1(%r9),%eax\n  add    $0x1,%r9\n  test   %al,%al\n  jne    L2\n  jmp    L6\nL0:\n  xor    %ecx,%ecx\n  jmp    L6\nL5:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4587
        },
        "L1": {
          "label": "L1",
          "addr": 4568
        },
        "L2": {
          "label": "L2",
          "addr": 4448
        },
        "L3": {
          "label": "L3",
          "addr": 4521
        },
        "L4": {
          "label": "L4",
          "addr": 4496
        },
        "L5": {
          "label": "L5",
          "addr": 4591
        },
        "L6": {
          "label": "L6",
          "addr": 4484
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, int *b, int *c, char *d) {\n  int i, j, k, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  int arr[26];\n  for (i = 0; i < 26; i++)\n    arr[i] = 0;\n  for (i = 0; a[i] != '\\0'; i++) {\n    if (a[i] == ' ')\n      continue;\n    j = a[i] - 'a';\n    arr[j]++;\n    if (arr[j] > m)\n      m = arr[j];\n  }\n  for (i = 0; i < 26; i++) {\n    b[i] = arr[i];\n    if (arr[i] == m) {\n      d[k++] = i + 'a';\n    }\n  }\n  *c = m;\n  d[k] = '\\0';\n}"
    },
    {
      "task_id": 111,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r8\n  mov    %rcx,%r10\n  mov    $0xd,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r9\n  mov    %rdx,%r11\n  mov    %r9,%rdi\n  rep stos %rax,%es:(%rdi)\n  movsbl (%r8),%eax\n  test   %al,%al\n  je     11d3 <func0+0xb3>\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x20,%al\n  je     1177 <func0+0x57>\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  cmp    %edx,%ecx\n  mov    %edx,(%rsp,%rax,4)\n  cmovl  %edx,%ecx\n  movsbl 0x1(%r8),%eax\n  add    $0x1,%r8\n  test   %al,%al\n  jne    1160 <func0+0x40>\n  mov    (%rsp),%edx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    1194 <func0+0x74>\n  nopl   (%rax)\n  mov    (%r9,%rax,4),%edx\n  mov    %edx,(%rsi,%rax,4)\n  cmp    %edx,%ecx\n  jne    11a9 <func0+0x89>\n  movslq %edi,%rdx\n  lea    0x61(%rax),%r8d\n  add    $0x1,%edi\n  mov    %r8b,(%r10,%rdx,1)\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  jne    1190 <func0+0x70>\n  movslq %edi,%rdi\n  mov    %ecx,(%r11)\n  movb   $0x0,(%r10,%rdi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11d9 <func0+0xb9>\n  add    $0x78,%rsp\n  ret\n  xor    %edx,%edx\n  xor    %ecx,%ecx\n  jmp    1187 <func0+0x67>\n  call   1050 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r8\n  mov    %rcx,%r10\n  mov    $0xd,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r9\n  mov    %rdx,%r11\n  mov    %r9,%rdi\n  rep stos %rax,%es:(%rdi)\n  movsbl (%r8),%eax\n  test   %al,%al\n  je     L0\n  nopw   0x0(%rax,%rax,1)\nL2:\n  cmp    $0x20,%al\n  je     L1\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  cmp    %edx,%ecx\n  mov    %edx,(%rsp,%rax,4)\n  cmovl  %edx,%ecx\nL1:\n  movsbl 0x1(%r8),%eax\n  add    $0x1,%r8\n  test   %al,%al\n  jne    L2\n  mov    (%rsp),%edx\nL7:\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    L3\n  nopl   (%rax)\nL5:\n  mov    (%r9,%rax,4),%edx\nL3:\n  mov    %edx,(%rsi,%rax,4)\n  cmp    %edx,%ecx\n  jne    L4\n  movslq %edi,%rdx\n  lea    0x61(%rax),%r8d\n  add    $0x1,%edi\n  mov    %r8b,(%r10,%rdx,1)\nL4:\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  jne    L5\n  movslq %edi,%rdi\n  mov    %ecx,(%r11)\n  movb   $0x0,(%r10,%rdi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x78,%rsp\n  ret\nL0:\n  xor    %edx,%edx\n  xor    %ecx,%ecx\n  jmp    L7\nL6:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4563
        },
        "L1": {
          "label": "L1",
          "addr": 4471
        },
        "L2": {
          "label": "L2",
          "addr": 4448
        },
        "L3": {
          "label": "L3",
          "addr": 4500
        },
        "L4": {
          "label": "L4",
          "addr": 4521
        },
        "L5": {
          "label": "L5",
          "addr": 4496
        },
        "L6": {
          "label": "L6",
          "addr": 4569
        },
        "L7": {
          "label": "L7",
          "addr": 4487
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, int *b, int *c, char *d) {\n  int i, j, k, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n  int arr[26];\n  for (i = 0; i < 26; i++)\n    arr[i] = 0;\n  for (i = 0; a[i] != '\\0'; i++) {\n    if (a[i] != ' ') {\n      arr[a[i] - 'a']++;\n      if (arr[a[i] - 'a'] > m)\n        m = arr[a[i] - 'a'];\n    }\n  }\n  for (i = 0; i < 26; i++) {\n    b[i] = arr[i];\n    if (arr[i] == m) {\n      d[j++] = i + 'a';\n    }\n  }\n  *c = m;\n  d[j] = '\\0';\n}"
    },
    {
      "task_id": 114,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    (%rdi),%rax\n  cmp    $0x1,%esi\n  jle    1133 <func0+0x3a>\n  lea    0x8(%rdi),%rdx\n  lea    -0x2(%rsi),%ecx\n  lea    0x10(%rdi,%rcx,8),%rsi\n  mov    %rax,%rcx\n  jmp    1129 <func0+0x30>\n  mov    (%rdx),%rax\n  cmp    %rax,%rcx\n  cmovg  %rax,%rcx\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  je     1136 <func0+0x3d>\n  test   %rax,%rax\n  jns    1116 <func0+0x1d>\n  add    (%rdx),%rax\n  jmp    1119 <func0+0x20>\n  mov    %rax,%rcx\n  mov    %rcx,%rax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    (%rdi),%rax\n  cmp    $0x1,%esi\n  jle    L0\n  lea    0x8(%rdi),%rdx\n  lea    -0x2(%rsi),%ecx\n  lea    0x10(%rdi,%rcx,8),%rsi\n  mov    %rax,%rcx\n  jmp    L1\nL3:\n  mov    (%rdx),%rax\nL4:\n  cmp    %rax,%rcx\n  cmovg  %rax,%rcx\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  je     L2\nL1:\n  test   %rax,%rax\n  jns    L3\n  add    (%rdx),%rax\n  jmp    L4\nL0:\n  mov    %rax,%rcx\nL2:\n  mov    %rcx,%rax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4403
        },
        "L1": {
          "label": "L1",
          "addr": 4393
        },
        "L2": {
          "label": "L2",
          "addr": 4406
        },
        "L3": {
          "label": "L3",
          "addr": 4374
        },
        "L4": {
          "label": "L4",
          "addr": 4377
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " long func0(long p[], int n) {\n  long x = p[0];\n  int i;\n  for (i = 1; i < n; i++)\n    if (x < 0)\n      x += p[i];\n    else if (x > p[i])\n      x = p[i];\n  return x;\n}"
    },
    {
      "task_id": 114,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    117f <func0+0x86>\n  cmpq   $0x0,-0x10(%rbp)\n  jns    114e <func0+0x55>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  jmp    1165 <func0+0x6c>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  cmp    -0x8(%rbp),%rax\n  jge    117b <func0+0x82>\n  mov    -0x10(%rbp),%rax\n  mov    %rax,-0x8(%rbp)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1127 <func0+0x2e>\n  mov    -0x8(%rbp),%rax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    L0\nL4:\n  cmpq   $0x0,-0x10(%rbp)\n  jns    L1\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  jmp    L2\nL1:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\nL2:\n  mov    %rax,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  cmp    -0x8(%rbp),%rax\n  jge    L3\n  mov    -0x10(%rbp),%rax\n  mov    %rax,-0x8(%rbp)\nL3:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L4\n  mov    -0x8(%rbp),%rax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4479
        },
        "L1": {
          "label": "L1",
          "addr": 4430
        },
        "L2": {
          "label": "L2",
          "addr": 4453
        },
        "L3": {
          "label": "L3",
          "addr": 4475
        },
        "L4": {
          "label": "L4",
          "addr": 4391
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " long func0(long *p, int c) {\n  int i;\n  long r = *p;\n  long s = *p;\n  for (i = 1; i < c; i++) {\n    r = (r < 0) ? r + p[i] : p[i];\n    if (r < s)\n      s = r;\n  }\n  return s;\n}"
    },
    {
      "task_id": 105,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rcx,%r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  lea    0xeb3(%rip),%rbx        # 200d <_fini+0xcfd>\n  movq   %rbx,%xmm0\n  lea    0xe9e(%rip),%rbx        # 2004 <_fini+0xcf4>\n  sub    $0x68,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  lea    0xe81(%rip),%rax        # 2000 <_fini+0xcf0>\n  movq   %rax,%xmm3\n  lea    0xe7d(%rip),%rax        # 2008 <_fini+0xcf8>\n  punpcklqdq %xmm3,%xmm0\n  movq   %rax,%xmm4\n  lea    0xe78(%rip),%rax        # 2013 <_fini+0xd03>\n  movaps %xmm0,(%rsp)\n  movq   %rbx,%xmm0\n  lea    0xe63(%rip),%rbx        # 200e <_fini+0xcfe>\n  movq   %rax,%xmm5\n  punpcklqdq %xmm4,%xmm0\n  lea    0xe61(%rip),%rax        # 201c <_fini+0xd0c>\n  movaps %xmm0,0x10(%rsp)\n  movq   %rbx,%xmm0\n  movq   %rax,%xmm6\n  lea    0xe47(%rip),%rbx        # 2018 <_fini+0xd08>\n  punpcklqdq %xmm5,%xmm0\n  lea    0xe4c(%rip),%rax        # 2028 <_fini+0xd18>\n  movaps %xmm0,0x20(%rsp)\n  movq   %rbx,%xmm0\n  movq   %rax,%xmm7\n  lea    0xe30(%rip),%rbx        # 2022 <_fini+0xd12>\n  punpcklqdq %xmm6,%xmm0\n  movaps %xmm0,0x30(%rsp)\n  movq   %rbx,%xmm0\n  lea    -0x1(%rsi),%ebx\n  punpcklqdq %xmm7,%xmm0\n  movaps %xmm0,0x40(%rsp)\n  test   %ebx,%ebx\n  jle    12f2 <func0+0x1b2>\n  mov    %ebx,%eax\n  lea    0x4(%rdi),%r8\n  nopw   0x0(%rax,%rax,1)\n  sub    $0x1,%eax\n  mov    %rbp,%rdx\n  mov    %rax,%rdi\n  lea    (%r8,%rax,4),%rsi\n  nopl   (%rax)\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    124e <func0+0x10e>\n  movq   %xmm1,(%rdx)\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    1230 <func0+0xf0>\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    1220 <func0+0xe0>\n  movl   $0x0,0x0(%r13)\n  movslq %ebx,%rbx\n  xor    %ecx,%ecx\n  mov    %rbx,%rax\n  nopl   (%rax)\n  mov    0x0(%rbp,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     1283 <func0+0x143>\n  add    $0x1,%ecx\n  mov    %ecx,0x0(%r13)\n  sub    $0x1,%rax\n  test   %eax,%eax\n  jns    1270 <func0+0x130>\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,8),%rdi\n  call   1070 <malloc@plt>\n  mov    0x0(%r13),%edi\n  xor    %ecx,%ecx\n  mov    %rax,(%r12)\n  jmp    12d3 <func0+0x193>\n  nopw   0x0(%rax,%rax,1)\n  movslq 0x0(%rbp,%rbx,4),%rdx\n  lea    -0x1(%rdx),%esi\n  cmp    $0x8,%esi\n  ja     12cb <func0+0x18b>\n  mov    (%rsp,%rdx,8),%rdx\n  movslq %ecx,%rsi\n  add    $0x1,%ecx\n  mov    %rdx,(%rax,%rsi,8)\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     12d7 <func0+0x197>\n  cmp    %ecx,%edi\n  jg     12b0 <func0+0x170>\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    130b <func0+0x1cb>\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  movl   $0x0,(%rcx)\n  je     1265 <func0+0x125>\n  xor    %edi,%edi\n  call   1070 <malloc@plt>\n  mov    %rax,(%r12)\n  jmp    12d7 <func0+0x197>\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rcx,%r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  lea    D0(%rip),%rbx\n  movq   %rbx,%xmm0\n  lea    D1(%rip),%rbx\n  sub    $0x68,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  lea    D2(%rip),%rax\n  movq   %rax,%xmm3\n  lea    D3(%rip),%rax\n  punpcklqdq %xmm3,%xmm0\n  movq   %rax,%xmm4\n  lea    D4(%rip),%rax\n  movaps %xmm0,(%rsp)\n  movq   %rbx,%xmm0\n  lea    D5(%rip),%rbx\n  movq   %rax,%xmm5\n  punpcklqdq %xmm4,%xmm0\n  lea    D6(%rip),%rax\n  movaps %xmm0,0x10(%rsp)\n  movq   %rbx,%xmm0\n  movq   %rax,%xmm6\n  lea    D7(%rip),%rbx\n  punpcklqdq %xmm5,%xmm0\n  lea    D8(%rip),%rax\n  movaps %xmm0,0x20(%rsp)\n  movq   %rbx,%xmm0\n  movq   %rax,%xmm7\n  lea    D9(%rip),%rbx\n  punpcklqdq %xmm6,%xmm0\n  movaps %xmm0,0x30(%rsp)\n  movq   %rbx,%xmm0\n  lea    -0x1(%rsi),%ebx\n  punpcklqdq %xmm7,%xmm0\n  movaps %xmm0,0x40(%rsp)\n  test   %ebx,%ebx\n  jle    L0\n  mov    %ebx,%eax\n  lea    0x4(%rdi),%r8\n  nopw   0x0(%rax,%rax,1)\nL3:\n  sub    $0x1,%eax\n  mov    %rbp,%rdx\n  mov    %rax,%rdi\n  lea    (%r8,%rax,4),%rsi\n  nopl   (%rax)\nL2:\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    L1\n  movq   %xmm1,(%rdx)\nL1:\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    L2\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    L3\n  movl   $0x0,0x0(%r13)\nL11:\n  movslq %ebx,%rbx\n  xor    %ecx,%ecx\n  mov    %rbx,%rax\n  nopl   (%rax)\nL5:\n  mov    0x0(%rbp,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     L4\n  add    $0x1,%ecx\n  mov    %ecx,0x0(%r13)\nL4:\n  sub    $0x1,%rax\n  test   %eax,%eax\n  jns    L5\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,8),%rdi\n  call   <malloc@plt>\n  mov    0x0(%r13),%edi\n  xor    %ecx,%ecx\n  mov    %rax,(%r12)\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL9:\n  movslq 0x0(%rbp,%rbx,4),%rdx\n  lea    -0x1(%rdx),%esi\n  cmp    $0x8,%esi\n  ja     L7\n  mov    (%rsp,%rdx,8),%rdx\n  movslq %ecx,%rsi\n  add    $0x1,%ecx\n  mov    %rdx,(%rax,%rsi,8)\nL7:\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     L8\nL6:\n  cmp    %ecx,%edi\n  jg     L9\nL8:\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L10\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL0:\n  movl   $0x0,(%rcx)\n  je     L11\n  xor    %edi,%edi\n  call   <malloc@plt>\n  mov    %rax,(%r12)\n  jmp    L8\nL10:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8205,
          "bias": [
            3763
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3742
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8192,
          "bias": [
            3713
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8200,
          "bias": [
            3709
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8211,
          "bias": [
            3704
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8206,
          "bias": [
            3683
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8220,
          "bias": [
            3681
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8216,
          "bias": [
            3655
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8232,
          "bias": [
            3660
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8226,
          "bias": [
            3632
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4850
        },
        "L1": {
          "label": "L1",
          "addr": 4686
        },
        "L2": {
          "label": "L2",
          "addr": 4656
        },
        "L3": {
          "label": "L3",
          "addr": 4640
        },
        "L4": {
          "label": "L4",
          "addr": 4739
        },
        "L5": {
          "label": "L5",
          "addr": 4720
        },
        "L6": {
          "label": "L6",
          "addr": 4819
        },
        "L7": {
          "label": "L7",
          "addr": 4811
        },
        "L8": {
          "label": "L8",
          "addr": 4823
        },
        "L9": {
          "label": "L9",
          "addr": 4784
        },
        "L10": {
          "label": "L10",
          "addr": 4875
        },
        "L11": {
          "label": "L11",
          "addr": 4709
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4f6e650054776f00546872656500466f757200466976650053697800536576656e004569676874004e696e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"One\""
          },
          "0x2022": {
            "type": "string",
            "value": "\"Eight\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"Two\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"Three\""
          },
          "0x2028": {
            "type": "string",
            "value": "\"Nine\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"\""
          },
          "0x200e": {
            "type": "string",
            "value": "\"Four\""
          },
          "0x2013": {
            "type": "string",
            "value": "\"Five\""
          },
          "0x2018": {
            "type": "string",
            "value": "\"Six\""
          },
          "0x201c": {
            "type": "string",
            "value": "\"Seven\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *a, int n, char ***b, int *m) {\n  int i, j, t;\n  char *c[10] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n  for (i = 0; i < n - 1; i++)\n    for (j = 0; j < n - i - 1; j++)\n      if (a[j] > a[j + 1]) {\n        t = a[j];\n        a[j] = a[j + 1];\n        a[j + 1] = t;\n      }\n  for (*m = 0, i = n - 1; i >= 0; i--)\n    if (a[i] > 0 && a[i] < 10)\n      (*m)++;\n  *b = (char **)malloc((*m) * sizeof(char *));\n  for (i = n - 1, j = 0; i >= 0 && j < *m; i--)\n    if (a[i] > 0 && a[i] < 10)\n      (*b)[j++] = c[a[i]];\n}"
    },
    {
      "task_id": 105,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rcx,%r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  lea    -0x1(%rsi),%ebx\n  sub    $0x68,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  lea    0xe9e(%rip),%rax        # 200d <_fini+0xd3d>\n  mov    %rax,(%rsp)\n  lea    0xe86(%rip),%rax        # 2000 <_fini+0xd30>\n  mov    %rax,0x8(%rsp)\n  lea    0xe7e(%rip),%rax        # 2004 <_fini+0xd34>\n  mov    %rax,0x10(%rsp)\n  lea    0xe76(%rip),%rax        # 2008 <_fini+0xd38>\n  mov    %rax,0x18(%rsp)\n  lea    0xe70(%rip),%rax        # 200e <_fini+0xd3e>\n  mov    %rax,0x20(%rsp)\n  lea    0xe69(%rip),%rax        # 2013 <_fini+0xd43>\n  mov    %rax,0x28(%rsp)\n  lea    0xe62(%rip),%rax        # 2018 <_fini+0xd48>\n  mov    %rax,0x30(%rsp)\n  lea    0xe5a(%rip),%rax        # 201c <_fini+0xd4c>\n  mov    %rax,0x38(%rsp)\n  lea    0xe54(%rip),%rax        # 2022 <_fini+0xd52>\n  mov    %rax,0x40(%rsp)\n  lea    0xe4e(%rip),%rax        # 2028 <_fini+0xd58>\n  mov    %rax,0x48(%rsp)\n  test   %ebx,%ebx\n  jle    12b2 <func0+0x172>\n  mov    %ebx,%edx\n  lea    0x4(%rdi),%r8\n  nopl   (%rax)\n  sub    $0x1,%edx\n  mov    %rbp,%rax\n  mov    %rdx,%rdi\n  lea    (%r8,%rdx,4),%rsi\n  nopl   (%rax)\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    120e <func0+0xce>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    1200 <func0+0xc0>\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    11f0 <func0+0xb0>\n  movl   $0x0,0x0(%r13)\n  movslq %ebx,%rbx\n  xor    %ecx,%ecx\n  mov    %rbx,%rax\n  nopl   (%rax)\n  mov    0x0(%rbp,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     1243 <func0+0x103>\n  add    $0x1,%ecx\n  mov    %ecx,0x0(%r13)\n  sub    $0x1,%rax\n  test   %eax,%eax\n  jns    1230 <func0+0xf0>\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,8),%rdi\n  call   1070 <malloc@plt>\n  mov    0x0(%r13),%edi\n  xor    %ecx,%ecx\n  mov    %rax,(%r12)\n  jmp    1293 <func0+0x153>\n  nopw   0x0(%rax,%rax,1)\n  movslq 0x0(%rbp,%rbx,4),%rdx\n  lea    -0x1(%rdx),%esi\n  cmp    $0x8,%esi\n  ja     128b <func0+0x14b>\n  mov    (%rsp,%rdx,8),%rdx\n  movslq %ecx,%rsi\n  add    $0x1,%ecx\n  mov    %rdx,(%rax,%rsi,8)\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     1297 <func0+0x157>\n  cmp    %ecx,%edi\n  jg     1270 <func0+0x130>\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12cb <func0+0x18b>\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  movl   $0x0,(%rcx)\n  je     1225 <func0+0xe5>\n  xor    %edi,%edi\n  call   1070 <malloc@plt>\n  mov    %rax,(%r12)\n  jmp    1297 <func0+0x157>\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rcx,%r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  lea    -0x1(%rsi),%ebx\n  sub    $0x68,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  lea    D0(%rip),%rax\n  mov    %rax,(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x8(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x10(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x18(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x20(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x28(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x30(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  test   %ebx,%ebx\n  jle    L0\n  mov    %ebx,%edx\n  lea    0x4(%rdi),%r8\n  nopl   (%rax)\nL3:\n  sub    $0x1,%edx\n  mov    %rbp,%rax\n  mov    %rdx,%rdi\n  lea    (%r8,%rdx,4),%rsi\n  nopl   (%rax)\nL2:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L1\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\nL1:\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    L2\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    L3\n  movl   $0x0,0x0(%r13)\nL11:\n  movslq %ebx,%rbx\n  xor    %ecx,%ecx\n  mov    %rbx,%rax\n  nopl   (%rax)\nL5:\n  mov    0x0(%rbp,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     L4\n  add    $0x1,%ecx\n  mov    %ecx,0x0(%r13)\nL4:\n  sub    $0x1,%rax\n  test   %eax,%eax\n  jns    L5\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,8),%rdi\n  call   <malloc@plt>\n  mov    0x0(%r13),%edi\n  xor    %ecx,%ecx\n  mov    %rax,(%r12)\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL9:\n  movslq 0x0(%rbp,%rbx,4),%rdx\n  lea    -0x1(%rdx),%esi\n  cmp    $0x8,%esi\n  ja     L7\n  mov    (%rsp,%rdx,8),%rdx\n  movslq %ecx,%rsi\n  add    $0x1,%ecx\n  mov    %rdx,(%rax,%rsi,8)\nL7:\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     L8\nL6:\n  cmp    %ecx,%edi\n  jg     L9\nL8:\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L10\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL0:\n  movl   $0x0,(%rcx)\n  je     L11\n  xor    %edi,%edi\n  call   <malloc@plt>\n  mov    %rax,(%r12)\n  jmp    L8\nL10:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8205,
          "bias": [
            3742
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3718
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8196,
          "bias": [
            3710
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8200,
          "bias": [
            3702
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8206,
          "bias": [
            3696
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8211,
          "bias": [
            3689
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8216,
          "bias": [
            3682
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8220,
          "bias": [
            3674
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8226,
          "bias": [
            3668
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8232,
          "bias": [
            3662
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4786
        },
        "L1": {
          "label": "L1",
          "addr": 4622
        },
        "L2": {
          "label": "L2",
          "addr": 4608
        },
        "L3": {
          "label": "L3",
          "addr": 4592
        },
        "L4": {
          "label": "L4",
          "addr": 4675
        },
        "L5": {
          "label": "L5",
          "addr": 4656
        },
        "L6": {
          "label": "L6",
          "addr": 4755
        },
        "L7": {
          "label": "L7",
          "addr": 4747
        },
        "L8": {
          "label": "L8",
          "addr": 4759
        },
        "L9": {
          "label": "L9",
          "addr": 4720
        },
        "L10": {
          "label": "L10",
          "addr": 4811
        },
        "L11": {
          "label": "L11",
          "addr": 4645
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4f6e650054776f00546872656500466f757200466976650053697800536576656e004569676874004e696e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"One\""
          },
          "0x2022": {
            "type": "string",
            "value": "\"Eight\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"Two\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"Three\""
          },
          "0x2028": {
            "type": "string",
            "value": "\"Nine\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"\""
          },
          "0x200e": {
            "type": "string",
            "value": "\"Four\""
          },
          "0x2013": {
            "type": "string",
            "value": "\"Five\""
          },
          "0x2018": {
            "type": "string",
            "value": "\"Six\""
          },
          "0x201c": {
            "type": "string",
            "value": "\"Seven\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *a, int n, char ***p, int *m) {\n  int i, j, t;\n  char *b[10] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n  for (i = 0; i < n - 1; i++)\n    for (j = 0; j < n - i - 1; j++)\n      if (a[j] > a[j + 1]) {\n        t = a[j];\n        a[j] = a[j + 1];\n        a[j + 1] = t;\n      }\n  for (*m = 0, i = n - 1; i >= 0; i--)\n    if (a[i] > 0 && a[i] < 10)\n      (*m)++;\n  *p = (char **)malloc((*m) * sizeof(char *));\n  for (i = n - 1, j = 0; i >= 0 && j < *m; i--)\n    if (a[i] > 0 && a[i] < 10)\n      (*p)[j++] = b[a[i]];\n}"
    },
    {
      "task_id": 114,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    (%rdi),%rax\n  cmp    $0x1,%esi\n  jle    1148 <func0+0x48>\n  lea    -0x2(%rsi),%ecx\n  lea    0x8(%rdi),%rdx\n  mov    %rax,%r8\n  lea    0x10(%rdi,%rcx,8),%rdi\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdx),%rcx\n  test   %rax,%rax\n  lea    (%rax,%rcx,1),%rsi\n  mov    %rcx,%rax\n  cmovs  %rsi,%rax\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rdi,%rdx\n  jne    1120 <func0+0x20>\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\n  mov    %rax,%r8\n  mov    %r8,%rax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    (%rdi),%rax\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%ecx\n  lea    0x8(%rdi),%rdx\n  mov    %rax,%r8\n  lea    0x10(%rdi,%rcx,8),%rdi\n  nopl   0x0(%rax,%rax,1)\nL1:\n  mov    (%rdx),%rcx\n  test   %rax,%rax\n  lea    (%rax,%rcx,1),%rsi\n  mov    %rcx,%rax\n  cmovs  %rsi,%rax\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rdi,%rdx\n  jne    L1\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\nL0:\n  mov    %rax,%r8\n  mov    %r8,%rax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4424
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " long func0(long p[], int n) {\n  long z = p[0];\n  int i;\n  for (i = 1; i < n; i++)\n    if (z > p[i])\n      z = p[i];\n  return z;\n}"
    },
    {
      "task_id": 105,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %rdi,%rbx\n  mov    %rdx,%r12\n  mov    %rcx,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    0xea6(%rip),%rax        # 200d <_fini+0xd45>\n  mov    %rax,(%rsp)\n  lea    0xe8e(%rip),%rax        # 2000 <_fini+0xd38>\n  mov    %rax,0x8(%rsp)\n  lea    0xe86(%rip),%rax        # 2004 <_fini+0xd3c>\n  mov    %rax,0x10(%rsp)\n  lea    0xe7e(%rip),%rax        # 2008 <_fini+0xd40>\n  mov    %rax,0x18(%rsp)\n  lea    0xe78(%rip),%rax        # 200e <_fini+0xd46>\n  mov    %rax,0x20(%rsp)\n  lea    0xe71(%rip),%rax        # 2013 <_fini+0xd4b>\n  mov    %rax,0x28(%rsp)\n  lea    0xe6a(%rip),%rax        # 2018 <_fini+0xd50>\n  mov    %rax,0x30(%rsp)\n  lea    0xe62(%rip),%rax        # 201c <_fini+0xd54>\n  mov    %rax,0x38(%rsp)\n  lea    0xe5c(%rip),%rax        # 2022 <_fini+0xd5a>\n  mov    %rax,0x40(%rsp)\n  lea    0xe56(%rip),%rax        # 2028 <_fini+0xd60>\n  mov    %rax,0x48(%rsp)\n  lea    -0x1(%rsi),%r13d\n  test   %r13d,%r13d\n  jle    121b <func0+0xe2>\n  mov    %r13d,%edi\n  lea    0x4(%rbx),%r8\n  jmp    120b <func0+0xd2>\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     1202 <func0+0xc9>\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11e9 <func0+0xb0>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    11e9 <func0+0xb0>\n  sub    $0x1,%edi\n  je     12b1 <func0+0x178>\n  test   %edi,%edi\n  jle    1202 <func0+0xc9>\n  mov    %rbx,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r8,%rdx,4),%rsi\n  jmp    11f2 <func0+0xb9>\n  movl   $0x0,(%rcx)\n  je     12b8 <func0+0x17f>\n  mov    $0x0,%edi\n  call   1070 <malloc@plt>\n  mov    %rax,(%r12)\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12c0 <func0+0x187>\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  sub    $0x1,%rax\n  test   %eax,%eax\n  js     1299 <func0+0x160>\n  mov    (%rbx,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     1250 <func0+0x117>\n  addl   $0x1,0x0(%rbp)\n  jmp    1250 <func0+0x117>\n  sub    $0x1,%r13\n  test   %r13d,%r13d\n  js     1235 <func0+0xfc>\n  cmp    %edx,0x0(%rbp)\n  jle    1235 <func0+0xfc>\n  mov    (%rbx,%r13,4),%eax\n  lea    -0x1(%rax),%ecx\n  cmp    $0x8,%ecx\n  ja     1269 <func0+0x130>\n  movslq %edx,%rsi\n  mov    (%r12),%rcx\n  cltq\n  mov    (%rsp,%rax,8),%rax\n  mov    %rax,(%rcx,%rsi,8)\n  lea    0x1(%rdx),%edx\n  jmp    1269 <func0+0x130>\n  movslq 0x0(%rbp),%rdi\n  shl    $0x3,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,(%r12)\n  mov    $0x0,%edx\n  jmp    1272 <func0+0x139>\n  movl   $0x0,0x0(%rbp)\n  movslq %r13d,%r13\n  mov    %r13,%rax\n  jmp    1258 <func0+0x11f>\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %rdi,%rbx\n  mov    %rdx,%r12\n  mov    %rcx,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x8(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x10(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x18(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x20(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x28(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x30(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  lea    -0x1(%rsi),%r13d\n  test   %r13d,%r13d\n  jle    L0\n  mov    %r13d,%edi\n  lea    0x4(%rbx),%r8\n  jmp    L1\nL3:\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     L2\nL5:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L3\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    L3\nL2:\n  sub    $0x1,%edi\n  je     L4\nL1:\n  test   %edi,%edi\n  jle    L2\n  mov    %rbx,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r8,%rdx,4),%rsi\n  jmp    L5\nL0:\n  movl   $0x0,(%rcx)\n  je     L6\n  mov    $0x0,%edi\n  call   <malloc@plt>\n  mov    %rax,(%r12)\nL10:\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL9:\n  sub    $0x1,%rax\n  test   %eax,%eax\n  js     L8\nL13:\n  mov    (%rbx,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     L9\n  addl   $0x1,0x0(%rbp)\n  jmp    L9\nL11:\n  sub    $0x1,%r13\n  test   %r13d,%r13d\n  js     L10\nL12:\n  cmp    %edx,0x0(%rbp)\n  jle    L10\n  mov    (%rbx,%r13,4),%eax\n  lea    -0x1(%rax),%ecx\n  cmp    $0x8,%ecx\n  ja     L11\n  movslq %edx,%rsi\n  mov    (%r12),%rcx\n  cltq\n  mov    (%rsp,%rax,8),%rax\n  mov    %rax,(%rcx,%rsi,8)\n  lea    0x1(%rdx),%edx\n  jmp    L11\nL8:\n  movslq 0x0(%rbp),%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%r12)\n  mov    $0x0,%edx\n  jmp    L12\nL4:\n  movl   $0x0,0x0(%rbp)\nL6:\n  movslq %r13d,%r13\n  mov    %r13,%rax\n  jmp    L13\nL7:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8205,
          "bias": [
            3750
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3726
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8196,
          "bias": [
            3718
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8200,
          "bias": [
            3710
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8206,
          "bias": [
            3704
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8211,
          "bias": [
            3697
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8216,
          "bias": [
            3690
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8220,
          "bias": [
            3682
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8226,
          "bias": [
            3676
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8232,
          "bias": [
            3670
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4635
        },
        "L1": {
          "label": "L1",
          "addr": 4619
        },
        "L2": {
          "label": "L2",
          "addr": 4610
        },
        "L3": {
          "label": "L3",
          "addr": 4585
        },
        "L4": {
          "label": "L4",
          "addr": 4785
        },
        "L5": {
          "label": "L5",
          "addr": 4594
        },
        "L6": {
          "label": "L6",
          "addr": 4792
        },
        "L7": {
          "label": "L7",
          "addr": 4800
        },
        "L8": {
          "label": "L8",
          "addr": 4761
        },
        "L9": {
          "label": "L9",
          "addr": 4688
        },
        "L10": {
          "label": "L10",
          "addr": 4661
        },
        "L11": {
          "label": "L11",
          "addr": 4713
        },
        "L12": {
          "label": "L12",
          "addr": 4722
        },
        "L13": {
          "label": "L13",
          "addr": 4696
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4f6e650054776f00546872656500466f757200466976650053697800536576656e004569676874004e696e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"One\""
          },
          "0x2022": {
            "type": "string",
            "value": "\"Eight\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"Two\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"Three\""
          },
          "0x2028": {
            "type": "string",
            "value": "\"Nine\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"\""
          },
          "0x200e": {
            "type": "string",
            "value": "\"Four\""
          },
          "0x2013": {
            "type": "string",
            "value": "\"Five\""
          },
          "0x2018": {
            "type": "string",
            "value": "\"Six\""
          },
          "0x201c": {
            "type": "string",
            "value": "\"Seven\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *a, int n, char ***p, int *m) {\n  int i, j, t;\n  char *b[10] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n  for (i = n - 1; i > 0; i--)\n    for (j = 0; j < i; j++)\n      if (a[j] > a[j + 1]) {\n        t = a[j];\n        a[j] = a[j + 1];\n        a[j + 1] = t;\n      }\n  *m = 0;\n  for (i = n - 1; i >= 0; i--)\n    if (a[i] > 0 && a[i] < 10)\n      (*m)++;\n  for (i = n - 1; i >= 0 && *m > 0; i--)\n    if (a[i] > 0 && a[i] < 10)\n      (*p)[--(*m)] = b[a[i]];\n  if (*m)\n    *p = malloc(*m * sizeof(char *));\n  for (i = n - 1; i >= 0; i--)\n    if (a[i] > 0 && a[i] < 10)\n      (*m)++;\n  *p = malloc(*m * sizeof(char *));\n  for (i = n - 1, j = 0; i >= 0 && j < *m; i--)\n    if (a[i] > 0 && a[i] < 10)\n      (*p)[j++] = b[a[i]];\n}"
    },
    {
      "task_id": 114,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    (%rdi),%rcx\n  cmp    $0x1,%esi\n  jle    1158 <func0+0x58>\n  lea    -0x2(%rsi),%eax\n  lea    0x8(%rdi),%rdx\n  mov    %rcx,%r8\n  lea    0x10(%rdi,%rax,8),%rsi\n  jmp    1133 <func0+0x33>\n  nopl   (%rax)\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rdx,%rsi\n  je     114e <func0+0x4e>\n  mov    %rax,%rcx\n  mov    (%rdx),%rax\n  test   %rcx,%rcx\n  jns    1120 <func0+0x20>\n  add    %rcx,%rax\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  jne    1130 <func0+0x30>\n  mov    %r8,%rax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %rcx,%r8\n  mov    %r8,%rax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    (%rdi),%rcx\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%eax\n  lea    0x8(%rdi),%rdx\n  mov    %rcx,%r8\n  lea    0x10(%rdi,%rax,8),%rsi\n  jmp    L1\n  nopl   (%rax)\nL3:\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rdx,%rsi\n  je     L2\nL4:\n  mov    %rax,%rcx\nL1:\n  mov    (%rdx),%rax\n  test   %rcx,%rcx\n  jns    L3\n  add    %rcx,%rax\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  jne    L4\nL2:\n  mov    %r8,%rax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    %rcx,%r8\n  mov    %r8,%rax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4440
        },
        "L1": {
          "label": "L1",
          "addr": 4403
        },
        "L2": {
          "label": "L2",
          "addr": 4430
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4400
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " long func0(long p[], int n) {\n  long z = p[0];\n  int i;\n  for (i = 1; i < n; i++)\n    if (z < 0)\n      if (z > p[i] + z)\n        z = p[i] + z;\n  return z;\n}"
    },
    {
      "task_id": 112,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    %rcx,-0x50(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  jmp    123c <func0+0xc3>\n  mov    -0x40(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  movb   $0x0,-0x26(%rbp)\n  jmp    11fc <func0+0x83>\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    11f7 <func0+0x7e>\n  movb   $0x1,-0x26(%rbp)\n  jmp    1207 <func0+0x8e>\n  addq   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11d6 <func0+0x5d>\n  movzbl -0x26(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     1238 <func0+0xbf>\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x24(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x24(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x20(%rbp)\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11c8 <func0+0x4f>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,-0x14(%rbp)\n  movb   $0x1,-0x25(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    12b4 <func0+0x13b>\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x1c(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     12b0 <func0+0x137>\n  movb   $0x0,-0x25(%rbp)\n  jmp    12c5 <func0+0x14c>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     1280 <func0+0x107>\n  mov    -0x8(%rbp),%rdx\n  mov    -0x48(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcpy@plt>\n  cmpb   $0x0,-0x25(%rbp)\n  je     12e7 <func0+0x16e>\n  lea    0xd1b(%rip),%rax        # 2000 <_fini+0xcf4>\n  jmp    12ee <func0+0x175>\n  lea    0xd17(%rip),%rax        # 2005 <_fini+0xcf9>\n  mov    -0x50(%rbp),%rdx\n  mov    %rax,%rsi\n  mov    %rdx,%rdi\n  call   1090 <strcpy@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  nop\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    %rcx,-0x50(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  jmp    L0\nL6:\n  mov    -0x40(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  movb   $0x0,-0x26(%rbp)\n  jmp    L1\nL4:\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    L2\n  movb   $0x1,-0x26(%rbp)\n  jmp    L3\nL2:\n  addq   $0x1,-0x10(%rbp)\nL1:\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L4\nL3:\n  movzbl -0x26(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     L5\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x24(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x24(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\nL5:\n  addl   $0x1,-0x20(%rbp)\nL0:\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L6\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x14(%rbp)\n  movb   $0x1,-0x25(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L7\nL10:\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x1c(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     L8\n  movb   $0x0,-0x25(%rbp)\n  jmp    L9\nL8:\n  addl   $0x1,-0x1c(%rbp)\nL7:\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     L10\nL9:\n  mov    -0x8(%rbp),%rdx\n  mov    -0x48(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  cmpb   $0x0,-0x25(%rbp)\n  je     L11\n  lea    D0(%rip),%rax\n  jmp    L12\nL11:\n  lea    D1(%rip),%rax\nL12:\n  mov    -0x50(%rbp),%rdx\n  mov    %rax,%rsi\n  mov    %rdx,%rdi\n  call   <strcpy@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  nop\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3355
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8197,
          "bias": [
            3351
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4668
        },
        "L1": {
          "label": "L1",
          "addr": 4604
        },
        "L2": {
          "label": "L2",
          "addr": 4599
        },
        "L3": {
          "label": "L3",
          "addr": 4615
        },
        "L4": {
          "label": "L4",
          "addr": 4566
        },
        "L5": {
          "label": "L5",
          "addr": 4664
        },
        "L6": {
          "label": "L6",
          "addr": 4552
        },
        "L7": {
          "label": "L7",
          "addr": 4788
        },
        "L8": {
          "label": "L8",
          "addr": 4784
        },
        "L9": {
          "label": "L9",
          "addr": 4805
        },
        "L10": {
          "label": "L10",
          "addr": 4736
        },
        "L11": {
          "label": "L11",
          "addr": 4839
        },
        "L12": {
          "label": "L12",
          "addr": 4846
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "547275650046616c736500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"True\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"False\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, char *b, char *c, char *d) {\n  int len = strlen(a);\n  char *buffer = (char *)malloc(len + 1);\n  int i, j, k = 0;\n  for (i = 0; a[i] != '\\0'; i++) {\n    char *p = b;\n    char flag = 0;\n    while (*p != '\\0') {\n      if (a[i] == *p) {\n        flag = 1;\n        break;\n      }\n      p++;\n    }\n    if (!flag) {\n      buffer[k++] = a[i];\n    }\n  }\n  buffer[k] = '\\0';\n  int len1 = strlen(buffer);\n  char flag1 = 1;\n  for (j = 0; j < len1 / 2; j++) {\n    if (buffer[j] != buffer[len1 - 1 - j]) {\n      flag1 = 0;\n      break;\n    }\n  }\n  strcpy(c, buffer);\n  strcpy(d, flag1 ? \"True\" : \"False\");\n  free(buffer);\n}"
    },
    {
      "task_id": 113,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    -0x3c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1060 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    1294 <func0+0x15b>\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    120d <func0+0xd4>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    1209 <func0+0xd0>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jg     1209 <func0+0xd0>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1209 <func0+0xd0>\n  addl   $0x1,-0x20(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1181 <func0+0x48>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x64,%edi\n  call   1060 <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x20(%rbp),%esi\n  mov    -0x20(%rbp),%ecx\n  mov    -0x20(%rbp),%edx\n  mov    %esi,%r8d\n  lea    0xd7d(%rip),%rsi        # 2000 <_fini+0xd54>\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1070 <sprintf@plt>\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     116e <func0+0x35>\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    -0x3c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L0\nL4:\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L1\nL3:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    L2\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jg     L2\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L2\n  addl   $0x1,-0x20(%rbp)\nL2:\n  addl   $0x1,-0x1c(%rbp)\nL1:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L3\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x64,%edi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x20(%rbp),%esi\n  mov    -0x20(%rbp),%ecx\n  mov    -0x20(%rbp),%edx\n  mov    %esi,%r8d\n  lea    D0(%rip),%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  addl   $0x1,-0x24(%rbp)\nL0:\n  mov    -0x24(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L4\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3453
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4756
        },
        "L1": {
          "label": "L1",
          "addr": 4621
        },
        "L2": {
          "label": "L2",
          "addr": 4617
        },
        "L3": {
          "label": "L3",
          "addr": 4481
        },
        "L4": {
          "label": "L4",
          "addr": 4462
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "746865206e756d626572206f66206f646420656c656d656e747320256420696e2074686520737472696e67202564206f662074686520256420696e7075742e00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"the number of odd elements %d in the string %d of the %d input.\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **arr, int n) {\n  char **res = malloc(n * sizeof(char *));\n  for (int i = 0; i < n; i++) {\n    int cnt = 0;\n    for (int j = 0; arr[i][j] != '\\0'; j++) {\n      if (arr[i][j] >= '0' && arr[i][j] <= '9' && (arr[i][j] - '0') % 2 == 1) {\n        cnt++;\n      }\n    }\n    res[i] = malloc(100);\n    sprintf(res[i], \"the number of odd elements %d in the string %d of the %d input.\", cnt, cnt, cnt);\n  }\n  return res;\n}"
    },
    {
      "task_id": 112,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %rsi,%rbp\n  mov    %rdx,%r13\n  mov    %rcx,%r12\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%rbx\n  movzbl (%r14),%ecx\n  test   %cl,%cl\n  je     11bf <func0+0x46>\n  movzbl 0x0(%rbp),%edi\n  lea    0x1(%r14),%rsi\n  mov    $0x0,%r8d\n  jmp    125d <func0+0xe4>\n  mov    $0x0,%r8d\n  movslq %r8d,%r8\n  movb   $0x0,(%rbx,%r8,1)\n  mov    %rbx,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    1204 <func0+0x8b>\n  cltq\n  lea    -0x1(%rbx,%rax,1),%rdx\n  mov    $0x0,%eax\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rbx,%rax,1)\n  jne    122f <func0+0xb6>\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     11ef <func0+0x76>\n  mov    %rbx,%rsi\n  mov    %r13,%rdi\n  call   1090 <strcpy@plt>\n  lea    0xdf0(%rip),%rsi        # 2006 <_fini+0xd8e>\n  mov    %r12,%rdi\n  call   1090 <strcpy@plt>\n  mov    %rbx,%rdi\n  call   1080 <free@plt>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    %rbx,%rsi\n  mov    %r13,%rdi\n  call   1090 <strcpy@plt>\n  lea    0xdbf(%rip),%rsi        # 2000 <_fini+0xd88>\n  jmp    1216 <func0+0x9d>\n  movslq %r8d,%rax\n  mov    %cl,(%rbx,%rax,1)\n  lea    0x1(%r8),%r8d\n  add    $0x1,%rsi\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  je     11c5 <func0+0x4c>\n  mov    %rbp,%rdx\n  mov    %edi,%eax\n  test   %dil,%dil\n  je     1243 <func0+0xca>\n  cmp    %cl,%al\n  je     124d <func0+0xd4>\n  add    $0x1,%rdx\n  movzbl (%rdx),%eax\n  test   %al,%al\n  jne    1267 <func0+0xee>\n  jmp    1243 <func0+0xca>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %rsi,%rbp\n  mov    %rdx,%r13\n  mov    %rcx,%r12\n  call   <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbx\n  movzbl (%r14),%ecx\n  test   %cl,%cl\n  je     L0\n  movzbl 0x0(%rbp),%edi\n  lea    0x1(%r14),%rsi\n  mov    $0x0,%r8d\n  jmp    L1\nL0:\n  mov    $0x0,%r8d\nL6:\n  movslq %r8d,%r8\n  movb   $0x0,(%rbx,%r8,1)\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    L2\n  cltq\n  lea    -0x1(%rbx,%rax,1),%rdx\n  mov    $0x0,%eax\nL4:\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rbx,%rax,1)\n  jne    L3\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     L4\nL2:\n  mov    %rbx,%rsi\n  mov    %r13,%rdi\n  call   <strcpy@plt>\n  lea    D0(%rip),%rsi\nL5:\n  mov    %r12,%rdi\n  call   <strcpy@plt>\n  mov    %rbx,%rdi\n  call   <free@plt>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL3:\n  mov    %rbx,%rsi\n  mov    %r13,%rdi\n  call   <strcpy@plt>\n  lea    D1(%rip),%rsi\n  jmp    L5\nL7:\n  movslq %r8d,%rax\n  mov    %cl,(%rbx,%rax,1)\n  lea    0x1(%r8),%r8d\nL8:\n  add    $0x1,%rsi\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  je     L6\nL1:\n  mov    %rbp,%rdx\n  mov    %edi,%eax\n  test   %dil,%dil\n  je     L7\nL9:\n  cmp    %cl,%al\n  je     L8\n  add    $0x1,%rdx\n  movzbl (%rdx),%eax\n  test   %al,%al\n  jne    L9\n  jmp    L7",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8198,
          "bias": [
            3568
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3519
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4543
        },
        "L1": {
          "label": "L1",
          "addr": 4701
        },
        "L2": {
          "label": "L2",
          "addr": 4612
        },
        "L3": {
          "label": "L3",
          "addr": 4655
        },
        "L4": {
          "label": "L4",
          "addr": 4591
        },
        "L5": {
          "label": "L5",
          "addr": 4630
        },
        "L6": {
          "label": "L6",
          "addr": 4549
        },
        "L7": {
          "label": "L7",
          "addr": 4675
        },
        "L8": {
          "label": "L8",
          "addr": 4685
        },
        "L9": {
          "label": "L9",
          "addr": 4711
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "46616c7365005472756500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"False\""
          },
          "0x2006": {
            "type": "string",
            "value": "\"True\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, char *b, char *c, char *d) {\n  char *buffer = malloc(sizeof(char) * (strlen(a) + 1));\n  int i = 0, j = 0, k = 0;\n  while (a[i] != '\\0') {\n    j = 0;\n    while (b[j] != '\\0') {\n      if (a[i] == b[j]) {\n        break;\n      }\n      j++;\n    }\n    if (b[j] == '\\0') {\n      buffer[k++] = a[i];\n    }\n    i++;\n  }\n  buffer[k] = '\\0';\n  int len = strlen(buffer);\n  for (i = 0, j = len - 1; i < len / 2; i++, j--) {\n    if (buffer[i] != buffer[j]) {\n      strcpy(c, buffer);\n      strcpy(d, \"False\");\n      break;\n    }\n  }\n  if (i >= len / 2) {\n    strcpy(c, buffer);\n    strcpy(d, \"True\");\n  }\n  free(buffer);\n}"
    },
    {
      "task_id": 115,
      "type": "O0",
      "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %ecx,-0x24(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    117e <func0+0x85>\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    115a <func0+0x61>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     112e <func0+0x35>\n  cmpl   $0x0,-0x8(%rbp)\n  jle    117a <func0+0x81>\n  mov    -0x8(%rbp),%edx\n  mov    -0x24(%rbp),%eax\n  add    %edx,%eax\n  sub    $0x1,%eax\n  cltd\n  idivl  -0x24(%rbp)\n  add    %eax,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111e <func0+0x25>\n  mov    -0x10(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %ecx,-0x24(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL4:\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L1\nL2:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     L2\n  cmpl   $0x0,-0x8(%rbp)\n  jle    L3\n  mov    -0x8(%rbp),%edx\n  mov    -0x24(%rbp),%eax\n  add    %edx,%eax\n  sub    $0x1,%eax\n  cltd\n  idivl  -0x24(%rbp)\n  add    %eax,-0x10(%rbp)\nL3:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  mov    -0x10(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4478
        },
        "L1": {
          "label": "L1",
          "addr": 4442
        },
        "L2": {
          "label": "L2",
          "addr": 4398
        },
        "L3": {
          "label": "L3",
          "addr": 4474
        },
        "L4": {
          "label": "L4",
          "addr": 4382
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int **x, int m, int n, int t) {\n  int i, j, sum, count = 0;\n  for (i = 0; i < m; i++) {\n    sum = 0;\n    for (j = 0; j < n; j++)\n      sum += x[i][j];\n    if (sum > 0)\n      count += (sum + t - 1) / t;\n  }\n  return count;\n}"
    },
    {
      "task_id": 115,
      "type": "O2",
      "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edx,%r10d\n  mov    %ecx,%r11d\n  test   %esi,%esi\n  jle    1168 <func0+0x68>\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x8(%rdi,%rax,8),%rsi\n  lea    -0x1(%rdx),%eax\n  lea    0x4(,%rax,4),%r9\n  nopl   0x0(%rax)\n  test   %r10d,%r10d\n  jle    115b <func0+0x5b>\n  mov    (%rdi),%rax\n  xor    %edx,%edx\n  lea    (%r9,%rax,1),%rcx\n  cs nopw 0x0(%rax,%rax,1)\n  add    (%rax),%edx\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    1140 <func0+0x40>\n  test   %edx,%edx\n  jle    115b <func0+0x5b>\n  lea    -0x1(%rdx,%r11,1),%eax\n  cltd\n  idiv   %r11d\n  add    %eax,%r8d\n  add    $0x8,%rdi\n  cmp    %rsi,%rdi\n  jne    1128 <func0+0x28>\n  mov    %r8d,%eax\n  ret\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edx,%r10d\n  mov    %ecx,%r11d\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x8(%rdi,%rax,8),%rsi\n  lea    -0x1(%rdx),%eax\n  lea    0x4(,%rax,4),%r9\n  nopl   0x0(%rax)\nL3:\n  test   %r10d,%r10d\n  jle    L1\n  mov    (%rdi),%rax\n  xor    %edx,%edx\n  lea    (%r9,%rax,1),%rcx\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  add    (%rax),%edx\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L2\n  test   %edx,%edx\n  jle    L1\n  lea    -0x1(%rdx,%r11,1),%eax\n  cltd\n  idiv   %r11d\n  add    %eax,%r8d\nL1:\n  add    $0x8,%rdi\n  cmp    %rsi,%rdi\n  jne    L3\n  mov    %r8d,%eax\n  ret\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4456
        },
        "L1": {
          "label": "L1",
          "addr": 4443
        },
        "L2": {
          "label": "L2",
          "addr": 4416
        },
        "L3": {
          "label": "L3",
          "addr": 4392
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int **x, int m, int n, int k) {\n  int i, j, sum, ret = 0;\n  for (i = 0; i < m; i++) {\n    sum = 0;\n    for (j = 0; j < n; j++)\n      sum += x[i][j];\n    if (sum > 0)\n      ret += (sum + k - 1) / k;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 115,
      "type": "O1",
      "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    115f <func0+0x66>\n  push   %rbx\n  mov    %edx,%r10d\n  mov    %ecx,%r9d\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%rdi\n  lea    -0x1(%rdx),%eax\n  mov    $0x0,%esi\n  lea    0x4(,%rax,4),%rbx\n  mov    $0x0,%r11d\n  jmp    1134 <func0+0x3b>\n  add    $0x8,%r8\n  cmp    %rdi,%r8\n  je     1167 <func0+0x6e>\n  test   %r10d,%r10d\n  jle    112b <func0+0x32>\n  mov    (%r8),%rax\n  lea    (%rbx,%rax,1),%rcx\n  mov    %r11d,%edx\n  add    (%rax),%edx\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    1143 <func0+0x4a>\n  test   %edx,%edx\n  jle    112b <func0+0x32>\n  lea    -0x1(%rdx,%r9,1),%eax\n  cltd\n  idiv   %r9d\n  add    %eax,%esi\n  jmp    112b <func0+0x32>\n  mov    $0x0,%esi\n  mov    %esi,%eax\n  ret\n  mov    %esi,%eax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %rbx\n  mov    %edx,%r10d\n  mov    %ecx,%r9d\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%rdi\n  lea    -0x1(%rdx),%eax\n  mov    $0x0,%esi\n  lea    0x4(,%rax,4),%rbx\n  mov    $0x0,%r11d\n  jmp    L1\nL3:\n  add    $0x8,%r8\n  cmp    %rdi,%r8\n  je     L2\nL1:\n  test   %r10d,%r10d\n  jle    L3\n  mov    (%r8),%rax\n  lea    (%rbx,%rax,1),%rcx\n  mov    %r11d,%edx\nL4:\n  add    (%rax),%edx\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L4\n  test   %edx,%edx\n  jle    L3\n  lea    -0x1(%rdx,%r9,1),%eax\n  cltd\n  idiv   %r9d\n  add    %eax,%esi\n  jmp    L3\nL0:\n  mov    $0x0,%esi\n  mov    %esi,%eax\n  ret\nL2:\n  mov    %esi,%eax\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4447
        },
        "L1": {
          "label": "L1",
          "addr": 4404
        },
        "L2": {
          "label": "L2",
          "addr": 4455
        },
        "L3": {
          "label": "L3",
          "addr": 4395
        },
        "L4": {
          "label": "L4",
          "addr": 4419
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int **x, int n, int m, int k) {\n  int i, j, sum, res = 0;\n  for (i = 0; i < n; i++) {\n    sum = 0;\n    for (j = 0; j < m; j++)\n      sum += x[i][j];\n    if (sum > 0)\n      res += (sum + k - 1) / k;\n  }\n  return res;\n}"
    },
    {
      "task_id": 115,
      "type": "O3",
      "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    11ed <func0+0xed>\n  lea    -0x1(%rsi),%eax\n  push   %r13\n  mov    %ecx,%r9d\n  mov    %rdi,%rcx\n  push   %r12\n  mov    %edx,%r8d\n  xor    %r10d,%r10d\n  push   %rbp\n  lea    -0x1(%rdx),%ebp\n  push   %rbx\n  lea    0x8(%rdi,%rax,8),%rbx\n  mov    %edx,%eax\n  mov    %edx,%edi\n  shr    $0x2,%eax\n  and    $0xfffffffc,%edi\n  lea    -0x1(%rax),%r11d\n  add    $0x1,%r11\n  shl    $0x4,%r11\n  nop\n  test   %r8d,%r8d\n  jle    11d0 <func0+0xd0>\n  mov    (%rcx),%rsi\n  cmp    $0x2,%ebp\n  jbe    11e7 <func0+0xe7>\n  mov    %rsi,%rax\n  lea    (%r11,%rsi,1),%rdx\n  pxor   %xmm0,%xmm0\n  movdqu (%rax),%xmm2\n  add    $0x10,%rax\n  paddd  %xmm2,%xmm0\n  cmp    %rdx,%rax\n  jne    1160 <func0+0x60>\n  movdqa %xmm0,%xmm1\n  mov    %edi,%edx\n  psrldq $0x8,%xmm1\n  paddd  %xmm1,%xmm0\n  movdqa %xmm0,%xmm1\n  psrldq $0x4,%xmm1\n  paddd  %xmm1,%xmm0\n  movd   %xmm0,%eax\n  cmp    %edi,%r8d\n  je     11c0 <func0+0xc0>\n  movslq %edx,%r12\n  lea    0x0(,%r12,4),%r13\n  add    (%rsi,%r12,4),%eax\n  lea    0x1(%rdx),%r12d\n  cmp    %r12d,%r8d\n  jle    11c0 <func0+0xc0>\n  add    $0x2,%edx\n  add    0x4(%rsi,%r13,1),%eax\n  cmp    %edx,%r8d\n  jle    11c0 <func0+0xc0>\n  add    0x8(%rsi,%r13,1),%eax\n  test   %eax,%eax\n  jle    11d0 <func0+0xd0>\n  lea    -0x1(%rax,%r9,1),%eax\n  cltd\n  idiv   %r9d\n  add    %eax,%r10d\n  add    $0x8,%rcx\n  cmp    %rbx,%rcx\n  jne    1140 <func0+0x40>\n  pop    %rbx\n  mov    %r10d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    1196 <func0+0x96>\n  xor    %eax,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  push   %r13\n  mov    %ecx,%r9d\n  mov    %rdi,%rcx\n  push   %r12\n  mov    %edx,%r8d\n  xor    %r10d,%r10d\n  push   %rbp\n  lea    -0x1(%rdx),%ebp\n  push   %rbx\n  lea    0x8(%rdi,%rax,8),%rbx\n  mov    %edx,%eax\n  mov    %edx,%edi\n  shr    $0x2,%eax\n  and    $0xfffffffc,%edi\n  lea    -0x1(%rax),%r11d\n  add    $0x1,%r11\n  shl    $0x4,%r11\n  nop\nL5:\n  test   %r8d,%r8d\n  jle    L1\n  mov    (%rcx),%rsi\n  cmp    $0x2,%ebp\n  jbe    L2\n  mov    %rsi,%rax\n  lea    (%r11,%rsi,1),%rdx\n  pxor   %xmm0,%xmm0\nL3:\n  movdqu (%rax),%xmm2\n  add    $0x10,%rax\n  paddd  %xmm2,%xmm0\n  cmp    %rdx,%rax\n  jne    L3\n  movdqa %xmm0,%xmm1\n  mov    %edi,%edx\n  psrldq $0x8,%xmm1\n  paddd  %xmm1,%xmm0\n  movdqa %xmm0,%xmm1\n  psrldq $0x4,%xmm1\n  paddd  %xmm1,%xmm0\n  movd   %xmm0,%eax\n  cmp    %edi,%r8d\n  je     L4\nL6:\n  movslq %edx,%r12\n  lea    0x0(,%r12,4),%r13\n  add    (%rsi,%r12,4),%eax\n  lea    0x1(%rdx),%r12d\n  cmp    %r12d,%r8d\n  jle    L4\n  add    $0x2,%edx\n  add    0x4(%rsi,%r13,1),%eax\n  cmp    %edx,%r8d\n  jle    L4\n  add    0x8(%rsi,%r13,1),%eax\nL4:\n  test   %eax,%eax\n  jle    L1\n  lea    -0x1(%rax,%r9,1),%eax\n  cltd\n  idiv   %r9d\n  add    %eax,%r10d\nL1:\n  add    $0x8,%rcx\n  cmp    %rbx,%rcx\n  jne    L5\n  pop    %rbx\n  mov    %r10d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL2:\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    L6\nL0:\n  xor    %eax,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4589
        },
        "L1": {
          "label": "L1",
          "addr": 4560
        },
        "L2": {
          "label": "L2",
          "addr": 4583
        },
        "L3": {
          "label": "L3",
          "addr": 4448
        },
        "L4": {
          "label": "L4",
          "addr": 4544
        },
        "L5": {
          "label": "L5",
          "addr": 4416
        },
        "L6": {
          "label": "L6",
          "addr": 4502
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int **x, int n, int m, int k) {\n  int i, j, sum, ret = 0;\n  for (i = 0; i < n; i++) {\n    sum = 0;\n    for (j = 0; j < m; j++)\n      sum += x[i][j];\n    if (sum > 0)\n      ret += (sum + k - 1) / k;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 112,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   10b0 <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   10d0 <malloc@plt>\n  movzbl (%rbx),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     1211 <func0+0x71>\n  movzbl (%r14),%r8d\n  lea    0x1(%rbx),%rsi\n  xor    %edi,%edi\n  nopl   0x0(%rax)\n  mov    %r14,%rdx\n  mov    %r8d,%eax\n  test   %r8b,%r8b\n  jne    11fc <func0+0x5c>\n  jmp    1270 <func0+0xd0>\n  movzbl 0x1(%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     1270 <func0+0xd0>\n  cmp    %al,%cl\n  jne    11f0 <func0+0x50>\n  movzbl (%rsi),%ecx\n  add    $0x1,%rsi\n  test   %cl,%cl\n  jne    11e0 <func0+0x40>\n  movslq %edi,%rax\n  add    %r13,%rax\n  movb   $0x0,(%rax)\n  mov    %r13,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,%esi\n  shr    $0x1f,%esi\n  add    %eax,%esi\n  sar    %esi\n  cmp    $0x1,%eax\n  jle    1290 <func0+0xf0>\n  lea    -0x1(%rax),%ecx\n  xor    %edx,%edx\n  movslq %ecx,%rcx\n  add    %r13,%rcx\n  jmp    124c <func0+0xac>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%rdx\n  sub    $0x1,%rcx\n  cmp    %edx,%esi\n  jle    1290 <func0+0xf0>\n  movzbl (%rcx),%ebx\n  cmp    %bl,0x0(%r13,%rdx,1)\n  je     1240 <func0+0xa0>\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   10c0 <memcpy@plt>\n  lea    0xd94(%rip),%rsi        # 2000 <_fini+0xd40>\n  jmp    12a6 <func0+0x106>\n  xchg   %ax,%ax\n  movslq %edi,%rax\n  add    $0x1,%rsi\n  add    $0x1,%edi\n  mov    %cl,0x0(%r13,%rax,1)\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  jne    11e0 <func0+0x40>\n  jmp    120b <func0+0x6b>\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   10c0 <memcpy@plt>\n  lea    0xd60(%rip),%rsi        # 2006 <_fini+0xd46>\n  mov    %rbp,%rdi\n  call   10a0 <strcpy@plt>\n  pop    %rbx\n  mov    %r13,%rdi\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1090 <free@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  movzbl (%rbx),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     L0\n  movzbl (%r14),%r8d\n  lea    0x1(%rbx),%rsi\n  xor    %edi,%edi\n  nopl   0x0(%rax)\nL4:\n  mov    %r14,%rdx\n  mov    %r8d,%eax\n  test   %r8b,%r8b\n  jne    L1\n  jmp    L2\nL3:\n  movzbl 0x1(%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     L2\nL1:\n  cmp    %al,%cl\n  jne    L3\n  movzbl (%rsi),%ecx\n  add    $0x1,%rsi\n  test   %cl,%cl\n  jne    L4\nL9:\n  movslq %edi,%rax\n  add    %r13,%rax\nL0:\n  movb   $0x0,(%rax)\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  mov    %eax,%esi\n  shr    $0x1f,%esi\n  add    %eax,%esi\n  sar    %esi\n  cmp    $0x1,%eax\n  jle    L5\n  lea    -0x1(%rax),%ecx\n  xor    %edx,%edx\n  movslq %ecx,%rcx\n  add    %r13,%rcx\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL7:\n  add    $0x1,%rdx\n  sub    $0x1,%rcx\n  cmp    %edx,%esi\n  jle    L5\nL6:\n  movzbl (%rcx),%ebx\n  cmp    %bl,0x0(%r13,%rdx,1)\n  je     L7\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   <memcpy@plt>\n  lea    D0(%rip),%rsi\n  jmp    L8\n  xchg   %ax,%ax\nL2:\n  movslq %edi,%rax\n  add    $0x1,%rsi\n  add    $0x1,%edi\n  mov    %cl,0x0(%r13,%rax,1)\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  jne    L4\n  jmp    L9\nL5:\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   <memcpy@plt>\n  lea    D1(%rip),%rsi\nL8:\n  mov    %rbp,%rdi\n  call   <strcpy@plt>\n  pop    %rbx\n  mov    %r13,%rdi\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1090 <free@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3476
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8198,
          "bias": [
            3424
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4625
        },
        "L1": {
          "label": "L1",
          "addr": 4604
        },
        "L2": {
          "label": "L2",
          "addr": 4720
        },
        "L3": {
          "label": "L3",
          "addr": 4592
        },
        "L4": {
          "label": "L4",
          "addr": 4576
        },
        "L5": {
          "label": "L5",
          "addr": 4752
        },
        "L6": {
          "label": "L6",
          "addr": 4684
        },
        "L7": {
          "label": "L7",
          "addr": 4672
        },
        "L8": {
          "label": "L8",
          "addr": 4774
        },
        "L9": {
          "label": "L9",
          "addr": 4619
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "46616c7365005472756500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"False\""
          },
          "0x2006": {
            "type": "string",
            "value": "\"True\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s1, char *s2, char *s3, char *s4) {\n  int i = 0, j = 0, k = 0, len = 0;\n  char *s = NULL;\n  s = (char *)malloc((len = strlen(s1) + 1) * sizeof(char));\n  while (s1[i] != '\\0') {\n    j = 0;\n    while (s2[j] != '\\0') {\n      if (s1[i] == s2[j]) {\n        break;\n      }\n      j++;\n    }\n    if (s2[j] == '\\0') {\n      s[k++] = s1[i];\n    }\n    i++;\n  }\n  s[k] = '\\0';\n  len = strlen(s);\n  for (i = 0, j = len - 1; i < len / 2; i++, j--) {\n    if (s[i] != s[j]) {\n      break;\n    }\n  }\n  if (i >= len / 2) {\n    memcpy(s3, s, len + 1);\n    strcpy(s4, \"True\");\n  } else {\n    memcpy(s3, s, len + 1);\n    strcpy(s4, \"False\");\n  }\n  free(s);\n  return;\n}"
    },
    {
      "task_id": 113,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %esi,%r12d\n  movslq %esi,%rdi\n  shl    $0x3,%rdi\n  call   1060 <malloc@plt>\n  mov    %rax,%r13\n  test   %r12d,%r12d\n  jle    1204 <func0+0xcb>\n  mov    %r12d,%r12d\n  mov    $0x0,%ebp\n  lea    0xe88(%rip),%r15        # 2000 <_fini+0xde8>\n  jmp    11ee <func0+0xb5>\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%eax\n  test   %al,%al\n  je     11ad <func0+0x74>\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     117a <func0+0x41>\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebx\n  jmp    117a <func0+0x41>\n  mov    $0x64,%edi\n  call   1060 <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13,%rbp,8)\n  sub    $0x8,%rsp\n  push   %rbx\n  mov    %ebx,%r9d\n  mov    %ebx,%r8d\n  mov    %r15,%rcx\n  mov    $0x64,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%eax\n  call   1070 <__sprintf_chk@plt>\n  add    $0x1,%rbp\n  add    $0x10,%rsp\n  cmp    %r12,%rbp\n  je     1204 <func0+0xcb>\n  mov    (%r14,%rbp,8),%rdx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  mov    $0x0,%ebx\n  test   %al,%al\n  jne    1186 <func0+0x4d>\n  jmp    11ad <func0+0x74>\n  mov    %r13,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %esi,%r12d\n  movslq %esi,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %r12d,%r12d\n  jle    L0\n  mov    %r12d,%r12d\n  mov    $0x0,%ebp\n  lea    D0(%rip),%r15\n  jmp    L1\nL3:\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%eax\n  test   %al,%al\n  je     L2\nL4:\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     L3\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebx\n  jmp    L3\nL2:\n  mov    $0x64,%edi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13,%rbp,8)\n  sub    $0x8,%rsp\n  push   %rbx\n  mov    %ebx,%r9d\n  mov    %ebx,%r8d\n  mov    %r15,%rcx\n  mov    $0x64,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\n  add    $0x1,%rbp\n  add    $0x10,%rsp\n  cmp    %r12,%rbp\n  je     L0\nL1:\n  mov    (%r14,%rbp,8),%rdx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  mov    $0x0,%ebx\n  test   %al,%al\n  jne    L4\n  jmp    L2\nL0:\n  mov    %r13,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3720
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4612
        },
        "L1": {
          "label": "L1",
          "addr": 4590
        },
        "L2": {
          "label": "L2",
          "addr": 4525
        },
        "L3": {
          "label": "L3",
          "addr": 4474
        },
        "L4": {
          "label": "L4",
          "addr": 4486
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "746865206e756d626572206f66206f646420656c656d656e747320256420696e2074686520737472696e67202564206f662074686520256420696e7075742e00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"the number of odd elements %d in the string %d of the %d input.\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char **func0(char **arr, int size) {\n  char **res = malloc(size * sizeof(char *));\n  int i, j, k, count;\n  for (i = 0; i < size; i++) {\n    count = 0;\n    for (j = 0; arr[i][j] != '\\0'; j++) {\n      if (arr[i][j] >= '0' && arr[i][j] <= '9') {\n        if (((int)arr[i][j] - '0') % 2 == 1)\n          count++;\n      }\n    }\n    res[i] = malloc(100 * sizeof(char));\n    __sprintf_chk(res[i], 1, 100, \"the number of odd elements %d in the string %d of the %d input.\", count, i, count);\n  }\n  return res;\n}"
    },
    {
      "task_id": 113,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  sub    $0x8,%rsp\n  call   1060 <malloc@plt>\n  mov    %rax,%r12\n  test   %ebp,%ebp\n  jle    11f0 <func0+0xb0>\n  xor    %r14d,%r14d\n  lea    0xe86(%rip),%r13        # 2000 <_fini+0xdfc>\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx,%r14,8),%rdx\n  xor    %r15d,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     11b4 <func0+0x74>\n  nopw   0x0(%rax,%rax,1)\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     11a9 <func0+0x69>\n  and    $0x1,%eax\n  cmp    $0x1,%al\n  sbb    $0xffffffff,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    1198 <func0+0x58>\n  mov    $0x64,%edi\n  call   1060 <malloc@plt>\n  sub    $0x8,%rsp\n  mov    %r15d,%r9d\n  mov    %r15d,%r8d\n  push   %r15\n  mov    %rax,%rdi\n  mov    $0x64,%edx\n  mov    %r13,%rcx\n  mov    %rax,(%r12,%r14,8)\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%r14\n  call   1070 <__sprintf_chk@plt>\n  pop    %rax\n  pop    %rdx\n  cmp    %r14,%rbp\n  jne    1180 <func0+0x40>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %rax,%r12\n  test   %ebp,%ebp\n  jle    L0\n  xor    %r14d,%r14d\n  lea    D0(%rip),%r13\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    (%rbx,%r14,8),%rdx\n  xor    %r15d,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     L2\n  and    $0x1,%eax\n  cmp    $0x1,%al\n  sbb    $0xffffffff,%r15d\nL2:\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    L3\nL1:\n  mov    $0x64,%edi\n  call   <malloc@plt>\n  sub    $0x8,%rsp\n  mov    %r15d,%r9d\n  mov    %r15d,%r8d\n  push   %r15\n  mov    %rax,%rdi\n  mov    $0x64,%edx\n  mov    %r13,%rcx\n  mov    %rax,(%r12,%r14,8)\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%r14\n  call   <__sprintf_chk@plt>\n  pop    %rax\n  pop    %rdx\n  cmp    %r14,%rbp\n  jne    L4\nL0:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3718
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4592
        },
        "L1": {
          "label": "L1",
          "addr": 4532
        },
        "L2": {
          "label": "L2",
          "addr": 4521
        },
        "L3": {
          "label": "L3",
          "addr": 4504
        },
        "L4": {
          "label": "L4",
          "addr": 4480
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "746865206e756d626572206f66206f646420656c656d656e747320256420696e2074686520737472696e67202564206f662074686520256420696e7075742e00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"the number of odd elements %d in the string %d of the %d input.\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char **func0(char **arr, int size) {\n  int i, j, k, odd_count;\n  char **res = malloc(size * sizeof(char *));\n  for (i = 0; i < size; i++) {\n    odd_count = 0;\n    for (j = 0; arr[i][j] != '\\0'; j++) {\n      if (arr[i][j] >= '0' && arr[i][j] <= '9' && arr[i][j] % 2 != 0) {\n        odd_count++;\n      }\n    }\n    res[i] = malloc(100);\n    __sprintf_chk(res[i], 1, 100, \"the number of odd elements %d in the string %d of the %d input.\", odd_count, i, odd_count);\n  }\n  return res;\n}"
    },
    {
      "task_id": 113,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  sub    $0x8,%rsp\n  call   1060 <malloc@plt>\n  mov    %rax,%r12\n  test   %ebp,%ebp\n  jle    11f0 <func0+0xb0>\n  xor    %r14d,%r14d\n  lea    0xe86(%rip),%r13        # 2000 <_fini+0xdfc>\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx,%r14,8),%rdx\n  xor    %r15d,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     11b4 <func0+0x74>\n  nopw   0x0(%rax,%rax,1)\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     11a9 <func0+0x69>\n  and    $0x1,%eax\n  cmp    $0x1,%al\n  sbb    $0xffffffff,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    1198 <func0+0x58>\n  mov    $0x64,%edi\n  call   1060 <malloc@plt>\n  sub    $0x8,%rsp\n  mov    %r15d,%r9d\n  mov    %r15d,%r8d\n  push   %r15\n  mov    %rax,%rdi\n  mov    $0x64,%edx\n  mov    %r13,%rcx\n  mov    %rax,(%r12,%r14,8)\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%r14\n  call   1070 <__sprintf_chk@plt>\n  pop    %rax\n  pop    %rdx\n  cmp    %rbp,%r14\n  jne    1180 <func0+0x40>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %rax,%r12\n  test   %ebp,%ebp\n  jle    L0\n  xor    %r14d,%r14d\n  lea    D0(%rip),%r13\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    (%rbx,%r14,8),%rdx\n  xor    %r15d,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     L2\n  and    $0x1,%eax\n  cmp    $0x1,%al\n  sbb    $0xffffffff,%r15d\nL2:\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    L3\nL1:\n  mov    $0x64,%edi\n  call   <malloc@plt>\n  sub    $0x8,%rsp\n  mov    %r15d,%r9d\n  mov    %r15d,%r8d\n  push   %r15\n  mov    %rax,%rdi\n  mov    $0x64,%edx\n  mov    %r13,%rcx\n  mov    %rax,(%r12,%r14,8)\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%r14\n  call   <__sprintf_chk@plt>\n  pop    %rax\n  pop    %rdx\n  cmp    %rbp,%r14\n  jne    L4\nL0:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3718
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4592
        },
        "L1": {
          "label": "L1",
          "addr": 4532
        },
        "L2": {
          "label": "L2",
          "addr": 4521
        },
        "L3": {
          "label": "L3",
          "addr": 4504
        },
        "L4": {
          "label": "L4",
          "addr": 4480
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "746865206e756d626572206f66206f646420656c656d656e747320256420696e2074686520737472696e67202564206f662074686520256420696e7075742e00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"the number of odd elements %d in the string %d of the %d input.\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char **func0(char **arr, int size) {\n  int i, j, k, odd_count;\n  char **res = malloc(size * sizeof(char *));\n  for (i = 0; i < size; i++) {\n    odd_count = 0;\n    for (j = 0; arr[i][j] != '\\0'; j++) {\n      if (arr[i][j] >= '0' && arr[i][j] <= '9' && arr[i][j] % 2 != 0) {\n        odd_count++;\n      }\n    }\n    res[i] = malloc(100);\n    __sprintf_chk(res[i], 1, 100, \"the number of odd elements %d in the string %d of the %d input.\", odd_count, i, odd_count);\n  }\n  return res;\n}"
    },
    {
      "task_id": 116,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    124d <func0+0x154>\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    123d <func0+0x144>\n  movl   $0x0,-0x18(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    1169 <func0+0x70>\n  mov    -0x14(%rbp),%eax\n  and    $0x1,%eax\n  add    %eax,-0x18(%rbp)\n  sarl   -0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     115d <func0+0x64>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    118a <func0+0x91>\n  mov    -0x10(%rbp),%eax\n  and    $0x1,%eax\n  add    %eax,-0x18(%rbp)\n  sarl   -0x10(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jg     117e <func0+0x85>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     11da <func0+0xe1>\n  mov    -0x10(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    1239 <func0+0x140>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    1239 <func0+0x140>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1122 <func0+0x29>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1114 <func0+0x1b>\n  nop\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL9:\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    L1\nL8:\n  movl   $0x0,-0x18(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    L2\nL3:\n  mov    -0x14(%rbp),%eax\n  and    $0x1,%eax\n  add    %eax,-0x18(%rbp)\n  sarl   -0x14(%rbp)\nL2:\n  cmpl   $0x0,-0x14(%rbp)\n  jg     L3\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    L4\nL5:\n  mov    -0x10(%rbp),%eax\n  and    $0x1,%eax\n  add    %eax,-0x18(%rbp)\n  sarl   -0x10(%rbp)\nL4:\n  cmpl   $0x0,-0x10(%rbp)\n  jg     L5\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L6\n  mov    -0x10(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    L7\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L7\nL6:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\nL7:\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L8\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L9\n  nop\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4685
        },
        "L1": {
          "label": "L1",
          "addr": 4669
        },
        "L2": {
          "label": "L2",
          "addr": 4457
        },
        "L3": {
          "label": "L3",
          "addr": 4445
        },
        "L4": {
          "label": "L4",
          "addr": 4490
        },
        "L5": {
          "label": "L5",
          "addr": 4478
        },
        "L6": {
          "label": "L6",
          "addr": 4570
        },
        "L7": {
          "label": "L7",
          "addr": 4665
        },
        "L8": {
          "label": "L8",
          "addr": 4386
        },
        "L9": {
          "label": "L9",
          "addr": 4372
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *p, int n) {\n  int i, j, t, a, b;\n  for (i = 0; i < n; i++)\n    for (j = i + 1; j < n; j++) {\n      t = 0;\n      a = p[i];\n      b = p[j];\n      while (a > 0) {\n        t += a & 1;\n        a >>= 1;\n      }\n      a = t;\n      t = 0;\n      while (b > 0) {\n        t += b & 1;\n        b >>= 1;\n      }\n      b = t;\n      if (b < a || (b == a && p[j] < p[i])) {\n        t = p[i];\n        p[i] = p[j];\n        p[j] = t;\n      }\n    }\n}"
    },
    {
      "task_id": 116,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  test   %ebp,%ebp\n  jle    11a9 <func0+0xa9>\n  mov    %rdi,%r12\n  lea    0x4(%rdi),%r10\n  lea    -0x1(%rbp),%r13d\n  mov    $0x1,%ebx\n  add    $0x8,%r12\n  cmp    %rbp,%rbx\n  je     11a9 <func0+0xa9>\n  nopl   (%rax)\n  mov    %r13d,%eax\n  mov    %r10,%rdi\n  sub    %ebx,%eax\n  lea    -0x1(%rbx,%rax,1),%rax\n  lea    (%r12,%rax,4),%r11\n  nopl   0x0(%rax)\n  mov    -0x4(%r10),%r8d\n  mov    (%rdi),%r9d\n  test   %r8d,%r8d\n  jle    11c0 <func0+0xc0>\n  mov    %r8d,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax)\n  mov    %eax,%edx\n  and    $0x1,%edx\n  add    %edx,%ecx\n  sar    %eax\n  jne    1160 <func0+0x60>\n  test   %r9d,%r9d\n  jle    1183 <func0+0x83>\n  mov    %r9d,%edx\n  xor    %eax,%eax\n  nopl   (%rax)\n  mov    %edx,%esi\n  and    $0x1,%esi\n  add    %esi,%eax\n  sar    %edx\n  jne    1178 <func0+0x78>\n  cmp    %eax,%ecx\n  jg     11b0 <func0+0xb0>\n  sete   %al\n  cmp    %r9d,%r8d\n  jle    1193 <func0+0x93>\n  test   %al,%al\n  jne    11b0 <func0+0xb0>\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  jne    1148 <func0+0x48>\n  add    $0x1,%rbx\n  add    $0x4,%r10\n  cmp    %rbp,%rbx\n  jne    1130 <func0+0x30>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  mov    %r9d,-0x4(%r10)\n  mov    %r8d,(%rdi)\n  jmp    1193 <func0+0x93>\n  nopl   0x0(%rax)\n  xor    %ecx,%ecx\n  mov    $0x1,%eax\n  test   %r9d,%r9d\n  jg     1170 <func0+0x70>\n  jmp    118a <func0+0x8a>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  test   %ebp,%ebp\n  jle    L0\n  mov    %rdi,%r12\n  lea    0x4(%rdi),%r10\n  lea    -0x1(%rbp),%r13d\n  mov    $0x1,%ebx\n  add    $0x8,%r12\n  cmp    %rbp,%rbx\n  je     L0\n  nopl   (%rax)\nL8:\n  mov    %r13d,%eax\n  mov    %r10,%rdi\n  sub    %ebx,%eax\n  lea    -0x1(%rbx,%rax,1),%rax\n  lea    (%r12,%rax,4),%r11\n  nopl   0x0(%rax)\nL7:\n  mov    -0x4(%r10),%r8d\n  mov    (%rdi),%r9d\n  test   %r8d,%r8d\n  jle    L1\n  mov    %r8d,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax)\nL2:\n  mov    %eax,%edx\n  and    $0x1,%edx\n  add    %edx,%ecx\n  sar    %eax\n  jne    L2\n  test   %r9d,%r9d\n  jle    L3\nL9:\n  mov    %r9d,%edx\n  xor    %eax,%eax\n  nopl   (%rax)\nL4:\n  mov    %edx,%esi\n  and    $0x1,%esi\n  add    %esi,%eax\n  sar    %edx\n  jne    L4\nL3:\n  cmp    %eax,%ecx\n  jg     L5\n  sete   %al\nL10:\n  cmp    %r9d,%r8d\n  jle    L6\n  test   %al,%al\n  jne    L5\nL6:\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  jne    L7\n  add    $0x1,%rbx\n  add    $0x4,%r10\n  cmp    %rbp,%rbx\n  jne    L8\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL5:\n  mov    %r9d,-0x4(%r10)\n  mov    %r8d,(%rdi)\n  jmp    L6\n  nopl   0x0(%rax)\nL1:\n  xor    %ecx,%ecx\n  mov    $0x1,%eax\n  test   %r9d,%r9d\n  jg     L9\n  jmp    L10",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4521
        },
        "L1": {
          "label": "L1",
          "addr": 4544
        },
        "L2": {
          "label": "L2",
          "addr": 4448
        },
        "L3": {
          "label": "L3",
          "addr": 4483
        },
        "L4": {
          "label": "L4",
          "addr": 4472
        },
        "L5": {
          "label": "L5",
          "addr": 4528
        },
        "L6": {
          "label": "L6",
          "addr": 4499
        },
        "L7": {
          "label": "L7",
          "addr": 4424
        },
        "L8": {
          "label": "L8",
          "addr": 4400
        },
        "L9": {
          "label": "L9",
          "addr": 4464
        },
        "L10": {
          "label": "L10",
          "addr": 4490
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n) {\n  int i, j, t;\n  for (i = 0; i < n; i++)\n    for (j = i + 1; j < n; j++) {\n      int a = x[i], b = x[j], c = 0, d = 0;\n      while (a > 0) {\n        c += a & 1;\n        a >>= 1;\n      }\n      while (b > 0) {\n        d += b & 1;\n        b >>= 1;\n      }\n      if (c > d || (c == d && b < a)) {\n        t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n      }\n    }\n}"
    },
    {
      "task_id": 112,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   10b0 <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   10d0 <malloc@plt>\n  movzbl (%rbx),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     1211 <func0+0x71>\n  movzbl (%r14),%r8d\n  lea    0x1(%rbx),%rsi\n  xor    %edi,%edi\n  nopl   0x0(%rax)\n  mov    %r14,%rdx\n  mov    %r8d,%eax\n  test   %r8b,%r8b\n  jne    11fc <func0+0x5c>\n  jmp    1270 <func0+0xd0>\n  movzbl 0x1(%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     1270 <func0+0xd0>\n  cmp    %al,%cl\n  jne    11f0 <func0+0x50>\n  movzbl (%rsi),%ecx\n  add    $0x1,%rsi\n  test   %cl,%cl\n  jne    11e0 <func0+0x40>\n  movslq %edi,%rax\n  add    %r13,%rax\n  movb   $0x0,(%rax)\n  mov    %r13,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,%esi\n  shr    $0x1f,%esi\n  add    %eax,%esi\n  sar    %esi\n  cmp    $0x1,%eax\n  jle    1290 <func0+0xf0>\n  lea    -0x1(%rax),%ecx\n  xor    %edx,%edx\n  movslq %ecx,%rcx\n  add    %r13,%rcx\n  jmp    124c <func0+0xac>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%rdx\n  sub    $0x1,%rcx\n  cmp    %edx,%esi\n  jle    1290 <func0+0xf0>\n  movzbl (%rcx),%ebx\n  cmp    %bl,0x0(%r13,%rdx,1)\n  je     1240 <func0+0xa0>\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   10c0 <memcpy@plt>\n  lea    0xd94(%rip),%rsi        # 2000 <_fini+0xd40>\n  jmp    12a6 <func0+0x106>\n  xchg   %ax,%ax\n  movslq %edi,%rax\n  add    $0x1,%rsi\n  add    $0x1,%edi\n  mov    %cl,0x0(%r13,%rax,1)\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  jne    11e0 <func0+0x40>\n  jmp    120b <func0+0x6b>\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   10c0 <memcpy@plt>\n  lea    0xd60(%rip),%rsi        # 2006 <_fini+0xd46>\n  mov    %rbp,%rdi\n  call   10a0 <strcpy@plt>\n  pop    %rbx\n  mov    %r13,%rdi\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1090 <free@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  movzbl (%rbx),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     L0\n  movzbl (%r14),%r8d\n  lea    0x1(%rbx),%rsi\n  xor    %edi,%edi\n  nopl   0x0(%rax)\nL4:\n  mov    %r14,%rdx\n  mov    %r8d,%eax\n  test   %r8b,%r8b\n  jne    L1\n  jmp    L2\nL3:\n  movzbl 0x1(%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     L2\nL1:\n  cmp    %al,%cl\n  jne    L3\n  movzbl (%rsi),%ecx\n  add    $0x1,%rsi\n  test   %cl,%cl\n  jne    L4\nL9:\n  movslq %edi,%rax\n  add    %r13,%rax\nL0:\n  movb   $0x0,(%rax)\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  mov    %eax,%esi\n  shr    $0x1f,%esi\n  add    %eax,%esi\n  sar    %esi\n  cmp    $0x1,%eax\n  jle    L5\n  lea    -0x1(%rax),%ecx\n  xor    %edx,%edx\n  movslq %ecx,%rcx\n  add    %r13,%rcx\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL7:\n  add    $0x1,%rdx\n  sub    $0x1,%rcx\n  cmp    %edx,%esi\n  jle    L5\nL6:\n  movzbl (%rcx),%ebx\n  cmp    %bl,0x0(%r13,%rdx,1)\n  je     L7\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   <memcpy@plt>\n  lea    D0(%rip),%rsi\n  jmp    L8\n  xchg   %ax,%ax\nL2:\n  movslq %edi,%rax\n  add    $0x1,%rsi\n  add    $0x1,%edi\n  mov    %cl,0x0(%r13,%rax,1)\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  jne    L4\n  jmp    L9\nL5:\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   <memcpy@plt>\n  lea    D1(%rip),%rsi\nL8:\n  mov    %rbp,%rdi\n  call   <strcpy@plt>\n  pop    %rbx\n  mov    %r13,%rdi\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1090 <free@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3476
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8198,
          "bias": [
            3424
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4625
        },
        "L1": {
          "label": "L1",
          "addr": 4604
        },
        "L2": {
          "label": "L2",
          "addr": 4720
        },
        "L3": {
          "label": "L3",
          "addr": 4592
        },
        "L4": {
          "label": "L4",
          "addr": 4576
        },
        "L5": {
          "label": "L5",
          "addr": 4752
        },
        "L6": {
          "label": "L6",
          "addr": 4684
        },
        "L7": {
          "label": "L7",
          "addr": 4672
        },
        "L8": {
          "label": "L8",
          "addr": 4774
        },
        "L9": {
          "label": "L9",
          "addr": 4619
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "46616c7365005472756500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"False\""
          },
          "0x2006": {
            "type": "string",
            "value": "\"True\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s1, char *s2, char *s3, char *s4) {\n  int i = 0, j = 0, k = 0, len = 0;\n  char *s = NULL;\n  s = (char *)malloc((len = strlen(s1) + 1) * sizeof(char));\n  while (s1[i] != '\\0') {\n    j = 0;\n    while (s2[j] != '\\0') {\n      if (s1[i] == s2[j]) {\n        break;\n      }\n      j++;\n    }\n    if (s2[j] == '\\0') {\n      s[k++] = s1[i];\n    }\n    i++;\n  }\n  s[k] = '\\0';\n  len = strlen(s);\n  for (i = 0, j = len - 1; i < len / 2; i++, j--) {\n    if (s[i] != s[j]) {\n      break;\n    }\n  }\n  if (i >= len / 2) {\n    memcpy(s3, s, len + 1);\n    strcpy(s4, \"True\");\n  } else {\n    memcpy(s3, s, len + 1);\n    strcpy(s4, \"False\");\n  }\n  free(s);\n  return;\n}"
    },
    {
      "task_id": 116,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    11cd <func0+0xd4>\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r13\n  lea    0x4(%rdi),%r9\n  lea    -0x1(%rsi),%r14d\n  mov    %esi,%r12d\n  mov    $0x1,%ebp\n  add    $0x8,%r13\n  jmp    1198 <func0+0x9f>\n  mov    $0x0,%ecx\n  jmp    1181 <func0+0x88>\n  mov    %r8d,-0x4(%r11)\n  mov    %edi,(%r10)\n  add    $0x4,%rsi\n  cmp    %rbx,%rsi\n  je     1190 <func0+0x97>\n  mov    %r9,%r11\n  mov    -0x4(%r9),%edi\n  mov    %rsi,%r10\n  mov    (%rsi),%r8d\n  test   %edi,%edi\n  jle    11b1 <func0+0xb8>\n  mov    %edi,%eax\n  mov    $0x0,%edx\n  mov    %eax,%ecx\n  and    $0x1,%ecx\n  add    %ecx,%edx\n  sar    %eax\n  test   %eax,%eax\n  jg     1157 <func0+0x5e>\n  test   %r8d,%r8d\n  jle    1128 <func0+0x2f>\n  mov    %r8d,%eax\n  mov    $0x0,%ecx\n  mov    %eax,%r15d\n  and    $0x1,%r15d\n  add    %r15d,%ecx\n  sar    %eax\n  test   %eax,%eax\n  jg     1171 <func0+0x78>\n  cmp    %ecx,%edx\n  jg     112f <func0+0x36>\n  cmp    %r8d,%edi\n  jle    1136 <func0+0x3d>\n  cmp    %edx,%ecx\n  jne    1136 <func0+0x3d>\n  jmp    112f <func0+0x36>\n  add    $0x1,%rbp\n  add    $0x4,%r9\n  cmp    %r12,%rbp\n  je     11c2 <func0+0xc9>\n  mov    %r14d,%eax\n  sub    %ebp,%eax\n  lea    -0x1(%rbp,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rbx\n  mov    %r9,%rsi\n  jmp    113f <func0+0x46>\n  mov    $0x0,%edx\n  mov    $0x0,%ecx\n  test   %r8d,%r8d\n  jg     1169 <func0+0x70>\n  jmp    1185 <func0+0x8c>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r13\n  lea    0x4(%rdi),%r9\n  lea    -0x1(%rsi),%r14d\n  mov    %esi,%r12d\n  mov    $0x1,%ebp\n  add    $0x8,%r13\n  jmp    L1\nL6:\n  mov    $0x0,%ecx\n  jmp    L2\nL8:\n  mov    %r8d,-0x4(%r11)\n  mov    %edi,(%r10)\nL9:\n  add    $0x4,%rsi\n  cmp    %rbx,%rsi\n  je     L3\nL11:\n  mov    %r9,%r11\n  mov    -0x4(%r9),%edi\n  mov    %rsi,%r10\n  mov    (%rsi),%r8d\n  test   %edi,%edi\n  jle    L4\n  mov    %edi,%eax\n  mov    $0x0,%edx\nL5:\n  mov    %eax,%ecx\n  and    $0x1,%ecx\n  add    %ecx,%edx\n  sar    %eax\n  test   %eax,%eax\n  jg     L5\n  test   %r8d,%r8d\n  jle    L6\nL12:\n  mov    %r8d,%eax\n  mov    $0x0,%ecx\nL7:\n  mov    %eax,%r15d\n  and    $0x1,%r15d\n  add    %r15d,%ecx\n  sar    %eax\n  test   %eax,%eax\n  jg     L7\nL2:\n  cmp    %ecx,%edx\n  jg     L8\nL13:\n  cmp    %r8d,%edi\n  jle    L9\n  cmp    %edx,%ecx\n  jne    L9\n  jmp    L8\nL3:\n  add    $0x1,%rbp\n  add    $0x4,%r9\nL1:\n  cmp    %r12,%rbp\n  je     L10\n  mov    %r14d,%eax\n  sub    %ebp,%eax\n  lea    -0x1(%rbp,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rbx\n  mov    %r9,%rsi\n  jmp    L11\nL4:\n  mov    $0x0,%edx\n  mov    $0x0,%ecx\n  test   %r8d,%r8d\n  jg     L12\n  jmp    L13\nL10:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4557
        },
        "L1": {
          "label": "L1",
          "addr": 4504
        },
        "L2": {
          "label": "L2",
          "addr": 4481
        },
        "L3": {
          "label": "L3",
          "addr": 4496
        },
        "L4": {
          "label": "L4",
          "addr": 4529
        },
        "L5": {
          "label": "L5",
          "addr": 4439
        },
        "L6": {
          "label": "L6",
          "addr": 4392
        },
        "L7": {
          "label": "L7",
          "addr": 4465
        },
        "L8": {
          "label": "L8",
          "addr": 4399
        },
        "L9": {
          "label": "L9",
          "addr": 4406
        },
        "L10": {
          "label": "L10",
          "addr": 4546
        },
        "L11": {
          "label": "L11",
          "addr": 4415
        },
        "L12": {
          "label": "L12",
          "addr": 4457
        },
        "L13": {
          "label": "L13",
          "addr": 4485
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n) {\n  int i, j;\n  for (i = 0; i < n; i++) {\n    for (j = i + 1; j < n; j++) {\n      int a = x[i], b = x[j];\n      int c1 = 0, c2 = 0;\n      while (a > 0) {\n        c1 += a & 1;\n        a >>= 1;\n      }\n      while (b > 0) {\n        c2 += b & 1;\n        b >>= 1;\n      }\n      if (c1 > c2 || (c1 == c2 && x[i] > x[j])) {\n        x[i] = x[i] ^ x[j];\n        x[j] = x[i] ^ x[j];\n        x[i] = x[i] ^ x[j];\n      }\n    }\n  }\n}"
    },
    {
      "task_id": 116,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    11ae <func0+0xae>\n  push   %rbp\n  mov    %rdi,%r10\n  movslq %esi,%rbp\n  mov    $0x1,%r11d\n  push   %rbx\n  mov    %esi,%ebx\n  nopl   (%rax)\n  mov    %r11,%rdi\n  nopl   0x0(%rax,%rax,1)\n  mov    -0x4(%r10,%r11,4),%r8d\n  mov    (%r10,%rdi,4),%r9d\n  test   %r8d,%r8d\n  jle    11a0 <func0+0xa0>\n  mov    %r8d,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\n  mov    %eax,%edx\n  and    $0x1,%edx\n  add    %edx,%ecx\n  sar    %eax\n  jne    1140 <func0+0x40>\n  test   %r9d,%r9d\n  jle    1163 <func0+0x63>\n  mov    %r9d,%edx\n  xor    %eax,%eax\n  nopl   (%rax)\n  mov    %edx,%esi\n  and    $0x1,%esi\n  add    %esi,%eax\n  sar    %edx\n  jne    1158 <func0+0x58>\n  cmp    %eax,%ecx\n  jg     1190 <func0+0x90>\n  sete   %al\n  cmp    %r9d,%r8d\n  jle    1173 <func0+0x73>\n  test   %al,%al\n  jne    1190 <func0+0x90>\n  add    $0x1,%rdi\n  cmp    %edi,%ebx\n  jg     1128 <func0+0x28>\n  add    $0x1,%r11\n  cmp    %r11,%rbp\n  jne    1120 <func0+0x20>\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %r9d,-0x4(%r10,%r11,4)\n  mov    %r8d,(%r10,%rdi,4)\n  jmp    1173 <func0+0x73>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ecx,%ecx\n  mov    $0x1,%eax\n  test   %r9d,%r9d\n  jg     1150 <func0+0x50>\n  jmp    116a <func0+0x6a>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  push   %rbp\n  mov    %rdi,%r10\n  movslq %esi,%rbp\n  mov    $0x1,%r11d\n  push   %rbx\n  mov    %esi,%ebx\n  nopl   (%rax)\nL8:\n  mov    %r11,%rdi\n  nopl   0x0(%rax,%rax,1)\nL7:\n  mov    -0x4(%r10,%r11,4),%r8d\n  mov    (%r10,%rdi,4),%r9d\n  test   %r8d,%r8d\n  jle    L1\n  mov    %r8d,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    %eax,%edx\n  and    $0x1,%edx\n  add    %edx,%ecx\n  sar    %eax\n  jne    L2\n  test   %r9d,%r9d\n  jle    L3\nL9:\n  mov    %r9d,%edx\n  xor    %eax,%eax\n  nopl   (%rax)\nL4:\n  mov    %edx,%esi\n  and    $0x1,%esi\n  add    %esi,%eax\n  sar    %edx\n  jne    L4\nL3:\n  cmp    %eax,%ecx\n  jg     L5\n  sete   %al\nL10:\n  cmp    %r9d,%r8d\n  jle    L6\n  test   %al,%al\n  jne    L5\nL6:\n  add    $0x1,%rdi\n  cmp    %edi,%ebx\n  jg     L7\n  add    $0x1,%r11\n  cmp    %r11,%rbp\n  jne    L8\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopw   0x0(%rax,%rax,1)\nL5:\n  mov    %r9d,-0x4(%r10,%r11,4)\n  mov    %r8d,(%r10,%rdi,4)\n  jmp    L6\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %ecx,%ecx\n  mov    $0x1,%eax\n  test   %r9d,%r9d\n  jg     L9\n  jmp    L10\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4526
        },
        "L1": {
          "label": "L1",
          "addr": 4512
        },
        "L2": {
          "label": "L2",
          "addr": 4416
        },
        "L3": {
          "label": "L3",
          "addr": 4451
        },
        "L4": {
          "label": "L4",
          "addr": 4440
        },
        "L5": {
          "label": "L5",
          "addr": 4496
        },
        "L6": {
          "label": "L6",
          "addr": 4467
        },
        "L7": {
          "label": "L7",
          "addr": 4392
        },
        "L8": {
          "label": "L8",
          "addr": 4384
        },
        "L9": {
          "label": "L9",
          "addr": 4432
        },
        "L10": {
          "label": "L10",
          "addr": 4458
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n) {\n  int i, j, t;\n  for (i = 0; i < n - 1; i++) {\n    for (j = i + 1; j < n; j++) {\n      int a = x[i], b = x[j], c = 0, d = 0;\n      while (a > 0) {\n        c += a & 1;\n        a >>= 1;\n      }\n      while (b > 0) {\n        d += b & 1;\n        b >>= 1;\n      }\n      if (c > d || (c == d && b < a)) {\n        t = x[i];\n        x[i] = x[j];\n        x[j] = t;\n      }\n    }\n  }\n}"
    },
    {
      "task_id": 118,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbp\n  call   1060 <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    11cd <func0+0x94>\n  movslq %edx,%rdx\n  lea    0x0(%rbp,%rdx,1),%rbx\n  lea    -0x1(%rbp,%rdx,1),%r14\n  lea    -0x3(%rax),%eax\n  sub    %rax,%r14\n  lea    0xe92(%rip),%r12        # 2000 <_fini+0xe2c>\n  jmp    1179 <func0+0x40>\n  sub    $0x1,%rbx\n  cmp    %r14,%rbx\n  je     11b1 <func0+0x78>\n  movzbl (%rbx),%ebp\n  movsbl %bpl,%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     1170 <func0+0x37>\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1170 <func0+0x37>\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1170 <func0+0x37>\n  jmp    11b6 <func0+0x7d>\n  mov    $0x0,%ebp\n  mov    %bpl,0x2e74(%rip)        # 4031 <out.0>\n  lea    0x2e6d(%rip),%rax        # 4031 <out.0>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x0,%ebp\n  jmp    11b6 <func0+0x7d>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbp\n  call   <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    L0\n  movslq %edx,%rdx\n  lea    0x0(%rbp,%rdx,1),%rbx\n  lea    -0x1(%rbp,%rdx,1),%r14\n  lea    -0x3(%rax),%eax\n  sub    %rax,%r14\n  lea    D0(%rip),%r12\n  jmp    L1\nL3:\n  sub    $0x1,%rbx\n  cmp    %r14,%rbx\n  je     L2\nL1:\n  movzbl (%rbx),%ebp\n  movsbl %bpl,%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L3\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L3\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L3\n  jmp    L4\nL2:\n  mov    $0x0,%ebp\nL4:\n  mov    %bpl,D1(%rip)\n  lea    D1(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  mov    $0x0,%ebp\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3730
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 16433,
          "bias": [
            11892,
            11885
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4557
        },
        "L1": {
          "label": "L1",
          "addr": 4473
        },
        "L2": {
          "label": "L2",
          "addr": 4529
        },
        "L3": {
          "label": "L3",
          "addr": 4464
        },
        "L4": {
          "label": "L4",
          "addr": 4534
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f556165696f7500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOUaeiou\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *s) {\n  static char buf[2];\n  int i;\n  buf[0] = 0;\n  for (i = strlen(s) - 2; i > 0; i--) {\n    if (strchr(\"aeiou\", s[i]) && !strchr(\"aeiou\", s[i + 1]) && !strchr(\"aeiou\", s[i - 1])) {\n      buf[0] = s[i];\n      return buf;\n    }\n  }\n  return buf;\n}"
    },
    {
      "task_id": 118,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    0xeb0(%rip),%rax        # 2000 <_fini+0xdd8>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  sub    $0x2,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    120e <func0+0xd5>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     120a <func0+0xd1>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    120a <func0+0xd1>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    120a <func0+0xd1>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,0x2e30(%rip)        # 4031 <out.0>\n  lea    0x2e29(%rip),%rax        # 4031 <out.0>\n  jmp    1226 <func0+0xed>\n  subl   $0x1,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     1173 <func0+0x3a>\n  movb   $0x0,0x2e12(%rip)        # 4031 <out.0>\n  lea    0x2e0b(%rip),%rax        # 4031 <out.0>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  sub    $0x2,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    L0\nL3:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L1\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L1\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,D1(%rip)\n  lea    D1(%rip),%rax\n  jmp    L2\nL1:\n  subl   $0x1,-0x14(%rbp)\nL0:\n  cmpl   $0x0,-0x14(%rbp)\n  jg     L3\n  movb   $0x0,D1(%rip)\n  lea    D1(%rip),%rax\nL2:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3760
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 16433,
          "bias": [
            11824,
            11817,
            11794,
            11787
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4622
        },
        "L1": {
          "label": "L1",
          "addr": 4618
        },
        "L2": {
          "label": "L2",
          "addr": 4646
        },
        "L3": {
          "label": "L3",
          "addr": 4467
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f556165696f7500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOUaeiou\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *s) {\n  static char buf[2];\n  const char *p = \"aeiou\";\n  size_t len = strlen(s);\n  int i;\n  for (i = len - 2; i > 0; i--) {\n    if (strchr(p, s[i]) && !strchr(p, s[i + 1]) && !strchr(p, s[i - 1])) {\n      buf[0] = s[i];\n      return buf;\n    }\n  }\n  buf[0] = '\\0';\n  return buf;\n}"
    },
    {
      "task_id": 118,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    11e0 <func0+0xa0>\n  movslq %edx,%rdx\n  sub    $0x3,%eax\n  lea    0xe92(%rip),%r12        # 2000 <_fini+0xe1c>\n  lea    -0x1(%rbp,%rdx,1),%r13\n  lea    0x0(%rbp,%rdx,1),%rbx\n  sub    %rax,%r13\n  jmp    1189 <func0+0x49>\n  nopl   (%rax)\n  sub    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     11e0 <func0+0xa0>\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  mov    %esi,%ebp\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     1180 <func0+0x40>\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1180 <func0+0x40>\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1180 <func0+0x40>\n  mov    %bpl,0x2e6d(%rip)        # 4031 <out.0>\n  add    $0x8,%rsp\n  lea    0x2e62(%rip),%rax        # 4031 <out.0>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  xor    %ebp,%ebp\n  jmp    11bd <func0+0x7d>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    L0\n  movslq %edx,%rdx\n  sub    $0x3,%eax\n  lea    D0(%rip),%r12\n  lea    -0x1(%rbp,%rdx,1),%r13\n  lea    0x0(%rbp,%rdx,1),%rbx\n  sub    %rax,%r13\n  jmp    L1\n  nopl   (%rax)\nL2:\n  sub    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  mov    %esi,%ebp\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L2\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\nL3:\n  mov    %bpl,D1(%rip)\n  add    $0x8,%rsp\n  lea    D1(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  xor    %ebp,%ebp\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3730
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 16433,
          "bias": [
            11885,
            11874
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4576
        },
        "L1": {
          "label": "L1",
          "addr": 4489
        },
        "L2": {
          "label": "L2",
          "addr": 4480
        },
        "L3": {
          "label": "L3",
          "addr": 4541
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f556165696f7500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOUaeiou\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s) {\n  static char buf[2];\n  int i;\n  for (i = strlen(s) - 2; i > 0; i--) {\n    if (strchr(\"AEIOUaeiou\", s[i]) && !strchr(\"AEIOUaeiou\", s[i + 1]) && !strchr(\"AEIOUaeiou\", s[i - 1])) {\n      buf[0] = s[i];\n      return buf;\n    }\n  }\n  buf[0] = 0;\n  return buf;\n}"
    },
    {
      "task_id": 118,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    11e0 <func0+0xa0>\n  movslq %edx,%rdx\n  sub    $0x3,%eax\n  lea    0xe92(%rip),%r12        # 2000 <_fini+0xe1c>\n  lea    -0x1(%rbp,%rdx,1),%r13\n  lea    0x0(%rbp,%rdx,1),%rbx\n  sub    %rax,%r13\n  jmp    1189 <func0+0x49>\n  nopl   (%rax)\n  sub    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     11e0 <func0+0xa0>\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  mov    %esi,%ebp\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     1180 <func0+0x40>\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1180 <func0+0x40>\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1180 <func0+0x40>\n  mov    %bpl,0x2e6d(%rip)        # 4031 <out.0>\n  add    $0x8,%rsp\n  lea    0x2e62(%rip),%rax        # 4031 <out.0>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  xor    %ebp,%ebp\n  jmp    11bd <func0+0x7d>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    L0\n  movslq %edx,%rdx\n  sub    $0x3,%eax\n  lea    D0(%rip),%r12\n  lea    -0x1(%rbp,%rdx,1),%r13\n  lea    0x0(%rbp,%rdx,1),%rbx\n  sub    %rax,%r13\n  jmp    L1\n  nopl   (%rax)\nL2:\n  sub    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  mov    %esi,%ebp\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L2\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\nL3:\n  mov    %bpl,D1(%rip)\n  add    $0x8,%rsp\n  lea    D1(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  xor    %ebp,%ebp\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3730
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 16433,
          "bias": [
            11885,
            11874
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4576
        },
        "L1": {
          "label": "L1",
          "addr": 4489
        },
        "L2": {
          "label": "L2",
          "addr": 4480
        },
        "L3": {
          "label": "L3",
          "addr": 4541
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4145494f556165696f7500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"AEIOUaeiou\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s) {\n  static char buf[2];\n  int i;\n  for (i = strlen(s) - 2; i > 0; i--) {\n    if (strchr(\"AEIOUaeiou\", s[i]) && !strchr(\"AEIOUaeiou\", s[i + 1]) && !strchr(\"AEIOUaeiou\", s[i - 1])) {\n      buf[0] = s[i];\n      return buf;\n    }\n  }\n  buf[0] = 0;\n  return buf;\n}"
    },
    {
      "task_id": 121,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    115f <func0+0x66>\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    115b <func0+0x62>\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jg     1118 <func0+0x1f>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jg     L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4447
        },
        "L1": {
          "label": "L1",
          "addr": 4443
        },
        "L2": {
          "label": "L2",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int sum = 0;\n  for (int i = 0; i * 2 < len; i++)\n    if (arr[i * 2] % 2 == 1)\n      sum += arr[i * 2];\n  return sum;\n}"
    },
    {
      "task_id": 121,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1138 <func0+0x3f>\n  mov    %rdi,%rcx\n  sub    $0x1,%esi\n  shr    %esi\n  mov    %esi,%esi\n  lea    0x8(%rdi,%rsi,8),%r8\n  mov    $0x0,%esi\n  mov    (%rcx),%eax\n  mov    %eax,%edi\n  shr    $0x1f,%edi\n  lea    (%rax,%rdi,1),%edx\n  and    $0x1,%edx\n  sub    %edi,%edx\n  add    %esi,%eax\n  cmp    $0x1,%edx\n  cmove  %eax,%esi\n  add    $0x8,%rcx\n  cmp    %r8,%rcx\n  jne    1115 <func0+0x1c>\n  mov    %esi,%eax\n  ret\n  mov    $0x0,%esi\n  jmp    1135 <func0+0x3c>",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rcx\n  sub    $0x1,%esi\n  shr    %esi\n  mov    %esi,%esi\n  lea    0x8(%rdi,%rsi,8),%r8\n  mov    $0x0,%esi\nL1:\n  mov    (%rcx),%eax\n  mov    %eax,%edi\n  shr    $0x1f,%edi\n  lea    (%rax,%rdi,1),%edx\n  and    $0x1,%edx\n  sub    %edi,%edx\n  add    %esi,%eax\n  cmp    $0x1,%edx\n  cmove  %eax,%esi\n  add    $0x8,%rcx\n  cmp    %r8,%rcx\n  jne    L1\nL2:\n  mov    %esi,%eax\n  ret\nL0:\n  mov    $0x0,%esi\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4373
        },
        "L2": {
          "label": "L2",
          "addr": 4405
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, sum = 0;\n  for (i = 0; i < len; i++) {\n    if (arr[i] % 2 == 1)\n      sum += arr[i];\n  }\n  return sum;\n}"
    },
    {
      "task_id": 120,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11dc <func0+0xe3>\n  movl   $0x0,-0xc(%rbp)\n  jmp    11c6 <func0+0xcd>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    11c2 <func0+0xc9>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0x1c(%rbp),%eax\n  sub    -0x10(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     1127 <func0+0x2e>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x10(%rbp)\n  jl     111b <func0+0x22>\n  movl   $0x0,-0x8(%rbp)\n  jmp    122f <func0+0x136>\n  mov    -0x1c(%rbp),%eax\n  sub    -0x20(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     11f4 <func0+0xfb>\n  nop\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL4:\n  movl   $0x0,-0xc(%rbp)\n  jmp    L1\nL3:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L2\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL1:\n  mov    -0x1c(%rbp),%eax\n  sub    -0x10(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     L3\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x10(%rbp)\n  jl     L4\n  movl   $0x0,-0x8(%rbp)\n  jmp    L5\nL6:\n  mov    -0x1c(%rbp),%eax\n  sub    -0x20(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\nL5:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     L6\n  nop\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4572
        },
        "L1": {
          "label": "L1",
          "addr": 4550
        },
        "L2": {
          "label": "L2",
          "addr": 4546
        },
        "L3": {
          "label": "L3",
          "addr": 4391
        },
        "L4": {
          "label": "L4",
          "addr": 4379
        },
        "L5": {
          "label": "L5",
          "addr": 4655
        },
        "L6": {
          "label": "L6",
          "addr": 4596
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *p, int n, int m, int *q) {\n  int i, j, tmp;\n  for (i = 0; i < n - 1; i++)\n    for (j = 0; j < n - i - 1; j++)\n      if (p[j] > p[j + 1]) {\n        tmp = p[j];\n        p[j] = p[j + 1];\n        p[j + 1] = tmp;\n      }\n  for (j = 0; j < m; j++)\n    q[j] = p[n - m + j];\n}"
    },
    {
      "task_id": 120,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%r8\n  mov    %esi,%r10d\n  mov    %edx,%ebx\n  mov    %rcx,%r9\n  lea    -0x1(%rsi),%edi\n  test   %edi,%edi\n  jle    1144 <func0+0x4b>\n  lea    0x4(%r8),%r11\n  jmp    1134 <func0+0x3b>\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     112f <func0+0x36>\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    1116 <func0+0x1d>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    1116 <func0+0x1d>\n  sub    $0x1,%edi\n  je     1144 <func0+0x4b>\n  test   %edi,%edi\n  jle    112f <func0+0x36>\n  mov    %r8,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r11,%rdx,4),%rsi\n  jmp    111f <func0+0x26>\n  test   %ebx,%ebx\n  jle    116c <func0+0x73>\n  mov    %ebx,%esi\n  movslq %r10d,%r10\n  movslq %ebx,%rbx\n  sub    %rbx,%r10\n  lea    (%r8,%r10,4),%rcx\n  mov    $0x0,%eax\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r9,%rax,4)\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    115c <func0+0x63>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%r8\n  mov    %esi,%r10d\n  mov    %edx,%ebx\n  mov    %rcx,%r9\n  lea    -0x1(%rsi),%edi\n  test   %edi,%edi\n  jle    L0\n  lea    0x4(%r8),%r11\n  jmp    L1\nL3:\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     L2\nL4:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L3\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    L3\nL2:\n  sub    $0x1,%edi\n  je     L0\nL1:\n  test   %edi,%edi\n  jle    L2\n  mov    %r8,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r11,%rdx,4),%rsi\n  jmp    L4\nL0:\n  test   %ebx,%ebx\n  jle    L5\n  mov    %ebx,%esi\n  movslq %r10d,%r10\n  movslq %ebx,%rbx\n  sub    %rbx,%r10\n  lea    (%r8,%r10,4),%rcx\n  mov    $0x0,%eax\nL6:\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r9,%rax,4)\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    L6\nL5:\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4420
        },
        "L1": {
          "label": "L1",
          "addr": 4404
        },
        "L2": {
          "label": "L2",
          "addr": 4399
        },
        "L3": {
          "label": "L3",
          "addr": 4374
        },
        "L4": {
          "label": "L4",
          "addr": 4383
        },
        "L5": {
          "label": "L5",
          "addr": 4460
        },
        "L6": {
          "label": "L6",
          "addr": 4444
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *p, int n, int m, int *q) {\n  int i, j, tmp;\n  for (i = 0; i < n - 1; i++)\n    for (j = 0; j < n - i - 1; j++)\n      if (p[j] > p[j + 1]) {\n        tmp = p[j];\n        p[j] = p[j + 1];\n        p[j + 1] = tmp;\n      }\n  for (i = 0; i < m; i++)\n    q[i] = p[n - m + i];\n}"
    },
    {
      "task_id": 120,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edx,%ebx\n  lea    -0x1(%rsi),%edx\n  mov    %rdi,%r8\n  mov    %esi,%r11d\n  mov    %rcx,%r9\n  test   %edx,%edx\n  jle    114d <func0+0x4d>\n  lea    0x4(%rdi),%r10\n  nopl   0x0(%rax,%rax,1)\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r10,%rdx,4),%rsi\n  nopl   (%rax)\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    113e <func0+0x3e>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    1130 <func0+0x30>\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    1120 <func0+0x20>\n  test   %ebx,%ebx\n  jle    1170 <func0+0x70>\n  sub    %ebx,%r11d\n  movslq %ebx,%rsi\n  movslq %r11d,%rax\n  lea    (%r8,%rax,4),%rcx\n  xor    %eax,%eax\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r9,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    1160 <func0+0x60>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edx,%ebx\n  lea    -0x1(%rsi),%edx\n  mov    %rdi,%r8\n  mov    %esi,%r11d\n  mov    %rcx,%r9\n  test   %edx,%edx\n  jle    L0\n  lea    0x4(%rdi),%r10\n  nopl   0x0(%rax,%rax,1)\nL3:\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r10,%rdx,4),%rsi\n  nopl   (%rax)\nL2:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L1\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\nL1:\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    L2\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    L3\nL0:\n  test   %ebx,%ebx\n  jle    L4\n  sub    %ebx,%r11d\n  movslq %ebx,%rsi\n  movslq %r11d,%rax\n  lea    (%r8,%rax,4),%rcx\n  xor    %eax,%eax\nL5:\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r9,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    L5\nL4:\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4429
        },
        "L1": {
          "label": "L1",
          "addr": 4414
        },
        "L2": {
          "label": "L2",
          "addr": 4400
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4464
        },
        "L5": {
          "label": "L5",
          "addr": 4448
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *p, int n, int m, int *q) {\n  int i, j, tmp;\n  for (i = 0; i < n - 1; i++)\n    for (j = 0; j < n - i - 1; j++)\n      if (p[j] > p[j + 1]) {\n        tmp = p[j];\n        p[j] = p[j + 1];\n        p[j + 1] = tmp;\n      }\n  for (i = 0; i < m; i++)\n    q[i] = p[n - m + i];\n}"
    },
    {
      "task_id": 121,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1140 <func0+0x40>\n  sub    $0x1,%esi\n  xor    %r8d,%r8d\n  shr    %esi\n  lea    0x8(%rdi,%rsi,8),%rsi\n  nopl   (%rax)\n  mov    (%rdi),%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rax,%rcx,1),%edx\n  add    %r8d,%eax\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  cmove  %eax,%r8d\n  add    $0x8,%rdi\n  cmp    %rsi,%rdi\n  jne    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret\n  xchg   %ax,%ax\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  sub    $0x1,%esi\n  xor    %r8d,%r8d\n  shr    %esi\n  lea    0x8(%rdi,%rsi,8),%rsi\n  nopl   (%rax)\nL1:\n  mov    (%rdi),%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rax,%rcx,1),%edx\n  add    %r8d,%eax\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  cmove  %eax,%r8d\n  add    $0x8,%rdi\n  cmp    %rsi,%rdi\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  xchg   %ax,%ax\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, sum = 0;\n  for (i = 0; i < len; i++)\n    if (arr[i] % 2 == 1)\n      sum += arr[i];\n  return sum;\n}"
    },
    {
      "task_id": 120,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movslq %esi,%r11\n  push   %rbx\n  mov    %rdi,%r8\n  mov    %edx,%r9d\n  lea    -0x1(%r11),%eax\n  mov    %rcx,%r10\n  test   %eax,%eax\n  jle    115d <func0+0x5d>\n  lea    0x4(%rdi),%rbx\n  nopl   (%rax)\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%rbx,%rax,4),%rsi\n  nopl   (%rax)\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%eax\n  movd   %xmm2,%ecx\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jge    114e <func0+0x4e>\n  movq   %xmm1,(%rdx)\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    1130 <func0+0x30>\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    1120 <func0+0x20>\n  test   %r9d,%r9d\n  jle    1212 <func0+0x112>\n  movslq %r9d,%rax\n  mov    %r11d,%esi\n  mov    %r10,%rdx\n  sub    %rax,%r11\n  sub    %r9d,%esi\n  lea    0x4(,%r11,4),%rax\n  lea    (%r8,%rax,1),%rcx\n  sub    %rcx,%rdx\n  cmp    $0x8,%rdx\n  jbe    1214 <func0+0x114>\n  lea    -0x1(%r9),%edx\n  cmp    $0x2,%edx\n  jbe    1214 <func0+0x114>\n  mov    %r9d,%edx\n  lea    -0x4(%r8,%rax,1),%rcx\n  xor    %eax,%eax\n  shr    $0x2,%edx\n  shl    $0x4,%rdx\n  nopl   0x0(%rax,%rax,1)\n  movdqu (%rcx,%rax,1),%xmm3\n  movups %xmm3,(%r10,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rdx\n  jne    11b0 <func0+0xb0>\n  mov    %r9d,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%r9b\n  je     1212 <func0+0x112>\n  lea    (%rsi,%rax,1),%edx\n  mov    %eax,%ecx\n  movslq %edx,%rdx\n  lea    0x0(,%rcx,4),%rdi\n  mov    (%r8,%rdx,4),%edx\n  mov    %edx,(%r10,%rcx,4)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%r9d\n  jle    1212 <func0+0x112>\n  add    %esi,%edx\n  add    $0x2,%eax\n  movslq %edx,%rdx\n  mov    (%r8,%rdx,4),%edx\n  mov    %edx,0x4(%r10,%rdi,1)\n  cmp    %eax,%r9d\n  jle    1212 <func0+0x112>\n  add    %esi,%eax\n  cltq\n  mov    (%r8,%rax,4),%eax\n  mov    %eax,0x8(%r10,%rdi,1)\n  pop    %rbx\n  ret\n  mov    %r9d,%r9d\n  lea    (%r8,%r11,4),%rcx\n  xor    %eax,%eax\n  nopl   (%rax)\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r10,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r9\n  jne    1220 <func0+0x120>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movslq %esi,%r11\n  push   %rbx\n  mov    %rdi,%r8\n  mov    %edx,%r9d\n  lea    -0x1(%r11),%eax\n  mov    %rcx,%r10\n  test   %eax,%eax\n  jle    L0\n  lea    0x4(%rdi),%rbx\n  nopl   (%rax)\nL3:\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%rbx,%rax,4),%rsi\n  nopl   (%rax)\nL2:\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%eax\n  movd   %xmm2,%ecx\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jge    L1\n  movq   %xmm1,(%rdx)\nL1:\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    L2\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    L3\nL0:\n  test   %r9d,%r9d\n  jle    L4\n  movslq %r9d,%rax\n  mov    %r11d,%esi\n  mov    %r10,%rdx\n  sub    %rax,%r11\n  sub    %r9d,%esi\n  lea    0x4(,%r11,4),%rax\n  lea    (%r8,%rax,1),%rcx\n  sub    %rcx,%rdx\n  cmp    $0x8,%rdx\n  jbe    L5\n  lea    -0x1(%r9),%edx\n  cmp    $0x2,%edx\n  jbe    L5\n  mov    %r9d,%edx\n  lea    -0x4(%r8,%rax,1),%rcx\n  xor    %eax,%eax\n  shr    $0x2,%edx\n  shl    $0x4,%rdx\n  nopl   0x0(%rax,%rax,1)\nL6:\n  movdqu (%rcx,%rax,1),%xmm3\n  movups %xmm3,(%r10,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rdx\n  jne    L6\n  mov    %r9d,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%r9b\n  je     L4\n  lea    (%rsi,%rax,1),%edx\n  mov    %eax,%ecx\n  movslq %edx,%rdx\n  lea    0x0(,%rcx,4),%rdi\n  mov    (%r8,%rdx,4),%edx\n  mov    %edx,(%r10,%rcx,4)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%r9d\n  jle    L4\n  add    %esi,%edx\n  add    $0x2,%eax\n  movslq %edx,%rdx\n  mov    (%r8,%rdx,4),%edx\n  mov    %edx,0x4(%r10,%rdi,1)\n  cmp    %eax,%r9d\n  jle    L4\n  add    %esi,%eax\n  cltq\n  mov    (%r8,%rax,4),%eax\n  mov    %eax,0x8(%r10,%rdi,1)\nL4:\n  pop    %rbx\n  ret\nL5:\n  mov    %r9d,%r9d\n  lea    (%r8,%r11,4),%rcx\n  xor    %eax,%eax\n  nopl   (%rax)\nL7:\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r10,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r9\n  jne    L7\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4445
        },
        "L1": {
          "label": "L1",
          "addr": 4430
        },
        "L2": {
          "label": "L2",
          "addr": 4400
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4626
        },
        "L5": {
          "label": "L5",
          "addr": 4628
        },
        "L6": {
          "label": "L6",
          "addr": 4528
        },
        "L7": {
          "label": "L7",
          "addr": 4640
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *p, int n, int m, int *q) {\n  int i, j;\n  for (i = n - 1; i > 0; i--) {\n    for (j = 0; j < i; j++) {\n      if (p[j] > p[j + 1]) {\n        int tmp = p[j];\n        p[j] = p[j + 1];\n        p[j + 1] = tmp;\n      }\n    }\n  }\n  for (i = 0; i < m; i++) {\n    q[i] = p[n - m + i];\n  }\n}"
    },
    {
      "task_id": 122,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    116b <func0+0x72>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0xffffff9d,%eax\n  jl     1167 <func0+0x6e>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x63,%eax\n  jg     1167 <func0+0x6e>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1118 <func0+0x1f>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0xffffff9d,%eax\n  jl     L1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x63,%eax\n  jg     L1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4459
        },
        "L1": {
          "label": "L1",
          "addr": 4455
        },
        "L2": {
          "label": "L2",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int result = 0;\n  for (int i = 0; i < len; i++)\n    if (arr[i] >= -99 && arr[i] <= 99)\n      result += arr[i];\n  return result;\n}"
    },
    {
      "task_id": 121,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  test   %esi,%esi\n  jle    1240 <func0+0x140>\n  lea    -0x1(%rsi),%edx\n  cmp    $0x7,%edx\n  jbe    1243 <func0+0x143>\n  shr    $0x3,%edx\n  mov    %rdi,%rax\n  movdqa 0xed7(%rip),%xmm4        # 2000 <_fini+0xdb0>\n  pxor   %xmm2,%xmm2\n  lea    -0x1(%rdx),%edi\n  shl    $0x5,%rdi\n  lea    0x20(%rcx,%rdi,1),%rdi\n  nopl   0x0(%rax)\n  movdqu (%rax),%xmm1\n  movdqu 0x10(%rax),%xmm5\n  add    $0x20,%rax\n  shufps $0x88,%xmm5,%xmm1\n  movdqa %xmm1,%xmm3\n  movdqa %xmm1,%xmm0\n  psrld  $0x1f,%xmm3\n  paddd  %xmm3,%xmm0\n  pand   %xmm4,%xmm0\n  psubd  %xmm3,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pand   %xmm1,%xmm0\n  paddd  %xmm0,%xmm2\n  cmp    %rdi,%rax\n  jne    1140 <func0+0x40>\n  movdqa %xmm2,%xmm0\n  lea    0x0(,%rdx,4),%r9d\n  shl    $0x3,%edx\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%eax\n  movslq %edx,%rdx\n  mov    (%rcx,%rdx,4),%edx\n  mov    %edx,%r8d\n  shr    $0x1f,%r8d\n  lea    (%rdx,%r8,1),%edi\n  add    %eax,%edx\n  and    $0x1,%edi\n  sub    %r8d,%edi\n  cmp    $0x1,%edi\n  cmove  %edx,%eax\n  lea    0x2(%r9,%r9,1),%edx\n  cmp    %esi,%edx\n  jge    1242 <func0+0x142>\n  movslq %edx,%rdi\n  lea    0x0(,%rdi,4),%r9\n  mov    (%rcx,%rdi,4),%edi\n  mov    %edi,%r10d\n  shr    $0x1f,%r10d\n  lea    (%rdi,%r10,1),%r8d\n  add    %eax,%edi\n  and    $0x1,%r8d\n  sub    %r10d,%r8d\n  cmp    $0x1,%r8d\n  cmove  %edi,%eax\n  lea    0x2(%rdx),%edi\n  cmp    %edi,%esi\n  jle    1242 <func0+0x142>\n  mov    0x8(%rcx,%r9,1),%edi\n  mov    %edi,%r10d\n  shr    $0x1f,%r10d\n  lea    (%rdi,%r10,1),%r8d\n  add    %eax,%edi\n  and    $0x1,%r8d\n  sub    %r10d,%r8d\n  cmp    $0x1,%r8d\n  cmove  %edi,%eax\n  add    $0x4,%edx\n  cmp    %edx,%esi\n  jle    1242 <func0+0x142>\n  mov    0x10(%rcx,%r9,1),%edx\n  mov    %edx,%esi\n  shr    $0x1f,%esi\n  lea    (%rdx,%rsi,1),%ecx\n  add    %eax,%edx\n  and    $0x1,%ecx\n  sub    %esi,%ecx\n  cmp    $0x1,%ecx\n  cmove  %edx,%eax\n  ret\n  xchg   %ax,%ax\n  xor    %eax,%eax\n  ret\n  xor    %r9d,%r9d\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    11a4 <func0+0xa4>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%edx\n  cmp    $0x7,%edx\n  jbe    L1\n  shr    $0x3,%edx\n  mov    %rdi,%rax\n  movdqa D0(%rip),%xmm4\n  pxor   %xmm2,%xmm2\n  lea    -0x1(%rdx),%edi\n  shl    $0x5,%rdi\n  lea    0x20(%rcx,%rdi,1),%rdi\n  nopl   0x0(%rax)\nL2:\n  movdqu (%rax),%xmm1\n  movdqu 0x10(%rax),%xmm5\n  add    $0x20,%rax\n  shufps $0x88,%xmm5,%xmm1\n  movdqa %xmm1,%xmm3\n  movdqa %xmm1,%xmm0\n  psrld  $0x1f,%xmm3\n  paddd  %xmm3,%xmm0\n  pand   %xmm4,%xmm0\n  psubd  %xmm3,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pand   %xmm1,%xmm0\n  paddd  %xmm0,%xmm2\n  cmp    %rdi,%rax\n  jne    L2\n  movdqa %xmm2,%xmm0\n  lea    0x0(,%rdx,4),%r9d\n  shl    $0x3,%edx\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%eax\nL4:\n  movslq %edx,%rdx\n  mov    (%rcx,%rdx,4),%edx\n  mov    %edx,%r8d\n  shr    $0x1f,%r8d\n  lea    (%rdx,%r8,1),%edi\n  add    %eax,%edx\n  and    $0x1,%edi\n  sub    %r8d,%edi\n  cmp    $0x1,%edi\n  cmove  %edx,%eax\n  lea    0x2(%r9,%r9,1),%edx\n  cmp    %esi,%edx\n  jge    L3\n  movslq %edx,%rdi\n  lea    0x0(,%rdi,4),%r9\n  mov    (%rcx,%rdi,4),%edi\n  mov    %edi,%r10d\n  shr    $0x1f,%r10d\n  lea    (%rdi,%r10,1),%r8d\n  add    %eax,%edi\n  and    $0x1,%r8d\n  sub    %r10d,%r8d\n  cmp    $0x1,%r8d\n  cmove  %edi,%eax\n  lea    0x2(%rdx),%edi\n  cmp    %edi,%esi\n  jle    L3\n  mov    0x8(%rcx,%r9,1),%edi\n  mov    %edi,%r10d\n  shr    $0x1f,%r10d\n  lea    (%rdi,%r10,1),%r8d\n  add    %eax,%edi\n  and    $0x1,%r8d\n  sub    %r10d,%r8d\n  cmp    $0x1,%r8d\n  cmove  %edi,%eax\n  add    $0x4,%edx\n  cmp    %edx,%esi\n  jle    L3\n  mov    0x10(%rcx,%r9,1),%edx\n  mov    %edx,%esi\n  shr    $0x1f,%esi\n  lea    (%rdx,%rsi,1),%ecx\n  add    %eax,%edx\n  and    $0x1,%ecx\n  sub    %esi,%ecx\n  cmp    $0x1,%ecx\n  cmove  %edx,%eax\n  ret\n  xchg   %ax,%ax\nL0:\n  xor    %eax,%eax\nL3:\n  ret\nL1:\n  xor    %r9d,%r9d\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    L4",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3799
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4672
        },
        "L1": {
          "label": "L1",
          "addr": 4675
        },
        "L2": {
          "label": "L2",
          "addr": 4416
        },
        "L3": {
          "label": "L3",
          "addr": 4674
        },
        "L4": {
          "label": "L4",
          "addr": 4516
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "01000000010000000100000001000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int a[], int n) {\n  int s = 0;\n  int i;\n  for (i = 0; i < n; i++)\n    if (a[i] % 2 == 1)\n      s += a[i];\n  return s;\n}"
    },
    {
      "task_id": 122,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    112d <func0+0x34>\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rdi\n  mov    $0x0,%ecx\n  mov    (%rdx),%eax\n  lea    0x63(%rax),%esi\n  add    %ecx,%eax\n  cmp    $0xc7,%esi\n  cmovb  %eax,%ecx\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    1111 <func0+0x18>\n  mov    %ecx,%eax\n  ret\n  mov    $0x0,%ecx\n  jmp    112a <func0+0x31>",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rdi\n  mov    $0x0,%ecx\nL1:\n  mov    (%rdx),%eax\n  lea    0x63(%rax),%esi\n  add    %ecx,%eax\n  cmp    $0xc7,%esi\n  cmovb  %eax,%ecx\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    L1\nL2:\n  mov    %ecx,%eax\n  ret\nL0:\n  mov    $0x0,%ecx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4397
        },
        "L1": {
          "label": "L1",
          "addr": 4369
        },
        "L2": {
          "label": "L2",
          "addr": 4394
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, sum = 0;\n  for (i = 0; i < len; i++) {\n    if (arr[i] + 99 < 200)\n      sum += arr[i];\n  }\n  return sum;\n}"
    },
    {
      "task_id": 117,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%r14\n  mov    %esi,0x10(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   10d0 <strlen@plt>\n  mov    %rax,%r13\n  lea    0x1(%rax),%rdi\n  call   10f0 <malloc@plt>\n  mov    %rax,0x20(%rsp)\n  call   1110 <__ctype_b_loc@plt>\n  mov    %rax,%r15\n  mov    $0x0,%ebx\n  movl   $0x0,0xc(%rsp)\n  movl   $0x0,0x14(%rsp)\n  movl   $0x0,0x8(%rsp)\n  movq   $0x0,0x18(%rsp)\n  jmp    126a <func0+0x91>\n  mov    0x8(%rsp),%esi\n  cmp    %esi,0x10(%rsp)\n  je     12c5 <func0+0xec>\n  mov    0x4(%rsp),%eax\n  add    $0x1,%eax\n  mov    %eax,0xc(%rsp)\n  movl   $0x0,0x8(%rsp)\n  lea    0x1(%rbx),%rax\n  cmp    %rbx,%r13\n  je     1322 <func0+0x149>\n  mov    %rax,%rbx\n  mov    %ebx,0x4(%rsp)\n  mov    %ebx,%eax\n  mov    (%r15),%r12\n  movzbl (%r14,%rbx,1),%ebp\n  movsbq %bpl,%rdx\n  testb  $0x20,0x1(%r12,%rdx,2)\n  jne    123d <func0+0x64>\n  test   %bpl,%bpl\n  je     123d <func0+0x64>\n  sub    0xc(%rsp),%eax\n  cltq\n  mov    0x20(%rsp),%rcx\n  mov    %bpl,(%rcx,%rax,1)\n  movsbl %bpl,%esi\n  lea    0xd5d(%rip),%rdi        # 2000 <_fini+0xcb4>\n  call   10e0 <strchr@plt>\n  test   %rax,%rax\n  jne    125a <func0+0x81>\n  movzbl %bpl,%ebp\n  movzwl (%r12,%rbp,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbbl   $0xffffffff,0x8(%rsp)\n  jmp    125a <func0+0x81>\n  sub    0xc(%rsp),%eax\n  cltq\n  mov    0x20(%rsp),%r12\n  movb   $0x0,(%r12,%rax,1)\n  addl   $0x1,0x14(%rsp)\n  mov    0x14(%rsp),%eax\n  movslq %eax,%rbp\n  shl    $0x3,%rbp\n  mov    %rbp,%rsi\n  mov    0x18(%rsp),%rdi\n  call   1100 <realloc@plt>\n  mov    %rax,0x18(%rsp)\n  mov    %r12,%rdi\n  call   10d0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   10f0 <malloc@plt>\n  mov    %rax,%rdi\n  mov    0x18(%rsp),%rax\n  mov    %rdi,-0x8(%rax,%rbp,1)\n  mov    %r12,%rsi\n  call   10c0 <strcpy@plt>\n  jmp    1247 <func0+0x6e>\n  mov    0x20(%rsp),%rdi\n  call   10b0 <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x14(%rsp),%ecx\n  mov    %ecx,(%rax)\n  mov    0x18(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%r14\n  mov    %esi,0x10(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   <strlen@plt>\n  mov    %rax,%r13\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,0x20(%rsp)\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r15\n  mov    $0x0,%ebx\n  movl   $0x0,0xc(%rsp)\n  movl   $0x0,0x14(%rsp)\n  movl   $0x0,0x8(%rsp)\n  movq   $0x0,0x18(%rsp)\n  jmp    L0\nL3:\n  mov    0x8(%rsp),%esi\n  cmp    %esi,0x10(%rsp)\n  je     L1\nL5:\n  mov    0x4(%rsp),%eax\n  add    $0x1,%eax\n  mov    %eax,0xc(%rsp)\n  movl   $0x0,0x8(%rsp)\nL4:\n  lea    0x1(%rbx),%rax\n  cmp    %rbx,%r13\n  je     L2\n  mov    %rax,%rbx\nL0:\n  mov    %ebx,0x4(%rsp)\n  mov    %ebx,%eax\n  mov    (%r15),%r12\n  movzbl (%r14,%rbx,1),%ebp\n  movsbq %bpl,%rdx\n  testb  $0x20,0x1(%r12,%rdx,2)\n  jne    L3\n  test   %bpl,%bpl\n  je     L3\n  sub    0xc(%rsp),%eax\n  cltq\n  mov    0x20(%rsp),%rcx\n  mov    %bpl,(%rcx,%rax,1)\n  movsbl %bpl,%esi\n  lea    D0(%rip),%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L4\n  movzbl %bpl,%ebp\n  movzwl (%r12,%rbp,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbbl   $0xffffffff,0x8(%rsp)\n  jmp    L4\nL1:\n  sub    0xc(%rsp),%eax\n  cltq\n  mov    0x20(%rsp),%r12\n  movb   $0x0,(%r12,%rax,1)\n  addl   $0x1,0x14(%rsp)\n  mov    0x14(%rsp),%eax\n  movslq %eax,%rbp\n  shl    $0x3,%rbp\n  mov    %rbp,%rsi\n  mov    0x18(%rsp),%rdi\n  call   <realloc@plt>\n  mov    %rax,0x18(%rsp)\n  mov    %r12,%rdi\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  mov    0x18(%rsp),%rax\n  mov    %rdi,-0x8(%rax,%rbp,1)\n  mov    %r12,%rsi\n  call   <strcpy@plt>\n  jmp    L5\nL2:\n  mov    0x20(%rsp),%rdi\n  call   <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x14(%rsp),%ecx\n  mov    %ecx,(%rax)\n  mov    0x18(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3421
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4714
        },
        "L1": {
          "label": "L1",
          "addr": 4805
        },
        "L2": {
          "label": "L2",
          "addr": 4898
        },
        "L3": {
          "label": "L3",
          "addr": 4669
        },
        "L4": {
          "label": "L4",
          "addr": 4698
        },
        "L5": {
          "label": "L5",
          "addr": 4679
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char **func0(char *s, int wl, int *n) {\n  size_t len = strlen(s);\n  char *w = malloc(len + 1);\n  int wi = 0;\n  int cc = 0;\n  int wc = 0;\n  char **a = NULL;\n  const unsigned short *_p;\n  _p = *(__const unsigned short **)(__ctype_b_loc());\n  for (int i = 0; i < len; ++i) {\n    char c = s[i];\n    if (!(_p[c + 1] & (1 << 5)) && c) {\n      w[i - cc] = c;\n      if (strchr(\"aeiouAEIOU\", c)) {\n        continue;\n      }\n      if (_p[c] & (1 << 10)) {\n        ++cc;\n      }\n    } else {\n      if (cc == wl) {\n        w[i - cc] = '\\0';\n        a = realloc(a, (++wc + 1) * sizeof(char *));\n        a[wc - 1] = malloc(strlen(w) + 1);\n        strcpy(a[wc - 1], w);\n      }\n      cc = 0;\n    }\n  }\n  free(w);\n  *n = wc;\n  return a;\n}"
    },
    {
      "task_id": 122,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1140 <func0+0x40>\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%rcx\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdi),%eax\n  lea    0x63(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0xc7,%edx\n  cmovb  %eax,%r8d\n  add    $0x4,%rdi\n  cmp    %rcx,%rdi\n  jne    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%rcx\n  nopl   0x0(%rax,%rax,1)\nL1:\n  mov    (%rdi),%eax\n  lea    0x63(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0xc7,%edx\n  cmovb  %eax,%r8d\n  add    $0x4,%rdi\n  cmp    %rcx,%rdi\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, sum = 0;\n  for (i = 0; i < len; i++)\n    if (arr[i] > 99 && arr[i] < 200)\n      sum += arr[i];\n  return sum;\n}"
    },
    {
      "task_id": 117,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x58,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %rdx,-0x58(%rbp)\n  lea    0xe08(%rip),%rax        # 2000 <_fini+0xc10>\n  mov    %rax,-0x28(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strlen@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x20(%rbp),%rax\n  add    $0x1,%rax\n  mov    %rax,%rdi\n  call   10f0 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  jmp    13c2 <func0+0x1e9>\n  call   1110 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    1292 <func0+0xb9>\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1341 <func0+0x168>\n  mov    -0x40(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jne    132f <func0+0x156>\n  mov    -0x34(%rbp),%eax\n  sub    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x3c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x30(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1100 <realloc@plt>\n  mov    %rax,-0x30(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strlen@plt>\n  add    $0x1,%rax\n  mov    -0x3c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x30(%rbp),%rdx\n  lea    (%rcx,%rdx,1),%rbx\n  mov    %rax,%rdi\n  call   10f0 <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x18(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10c0 <strcpy@plt>\n  addl   $0x1,-0x3c(%rbp)\n  mov    -0x34(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x38(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  jmp    13be <func0+0x1e5>\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  sub    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x28(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   10e0 <strchr@plt>\n  test   %rax,%rax\n  jne    13be <func0+0x1e5>\n  call   1110 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     13be <func0+0x1e5>\n  addl   $0x1,-0x40(%rbp)\n  addl   $0x1,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  cmp    %rax,-0x20(%rbp)\n  jae    1249 <func0+0x70>\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <free@plt>\n  mov    -0x58(%rbp),%rax\n  mov    -0x3c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x30(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x58,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %rdx,-0x58(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x28(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x20(%rbp),%rax\n  add    $0x1,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  jmp    L0\nL5:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\nL1:\n  mov    -0x40(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jne    L3\n  mov    -0x34(%rbp),%eax\n  sub    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x3c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x30(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x30(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  add    $0x1,%rax\n  mov    -0x3c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x30(%rbp),%rdx\n  lea    (%rcx,%rdx,1),%rbx\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x18(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  addl   $0x1,-0x3c(%rbp)\nL3:\n  mov    -0x34(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x38(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  jmp    L4\nL2:\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  sub    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x28(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L4\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     L4\n  addl   $0x1,-0x40(%rbp)\nL4:\n  addl   $0x1,-0x34(%rbp)\nL0:\n  mov    -0x34(%rbp),%eax\n  cltq\n  cmp    %rax,-0x20(%rbp)\n  jae    L5\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x58(%rbp),%rax\n  mov    -0x3c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x30(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3592
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5058
        },
        "L1": {
          "label": "L1",
          "addr": 4754
        },
        "L2": {
          "label": "L2",
          "addr": 4929
        },
        "L3": {
          "label": "L3",
          "addr": 4911
        },
        "L4": {
          "label": "L4",
          "addr": 5054
        },
        "L5": {
          "label": "L5",
          "addr": 4681
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " char **func0(char *s, int n, int *m) {\n  char *t;\n  char **u;\n  char *v = \"aeiouAEIOU\";\n  size_t w;\n  int x;\n  int y;\n  int z;\n  int aa;\n  u = NULL;\n  aa = 0;\n  y = 0;\n  z = 0;\n  w = strlen(s);\n  t = malloc(w + 1);\n  for (x = 0; x <= w; x++) {\n    if (!((((*(const unsigned short *)(__ctype_b_loc()) + (unsigned char)(s[x])) & ((0x2000))) || (s[x]) == '\\0') || aa == n) {\n      if (aa == n) {\n        t[x - z] = '\\0';\n        u = realloc(u, (y + 1) * sizeof(char *));\n        u[y] = malloc(strlen(t) + 1);\n        strcpy(u[y], t);\n        y++;\n      }\n      z = x + 1;\n      aa = 0;\n    } else {\n      t[x - z] = s[x];\n      if (strchr(v, s[x]) == NULL && (((*(const unsigned short *)(__ctype_b_loc()) + (unsigned char)(s[x])) & ((0x0400)))) != 0)\n        aa++;\n    }\n  }\n  free(t);\n  *m = y;\n  return u;\n}"
    },
    {
      "task_id": 117,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x38,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   10c0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  mov    %rax,%r15\n  call   10f0 <malloc@plt>\n  add    $0x1,%r15d\n  mov    %rax,%rbp\n  call   1110 <__ctype_b_loc@plt>\n  movl   $0x0,0x20(%rsp)\n  xor    %r11d,%r11d\n  xor    %r8d,%r8d\n  mov    (%rax),%r12\n  jmp    1252 <func0+0x72>\n  nopl   0x0(%rax,%rax,1)\n  cmp    %r8d,0xc(%rsp)\n  je     12f0 <func0+0x110>\n  mov    %ebx,%r11d\n  xor    %r8d,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  je     12c1 <func0+0xe1>\n  movsbq (%r14),%rsi\n  mov    %ebx,%eax\n  add    $0x1,%ebx\n  mov    %rsi,%rdx\n  testb  $0x20,0x1(%r12,%rsi,2)\n  jne    1238 <func0+0x58>\n  test   %sil,%sil\n  je     1238 <func0+0x58>\n  sub    %r11d,%eax\n  lea    0xd8b(%rip),%rdi        # 2000 <_fini+0xcb0>\n  mov    %r8d,0x24(%rsp)\n  cltq\n  mov    %r11d,0x18(%rsp)\n  mov    %sil,0x0(%rbp,%rax,1)\n  movsbl %sil,%esi\n  mov    %dl,0x10(%rsp)\n  call   10d0 <strchr@plt>\n  movzbl 0x10(%rsp),%edx\n  mov    0x18(%rsp),%r11d\n  test   %rax,%rax\n  mov    0x24(%rsp),%r8d\n  jne    1249 <func0+0x69>\n  movzwl (%r12,%rdx,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbb    $0xffffffff,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  jne    1252 <func0+0x72>\n  mov    %rbp,%rdi\n  call   10b0 <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x20(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x38,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  addl   $0x1,0x20(%rsp)\n  movslq 0x20(%rsp),%rsi\n  sub    %r11d,%eax\n  mov    %r13,%rdi\n  cltq\n  shl    $0x3,%rsi\n  movb   $0x0,0x0(%rbp,%rax,1)\n  mov    %rsi,0x18(%rsp)\n  call   1100 <realloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r13\n  call   10c0 <strlen@plt>\n  lea    0x1(%rax),%rdx\n  mov    %rdx,%rdi\n  mov    %rdx,0x10(%rsp)\n  call   10f0 <malloc@plt>\n  mov    0x18(%rsp),%rsi\n  mov    0x10(%rsp),%rdx\n  mov    %rax,%rdi\n  mov    %rax,-0x8(%r13,%rsi,1)\n  mov    %rbp,%rsi\n  call   10e0 <memcpy@plt>\n  jmp    1243 <func0+0x63>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x38,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  mov    %rax,%r15\n  call   <malloc@plt>\n  add    $0x1,%r15d\n  mov    %rax,%rbp\n  call   <__ctype_b_loc@plt>\n  movl   $0x0,0x20(%rsp)\n  xor    %r11d,%r11d\n  xor    %r8d,%r8d\n  mov    (%rax),%r12\n  jmp    L0\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    %r8d,0xc(%rsp)\n  je     L1\nL5:\n  mov    %ebx,%r11d\n  xor    %r8d,%r8d\nL4:\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  je     L2\nL0:\n  movsbq (%r14),%rsi\n  mov    %ebx,%eax\n  add    $0x1,%ebx\n  mov    %rsi,%rdx\n  testb  $0x20,0x1(%r12,%rsi,2)\n  jne    L3\n  test   %sil,%sil\n  je     L3\n  sub    %r11d,%eax\n  lea    D0(%rip),%rdi\n  mov    %r8d,0x24(%rsp)\n  cltq\n  mov    %r11d,0x18(%rsp)\n  mov    %sil,0x0(%rbp,%rax,1)\n  movsbl %sil,%esi\n  mov    %dl,0x10(%rsp)\n  call   <strchr@plt>\n  movzbl 0x10(%rsp),%edx\n  mov    0x18(%rsp),%r11d\n  test   %rax,%rax\n  mov    0x24(%rsp),%r8d\n  jne    L4\n  movzwl (%r12,%rdx,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbb    $0xffffffff,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  jne    L0\nL2:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x20(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x38,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  addl   $0x1,0x20(%rsp)\n  movslq 0x20(%rsp),%rsi\n  sub    %r11d,%eax\n  mov    %r13,%rdi\n  cltq\n  shl    $0x3,%rsi\n  movb   $0x0,0x0(%rbp,%rax,1)\n  mov    %rsi,0x18(%rsp)\n  call   <realloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r13\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdx\n  mov    %rdx,%rdi\n  mov    %rdx,0x10(%rsp)\n  call   <malloc@plt>\n  mov    0x18(%rsp),%rsi\n  mov    0x10(%rsp),%rdx\n  mov    %rax,%rdi\n  mov    %rax,-0x8(%r13,%rsi,1)\n  mov    %rbp,%rsi\n  call   <memcpy@plt>\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3467
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4690
        },
        "L1": {
          "label": "L1",
          "addr": 4848
        },
        "L2": {
          "label": "L2",
          "addr": 4801
        },
        "L3": {
          "label": "L3",
          "addr": 4664
        },
        "L4": {
          "label": "L4",
          "addr": 4681
        },
        "L5": {
          "label": "L5",
          "addr": 4675
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char **func0(char *s, int n, int *m) {\n  int i, j, k, l, len, *map;\n  char *t, **a;\n  len = strlen(s);\n  t = (char *)malloc(len + 1);\n  map = (*((int *(*)(unsigned long))(__ctype_b_loc() + 2)));\n  a = NULL;\n  j = k = l = 0;\n  for (i = 0; i < len + 1; i++) {\n    if (((map[(int)s[i]] & (1 << 5)) != 0 || s[i] == '\\0') && k == n) {\n      k = 0;\n      t[i - j] = '\\0';\n      a = (char **)realloc(a, (l + 1) * sizeof(char *));\n      a[l++] = (char *)malloc(strlen(t) + 1);\n      memcpy(a[l - 1], t, strlen(t) + 1);\n      j = i;\n    }\n    if (((map[(int)s[i]] & (1 << 5)) != 0 || s[i] == '\\0') && k < n) {\n      t[i - j] = s[i];\n      if (strchr(\"aeiouAEIOU\", s[i]) == NULL && (map[(int)s[i]] & (1 << 10)) != 0)\n        k++;\n      j = i;\n    }\n  }\n  free(t);\n  *m = l;\n  return a;\n}"
    },
    {
      "task_id": 117,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x38,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   10c0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  mov    %rax,%r15\n  call   10f0 <malloc@plt>\n  add    $0x1,%r15d\n  mov    %rax,%rbp\n  call   1110 <__ctype_b_loc@plt>\n  movl   $0x0,0x20(%rsp)\n  xor    %r11d,%r11d\n  xor    %r8d,%r8d\n  mov    (%rax),%r12\n  jmp    1252 <func0+0x72>\n  nopl   0x0(%rax,%rax,1)\n  cmp    %r8d,0xc(%rsp)\n  je     12f0 <func0+0x110>\n  mov    %ebx,%r11d\n  xor    %r8d,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  je     12c1 <func0+0xe1>\n  movsbq (%r14),%rsi\n  mov    %ebx,%eax\n  add    $0x1,%ebx\n  mov    %rsi,%rdx\n  testb  $0x20,0x1(%r12,%rsi,2)\n  jne    1238 <func0+0x58>\n  test   %sil,%sil\n  je     1238 <func0+0x58>\n  sub    %r11d,%eax\n  lea    0xd8b(%rip),%rdi        # 2000 <_fini+0xcb0>\n  mov    %r8d,0x24(%rsp)\n  cltq\n  mov    %r11d,0x18(%rsp)\n  mov    %sil,0x0(%rbp,%rax,1)\n  movsbl %sil,%esi\n  mov    %dl,0x10(%rsp)\n  call   10d0 <strchr@plt>\n  movzbl 0x10(%rsp),%edx\n  mov    0x18(%rsp),%r11d\n  test   %rax,%rax\n  mov    0x24(%rsp),%r8d\n  jne    1249 <func0+0x69>\n  movzwl (%r12,%rdx,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbb    $0xffffffff,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  jne    1252 <func0+0x72>\n  mov    %rbp,%rdi\n  call   10b0 <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x20(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x38,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  addl   $0x1,0x20(%rsp)\n  movslq 0x20(%rsp),%rsi\n  sub    %r11d,%eax\n  mov    %r13,%rdi\n  cltq\n  shl    $0x3,%rsi\n  movb   $0x0,0x0(%rbp,%rax,1)\n  mov    %rsi,0x18(%rsp)\n  call   1100 <realloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r13\n  call   10c0 <strlen@plt>\n  lea    0x1(%rax),%rdx\n  mov    %rdx,%rdi\n  mov    %rdx,0x10(%rsp)\n  call   10f0 <malloc@plt>\n  mov    0x18(%rsp),%rsi\n  mov    0x10(%rsp),%rdx\n  mov    %rax,%rdi\n  mov    %rax,-0x8(%r13,%rsi,1)\n  mov    %rbp,%rsi\n  call   10e0 <memcpy@plt>\n  jmp    1243 <func0+0x63>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x38,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  mov    %rax,%r15\n  call   <malloc@plt>\n  add    $0x1,%r15d\n  mov    %rax,%rbp\n  call   <__ctype_b_loc@plt>\n  movl   $0x0,0x20(%rsp)\n  xor    %r11d,%r11d\n  xor    %r8d,%r8d\n  mov    (%rax),%r12\n  jmp    L0\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    %r8d,0xc(%rsp)\n  je     L1\nL5:\n  mov    %ebx,%r11d\n  xor    %r8d,%r8d\nL4:\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  je     L2\nL0:\n  movsbq (%r14),%rsi\n  mov    %ebx,%eax\n  add    $0x1,%ebx\n  mov    %rsi,%rdx\n  testb  $0x20,0x1(%r12,%rsi,2)\n  jne    L3\n  test   %sil,%sil\n  je     L3\n  sub    %r11d,%eax\n  lea    D0(%rip),%rdi\n  mov    %r8d,0x24(%rsp)\n  cltq\n  mov    %r11d,0x18(%rsp)\n  mov    %sil,0x0(%rbp,%rax,1)\n  movsbl %sil,%esi\n  mov    %dl,0x10(%rsp)\n  call   <strchr@plt>\n  movzbl 0x10(%rsp),%edx\n  mov    0x18(%rsp),%r11d\n  test   %rax,%rax\n  mov    0x24(%rsp),%r8d\n  jne    L4\n  movzwl (%r12,%rdx,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbb    $0xffffffff,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  jne    L0\nL2:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x20(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x38,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  addl   $0x1,0x20(%rsp)\n  movslq 0x20(%rsp),%rsi\n  sub    %r11d,%eax\n  mov    %r13,%rdi\n  cltq\n  shl    $0x3,%rsi\n  movb   $0x0,0x0(%rbp,%rax,1)\n  mov    %rsi,0x18(%rsp)\n  call   <realloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r13\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdx\n  mov    %rdx,%rdi\n  mov    %rdx,0x10(%rsp)\n  call   <malloc@plt>\n  mov    0x18(%rsp),%rsi\n  mov    0x10(%rsp),%rdx\n  mov    %rax,%rdi\n  mov    %rax,-0x8(%r13,%rsi,1)\n  mov    %rbp,%rsi\n  call   <memcpy@plt>\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3467
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4690
        },
        "L1": {
          "label": "L1",
          "addr": 4848
        },
        "L2": {
          "label": "L2",
          "addr": 4801
        },
        "L3": {
          "label": "L3",
          "addr": 4664
        },
        "L4": {
          "label": "L4",
          "addr": 4681
        },
        "L5": {
          "label": "L5",
          "addr": 4675
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6165696f754145494f5500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"aeiouAEIOU\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char **func0(char *s, int n, int *m) {\n  int i, j, k, l, len, *map;\n  char *t, **a;\n  len = strlen(s);\n  t = (char *)malloc(len + 1);\n  map = (*((int *(*)(unsigned long))(__ctype_b_loc() + 2)));\n  a = NULL;\n  j = k = l = 0;\n  for (i = 0; i < len + 1; i++) {\n    if (((map[(int)s[i]] & (1 << 5)) != 0 || s[i] == '\\0') && k == n) {\n      k = 0;\n      t[i - j] = '\\0';\n      a = (char **)realloc(a, (l + 1) * sizeof(char *));\n      a[l++] = (char *)malloc(strlen(t) + 1);\n      memcpy(a[l - 1], t, strlen(t) + 1);\n      j = i;\n    }\n    if (((map[(int)s[i]] & (1 << 5)) != 0 || s[i] == '\\0') && k < n) {\n      t[i - j] = s[i];\n      if (strchr(\"aeiouAEIOU\", s[i]) == NULL && (map[(int)s[i]] & (1 << 10)) != 0)\n        k++;\n      j = i;\n    }\n  }\n  free(t);\n  *m = l;\n  return a;\n}"
    },
    {
      "task_id": 122,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  mov    %esi,%edx\n  test   %esi,%esi\n  jle    11f8 <func0+0xf8>\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    1201 <func0+0x101>\n  shr    $0x2,%esi\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  movdqa 0xef1(%rip),%xmm3        # 2020 <_fini+0xe18>\n  movdqa 0xed9(%rip),%xmm2        # 2010 <_fini+0xe08>\n  sub    $0x1,%esi\n  movdqa 0xebe(%rip),%xmm4        # 2000 <_fini+0xdf8>\n  shl    $0x4,%rsi\n  lea    0x10(%rdi,%rsi,1),%rsi\n  psubd  %xmm3,%xmm2\n  nop\n  movdqu (%rax),%xmm0\n  movdqu (%rax),%xmm5\n  add    $0x10,%rax\n  paddd  %xmm4,%xmm0\n  psubd  %xmm3,%xmm0\n  pcmpgtd %xmm2,%xmm0\n  pandn  %xmm5,%xmm0\n  paddd  %xmm0,%xmm1\n  cmp    %rax,%rsi\n  jne    1150 <func0+0x50>\n  movdqa %xmm1,%xmm0\n  mov    %edx,%esi\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%esi\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%dl\n  je     1200 <func0+0x100>\n  movslq %esi,%rdi\n  lea    0x0(,%rdi,4),%r8\n  mov    (%rcx,%rdi,4),%edi\n  lea    0x63(%rdi),%r9d\n  add    %eax,%edi\n  cmp    $0xc7,%r9d\n  cmovb  %edi,%eax\n  lea    0x1(%rsi),%edi\n  cmp    %edx,%edi\n  jge    11fa <func0+0xfa>\n  mov    0x4(%rcx,%r8,1),%edi\n  lea    0x63(%rdi),%r9d\n  add    %eax,%edi\n  cmp    $0xc7,%r9d\n  cmovb  %edi,%eax\n  add    $0x2,%esi\n  cmp    %edx,%esi\n  jge    11fa <func0+0xfa>\n  mov    0x8(%rcx,%r8,1),%edx\n  lea    0x63(%rdx),%ecx\n  add    %eax,%edx\n  cmp    $0xc7,%ecx\n  cmovb  %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  ret\n  xor    %esi,%esi\n  xor    %eax,%eax\n  jmp    119d <func0+0x9d>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  mov    %esi,%edx\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    L1\n  shr    $0x2,%esi\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  movdqa D0(%rip),%xmm3\n  movdqa D1(%rip),%xmm2\n  sub    $0x1,%esi\n  movdqa D2(%rip),%xmm4\n  shl    $0x4,%rsi\n  lea    0x10(%rdi,%rsi,1),%rsi\n  psubd  %xmm3,%xmm2\n  nop\nL2:\n  movdqu (%rax),%xmm0\n  movdqu (%rax),%xmm5\n  add    $0x10,%rax\n  paddd  %xmm4,%xmm0\n  psubd  %xmm3,%xmm0\n  pcmpgtd %xmm2,%xmm0\n  pandn  %xmm5,%xmm0\n  paddd  %xmm0,%xmm1\n  cmp    %rax,%rsi\n  jne    L2\n  movdqa %xmm1,%xmm0\n  mov    %edx,%esi\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%esi\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%dl\n  je     L3\nL5:\n  movslq %esi,%rdi\n  lea    0x0(,%rdi,4),%r8\n  mov    (%rcx,%rdi,4),%edi\n  lea    0x63(%rdi),%r9d\n  add    %eax,%edi\n  cmp    $0xc7,%r9d\n  cmovb  %edi,%eax\n  lea    0x1(%rsi),%edi\n  cmp    %edx,%edi\n  jge    L4\n  mov    0x4(%rcx,%r8,1),%edi\n  lea    0x63(%rdi),%r9d\n  add    %eax,%edi\n  cmp    $0xc7,%r9d\n  cmovb  %edi,%eax\n  add    $0x2,%esi\n  cmp    %edx,%esi\n  jge    L4\n  mov    0x8(%rcx,%r8,1),%edx\n  lea    0x63(%rdx),%ecx\n  add    %eax,%edx\n  cmp    $0xc7,%ecx\n  cmovb  %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\nL4:\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  ret\nL1:\n  xor    %esi,%esi\n  xor    %eax,%eax\n  jmp    L5",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8224,
          "bias": [
            3825
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3801
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8192,
          "bias": [
            3774
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4600
        },
        "L1": {
          "label": "L1",
          "addr": 4609
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4608
        },
        "L4": {
          "label": "L4",
          "addr": 4602
        },
        "L5": {
          "label": "L5",
          "addr": 4509
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "63000000630000006300000063000000c6000000c6000000c6000000c600000000000080000000800000008000000080",
      "rodata_parsed": {
        "func0": {
          "0x2020": {
            "type": "byte[16]",
            "value": [
              0,
              0,
              0,
              128,
              0,
              0,
              0,
              128,
              0,
              0,
              0,
              128,
              0,
              0,
              0,
              128
            ]
          },
          "0x2010": {
            "type": "byte[16]",
            "value": [
              198,
              0,
              0,
              0,
              198,
              0,
              0,
              0,
              198,
              0,
              0,
              0,
              198,
              0,
              0,
              0
            ]
          },
          "0x2000": {
            "type": "byte[16]",
            "value": [
              99,
              0,
              0,
              0,
              99,
              0,
              0,
              0,
              99,
              0,
              0,
              0,
              99,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int n) {\n  int i, sum = 0;\n  for (i = 0; i < n; i++)\n    if (arr[i] % 100 < 99 && arr[i] % 100 >= 50)\n      sum += arr[i];\n  return sum;\n}"
    },
    {
      "task_id": 119,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11a3 <func0+0x8a>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    117a <func0+0x61>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    1192 <func0+0x79>\n  subl   $0x1,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jns    119f <func0+0x86>\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     1162 <func0+0x49>\n  movl   $0x0,-0x10(%rbp)\n  jmp    11f5 <func0+0xdc>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    11cc <func0+0xb3>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    11e4 <func0+0xcb>\n  subl   $0x1,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jns    11f1 <func0+0xd8>\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     11b4 <func0+0x9b>\n  cmpl   $0x0,-0x14(%rbp)\n  jne    1215 <func0+0xfc>\n  cmpl   $0x0,-0xc(%rbp)\n  je     1215 <func0+0xfc>\n  lea    0xdf0(%rip),%rax        # 2000 <_fini+0xd18>\n  jmp    12e3 <func0+0x1ca>\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    126d <func0+0x154>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    1244 <func0+0x12b>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    125c <func0+0x143>\n  subl   $0x1,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jns    1269 <func0+0x150>\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     122c <func0+0x113>\n  movl   $0x0,-0x10(%rbp)\n  jmp    12bf <func0+0x1a6>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    1296 <func0+0x17d>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    12ae <func0+0x195>\n  subl   $0x1,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jns    12bb <func0+0x1a2>\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     127e <func0+0x165>\n  cmpl   $0x0,-0x14(%rbp)\n  jne    12dc <func0+0x1c3>\n  cmpl   $0x0,-0xc(%rbp)\n  je     12dc <func0+0x1c3>\n  lea    0xd26(%rip),%rax        # 2000 <_fini+0xd18>\n  jmp    12e3 <func0+0x1ca>\n  lea    0xd21(%rip),%rax        # 2004 <_fini+0xd1c>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL4:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    L1\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    L2\n  subl   $0x1,-0x14(%rbp)\nL2:\n  cmpl   $0x0,-0x14(%rbp)\n  jns    L3\n  movl   $0x0,-0xc(%rbp)\nL3:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     L4\n  movl   $0x0,-0x10(%rbp)\n  jmp    L5\nL9:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    L6\n  addl   $0x1,-0x14(%rbp)\nL6:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    L7\n  subl   $0x1,-0x14(%rbp)\nL7:\n  cmpl   $0x0,-0x14(%rbp)\n  jns    L8\n  movl   $0x0,-0xc(%rbp)\nL8:\n  addl   $0x1,-0x10(%rbp)\nL5:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L9\n  cmpl   $0x0,-0x14(%rbp)\n  jne    L10\n  cmpl   $0x0,-0xc(%rbp)\n  je     L10\n  lea    D0(%rip),%rax\n  jmp    L11\nL10:\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L12\nL16:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    L13\n  addl   $0x1,-0x14(%rbp)\nL13:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    L14\n  subl   $0x1,-0x14(%rbp)\nL14:\n  cmpl   $0x0,-0x14(%rbp)\n  jns    L15\n  movl   $0x0,-0xc(%rbp)\nL15:\n  addl   $0x1,-0x10(%rbp)\nL12:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L16\n  movl   $0x0,-0x10(%rbp)\n  jmp    L17\nL21:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    L18\n  addl   $0x1,-0x14(%rbp)\nL18:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    L19\n  subl   $0x1,-0x14(%rbp)\nL19:\n  cmpl   $0x0,-0x14(%rbp)\n  jns    L20\n  movl   $0x0,-0xc(%rbp)\nL20:\n  addl   $0x1,-0x10(%rbp)\nL17:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     L21\n  cmpl   $0x0,-0x14(%rbp)\n  jne    L22\n  cmpl   $0x0,-0xc(%rbp)\n  je     L22\n  lea    D0(%rip),%rax\n  jmp    L11\nL22:\n  lea    D1(%rip),%rax\nL11:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3568,
            3366
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3361
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4515
        },
        "L1": {
          "label": "L1",
          "addr": 4474
        },
        "L2": {
          "label": "L2",
          "addr": 4498
        },
        "L3": {
          "label": "L3",
          "addr": 4511
        },
        "L4": {
          "label": "L4",
          "addr": 4450
        },
        "L5": {
          "label": "L5",
          "addr": 4597
        },
        "L6": {
          "label": "L6",
          "addr": 4556
        },
        "L7": {
          "label": "L7",
          "addr": 4580
        },
        "L8": {
          "label": "L8",
          "addr": 4593
        },
        "L9": {
          "label": "L9",
          "addr": 4532
        },
        "L10": {
          "label": "L10",
          "addr": 4629
        },
        "L11": {
          "label": "L11",
          "addr": 4835
        },
        "L12": {
          "label": "L12",
          "addr": 4717
        },
        "L13": {
          "label": "L13",
          "addr": 4676
        },
        "L14": {
          "label": "L14",
          "addr": 4700
        },
        "L15": {
          "label": "L15",
          "addr": 4713
        },
        "L16": {
          "label": "L16",
          "addr": 4652
        },
        "L17": {
          "label": "L17",
          "addr": 4799
        },
        "L18": {
          "label": "L18",
          "addr": 4758
        },
        "L19": {
          "label": "L19",
          "addr": 4782
        },
        "L20": {
          "label": "L20",
          "addr": 4795
        },
        "L21": {
          "label": "L21",
          "addr": 4734
        },
        "L22": {
          "label": "L22",
          "addr": 4828
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "596573004e6f00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Yes\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"No\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s1, char *s2) {\n  int i, j, k, m, n, flag1, flag2;\n  i = 0;\n  m = strlen(s1);\n  n = strlen(s2);\n  flag1 = 1;\n  for (j = 0; j < m; j++) {\n    if (s1[j] == '(')\n      i++;\n    if (s1[j] == ')')\n      i--;\n    if (i < 0)\n      flag1 = 0;\n  }\n  for (j = 0; j < n; j++) {\n    if (s2[j] == '(')\n      i++;\n    if (s2[j] == ')')\n      i--;\n    if (i < 0)\n      flag1 = 0;\n  }\n  if (i == 0 && flag1)\n    return \"Yes\";\n  i = 0;\n  flag1 = 1;\n  for (j = 0; j < n; j++) {\n    if (s2[j] == '(')\n      i++;\n    if (s2[j] == ')')\n      i--;\n    if (i < 0)\n      flag1 = 0;\n  }\n  for (j = 0; j < m; j++) {\n    if (s1[j] == '(')\n      i++;\n    if (s1[j] == ')')\n      i--;\n    if (i < 0)\n      flag1 = 0;\n  }\n  if (i == 0 && flag1)\n    return \"Yes\";\n  else\n    return \"No\";\n}"
    },
    {
      "task_id": 123,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0xa,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x1,(%rax)\n  mov    -0x20(%rbp),%rax\n  movl   $0x1,(%rax)\n  jmp    11d6 <func0+0xbd>\n  mov    -0x14(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    11c7 <func0+0xae>\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jg     1191 <func0+0x78>\n  shll   -0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1050 <realloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x14(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  add    $0x1,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    11d6 <func0+0xbd>\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x14(%rbp)\n  cmpl   $0x1,-0x14(%rbp)\n  jne    1150 <func0+0x37>\n  movl   $0x1,-0xc(%rbp)\n  jmp    1287 <func0+0x16e>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    1245 <func0+0x12c>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  subl   $0x1,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  js     1266 <func0+0x14d>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x4(%rbp)\n  jl     1210 <func0+0xf7>\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     11ec <func0+0xd3>\n  nop\n  nop\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0xa,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x1,(%rax)\n  mov    -0x20(%rbp),%rax\n  movl   $0x1,(%rax)\n  jmp    L0\nL3:\n  mov    -0x14(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jg     L2\n  shll   -0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x20(%rbp)\nL2:\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x14(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  add    $0x1,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    L0\nL1:\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x14(%rbp)\nL0:\n  cmpl   $0x1,-0x14(%rbp)\n  jne    L3\n  movl   $0x1,-0xc(%rbp)\n  jmp    L4\nL8:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    L5\nL7:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  subl   $0x1,-0x8(%rbp)\nL5:\n  cmpl   $0x0,-0x8(%rbp)\n  js     L6\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x4(%rbp)\n  jl     L7\nL6:\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\nL4:\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     L8\n  nop\n  nop\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4566
        },
        "L1": {
          "label": "L1",
          "addr": 4551
        },
        "L2": {
          "label": "L2",
          "addr": 4497
        },
        "L3": {
          "label": "L3",
          "addr": 4432
        },
        "L4": {
          "label": "L4",
          "addr": 4743
        },
        "L5": {
          "label": "L5",
          "addr": 4677
        },
        "L6": {
          "label": "L6",
          "addr": 4710
        },
        "L7": {
          "label": "L7",
          "addr": 4624
        },
        "L8": {
          "label": "L8",
          "addr": 4588
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int x, int *a, int *n) {\n  int i, j, k, m = 10;\n  *n = 1;\n  a[0] = 1;\n  while (x != 1) {\n    if (x % 2 == 1) {\n      if (*n >= m) {\n        m *= 2;\n        a = realloc(a, m * sizeof(int));\n      }\n      a[(*n)++] = x;\n      x = x * 3 + 1;\n    } else {\n      x /= 2;\n    }\n  }\n  for (i = 1; i < *n; i++) {\n    k = a[i];\n    j = i - 1;\n    while (j >= 0 && a[j] > k) {\n      a[j + 1] = a[j];\n      j--;\n    }\n    a[j + 1] = k;\n  }\n}"
    },
    {
      "task_id": 123,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rsi,%r8\n  mov    %rdx,%rbx\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%edi\n  je     1194 <func0+0x7b>\n  mov    %edi,%ebp\n  mov    $0xa,%r12d\n  jmp    115d <func0+0x44>\n  cmp    %r12d,(%rbx)\n  jge    117d <func0+0x64>\n  mov    (%rbx),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,(%rbx)\n  cltq\n  mov    %ebp,(%r8,%rax,4)\n  lea    0x1(%rbp,%rbp,2),%ebp\n  cmp    $0x1,%ebp\n  je     1194 <func0+0x7b>\n  mov    %ebp,%edx\n  shr    $0x1f,%edx\n  lea    0x0(%rbp,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     1142 <func0+0x29>\n  mov    %ebp,%eax\n  shr    $0x1f,%eax\n  add    %ebp,%eax\n  sar    %eax\n  mov    %eax,%ebp\n  jmp    1158 <func0+0x3f>\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  mov    %r8,%rdi\n  call   1050 <realloc@plt>\n  mov    %rax,%r8\n  jmp    1147 <func0+0x2e>\n  cmpl   $0x1,(%rbx)\n  jle    11de <func0+0xc5>\n  mov    %r8,%r9\n  mov    $0x0,%edi\n  jmp    11ba <func0+0xa1>\n  movslq %edx,%rdx\n  mov    %esi,0x4(%r8,%rdx,4)\n  add    $0x1,%rdi\n  add    $0x4,%r9\n  lea    0x1(%rdi),%eax\n  cmp    %eax,(%rbx)\n  jle    11de <func0+0xc5>\n  mov    0x4(%r9),%esi\n  mov    %edi,%edx\n  mov    %r9,%rax\n  test   %edi,%edi\n  js     11a3 <func0+0x8a>\n  mov    (%rax),%ecx\n  cmp    %esi,%ecx\n  jle    11a3 <func0+0x8a>\n  mov    %ecx,0x4(%rax)\n  sub    $0x1,%edx\n  sub    $0x4,%rax\n  cmp    $0xffffffff,%edx\n  jne    11c7 <func0+0xae>\n  jmp    11a3 <func0+0x8a>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rsi,%r8\n  mov    %rdx,%rbx\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%edi\n  je     L0\n  mov    %edi,%ebp\n  mov    $0xa,%r12d\n  jmp    L1\nL3:\n  cmp    %r12d,(%rbx)\n  jge    L2\nL5:\n  mov    (%rbx),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,(%rbx)\n  cltq\n  mov    %ebp,(%r8,%rax,4)\n  lea    0x1(%rbp,%rbp,2),%ebp\nL4:\n  cmp    $0x1,%ebp\n  je     L0\nL1:\n  mov    %ebp,%edx\n  shr    $0x1f,%edx\n  lea    0x0(%rbp,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     L3\n  mov    %ebp,%eax\n  shr    $0x1f,%eax\n  add    %ebp,%eax\n  sar    %eax\n  mov    %eax,%ebp\n  jmp    L4\nL2:\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  mov    %r8,%rdi\n  call   <realloc@plt>\n  mov    %rax,%r8\n  jmp    L5\nL0:\n  cmpl   $0x1,(%rbx)\n  jle    L6\n  mov    %r8,%r9\n  mov    $0x0,%edi\n  jmp    L7\nL8:\n  movslq %edx,%rdx\n  mov    %esi,0x4(%r8,%rdx,4)\n  add    $0x1,%rdi\n  add    $0x4,%r9\n  lea    0x1(%rdi),%eax\n  cmp    %eax,(%rbx)\n  jle    L6\nL7:\n  mov    0x4(%r9),%esi\n  mov    %edi,%edx\n  mov    %r9,%rax\n  test   %edi,%edi\n  js     L8\nL9:\n  mov    (%rax),%ecx\n  cmp    %esi,%ecx\n  jle    L8\n  mov    %ecx,0x4(%rax)\n  sub    $0x1,%edx\n  sub    $0x4,%rax\n  cmp    $0xffffffff,%edx\n  jne    L9\n  jmp    L8\nL6:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4500
        },
        "L1": {
          "label": "L1",
          "addr": 4445
        },
        "L2": {
          "label": "L2",
          "addr": 4477
        },
        "L3": {
          "label": "L3",
          "addr": 4418
        },
        "L4": {
          "label": "L4",
          "addr": 4440
        },
        "L5": {
          "label": "L5",
          "addr": 4423
        },
        "L6": {
          "label": "L6",
          "addr": 4574
        },
        "L7": {
          "label": "L7",
          "addr": 4538
        },
        "L8": {
          "label": "L8",
          "addr": 4515
        },
        "L9": {
          "label": "L9",
          "addr": 4551
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int x, int *a, int *n) {\n  int i, j, t;\n  *n = 1;\n  a[0] = 1;\n  while (x != 1) {\n    if (x % 2 == 1) {\n      if (*n >= 10) {\n        a = (int *)realloc(a, 2 * *n * sizeof(int));\n      }\n      a[(*n)++] = x;\n      x = 3 * x + 1;\n    } else {\n      x = x / 2;\n    }\n  }\n  for (i = 1; i < *n; i++) {\n    t = a[i];\n    for (j = i - 1; j >= 0; j--) {\n      if (a[j] > t) {\n        a[j + 1] = a[j];\n      } else {\n        break;\n      }\n    }\n    a[j + 1] = t;\n  }\n}"
    },
    {
      "task_id": 123,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    %rsi,%rdi\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%ebx\n  je     118d <func0+0x6d>\n  mov    $0xa,%r12d\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax)\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  cmp    $0x1,%ebx\n  je     118d <func0+0x6d>\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  lea    (%rbx,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1150 <func0+0x30>\n  movslq 0x0(%rbp),%rax\n  cmp    %eax,%r12d\n  jle    11f0 <func0+0xd0>\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  mov    %ebx,(%rdi,%rax,4)\n  lea    0x1(%rbx,%rbx,2),%ebx\n  cmp    $0x1,%ebx\n  jne    1160 <func0+0x40>\n  cmpl   $0x1,0x0(%rbp)\n  mov    $0x1,%r8d\n  jle    11d5 <func0+0xb5>\n  nopl   0x0(%rax)\n  mov    (%rdi,%r8,4),%esi\n  lea    -0x1(%r8),%rax\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdi,%rax,4),%edx\n  mov    %eax,%ecx\n  cmp    %esi,%edx\n  jle    11e0 <func0+0xc0>\n  mov    %edx,0x4(%rdi,%rax,4)\n  sub    $0x1,%rax\n  cmp    $0xffffffff,%eax\n  jne    11b0 <func0+0x90>\n  mov    %rdi,%rax\n  mov    %esi,(%rax)\n  add    $0x1,%r8\n  cmp    %r8d,0x0(%rbp)\n  jg     11a0 <func0+0x80>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%ecx\n  movslq %ecx,%rcx\n  lea    (%rdi,%rcx,4),%rax\n  jmp    11c9 <func0+0xa9>\n  nopl   0x0(%rax)\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  call   1050 <realloc@plt>\n  mov    %rax,%rdi\n  movslq 0x0(%rbp),%rax\n  jmp    117b <func0+0x5b>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    %rsi,%rdi\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%ebx\n  je     L0\n  mov    $0xa,%r12d\n  jmp    L1\n  nopl   0x0(%rax)\nL2:\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  cmp    $0x1,%ebx\n  je     L0\nL1:\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  lea    (%rbx,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L2\n  movslq 0x0(%rbp),%rax\n  cmp    %eax,%r12d\n  jle    L3\nL9:\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  mov    %ebx,(%rdi,%rax,4)\n  lea    0x1(%rbx,%rbx,2),%ebx\n  cmp    $0x1,%ebx\n  jne    L1\nL0:\n  cmpl   $0x1,0x0(%rbp)\n  mov    $0x1,%r8d\n  jle    L4\n  nopl   0x0(%rax)\nL7:\n  mov    (%rdi,%r8,4),%esi\n  lea    -0x1(%r8),%rax\n  nopl   0x0(%rax,%rax,1)\nL6:\n  mov    (%rdi,%rax,4),%edx\n  mov    %eax,%ecx\n  cmp    %esi,%edx\n  jle    L5\n  mov    %edx,0x4(%rdi,%rax,4)\n  sub    $0x1,%rax\n  cmp    $0xffffffff,%eax\n  jne    L6\n  mov    %rdi,%rax\nL8:\n  mov    %esi,(%rax)\n  add    $0x1,%r8\n  cmp    %r8d,0x0(%rbp)\n  jg     L7\nL4:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL5:\n  add    $0x1,%ecx\n  movslq %ecx,%rcx\n  lea    (%rdi,%rcx,4),%rax\n  jmp    L8\n  nopl   0x0(%rax)\nL3:\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  call   <realloc@plt>\n  mov    %rax,%rdi\n  movslq 0x0(%rbp),%rax\n  jmp    L9",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4493
        },
        "L1": {
          "label": "L1",
          "addr": 4448
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4592
        },
        "L4": {
          "label": "L4",
          "addr": 4565
        },
        "L5": {
          "label": "L5",
          "addr": 4576
        },
        "L6": {
          "label": "L6",
          "addr": 4528
        },
        "L7": {
          "label": "L7",
          "addr": 4512
        },
        "L8": {
          "label": "L8",
          "addr": 4553
        },
        "L9": {
          "label": "L9",
          "addr": 4475
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int x, int *y, int *size) {\n  int i, j;\n  *size = 1;\n  y[0] = 1;\n  while (x != 1) {\n    if (x % 2 == 1) {\n      if (*size >= 10) {\n        *size *= 2;\n        y = realloc(y, *size * sizeof(int));\n      }\n      y[(*size)++] = x;\n      x = x * 3 + 1;\n    } else\n      x /= 2;\n  }\n  for (i = 1; i < *size; i++) {\n    int tmp = y[i];\n    for (j = i - 1; j >= 0; j--) {\n      if (y[j] <= tmp)\n        break;\n      y[j + 1] = y[j];\n    }\n    y[j + 1] = tmp;\n  }\n  return y;\n}"
    },
    {
      "task_id": 123,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    %rsi,%rdi\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%ebx\n  je     118d <func0+0x6d>\n  mov    $0xa,%r12d\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax)\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  cmp    $0x1,%ebx\n  je     118d <func0+0x6d>\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  lea    (%rbx,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1150 <func0+0x30>\n  movslq 0x0(%rbp),%rax\n  cmp    %eax,%r12d\n  jle    11f0 <func0+0xd0>\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  mov    %ebx,(%rdi,%rax,4)\n  lea    0x1(%rbx,%rbx,2),%ebx\n  cmp    $0x1,%ebx\n  jne    1160 <func0+0x40>\n  cmpl   $0x1,0x0(%rbp)\n  mov    $0x1,%r8d\n  jle    11d5 <func0+0xb5>\n  nopl   0x0(%rax)\n  mov    (%rdi,%r8,4),%esi\n  lea    -0x1(%r8),%rax\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdi,%rax,4),%edx\n  mov    %eax,%ecx\n  cmp    %esi,%edx\n  jle    11e0 <func0+0xc0>\n  mov    %edx,0x4(%rdi,%rax,4)\n  sub    $0x1,%rax\n  cmp    $0xffffffff,%eax\n  jne    11b0 <func0+0x90>\n  mov    %rdi,%rax\n  mov    %esi,(%rax)\n  add    $0x1,%r8\n  cmp    %r8d,0x0(%rbp)\n  jg     11a0 <func0+0x80>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%ecx\n  movslq %ecx,%rcx\n  lea    (%rdi,%rcx,4),%rax\n  jmp    11c9 <func0+0xa9>\n  nopl   0x0(%rax)\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  call   1050 <realloc@plt>\n  mov    %rax,%rdi\n  movslq 0x0(%rbp),%rax\n  jmp    117b <func0+0x5b>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    %rsi,%rdi\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%ebx\n  je     L0\n  mov    $0xa,%r12d\n  jmp    L1\n  nopl   0x0(%rax)\nL2:\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  cmp    $0x1,%ebx\n  je     L0\nL1:\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  lea    (%rbx,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L2\n  movslq 0x0(%rbp),%rax\n  cmp    %eax,%r12d\n  jle    L3\nL9:\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  mov    %ebx,(%rdi,%rax,4)\n  lea    0x1(%rbx,%rbx,2),%ebx\n  cmp    $0x1,%ebx\n  jne    L1\nL0:\n  cmpl   $0x1,0x0(%rbp)\n  mov    $0x1,%r8d\n  jle    L4\n  nopl   0x0(%rax)\nL7:\n  mov    (%rdi,%r8,4),%esi\n  lea    -0x1(%r8),%rax\n  nopl   0x0(%rax,%rax,1)\nL6:\n  mov    (%rdi,%rax,4),%edx\n  mov    %eax,%ecx\n  cmp    %esi,%edx\n  jle    L5\n  mov    %edx,0x4(%rdi,%rax,4)\n  sub    $0x1,%rax\n  cmp    $0xffffffff,%eax\n  jne    L6\n  mov    %rdi,%rax\nL8:\n  mov    %esi,(%rax)\n  add    $0x1,%r8\n  cmp    %r8d,0x0(%rbp)\n  jg     L7\nL4:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL5:\n  add    $0x1,%ecx\n  movslq %ecx,%rcx\n  lea    (%rdi,%rcx,4),%rax\n  jmp    L8\n  nopl   0x0(%rax)\nL3:\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  call   <realloc@plt>\n  mov    %rax,%rdi\n  movslq 0x0(%rbp),%rax\n  jmp    L9",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4493
        },
        "L1": {
          "label": "L1",
          "addr": 4448
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4592
        },
        "L4": {
          "label": "L4",
          "addr": 4565
        },
        "L5": {
          "label": "L5",
          "addr": 4576
        },
        "L6": {
          "label": "L6",
          "addr": 4528
        },
        "L7": {
          "label": "L7",
          "addr": 4512
        },
        "L8": {
          "label": "L8",
          "addr": 4553
        },
        "L9": {
          "label": "L9",
          "addr": 4475
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int x, int *y, int *size) {\n  int i, j;\n  *size = 1;\n  y[0] = 1;\n  while (x != 1) {\n    if (x % 2 == 1) {\n      if (*size >= 10) {\n        *size *= 2;\n        y = realloc(y, *size * sizeof(int));\n      }\n      y[(*size)++] = x;\n      x = x * 3 + 1;\n    } else\n      x /= 2;\n  }\n  for (i = 1; i < *size; i++) {\n    int tmp = y[i];\n    for (j = i - 1; j >= 0; j--) {\n      if (y[j] <= tmp)\n        break;\n      y[j + 1] = y[j];\n    }\n    y[j + 1] = tmp;\n  }\n  return y;\n}"
    },
    {
      "task_id": 119,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,%rbp\n  call   1050 <strlen@plt>\n  mov    %rax,%r12\n  mov    %eax,%r13d\n  mov    %rbp,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,%r8d\n  test   %r12d,%r12d\n  jle    12b0 <func0+0x197>\n  mov    %rbx,%rsi\n  lea    -0x1(%r12),%edx\n  lea    0x1(%rbx,%rdx,1),%r10\n  mov    $0x1,%ecx\n  mov    $0x0,%edx\n  mov    $0x0,%r9d\n  jmp    1188 <func0+0x6f>\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rsi\n  cmp    %r10,%rsi\n  je     1196 <func0+0x7d>\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    116b <func0+0x52>\n  add    $0x1,%edx\n  jmp    1179 <func0+0x60>\n  test   %eax,%eax\n  jle    11d4 <func0+0xbb>\n  mov    %rbp,%rsi\n  lea    -0x1(%rax),%eax\n  lea    0x1(%rbp,%rax,1),%r9\n  mov    $0x0,%edi\n  jmp    11c1 <func0+0xa8>\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %edi,%ecx\n  add    $0x1,%rsi\n  cmp    %rsi,%r9\n  je     1288 <func0+0x16f>\n  movzbl (%rsi),%eax\n  cmp    $0x28,%al\n  je     11ac <func0+0x93>\n  cmp    $0x29,%al\n  sete   %al\n  movzbl %al,%eax\n  sub    %eax,%edx\n  jmp    11af <func0+0x96>\n  test   %edx,%edx\n  jne    11e7 <func0+0xce>\n  lea    0xe21(%rip),%rax        # 2000 <_fini+0xd34>\n  test   %ecx,%ecx\n  jne    127d <func0+0x164>\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  test   %r12d,%r12d\n  jg     1230 <func0+0x117>\n  lea    0xe03(%rip),%rax        # 2000 <_fini+0xd34>\n  jmp    127d <func0+0x164>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r8d\n  jle    122b <func0+0x112>\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  je     11ff <func0+0xe6>\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    1202 <func0+0xe9>\n  test   %r12d,%r12d\n  jle    1267 <func0+0x14e>\n  mov    $0x0,%ecx\n  mov    $0x0,%edi\n  jmp    124d <func0+0x134>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r13d\n  jle    1267 <func0+0x14e>\n  movzbl (%rbx,%rcx,1),%esi\n  cmp    $0x28,%sil\n  je     123c <func0+0x123>\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    123f <func0+0x126>\n  test   %eax,%eax\n  jne    1276 <func0+0x15d>\n  lea    0xd8e(%rip),%rax        # 2000 <_fini+0xd34>\n  test   %edx,%edx\n  jne    127d <func0+0x164>\n  lea    0xd87(%rip),%rax        # 2004 <_fini+0xd38>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  test   %ecx,%ecx\n  je     1297 <func0+0x17e>\n  lea    0xd6d(%rip),%rax        # 2000 <_fini+0xd34>\n  test   %edx,%edx\n  je     127d <func0+0x164>\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  mov    $0x0,%edi\n  jmp    1210 <func0+0xf7>\n  mov    $0x1,%ecx\n  mov    $0x0,%edx\n  test   %eax,%eax\n  jg     119a <func0+0x81>\n  lea    0xd37(%rip),%rax        # 2000 <_fini+0xd34>\n  jmp    127d <func0+0x164>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,%rbp\n  call   <strlen@plt>\n  mov    %rax,%r12\n  mov    %eax,%r13d\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  mov    %eax,%r8d\n  test   %r12d,%r12d\n  jle    L0\n  mov    %rbx,%rsi\n  lea    -0x1(%r12),%edx\n  lea    0x1(%rbx,%rdx,1),%r10\n  mov    $0x1,%ecx\n  mov    $0x0,%edx\n  mov    $0x0,%r9d\n  jmp    L1\nL3:\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\nL4:\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rsi\n  cmp    %r10,%rsi\n  je     L2\nL1:\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    L3\n  add    $0x1,%edx\n  jmp    L4\nL2:\n  test   %eax,%eax\n  jle    L5\nL23:\n  mov    %rbp,%rsi\n  lea    -0x1(%rax),%eax\n  lea    0x1(%rbp,%rax,1),%r9\n  mov    $0x0,%edi\n  jmp    L6\nL8:\n  add    $0x1,%edx\nL9:\n  test   %edx,%edx\n  cmovs  %edi,%ecx\n  add    $0x1,%rsi\n  cmp    %rsi,%r9\n  je     L7\nL6:\n  movzbl (%rsi),%eax\n  cmp    $0x28,%al\n  je     L8\n  cmp    $0x29,%al\n  sete   %al\n  movzbl %al,%eax\n  sub    %eax,%edx\n  jmp    L9\nL5:\n  test   %edx,%edx\n  jne    L10\n  lea    D0(%rip),%rax\n  test   %ecx,%ecx\n  jne    L11\nL10:\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  test   %r12d,%r12d\n  jg     L12\n  lea    D0(%rip),%rax\n  jmp    L11\nL14:\n  add    $0x1,%eax\nL15:\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r8d\n  jle    L13\nL22:\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  je     L14\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    L15\nL13:\n  test   %r12d,%r12d\n  jle    L16\nL12:\n  mov    $0x0,%ecx\n  mov    $0x0,%edi\n  jmp    L17\nL18:\n  add    $0x1,%eax\nL19:\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r13d\n  jle    L16\nL17:\n  movzbl (%rbx,%rcx,1),%esi\n  cmp    $0x28,%sil\n  je     L18\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    L19\nL16:\n  test   %eax,%eax\n  jne    L20\n  lea    D0(%rip),%rax\n  test   %edx,%edx\n  jne    L11\nL20:\n  lea    D1(%rip),%rax\nL11:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL7:\n  test   %ecx,%ecx\n  je     L21\n  lea    D0(%rip),%rax\n  test   %edx,%edx\n  je     L11\nL21:\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  mov    $0x0,%edi\n  jmp    L22\nL0:\n  mov    $0x1,%ecx\n  mov    $0x0,%edx\n  test   %eax,%eax\n  jg     L23\n  lea    D0(%rip),%rax\n  jmp    L11",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3617,
            3587,
            3470,
            3437,
            3383
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3463
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4784
        },
        "L1": {
          "label": "L1",
          "addr": 4488
        },
        "L2": {
          "label": "L2",
          "addr": 4502
        },
        "L3": {
          "label": "L3",
          "addr": 4459
        },
        "L4": {
          "label": "L4",
          "addr": 4473
        },
        "L5": {
          "label": "L5",
          "addr": 4564
        },
        "L6": {
          "label": "L6",
          "addr": 4545
        },
        "L7": {
          "label": "L7",
          "addr": 4744
        },
        "L8": {
          "label": "L8",
          "addr": 4524
        },
        "L9": {
          "label": "L9",
          "addr": 4527
        },
        "L10": {
          "label": "L10",
          "addr": 4583
        },
        "L11": {
          "label": "L11",
          "addr": 4733
        },
        "L12": {
          "label": "L12",
          "addr": 4656
        },
        "L13": {
          "label": "L13",
          "addr": 4651
        },
        "L14": {
          "label": "L14",
          "addr": 4607
        },
        "L15": {
          "label": "L15",
          "addr": 4610
        },
        "L16": {
          "label": "L16",
          "addr": 4711
        },
        "L17": {
          "label": "L17",
          "addr": 4685
        },
        "L18": {
          "label": "L18",
          "addr": 4668
        },
        "L19": {
          "label": "L19",
          "addr": 4671
        },
        "L20": {
          "label": "L20",
          "addr": 4726
        },
        "L21": {
          "label": "L21",
          "addr": 4759
        },
        "L22": {
          "label": "L22",
          "addr": 4624
        },
        "L23": {
          "label": "L23",
          "addr": 4506
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "596573004e6f00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Yes\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"No\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s1, char *s2) {\n  int i, j, k, len1, len2, flag1, flag2;\n  len1 = strlen(s1);\n  len2 = strlen(s2);\n  flag1 = 1;\n  flag2 = 1;\n  k = 0;\n  for (i = 0; i < len1; i++) {\n    if (s1[i] == '(')\n      k++;\n    else if (s1[i] == ')')\n      k--;\n    if (k < 0)\n      flag1 = 0;\n  }\n  if (flag1) {\n    for (i = 0; i < len2; i++) {\n      if (s2[i] == '(')\n        k++;\n      else if (s2[i] == ')')\n        k--;\n      if (k < 0)\n        flag2 = 0;\n    }\n  }\n  if (flag1 && flag2)\n    return \"Yes\";\n  flag1 = 1;\n  flag2 = 1;\n  k = 0;\n  for (i = 0; i < len2; i++) {\n    if (s2[i] == '(')\n      k++;\n    else if (s2[i] == ')')\n      k--;\n    if (k < 0)\n      flag2 = 0;\n  }\n  if (flag2) {\n    for (i = 0; i < len1; i++) {\n      if (s1[i] == '(')\n        k++;\n      else if (s1[i] == ')')\n        k--;\n      if (k < 0)\n        flag1 = 0;\n    }\n  }\n  if (flag1 && flag2)\n    return \"Yes\";\n  return \"No\";\n}"
    },
    {
      "task_id": 119,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  call   1050 <strlen@plt>\n  test   %r13d,%r13d\n  jle    12e0 <func0+0x1c0>\n  lea    -0x1(%r13),%edx\n  mov    %rbp,%rsi\n  mov    $0x1,%ecx\n  xor    %r8d,%r8d\n  lea    0x1(%rbp,%rdx,1),%r9\n  xor    %edx,%edx\n  jmp    118d <func0+0x6d>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     11a8 <func0+0x88>\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    1170 <func0+0x50>\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  jne    118d <func0+0x6d>\n  test   %eax,%eax\n  jle    12f8 <func0+0x1d8>\n  sub    $0x1,%eax\n  mov    %rbx,%rsi\n  xor    %r9d,%r9d\n  lea    0x1(%rbx,%rax,1),%r8\n  mov    %rbx,%rax\n  jmp    11e5 <func0+0xc5>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  je     1200 <func0+0xe0>\n  movzbl (%rax),%edi\n  cmp    $0x28,%dil\n  jne    11c8 <func0+0xa8>\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  jne    11e5 <func0+0xc5>\n  test   %edx,%edx\n  jne    1220 <func0+0x100>\n  and    $0x1,%ecx\n  lea    0xdf2(%rip),%rax        # 2000 <_fini+0xce8>\n  je     1220 <func0+0x100>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x1,%edx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    1249 <func0+0x129>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %r8,%rsi\n  je     1262 <func0+0x142>\n  movzbl (%rsi),%ecx\n  cmp    $0x28,%cl\n  jne    1230 <func0+0x110>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %r8,%rsi\n  jne    1249 <func0+0x129>\n  test   %r13d,%r13d\n  jle    12a8 <func0+0x188>\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    128c <func0+0x16c>\n  nopl   (%rax)\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jle    12a8 <func0+0x188>\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  jne    1270 <func0+0x150>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jg     128c <func0+0x16c>\n  test   %eax,%eax\n  jne    12c8 <func0+0x1a8>\n  and    $0x1,%edx\n  je     12c8 <func0+0x1a8>\n  add    $0x8,%rsp\n  lea    0xd44(%rip),%rax        # 2000 <_fini+0xce8>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\n  add    $0x8,%rsp\n  lea    0xd31(%rip),%rax        # 2004 <_fini+0xcec>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  test   %eax,%eax\n  jg     11b0 <func0+0x90>\n  jmp    12b1 <func0+0x191>\n  nopl   0x0(%rax)\n  test   %edx,%edx\n  jne    130c <func0+0x1ec>\n  and    $0x1,%ecx\n  lea    0xcfa(%rip),%rax        # 2000 <_fini+0xce8>\n  jne    1210 <func0+0xf0>\n  xor    %eax,%eax\n  mov    $0x1,%edx\n  jmp    1267 <func0+0x147>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  call   <strlen@plt>\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%edx\n  mov    %rbp,%rsi\n  mov    $0x1,%ecx\n  xor    %r8d,%r8d\n  lea    0x1(%rbp,%rdx,1),%r9\n  xor    %edx,%edx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     L2\nL1:\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    L3\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  jne    L1\nL2:\n  test   %eax,%eax\n  jle    L4\nL16:\n  sub    $0x1,%eax\n  mov    %rbx,%rsi\n  xor    %r9d,%r9d\n  lea    0x1(%rbx,%rax,1),%r8\n  mov    %rbx,%rax\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL7:\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  je     L6\nL5:\n  movzbl (%rax),%edi\n  cmp    $0x28,%dil\n  jne    L7\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  jne    L5\nL6:\n  test   %edx,%edx\n  jne    L8\n  and    $0x1,%ecx\n  lea    D0(%rip),%rax\n  je     L8\nL19:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\nL8:\n  mov    $0x1,%edx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL11:\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %r8,%rsi\n  je     L10\nL9:\n  movzbl (%rsi),%ecx\n  cmp    $0x28,%cl\n  jne    L11\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %r8,%rsi\n  jne    L9\nL10:\n  test   %r13d,%r13d\n  jle    L12\nL20:\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    L13\n  nopl   (%rax)\nL14:\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jle    L12\nL13:\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  jne    L14\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jg     L13\nL12:\n  test   %eax,%eax\n  jne    L15\n  and    $0x1,%edx\n  je     L15\nL17:\n  add    $0x8,%rsp\n  lea    D0(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\nL15:\n  add    $0x8,%rsp\n  lea    D1(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  test   %eax,%eax\n  jg     L16\n  jmp    L17\n  nopl   0x0(%rax)\nL4:\n  test   %edx,%edx\n  jne    L18\n  and    $0x1,%ecx\n  lea    D0(%rip),%rax\n  jne    L19\nL18:\n  xor    %eax,%eax\n  mov    $0x1,%edx\n  jmp    L20",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3570,
            3396,
            3322
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3377
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4832
        },
        "L1": {
          "label": "L1",
          "addr": 4493
        },
        "L2": {
          "label": "L2",
          "addr": 4520
        },
        "L3": {
          "label": "L3",
          "addr": 4464
        },
        "L4": {
          "label": "L4",
          "addr": 4856
        },
        "L5": {
          "label": "L5",
          "addr": 4581
        },
        "L6": {
          "label": "L6",
          "addr": 4608
        },
        "L7": {
          "label": "L7",
          "addr": 4552
        },
        "L8": {
          "label": "L8",
          "addr": 4640
        },
        "L9": {
          "label": "L9",
          "addr": 4681
        },
        "L10": {
          "label": "L10",
          "addr": 4706
        },
        "L11": {
          "label": "L11",
          "addr": 4656
        },
        "L12": {
          "label": "L12",
          "addr": 4776
        },
        "L13": {
          "label": "L13",
          "addr": 4748
        },
        "L14": {
          "label": "L14",
          "addr": 4720
        },
        "L15": {
          "label": "L15",
          "addr": 4808
        },
        "L16": {
          "label": "L16",
          "addr": 4528
        },
        "L17": {
          "label": "L17",
          "addr": 4785
        },
        "L18": {
          "label": "L18",
          "addr": 4876
        },
        "L19": {
          "label": "L19",
          "addr": 4624
        },
        "L20": {
          "label": "L20",
          "addr": 4711
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "596573004e6f00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Yes\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"No\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s1, char *s2) {\n  int i, j, k, m, n, flag1 = 1, flag2 = 1;\n  m = strlen(s1);\n  n = strlen(s2);\n  for (i = 0; i < m; i++) {\n    if (s1[i] == '(')\n      k++;\n    if (s1[i] == ')')\n      k--;\n    if (k < 0)\n      flag1 = 0;\n  }\n  if (k != 0)\n    flag1 = 0;\n  for (i = 0; i < n; i++) {\n    if (s2[i] == '(')\n      k++;\n    if (s2[i] == ')')\n      k--;\n    if (k < 0)\n      flag2 = 0;\n  }\n  if (k != 0)\n    flag2 = 0;\n  if (flag1 == 1 && flag2 == 1)\n    return \"Yes\";\n  else {\n    k = 0;\n    for (i = 0; i < n; i++) {\n      if (s2[i] == '(')\n        k++;\n      if (s2[i] == ')')\n        k--;\n      if (k < 0)\n        flag2 = 0;\n    }\n    for (i = 0; i < m; i++) {\n      if (s1[i] == '(')\n        k++;\n      if (s1[i] == ')')\n        k--;\n      if (k < 0)\n        flag1 = 0;\n    }\n    if (k != 0)\n      return \"No\";\n    else {\n      if (flag1 == 1 && flag2 == 1)\n        return \"Yes\";\n      else\n        return \"No\";\n    }\n  }\n}"
    },
    {
      "task_id": 119,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  call   1050 <strlen@plt>\n  test   %r13d,%r13d\n  jle    12e0 <func0+0x1c0>\n  lea    -0x1(%r13),%edx\n  mov    %rbp,%rsi\n  mov    $0x1,%ecx\n  xor    %r8d,%r8d\n  lea    0x1(%rbp,%rdx,1),%r9\n  xor    %edx,%edx\n  jmp    118d <func0+0x6d>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     11a8 <func0+0x88>\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    1170 <func0+0x50>\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  jne    118d <func0+0x6d>\n  test   %eax,%eax\n  jle    12f8 <func0+0x1d8>\n  sub    $0x1,%eax\n  mov    %rbx,%rsi\n  xor    %r9d,%r9d\n  lea    0x1(%rbx,%rax,1),%r8\n  mov    %rbx,%rax\n  jmp    11e5 <func0+0xc5>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  je     1200 <func0+0xe0>\n  movzbl (%rax),%edi\n  cmp    $0x28,%dil\n  jne    11c8 <func0+0xa8>\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  jne    11e5 <func0+0xc5>\n  test   %edx,%edx\n  jne    1220 <func0+0x100>\n  and    $0x1,%ecx\n  lea    0xdf2(%rip),%rax        # 2000 <_fini+0xce8>\n  je     1220 <func0+0x100>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x1,%edx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    1249 <func0+0x129>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %rsi,%r8\n  je     1262 <func0+0x142>\n  movzbl (%rsi),%ecx\n  cmp    $0x28,%cl\n  jne    1230 <func0+0x110>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %rsi,%r8\n  jne    1249 <func0+0x129>\n  test   %r13d,%r13d\n  jle    12a8 <func0+0x188>\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    128c <func0+0x16c>\n  nopl   (%rax)\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jle    12a8 <func0+0x188>\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  jne    1270 <func0+0x150>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jg     128c <func0+0x16c>\n  test   %eax,%eax\n  jne    12c8 <func0+0x1a8>\n  and    $0x1,%edx\n  je     12c8 <func0+0x1a8>\n  add    $0x8,%rsp\n  lea    0xd44(%rip),%rax        # 2000 <_fini+0xce8>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\n  add    $0x8,%rsp\n  lea    0xd31(%rip),%rax        # 2004 <_fini+0xcec>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  test   %eax,%eax\n  jg     11b0 <func0+0x90>\n  jmp    12b1 <func0+0x191>\n  nopl   0x0(%rax)\n  test   %edx,%edx\n  jne    130c <func0+0x1ec>\n  and    $0x1,%ecx\n  lea    0xcfa(%rip),%rax        # 2000 <_fini+0xce8>\n  jne    1210 <func0+0xf0>\n  xor    %eax,%eax\n  mov    $0x1,%edx\n  jmp    1267 <func0+0x147>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  call   <strlen@plt>\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%edx\n  mov    %rbp,%rsi\n  mov    $0x1,%ecx\n  xor    %r8d,%r8d\n  lea    0x1(%rbp,%rdx,1),%r9\n  xor    %edx,%edx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     L2\nL1:\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    L3\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  jne    L1\nL2:\n  test   %eax,%eax\n  jle    L4\nL16:\n  sub    $0x1,%eax\n  mov    %rbx,%rsi\n  xor    %r9d,%r9d\n  lea    0x1(%rbx,%rax,1),%r8\n  mov    %rbx,%rax\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL7:\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  je     L6\nL5:\n  movzbl (%rax),%edi\n  cmp    $0x28,%dil\n  jne    L7\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  jne    L5\nL6:\n  test   %edx,%edx\n  jne    L8\n  and    $0x1,%ecx\n  lea    D0(%rip),%rax\n  je     L8\nL19:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\nL8:\n  mov    $0x1,%edx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL11:\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %rsi,%r8\n  je     L10\nL9:\n  movzbl (%rsi),%ecx\n  cmp    $0x28,%cl\n  jne    L11\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %rsi,%r8\n  jne    L9\nL10:\n  test   %r13d,%r13d\n  jle    L12\nL20:\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    L13\n  nopl   (%rax)\nL14:\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jle    L12\nL13:\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  jne    L14\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jg     L13\nL12:\n  test   %eax,%eax\n  jne    L15\n  and    $0x1,%edx\n  je     L15\nL17:\n  add    $0x8,%rsp\n  lea    D0(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\nL15:\n  add    $0x8,%rsp\n  lea    D1(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  test   %eax,%eax\n  jg     L16\n  jmp    L17\n  nopl   0x0(%rax)\nL4:\n  test   %edx,%edx\n  jne    L18\n  and    $0x1,%ecx\n  lea    D0(%rip),%rax\n  jne    L19\nL18:\n  xor    %eax,%eax\n  mov    $0x1,%edx\n  jmp    L20",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3570,
            3396,
            3322
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3377
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4832
        },
        "L1": {
          "label": "L1",
          "addr": 4493
        },
        "L2": {
          "label": "L2",
          "addr": 4520
        },
        "L3": {
          "label": "L3",
          "addr": 4464
        },
        "L4": {
          "label": "L4",
          "addr": 4856
        },
        "L5": {
          "label": "L5",
          "addr": 4581
        },
        "L6": {
          "label": "L6",
          "addr": 4608
        },
        "L7": {
          "label": "L7",
          "addr": 4552
        },
        "L8": {
          "label": "L8",
          "addr": 4640
        },
        "L9": {
          "label": "L9",
          "addr": 4681
        },
        "L10": {
          "label": "L10",
          "addr": 4706
        },
        "L11": {
          "label": "L11",
          "addr": 4656
        },
        "L12": {
          "label": "L12",
          "addr": 4776
        },
        "L13": {
          "label": "L13",
          "addr": 4748
        },
        "L14": {
          "label": "L14",
          "addr": 4720
        },
        "L15": {
          "label": "L15",
          "addr": 4808
        },
        "L16": {
          "label": "L16",
          "addr": 4528
        },
        "L17": {
          "label": "L17",
          "addr": 4785
        },
        "L18": {
          "label": "L18",
          "addr": 4876
        },
        "L19": {
          "label": "L19",
          "addr": 4624
        },
        "L20": {
          "label": "L20",
          "addr": 4711
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "596573004e6f00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Yes\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"No\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s1, char *s2) {\n  int i, j, k, m, n, flag1 = 1, flag2 = 1;\n  m = strlen(s1);\n  n = strlen(s2);\n  for (i = 0, j = 0; i < m; i++) {\n    if (s1[i] == '(')\n      j++;\n    if (s1[i] == ')')\n      j--;\n    if (j < 0)\n      flag1 = 0;\n  }\n  for (i = 0, j = 0; i < n; i++) {\n    if (s2[i] == '(')\n      j++;\n    if (s2[i] == ')')\n      j--;\n    if (j < 0)\n      flag2 = 0;\n  }\n  if (j == 0 && flag1 == 1)\n    return \"Yes\";\n  else {\n    for (i = 0, j = 0; i < m; i++) {\n      if (s1[i] == '(')\n        j++;\n      if (s1[i] == ')')\n        j--;\n      if (j < 0)\n        flag1 = 0;\n    }\n    for (i = 0, j = 0; i < n; i++) {\n      if (s2[i] == '(')\n        j++;\n      if (s2[i] == ')')\n        j--;\n      if (j < 0)\n        flag2 = 0;\n    }\n    if (j == 0 && flag1 == 1)\n      return \"Yes\";\n    else\n      return \"No\";\n  }\n}"
    },
    {
      "task_id": 126,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    1118 <func0+0x1f>\n  mov    $0x1,%eax\n  jmp    11e0 <func0+0xe7>\n  movl   $0x1,-0x4(%rbp)\n  jmp    11cf <func0+0xd6>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    115e <func0+0x65>\n  mov    $0x0,%eax\n  jmp    11e0 <func0+0xe7>\n  cmpl   $0x1,-0x4(%rbp)\n  jle    11cb <func0+0xd2>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    11cb <func0+0xd2>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x8(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    11cb <func0+0xd2>\n  mov    $0x0,%eax\n  jmp    11e0 <func0+0xe7>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1124 <func0+0x2b>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    L0\n  mov    $0x1,%eax\n  jmp    L1\nL0:\n  movl   $0x1,-0x4(%rbp)\n  jmp    L2\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L3\n  mov    $0x0,%eax\n  jmp    L1\nL3:\n  cmpl   $0x1,-0x4(%rbp)\n  jle    L4\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L4\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x8(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L4\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    $0x1,%eax\nL1:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4376
        },
        "L1": {
          "label": "L1",
          "addr": 4576
        },
        "L2": {
          "label": "L2",
          "addr": 4559
        },
        "L3": {
          "label": "L3",
          "addr": 4446
        },
        "L4": {
          "label": "L4",
          "addr": 4555
        },
        "L5": {
          "label": "L5",
          "addr": 4388
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i;\n  if (len == 0)\n    return 1;\n  for (i = 1; i < len; i++) {\n    if (arr[i] < arr[i - 1])\n      return 0;\n    if (i > 1 && arr[i] == arr[i - 1] && arr[i] == arr[i - 2])\n      return 0;\n  }\n  return 1;\n}"
    },
    {
      "task_id": 126,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1138 <func0+0x3f>\n  mov    %esi,%esi\n  mov    $0x1,%eax\n  jmp    1114 <func0+0x1b>\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     1132 <func0+0x39>\n  mov    (%rdi,%rax,4),%edx\n  mov    -0x4(%rdi,%rax,4),%ecx\n  cmp    %ecx,%edx\n  jl     113e <func0+0x45>\n  jne    110b <func0+0x12>\n  cmp    $0x1,%eax\n  jle    110b <func0+0x12>\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    110b <func0+0x12>\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %esi,%esi\n  mov    $0x1,%eax\n  jmp    L1\nL4:\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     L2\nL1:\n  mov    (%rdi,%rax,4),%edx\n  mov    -0x4(%rdi,%rax,4),%ecx\n  cmp    %ecx,%edx\n  jl     L3\n  jne    L4\n  cmp    $0x1,%eax\n  jle    L4\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    L4\n  mov    $0x0,%eax\n  ret\nL2:\n  mov    $0x1,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret\nL3:\n  mov    $0x0,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4372
        },
        "L2": {
          "label": "L2",
          "addr": 4402
        },
        "L3": {
          "label": "L3",
          "addr": 4414
        },
        "L4": {
          "label": "L4",
          "addr": 4363
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  int i;\n  for (i = 1; i < n; i++) {\n    if (x[i] < x[i - 1])\n      return 0;\n    if (x[i] == x[i - 1] && i > 1 && x[i] == x[i - 2])\n      return 0;\n  }\n  return 1;\n}"
    },
    {
      "task_id": 126,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1140 <func0+0x40>\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  jmp    1121 <func0+0x21>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  je     1140 <func0+0x40>\n  mov    (%rdi,%rax,4),%edx\n  cmp    -0x4(%rdi,%rax,4),%edx\n  jl     1137 <func0+0x37>\n  jne    1118 <func0+0x18>\n  cmp    $0x1,%eax\n  je     1118 <func0+0x18>\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    1118 <func0+0x18>\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  je     L0\nL1:\n  mov    (%rdi,%rax,4),%edx\n  cmp    -0x4(%rdi,%rax,4),%edx\n  jl     L2\n  jne    L3\n  cmp    $0x1,%eax\n  je     L3\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    L3\nL2:\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4385
        },
        "L2": {
          "label": "L2",
          "addr": 4407
        },
        "L3": {
          "label": "L3",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int a) {\n  int i;\n  for (i = 1; i < a; i++)\n    if (x[i] < x[i - 1] || (x[i] == x[i - 1] && i > 1 && x[i] != x[i - 2]))\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 126,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1140 <func0+0x40>\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  jmp    1121 <func0+0x21>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  je     1140 <func0+0x40>\n  mov    (%rdi,%rax,4),%edx\n  cmp    -0x4(%rdi,%rax,4),%edx\n  jl     1137 <func0+0x37>\n  jne    1118 <func0+0x18>\n  cmp    $0x1,%eax\n  je     1118 <func0+0x18>\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    1118 <func0+0x18>\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  je     L0\nL1:\n  mov    (%rdi,%rax,4),%edx\n  cmp    -0x4(%rdi,%rax,4),%edx\n  jl     L2\n  jne    L3\n  cmp    $0x1,%eax\n  je     L3\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    L3\nL2:\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4385
        },
        "L2": {
          "label": "L2",
          "addr": 4407
        },
        "L3": {
          "label": "L3",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int a) {\n  int i;\n  for (i = 1; i < a; i++)\n    if (x[i] < x[i - 1] || (x[i] == x[i - 1] && i > 1 && x[i] != x[i - 2]))\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 124,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  cmp    $0xa,%rax\n  je     1194 <func0+0x3b>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  movl   $0x0,-0x24(%rbp)\n  jmp    11fd <func0+0xa4>\n  cmpl   $0x2,-0x24(%rbp)\n  je     11a9 <func0+0x50>\n  cmpl   $0x5,-0x24(%rbp)\n  jne    11c7 <func0+0x6e>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2d,%al\n  je     11f9 <func0+0xa0>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    11ef <func0+0x96>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jle    11f9 <func0+0xa0>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  addl   $0x1,-0x24(%rbp)\n  cmpl   $0x9,-0x24(%rbp)\n  jle    119d <func0+0x44>\n  mov    -0x38(%rbp),%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x13(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x1,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x12(%rbp)\n  movb   $0x0,-0x11(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x3,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x10(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xf(%rbp)\n  movb   $0x0,-0xe(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x6,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xd(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x7,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xc(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x8,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xb(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x9,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xa(%rbp)\n  movb   $0x0,-0x9(%rbp)\n  lea    -0x13(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <atoi@plt>\n  mov    %eax,-0x20(%rbp)\n  lea    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <atoi@plt>\n  mov    %eax,-0x1c(%rbp)\n  lea    -0xd(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <atoi@plt>\n  mov    %eax,-0x18(%rbp)\n  cmpl   $0x0,-0x20(%rbp)\n  jle    12b4 <func0+0x15b>\n  cmpl   $0xc,-0x20(%rbp)\n  jle    12bb <func0+0x162>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    12c7 <func0+0x16e>\n  cmpl   $0x1f,-0x1c(%rbp)\n  jle    12ce <func0+0x175>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  cmpl   $0x4,-0x20(%rbp)\n  je     12e6 <func0+0x18d>\n  cmpl   $0x6,-0x20(%rbp)\n  je     12e6 <func0+0x18d>\n  cmpl   $0x9,-0x20(%rbp)\n  je     12e6 <func0+0x18d>\n  cmpl   $0xb,-0x20(%rbp)\n  jne    12f3 <func0+0x19a>\n  cmpl   $0x1f,-0x1c(%rbp)\n  jne    12f3 <func0+0x19a>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  cmpl   $0x2,-0x20(%rbp)\n  jne    1306 <func0+0x1ad>\n  cmpl   $0x1d,-0x1c(%rbp)\n  jle    1306 <func0+0x1ad>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  mov    $0x1,%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     131f <func0+0x1c6>\n  call   1080 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    $0xa,%rax\n  je     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0x24(%rbp)\n  jmp    L2\nL7:\n  cmpl   $0x2,-0x24(%rbp)\n  je     L3\n  cmpl   $0x5,-0x24(%rbp)\n  jne    L4\nL3:\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2d,%al\n  je     L5\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    L6\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jle    L5\nL6:\n  mov    $0x0,%eax\n  jmp    L1\nL5:\n  addl   $0x1,-0x24(%rbp)\nL2:\n  cmpl   $0x9,-0x24(%rbp)\n  jle    L7\n  mov    -0x38(%rbp),%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x13(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x1,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x12(%rbp)\n  movb   $0x0,-0x11(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x3,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x10(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xf(%rbp)\n  movb   $0x0,-0xe(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x6,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xd(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x7,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xc(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x8,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xb(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x9,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xa(%rbp)\n  movb   $0x0,-0x9(%rbp)\n  lea    -0x13(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0x20(%rbp)\n  lea    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0x1c(%rbp)\n  lea    -0xd(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0x18(%rbp)\n  cmpl   $0x0,-0x20(%rbp)\n  jle    L8\n  cmpl   $0xc,-0x20(%rbp)\n  jle    L9\nL8:\n  mov    $0x0,%eax\n  jmp    L1\nL9:\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    L10\n  cmpl   $0x1f,-0x1c(%rbp)\n  jle    L11\nL10:\n  mov    $0x0,%eax\n  jmp    L1\nL11:\n  cmpl   $0x4,-0x20(%rbp)\n  je     L12\n  cmpl   $0x6,-0x20(%rbp)\n  je     L12\n  cmpl   $0x9,-0x20(%rbp)\n  je     L12\n  cmpl   $0xb,-0x20(%rbp)\n  jne    L13\nL12:\n  cmpl   $0x1f,-0x1c(%rbp)\n  jne    L13\n  mov    $0x0,%eax\n  jmp    L1\nL13:\n  cmpl   $0x2,-0x20(%rbp)\n  jne    L14\n  cmpl   $0x1d,-0x1c(%rbp)\n  jle    L14\n  mov    $0x0,%eax\n  jmp    L1\nL14:\n  mov    $0x1,%eax\nL1:\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L15\n  call   <__stack_chk_fail@plt>\nL15:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4500
        },
        "L1": {
          "label": "L1",
          "addr": 4875
        },
        "L2": {
          "label": "L2",
          "addr": 4605
        },
        "L3": {
          "label": "L3",
          "addr": 4521
        },
        "L4": {
          "label": "L4",
          "addr": 4551
        },
        "L5": {
          "label": "L5",
          "addr": 4601
        },
        "L6": {
          "label": "L6",
          "addr": 4591
        },
        "L7": {
          "label": "L7",
          "addr": 4509
        },
        "L8": {
          "label": "L8",
          "addr": 4788
        },
        "L9": {
          "label": "L9",
          "addr": 4795
        },
        "L10": {
          "label": "L10",
          "addr": 4807
        },
        "L11": {
          "label": "L11",
          "addr": 4814
        },
        "L12": {
          "label": "L12",
          "addr": 4838
        },
        "L13": {
          "label": "L13",
          "addr": 4851
        },
        "L14": {
          "label": "L14",
          "addr": 4870
        },
        "L15": {
          "label": "L15",
          "addr": 4895
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(const char *str) {\n  if (strlen(str) != 10)\n    return 0;\n  for (int i = 0; i < 10; i++) {\n    if (i != 2 && i != 5) {\n      if (str[i] < '0' || str[i] > '9')\n        return 0;\n    } else {\n      if (str[i] != '-')\n        return 0;\n    }\n  }\n  char month_str[3] = {str[0], str[1], '\\0'};\n  char day_str[3] = {str[3], str[4], '\\0'};\n  char year_str[5] = {str[6], str[7], str[8], str[9], '\\0'};\n  int month = atoi(month_str);\n  int day = atoi(day_str);\n  int year = atoi(year_str);\n  if (month < 1 || month > 12)\n    return 0;\n  if (day < 1 || day > 31)\n    return 0;\n  if ((month == 4 || month == 6 || month == 9 || month == 11) && day == 31)\n    return 0;\n  if (month == 2 && day > 29)\n    return 0;\n  return 1;\n}"
    },
    {
      "task_id": 124,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1070 <strlen@plt>\n  cmp    $0xa,%rax\n  jne    11c0 <func0+0x60>\n  xor    %eax,%eax\n  mov    $0x24,%ecx\n  jmp    11a7 <func0+0x47>\n  nopl   0x0(%rax)\n  cmp    $0x2d,%dl\n  jne    11c0 <func0+0x60>\n  add    $0x1,%rax\n  cmp    $0xa,%rax\n  je     11e0 <func0+0x80>\n  bt     %rax,%rcx\n  movzbl (%rbx,%rax,1),%edx\n  jb     1198 <func0+0x38>\n  sub    $0x30,%edx\n  cmp    $0x9,%dl\n  jbe    119d <func0+0x3d>\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    128a <func0+0x12a>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\n  movzwl (%rbx),%eax\n  lea    0xd(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0xf(%rsp)\n  mov    %ax,0xd(%rsp)\n  movzwl 0x3(%rbx),%eax\n  movb   $0x0,0x12(%rsp)\n  mov    %ax,0x10(%rsp)\n  mov    0x6(%rbx),%eax\n  movb   $0x0,0x17(%rsp)\n  mov    %eax,0x13(%rsp)\n  call   1090 <strtol@plt>\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbx\n  call   1090 <strtol@plt>\n  lea    0x13(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbp\n  call   1090 <strtol@plt>\n  lea    -0x1(%rbx),%eax\n  cmp    $0xb,%eax\n  ja     11c0 <func0+0x60>\n  lea    -0x1(%rbp),%eax\n  cmp    $0x1e,%eax\n  ja     11c0 <func0+0x60>\n  cmp    $0xb,%ebx\n  ja     1271 <func0+0x111>\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    1271 <func0+0x111>\n  cmp    $0x1f,%ebp\n  je     11c0 <func0+0x60>\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\n  jmp    11c2 <func0+0x62>\n  call   1080 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  cmp    $0xa,%rax\n  jne    L0\n  xor    %eax,%eax\n  mov    $0x24,%ecx\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  cmp    $0x2d,%dl\n  jne    L0\nL4:\n  add    $0x1,%rax\n  cmp    $0xa,%rax\n  je     L2\nL1:\n  bt     %rax,%rcx\n  movzbl (%rbx,%rax,1),%edx\n  jb     L3\n  sub    $0x30,%edx\n  cmp    $0x9,%dl\n  jbe    L4\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\nL7:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L5\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\nL2:\n  movzwl (%rbx),%eax\n  lea    0xd(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0xf(%rsp)\n  mov    %ax,0xd(%rsp)\n  movzwl 0x3(%rbx),%eax\n  movb   $0x0,0x12(%rsp)\n  mov    %ax,0x10(%rsp)\n  mov    0x6(%rbx),%eax\n  movb   $0x0,0x17(%rsp)\n  mov    %eax,0x13(%rsp)\n  call   <strtol@plt>\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbx\n  call   <strtol@plt>\n  lea    0x13(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbp\n  call   <strtol@plt>\n  lea    -0x1(%rbx),%eax\n  cmp    $0xb,%eax\n  ja     L0\n  lea    -0x1(%rbp),%eax\n  cmp    $0x1e,%eax\n  ja     L0\n  cmp    $0xb,%ebx\n  ja     L6\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    L6\n  cmp    $0x1f,%ebp\n  je     L0\nL6:\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\n  jmp    L7\nL5:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4544
        },
        "L1": {
          "label": "L1",
          "addr": 4519
        },
        "L2": {
          "label": "L2",
          "addr": 4576
        },
        "L3": {
          "label": "L3",
          "addr": 4504
        },
        "L4": {
          "label": "L4",
          "addr": 4509
        },
        "L5": {
          "label": "L5",
          "addr": 4746
        },
        "L6": {
          "label": "L6",
          "addr": 4721
        },
        "L7": {
          "label": "L7",
          "addr": 4546
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const char *s) {\n  int i;\n  if (strlen(s) != 10)\n    return 0;\n  for (i = 0; i < 10; i++)\n    if (s[i] < '0' || s[i] > '9')\n      if (s[i] != '-')\n        return 0;\n  char year[3] = {s[0], s[1], '\\0'};\n  char month[3] = {s[2], s[3], '\\0'};\n  char day[3] = {s[4], s[5], '\\0'};\n  long int lyear = strtol(year, NULL, 10);\n  long int lmonth = strtol(month, NULL, 10);\n  long int lday = strtol(day, NULL, 10);\n  if (lyear < 1 || lyear > 12)\n    return 0;\n  if (lmonth < 1 || lmonth > 31)\n    return 0;\n  if (lyear == 1 || lyear == 3 || lyear == 5 || lyear == 7 || lyear == 8 || lyear == 10 || lyear == 12)\n    if (lmonth == 31)\n      return 0;\n  if (lyear == 4 || lyear == 6 || lyear == 9 || lyear == 11)\n    if (lmonth == 31)\n      return 0;\n  if (lyear == 2)\n    if (lmonth > 29)\n      return 0;\n  return 1;\n}"
    },
    {
      "task_id": 128,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    1118 <func0+0x1f>\n  mov    $0xffff8000,%eax\n  jmp    11a0 <func0+0xa7>\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1191 <func0+0x98>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  add    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jne    1170 <func0+0x77>\n  movl   $0x0,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jns    118d <func0+0x94>\n  negl   -0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     112f <func0+0x36>\n  mov    -0xc(%rbp),%eax\n  imul   -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    L0\n  mov    $0xffff8000,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L2\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  add    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jne    L3\n  movl   $0x0,-0x8(%rbp)\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jns    L4\n  negl   -0x8(%rbp)\nL4:\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    -0xc(%rbp),%eax\n  imul   -0x8(%rbp),%eax\nL1:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4376
        },
        "L1": {
          "label": "L1",
          "addr": 4512
        },
        "L2": {
          "label": "L2",
          "addr": 4497
        },
        "L3": {
          "label": "L3",
          "addr": 4464
        },
        "L4": {
          "label": "L4",
          "addr": 4493
        },
        "L5": {
          "label": "L5",
          "addr": 4399
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  if (n == 0)\n    return -32768;\n  int sum = 0;\n  int sign = 1;\n  for (int i = 0; i < n; i++) {\n    sum += abs(x[i]);\n    if (x[i] == 0)\n      sign = 0;\n    if (x[i] < 0)\n      sign = -sign;\n  }\n  return sum * sign;\n}"
    },
    {
      "task_id": 127,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %edx,-0x1c(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  mov    -0x1c(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  cmp    %eax,%edx\n  cmovge %edx,%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x20(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  sub    -0xc(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jg     1141 <func0+0x48>\n  lea    0xec1(%rip),%rax        # 2000 <_fini+0xe88>\n  jmp    1176 <func0+0x7d>\n  movl   $0x2,-0x10(%rbp)\n  jmp    1164 <func0+0x6b>\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x10(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1160 <func0+0x67>\n  lea    0xea2(%rip),%rax        # 2000 <_fini+0xe88>\n  jmp    1176 <func0+0x7d>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    114a <func0+0x51>\n  lea    0xe8d(%rip),%rax        # 2003 <_fini+0xe8b>\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %edx,-0x1c(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  mov    -0x1c(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  cmp    %eax,%edx\n  cmovge %edx,%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x20(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  sub    -0xc(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jg     L0\n  lea    D0(%rip),%rax\n  jmp    L1\nL0:\n  movl   $0x2,-0x10(%rbp)\n  jmp    L2\nL4:\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x10(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L3\n  lea    D0(%rip),%rax\n  jmp    L1\nL3:\n  addl   $0x1,-0x10(%rbp)\nL2:\n  mov    -0x10(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    L4\n  lea    D1(%rip),%rax\nL1:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3777,
            3746
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8195,
          "bias": [
            3725
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4417
        },
        "L1": {
          "label": "L1",
          "addr": 4470
        },
        "L2": {
          "label": "L2",
          "addr": 4452
        },
        "L3": {
          "label": "L3",
          "addr": 4448
        },
        "L4": {
          "label": "L4",
          "addr": 4426
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e4f0059455300",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"NO\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"YES\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(int a, int b, int c, int d) {\n  int max = a > c ? a : c;\n  int min = b < d ? b : d;\n  int diff = min - max;\n  if (diff <= 1)\n    return \"NO\";\n  int i;\n  for (i = 2; i * i <= diff; i++) {\n    if (diff % i == 0)\n      return \"NO\";\n  }\n  return \"YES\";\n}"
    },
    {
      "task_id": 128,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     114d <func0+0x54>\n  jle    113f <func0+0x46>\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x1,%edi\n  mov    $0x0,%eax\n  jmp    1125 <func0+0x2c>\n  mov    %edx,%edi\n  add    $0x4,%rcx\n  cmp    %r8,%rcx\n  je     1149 <func0+0x50>\n  mov    (%rcx),%edx\n  mov    %edx,%esi\n  neg    %esi\n  cmovs  %edx,%esi\n  add    %esi,%eax\n  test   %edx,%edx\n  je     111a <func0+0x21>\n  mov    %edi,%esi\n  neg    %esi\n  test   %edx,%edx\n  cmovs  %esi,%edi\n  jmp    111c <func0+0x23>\n  mov    $0x1,%edi\n  mov    $0x0,%eax\n  imul   %edi,%eax\n  ret\n  mov    $0xffff8000,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x1,%edi\n  mov    $0x0,%eax\n  jmp    L2\nL4:\n  mov    %edx,%edi\nL5:\n  add    $0x4,%rcx\n  cmp    %r8,%rcx\n  je     L3\nL2:\n  mov    (%rcx),%edx\n  mov    %edx,%esi\n  neg    %esi\n  cmovs  %edx,%esi\n  add    %esi,%eax\n  test   %edx,%edx\n  je     L4\n  mov    %edi,%esi\n  neg    %esi\n  test   %edx,%edx\n  cmovs  %esi,%edi\n  jmp    L5\nL1:\n  mov    $0x1,%edi\n  mov    $0x0,%eax\nL3:\n  imul   %edi,%eax\n  ret\nL0:\n  mov    $0xffff8000,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4429
        },
        "L1": {
          "label": "L1",
          "addr": 4415
        },
        "L2": {
          "label": "L2",
          "addr": 4389
        },
        "L3": {
          "label": "L3",
          "addr": 4425
        },
        "L4": {
          "label": "L4",
          "addr": 4378
        },
        "L5": {
          "label": "L5",
          "addr": 4380
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int arrLen) {\n  int sum = 0;\n  int sign = 1;\n  if (arrLen == 0)\n    return -32768;\n  for (int i = 0; i < arrLen; i++) {\n    sum += abs(arr[i]);\n    if (arr[i] == 0)\n      sign = 1;\n    else\n      sign *= (arr[i] < 0) ? -1 : 1;\n  }\n  return sum * sign;\n}"
    },
    {
      "task_id": 128,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     1153 <func0+0x53>\n  jle    1150 <func0+0x50>\n  lea    -0x1(%rsi),%eax\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x1,%eax\n  jmp    1132 <func0+0x32>\n  nopl   0x0(%rax,%rax,1)\n  mov    %eax,%ecx\n  neg    %ecx\n  test   %edx,%edx\n  cmovs  %ecx,%eax\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     114c <func0+0x4c>\n  mov    (%rdi),%edx\n  mov    %edx,%ecx\n  neg    %ecx\n  cmovs  %edx,%ecx\n  add    %ecx,%esi\n  test   %edx,%edx\n  jne    1120 <func0+0x20>\n  add    $0x4,%rdi\n  xor    %eax,%eax\n  cmp    %r8,%rdi\n  jne    1132 <func0+0x32>\n  imul   %esi,%eax\n  ret\n  xor    %eax,%eax\n  ret\n  mov    $0xffff8000,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  lea    -0x1(%rsi),%eax\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x1,%eax\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    %eax,%ecx\n  neg    %ecx\n  test   %edx,%edx\n  cmovs  %ecx,%eax\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     L3\nL2:\n  mov    (%rdi),%edx\n  mov    %edx,%ecx\n  neg    %ecx\n  cmovs  %edx,%ecx\n  add    %ecx,%esi\n  test   %edx,%edx\n  jne    L4\n  add    $0x4,%rdi\n  xor    %eax,%eax\n  cmp    %r8,%rdi\n  jne    L2\nL3:\n  imul   %esi,%eax\n  ret\nL1:\n  xor    %eax,%eax\n  ret\nL0:\n  mov    $0xffff8000,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4435
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        },
        "L2": {
          "label": "L2",
          "addr": 4402
        },
        "L3": {
          "label": "L3",
          "addr": 4428
        },
        "L4": {
          "label": "L4",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  int s = 0, p = 1;\n  if (n == 0)\n    return -32768;\n  for (int i = 0; i < n; ++i) {\n    s += (x[i] > 0 ? x[i] : -x[i]);\n    if (x[i] == 0)\n      p = 0;\n    else if (x[i] < 0)\n      p *= -1;\n  }\n  return p * s;\n}"
    },
    {
      "task_id": 128,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     1153 <func0+0x53>\n  jle    1150 <func0+0x50>\n  lea    -0x1(%rsi),%eax\n  mov    $0x1,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  xor    %eax,%eax\n  jmp    1132 <func0+0x32>\n  nopl   0x0(%rax,%rax,1)\n  mov    %esi,%ecx\n  neg    %ecx\n  test   %edx,%edx\n  cmovs  %ecx,%esi\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  je     114c <func0+0x4c>\n  mov    (%rdi),%edx\n  mov    %edx,%ecx\n  neg    %ecx\n  cmovs  %edx,%ecx\n  add    %ecx,%eax\n  test   %edx,%edx\n  jne    1120 <func0+0x20>\n  add    $0x4,%rdi\n  xor    %esi,%esi\n  cmp    %rdi,%r8\n  jne    1132 <func0+0x32>\n  imul   %esi,%eax\n  ret\n  xor    %eax,%eax\n  ret\n  mov    $0xffff8000,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  lea    -0x1(%rsi),%eax\n  mov    $0x1,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  xor    %eax,%eax\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    %esi,%ecx\n  neg    %ecx\n  test   %edx,%edx\n  cmovs  %ecx,%esi\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  je     L3\nL2:\n  mov    (%rdi),%edx\n  mov    %edx,%ecx\n  neg    %ecx\n  cmovs  %edx,%ecx\n  add    %ecx,%eax\n  test   %edx,%edx\n  jne    L4\n  add    $0x4,%rdi\n  xor    %esi,%esi\n  cmp    %rdi,%r8\n  jne    L2\nL3:\n  imul   %esi,%eax\n  ret\nL1:\n  xor    %eax,%eax\n  ret\nL0:\n  mov    $0xffff8000,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4435
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        },
        "L2": {
          "label": "L2",
          "addr": 4402
        },
        "L3": {
          "label": "L3",
          "addr": 4428
        },
        "L4": {
          "label": "L4",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int n) {\n  int s = 0, p = 1;\n  if (n == 0)\n    return -32768;\n  for (int i = 0; i < n; ++i) {\n    s += (x[i] > 0 ? x[i] : -x[i]);\n    if (x[i] == 0)\n      p = 0;\n    else if (x[i] < 0)\n      p *= -1;\n  }\n  return p * s;\n}"
    },
    {
      "task_id": 127,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  lea    0xef0(%rip),%rax        # 2000 <_fini+0xea8>\n  cmp    $0x1,%ecx\n  jle    114e <func0+0x55>\n  lea    0xee7(%rip),%rax        # 2003 <_fini+0xeab>\n  cmp    $0x3,%ecx\n  jle    114e <func0+0x55>\n  lea    0xed8(%rip),%rax        # 2000 <_fini+0xea8>\n  test   $0x1,%cl\n  je     114e <func0+0x55>\n  mov    $0x2,%esi\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jg     114f <func0+0x56>\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  jne    1132 <func0+0x39>\n  lea    0xeb2(%rip),%rax        # 2000 <_fini+0xea8>\n  ret\n  lea    0xead(%rip),%rax        # 2003 <_fini+0xeab>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  lea    D0(%rip),%rax\n  cmp    $0x1,%ecx\n  jle    L0\n  lea    D1(%rip),%rax\n  cmp    $0x3,%ecx\n  jle    L0\n  lea    D0(%rip),%rax\n  test   $0x1,%cl\n  je     L0\n  mov    $0x2,%esi\nL2:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jg     L1\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  jne    L2\n  lea    D0(%rip),%rax\nL0:\n  ret\nL1:\n  lea    D1(%rip),%rax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3824,
            3800,
            3762
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8195,
          "bias": [
            3815,
            3757
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4430
        },
        "L1": {
          "label": "L1",
          "addr": 4431
        },
        "L2": {
          "label": "L2",
          "addr": 4402
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e4f0059455300",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"NO\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"YES\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int a, int b, int c, int d) {\n  int i, j;\n  if (a > c)\n    a = c;\n  if (b < d)\n    b = d;\n  if (b - a < 2)\n    return \"NO\";\n  if (b - a > 3) {\n    if ((b - a) % 2 == 0)\n      return \"NO\";\n    else {\n      for (i = 2; i * i <= b - a; i++)\n        if ((b - a) % i == 0)\n          return \"NO\";\n    }\n  }\n  return \"YES\";\n}"
    },
    {
      "task_id": 124,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,%rbx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1070 <strlen@plt>\n  mov    %rax,%rdx\n  mov    $0x0,%eax\n  cmp    $0xa,%rdx\n  jne    129b <func0+0x142>\n  mov    $0x0,%eax\n  jmp    11a8 <func0+0x4f>\n  cmpb   $0x2d,(%rbx,%rax,1)\n  jne    12b2 <func0+0x159>\n  add    $0x1,%rax\n  cmp    $0xa,%rax\n  je     11c8 <func0+0x6f>\n  cmp    $0x2,%eax\n  je     1194 <func0+0x3b>\n  cmp    $0x5,%eax\n  je     1194 <func0+0x3b>\n  movzbl (%rbx,%rax,1),%ecx\n  lea    -0x30(%rcx),%edx\n  cmp    $0x9,%dl\n  jbe    119e <func0+0x45>\n  mov    $0x0,%eax\n  jmp    129b <func0+0x142>\n  movzbl (%rbx),%eax\n  mov    %al,0xd(%rsp)\n  movzbl 0x1(%rbx),%eax\n  mov    %al,0xe(%rsp)\n  movb   $0x0,0xf(%rsp)\n  movzbl 0x3(%rbx),%eax\n  mov    %al,0x10(%rsp)\n  movzbl 0x4(%rbx),%eax\n  mov    %al,0x11(%rsp)\n  movb   $0x0,0x12(%rsp)\n  movzbl 0x6(%rbx),%eax\n  mov    %al,0x13(%rsp)\n  movzbl 0x7(%rbx),%eax\n  mov    %al,0x14(%rsp)\n  movzbl 0x8(%rbx),%eax\n  mov    %al,0x15(%rsp)\n  movzbl 0x9(%rbx),%eax\n  mov    %al,0x16(%rsp)\n  movb   $0x0,0x17(%rsp)\n  lea    0xd(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1090 <strtol@plt>\n  mov    %rax,%rbx\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1090 <strtol@plt>\n  mov    %rax,%rbp\n  lea    0x13(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1090 <strtol@plt>\n  lea    -0x1(%rbx),%edx\n  mov    $0x0,%eax\n  cmp    $0xb,%edx\n  ja     129b <func0+0x142>\n  lea    -0x1(%rbp),%edx\n  cmp    $0x1e,%edx\n  ja     129b <func0+0x142>\n  cmp    $0xb,%ebx\n  ja     1287 <func0+0x12e>\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    1287 <func0+0x12e>\n  mov    $0x0,%eax\n  cmp    $0x1f,%ebp\n  je     129b <func0+0x142>\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12b9 <func0+0x160>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  mov    $0x0,%eax\n  jmp    129b <func0+0x142>\n  call   1080 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,%rbx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%rdx\n  mov    $0x0,%eax\n  cmp    $0xa,%rdx\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  cmpb   $0x2d,(%rbx,%rax,1)\n  jne    L2\nL5:\n  add    $0x1,%rax\n  cmp    $0xa,%rax\n  je     L3\nL1:\n  cmp    $0x2,%eax\n  je     L4\n  cmp    $0x5,%eax\n  je     L4\n  movzbl (%rbx,%rax,1),%ecx\n  lea    -0x30(%rcx),%edx\n  cmp    $0x9,%dl\n  jbe    L5\n  mov    $0x0,%eax\n  jmp    L0\nL3:\n  movzbl (%rbx),%eax\n  mov    %al,0xd(%rsp)\n  movzbl 0x1(%rbx),%eax\n  mov    %al,0xe(%rsp)\n  movb   $0x0,0xf(%rsp)\n  movzbl 0x3(%rbx),%eax\n  mov    %al,0x10(%rsp)\n  movzbl 0x4(%rbx),%eax\n  mov    %al,0x11(%rsp)\n  movb   $0x0,0x12(%rsp)\n  movzbl 0x6(%rbx),%eax\n  mov    %al,0x13(%rsp)\n  movzbl 0x7(%rbx),%eax\n  mov    %al,0x14(%rsp)\n  movzbl 0x8(%rbx),%eax\n  mov    %al,0x15(%rsp)\n  movzbl 0x9(%rbx),%eax\n  mov    %al,0x16(%rsp)\n  movb   $0x0,0x17(%rsp)\n  lea    0xd(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%rbx\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%rbp\n  lea    0x13(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  lea    -0x1(%rbx),%edx\n  mov    $0x0,%eax\n  cmp    $0xb,%edx\n  ja     L0\n  lea    -0x1(%rbp),%edx\n  cmp    $0x1e,%edx\n  ja     L0\n  cmp    $0xb,%ebx\n  ja     L6\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    L6\n  mov    $0x0,%eax\n  cmp    $0x1f,%ebp\n  je     L0\nL6:\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\nL0:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L7\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL2:\n  mov    $0x0,%eax\n  jmp    L0\nL7:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4763
        },
        "L1": {
          "label": "L1",
          "addr": 4520
        },
        "L2": {
          "label": "L2",
          "addr": 4786
        },
        "L3": {
          "label": "L3",
          "addr": 4552
        },
        "L4": {
          "label": "L4",
          "addr": 4500
        },
        "L5": {
          "label": "L5",
          "addr": 4510
        },
        "L6": {
          "label": "L6",
          "addr": 4743
        },
        "L7": {
          "label": "L7",
          "addr": 4793
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const char *date) {\n  if (strlen(date) != 10)\n    return 0;\n  for (int i = 0; i < 10; i++) {\n    if (i == 2 || i == 5) {\n      if (date[i] != '-')\n        return 0;\n    } else {\n      if (date[i] < '0' || date[i] > '9')\n        return 0;\n    }\n  }\n  char year[5];\n  char month[3];\n  char day[3];\n  year[0] = date[0];\n  year[1] = date[1];\n  year[2] = '\\0';\n  month[0] = date[3];\n  month[1] = date[4];\n  month[2] = '\\0';\n  day[0] = date[6];\n  day[1] = date[7];\n  day[2] = date[8];\n  day[3] = date[9];\n  day[4] = '\\0';\n  int y = (int)strtol(year, NULL, 10);\n  int m = (int)strtol(month, NULL, 10);\n  int d = (int)strtol(day, NULL, 10);\n  if (y < 1 || y > 12)\n    return 0;\n  if (m < 1 || m > 31)\n    return 0;\n  if (y == 1 || y == 3 || y == 5 || y == 7 || y == 8 || y == 10 || y == 12) {\n    if (m == 31)\n      return 0;\n  }\n  if (y == 4 || y == 6 || y == 9 || y == 11) {\n    if (m == 31)\n      return 0;\n  }\n  if (y == 2) {\n    if (m > 29)\n      return 0;\n  }\n  return 1;\n}"
    },
    {
      "task_id": 127,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  lea    0xef3(%rip),%rax        # 2000 <_fini+0xe98>\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  cmp    $0x1,%ecx\n  jle    1167 <func0+0x67>\n  lea    0xee0(%rip),%rax        # 2003 <_fini+0xe9b>\n  cmp    $0x3,%ecx\n  jle    1167 <func0+0x67>\n  lea    0xed1(%rip),%rax        # 2000 <_fini+0xe98>\n  test   $0x1,%cl\n  je     1167 <func0+0x67>\n  mov    $0x2,%esi\n  jmp    1149 <func0+0x49>\n  nopl   0x0(%rax,%rax,1)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     1160 <func0+0x60>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1140 <func0+0x40>\n  lea    0xea7(%rip),%rax        # 2003 <_fini+0xe9b>\n  ret\n  nopl   (%rax)\n  lea    0xe99(%rip),%rax        # 2000 <_fini+0xe98>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  lea    D0(%rip),%rax\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  cmp    $0x1,%ecx\n  jle    L0\n  lea    D1(%rip),%rax\n  cmp    $0x3,%ecx\n  jle    L0\n  lea    D0(%rip),%rax\n  test   $0x1,%cl\n  je     L0\n  mov    $0x2,%esi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L2\nL1:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L3\n  lea    D1(%rip),%rax\n  ret\n  nopl   (%rax)\nL2:\n  lea    D0(%rip),%rax\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3827,
            3793,
            3737
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8195,
          "bias": [
            3808,
            3751
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4455
        },
        "L1": {
          "label": "L1",
          "addr": 4425
        },
        "L2": {
          "label": "L2",
          "addr": 4448
        },
        "L3": {
          "label": "L3",
          "addr": 4416
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e4f0059455300",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"NO\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"YES\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int a, int b, int c, int d) {\n  int i, j;\n  if (a > c)\n    c = a;\n  if (b > d)\n    d = b;\n  if (d - c < 2)\n    return \"NO\";\n  if (d - c > 3) {\n    if ((d - c) % 2 == 0)\n      return \"NO\";\n    else {\n      for (i = 2; i * i <= d - c; i++)\n        if ((d - c) % i == 0)\n          return \"NO\";\n    }\n  }\n  return \"YES\";\n}"
    },
    {
      "task_id": 125,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0xa8,%rsp\n  mov    %rdi,-0xa8(%rbp)\n  mov    %rsi,-0xb0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x18(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x98(%rbp)\n  movl   $0x0,-0x94(%rbp)\n  movl   $0x0,-0x90(%rbp)\n  mov    -0xa8(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,-0x8c(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  movq   $0x0,-0x68(%rbp)\n  movq   $0x0,-0x60(%rbp)\n  movq   $0x0,-0x58(%rbp)\n  movq   $0x0,-0x50(%rbp)\n  movq   $0x0,-0x48(%rbp)\n  movq   $0x0,-0x40(%rbp)\n  movq   $0x0,-0x38(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movq   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movb   $0x0,-0x1c(%rbp)\n  mov    -0xa8(%rbp),%rax\n  mov    $0x20,%esi\n  mov    %rax,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  jne    12e5 <func0+0x10c>\n  mov    -0xa8(%rbp),%rax\n  mov    $0x2c,%esi\n  mov    %rax,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  je     13fd <func0+0x224>\n  mov    -0x8c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rax,-0x88(%rbp)\n  movl   $0x0,-0x9c(%rbp)\n  jmp    13e6 <func0+0x20d>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     1360 <func0+0x187>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  je     1360 <func0+0x187>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    13b3 <func0+0x1da>\n  cmpl   $0x0,-0x98(%rbp)\n  jle    13df <func0+0x206>\n  mov    -0x98(%rbp),%eax\n  cltq\n  movb   $0x0,-0x80(%rbp,%rax,1)\n  mov    -0x90(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x88(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  lea    -0x80(%rbp),%rax\n  mov    %rax,%rdi\n  call   1100 <strdup@plt>\n  mov    %rax,(%rbx)\n  addl   $0x1,-0x90(%rbp)\n  movl   $0x0,-0x98(%rbp)\n  jmp    13df <func0+0x206>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x98(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x98(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x80(%rbp,%rax,1)\n  addl   $0x1,-0x9c(%rbp)\n  mov    -0x9c(%rbp),%eax\n  cmp    -0x8c(%rbp),%eax\n  jle    1312 <func0+0x139>\n  jmp    14e1 <func0+0x308>\n  movl   $0x0,-0x9c(%rbp)\n  jmp    147a <func0+0x2a1>\n  call   1110 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0xa8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     1473 <func0+0x29a>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1473 <func0+0x29a>\n  addl   $0x1,-0x94(%rbp)\n  addl   $0x1,-0x9c(%rbp)\n  mov    -0x9c(%rbp),%eax\n  cmp    -0x8c(%rbp),%eax\n  jl     1409 <func0+0x230>\n  mov    $0x8,%edi\n  call   10e0 <malloc@plt>\n  mov    %rax,-0x88(%rbp)\n  mov    $0xc,%edi\n  call   10e0 <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x88(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%rax\n  mov    -0x94(%rbp),%edx\n  lea    0xb39(%rip),%rcx        # 2000 <_fini+0xaec>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   10f0 <sprintf@plt>\n  movl   $0x1,-0x90(%rbp)\n  mov    -0xb0(%rbp),%rax\n  mov    -0x90(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    -0x18(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     150b <func0+0x332>\n  call   10c0 <__stack_chk_fail@plt>\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0xa8,%rsp\n  mov    %rdi,-0xa8(%rbp)\n  mov    %rsi,-0xb0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x18(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x98(%rbp)\n  movl   $0x0,-0x94(%rbp)\n  movl   $0x0,-0x90(%rbp)\n  mov    -0xa8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x8c(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  movq   $0x0,-0x68(%rbp)\n  movq   $0x0,-0x60(%rbp)\n  movq   $0x0,-0x58(%rbp)\n  movq   $0x0,-0x50(%rbp)\n  movq   $0x0,-0x48(%rbp)\n  movq   $0x0,-0x40(%rbp)\n  movq   $0x0,-0x38(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movq   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movb   $0x0,-0x1c(%rbp)\n  mov    -0xa8(%rbp),%rax\n  mov    $0x20,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L0\n  mov    -0xa8(%rbp),%rax\n  mov    $0x2c,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\nL0:\n  mov    -0x8c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x88(%rbp)\n  movl   $0x0,-0x9c(%rbp)\n  jmp    L2\nL6:\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L3\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  je     L3\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L4\nL3:\n  cmpl   $0x0,-0x98(%rbp)\n  jle    L5\n  mov    -0x98(%rbp),%eax\n  cltq\n  movb   $0x0,-0x80(%rbp,%rax,1)\n  mov    -0x90(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x88(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  lea    -0x80(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,(%rbx)\n  addl   $0x1,-0x90(%rbp)\n  movl   $0x0,-0x98(%rbp)\n  jmp    L5\nL4:\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x98(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x98(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x80(%rbp,%rax,1)\nL5:\n  addl   $0x1,-0x9c(%rbp)\nL2:\n  mov    -0x9c(%rbp),%eax\n  cmp    -0x8c(%rbp),%eax\n  jle    L6\n  jmp    L7\nL1:\n  movl   $0x0,-0x9c(%rbp)\n  jmp    L8\nL10:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0xa8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     L9\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L9\n  addl   $0x1,-0x94(%rbp)\nL9:\n  addl   $0x1,-0x9c(%rbp)\nL8:\n  mov    -0x9c(%rbp),%eax\n  cmp    -0x8c(%rbp),%eax\n  jl     L10\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x88(%rbp)\n  mov    $0xc,%edi\n  call   <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x88(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%rax\n  mov    -0x94(%rbp),%edx\n  lea    D0(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  movl   $0x1,-0x90(%rbp)\nL7:\n  mov    -0xb0(%rbp),%rax\n  mov    -0x90(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    -0x18(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L11\n  call   <__stack_chk_fail@plt>\nL11:\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            2873
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4837
        },
        "L1": {
          "label": "L1",
          "addr": 5117
        },
        "L2": {
          "label": "L2",
          "addr": 5094
        },
        "L3": {
          "label": "L3",
          "addr": 4960
        },
        "L4": {
          "label": "L4",
          "addr": 5043
        },
        "L5": {
          "label": "L5",
          "addr": 5087
        },
        "L6": {
          "label": "L6",
          "addr": 4882
        },
        "L7": {
          "label": "L7",
          "addr": 5345
        },
        "L8": {
          "label": "L8",
          "addr": 5242
        },
        "L9": {
          "label": "L9",
          "addr": 5235
        },
        "L10": {
          "label": "L10",
          "addr": 5129
        },
        "L11": {
          "label": "L11",
          "addr": 5387
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " char **func0(char *str, int *argc) {\n  int i, j = 0, k = 0, arg_count = 0, len = strlen(str);\n  char **argv = NULL, temp[100] = {0};\n  if (strchr(str, ' ') || strchr(str, ',')) {\n    argv = (char **)malloc((len + 1) * sizeof(char *));\n    for (i = 0; i <= len; i++) {\n      if (str[i] == ' ' || str[i] == ',' || str[i] == '\\0') {\n        if (j > 0) {\n          temp[j] = '\\0';\n          argv[arg_count] = strdup(temp);\n          arg_count++;\n          j = 0;\n        }\n      } else {\n        temp[j++] = str[i];\n      }\n    }\n  } else {\n    for (i = 0; i < len; i++) {\n      if (((*(const short *)(__ctype_b_loc()))[(u_char)(str[i])] & (unsigned short int)(0200)) && (str[i] - 'a') % 2 == 1) {\n        k++;\n      }\n    }\n    argv = (char **)malloc(sizeof(char *));\n    argv[0] = (char *)malloc(sizeof(char) * 12);\n    sprintf(argv[0], \"%d\", k);\n    arg_count = 1;\n  }\n  *argc = arg_count;\n  return argv;\n}"
    },
    {
      "task_id": 127,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  lea    0xef3(%rip),%rax        # 2000 <_fini+0xe98>\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  cmp    $0x1,%ecx\n  jle    1167 <func0+0x67>\n  lea    0xee0(%rip),%rax        # 2003 <_fini+0xe9b>\n  cmp    $0x3,%ecx\n  jle    1167 <func0+0x67>\n  lea    0xed1(%rip),%rax        # 2000 <_fini+0xe98>\n  test   $0x1,%cl\n  je     1167 <func0+0x67>\n  mov    $0x2,%esi\n  jmp    1149 <func0+0x49>\n  nopl   0x0(%rax,%rax,1)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     1160 <func0+0x60>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1140 <func0+0x40>\n  lea    0xea7(%rip),%rax        # 2003 <_fini+0xe9b>\n  ret\n  nopl   (%rax)\n  lea    0xe99(%rip),%rax        # 2000 <_fini+0xe98>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  lea    D0(%rip),%rax\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  cmp    $0x1,%ecx\n  jle    L0\n  lea    D1(%rip),%rax\n  cmp    $0x3,%ecx\n  jle    L0\n  lea    D0(%rip),%rax\n  test   $0x1,%cl\n  je     L0\n  mov    $0x2,%esi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L2\nL1:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L3\n  lea    D1(%rip),%rax\n  ret\n  nopl   (%rax)\nL2:\n  lea    D0(%rip),%rax\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3827,
            3793,
            3737
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8195,
          "bias": [
            3808,
            3751
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4455
        },
        "L1": {
          "label": "L1",
          "addr": 4425
        },
        "L2": {
          "label": "L2",
          "addr": 4448
        },
        "L3": {
          "label": "L3",
          "addr": 4416
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e4f0059455300",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"NO\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"YES\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(int a, int b, int c, int d) {\n  int i, j;\n  if (a > c)\n    c = a;\n  if (b > d)\n    d = b;\n  if (d - c < 2)\n    return \"NO\";\n  if (d - c > 3) {\n    if ((d - c) % 2 == 0)\n      return \"NO\";\n    else {\n      for (i = 2; i * i <= d - c; i++)\n        if ((d - c) % i == 0)\n          return \"NO\";\n    }\n  }\n  return \"YES\";\n}"
    },
    {
      "task_id": 124,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1070 <strlen@plt>\n  cmp    $0xa,%rax\n  jne    12b8 <func0+0x158>\n  movzbl (%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  movzbl 0x1(%rbx),%eax\n  movzwl (%rbx),%edx\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  cmpb   $0x2d,0x2(%rbx)\n  jne    12b8 <func0+0x158>\n  movzbl 0x3(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  movzbl 0x4(%rbx),%eax\n  movzwl 0x3(%rbx),%ecx\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  cmpb   $0x2d,0x5(%rbx)\n  jne    12b8 <func0+0x158>\n  movzbl 0x6(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  movzbl 0x7(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  movzbl 0x8(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  movzbl 0x9(%rbx),%eax\n  mov    0x6(%rbx),%esi\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  mov    %dx,0x8(%rsp)\n  lea    0x8(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    %esi,0x10(%rsp)\n  xor    %esi,%esi\n  mov    %cx,0xc(%rsp)\n  movb   $0x0,0xa(%rsp)\n  movb   $0x0,0xe(%rsp)\n  movb   $0x0,0x14(%rsp)\n  call   1090 <strtol@plt>\n  lea    0xc(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbx\n  call   1090 <strtol@plt>\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbp\n  call   1090 <strtol@plt>\n  lea    -0x1(%rbx),%eax\n  cmp    $0xb,%eax\n  ja     12b8 <func0+0x158>\n  lea    -0x1(%rbp),%eax\n  cmp    $0x1e,%eax\n  ja     12b8 <func0+0x158>\n  cmp    $0xb,%ebx\n  ja     129c <func0+0x13c>\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    129c <func0+0x13c>\n  cmp    $0x1f,%ebp\n  je     12b8 <func0+0x158>\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\n  jmp    12ba <func0+0x15a>\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12d1 <func0+0x171>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  call   1080 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  cmp    $0xa,%rax\n  jne    L0\n  movzbl (%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  movzbl 0x1(%rbx),%eax\n  movzwl (%rbx),%edx\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  cmpb   $0x2d,0x2(%rbx)\n  jne    L0\n  movzbl 0x3(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  movzbl 0x4(%rbx),%eax\n  movzwl 0x3(%rbx),%ecx\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  cmpb   $0x2d,0x5(%rbx)\n  jne    L0\n  movzbl 0x6(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  movzbl 0x7(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  movzbl 0x8(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  movzbl 0x9(%rbx),%eax\n  mov    0x6(%rbx),%esi\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  mov    %dx,0x8(%rsp)\n  lea    0x8(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    %esi,0x10(%rsp)\n  xor    %esi,%esi\n  mov    %cx,0xc(%rsp)\n  movb   $0x0,0xa(%rsp)\n  movb   $0x0,0xe(%rsp)\n  movb   $0x0,0x14(%rsp)\n  call   <strtol@plt>\n  lea    0xc(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbx\n  call   <strtol@plt>\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbp\n  call   <strtol@plt>\n  lea    -0x1(%rbx),%eax\n  cmp    $0xb,%eax\n  ja     L0\n  lea    -0x1(%rbp),%eax\n  cmp    $0x1e,%eax\n  ja     L0\n  cmp    $0xb,%ebx\n  ja     L1\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    L1\n  cmp    $0x1f,%ebp\n  je     L0\nL1:\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\nL2:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L3\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL3:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4792
        },
        "L1": {
          "label": "L1",
          "addr": 4764
        },
        "L2": {
          "label": "L2",
          "addr": 4794
        },
        "L3": {
          "label": "L3",
          "addr": 4817
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *str) {\n  if (strlen(str) != 10)\n    return 0;\n  if (str[0] < '0' || str[0] > '9')\n    return 0;\n  if (str[1] < '0' || str[1] > '9')\n    return 0;\n  if (str[2] != '-')\n    return 0;\n  if (str[3] < '0' || str[3] > '9')\n    return 0;\n  if (str[4] < '0' || str[4] > '9')\n    return 0;\n  if (str[5] != '-')\n    return 0;\n  if (str[6] < '0' || str[6] > '9')\n    return 0;\n  if (str[7] < '0' || str[7] > '9')\n    return 0;\n  if (str[8] < '0' || str[8] > '9')\n    return 0;\n  if (str[9] < '0' || str[9] > '9')\n    return 0;\n  char day[3] = {str[0], str[1], '\\0'};\n  char month[3] = {str[3], str[4], '\\0'};\n  char year[3] = {str[6], str[7], str[8]};\n  int d = (int)strtol(day, NULL, 10);\n  int m = (int)strtol(month, NULL, 10);\n  int y = (int)strtol(year, NULL, 10);\n  if (d < 1 || d > 12)\n    return 0;\n  if (m < 1 || m > 31)\n    return 0;\n  if (d == 12 || d == 10 || d == 8 || d == 7) {\n    if (m == 31)\n      return 0;\n  }\n  if (d == 2 && m > 29)\n    return 0;\n  return 1;\n}"
    },
    {
      "task_id": 125,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x78,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strlen@plt>\n  pxor   %xmm0,%xmm0\n  mov    %rbx,%rdi\n  mov    $0x20,%esi\n  movl   $0x0,0x60(%rsp)\n  mov    %rax,%r12\n  movb   $0x0,0x64(%rsp)\n  movaps %xmm0,(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  movaps %xmm0,0x20(%rsp)\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  je     1308 <func0+0x128>\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rax,%r14\n  test   %r12d,%r12d\n  js     13b8 <func0+0x1d8>\n  mov    %r12d,%r12d\n  xor    %edx,%edx\n  mov    %rsp,%r15\n  lea    0x1(%rbx,%r12,1),%r13\n  xor    %r12d,%r12d\n  jmp    12b4 <func0+0xd4>\n  nopl   0x0(%rax,%rax,1)\n  test   %edx,%edx\n  je     12ab <func0+0xcb>\n  movslq %edx,%rdx\n  mov    %r15,%rdi\n  movb   $0x0,(%rsp,%rdx,1)\n  call   10f0 <strdup@plt>\n  xor    %edx,%edx\n  mov    %rax,%r8\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r8,(%r14,%rax,8)\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     12d8 <func0+0xf8>\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     1288 <func0+0xa8>\n  cmp    $0x2c,%al\n  je     1288 <func0+0xa8>\n  movslq %edx,%rcx\n  add    $0x1,%rbx\n  add    $0x1,%edx\n  mov    %al,(%rsp,%rcx,1)\n  cmp    %rbx,%r13\n  jne    12b4 <func0+0xd4>\n  nopl   0x0(%rax)\n  mov    %r12d,0x0(%rbp)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    13c5 <func0+0x1e5>\n  add    $0x78,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x2c,%esi\n  mov    %rbx,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  jne    1254 <func0+0x74>\n  test   %r12d,%r12d\n  jle    13c0 <func0+0x1e0>\n  call   1100 <__ctype_b_loc@plt>\n  mov    (%rax),%rsi\n  lea    -0x1(%r12),%eax\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%rcx\n  nopl   0x0(%rax)\n  movsbq (%rbx),%rdx\n  mov    %rdx,%rax\n  testb  $0x2,0x1(%rsi,%rdx,2)\n  je     1369 <func0+0x189>\n  sub    $0x61,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\n  add    $0x1,%rbx\n  cmp    %rbx,%rcx\n  jne    1340 <func0+0x160>\n  mov    $0x8,%edi\n  call   10e0 <malloc@plt>\n  mov    $0xc,%edi\n  mov    %rax,%r14\n  call   10e0 <malloc@plt>\n  mov    %r12d,%r8d\n  mov    $0xc,%edx\n  lea    0xc68(%rip),%rcx        # 2000 <_fini+0xc34>\n  mov    %rax,(%r14)\n  mov    %rax,%rdi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  mov    $0x1,%r12d\n  call   1110 <__sprintf_chk@plt>\n  jmp    12d8 <func0+0xf8>\n  nopl   (%rax)\n  xor    %r12d,%r12d\n  jmp    12d8 <func0+0xf8>\n  xor    %r12d,%r12d\n  jmp    1372 <func0+0x192>\n  call   10c0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x78,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  pxor   %xmm0,%xmm0\n  mov    %rbx,%rdi\n  mov    $0x20,%esi\n  movl   $0x0,0x60(%rsp)\n  mov    %rax,%r12\n  movb   $0x0,0x64(%rsp)\n  movaps %xmm0,(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  movaps %xmm0,0x20(%rsp)\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L0\nL7:\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %r12d,%r12d\n  js     L1\n  mov    %r12d,%r12d\n  xor    %edx,%edx\n  mov    %rsp,%r15\n  lea    0x1(%rbx,%r12,1),%r13\n  xor    %r12d,%r12d\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL5:\n  test   %edx,%edx\n  je     L3\n  movslq %edx,%rdx\n  mov    %r15,%rdi\n  movb   $0x0,(%rsp,%rdx,1)\n  call   <strdup@plt>\n  xor    %edx,%edx\n  mov    %rax,%r8\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r8,(%r14,%rax,8)\nL3:\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     L4\nL2:\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     L5\n  cmp    $0x2c,%al\n  je     L5\n  movslq %edx,%rcx\n  add    $0x1,%rbx\n  add    $0x1,%edx\n  mov    %al,(%rsp,%rcx,1)\n  cmp    %rbx,%r13\n  jne    L2\n  nopl   0x0(%rax)\nL4:\n  mov    %r12d,0x0(%rbp)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x78,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    $0x2c,%esi\n  mov    %rbx,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L7\n  test   %r12d,%r12d\n  jle    L8\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rsi\n  lea    -0x1(%r12),%eax\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%rcx\n  nopl   0x0(%rax)\nL10:\n  movsbq (%rbx),%rdx\n  mov    %rdx,%rax\n  testb  $0x2,0x1(%rsi,%rdx,2)\n  je     L9\n  sub    $0x61,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\nL9:\n  add    $0x1,%rbx\n  cmp    %rbx,%rcx\n  jne    L10\nL11:\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    $0xc,%edi\n  mov    %rax,%r14\n  call   <malloc@plt>\n  mov    %r12d,%r8d\n  mov    $0xc,%edx\n  lea    D0(%rip),%rcx\n  mov    %rax,(%r14)\n  mov    %rax,%rdi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  mov    $0x1,%r12d\n  call   <__sprintf_chk@plt>\n  jmp    L4\n  nopl   (%rax)\nL1:\n  xor    %r12d,%r12d\n  jmp    L4\nL8:\n  xor    %r12d,%r12d\n  jmp    L11\nL6:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3176
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4872
        },
        "L1": {
          "label": "L1",
          "addr": 5048
        },
        "L2": {
          "label": "L2",
          "addr": 4788
        },
        "L3": {
          "label": "L3",
          "addr": 4779
        },
        "L4": {
          "label": "L4",
          "addr": 4824
        },
        "L5": {
          "label": "L5",
          "addr": 4744
        },
        "L6": {
          "label": "L6",
          "addr": 5061
        },
        "L7": {
          "label": "L7",
          "addr": 4692
        },
        "L8": {
          "label": "L8",
          "addr": 5056
        },
        "L9": {
          "label": "L9",
          "addr": 4969
        },
        "L10": {
          "label": "L10",
          "addr": 4928
        },
        "L11": {
          "label": "L11",
          "addr": 4978
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " char **func0(char *str, int *argcp) {\n  int len = strlen(str);\n  char **argv;\n  char arg[100] = {0};\n  int argc = 0;\n  int i, j, k;\n  if (strchr(str, ' ') || strchr(str, ',')) {\n    argv = (char **)malloc(sizeof(char *) * (len + 1));\n    j = 0;\n    for (i = 0; i <= len; i++) {\n      if (str[i] == ' ' || str[i] == ',' || str[i] == '\\0') {\n        if (j != 0) {\n          arg[j] = '\\0';\n          argv[argc] = strdup(arg);\n          argc++;\n        }\n        j = 0;\n      } else {\n        arg[j] = str[i];\n        j++;\n      }\n    }\n  } else {\n    int vowel = 0;\n    for (i = 0; i < len; i++) {\n      if (((*(const unsigned short *)(__ctype_b_loc()))[(unsigned int)(str[i])] & (0x0200)) && (((str[i]) - 'a' + 1) % 2 == 1))\n        vowel++;\n    }\n    argv = (char **)malloc(sizeof(char *));\n    argv[0] = (char *)malloc(sizeof(char) * 12);\n    __sprintf_chk(argv[0], 1, 12, \"%d\", vowel);\n    argc = 1;\n  }\n  *argcp = argc;\n  return argv;\n}"
    },
    {
      "task_id": 130,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movl   $0x1,(%rax)\n  cmpl   $0x0,-0x14(%rbp)\n  jne    1159 <func0+0x40>\n  mov    -0x8(%rbp),%rax\n  jmp    1214 <func0+0xfb>\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x3,(%rax)\n  movl   $0x2,-0xc(%rbp)\n  jmp    1204 <func0+0xeb>\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    11a6 <func0+0x8d>\n  mov    -0xc(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  jmp    1200 <func0+0xe7>\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x8(%rax),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  lea    0x1(%rax),%edx\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  sar    %eax\n  mov    %eax,%esi\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    %esi,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    1173 <func0+0x5a>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movl   $0x1,(%rax)\n  cmpl   $0x0,-0x14(%rbp)\n  jne    L0\n  mov    -0x8(%rbp),%rax\n  jmp    L1\nL0:\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x3,(%rax)\n  movl   $0x2,-0xc(%rbp)\n  jmp    L2\nL5:\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L3\n  mov    -0xc(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  jmp    L4\nL3:\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x8(%rax),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  lea    0x1(%rax),%edx\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  sar    %eax\n  mov    %eax,%esi\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    %esi,%edx\n  mov    %edx,(%rax)\nL4:\n  addl   $0x1,-0xc(%rbp)\nL2:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    L5\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4441
        },
        "L1": {
          "label": "L1",
          "addr": 4628
        },
        "L2": {
          "label": "L2",
          "addr": 4612
        },
        "L3": {
          "label": "L3",
          "addr": 4518
        },
        "L4": {
          "label": "L4",
          "addr": 4608
        },
        "L5": {
          "label": "L5",
          "addr": 4467
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = malloc((n + 1) * sizeof(int));\n  a[0] = 1;\n  if (n == 0)\n    return a;\n  a[1] = 3;\n  for (int i = 2; i <= n; i++) {\n    if (i % 2 == 0)\n      a[i] = i / 2 + 1;\n    else\n      a[i] = a[i - 1] + a[i - 2] + 1 + (i + 1) / 2;\n  }\n  return a;\n}"
    },
    {
      "task_id": 125,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x78,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strlen@plt>\n  pxor   %xmm0,%xmm0\n  mov    %rbx,%rdi\n  mov    $0x20,%esi\n  movl   $0x0,0x60(%rsp)\n  mov    %rax,%r12\n  movb   $0x0,0x64(%rsp)\n  movaps %xmm0,(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  movaps %xmm0,0x20(%rsp)\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  je     1308 <func0+0x128>\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rax,%r14\n  test   %r12d,%r12d\n  js     13b8 <func0+0x1d8>\n  mov    %r12d,%r12d\n  xor    %edx,%edx\n  mov    %rsp,%r15\n  lea    0x1(%rbx,%r12,1),%r13\n  xor    %r12d,%r12d\n  jmp    12b4 <func0+0xd4>\n  nopl   0x0(%rax,%rax,1)\n  test   %edx,%edx\n  je     12ab <func0+0xcb>\n  movslq %edx,%rdx\n  mov    %r15,%rdi\n  movb   $0x0,(%rsp,%rdx,1)\n  call   10f0 <strdup@plt>\n  xor    %edx,%edx\n  mov    %rax,%r8\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r8,(%r14,%rax,8)\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     12d8 <func0+0xf8>\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     1288 <func0+0xa8>\n  cmp    $0x2c,%al\n  je     1288 <func0+0xa8>\n  movslq %edx,%rcx\n  add    $0x1,%rbx\n  add    $0x1,%edx\n  mov    %al,(%rsp,%rcx,1)\n  cmp    %rbx,%r13\n  jne    12b4 <func0+0xd4>\n  nopl   0x0(%rax)\n  mov    %r12d,0x0(%rbp)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    13c5 <func0+0x1e5>\n  add    $0x78,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x2c,%esi\n  mov    %rbx,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  jne    1254 <func0+0x74>\n  test   %r12d,%r12d\n  jle    13c0 <func0+0x1e0>\n  call   1100 <__ctype_b_loc@plt>\n  mov    (%rax),%rsi\n  lea    -0x1(%r12),%eax\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%rcx\n  nopl   0x0(%rax)\n  movsbq (%rbx),%rdx\n  mov    %rdx,%rax\n  testb  $0x2,0x1(%rsi,%rdx,2)\n  je     1369 <func0+0x189>\n  sub    $0x61,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\n  add    $0x1,%rbx\n  cmp    %rbx,%rcx\n  jne    1340 <func0+0x160>\n  mov    $0x8,%edi\n  call   10e0 <malloc@plt>\n  mov    $0xc,%edi\n  mov    %rax,%r14\n  call   10e0 <malloc@plt>\n  mov    %r12d,%r8d\n  mov    $0xc,%edx\n  lea    0xc68(%rip),%rcx        # 2000 <_fini+0xc34>\n  mov    %rax,(%r14)\n  mov    %rax,%rdi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  mov    $0x1,%r12d\n  call   1110 <__sprintf_chk@plt>\n  jmp    12d8 <func0+0xf8>\n  nopl   (%rax)\n  xor    %r12d,%r12d\n  jmp    12d8 <func0+0xf8>\n  xor    %r12d,%r12d\n  jmp    1372 <func0+0x192>\n  call   10c0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x78,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  pxor   %xmm0,%xmm0\n  mov    %rbx,%rdi\n  mov    $0x20,%esi\n  movl   $0x0,0x60(%rsp)\n  mov    %rax,%r12\n  movb   $0x0,0x64(%rsp)\n  movaps %xmm0,(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  movaps %xmm0,0x20(%rsp)\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L0\nL7:\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %r12d,%r12d\n  js     L1\n  mov    %r12d,%r12d\n  xor    %edx,%edx\n  mov    %rsp,%r15\n  lea    0x1(%rbx,%r12,1),%r13\n  xor    %r12d,%r12d\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL5:\n  test   %edx,%edx\n  je     L3\n  movslq %edx,%rdx\n  mov    %r15,%rdi\n  movb   $0x0,(%rsp,%rdx,1)\n  call   <strdup@plt>\n  xor    %edx,%edx\n  mov    %rax,%r8\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r8,(%r14,%rax,8)\nL3:\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     L4\nL2:\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     L5\n  cmp    $0x2c,%al\n  je     L5\n  movslq %edx,%rcx\n  add    $0x1,%rbx\n  add    $0x1,%edx\n  mov    %al,(%rsp,%rcx,1)\n  cmp    %rbx,%r13\n  jne    L2\n  nopl   0x0(%rax)\nL4:\n  mov    %r12d,0x0(%rbp)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x78,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    $0x2c,%esi\n  mov    %rbx,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L7\n  test   %r12d,%r12d\n  jle    L8\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rsi\n  lea    -0x1(%r12),%eax\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%rcx\n  nopl   0x0(%rax)\nL10:\n  movsbq (%rbx),%rdx\n  mov    %rdx,%rax\n  testb  $0x2,0x1(%rsi,%rdx,2)\n  je     L9\n  sub    $0x61,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\nL9:\n  add    $0x1,%rbx\n  cmp    %rbx,%rcx\n  jne    L10\nL11:\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    $0xc,%edi\n  mov    %rax,%r14\n  call   <malloc@plt>\n  mov    %r12d,%r8d\n  mov    $0xc,%edx\n  lea    D0(%rip),%rcx\n  mov    %rax,(%r14)\n  mov    %rax,%rdi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  mov    $0x1,%r12d\n  call   <__sprintf_chk@plt>\n  jmp    L4\n  nopl   (%rax)\nL1:\n  xor    %r12d,%r12d\n  jmp    L4\nL8:\n  xor    %r12d,%r12d\n  jmp    L11\nL6:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3176
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4872
        },
        "L1": {
          "label": "L1",
          "addr": 5048
        },
        "L2": {
          "label": "L2",
          "addr": 4788
        },
        "L3": {
          "label": "L3",
          "addr": 4779
        },
        "L4": {
          "label": "L4",
          "addr": 4824
        },
        "L5": {
          "label": "L5",
          "addr": 4744
        },
        "L6": {
          "label": "L6",
          "addr": 5061
        },
        "L7": {
          "label": "L7",
          "addr": 4692
        },
        "L8": {
          "label": "L8",
          "addr": 5056
        },
        "L9": {
          "label": "L9",
          "addr": 4969
        },
        "L10": {
          "label": "L10",
          "addr": 4928
        },
        "L11": {
          "label": "L11",
          "addr": 4978
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " char **func0(char *str, int *argcp) {\n  int i, j, k, len, count;\n  char **argv, *p, temp[80];\n  len = strlen(str);\n  for (i = 0; i < 80; i++)\n    temp[i] = '\\0';\n  if (strchr(str, ' ') || strchr(str, ',')) {\n    argv = (char **)malloc((len + 1) * sizeof(char *));\n    for (i = j = k = 0; i <= len; i++) {\n      if (str[i] == ' ' || str[i] == ',' || str[i] == '\\0') {\n        if (k != 0) {\n          temp[k] = '\\0';\n          argv[j++] = strdup(temp);\n          k = 0;\n        }\n      } else\n        temp[k++] = str[i];\n    }\n  } else {\n    count = 0;\n    for (i = 0; i < len; i++)\n      if (((*(const unsigned short *)(__ctype_b_loc()))[(int)(str[i])] & 2) && ((str[i] - 'a') % 2 == 1))\n        count++;\n    argv = (char **)malloc(sizeof(char *));\n    argv[0] = (char *)malloc(12);\n    __sprintf_chk(argv[0], 1, 12, \"%d\", count);\n    j = 1;\n  }\n  *argcp = j;\n  return argv;\n}"
    },
    {
      "task_id": 130,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     119b <func0+0x7b>\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    119b <func0+0x7b>\n  mov    %rax,%rcx\n  mov    $0x2,%edx\n  jmp    1172 <func0+0x52>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    %esi,%edi\n  add    $0x4,%rcx\n  sar    %edi\n  add    $0x1,%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  je     119b <func0+0x7b>\n  mov    %edx,%edi\n  mov    %edx,%esi\n  add    $0x1,%edx\n  and    $0x1,%edi\n  test   %edi,%edi\n  je     1160 <func0+0x40>\n  mov    %edx,%r8d\n  mov    (%rcx),%edi\n  add    0x4(%rcx),%edi\n  add    $0x4,%rcx\n  sar    %r8d\n  lea    0x1(%rdi,%r8,1),%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  jne    1172 <func0+0x52>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     L0\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  mov    %rax,%rcx\n  mov    $0x2,%edx\n  jmp    L1\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  mov    %esi,%edi\n  add    $0x4,%rcx\n  sar    %edi\n  add    $0x1,%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  je     L0\nL1:\n  mov    %edx,%edi\n  mov    %edx,%esi\n  add    $0x1,%edx\n  and    $0x1,%edi\n  test   %edi,%edi\n  je     L2\n  mov    %edx,%r8d\n  mov    (%rcx),%edi\n  add    0x4(%rcx),%edi\n  add    $0x4,%rcx\n  sar    %r8d\n  lea    0x1(%rdi,%r8,1),%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4507
        },
        "L1": {
          "label": "L1",
          "addr": 4466
        },
        "L2": {
          "label": "L2",
          "addr": 4448
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = malloc((n + 1) * sizeof(int));\n  int i;\n  a[0] = 1;\n  for (i = 1; i < n; i++) {\n    if (i % 2)\n      a[i] = a[i - 1] + a[i / 2] + i / 2 + 1;\n    else\n      a[i] = a[i / 2] + i / 2 + 1;\n  }\n  return a;\n}"
    },
    {
      "task_id": 131,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
      "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  test   %edi,%edi\n  jle    116e <func0+0x75>\n  mov    $0x0,%edi\n  mov    $0x1,%esi\n  jmp    112b <func0+0x32>\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    1166 <func0+0x6d>\n  mov    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,%r8d\n  shr    $0x1f,%r8d\n  lea    (%rax,%r8,1),%ecx\n  and    $0x1,%ecx\n  sub    %r8d,%ecx\n  cmp    $0x1,%ecx\n  jne    110f <func0+0x16>\n  imul   %eax,%esi\n  mov    %ecx,%edi\n  jmp    110f <func0+0x16>\n  test   %edi,%edi\n  cmove  %edi,%esi\n  mov    %esi,%eax\n  ret\n  mov    $0x0,%esi\n  jmp    116b <func0+0x72>",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  test   %edi,%edi\n  jle    L0\n  mov    $0x0,%edi\n  mov    $0x1,%esi\n  jmp    L1\nL3:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    L2\n  mov    %eax,%edx\nL1:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,%r8d\n  shr    $0x1f,%r8d\n  lea    (%rax,%r8,1),%ecx\n  and    $0x1,%ecx\n  sub    %r8d,%ecx\n  cmp    $0x1,%ecx\n  jne    L3\n  imul   %eax,%esi\n  mov    %ecx,%edi\n  jmp    L3\nL2:\n  test   %edi,%edi\n  cmove  %edi,%esi\nL4:\n  mov    %esi,%eax\n  ret\nL0:\n  mov    $0x0,%esi\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4462
        },
        "L1": {
          "label": "L1",
          "addr": 4395
        },
        "L2": {
          "label": "L2",
          "addr": 4454
        },
        "L3": {
          "label": "L3",
          "addr": 4367
        },
        "L4": {
          "label": "L4",
          "addr": 4459
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int i = 0, j = 1, flag = 0;\n  while (n > 0) {\n    i = n % 10;\n    if (i % 2 == 1) {\n      j = j * i;\n      flag = 1;\n    }\n    n = n / 10;\n  }\n  if (flag == 0)\n    j = 0;\n  return j;\n}"
    },
    {
      "task_id": 130,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  lea    0x1(%rdi),%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     118a <func0+0x71>\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    118a <func0+0x71>\n  lea    0x1(%rbx),%r8d\n  mov    $0x2,%edx\n  jmp    1174 <func0+0x5b>\n  mov    -0x8(%rax,%rdx,4),%esi\n  add    -0x4(%rax,%rdx,4),%esi\n  lea    0x1(%rdx),%edi\n  mov    %edi,%ecx\n  shr    $0x1f,%ecx\n  add    %edi,%ecx\n  sar    %ecx\n  lea    0x1(%rsi,%rcx,1),%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %r8,%rdx\n  je     118a <func0+0x71>\n  test   $0x1,%dl\n  jne    1150 <func0+0x37>\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  add    %edx,%ecx\n  sar    %ecx\n  add    $0x1,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  jmp    116b <func0+0x52>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  lea    0x1(%rdi),%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     L0\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r8d\n  mov    $0x2,%edx\n  jmp    L1\nL2:\n  mov    -0x8(%rax,%rdx,4),%esi\n  add    -0x4(%rax,%rdx,4),%esi\n  lea    0x1(%rdx),%edi\n  mov    %edi,%ecx\n  shr    $0x1f,%ecx\n  add    %edi,%ecx\n  sar    %ecx\n  lea    0x1(%rsi,%rcx,1),%ecx\n  mov    %ecx,(%rax,%rdx,4)\nL3:\n  add    $0x1,%rdx\n  cmp    %r8,%rdx\n  je     L0\nL1:\n  test   $0x1,%dl\n  jne    L2\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  add    %edx,%ecx\n  sar    %ecx\n  add    $0x1,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  jmp    L3\nL0:\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4490
        },
        "L1": {
          "label": "L1",
          "addr": 4468
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4459
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = malloc((n + 1) * sizeof(int));\n  a[0] = 1;\n  if (n == 0)\n    return a;\n  a[1] = 3;\n  for (int i = 2; i <= n; i++) {\n    if (i % 2 == 0)\n      a[i] = i / 2 + 1;\n    else\n      a[i] = a[i - 1] + a[i - 2] + (i + 1) / 2;\n  }\n  return a;\n}"
    },
    {
      "task_id": 131,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
      "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1183 <func0+0x8a>\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1163 <func0+0x6a>\n  movl   $0x1,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     1114 <func0+0x1b>\n  cmpl   $0x0,-0x8(%rbp)\n  je     1194 <func0+0x9b>\n  mov    -0xc(%rbp),%eax\n  jmp    1199 <func0+0xa0>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL2:\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  movl   $0x1,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\nL0:\n  cmpl   $0x0,-0x14(%rbp)\n  jg     L2\n  cmpl   $0x0,-0x8(%rbp)\n  je     L3\n  mov    -0xc(%rbp),%eax\n  jmp    L4\nL3:\n  mov    $0x0,%eax\nL4:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4483
        },
        "L1": {
          "label": "L1",
          "addr": 4451
        },
        "L2": {
          "label": "L2",
          "addr": 4372
        },
        "L3": {
          "label": "L3",
          "addr": 4500
        },
        "L4": {
          "label": "L4",
          "addr": 4505
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int digit;\n  int result = 1;\n  int flag = 0;\n  while (n > 0) {\n    digit = n % 10;\n    if (digit % 2 == 1) {\n      flag = 1;\n      result *= digit;\n    }\n    n /= 10;\n  }\n  if (flag)\n    return result;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 131,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
      "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  test   %edi,%edi\n  jle    115a <func0+0x5a>\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%esi\n  jmp    1122 <func0+0x22>\n  nopl   0x0(%rax,%rax,1)\n  mov    %eax,%edi\n  mov    %edi,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%ecx\n  mov    %edi,%edx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  mov    %edi,%ecx\n  and    $0x1,%ecx\n  je     1146 <func0+0x46>\n  imul   %edx,%r9d\n  mov    %ecx,%r8d\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x9,%edi\n  jg     1120 <func0+0x20>\n  test   %r8d,%r8d\n  cmovne %r9d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  test   %edi,%edi\n  jle    L0\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%esi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    %eax,%edi\nL1:\n  mov    %edi,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%ecx\n  mov    %edi,%edx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  mov    %edi,%ecx\n  and    $0x1,%ecx\n  je     L2\n  imul   %edx,%r9d\n  mov    %ecx,%r8d\nL2:\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x9,%edi\n  jg     L3\n  test   %r8d,%r8d\n  cmovne %r9d,%r8d\nL0:\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4442
        },
        "L1": {
          "label": "L1",
          "addr": 4386
        },
        "L2": {
          "label": "L2",
          "addr": 4422
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int ret = 0;\n  int i = 1;\n  while (n > 0) {\n    if (n % 10 % 2 != 0) {\n      ret = ret * (n % 10);\n      i = 0;\n    }\n    n = n / 10;\n  }\n  if (i == 0)\n    return ret;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 130,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     119b <func0+0x7b>\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    119b <func0+0x7b>\n  mov    %rax,%rcx\n  mov    $0x2,%edx\n  jmp    1172 <func0+0x52>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    %esi,%edi\n  add    $0x4,%rcx\n  sar    %edi\n  add    $0x1,%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  je     119b <func0+0x7b>\n  mov    %edx,%edi\n  mov    %edx,%esi\n  add    $0x1,%edx\n  and    $0x1,%edi\n  test   %edi,%edi\n  je     1160 <func0+0x40>\n  mov    %edx,%r8d\n  mov    (%rcx),%edi\n  add    0x4(%rcx),%edi\n  add    $0x4,%rcx\n  sar    %r8d\n  lea    0x1(%rdi,%r8,1),%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  jne    1172 <func0+0x52>\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     L0\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  mov    %rax,%rcx\n  mov    $0x2,%edx\n  jmp    L1\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  mov    %esi,%edi\n  add    $0x4,%rcx\n  sar    %edi\n  add    $0x1,%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  je     L0\nL1:\n  mov    %edx,%edi\n  mov    %edx,%esi\n  add    $0x1,%edx\n  and    $0x1,%edi\n  test   %edi,%edi\n  je     L2\n  mov    %edx,%r8d\n  mov    (%rcx),%edi\n  add    0x4(%rcx),%edi\n  add    $0x4,%rcx\n  sar    %r8d\n  lea    0x1(%rdi,%r8,1),%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4507
        },
        "L1": {
          "label": "L1",
          "addr": 4466
        },
        "L2": {
          "label": "L2",
          "addr": 4448
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int n) {\n  int *a = malloc((n + 1) * sizeof(int));\n  int i;\n  a[0] = 1;\n  for (i = 1; i < n; i++) {\n    if (i % 2)\n      a[i] = a[i - 1] + a[i / 2] + i / 2 + 1;\n    else\n      a[i] = a[i / 2] + i / 2 + 1;\n  }\n  return a;\n}"
    },
    {
      "task_id": 133,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11ad <func0+0x94>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movq   %xmm1,%rax\n  movq   %rax,%xmm0\n  call   1050 <ceil@plt>\n  cvttsd2si %xmm0,%ebx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  movq   %xmm2,%rax\n  movq   %rax,%xmm0\n  call   1050 <ceil@plt>\n  cvttsd2si %xmm0,%eax\n  imul   %ebx,%eax\n  add    %eax,-0x18(%rbp)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     113d <func0+0x24>\n  mov    -0x18(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL1:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movq   %xmm1,%rax\n  movq   %rax,%xmm0\n  call   <ceil@plt>\n  cvttsd2si %xmm0,%ebx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  movq   %xmm2,%rax\n  movq   %rax,%xmm0\n  call   <ceil@plt>\n  cvttsd2si %xmm0,%eax\n  imul   %ebx,%eax\n  add    %eax,-0x18(%rbp)\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L1\n  mov    -0x18(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4525
        },
        "L1": {
          "label": "L1",
          "addr": 4413
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float *x, int n) {\n  int s = 0;\n  for (int i = 0; i < n; ++i)\n    s += (int)ceil(x[i]) * (int)ceil(x[i]);\n  return s;\n}"
    },
    {
      "task_id": 131,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
      "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  test   %edi,%edi\n  jle    115a <func0+0x5a>\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%esi\n  jmp    1122 <func0+0x22>\n  nopl   0x0(%rax,%rax,1)\n  mov    %eax,%edi\n  mov    %edi,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%ecx\n  mov    %edi,%edx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  mov    %edi,%ecx\n  and    $0x1,%ecx\n  je     1146 <func0+0x46>\n  imul   %edx,%r9d\n  mov    %ecx,%r8d\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x9,%edi\n  jg     1120 <func0+0x20>\n  test   %r8d,%r8d\n  cmovne %r9d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  test   %edi,%edi\n  jle    L0\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%esi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    %eax,%edi\nL1:\n  mov    %edi,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%ecx\n  mov    %edi,%edx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  mov    %edi,%ecx\n  and    $0x1,%ecx\n  je     L2\n  imul   %edx,%r9d\n  mov    %ecx,%r8d\nL2:\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x9,%edi\n  jg     L3\n  test   %r8d,%r8d\n  cmovne %r9d,%r8d\nL0:\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4442
        },
        "L1": {
          "label": "L1",
          "addr": 4386
        },
        "L2": {
          "label": "L2",
          "addr": 4422
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int ret = 0;\n  int i = 1;\n  while (n > 0) {\n    if (n % 10 % 2 != 0) {\n      ret = ret * (n % 10);\n      i = 0;\n    }\n    n = n / 10;\n  }\n  if (i == 0)\n    return ret;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 132,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11a2 <func0+0x89>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5b,%al\n  jne    1159 <func0+0x40>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5d,%al\n  jne    1171 <func0+0x58>\n  subl   $0x1,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jns    117e <func0+0x65>\n  movl   $0x0,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    118c <func0+0x73>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jge    119e <func0+0x85>\n  mov    $0x1,%eax\n  jmp    11be <func0+0xa5>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     1141 <func0+0x28>\n  mov    $0x0,%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL7:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5b,%al\n  jne    L1\n  addl   $0x1,-0x1c(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5d,%al\n  jne    L2\n  subl   $0x1,-0x1c(%rbp)\nL2:\n  cmpl   $0x0,-0x1c(%rbp)\n  jns    L3\n  movl   $0x0,-0x1c(%rbp)\nL3:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    L4\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\nL4:\n  mov    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jge    L5\n  mov    $0x1,%eax\n  jmp    L6\nL5:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L7\n  mov    $0x0,%eax\nL6:\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4514
        },
        "L1": {
          "label": "L1",
          "addr": 4441
        },
        "L2": {
          "label": "L2",
          "addr": 4465
        },
        "L3": {
          "label": "L3",
          "addr": 4478
        },
        "L4": {
          "label": "L4",
          "addr": 4492
        },
        "L5": {
          "label": "L5",
          "addr": 4510
        },
        "L6": {
          "label": "L6",
          "addr": 4542
        },
        "L7": {
          "label": "L7",
          "addr": 4417
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(char *s) {\n  int i = 0, j = 0, k;\n  for (k = 0; k < strlen(s); k++) {\n    if (s[k] == '[')\n      i++;\n    if (s[k] == ']')\n      i--;\n    if (i < 0)\n      i = 0;\n    if (i > j)\n      j = i;\n    if (i < j - 1)\n      return 1;\n  }\n  return 0;\n}"
    },
    {
      "task_id": 132,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdx\n  lea    (%rbx,%rax,1),%rdi\n  mov    $0x0,%ecx\n  mov    $0x0,%eax\n  jmp    1156 <func0+0x3d>\n  add    $0x1,%eax\n  test   %eax,%eax\n  mov    $0x0,%esi\n  cmovs  %esi,%eax\n  cmp    %eax,%ecx\n  cmovl  %eax,%ecx\n  add    $0x1,%rdx\n  lea    -0x1(%rcx),%esi\n  cmp    %esi,%eax\n  jl     117b <func0+0x62>\n  cmp    %rdi,%rdx\n  je     1174 <func0+0x5b>\n  movzbl (%rdx),%esi\n  cmp    $0x5b,%sil\n  je     1139 <func0+0x20>\n  cmp    $0x5d,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    113c <func0+0x23>\n  mov    $0x0,%eax\n  pop    %rbx\n  ret\n  mov    $0x1,%eax\n  jmp    1179 <func0+0x60>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdx\n  lea    (%rbx,%rax,1),%rdi\n  mov    $0x0,%ecx\n  mov    $0x0,%eax\n  jmp    L0\nL3:\n  add    $0x1,%eax\nL4:\n  test   %eax,%eax\n  mov    $0x0,%esi\n  cmovs  %esi,%eax\n  cmp    %eax,%ecx\n  cmovl  %eax,%ecx\n  add    $0x1,%rdx\n  lea    -0x1(%rcx),%esi\n  cmp    %esi,%eax\n  jl     L1\nL0:\n  cmp    %rdi,%rdx\n  je     L2\n  movzbl (%rdx),%esi\n  cmp    $0x5b,%sil\n  je     L3\n  cmp    $0x5d,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    L4\nL2:\n  mov    $0x0,%eax\nL5:\n  pop    %rbx\n  ret\nL1:\n  mov    $0x1,%eax\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4438
        },
        "L1": {
          "label": "L1",
          "addr": 4475
        },
        "L2": {
          "label": "L2",
          "addr": 4468
        },
        "L3": {
          "label": "L3",
          "addr": 4409
        },
        "L4": {
          "label": "L4",
          "addr": 4412
        },
        "L5": {
          "label": "L5",
          "addr": 4473
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(char *s) {\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int len = strlen(s);\n  for (i = 0; i < len; i++) {\n    if (s[i] == '[')\n      j++;\n    else if (s[i] == ']')\n      j--;\n    if (j > k)\n      k = j;\n    if (j < 0)\n      return 0;\n  }\n  if (j != 0)\n    return 0;\n  return 1;\n}"
    },
    {
      "task_id": 129,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %edx,-0x30(%rbp)\n  mov    %rcx,-0x38(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    118b <func0+0x72>\n  movl   $0x0,-0x18(%rbp)\n  jmp    117f <func0+0x66>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x1,%eax\n  jne    117b <func0+0x62>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1145 <func0+0x2c>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     113c <func0+0x23>\n  mov    -0x2c(%rbp),%eax\n  imul   %eax,%eax\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jle    11f4 <func0+0xdb>\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    11f4 <func0+0xdb>\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    1259 <func0+0x140>\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    1259 <func0+0x140>\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jle    12b9 <func0+0x1a0>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  sub    $0x4,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    12b9 <func0+0x1a0>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  sub    $0x4,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    131e <func0+0x205>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    131e <func0+0x205>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    -0x30(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1388 <func0+0x26f>\n  mov    -0x1c(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    136b <func0+0x252>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x1,(%rax)\n  jmp    1384 <func0+0x26b>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     1345 <func0+0x22c>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %edx,-0x30(%rbp)\n  mov    %rcx,-0x38(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL4:\n  movl   $0x0,-0x18(%rbp)\n  jmp    L1\nL3:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x1,%eax\n  jne    L2\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\nL2:\n  addl   $0x1,-0x18(%rbp)\nL1:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L3\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L4\n  mov    -0x2c(%rbp),%eax\n  imul   %eax,%eax\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jle    L5\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L5\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\nL5:\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L6\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L6\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\nL6:\n  cmpl   $0x0,-0x10(%rbp)\n  jle    L7\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  sub    $0x4,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L7\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  sub    $0x4,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\nL7:\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    L8\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L8\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\nL8:\n  mov    -0x38(%rbp),%rax\n  mov    -0x30(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L9\nL12:\n  mov    -0x1c(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L10\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x1,(%rax)\n  jmp    L11\nL10:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\nL11:\n  addl   $0x1,-0x1c(%rbp)\nL9:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L12\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4491
        },
        "L1": {
          "label": "L1",
          "addr": 4479
        },
        "L2": {
          "label": "L2",
          "addr": 4475
        },
        "L3": {
          "label": "L3",
          "addr": 4421
        },
        "L4": {
          "label": "L4",
          "addr": 4412
        },
        "L5": {
          "label": "L5",
          "addr": 4596
        },
        "L6": {
          "label": "L6",
          "addr": 4697
        },
        "L7": {
          "label": "L7",
          "addr": 4793
        },
        "L8": {
          "label": "L8",
          "addr": 4894
        },
        "L9": {
          "label": "L9",
          "addr": 5000
        },
        "L10": {
          "label": "L10",
          "addr": 4971
        },
        "L11": {
          "label": "L11",
          "addr": 4996
        },
        "L12": {
          "label": "L12",
          "addr": 4933
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int **a, int n, int m, int *returnSize) {\n  int i, j, min, min_i, min_j;\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      if (a[i][j] == 1) {\n        min_i = i;\n        min_j = j;\n      }\n    }\n  }\n  min = n * n;\n  if (min_i > 0 && a[min_i - 1][min_j] < min)\n    min = a[min_i - 1][min_j];\n  if (min_i < n - 1 && a[min_i + 1][min_j] < min)\n    min = a[min_i + 1][min_j];\n  if (min_j > 0 && a[min_i][min_j - 1] < min)\n    min = a[min_i][min_j - 1];\n  if (min_j < n - 1 && a[min_i][min_j + 1] < min)\n    min = a[min_i][min_j + 1];\n  *returnSize = m;\n  int *res = (int *)malloc(m * sizeof(int));\n  for (i = 0; i < m; i++) {\n    if (i % 2 == 0)\n      res[i] = 1;\n    else\n      res[i] = min;\n  }\n  return res;\n}"
    },
    {
      "task_id": 129,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r10\n  mov    %esi,%r11d\n  mov    %edx,%ebx\n  mov    %rcx,%r12\n  test   %esi,%esi\n  jle    1160 <func0+0x47>\n  mov    %esi,%ecx\n  mov    $0x0,%edi\n  mov    %edi,%esi\n  mov    (%r10,%rdi,8),%rdx\n  mov    $0x0,%eax\n  cmpl   $0x1,(%rdx,%rax,4)\n  cmove  %eax,%r8d\n  cmove  %esi,%r9d\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    1142 <func0+0x29>\n  add    $0x1,%rdi\n  cmp    %rcx,%rdi\n  jne    1137 <func0+0x1e>\n  mov    %r11d,%ebp\n  imul   %r11d,%ebp\n  test   %r9d,%r9d\n  jle    117f <func0+0x66>\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    -0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  sub    $0x1,%r11d\n  cmp    %r9d,%r11d\n  jle    119b <func0+0x82>\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  test   %r8d,%r8d\n  jle    11b3 <func0+0x9a>\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    (%r10,%rdx,8),%rdx\n  mov    -0x4(%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  cmp    %r8d,%r11d\n  jle    11cc <func0+0xb3>\n  movslq %r9d,%r9\n  movslq %r8d,%r8\n  mov    (%r10,%r9,8),%rax\n  mov    0x4(%rax,%r8,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  mov    %ebx,(%r12)\n  movslq %ebx,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  test   %ebx,%ebx\n  jle    1200 <func0+0xe7>\n  mov    %ebx,%ebx\n  mov    $0x0,%edx\n  mov    $0x1,%esi\n  test   $0x1,%dl\n  mov    %esi,%ecx\n  cmovne %ebp,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rbx,%rdx\n  jne    11ec <func0+0xd3>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r10\n  mov    %esi,%r11d\n  mov    %edx,%ebx\n  mov    %rcx,%r12\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%ecx\n  mov    $0x0,%edi\nL2:\n  mov    %edi,%esi\n  mov    (%r10,%rdi,8),%rdx\n  mov    $0x0,%eax\nL1:\n  cmpl   $0x1,(%rdx,%rax,4)\n  cmove  %eax,%r8d\n  cmove  %esi,%r9d\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    L1\n  add    $0x1,%rdi\n  cmp    %rcx,%rdi\n  jne    L2\nL0:\n  mov    %r11d,%ebp\n  imul   %r11d,%ebp\n  test   %r9d,%r9d\n  jle    L3\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    -0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL3:\n  sub    $0x1,%r11d\n  cmp    %r9d,%r11d\n  jle    L4\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL4:\n  test   %r8d,%r8d\n  jle    L5\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    (%r10,%rdx,8),%rdx\n  mov    -0x4(%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL5:\n  cmp    %r8d,%r11d\n  jle    L6\n  movslq %r9d,%r9\n  movslq %r8d,%r8\n  mov    (%r10,%r9,8),%rax\n  mov    0x4(%rax,%r8,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL6:\n  mov    %ebx,(%r12)\n  movslq %ebx,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  test   %ebx,%ebx\n  jle    L7\n  mov    %ebx,%ebx\n  mov    $0x0,%edx\n  mov    $0x1,%esi\nL8:\n  test   $0x1,%dl\n  mov    %esi,%ecx\n  cmovne %ebp,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rbx,%rdx\n  jne    L8\nL7:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4448
        },
        "L1": {
          "label": "L1",
          "addr": 4418
        },
        "L2": {
          "label": "L2",
          "addr": 4407
        },
        "L3": {
          "label": "L3",
          "addr": 4479
        },
        "L4": {
          "label": "L4",
          "addr": 4507
        },
        "L5": {
          "label": "L5",
          "addr": 4531
        },
        "L6": {
          "label": "L6",
          "addr": 4556
        },
        "L7": {
          "label": "L7",
          "addr": 4608
        },
        "L8": {
          "label": "L8",
          "addr": 4588
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int **a, int n, int m, int *ret_m) {\n  int i, j, min, x, y;\n  for (i = 0; i < n; i++)\n    for (j = 0; j < n; j++)\n      if (a[i][j] == 1) {\n        x = i;\n        y = j;\n      }\n  min = n * n;\n  if (x > 0)\n    if (a[x - 1][y] < min)\n      min = a[x - 1][y];\n  if (x < n - 1)\n    if (a[x + 1][y] < min)\n      min = a[x + 1][y];\n  if (y > 0)\n    if (a[x][y - 1] < min)\n      min = a[x][y - 1];\n  if (y < n - 1)\n    if (a[x][y + 1] < min)\n      min = a[x][y + 1];\n  *ret_m = m;\n  int *b = (int *)malloc(m * sizeof(int));\n  for (i = 0; i < m; i++)\n    if (i % 2 == 0)\n      b[i] = 1;\n    else\n      b[i] = min;\n  return b;\n}"
    },
    {
      "task_id": 134,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x0,-0x4(%rbp)\n  jne    1168 <func0+0x2f>\n  mov    $0x0,%eax\n  jmp    11fc <func0+0xc3>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x6(%rbp)\n  call   1070 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x6(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  jne    11a9 <func0+0x70>\n  mov    $0x0,%eax\n  jmp    11fc <func0+0xc3>\n  cmpl   $0x1,-0x4(%rbp)\n  jne    11b6 <func0+0x7d>\n  mov    $0x1,%eax\n  jmp    11fc <func0+0xc3>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    -0x2(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x5(%rbp)\n  call   1070 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x5(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     11f7 <func0+0xbe>\n  mov    $0x0,%eax\n  jmp    11fc <func0+0xc3>\n  mov    $0x1,%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x0,-0x4(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x6(%rbp)\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x6(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  jne    L2\n  mov    $0x0,%eax\n  jmp    L1\nL2:\n  cmpl   $0x1,-0x4(%rbp)\n  jne    L3\n  mov    $0x1,%eax\n  jmp    L1\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    -0x2(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x5(%rbp)\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x5(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     L4\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  mov    $0x1,%eax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4456
        },
        "L1": {
          "label": "L1",
          "addr": 4604
        },
        "L2": {
          "label": "L2",
          "addr": 4521
        },
        "L3": {
          "label": "L3",
          "addr": 4534
        },
        "L4": {
          "label": "L4",
          "addr": 4599
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(const char *str) {\n  unsigned char c, d;\n  int i;\n  i = strlen(str);\n  if (i == 0)\n    return 0;\n  c = str[i - 1];\n  if (!(__ctype_b_loc()[(int)(c)] & 0x400))\n    return 0;\n  if (i == 1)\n    return 1;\n  d = str[i - 2];\n  if (__ctype_b_loc()[(int)(d)] & 0x400)\n    return 0;\n  return 1;\n}"
    },
    {
      "task_id": 135,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0xffffffff,-0x8(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    1152 <func0+0x59>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    114e <func0+0x55>\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1118 <func0+0x1f>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0xffffffff,-0x8(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L1\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4434
        },
        "L1": {
          "label": "L1",
          "addr": 4430
        },
        "L2": {
          "label": "L2",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, min_idx;\n  min_idx = -1;\n  for (i = 1; i < len; ++i) {\n    if (arr[i] < arr[i - 1]) {\n      min_idx = i;\n    }\n  }\n  return min_idx;\n}"
    },
    {
      "task_id": 134,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r12\n  call   1060 <strlen@plt>\n  mov    %eax,%ebp\n  test   %eax,%eax\n  je     1186 <func0+0x4d>\n  movslq %eax,%r13\n  call   1070 <__ctype_b_loc@plt>\n  mov    (%rax),%rax\n  movzbl -0x1(%r12,%r13,1),%edx\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     1193 <func0+0x5a>\n  cmp    $0x1,%ebp\n  je     1186 <func0+0x4d>\n  movzbl -0x2(%r12,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%ebp\n  shr    $0xa,%bp\n  xor    $0x1,%ebp\n  and    $0x1,%ebp\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  mov    $0x0,%ebp\n  jmp    1186 <func0+0x4d>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r12\n  call   <strlen@plt>\n  mov    %eax,%ebp\n  test   %eax,%eax\n  je     L0\n  movslq %eax,%r13\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rax\n  movzbl -0x1(%r12,%r13,1),%edx\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     L1\n  cmp    $0x1,%ebp\n  je     L0\n  movzbl -0x2(%r12,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%ebp\n  shr    $0xa,%bp\n  xor    $0x1,%ebp\n  and    $0x1,%ebp\nL0:\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL1:\n  mov    $0x0,%ebp\n  jmp    L0",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4486
        },
        "L1": {
          "label": "L1",
          "addr": 4499
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const char *str) {\n  int len = strlen(str);\n  if (len == 0)\n    return 0;\n  const unsigned short *fold_prop = __ctype_b_loc();\n  if (!(fold_prop[(unsigned char)str[len - 1]] & (0x0400)))\n    return 0;\n  if (len == 1)\n    return 1;\n  if (!(fold_prop[(unsigned char)str[len - 2]] & (0x0040)))\n    return 0;\n  return 1;\n}"
    },
    {
      "task_id": 133,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1172 <func0+0x79>\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rsi\n  mov    $0x0,%ecx\n  movss  0xee7(%rip),%xmm4        # 2000 <_fini+0xe84>\n  movss  0xeef(%rip),%xmm3        # 2010 <_fini+0xe94>\n  movss  0xedb(%rip),%xmm5        # 2004 <_fini+0xe88>\n  jmp    113d <func0+0x44>\n  cvttss2si %xmm2,%eax\n  imul   %eax,%eax\n  add    %eax,%ecx\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  je     1177 <func0+0x7e>\n  movss  (%rdx),%xmm1\n  movaps %xmm1,%xmm2\n  movaps %xmm1,%xmm0\n  andps  %xmm3,%xmm0\n  ucomiss %xmm0,%xmm4\n  jbe    112b <func0+0x32>\n  cvttss2si %xmm1,%eax\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  cmpnless %xmm0,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm0\n  movaps %xmm3,%xmm2\n  andnps %xmm1,%xmm2\n  orps   %xmm0,%xmm2\n  jmp    112b <func0+0x32>\n  mov    $0x0,%ecx\n  mov    %ecx,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rsi\n  mov    $0x0,%ecx\n  movss  D0(%rip),%xmm4\n  movss  D1(%rip),%xmm3\n  movss  D2(%rip),%xmm5\n  jmp    L1\nL3:\n  cvttss2si %xmm2,%eax\n  imul   %eax,%eax\n  add    %eax,%ecx\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  je     L2\nL1:\n  movss  (%rdx),%xmm1\n  movaps %xmm1,%xmm2\n  movaps %xmm1,%xmm0\n  andps  %xmm3,%xmm0\n  ucomiss %xmm0,%xmm4\n  jbe    L3\n  cvttss2si %xmm1,%eax\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  cmpnless %xmm0,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm0\n  movaps %xmm3,%xmm2\n  andnps %xmm1,%xmm2\n  orps   %xmm0,%xmm2\n  jmp    L3\nL0:\n  mov    $0x0,%ecx\nL2:\n  mov    %ecx,%eax\n  ret",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3815
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3823
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8196,
          "bias": [
            3803
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4466
        },
        "L1": {
          "label": "L1",
          "addr": 4413
        },
        "L2": {
          "label": "L2",
          "addr": 4471
        },
        "L3": {
          "label": "L3",
          "addr": 4395
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000004b0000803f0000000000000000ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              0,
              75
            ]
          },
          "0x2010": {
            "type": "byte[4]",
            "value": [
              255,
              255,
              255,
              127
            ]
          },
          "0x2004": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              128,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(float *x, int n) {\n  int i;\n  int ret = 0;\n  for (i = 0; i < n; ++i) {\n    ret += (int)x[i] * (int)x[i];\n  }\n  return ret;\n}"
    },
    {
      "task_id": 133,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1180 <func0+0x80>\n  lea    -0x1(%rsi),%eax\n  movss  0xeed(%rip),%xmm4        # 2000 <_fini+0xe78>\n  xor    %r8d,%r8d\n  movss  0xef2(%rip),%xmm3        # 2010 <_fini+0xe88>\n  movss  0xede(%rip),%xmm5        # 2004 <_fini+0xe7c>\n  lea    0x4(%rdi,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rdi),%xmm0\n  movaps %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  ucomiss %xmm1,%xmm4\n  jbe    1166 <func0+0x66>\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  movaps %xmm0,%xmm2\n  cvtsi2ss %eax,%xmm1\n  cmpnless %xmm1,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm1\n  movaps %xmm3,%xmm2\n  andnps %xmm0,%xmm2\n  movaps %xmm1,%xmm0\n  orps   %xmm2,%xmm0\n  cvttss2si %xmm0,%eax\n  add    $0x4,%rdi\n  imul   %eax,%eax\n  add    %eax,%r8d\n  cmp    %rdx,%rdi\n  jne    1130 <func0+0x30>\n  mov    %r8d,%eax\n  ret\n  nopl   (%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movss  D0(%rip),%xmm4\n  xor    %r8d,%r8d\n  movss  D1(%rip),%xmm3\n  movss  D2(%rip),%xmm5\n  lea    0x4(%rdi,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\nL2:\n  movss  (%rdi),%xmm0\n  movaps %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  ucomiss %xmm1,%xmm4\n  jbe    L1\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  movaps %xmm0,%xmm2\n  cvtsi2ss %eax,%xmm1\n  cmpnless %xmm1,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm1\n  movaps %xmm3,%xmm2\n  andnps %xmm0,%xmm2\n  movaps %xmm1,%xmm0\n  orps   %xmm2,%xmm0\nL1:\n  cvttss2si %xmm0,%eax\n  add    $0x4,%rdi\n  imul   %eax,%eax\n  add    %eax,%r8d\n  cmp    %rdx,%rdi\n  jne    L2\n  mov    %r8d,%eax\n  ret\n  nopl   (%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3821
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3826
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8196,
          "bias": [
            3806
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4480
        },
        "L1": {
          "label": "L1",
          "addr": 4454
        },
        "L2": {
          "label": "L2",
          "addr": 4400
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000004b0000803f0000000000000000ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              0,
              75
            ]
          },
          "0x2010": {
            "type": "byte[4]",
            "value": [
              255,
              255,
              255,
              127
            ]
          },
          "0x2004": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              128,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(float *x, int n) {\n  int i;\n  int ret = 0;\n  for (i = 0; i < n; ++i) {\n    int tmp = (int)x[i];\n    ret += tmp * tmp;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 133,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1180 <func0+0x80>\n  lea    -0x1(%rsi),%eax\n  movss  0xeed(%rip),%xmm4        # 2000 <_fini+0xe78>\n  xor    %r8d,%r8d\n  movss  0xef2(%rip),%xmm3        # 2010 <_fini+0xe88>\n  movss  0xede(%rip),%xmm5        # 2004 <_fini+0xe7c>\n  lea    0x4(%rdi,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rdi),%xmm0\n  movaps %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  ucomiss %xmm1,%xmm4\n  jbe    1166 <func0+0x66>\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  movaps %xmm0,%xmm2\n  cvtsi2ss %eax,%xmm1\n  cmpnless %xmm1,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm1\n  movaps %xmm3,%xmm2\n  andnps %xmm0,%xmm2\n  movaps %xmm1,%xmm0\n  orps   %xmm2,%xmm0\n  cvttss2si %xmm0,%eax\n  add    $0x4,%rdi\n  imul   %eax,%eax\n  add    %eax,%r8d\n  cmp    %rdi,%rdx\n  jne    1130 <func0+0x30>\n  mov    %r8d,%eax\n  ret\n  nopl   (%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movss  D0(%rip),%xmm4\n  xor    %r8d,%r8d\n  movss  D1(%rip),%xmm3\n  movss  D2(%rip),%xmm5\n  lea    0x4(%rdi,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\nL2:\n  movss  (%rdi),%xmm0\n  movaps %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  ucomiss %xmm1,%xmm4\n  jbe    L1\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  movaps %xmm0,%xmm2\n  cvtsi2ss %eax,%xmm1\n  cmpnless %xmm1,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm1\n  movaps %xmm3,%xmm2\n  andnps %xmm0,%xmm2\n  movaps %xmm1,%xmm0\n  orps   %xmm2,%xmm0\nL1:\n  cvttss2si %xmm0,%eax\n  add    $0x4,%rdi\n  imul   %eax,%eax\n  add    %eax,%r8d\n  cmp    %rdi,%rdx\n  jne    L2\n  mov    %r8d,%eax\n  ret\n  nopl   (%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3821
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3826
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8196,
          "bias": [
            3806
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4480
        },
        "L1": {
          "label": "L1",
          "addr": 4454
        },
        "L2": {
          "label": "L2",
          "addr": 4400
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000004b0000803f0000000000000000ffffff7f000000000000000000000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              0,
              75
            ]
          },
          "0x2010": {
            "type": "byte[4]",
            "value": [
              255,
              255,
              255,
              127
            ]
          },
          "0x2004": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              128,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(float *x, int n) {\n  int i;\n  int ret = 0;\n  for (i = 0; i < n; ++i) {\n    int tmp = (int)x[i];\n    ret += tmp * tmp;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 135,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1124 <func0+0x2b>\n  mov    %esi,%esi\n  mov    $0x1,%eax\n  mov    $0xffffffff,%edx\n  mov    -0x4(%rdi,%rax,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    110e <func0+0x15>\n  mov    %edx,%eax\n  ret\n  mov    $0xffffffff,%edx\n  jmp    1121 <func0+0x28>",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %esi,%esi\n  mov    $0x1,%eax\n  mov    $0xffffffff,%edx\nL1:\n  mov    -0x4(%rdi,%rax,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    L1\nL2:\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0xffffffff,%edx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4388
        },
        "L1": {
          "label": "L1",
          "addr": 4366
        },
        "L2": {
          "label": "L2",
          "addr": 4385
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, min_idx;\n  min_idx = -1;\n  for (i = 1; i < len; i++) {\n    if (arr[i] < arr[i - 1]) {\n      min_idx = i;\n    }\n  }\n  return min_idx;\n}"
    },
    {
      "task_id": 135,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1140 <func0+0x40>\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  mov    $0xffffffff,%r8d\n  nopw   0x0(%rax,%rax,1)\n  mov    -0x4(%rdi,%rax,4),%edx\n  cmp    %edx,(%rdi,%rax,4)\n  cmovl  %eax,%r8d\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    1120 <func0+0x20>\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0xffffffff,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  mov    $0xffffffff,%r8d\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    -0x4(%rdi,%rax,4),%edx\n  cmp    %edx,(%rdi,%rax,4)\n  cmovl  %eax,%r8d\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    $0xffffffff,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4416
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, min_idx;\n  min_idx = -1;\n  for (i = 1; i < len; i++) {\n    if (arr[i] < arr[i - 1]) {\n      min_idx = i;\n    }\n  }\n  return min_idx;\n}"
    },
    {
      "task_id": 129,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdi,%r10\n  mov    %esi,%r11d\n  mov    %rcx,%r12\n  push   %rbp\n  push   %rbx\n  mov    %edx,%ebx\n  test   %esi,%esi\n  jle    116e <func0+0x4e>\n  movslq %esi,%rdx\n  xor    %edi,%edi\n  nopl   0x0(%rax)\n  mov    (%r10,%rdi,8),%rcx\n  mov    %edi,%esi\n  xor    %eax,%eax\n  nopl   0x0(%rax,%rax,1)\n  cmpl   $0x1,(%rcx,%rax,4)\n  cmove  %eax,%r8d\n  cmove  %esi,%r9d\n  add    $0x1,%rax\n  cmp    %rdx,%rax\n  jne    1150 <func0+0x30>\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  jne    1140 <func0+0x20>\n  mov    %r11d,%ebp\n  imul   %r11d,%ebp\n  test   %r9d,%r9d\n  je     118d <func0+0x6d>\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    -0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  sub    $0x1,%r11d\n  cmp    %r9d,%r11d\n  jle    11ac <func0+0x8c>\n  lea    0x1(%r9),%edx\n  movslq %r8d,%rax\n  movslq %edx,%rdx\n  mov    (%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  test   %r8d,%r8d\n  je     11c4 <func0+0xa4>\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    (%r10,%rdx,8),%rdx\n  mov    -0x4(%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  cmp    %r8d,%r11d\n  jle    11de <func0+0xbe>\n  movslq %r9d,%r9\n  lea    0x1(%r8),%eax\n  mov    (%r10,%r9,8),%rdx\n  cltq\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  mov    %ebx,(%r12)\n  movslq %ebx,%r12\n  lea    0x0(,%r12,4),%rdi\n  call   1050 <malloc@plt>\n  xor    %edx,%edx\n  mov    $0x1,%esi\n  test   %ebx,%ebx\n  jle    1214 <func0+0xf4>\n  nopl   (%rax)\n  test   $0x1,%dl\n  mov    %esi,%ecx\n  cmovne %ebp,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%r12\n  jne    1200 <func0+0xe0>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdi,%r10\n  mov    %esi,%r11d\n  mov    %rcx,%r12\n  push   %rbp\n  push   %rbx\n  mov    %edx,%ebx\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rdx\n  xor    %edi,%edi\n  nopl   0x0(%rax)\nL2:\n  mov    (%r10,%rdi,8),%rcx\n  mov    %edi,%esi\n  xor    %eax,%eax\n  nopl   0x0(%rax,%rax,1)\nL1:\n  cmpl   $0x1,(%rcx,%rax,4)\n  cmove  %eax,%r8d\n  cmove  %esi,%r9d\n  add    $0x1,%rax\n  cmp    %rdx,%rax\n  jne    L1\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  jne    L2\nL0:\n  mov    %r11d,%ebp\n  imul   %r11d,%ebp\n  test   %r9d,%r9d\n  je     L3\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    -0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL3:\n  sub    $0x1,%r11d\n  cmp    %r9d,%r11d\n  jle    L4\n  lea    0x1(%r9),%edx\n  movslq %r8d,%rax\n  movslq %edx,%rdx\n  mov    (%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL4:\n  test   %r8d,%r8d\n  je     L5\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    (%r10,%rdx,8),%rdx\n  mov    -0x4(%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL5:\n  cmp    %r8d,%r11d\n  jle    L6\n  movslq %r9d,%r9\n  lea    0x1(%r8),%eax\n  mov    (%r10,%r9,8),%rdx\n  cltq\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL6:\n  mov    %ebx,(%r12)\n  movslq %ebx,%r12\n  lea    0x0(,%r12,4),%rdi\n  call   <malloc@plt>\n  xor    %edx,%edx\n  mov    $0x1,%esi\n  test   %ebx,%ebx\n  jle    L7\n  nopl   (%rax)\nL8:\n  test   $0x1,%dl\n  mov    %esi,%ecx\n  cmovne %ebp,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%r12\n  jne    L8\nL7:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4462
        },
        "L1": {
          "label": "L1",
          "addr": 4432
        },
        "L2": {
          "label": "L2",
          "addr": 4416
        },
        "L3": {
          "label": "L3",
          "addr": 4493
        },
        "L4": {
          "label": "L4",
          "addr": 4524
        },
        "L5": {
          "label": "L5",
          "addr": 4548
        },
        "L6": {
          "label": "L6",
          "addr": 4574
        },
        "L7": {
          "label": "L7",
          "addr": 4628
        },
        "L8": {
          "label": "L8",
          "addr": 4608
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int **a, int n, int m, int *ret_m) {\n  int i, j, min, x, y;\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      if (a[i][j] == 1) {\n        x = i;\n        y = j;\n      }\n    }\n  }\n  min = n * n;\n  if (x != 0) {\n    if (a[x - 1][y] < min) {\n      min = a[x - 1][y];\n    }\n  }\n  if (x != n - 1) {\n    if (a[x + 1][y] < min) {\n      min = a[x + 1][y];\n    }\n  }\n  if (y != 0) {\n    if (a[x][y - 1] < min) {\n      min = a[x][y - 1];\n    }\n  }\n  if (y != n - 1) {\n    if (a[x][y + 1] < min) {\n      min = a[x][y + 1];\n    }\n  }\n  *ret_m = m;\n  int *b = (int *)malloc(m * sizeof(int));\n  for (i = 0; i < m; i++) {\n    if (i % 2 == 0) {\n      b[i] = 1;\n    } else {\n      b[i] = min;\n    }\n  }\n  return b;\n}"
    },
    {
      "task_id": 134,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     1193 <func0+0x53>\n  movslq %eax,%r13\n  call   1070 <__ctype_b_loc@plt>\n  movzbl -0x1(%rbp,%r13,1),%edx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     11a8 <func0+0x68>\n  cmp    $0x1,%r12d\n  je     1193 <func0+0x53>\n  movzbl -0x2(%rbp,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%r12d\n  shr    $0xa,%r12w\n  xor    $0x1,%r12d\n  and    $0x1,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     L0\n  movslq %eax,%r13\n  call   <__ctype_b_loc@plt>\n  movzbl -0x1(%rbp,%r13,1),%edx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     L1\n  cmp    $0x1,%r12d\n  je     L0\n  movzbl -0x2(%rbp,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%r12d\n  shr    $0xa,%r12w\n  xor    $0x1,%r12d\n  and    $0x1,%r12d\nL0:\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\nL1:\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4499
        },
        "L1": {
          "label": "L1",
          "addr": 4520
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const char *str) {\n  int len = strlen(str);\n  if (len == 0)\n    return 0;\n  const unsigned short *map = (const unsigned short *)(*(const unsigned short **)(__ctype_b_loc()));\n  if (!(map[((unsigned char)(str[len - 1]))] & (0x0004)))\n    return 0;\n  if (len == 1)\n    return 1;\n  if (!(map[((unsigned char)(str[len - 2]))] & (0x0002)))\n    return 0;\n  return 1;\n}"
    },
    {
      "task_id": 134,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     1193 <func0+0x53>\n  movslq %eax,%r13\n  call   1070 <__ctype_b_loc@plt>\n  movzbl -0x1(%rbp,%r13,1),%edx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     11a8 <func0+0x68>\n  cmp    $0x1,%r12d\n  je     1193 <func0+0x53>\n  movzbl -0x2(%rbp,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%r12d\n  shr    $0xa,%r12w\n  xor    $0x1,%r12d\n  and    $0x1,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     L0\n  movslq %eax,%r13\n  call   <__ctype_b_loc@plt>\n  movzbl -0x1(%rbp,%r13,1),%edx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     L1\n  cmp    $0x1,%r12d\n  je     L0\n  movzbl -0x2(%rbp,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%r12d\n  shr    $0xa,%r12w\n  xor    $0x1,%r12d\n  and    $0x1,%r12d\nL0:\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\nL1:\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4499
        },
        "L1": {
          "label": "L1",
          "addr": 4520
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const char *str) {\n  int len = strlen(str);\n  if (len == 0)\n    return 0;\n  const unsigned short *map = (const unsigned short *)(*(const unsigned short **)(__ctype_b_loc()));\n  if (!(map[((unsigned char)(str[len - 1]))] & (0x0004)))\n    return 0;\n  if (len == 1)\n    return 1;\n  if (!(map[((unsigned char)(str[len - 2]))] & (0x0002)))\n    return 0;\n  return 1;\n}"
    },
    {
      "task_id": 138,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    111b <func0+0x22>\n  cmpl   $0x7,-0x4(%rbp)\n  jle    111b <func0+0x22>\n  mov    $0x1,%eax\n  jmp    1120 <func0+0x27>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L0\n  cmpl   $0x7,-0x4(%rbp)\n  jle    L0\n  mov    $0x1,%eax\n  jmp    L1\nL0:\n  mov    $0x0,%eax\nL1:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4379
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  if (n % 2 == 0 && n > 7)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 138,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  xor    $0x1,%edx\n  cmp    $0x7,%edi\n  setg   %al\n  movzbl %al,%eax\n  and    %edx,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  xor    $0x1,%edx\n  cmp    $0x7,%edi\n  setg   %al\n  movzbl %al,%eax\n  and    %edx,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a) {\n  int v0 = a ^ 1;\n  int v1 = a > 7;\n  return v0 & v1;\n}"
    },
    {
      "task_id": 138,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x7,%edi\n  not    %edi\n  setg   %al\n  and    %edi,%eax\n  movzbl %al,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x7,%edi\n  not    %edi\n  setg   %al\n  and    %edi,%eax\n  movzbl %al,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a) {\n  int v0 = a > 7;\n  int v1 = ~a;\n  int v2 = v1 & v0;\n  return v2;\n}"
    },
    {
      "task_id": 135,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    12b0 <func0+0x1b0>\n  lea    -0x2(%rsi),%eax\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%r8d\n  mov    %esi,%ecx\n  cmp    $0x2,%eax\n  jbe    12b6 <func0+0x1b6>\n  mov    %r8d,%esi\n  movdqa 0xed3(%rip),%xmm2        # 2000 <_fini+0xd2c>\n  mov    %rdi,%rax\n  pxor   %xmm3,%xmm3\n  shr    $0x2,%esi\n  movdqa 0xed1(%rip),%xmm4        # 2010 <_fini+0xd3c>\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  lea    0x10(%rdi,%rsi,1),%rsi\n  nopl   0x0(%rax,%rax,1)\n  movdqu (%rax),%xmm0\n  movdqu 0x4(%rax),%xmm5\n  movdqa %xmm2,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm4,%xmm2\n  pcmpgtd %xmm5,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm3,%xmm0\n  movdqa %xmm0,%xmm3\n  por    %xmm1,%xmm3\n  cmp    %rsi,%rax\n  jne    1150 <func0+0x50>\n  movdqa %xmm3,%xmm0\n  mov    $0xffffffff,%esi\n  mov    %r8d,%edi\n  psrldq $0x8,%xmm0\n  movdqa %xmm0,%xmm1\n  pcmpgtd %xmm3,%xmm1\n  pand   %xmm1,%xmm0\n  pandn  %xmm3,%xmm1\n  por    %xmm0,%xmm1\n  movdqa %xmm1,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm0\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm2\n  pandn  %xmm1,%xmm0\n  por    %xmm2,%xmm0\n  movd   %xmm0,%eax\n  test   %eax,%eax\n  cmove  %esi,%eax\n  and    $0xfffffffc,%edi\n  lea    0x1(%rdi),%esi\n  cmp    %edi,%r8d\n  je     12a8 <func0+0x1a8>\n  movslq %esi,%rdi\n  lea    0x1(%rsi),%r9d\n  push   %rbx\n  shl    $0x2,%rdi\n  lea    (%rdx,%rdi,1),%r10\n  cmp    %r8d,%r9d\n  jge    12c5 <func0+0x1c5>\n  cmp    %esi,%ecx\n  jle    12c5 <func0+0x1c5>\n  mov    (%r10),%r11d\n  cmp    %r11d,-0x4(%r10)\n  mov    0x4(%rdx,%rdi,1),%r10d\n  cmovg  %esi,%eax\n  cmp    %r10d,%r11d\n  lea    0x2(%rsi),%r11d\n  cmovg  %r9d,%eax\n  lea    0x3(%rsi),%r9d\n  cmp    %r9d,%r8d\n  jg     1260 <func0+0x160>\n  movslq %r11d,%rsi\n  mov    (%rdx,%rsi,4),%r8d\n  lea    0x0(,%rsi,4),%rdi\n  cmp    -0x4(%rdx,%rsi,4),%r8d\n  lea    0x1(%r11),%esi\n  cmovl  %r11d,%eax\n  cmp    %esi,%ecx\n  jle    125b <func0+0x15b>\n  cmp    0x4(%rdx,%rdi,1),%r8d\n  cmovle %eax,%esi\n  lea    0x2(%r11),%eax\n  cmp    %eax,%ecx\n  jle    12cd <func0+0x1cd>\n  mov    0x8(%rdx,%rdi,1),%ebx\n  cmp    %ebx,0x4(%rdx,%rdi,1)\n  cmovle %esi,%eax\n  pop    %rbx\n  ret\n  nopl   (%rax)\n  mov    0x8(%rdx,%rdi,1),%ebx\n  cmp    %ebx,%r10d\n  mov    0xc(%rdx,%rdi,1),%r10d\n  cmovg  %r11d,%eax\n  lea    0x4(%rsi),%r11d\n  cmp    %r10d,%ebx\n  cmovg  %r9d,%eax\n  lea    0x5(%rsi),%r9d\n  cmp    %r9d,%r8d\n  jle    121c <func0+0x11c>\n  mov    0x10(%rdx,%rdi,1),%r8d\n  cmp    %r10d,%r8d\n  cmovge %eax,%r11d\n  cmp    0x14(%rdx,%rdi,1),%r8d\n  mov    %r11d,%eax\n  lea    0x6(%rsi),%r11d\n  cmovg  %r9d,%eax\n  jmp    121c <func0+0x11c>\n  nopl   (%rax)\n  ret\n  nopl   0x0(%rax)\n  mov    $0xffffffff,%eax\n  ret\n  mov    $0x1,%esi\n  mov    $0xffffffff,%eax\n  jmp    11d8 <func0+0xd8>\n  mov    %esi,%r11d\n  jmp    121c <func0+0x11c>\n  mov    %esi,%eax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%eax\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%r8d\n  mov    %esi,%ecx\n  cmp    $0x2,%eax\n  jbe    L1\n  mov    %r8d,%esi\n  movdqa D0(%rip),%xmm2\n  mov    %rdi,%rax\n  pxor   %xmm3,%xmm3\n  shr    $0x2,%esi\n  movdqa D1(%rip),%xmm4\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  lea    0x10(%rdi,%rsi,1),%rsi\n  nopl   0x0(%rax,%rax,1)\nL2:\n  movdqu (%rax),%xmm0\n  movdqu 0x4(%rax),%xmm5\n  movdqa %xmm2,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm4,%xmm2\n  pcmpgtd %xmm5,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm3,%xmm0\n  movdqa %xmm0,%xmm3\n  por    %xmm1,%xmm3\n  cmp    %rsi,%rax\n  jne    L2\n  movdqa %xmm3,%xmm0\n  mov    $0xffffffff,%esi\n  mov    %r8d,%edi\n  psrldq $0x8,%xmm0\n  movdqa %xmm0,%xmm1\n  pcmpgtd %xmm3,%xmm1\n  pand   %xmm1,%xmm0\n  pandn  %xmm3,%xmm1\n  por    %xmm0,%xmm1\n  movdqa %xmm1,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm0\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm2\n  pandn  %xmm1,%xmm0\n  por    %xmm2,%xmm0\n  movd   %xmm0,%eax\n  test   %eax,%eax\n  cmove  %esi,%eax\n  and    $0xfffffffc,%edi\n  lea    0x1(%rdi),%esi\n  cmp    %edi,%r8d\n  je     L3\nL9:\n  movslq %esi,%rdi\n  lea    0x1(%rsi),%r9d\n  push   %rbx\n  shl    $0x2,%rdi\n  lea    (%rdx,%rdi,1),%r10\n  cmp    %r8d,%r9d\n  jge    L4\n  cmp    %esi,%ecx\n  jle    L4\n  mov    (%r10),%r11d\n  cmp    %r11d,-0x4(%r10)\n  mov    0x4(%rdx,%rdi,1),%r10d\n  cmovg  %esi,%eax\n  cmp    %r10d,%r11d\n  lea    0x2(%rsi),%r11d\n  cmovg  %r9d,%eax\n  lea    0x3(%rsi),%r9d\n  cmp    %r9d,%r8d\n  jg     L5\nL8:\n  movslq %r11d,%rsi\n  mov    (%rdx,%rsi,4),%r8d\n  lea    0x0(,%rsi,4),%rdi\n  cmp    -0x4(%rdx,%rsi,4),%r8d\n  lea    0x1(%r11),%esi\n  cmovl  %r11d,%eax\n  cmp    %esi,%ecx\n  jle    L6\n  cmp    0x4(%rdx,%rdi,1),%r8d\n  cmovle %eax,%esi\n  lea    0x2(%r11),%eax\n  cmp    %eax,%ecx\n  jle    L7\n  mov    0x8(%rdx,%rdi,1),%ebx\n  cmp    %ebx,0x4(%rdx,%rdi,1)\n  cmovle %esi,%eax\nL6:\n  pop    %rbx\n  ret\n  nopl   (%rax)\nL5:\n  mov    0x8(%rdx,%rdi,1),%ebx\n  cmp    %ebx,%r10d\n  mov    0xc(%rdx,%rdi,1),%r10d\n  cmovg  %r11d,%eax\n  lea    0x4(%rsi),%r11d\n  cmp    %r10d,%ebx\n  cmovg  %r9d,%eax\n  lea    0x5(%rsi),%r9d\n  cmp    %r9d,%r8d\n  jle    L8\n  mov    0x10(%rdx,%rdi,1),%r8d\n  cmp    %r10d,%r8d\n  cmovge %eax,%r11d\n  cmp    0x14(%rdx,%rdi,1),%r8d\n  mov    %r11d,%eax\n  lea    0x6(%rsi),%r11d\n  cmovg  %r9d,%eax\n  jmp    L8\n  nopl   (%rax)\nL3:\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0xffffffff,%eax\n  ret\nL1:\n  mov    $0x1,%esi\n  mov    $0xffffffff,%eax\n  jmp    L9\nL4:\n  mov    %esi,%r11d\n  jmp    L8\nL7:\n  mov    %esi,%eax\n  pop    %rbx\n  ret",
      "num_missing": 2,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3795
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3793
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4784
        },
        "L1": {
          "label": "L1",
          "addr": 4790
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4776
        },
        "L4": {
          "label": "L4",
          "addr": 4805
        },
        "L5": {
          "label": "L5",
          "addr": 4704
        },
        "L6": {
          "label": "L6",
          "addr": 4699
        },
        "L7": {
          "label": "L7",
          "addr": 4813
        },
        "L8": {
          "label": "L8",
          "addr": 4636
        },
        "L9": {
          "label": "L9",
          "addr": 4568
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0100000002000000030000000400000004000000040000000400000004000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              1,
              0,
              0,
              0,
              2,
              0,
              0,
              0,
              3,
              0,
              0,
              0,
              4,
              0,
              0,
              0
            ]
          },
          "0x2010": {
            "type": "byte[16]",
            "value": [
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, max = -1;\n  for (i = 1; i < len; i++) {\n    if (arr[i] > arr[i - 1])\n      max = i;\n  }\n  return max;\n}"
    },
    {
      "task_id": 138,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    $0x7,%edi\n  not    %edi\n  setg   %al\n  and    %edi,%eax\n  movzbl %al,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x7,%edi\n  not    %edi\n  setg   %al\n  and    %edi,%eax\n  movzbl %al,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {},
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a) {\n  int v0 = a > 7;\n  int v1 = ~a;\n  int v2 = v1 & v0;\n  return v2;\n}"
    },
    {
      "task_id": 136,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    11d2 <func0+0xd9>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jns    117a <func0+0x81>\n  cmpl   $0x0,-0xc(%rbp)\n  je     1161 <func0+0x68>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jge    117a <func0+0x81>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    11ce <func0+0xd5>\n  cmpl   $0x0,-0x8(%rbp)\n  je     11b5 <func0+0xbc>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x8(%rbp)\n  jle    11ce <func0+0xd5>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1126 <func0+0x2d>\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jns    L1\n  cmpl   $0x0,-0xc(%rbp)\n  je     L2\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jge    L1\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    L3\n  cmpl   $0x0,-0x8(%rbp)\n  je     L4\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x8(%rbp)\n  jle    L3\nL4:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\nL3:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4562
        },
        "L1": {
          "label": "L1",
          "addr": 4474
        },
        "L2": {
          "label": "L2",
          "addr": 4449
        },
        "L3": {
          "label": "L3",
          "addr": 4558
        },
        "L4": {
          "label": "L4",
          "addr": 4533
        },
        "L5": {
          "label": "L5",
          "addr": 4390
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int *out) {\n  int min = 0;\n  int max = 0;\n  for (int i = 0; i < n; i++) {\n    if (x[i] < 0 && (min == 0 || x[i] < min))\n      min = x[i];\n    if (x[i] > 0 && (max == 0 || x[i] > max))\n      max = x[i];\n  }\n  out[0] = min;\n  out[1] = max;\n}"
    },
    {
      "task_id": 136,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1150 <func0+0x50>\n  lea    -0x1(%rsi),%eax\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopl   0x0(%rax)\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     1140 <func0+0x40>\n  je     112a <func0+0x2a>\n  test   %ecx,%ecx\n  je     1128 <func0+0x28>\n  cmp    %ecx,%eax\n  jge    112a <func0+0x2a>\n  mov    %eax,%ecx\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  jne    1118 <func0+0x18>\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  nopl   0x0(%rax)\n  cmp    %esi,%eax\n  jg     1148 <func0+0x48>\n  test   %esi,%esi\n  jne    112a <func0+0x2a>\n  mov    %eax,%esi\n  jmp    112a <func0+0x2a>\n  nopl   0x0(%rax)\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopl   0x0(%rax)\nL4:\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     L1\n  je     L2\n  test   %ecx,%ecx\n  je     L3\n  cmp    %ecx,%eax\n  jge    L2\nL3:\n  mov    %eax,%ecx\nL2:\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  jne    L4\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  nopl   0x0(%rax)\nL1:\n  cmp    %esi,%eax\n  jg     L5\n  test   %esi,%esi\n  jne    L2\nL5:\n  mov    %eax,%esi\n  jmp    L2\n  nopl   0x0(%rax)\nL0:\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4432
        },
        "L1": {
          "label": "L1",
          "addr": 4416
        },
        "L2": {
          "label": "L2",
          "addr": 4394
        },
        "L3": {
          "label": "L3",
          "addr": 4392
        },
        "L4": {
          "label": "L4",
          "addr": 4376
        },
        "L5": {
          "label": "L5",
          "addr": 4424
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int *r) {\n  int i, a = 0, b = 0;\n  for (i = 0; i < n; ++i) {\n    if (x[i] < 0) {\n      if (x[i] > a || a == 0)\n        a = x[i];\n    } else if (x[i] > 0) {\n      if (x[i] < b || b == 0)\n        b = x[i];\n    }\n  }\n  r[0] = a;\n  r[1] = b;\n}"
    },
    {
      "task_id": 136,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1150 <func0+0x50>\n  lea    -0x1(%rsi),%eax\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopl   0x0(%rax)\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     1140 <func0+0x40>\n  je     112a <func0+0x2a>\n  test   %ecx,%ecx\n  je     1128 <func0+0x28>\n  cmp    %ecx,%eax\n  jge    112a <func0+0x2a>\n  mov    %eax,%ecx\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  jne    1118 <func0+0x18>\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  nopl   0x0(%rax)\n  cmp    %esi,%eax\n  jg     1148 <func0+0x48>\n  test   %esi,%esi\n  jne    112a <func0+0x2a>\n  mov    %eax,%esi\n  jmp    112a <func0+0x2a>\n  nopl   0x0(%rax)\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopl   0x0(%rax)\nL4:\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     L1\n  je     L2\n  test   %ecx,%ecx\n  je     L3\n  cmp    %ecx,%eax\n  jge    L2\nL3:\n  mov    %eax,%ecx\nL2:\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  jne    L4\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  nopl   0x0(%rax)\nL1:\n  cmp    %esi,%eax\n  jg     L5\n  test   %esi,%esi\n  jne    L2\nL5:\n  mov    %eax,%esi\n  jmp    L2\n  nopl   0x0(%rax)\nL0:\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4432
        },
        "L1": {
          "label": "L1",
          "addr": 4416
        },
        "L2": {
          "label": "L2",
          "addr": 4394
        },
        "L3": {
          "label": "L3",
          "addr": 4392
        },
        "L4": {
          "label": "L4",
          "addr": 4376
        },
        "L5": {
          "label": "L5",
          "addr": 4424
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int *r) {\n  int i, a = 0, b = 0;\n  for (i = 0; i < n; ++i) {\n    if (x[i] < 0) {\n      if (x[i] > a || a == 0)\n        a = x[i];\n    } else if (x[i] > 0) {\n      if (x[i] < b || b == 0)\n        b = x[i];\n    }\n  }\n  r[0] = a;\n  r[1] = b;\n}"
    },
    {
      "task_id": 136,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
      "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1141 <func0+0x48>\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  jmp    112f <func0+0x36>\n  cmp    %edi,%eax\n  jg     1120 <func0+0x27>\n  test   %edi,%edi\n  jne    1126 <func0+0x2d>\n  mov    %eax,%edi\n  jmp    1126 <func0+0x2d>\n  mov    %eax,%esi\n  add    $0x4,%rcx\n  cmp    %r8,%rcx\n  je     114b <func0+0x52>\n  mov    (%rcx),%eax\n  test   %eax,%eax\n  js     1118 <func0+0x1f>\n  jle    1126 <func0+0x2d>\n  cmp    %esi,%eax\n  jl     1124 <func0+0x2b>\n  test   %esi,%esi\n  je     1124 <func0+0x2b>\n  jmp    1126 <func0+0x2d>\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  mov    %edi,(%rdx)\n  mov    %esi,0x4(%rdx)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  jmp    L1\nL5:\n  cmp    %edi,%eax\n  jg     L2\n  test   %edi,%edi\n  jne    L3\nL2:\n  mov    %eax,%edi\n  jmp    L3\nL6:\n  mov    %eax,%esi\nL3:\n  add    $0x4,%rcx\n  cmp    %r8,%rcx\n  je     L4\nL1:\n  mov    (%rcx),%eax\n  test   %eax,%eax\n  js     L5\n  jle    L3\n  cmp    %esi,%eax\n  jl     L6\n  test   %esi,%esi\n  je     L6\n  jmp    L3\nL0:\n  mov    $0x0,%esi\n  mov    $0x0,%edi\nL4:\n  mov    %edi,(%rdx)\n  mov    %esi,0x4(%rdx)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4417
        },
        "L1": {
          "label": "L1",
          "addr": 4399
        },
        "L2": {
          "label": "L2",
          "addr": 4384
        },
        "L3": {
          "label": "L3",
          "addr": 4390
        },
        "L4": {
          "label": "L4",
          "addr": 4427
        },
        "L5": {
          "label": "L5",
          "addr": 4376
        },
        "L6": {
          "label": "L6",
          "addr": 4388
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int n, int *p) {\n  int i;\n  int min0 = 0, max0 = 0;\n  for (i = 0; i < n; ++i) {\n    if (x[i] < 0) {\n      if (x[i] < min0 || min0 == 0)\n        min0 = x[i];\n    } else if (x[i] > 0) {\n      if (x[i] > max0 || max0 == 0)\n        max0 = x[i];\n    }\n  }\n  p[0] = min0;\n  p[1] = max0;\n}"
    },
    {
      "task_id": 139,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x24(%rbp)\n  movq   $0x1,-0x10(%rbp)\n  movq   $0x1,-0x8(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    113f <func0+0x46>\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0x10(%rbp),%rdx\n  imul   %rdx,%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x8(%rbp),%rax\n  imul   -0x10(%rbp),%rax\n  mov    %rax,-0x8(%rbp)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    111d <func0+0x24>\n  mov    -0x8(%rbp),%rax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x24(%rbp)\n  movq   $0x1,-0x10(%rbp)\n  movq   $0x1,-0x8(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    L0\nL1:\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0x10(%rbp),%rdx\n  imul   %rdx,%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x8(%rbp),%rax\n  imul   -0x10(%rbp),%rax\n  mov    %rax,-0x8(%rbp)\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    L1\n  mov    -0x8(%rbp),%rax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4415
        },
        "L1": {
          "label": "L1",
          "addr": 4381
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " long func0(int n) {\n  long i, j, k;\n  i = 1;\n  j = 1;\n  for (k = 1; k <= n; k++) {\n    i = i * k;\n    j = j * i;\n  }\n  return j;\n}"
    },
    {
      "task_id": 139,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1128 <func0+0x2f>\n  lea    0x1(%rdi),%esi\n  mov    $0x1,%eax\n  mov    $0x1,%ecx\n  mov    $0x1,%edx\n  imul   %rax,%rdx\n  imul   %rdx,%rcx\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    1113 <func0+0x1a>\n  mov    %rcx,%rax\n  ret\n  mov    $0x1,%ecx\n  jmp    1124 <func0+0x2b>",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  lea    0x1(%rdi),%esi\n  mov    $0x1,%eax\n  mov    $0x1,%ecx\n  mov    $0x1,%edx\nL1:\n  imul   %rax,%rdx\n  imul   %rdx,%rcx\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    L1\nL2:\n  mov    %rcx,%rax\n  ret\nL0:\n  mov    $0x1,%ecx\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4392
        },
        "L1": {
          "label": "L1",
          "addr": 4371
        },
        "L2": {
          "label": "L2",
          "addr": 4388
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " long long func0(int n) {\n  long long sum = 1;\n  long long i = 1;\n  for (i = 1; i <= n; i++) {\n    sum *= i;\n  }\n  return sum;\n}"
    },
    {
      "task_id": 139,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1138 <func0+0x38>\n  lea    0x1(%rdi),%ecx\n  mov    $0x1,%eax\n  mov    $0x1,%r8d\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\n  imul   %rax,%rdx\n  add    $0x1,%rax\n  imul   %rdx,%r8\n  cmp    %rcx,%rax\n  jne    1120 <func0+0x20>\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\n  mov    $0x1,%r8d\n  mov    %r8,%rax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  lea    0x1(%rdi),%ecx\n  mov    $0x1,%eax\n  mov    $0x1,%r8d\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\nL1:\n  imul   %rax,%rdx\n  add    $0x1,%rax\n  imul   %rdx,%r8\n  cmp    %rcx,%rax\n  jne    L1\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\nL0:\n  mov    $0x1,%r8d\n  mov    %r8,%rax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " long func0(int n) {\n  long result = 1;\n  int i;\n  for (i = 1; i <= n; i++)\n    result *= i;\n  return result;\n}"
    },
    {
      "task_id": 139,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1138 <func0+0x38>\n  lea    0x1(%rdi),%ecx\n  mov    $0x1,%eax\n  mov    $0x1,%r8d\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\n  imul   %rax,%rdx\n  add    $0x1,%rax\n  imul   %rdx,%r8\n  cmp    %rcx,%rax\n  jne    1120 <func0+0x20>\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\n  mov    $0x1,%r8d\n  mov    %r8,%rax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  lea    0x1(%rdi),%ecx\n  mov    $0x1,%eax\n  mov    $0x1,%r8d\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\nL1:\n  imul   %rax,%rdx\n  add    $0x1,%rax\n  imul   %rdx,%r8\n  cmp    %rcx,%rax\n  jne    L1\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\nL0:\n  mov    $0x1,%r8d\n  mov    %r8,%rax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4408
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " long func0(int n) {\n  long result = 1;\n  int i;\n  for (i = 1; i <= n; i++)\n    result *= i;\n  return result;\n}"
    },
    {
      "task_id": 129,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  lea    -0x1(%rsi),%r15d\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %edx,0x4(%rsp)\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    13a8 <func0+0x288>\n  mov    %esi,%edx\n  mov    %esi,%r13d\n  movdqa 0xec9(%rip),%xmm7        # 2020 <_fini+0xac8>\n  mov    %esi,%ebp\n  shr    $0x2,%edx\n  and    $0xfffffffc,%r13d\n  pcmpeqd %xmm10,%xmm10\n  xor    %ecx,%ecx\n  movdqa 0xec0(%rip),%xmm9        # 2030 <_fini+0xad8>\n  lea    -0x1(%rdx),%r14d\n  add    $0x1,%r14\n  shl    $0x4,%r14\n  nopl   0x0(%rax)\n  mov    (%r12,%rcx,8),%rdx\n  mov    %ecx,%r10d\n  cmp    $0x7,%r15d\n  jbe    1530 <func0+0x410>\n  movd   %eax,%xmm4\n  lea    (%r14,%rdx,1),%rdi\n  pxor   %xmm2,%xmm2\n  mov    %rdx,%rax\n  pshufd $0x0,%xmm4,%xmm5\n  movd   %ecx,%xmm4\n  movdqa %xmm10,%xmm6\n  movdqa 0xe5a(%rip),%xmm3        # 2010 <_fini+0xab8>\n  pshufd $0x0,%xmm4,%xmm11\n  movdqa 0xe3c(%rip),%xmm4        # 2000 <_fini+0xaa8>\n  nopl   0x0(%rax)\n  movdqu (%rax),%xmm0\n  movdqa %xmm11,%xmm8\n  movdqa %xmm3,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm7,%xmm3\n  pcmpeqd %xmm9,%xmm0\n  movdqa %xmm0,%xmm12\n  pand   %xmm0,%xmm8\n  pand   %xmm0,%xmm1\n  pandn  %xmm5,%xmm12\n  movdqa %xmm12,%xmm5\n  por    %xmm8,%xmm5\n  movdqa %xmm0,%xmm8\n  pandn  %xmm6,%xmm8\n  movdqa %xmm8,%xmm6\n  por    %xmm1,%xmm6\n  movdqa %xmm4,%xmm1\n  paddd  %xmm7,%xmm4\n  pand   %xmm0,%xmm1\n  pandn  %xmm2,%xmm0\n  movdqa %xmm0,%xmm2\n  por    %xmm1,%xmm2\n  cmp    %rax,%rdi\n  jne    11c8 <func0+0xa8>\n  movdqa %xmm6,%xmm0\n  movd   %xmm2,%ebx\n  psrldq $0x8,%xmm0\n  movdqa %xmm0,%xmm1\n  pcmpgtd %xmm6,%xmm1\n  pand   %xmm1,%xmm0\n  pandn  %xmm6,%xmm1\n  por    %xmm0,%xmm1\n  movdqa %xmm1,%xmm3\n  psrldq $0x4,%xmm3\n  movdqa %xmm3,%xmm0\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm1,%xmm0\n  por    %xmm3,%xmm0\n  movd   %xmm0,%eax\n  pshufd $0x55,%xmm2,%xmm0\n  cmp    $0xffffffff,%eax\n  movd   %xmm0,%r9d\n  cmovne %eax,%r8d\n  movd   %xmm0,%eax\n  movdqa %xmm2,%xmm0\n  cmp    %r9d,%ebx\n  punpckhdq %xmm2,%xmm0\n  cmovae %ebx,%eax\n  movd   %xmm0,%edi\n  cmp    %edi,%eax\n  jb     1518 <func0+0x3f8>\n  pshufd $0x55,%xmm5,%xmm0\n  movd   %xmm5,%r11d\n  cmp    %r9d,%ebx\n  movd   %xmm0,(%rsp)\n  cmovb  (%rsp),%r11d\n  pshufd $0xff,%xmm2,%xmm2\n  pshufd $0xff,%xmm5,%xmm5\n  cmp    %edi,%eax\n  cmovb  %edi,%eax\n  movd   %xmm2,%edi\n  cmp    %edi,%eax\n  movd   %xmm5,%eax\n  mov    %r13d,%edi\n  cmovae %r11d,%eax\n  cmp    %r13d,%esi\n  je     139b <func0+0x27b>\n  movslq %edi,%r11\n  cmpl   $0x1,(%rdx,%r11,4)\n  lea    0x0(,%r11,4),%r9\n  lea    0x1(%rdi),%r11d\n  cmove  %edi,%r8d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    139b <func0+0x27b>\n  cmpl   $0x1,0x4(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x2(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    139b <func0+0x27b>\n  cmpl   $0x1,0x8(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x3(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %esi,%r11d\n  jge    139b <func0+0x27b>\n  cmpl   $0x1,0xc(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x4(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    139b <func0+0x27b>\n  cmpl   $0x1,0x10(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x5(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %esi,%r11d\n  jge    139b <func0+0x27b>\n  cmpl   $0x1,0x14(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x6(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    139b <func0+0x27b>\n  cmpl   $0x1,0x18(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  cmove  %r10d,%eax\n  add    $0x7,%edi\n  cmp    %edi,%esi\n  jle    139b <func0+0x27b>\n  cmpl   $0x1,0x1c(%rdx,%r9,1)\n  cmove  %edi,%r8d\n  cmove  %r10d,%eax\n  add    $0x1,%rcx\n  cmp    %rbp,%rcx\n  jne    1180 <func0+0x60>\n  mov    %esi,%ebx\n  imul   %esi,%ebx\n  test   %eax,%eax\n  jle    13c4 <func0+0x2a4>\n  movslq %eax,%rcx\n  movslq %r8d,%rdx\n  mov    -0x8(%r12,%rcx,8),%rcx\n  mov    (%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\n  cmp    %eax,%r15d\n  jle    13de <func0+0x2be>\n  lea    0x1(%rax),%ecx\n  movslq %r8d,%rdx\n  movslq %ecx,%rcx\n  mov    (%r12,%rcx,8),%rcx\n  mov    (%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\n  test   %r8d,%r8d\n  jle    13f6 <func0+0x2d6>\n  movslq %eax,%rcx\n  movslq %r8d,%rdx\n  mov    (%r12,%rcx,8),%rcx\n  mov    -0x4(%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\n  cmp    %r8d,%r15d\n  jle    1410 <func0+0x2f0>\n  cltq\n  lea    0x1(%r8),%edx\n  mov    (%r12,%rax,8),%rax\n  movslq %edx,%rdx\n  mov    (%rax,%rdx,4),%eax\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\n  movslq 0x4(%rsp),%rdi\n  mov    0x8(%rsp),%rax\n  mov    %edi,(%rax)\n  mov    %rdi,%r14\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r8\n  test   %r14d,%r14d\n  jle    1501 <func0+0x3e1>\n  lea    -0x1(%r14),%eax\n  cmp    $0x2,%eax\n  jbe    1537 <func0+0x417>\n  movd   %ebx,%xmm7\n  shr    $0x2,%r14d\n  mov    %r8,%rax\n  pxor   %xmm4,%xmm4\n  mov    %r14d,%edx\n  movdqa 0xbb5(%rip),%xmm1        # 2010 <_fini+0xab8>\n  movdqa 0xbbd(%rip),%xmm5        # 2020 <_fini+0xac8>\n  pshufd $0x0,%xmm7,%xmm6\n  shl    $0x4,%rdx\n  movdqa 0xbbc(%rip),%xmm2        # 2030 <_fini+0xad8>\n  add    %r8,%rdx\n  nopw   0x0(%rax,%rax,1)\n  movdqa %xmm1,%xmm0\n  movdqa %xmm2,%xmm3\n  paddd  %xmm5,%xmm1\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm6,%xmm0\n  por    %xmm3,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rdx,%rax\n  jne    1480 <func0+0x360>\n  mov    0x4(%rsp),%esi\n  mov    %esi,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%sil\n  je     1501 <func0+0x3e1>\n  movslq %eax,%rcx\n  add    $0x1,%eax\n  movl   $0x1,(%r8,%rcx,4)\n  lea    0x0(,%rcx,4),%rdx\n  cmp    %eax,%esi\n  jle    1501 <func0+0x3e1>\n  add    $0x4,%rdx\n  mov    $0x1,%ecx\n  lea    (%r8,%rdx,1),%rsi\n  test   $0x1,%al\n  jne    1553 <func0+0x433>\n  mov    %ecx,(%rsi)\n  add    $0x1,%eax\n  cmp    %eax,0x4(%rsp)\n  jle    1501 <func0+0x3e1>\n  test   $0x1,%al\n  mov    $0x1,%eax\n  cmove  %eax,%ebx\n  mov    %ebx,0x4(%r8,%rdx,1)\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  movdqa %xmm5,%xmm0\n  punpckhdq %xmm5,%xmm0\n  movd   %xmm0,%r11d\n  jmp    12b7 <func0+0x197>\n  nopw   0x0(%rax,%rax,1)\n  xor    %edi,%edi\n  jmp    12e0 <func0+0x1c0>\n  cmpl   $0x1,0x4(%rsp)\n  movl   $0x1,(%r8)\n  jle    1501 <func0+0x3e1>\n  lea    0x4(%r8),%rsi\n  mov    $0x1,%eax\n  mov    $0x4,%edx\n  mov    %ebx,%ecx\n  jmp    14e7 <func0+0x3c7>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  lea    -0x1(%rsi),%r15d\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %edx,0x4(%rsp)\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%edx\n  mov    %esi,%r13d\n  movdqa D0(%rip),%xmm7\n  mov    %esi,%ebp\n  shr    $0x2,%edx\n  and    $0xfffffffc,%r13d\n  pcmpeqd %xmm10,%xmm10\n  xor    %ecx,%ecx\n  movdqa D1(%rip),%xmm9\n  lea    -0x1(%rdx),%r14d\n  add    $0x1,%r14\n  shl    $0x4,%r14\n  nopl   0x0(%rax)\nL5:\n  mov    (%r12,%rcx,8),%rdx\n  mov    %ecx,%r10d\n  cmp    $0x7,%r15d\n  jbe    L1\n  movd   %eax,%xmm4\n  lea    (%r14,%rdx,1),%rdi\n  pxor   %xmm2,%xmm2\n  mov    %rdx,%rax\n  pshufd $0x0,%xmm4,%xmm5\n  movd   %ecx,%xmm4\n  movdqa %xmm10,%xmm6\n  movdqa D2(%rip),%xmm3\n  pshufd $0x0,%xmm4,%xmm11\n  movdqa D3(%rip),%xmm4\n  nopl   0x0(%rax)\nL2:\n  movdqu (%rax),%xmm0\n  movdqa %xmm11,%xmm8\n  movdqa %xmm3,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm7,%xmm3\n  pcmpeqd %xmm9,%xmm0\n  movdqa %xmm0,%xmm12\n  pand   %xmm0,%xmm8\n  pand   %xmm0,%xmm1\n  pandn  %xmm5,%xmm12\n  movdqa %xmm12,%xmm5\n  por    %xmm8,%xmm5\n  movdqa %xmm0,%xmm8\n  pandn  %xmm6,%xmm8\n  movdqa %xmm8,%xmm6\n  por    %xmm1,%xmm6\n  movdqa %xmm4,%xmm1\n  paddd  %xmm7,%xmm4\n  pand   %xmm0,%xmm1\n  pandn  %xmm2,%xmm0\n  movdqa %xmm0,%xmm2\n  por    %xmm1,%xmm2\n  cmp    %rax,%rdi\n  jne    L2\n  movdqa %xmm6,%xmm0\n  movd   %xmm2,%ebx\n  psrldq $0x8,%xmm0\n  movdqa %xmm0,%xmm1\n  pcmpgtd %xmm6,%xmm1\n  pand   %xmm1,%xmm0\n  pandn  %xmm6,%xmm1\n  por    %xmm0,%xmm1\n  movdqa %xmm1,%xmm3\n  psrldq $0x4,%xmm3\n  movdqa %xmm3,%xmm0\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm1,%xmm0\n  por    %xmm3,%xmm0\n  movd   %xmm0,%eax\n  pshufd $0x55,%xmm2,%xmm0\n  cmp    $0xffffffff,%eax\n  movd   %xmm0,%r9d\n  cmovne %eax,%r8d\n  movd   %xmm0,%eax\n  movdqa %xmm2,%xmm0\n  cmp    %r9d,%ebx\n  punpckhdq %xmm2,%xmm0\n  cmovae %ebx,%eax\n  movd   %xmm0,%edi\n  cmp    %edi,%eax\n  jb     L3\n  pshufd $0x55,%xmm5,%xmm0\n  movd   %xmm5,%r11d\n  cmp    %r9d,%ebx\n  movd   %xmm0,(%rsp)\n  cmovb  (%rsp),%r11d\nL14:\n  pshufd $0xff,%xmm2,%xmm2\n  pshufd $0xff,%xmm5,%xmm5\n  cmp    %edi,%eax\n  cmovb  %edi,%eax\n  movd   %xmm2,%edi\n  cmp    %edi,%eax\n  movd   %xmm5,%eax\n  mov    %r13d,%edi\n  cmovae %r11d,%eax\n  cmp    %r13d,%esi\n  je     L4\nL15:\n  movslq %edi,%r11\n  cmpl   $0x1,(%rdx,%r11,4)\n  lea    0x0(,%r11,4),%r9\n  lea    0x1(%rdi),%r11d\n  cmove  %edi,%r8d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    L4\n  cmpl   $0x1,0x4(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x2(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    L4\n  cmpl   $0x1,0x8(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x3(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %esi,%r11d\n  jge    L4\n  cmpl   $0x1,0xc(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x4(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    L4\n  cmpl   $0x1,0x10(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x5(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %esi,%r11d\n  jge    L4\n  cmpl   $0x1,0x14(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x6(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    L4\n  cmpl   $0x1,0x18(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  cmove  %r10d,%eax\n  add    $0x7,%edi\n  cmp    %edi,%esi\n  jle    L4\n  cmpl   $0x1,0x1c(%rdx,%r9,1)\n  cmove  %edi,%r8d\n  cmove  %r10d,%eax\nL4:\n  add    $0x1,%rcx\n  cmp    %rbp,%rcx\n  jne    L5\nL0:\n  mov    %esi,%ebx\n  imul   %esi,%ebx\n  test   %eax,%eax\n  jle    L6\n  movslq %eax,%rcx\n  movslq %r8d,%rdx\n  mov    -0x8(%r12,%rcx,8),%rcx\n  mov    (%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\nL6:\n  cmp    %eax,%r15d\n  jle    L7\n  lea    0x1(%rax),%ecx\n  movslq %r8d,%rdx\n  movslq %ecx,%rcx\n  mov    (%r12,%rcx,8),%rcx\n  mov    (%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\nL7:\n  test   %r8d,%r8d\n  jle    L8\n  movslq %eax,%rcx\n  movslq %r8d,%rdx\n  mov    (%r12,%rcx,8),%rcx\n  mov    -0x4(%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\nL8:\n  cmp    %r8d,%r15d\n  jle    L9\n  cltq\n  lea    0x1(%r8),%edx\n  mov    (%r12,%rax,8),%rax\n  movslq %edx,%rdx\n  mov    (%rax,%rdx,4),%eax\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\nL9:\n  movslq 0x4(%rsp),%rdi\n  mov    0x8(%rsp),%rax\n  mov    %edi,(%rax)\n  mov    %rdi,%r14\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %r14d,%r14d\n  jle    L10\n  lea    -0x1(%r14),%eax\n  cmp    $0x2,%eax\n  jbe    L11\n  movd   %ebx,%xmm7\n  shr    $0x2,%r14d\n  mov    %r8,%rax\n  pxor   %xmm4,%xmm4\n  mov    %r14d,%edx\n  movdqa D2(%rip),%xmm1\n  movdqa D0(%rip),%xmm5\n  pshufd $0x0,%xmm7,%xmm6\n  shl    $0x4,%rdx\n  movdqa D1(%rip),%xmm2\n  add    %r8,%rdx\n  nopw   0x0(%rax,%rax,1)\nL12:\n  movdqa %xmm1,%xmm0\n  movdqa %xmm2,%xmm3\n  paddd  %xmm5,%xmm1\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm6,%xmm0\n  por    %xmm3,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rdx,%rax\n  jne    L12\n  mov    0x4(%rsp),%esi\n  mov    %esi,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%sil\n  je     L10\n  movslq %eax,%rcx\n  add    $0x1,%eax\n  movl   $0x1,(%r8,%rcx,4)\n  lea    0x0(,%rcx,4),%rdx\n  cmp    %eax,%esi\n  jle    L10\n  add    $0x4,%rdx\n  mov    $0x1,%ecx\n  lea    (%r8,%rdx,1),%rsi\n  test   $0x1,%al\n  jne    L13\nL16:\n  mov    %ecx,(%rsi)\n  add    $0x1,%eax\n  cmp    %eax,0x4(%rsp)\n  jle    L10\n  test   $0x1,%al\n  mov    $0x1,%eax\n  cmove  %eax,%ebx\n  mov    %ebx,0x4(%r8,%rdx,1)\nL10:\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  movdqa %xmm5,%xmm0\n  punpckhdq %xmm5,%xmm0\n  movd   %xmm0,%r11d\n  jmp    L14\n  nopw   0x0(%rax,%rax,1)\nL1:\n  xor    %edi,%edi\n  jmp    L15\nL11:\n  cmpl   $0x1,0x4(%rsp)\n  movl   $0x1,(%r8)\n  jle    L10\n  lea    0x4(%r8),%rsi\n  mov    $0x1,%eax\n  mov    $0x4,%edx\nL13:\n  mov    %ebx,%ecx\n  jmp    L16",
      "num_missing": 4,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8224,
          "bias": [
            3785,
            3005
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8240,
          "bias": [
            3776,
            3004
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8208,
          "bias": [
            3674,
            2997
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8192,
          "bias": [
            3644
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5032
        },
        "L1": {
          "label": "L1",
          "addr": 5424
        },
        "L2": {
          "label": "L2",
          "addr": 4552
        },
        "L3": {
          "label": "L3",
          "addr": 5400
        },
        "L4": {
          "label": "L4",
          "addr": 5019
        },
        "L5": {
          "label": "L5",
          "addr": 4480
        },
        "L6": {
          "label": "L6",
          "addr": 5060
        },
        "L7": {
          "label": "L7",
          "addr": 5086
        },
        "L8": {
          "label": "L8",
          "addr": 5110
        },
        "L9": {
          "label": "L9",
          "addr": 5136
        },
        "L10": {
          "label": "L10",
          "addr": 5377
        },
        "L11": {
          "label": "L11",
          "addr": 5431
        },
        "L12": {
          "label": "L12",
          "addr": 5248
        },
        "L13": {
          "label": "L13",
          "addr": 5459
        },
        "L14": {
          "label": "L14",
          "addr": 4791
        },
        "L15": {
          "label": "L15",
          "addr": 4832
        },
        "L16": {
          "label": "L16",
          "addr": 5351
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "01000000020000000300000004000000000000000100000002000000030000000400000004000000040000000400000001000000010000000100000001000000",
      "rodata_parsed": {
        "func0": {
          "0x2020": {
            "type": "byte[16]",
            "value": [
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0
            ]
          },
          "0x2030": {
            "type": "byte[16]",
            "value": [
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              0,
              0
            ]
          },
          "0x2010": {
            "type": "byte[16]",
            "value": [
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              2,
              0,
              0,
              0,
              3,
              0,
              0,
              0
            ]
          },
          "0x2000": {
            "type": "byte[16]",
            "value": [
              1,
              0,
              0,
              0,
              2,
              0,
              0,
              0,
              3,
              0,
              0,
              0,
              4,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int **matrix, int n, int m, int *ret_m) {\n  int i, j, min_i, min_j, min;\n  min_i = min_j = min = n * n;\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      if (matrix[i][j] == 1) {\n        min_i = i;\n        min_j = j;\n      }\n    }\n  }\n  if (min_i > 0) {\n    if (matrix[min_i - 1][min_j] < min) {\n      min = matrix[min_i - 1][min_j];\n    }\n  }\n  if (min_i < n - 1) {\n    if (matrix[min_i + 1][min_j] < min) {\n      min = matrix[min_i + 1][min_j];\n    }\n  }\n  if (min_j > 0) {\n    if (matrix[min_i][min_j - 1] < min) {\n      min = matrix[min_i][min_j - 1];\n    }\n  }\n  if (min_j < n - 1) {\n    if (matrix[min_i][min_j + 1] < min) {\n      min = matrix[min_i][min_j + 1];\n    }\n  }\n  *ret_m = m;\n  int *ret = (int *)malloc(sizeof(int) * m);\n  for (i = 0; i < m; i++) {\n    if (i % 2 == 0) {\n      ret[i] = 1;\n    } else {\n      ret[i] = min;\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 132,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  add    %rbx,%rax\n  jmp    115d <func0+0x3d>\n  nopl   0x0(%rax)\n  cmp    $0x5d,%sil\n  jne    114d <func0+0x2d>\n  sub    $0x1,%edx\n  jae    114d <func0+0x2d>\n  xor    %edx,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jg     117e <func0+0x5e>\n  cmp    %rdi,%rax\n  je     1188 <func0+0x68>\n  movzbl (%rdi),%esi\n  cmp    $0x5b,%sil\n  jne    1140 <func0+0x20>\n  add    $0x1,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jle    115d <func0+0x3d>\n  mov    $0x1,%eax\n  pop    %rbx\n  ret\n  nopl   (%rax)\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  add    %rbx,%rax\n  jmp    L0\n  nopl   0x0(%rax)\nL4:\n  cmp    $0x5d,%sil\n  jne    L1\n  sub    $0x1,%edx\n  jae    L1\n  xor    %edx,%edx\nL1:\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jg     L2\nL0:\n  cmp    %rdi,%rax\n  je     L3\n  movzbl (%rdi),%esi\n  cmp    $0x5b,%sil\n  jne    L4\n  add    $0x1,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jle    L0\nL2:\n  mov    $0x1,%eax\n  pop    %rbx\n  ret\n  nopl   (%rax)\nL3:\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4445
        },
        "L1": {
          "label": "L1",
          "addr": 4429
        },
        "L2": {
          "label": "L2",
          "addr": 4478
        },
        "L3": {
          "label": "L3",
          "addr": 4488
        },
        "L4": {
          "label": "L4",
          "addr": 4416
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const char *s) {\n  int i = 0;\n  int max = 0;\n  int len = strlen(s);\n  for (i = 0; i < len; i++) {\n    if (s[i] == '[') {\n      i++;\n      if (i > max)\n        max = i;\n    } else if (s[i] == ']') {\n      i--;\n      if (i < 0)\n        i = 0;\n      if (i > max)\n        max = i;\n    }\n  }\n  return 0;\n}"
    },
    {
      "task_id": 132,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  add    %rbx,%rax\n  jmp    115d <func0+0x3d>\n  nopl   0x0(%rax)\n  cmp    $0x5d,%sil\n  jne    114d <func0+0x2d>\n  sub    $0x1,%edx\n  jae    114d <func0+0x2d>\n  xor    %edx,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jg     117e <func0+0x5e>\n  cmp    %rdi,%rax\n  je     1188 <func0+0x68>\n  movzbl (%rdi),%esi\n  cmp    $0x5b,%sil\n  jne    1140 <func0+0x20>\n  add    $0x1,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jle    115d <func0+0x3d>\n  mov    $0x1,%eax\n  pop    %rbx\n  ret\n  nopl   (%rax)\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  add    %rbx,%rax\n  jmp    L0\n  nopl   0x0(%rax)\nL4:\n  cmp    $0x5d,%sil\n  jne    L1\n  sub    $0x1,%edx\n  jae    L1\n  xor    %edx,%edx\nL1:\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jg     L2\nL0:\n  cmp    %rdi,%rax\n  je     L3\n  movzbl (%rdi),%esi\n  cmp    $0x5b,%sil\n  jne    L4\n  add    $0x1,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jle    L0\nL2:\n  mov    $0x1,%eax\n  pop    %rbx\n  ret\n  nopl   (%rax)\nL3:\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4445
        },
        "L1": {
          "label": "L1",
          "addr": 4429
        },
        "L2": {
          "label": "L2",
          "addr": 4478
        },
        "L3": {
          "label": "L3",
          "addr": 4488
        },
        "L4": {
          "label": "L4",
          "addr": 4416
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(const char *s) {\n  int i = 0;\n  int max = 0;\n  int len = strlen(s);\n  for (i = 0; i < len; i++) {\n    if (s[i] == '[') {\n      i++;\n      if (i > max)\n        max = i;\n    } else if (s[i] == ']') {\n      i--;\n      if (i < 0)\n        i = 0;\n      if (i > max)\n        max = i;\n    }\n  }\n  return 0;\n}"
    },
    {
      "task_id": 137,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  mov    %rdi,%r13\n  mov    %rsi,%r12\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strdup@plt>\n  mov    %rax,%rbx\n  mov    %r12,%rdi\n  call   10b0 <strdup@plt>\n  mov    %rax,%rbp\n  movzbl (%rbx),%edx\n  test   %dl,%dl\n  je     11d3 <func0+0x5a>\n  mov    %rbx,%rax\n  jmp    11c9 <func0+0x50>\n  add    $0x1,%rax\n  movzbl (%rax),%edx\n  test   %dl,%dl\n  je     11d3 <func0+0x5a>\n  cmp    $0x2c,%dl\n  jne    11be <func0+0x45>\n  movb   $0x2e,(%rax)\n  jmp    11be <func0+0x45>\n  movzbl 0x0(%rbp),%edx\n  test   %dl,%dl\n  je     11f5 <func0+0x7c>\n  mov    %rbp,%rax\n  jmp    11eb <func0+0x72>\n  add    $0x1,%rax\n  movzbl (%rax),%edx\n  test   %dl,%dl\n  je     11f5 <func0+0x7c>\n  cmp    $0x2c,%dl\n  jne    11e0 <func0+0x67>\n  movb   $0x2e,(%rax)\n  jmp    11e0 <func0+0x67>\n  lea    0x10(%rsp),%rsi\n  mov    %rbx,%rdi\n  call   1090 <strtod@plt>\n  movq   %xmm0,%r14\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    126c <func0+0xf3>\n  lea    0x10(%rsp),%rsi\n  mov    %rbp,%rdi\n  call   1090 <strtod@plt>\n  movsd  %xmm0,0x8(%rsp)\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    12a0 <func0+0x127>\n  mov    %rbx,%rdi\n  call   1080 <free@plt>\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  movq   %r14,%xmm2\n  movsd  0x8(%rsp),%xmm1\n  ucomisd %xmm1,%xmm2\n  jp     1258 <func0+0xdf>\n  lea    0xdb8(%rip),%rax        # 200e <_fini+0xd4e>\n  je     1283 <func0+0x10a>\n  movq   %r14,%xmm4\n  comisd 0x8(%rsp),%xmm4\n  mov    %r12,%rax\n  cmova  %r13,%rax\n  jmp    1283 <func0+0x10a>\n  mov    %rbx,%rdi\n  call   1080 <free@plt>\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  lea    0xd7d(%rip),%rax        # 2000 <_fini+0xd40>\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12b9 <func0+0x140>\n  add    $0x20,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    %rbx,%rdi\n  call   1080 <free@plt>\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  lea    0xd49(%rip),%rax        # 2000 <_fini+0xd40>\n  jmp    1283 <func0+0x10a>\n  call   10a0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  mov    %rdi,%r13\n  mov    %rsi,%r12\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strdup@plt>\n  mov    %rax,%rbx\n  mov    %r12,%rdi\n  call   <strdup@plt>\n  mov    %rax,%rbp\n  movzbl (%rbx),%edx\n  test   %dl,%dl\n  je     L0\n  mov    %rbx,%rax\n  jmp    L1\nL2:\n  add    $0x1,%rax\n  movzbl (%rax),%edx\n  test   %dl,%dl\n  je     L0\nL1:\n  cmp    $0x2c,%dl\n  jne    L2\n  movb   $0x2e,(%rax)\n  jmp    L2\nL0:\n  movzbl 0x0(%rbp),%edx\n  test   %dl,%dl\n  je     L3\n  mov    %rbp,%rax\n  jmp    L4\nL5:\n  add    $0x1,%rax\n  movzbl (%rax),%edx\n  test   %dl,%dl\n  je     L3\nL4:\n  cmp    $0x2c,%dl\n  jne    L5\n  movb   $0x2e,(%rax)\n  jmp    L5\nL3:\n  lea    0x10(%rsp),%rsi\n  mov    %rbx,%rdi\n  call   <strtod@plt>\n  movq   %xmm0,%r14\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    L6\n  lea    0x10(%rsp),%rsi\n  mov    %rbp,%rdi\n  call   <strtod@plt>\n  movsd  %xmm0,0x8(%rsp)\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    L7\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  movq   %r14,%xmm2\n  movsd  0x8(%rsp),%xmm1\n  ucomisd %xmm1,%xmm2\n  jp     L8\n  lea    D0(%rip),%rax\n  je     L9\nL8:\n  movq   %r14,%xmm4\n  comisd 0x8(%rsp),%xmm4\n  mov    %r12,%rax\n  cmova  %r13,%rax\n  jmp    L9\nL6:\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  lea    D1(%rip),%rax\nL9:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L10\n  add    $0x20,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL7:\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  lea    D1(%rip),%rax\n  jmp    L9\nL10:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8206,
          "bias": [
            3512
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3453,
            3401
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4563
        },
        "L1": {
          "label": "L1",
          "addr": 4553
        },
        "L2": {
          "label": "L2",
          "addr": 4542
        },
        "L3": {
          "label": "L3",
          "addr": 4597
        },
        "L4": {
          "label": "L4",
          "addr": 4587
        },
        "L5": {
          "label": "L5",
          "addr": 4576
        },
        "L6": {
          "label": "L6",
          "addr": 4716
        },
        "L7": {
          "label": "L7",
          "addr": 4768
        },
        "L8": {
          "label": "L8",
          "addr": 4696
        },
        "L9": {
          "label": "L9",
          "addr": 4739
        },
        "L10": {
          "label": "L10",
          "addr": 4793
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "496e76616c696420696e707574004e6f6e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Invalid input\""
          },
          "0x200e": {
            "type": "string",
            "value": "\"None\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s1, char *s2) {\n  char *s3, *s4, *p;\n  double d1, d2;\n  s3 = strdup(s1);\n  s4 = strdup(s2);\n  for (p = s3; *p; p++)\n    if (*p == ',')\n      *p = '.';\n  for (p = s4; *p; p++)\n    if (*p == ',')\n      *p = '.';\n  d1 = strtod(s3, &p);\n  if (*p) {\n    free(s3);\n    free(s4);\n    return \"Invalid input\";\n  }\n  d2 = strtod(s4, &p);\n  if (*p) {\n    free(s3);\n    free(s4);\n    return \"Invalid input\";\n  }\n  free(s3);\n  free(s4);\n  if (d1 == d2)\n    return \"None\";\n  return d1 > d2 ? s1 : s2;\n}"
    },
    {
      "task_id": 137,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strdup@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   10b0 <strdup@plt>\n  movzbl (%r12),%edx\n  mov    %rax,%r13\n  test   %dl,%dl\n  je     11e4 <func0+0x64>\n  mov    %r12,%rax\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x2c,%dl\n  jne    11d8 <func0+0x58>\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11d0 <func0+0x50>\n  movzbl 0x0(%r13),%edx\n  test   %dl,%dl\n  je     1204 <func0+0x84>\n  mov    %r13,%rax\n  cmp    $0x2c,%dl\n  jne    11f8 <func0+0x78>\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11f0 <func0+0x70>\n  lea    0x10(%rsp),%r14\n  mov    %r12,%rdi\n  mov    %r14,%rsi\n  call   1090 <strtod@plt>\n  mov    0x10(%rsp),%rax\n  movq   %xmm0,%r15\n  cmpb   $0x0,(%rax)\n  jne    1280 <func0+0x100>\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   1090 <strtod@plt>\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    1280 <func0+0x100>\n  mov    %r12,%rdi\n  movsd  %xmm0,0x8(%rsp)\n  call   1080 <free@plt>\n  mov    %r13,%rdi\n  call   1080 <free@plt>\n  movsd  0x8(%rsp),%xmm0\n  movq   %r15,%xmm1\n  ucomisd %xmm0,%xmm1\n  jp     1268 <func0+0xe8>\n  lea    0xda8(%rip),%rax        # 200e <_fini+0xd52>\n  je     1297 <func0+0x117>\n  movq   %r15,%xmm2\n  mov    %rbx,%rax\n  comisd %xmm0,%xmm2\n  cmova  %rbp,%rax\n  jmp    1297 <func0+0x117>\n  nopw   0x0(%rax,%rax,1)\n  mov    %r12,%rdi\n  call   1080 <free@plt>\n  mov    %r13,%rdi\n  call   1080 <free@plt>\n  lea    0xd69(%rip),%rax        # 2000 <_fini+0xd44>\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12b6 <func0+0x136>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10a0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strdup@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strdup@plt>\n  movzbl (%r12),%edx\n  mov    %rax,%r13\n  test   %dl,%dl\n  je     L0\n  mov    %r12,%rax\n  nopw   0x0(%rax,%rax,1)\nL2:\n  cmp    $0x2c,%dl\n  jne    L1\n  movb   $0x2e,(%rax)\nL1:\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L2\nL0:\n  movzbl 0x0(%r13),%edx\n  test   %dl,%dl\n  je     L3\n  mov    %r13,%rax\nL5:\n  cmp    $0x2c,%dl\n  jne    L4\n  movb   $0x2e,(%rax)\nL4:\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L5\nL3:\n  lea    0x10(%rsp),%r14\n  mov    %r12,%rdi\n  mov    %r14,%rsi\n  call   <strtod@plt>\n  mov    0x10(%rsp),%rax\n  movq   %xmm0,%r15\n  cmpb   $0x0,(%rax)\n  jne    L6\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   <strtod@plt>\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    L6\n  mov    %r12,%rdi\n  movsd  %xmm0,0x8(%rsp)\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  movsd  0x8(%rsp),%xmm0\n  movq   %r15,%xmm1\n  ucomisd %xmm0,%xmm1\n  jp     L7\n  lea    D0(%rip),%rax\n  je     L8\nL7:\n  movq   %r15,%xmm2\n  mov    %rbx,%rax\n  comisd %xmm0,%xmm2\n  cmova  %rbp,%rax\n  jmp    L8\n  nopw   0x0(%rax,%rax,1)\nL6:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  lea    D1(%rip),%rax\nL8:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L9\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL9:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8206,
          "bias": [
            3496
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3433
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4580
        },
        "L1": {
          "label": "L1",
          "addr": 4568
        },
        "L2": {
          "label": "L2",
          "addr": 4560
        },
        "L3": {
          "label": "L3",
          "addr": 4612
        },
        "L4": {
          "label": "L4",
          "addr": 4600
        },
        "L5": {
          "label": "L5",
          "addr": 4592
        },
        "L6": {
          "label": "L6",
          "addr": 4736
        },
        "L7": {
          "label": "L7",
          "addr": 4712
        },
        "L8": {
          "label": "L8",
          "addr": 4759
        },
        "L9": {
          "label": "L9",
          "addr": 4790
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "496e76616c696420696e707574004e6f6e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Invalid input\""
          },
          "0x200e": {
            "type": "string",
            "value": "\"None\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s1, char *s2) {\n  char *s3, *s4, *p;\n  double d1, d2;\n  s3 = strdup(s1);\n  s4 = strdup(s2);\n  for (p = s3; *p; p++)\n    if (*p == ',')\n      *p = '.';\n  for (p = s4; *p; p++)\n    if (*p == ',')\n      *p = '.';\n  d1 = strtod(s3, &p);\n  if (*p) {\n    free(s3);\n    free(s4);\n    return \"Invalid input\";\n  }\n  d2 = strtod(s4, &p);\n  if (*p) {\n    free(s3);\n    free(s4);\n    return \"Invalid input\";\n  }\n  free(s3);\n  free(s4);\n  if (d1 == d2)\n    return \"None\";\n  return d1 > d2 ? s1 : s2;\n}"
    },
    {
      "task_id": 142,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    11e9 <func0+0xf0>\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  test   %eax,%eax\n  jne    1175 <func0+0x7c>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %edx,%eax\n  add    %eax,-0x8(%rbp)\n  jmp    11e5 <func0+0xec>\n  mov    -0x4(%rbp),%eax\n  and    $0x3,%eax\n  test   %eax,%eax\n  jne    11cc <func0+0xd3>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %eax,%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %edx,%eax\n  add    %eax,-0x8(%rbp)\n  jmp    11e5 <func0+0xec>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111b <func0+0x22>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL4:\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %edx,%eax\n  add    %eax,-0x8(%rbp)\n  jmp    L2\nL1:\n  mov    -0x4(%rbp),%eax\n  and    $0x3,%eax\n  test   %eax,%eax\n  jne    L3\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %eax,%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %edx,%eax\n  add    %eax,-0x8(%rbp)\n  jmp    L2\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\nL2:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4585
        },
        "L1": {
          "label": "L1",
          "addr": 4469
        },
        "L2": {
          "label": "L2",
          "addr": 4581
        },
        "L3": {
          "label": "L3",
          "addr": 4556
        },
        "L4": {
          "label": "L4",
          "addr": 4379
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int c) {\n  int result = 0;\n  for (int i = 0; i < c; ++i) {\n    if (i % 3 == 0) {\n      result += x[i] * x[i];\n    } else if (i % 4 == 0) {\n      result += x[i] * x[i] * x[i];\n    } else {\n      result += x[i];\n    }\n  }\n  return result;\n}"
    },
    {
      "task_id": 125,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
      "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x78,%rsp\n  mov    %rdi,%r12\n  mov    %rsi,%r14\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strlen@plt>\n  mov    %rax,%rbp\n  movq   $0x0,(%rsp)\n  movq   $0x0,0x8(%rsp)\n  movq   $0x0,0x10(%rsp)\n  movq   $0x0,0x18(%rsp)\n  movq   $0x0,0x20(%rsp)\n  movq   $0x0,0x28(%rsp)\n  movq   $0x0,0x30(%rsp)\n  movq   $0x0,0x38(%rsp)\n  movq   $0x0,0x40(%rsp)\n  movq   $0x0,0x48(%rsp)\n  movq   $0x0,0x50(%rsp)\n  movq   $0x0,0x58(%rsp)\n  movl   $0x0,0x60(%rsp)\n  movb   $0x0,0x64(%rsp)\n  mov    $0x20,%esi\n  mov    %r12,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  je     12c6 <func0+0xed>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rax,%r13\n  test   %ebp,%ebp\n  js     13e6 <func0+0x20d>\n  mov    %r12,%rbx\n  mov    %ebp,%ebp\n  lea    0x1(%r12,%rbp,1),%r12\n  mov    $0x0,%ebp\n  mov    $0x0,%edx\n  mov    %rsp,%r15\n  jmp    1310 <func0+0x137>\n  mov    $0x2c,%esi\n  mov    %r12,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  jne    1293 <func0+0xba>\n  mov    $0x0,%ebx\n  test   %ebp,%ebp\n  jle    1380 <func0+0x1a7>\n  call   1100 <__ctype_b_loc@plt>\n  mov    (%rax),%rdi\n  mov    %r12,%rdx\n  lea    -0x1(%rbp),%eax\n  lea    0x1(%r12,%rax,1),%rsi\n  mov    $0x0,%ebx\n  jmp    1353 <func0+0x17a>\n  test   %edx,%edx\n  jg     1326 <func0+0x14d>\n  add    $0x1,%rbx\n  cmp    %r12,%rbx\n  je     13c1 <func0+0x1e8>\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     12ff <func0+0x126>\n  cmp    $0x2c,%al\n  je     12ff <func0+0x126>\n  movslq %edx,%rcx\n  mov    %al,(%rsp,%rcx,1)\n  lea    0x1(%rdx),%edx\n  jmp    1303 <func0+0x12a>\n  movslq %edx,%rdx\n  movb   $0x0,(%rsp,%rdx,1)\n  mov    %r15,%rdi\n  call   10f0 <strdup@plt>\n  mov    %rax,%rdx\n  movslq %ebp,%rax\n  mov    %rdx,0x0(%r13,%rax,8)\n  add    $0x1,%ebp\n  mov    $0x0,%edx\n  jmp    1303 <func0+0x12a>\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  je     1380 <func0+0x1a7>\n  movzbl (%rdx),%eax\n  movsbq %al,%rcx\n  testb  $0x2,0x1(%rdi,%rcx,2)\n  je     134a <func0+0x171>\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebx\n  jmp    134a <func0+0x171>\n  mov    $0x8,%edi\n  call   10e0 <malloc@plt>\n  mov    %rax,%r13\n  mov    $0xc,%edi\n  call   10e0 <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13)\n  mov    %ebx,%r8d\n  lea    0xc58(%rip),%rcx        # 2000 <_fini+0xc0c>\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%eax\n  call   1110 <__sprintf_chk@plt>\n  mov    $0x1,%ebp\n  mov    %ebp,(%r14)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    13ed <func0+0x214>\n  mov    %r13,%rax\n  add    $0x78,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    $0x0,%ebp\n  jmp    13c1 <func0+0x1e8>\n  call   10c0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x78,%rsp\n  mov    %rdi,%r12\n  mov    %rsi,%r14\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  movq   $0x0,(%rsp)\n  movq   $0x0,0x8(%rsp)\n  movq   $0x0,0x10(%rsp)\n  movq   $0x0,0x18(%rsp)\n  movq   $0x0,0x20(%rsp)\n  movq   $0x0,0x28(%rsp)\n  movq   $0x0,0x30(%rsp)\n  movq   $0x0,0x38(%rsp)\n  movq   $0x0,0x40(%rsp)\n  movq   $0x0,0x48(%rsp)\n  movq   $0x0,0x50(%rsp)\n  movq   $0x0,0x58(%rsp)\n  movl   $0x0,0x60(%rsp)\n  movb   $0x0,0x64(%rsp)\n  mov    $0x20,%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L0\nL3:\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %ebp,%ebp\n  js     L1\n  mov    %r12,%rbx\n  mov    %ebp,%ebp\n  lea    0x1(%r12,%rbp,1),%r12\n  mov    $0x0,%ebp\n  mov    $0x0,%edx\n  mov    %rsp,%r15\n  jmp    L2\nL0:\n  mov    $0x2c,%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L3\n  mov    $0x0,%ebx\n  test   %ebp,%ebp\n  jle    L4\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdi\n  mov    %r12,%rdx\n  lea    -0x1(%rbp),%eax\n  lea    0x1(%r12,%rax,1),%rsi\n  mov    $0x0,%ebx\n  jmp    L5\nL8:\n  test   %edx,%edx\n  jg     L6\nL9:\n  add    $0x1,%rbx\n  cmp    %r12,%rbx\n  je     L7\nL2:\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     L8\n  cmp    $0x2c,%al\n  je     L8\n  movslq %edx,%rcx\n  mov    %al,(%rsp,%rcx,1)\n  lea    0x1(%rdx),%edx\n  jmp    L9\nL6:\n  movslq %edx,%rdx\n  movb   $0x0,(%rsp,%rdx,1)\n  mov    %r15,%rdi\n  call   <strdup@plt>\n  mov    %rax,%rdx\n  movslq %ebp,%rax\n  mov    %rdx,0x0(%r13,%rax,8)\n  add    $0x1,%ebp\n  mov    $0x0,%edx\n  jmp    L9\nL10:\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  je     L4\nL5:\n  movzbl (%rdx),%eax\n  movsbq %al,%rcx\n  testb  $0x2,0x1(%rdi,%rcx,2)\n  je     L10\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebx\n  jmp    L10\nL4:\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  mov    $0xc,%edi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13)\n  mov    %ebx,%r8d\n  lea    D0(%rip),%rcx\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\n  mov    $0x1,%ebp\nL7:\n  mov    %ebp,(%r14)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L11\n  mov    %r13,%rax\n  add    $0x78,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL1:\n  mov    $0x0,%ebp\n  jmp    L7\nL11:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3160
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4806
        },
        "L1": {
          "label": "L1",
          "addr": 5094
        },
        "L2": {
          "label": "L2",
          "addr": 4880
        },
        "L3": {
          "label": "L3",
          "addr": 4755
        },
        "L4": {
          "label": "L4",
          "addr": 4992
        },
        "L5": {
          "label": "L5",
          "addr": 4947
        },
        "L6": {
          "label": "L6",
          "addr": 4902
        },
        "L7": {
          "label": "L7",
          "addr": 5057
        },
        "L8": {
          "label": "L8",
          "addr": 4863
        },
        "L9": {
          "label": "L9",
          "addr": 4867
        },
        "L10": {
          "label": "L10",
          "addr": 4938
        },
        "L11": {
          "label": "L11",
          "addr": 5101
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " char **func0(char *str, int *len) {\n  int i = 0;\n  int j = 0;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u = 0;\n  int v = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n  char **ret;\n  char *pstr;\n  char *buf;\n  char *pbuf;\n  char *p1;\n  char *p2;\n  char *p3;\n  char *p4;\n  char *p5;\n  char *p6;\n  char *p7;\n  char *p8;\n  char *p9;\n  char *p10;\n  char *p11;\n  char *p12;\n  char *p13;\n  char *p14;\n  char *p15;\n  char *p16;\n  char *p17;\n  char *p18;\n  char *p19;\n  char *p20;\n  char *p21;\n  char *p22;\n  char *p23;\n  char *p24;\n  char *p25;\n  char *p26;\n  char *p27;\n  char *p28;\n  char *p29;\n  char *p30;\n  char *p31;\n  char *p32;\n  char *p33;\n  char *p34;\n  char *p35;\n  char *p36;\n  char *p37;\n  char *p38;\n  char *p39;\n  char *p40;\n  char *p41;\n  char *p42;\n  char *p43;\n  char *p44;\n  char *p45;\n  char *p46;\n  char *p47;\n  char *p48;\n  char *p49;\n  char *p50;\n  char *p51;\n  char *p52;\n  char *p53;\n  char *p54;\n  char *p55;\n  char *p56;\n  char *p57;\n  char *p58;\n  char *p59;\n  char *p60;\n  char *p61;\n  char *p62;\n  char *p63;\n  char *p64;\n  char *p65;\n  char *p66;\n  char *p67;\n  char *p68;\n  char *p69;\n  char *p70;\n  char *p71;\n  char *p72;\n  char *p73;\n  char *p74;\n  char *p75;\n  char *p76;\n  char *p77;\n  char *p78;\n  char *p79;\n  char *p80;\n  char *p81;\n  char *p82;\n  char *p83;\n  char *p84;\n  char *p85;\n  char *p86;\n  char *p87;\n  char *p88;\n  char *p89;\n  char *p90;\n  char *p91;\n  char *p92;\n  char *p93;\n  char *p94;\n  char *p95;\n  char *p96;\n  char *p97;\n  char *p98;\n  char *p99;\n  char *p100;\n  char *p101;\n  char *p102;\n  char *p103;\n  char *p104;\n  char *p105;\n  char *p106;\n  char *p107;\n  char"
    },
    {
      "task_id": 137,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strdup@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x50(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strdup@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  jmp    11ed <func0+0x74>\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    11e9 <func0+0x70>\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2e,(%rax)\n  addl   $0x1,-0x38(%rbp)\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11c5 <func0+0x4c>\n  movl   $0x0,-0x34(%rbp)\n  jmp    1232 <func0+0xb9>\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    122e <func0+0xb5>\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2e,(%rax)\n  addl   $0x1,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    120a <func0+0x91>\n  lea    -0x30(%rbp),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strtod@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x18(%rbp)\n  mov    -0x30(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     1291 <func0+0x118>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  lea    0xd74(%rip),%rax        # 2000 <_fini+0xcc0>\n  jmp    1328 <func0+0x1af>\n  lea    -0x30(%rbp),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strtod@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x30(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     12d9 <func0+0x160>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  lea    0xd29(%rip),%rax        # 2000 <_fini+0xcc0>\n  jmp    1328 <func0+0x1af>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  movsd  -0x18(%rbp),%xmm0\n  ucomisd -0x10(%rbp),%xmm0\n  jp     1312 <func0+0x199>\n  movsd  -0x18(%rbp),%xmm0\n  ucomisd -0x10(%rbp),%xmm0\n  jne    1312 <func0+0x199>\n  lea    0xcfe(%rip),%rax        # 200e <_fini+0xcce>\n  jmp    1328 <func0+0x1af>\n  movsd  -0x18(%rbp),%xmm0\n  comisd -0x10(%rbp),%xmm0\n  jbe    1324 <func0+0x1ab>\n  mov    -0x48(%rbp),%rax\n  jmp    1328 <func0+0x1af>\n  mov    -0x50(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     133c <func0+0x1c3>\n  call   10a0 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x50(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  jmp    L0\nL2:\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    L1\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2e,(%rax)\nL1:\n  addl   $0x1,-0x38(%rbp)\nL0:\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\n  movl   $0x0,-0x34(%rbp)\n  jmp    L3\nL5:\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    L4\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2e,(%rax)\nL4:\n  addl   $0x1,-0x34(%rbp)\nL3:\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L5\n  lea    -0x30(%rbp),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strtod@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x18(%rbp)\n  mov    -0x30(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L6\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  lea    D0(%rip),%rax\n  jmp    L7\nL6:\n  lea    -0x30(%rbp),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strtod@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x30(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L8\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  lea    D0(%rip),%rax\n  jmp    L7\nL8:\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  movsd  -0x18(%rbp),%xmm0\n  ucomisd -0x10(%rbp),%xmm0\n  jp     L9\n  movsd  -0x18(%rbp),%xmm0\n  ucomisd -0x10(%rbp),%xmm0\n  jne    L9\n  lea    D1(%rip),%rax\n  jmp    L7\nL9:\n  movsd  -0x18(%rbp),%xmm0\n  comisd -0x10(%rbp),%xmm0\n  jbe    L10\n  mov    -0x48(%rbp),%rax\n  jmp    L7\nL10:\n  mov    -0x50(%rbp),%rax\nL7:\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L11\n  call   <__stack_chk_fail@plt>\nL11:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3444,
            3369
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8206,
          "bias": [
            3326
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4589
        },
        "L1": {
          "label": "L1",
          "addr": 4585
        },
        "L2": {
          "label": "L2",
          "addr": 4549
        },
        "L3": {
          "label": "L3",
          "addr": 4658
        },
        "L4": {
          "label": "L4",
          "addr": 4654
        },
        "L5": {
          "label": "L5",
          "addr": 4618
        },
        "L6": {
          "label": "L6",
          "addr": 4753
        },
        "L7": {
          "label": "L7",
          "addr": 4904
        },
        "L8": {
          "label": "L8",
          "addr": 4825
        },
        "L9": {
          "label": "L9",
          "addr": 4882
        },
        "L10": {
          "label": "L10",
          "addr": 4900
        },
        "L11": {
          "label": "L11",
          "addr": 4924
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "496e76616c696420696e707574004e6f6e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Invalid input\""
          },
          "0x200e": {
            "type": "string",
            "value": "\"None\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *l, char *r) {\n  char *s, *t;\n  char *endptr;\n  double dl, dr;\n  int i, j;\n  s = strdup(l);\n  t = strdup(r);\n  for (i = 0; s[i] != '\\0'; i++)\n    if (s[i] == ',')\n      s[i] = '.';\n  for (j = 0; t[j] != '\\0'; j++)\n    if (t[j] == ',')\n      t[j] = '.';\n  dl = strtod(s, &endptr);\n  if (*endptr != '\\0') {\n    free(s);\n    free(t);\n    return \"Invalid input\";\n  }\n  dr = strtod(t, &endptr);\n  if (*endptr != '\\0') {\n    free(s);\n    free(t);\n    return \"Invalid input\";\n  }\n  free(s);\n  free(t);\n  if (dl == dr)\n    return \"None\";\n  else if (dl > dr)\n    return l;\n  else\n    return r;\n}"
    },
    {
      "task_id": 142,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  test   %esi,%esi\n  jle    115b <func0+0x62>\n  mov    %esi,%esi\n  mov    $0x0,%edx\n  mov    $0x0,%ecx\n  jmp    112e <func0+0x35>\n  test   $0x3,%dl\n  jne    1155 <func0+0x5c>\n  mov    (%r8,%rdx,4),%edi\n  mov    %edi,%eax\n  imul   %edi,%eax\n  imul   %edi,%eax\n  add    %eax,%ecx\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  je     1160 <func0+0x67>\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  lea    (%rax,%rax,2),%eax\n  cmp    %edx,%eax\n  jne    1112 <func0+0x19>\n  mov    (%r8,%rdx,4),%eax\n  imul   %eax,%eax\n  add    %eax,%ecx\n  jmp    1125 <func0+0x2c>\n  add    (%r8,%rdx,4),%ecx\n  jmp    1125 <func0+0x2c>\n  mov    $0x0,%ecx\n  mov    %ecx,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%esi\n  mov    $0x0,%edx\n  mov    $0x0,%ecx\n  jmp    L1\nL4:\n  test   $0x3,%dl\n  jne    L2\n  mov    (%r8,%rdx,4),%edi\n  mov    %edi,%eax\n  imul   %edi,%eax\n  imul   %edi,%eax\n  add    %eax,%ecx\nL5:\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  je     L3\nL1:\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  lea    (%rax,%rax,2),%eax\n  cmp    %edx,%eax\n  jne    L4\n  mov    (%r8,%rdx,4),%eax\n  imul   %eax,%eax\n  add    %eax,%ecx\n  jmp    L5\nL2:\n  add    (%r8,%rdx,4),%ecx\n  jmp    L5\nL0:\n  mov    $0x0,%ecx\nL3:\n  mov    %ecx,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4443
        },
        "L1": {
          "label": "L1",
          "addr": 4398
        },
        "L2": {
          "label": "L2",
          "addr": 4437
        },
        "L3": {
          "label": "L3",
          "addr": 4448
        },
        "L4": {
          "label": "L4",
          "addr": 4370
        },
        "L5": {
          "label": "L5",
          "addr": 4389
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *x, int c) {\n  int result = 0;\n  int i;\n  for (i = 0; i < c; ++i) {\n    if (i % 3 == 0) {\n      result += x[i] * x[i] * x[i];\n    } else if (i % 4 == 0) {\n      result += x[i] * x[i];\n    } else {\n      result += x[i];\n    }\n  }\n  return result;\n}"
    },
    {
      "task_id": 142,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1160 <func0+0x60>\n  movslq %esi,%rsi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  jmp    1127 <func0+0x27>\n  nopw   0x0(%rax,%rax,1)\n  imul   %edx,%edx\n  add    %edx,%r8d\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     1150 <func0+0x50>\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  mov    (%rdi,%rax,4),%edx\n  jbe    1118 <func0+0x18>\n  test   $0x3,%al\n  jne    1158 <func0+0x58>\n  mov    %edx,%ecx\n  add    $0x1,%rax\n  imul   %edx,%ecx\n  imul   %ecx,%edx\n  add    %edx,%r8d\n  cmp    %rsi,%rax\n  jne    1127 <func0+0x27>\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\n  add    %edx,%r8d\n  jmp    111e <func0+0x1e>\n  nopl   (%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rsi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  imul   %edx,%edx\n  add    %edx,%r8d\nL5:\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     L2\nL1:\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  mov    (%rdi,%rax,4),%edx\n  jbe    L3\n  test   $0x3,%al\n  jne    L4\n  mov    %edx,%ecx\n  add    $0x1,%rax\n  imul   %edx,%ecx\n  imul   %ecx,%edx\n  add    %edx,%r8d\n  cmp    %rsi,%rax\n  jne    L1\nL2:\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\nL4:\n  add    %edx,%r8d\n  jmp    L5\n  nopl   (%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4448
        },
        "L1": {
          "label": "L1",
          "addr": 4391
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4376
        },
        "L4": {
          "label": "L4",
          "addr": 4440
        },
        "L5": {
          "label": "L5",
          "addr": 4382
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int sum = 0;\n  for (int i = 0; i < len; i++) {\n    if (i % 3 == 0) {\n      sum += arr[i] * arr[i] * arr[i];\n    } else if (i % 4 == 0) {\n      sum += arr[i] * arr[i];\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}"
    },
    {
      "task_id": 140,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %rsi,%r13\n  mov    $0x0,%ebp\n  mov    $0x0,%ebx\n  mov    $0x0,%r14d\n  jmp    1178 <func0+0x5f>\n  add    $0x1,%r14d\n  jmp    1174 <func0+0x5b>\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    115f <func0+0x46>\n  jle    11b2 <func0+0x99>\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x2d,0x0(%r13,%rbx,1)\n  lea    0x1(%rax),%ebx\n  movzbl (%r12,%rbp,1),%edx\n  cltq\n  mov    %dl,0x0(%r13,%rax,1)\n  mov    $0x0,%r14d\n  add    $0x1,%rbp\n  mov    %r12,%rdi\n  call   1050 <strlen@plt>\n  cmp    %rbp,%rax\n  jbe    11b6 <func0+0x9d>\n  cmpb   $0x20,(%r12,%rbp,1)\n  je     113d <func0+0x24>\n  cmp    $0x1,%r14d\n  je     1143 <func0+0x2a>\n  cmp    $0x2,%r14d\n  jne    1151 <func0+0x38>\n  movslq %ebx,%rax\n  movb   $0x5f,0x0(%r13,%rax,1)\n  lea    0x2(%rbx),%eax\n  add    $0x1,%ebx\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    115f <func0+0x46>\n  mov    %ebx,%eax\n  jmp    115f <func0+0x46>\n  cmp    $0x1,%r14d\n  je     11dc <func0+0xc3>\n  cmp    $0x2,%r14d\n  jne    11ea <func0+0xd1>\n  movslq %ebx,%rax\n  movb   $0x5f,0x0(%r13,%rax,1)\n  lea    0x2(%rbx),%eax\n  add    $0x1,%ebx\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    11f8 <func0+0xdf>\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    11f8 <func0+0xdf>\n  jle    1209 <func0+0xf0>\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x2d,0x0(%r13,%rbx,1)\n  cltq\n  movb   $0x0,0x0(%r13,%rax,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    %ebx,%eax\n  jmp    11f8 <func0+0xdf>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %rsi,%r13\n  mov    $0x0,%ebp\n  mov    $0x0,%ebx\n  mov    $0x0,%r14d\n  jmp    L0\nL5:\n  add    $0x1,%r14d\n  jmp    L1\nL6:\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    L2\nL7:\n  jle    L3\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x2d,0x0(%r13,%rbx,1)\nL2:\n  lea    0x1(%rax),%ebx\n  movzbl (%r12,%rbp,1),%edx\n  cltq\n  mov    %dl,0x0(%r13,%rax,1)\n  mov    $0x0,%r14d\nL1:\n  add    $0x1,%rbp\nL0:\n  mov    %r12,%rdi\n  call   <strlen@plt>\n  cmp    %rbp,%rax\n  jbe    L4\n  cmpb   $0x20,(%r12,%rbp,1)\n  je     L5\n  cmp    $0x1,%r14d\n  je     L6\n  cmp    $0x2,%r14d\n  jne    L7\n  movslq %ebx,%rax\n  movb   $0x5f,0x0(%r13,%rax,1)\n  lea    0x2(%rbx),%eax\n  add    $0x1,%ebx\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    L2\nL3:\n  mov    %ebx,%eax\n  jmp    L2\nL4:\n  cmp    $0x1,%r14d\n  je     L8\n  cmp    $0x2,%r14d\n  jne    L9\n  movslq %ebx,%rax\n  movb   $0x5f,0x0(%r13,%rax,1)\n  lea    0x2(%rbx),%eax\n  add    $0x1,%ebx\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    L10\nL8:\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    L10\nL9:\n  jle    L11\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x2d,0x0(%r13,%rbx,1)\nL10:\n  cltq\n  movb   $0x0,0x0(%r13,%rax,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL11:\n  mov    %ebx,%eax\n  jmp    L10",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4472
        },
        "L1": {
          "label": "L1",
          "addr": 4468
        },
        "L2": {
          "label": "L2",
          "addr": 4447
        },
        "L3": {
          "label": "L3",
          "addr": 4530
        },
        "L4": {
          "label": "L4",
          "addr": 4534
        },
        "L5": {
          "label": "L5",
          "addr": 4413
        },
        "L6": {
          "label": "L6",
          "addr": 4419
        },
        "L7": {
          "label": "L7",
          "addr": 4433
        },
        "L8": {
          "label": "L8",
          "addr": 4572
        },
        "L9": {
          "label": "L9",
          "addr": 4586
        },
        "L10": {
          "label": "L10",
          "addr": 4600
        },
        "L11": {
          "label": "L11",
          "addr": 4617
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s, char *t) {\n  int i = 0, j = 0, k = 0;\n  for (i = 0; i < strlen(s); i++) {\n    if (s[i] == ' ')\n      k++;\n    else {\n      if (k == 1)\n        t[j++] = '_';\n      else if (k == 2) {\n        t[j++] = '_';\n        t[j++] = '_';\n      } else if (k > 2)\n        t[j++] = '-';\n      t[j++] = s[i];\n      k = 0;\n    }\n  }\n  if (k == 1)\n    t[j++] = '_';\n  else if (k == 2) {\n    t[j++] = '_';\n    t[j++] = '_';\n  } else if (k > 2)\n    t[j++] = '-';\n  t[j] = '\\0';\n}"
    },
    {
      "task_id": 140,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x8,%rsp\n  jmp    1181 <func0+0x61>\n  nopl   (%rax)\n  lea    0x1(%r12),%eax\n  cmp    $0x1,%r13d\n  je     11b0 <func0+0x90>\n  cmp    $0x2,%r13d\n  jne    11a0 <func0+0x80>\n  cltq\n  movb   $0x5f,(%rdx)\n  movb   $0x5f,(%r14,%rax,1)\n  lea    0x2(%r12),%eax\n  movzbl 0x0(%rbp,%rbx,1),%edx\n  lea    0x1(%rax),%r12d\n  cltq\n  xor    %r13d,%r13d\n  movslq %r12d,%r15\n  mov    %dl,(%r14,%rax,1)\n  add    $0x1,%rbx\n  mov    %rbp,%rdi\n  call   1050 <strlen@plt>\n  lea    (%r14,%r15,1),%rdx\n  cmp    %rbx,%rax\n  jbe    11b8 <func0+0x98>\n  cmpb   $0x20,0x0(%rbp,%rbx,1)\n  jne    1148 <func0+0x28>\n  add    $0x1,%r13d\n  jmp    117d <func0+0x5d>\n  nop\n  jle    120c <func0+0xec>\n  movb   $0x2d,(%rdx)\n  jmp    1168 <func0+0x48>\n  nopw   0x0(%rax,%rax,1)\n  movb   $0x5f,(%rdx)\n  jmp    1168 <func0+0x48>\n  nopl   (%rax)\n  cmp    $0x1,%r13d\n  je     1200 <func0+0xe0>\n  cmp    $0x2,%r13d\n  jne    11e0 <func0+0xc0>\n  lea    0x1(%r12),%eax\n  add    $0x2,%r12d\n  movb   $0x5f,(%rdx)\n  cltq\n  movslq %r12d,%r15\n  movb   $0x5f,(%r14,%rax,1)\n  jmp    11ec <func0+0xcc>\n  nopl   0x0(%rax)\n  jle    11ec <func0+0xcc>\n  movb   $0x2d,(%rdx)\n  add    $0x1,%r12d\n  movslq %r12d,%r15\n  movb   $0x0,(%r14,%r15,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  add    $0x1,%r12d\n  movb   $0x5f,(%rdx)\n  movslq %r12d,%r15\n  jmp    11ec <func0+0xcc>\n  mov    %r12d,%eax\n  jmp    1168 <func0+0x48>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x8,%rsp\n  jmp    L0\n  nopl   (%rax)\nL4:\n  lea    0x1(%r12),%eax\n  cmp    $0x1,%r13d\n  je     L1\n  cmp    $0x2,%r13d\n  jne    L2\n  cltq\n  movb   $0x5f,(%rdx)\n  movb   $0x5f,(%r14,%rax,1)\n  lea    0x2(%r12),%eax\nL7:\n  movzbl 0x0(%rbp,%rbx,1),%edx\n  lea    0x1(%rax),%r12d\n  cltq\n  xor    %r13d,%r13d\n  movslq %r12d,%r15\n  mov    %dl,(%r14,%rax,1)\nL5:\n  add    $0x1,%rbx\nL0:\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  lea    (%r14,%r15,1),%rdx\n  cmp    %rbx,%rax\n  jbe    L3\n  cmpb   $0x20,0x0(%rbp,%rbx,1)\n  jne    L4\n  add    $0x1,%r13d\n  jmp    L5\n  nop\nL2:\n  jle    L6\n  movb   $0x2d,(%rdx)\n  jmp    L7\n  nopw   0x0(%rax,%rax,1)\nL1:\n  movb   $0x5f,(%rdx)\n  jmp    L7\n  nopl   (%rax)\nL3:\n  cmp    $0x1,%r13d\n  je     L8\n  cmp    $0x2,%r13d\n  jne    L9\n  lea    0x1(%r12),%eax\n  add    $0x2,%r12d\n  movb   $0x5f,(%rdx)\n  cltq\n  movslq %r12d,%r15\n  movb   $0x5f,(%r14,%rax,1)\n  jmp    L10\n  nopl   0x0(%rax)\nL9:\n  jle    L10\n  movb   $0x2d,(%rdx)\n  add    $0x1,%r12d\n  movslq %r12d,%r15\nL10:\n  movb   $0x0,(%r14,%r15,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  add    $0x1,%r12d\n  movb   $0x5f,(%rdx)\n  movslq %r12d,%r15\n  jmp    L10\nL6:\n  mov    %r12d,%eax\n  jmp    L7",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4481
        },
        "L1": {
          "label": "L1",
          "addr": 4528
        },
        "L2": {
          "label": "L2",
          "addr": 4512
        },
        "L3": {
          "label": "L3",
          "addr": 4536
        },
        "L4": {
          "label": "L4",
          "addr": 4424
        },
        "L5": {
          "label": "L5",
          "addr": 4477
        },
        "L6": {
          "label": "L6",
          "addr": 4620
        },
        "L7": {
          "label": "L7",
          "addr": 4456
        },
        "L8": {
          "label": "L8",
          "addr": 4608
        },
        "L9": {
          "label": "L9",
          "addr": 4576
        },
        "L10": {
          "label": "L10",
          "addr": 4588
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s, char *t) {\n  int i = 0, j = 0, k = 0, n = 0;\n  for (i = 0; i < strlen(s); i++) {\n    if (s[i] == ' ') {\n      n++;\n    } else {\n      if (n == 1) {\n        t[j++] = '_';\n      } else if (n == 2) {\n        t[j++] = '_';\n        t[j++] = '_';\n      } else if (n > 0) {\n        t[j++] = '-';\n      }\n      t[j++] = s[i];\n      n = 0;\n    }\n  }\n  if (n == 1) {\n    t[j++] = '_';\n  } else if (n == 2) {\n    t[j++] = '_';\n    t[j++] = '_';\n  } else if (n > 0) {\n    t[j++] = '-';\n  }\n  t[j] = '\\0';\n}"
    },
    {
      "task_id": 140,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    1200 <func0+0xe7>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  jne    1165 <func0+0x4c>\n  addl   $0x1,-0x1c(%rbp)\n  jmp    11fc <func0+0xe3>\n  cmpl   $0x1,-0x1c(%rbp)\n  jne    1181 <func0+0x68>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  cmpl   $0x2,-0x1c(%rbp)\n  jne    11b3 <func0+0x9a>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  cmpl   $0x2,-0x1c(%rbp)\n  jle    11cf <func0+0xb6>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2d,(%rax)\n  movl   $0x0,-0x1c(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     1148 <func0+0x2f>\n  cmpl   $0x1,-0x1c(%rbp)\n  jne    1237 <func0+0x11e>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  cmpl   $0x2,-0x1c(%rbp)\n  jne    1269 <func0+0x150>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  cmpl   $0x2,-0x1c(%rbp)\n  jle    1285 <func0+0x16c>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2d,(%rax)\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL6:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  jne    L1\n  addl   $0x1,-0x1c(%rbp)\n  jmp    L2\nL1:\n  cmpl   $0x1,-0x1c(%rbp)\n  jne    L3\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\nL3:\n  cmpl   $0x2,-0x1c(%rbp)\n  jne    L4\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\nL4:\n  cmpl   $0x2,-0x1c(%rbp)\n  jle    L5\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2d,(%rax)\nL5:\n  movl   $0x0,-0x1c(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\nL2:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L6\n  cmpl   $0x1,-0x1c(%rbp)\n  jne    L7\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\nL7:\n  cmpl   $0x2,-0x1c(%rbp)\n  jne    L8\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\nL8:\n  cmpl   $0x2,-0x1c(%rbp)\n  jle    L9\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2d,(%rax)\nL9:\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4608
        },
        "L1": {
          "label": "L1",
          "addr": 4453
        },
        "L2": {
          "label": "L2",
          "addr": 4604
        },
        "L3": {
          "label": "L3",
          "addr": 4481
        },
        "L4": {
          "label": "L4",
          "addr": 4531
        },
        "L5": {
          "label": "L5",
          "addr": 4559
        },
        "L6": {
          "label": "L6",
          "addr": 4424
        },
        "L7": {
          "label": "L7",
          "addr": 4663
        },
        "L8": {
          "label": "L8",
          "addr": 4713
        },
        "L9": {
          "label": "L9",
          "addr": 4741
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *p, char *q) {\n  int i = 0;\n  int j = 0;\n  for (int k = 0; k < strlen(p); k++) {\n    if (p[k] == ' ') {\n      i++;\n    } else {\n      if (i == 1) {\n        q[j++] = '_';\n      }\n      if (i == 2) {\n        q[j++] = '_';\n        q[j++] = '_';\n      }\n      if (i >= 3) {\n        q[j++] = '-';\n      }\n      i = 0;\n      q[j++] = p[k];\n    }\n  }\n  if (i == 1) {\n    q[j++] = '_';\n  }\n  if (i == 2) {\n    q[j++] = '_';\n    q[j++] = '_';\n  }\n  if (i >= 3) {\n    q[j++] = '-';\n  }\n  q[j] = '\\0';\n}"
    },
    {
      "task_id": 140,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x8,%rsp\n  jmp    1181 <func0+0x61>\n  nopl   (%rax)\n  lea    0x1(%r12),%eax\n  cmp    $0x1,%r13d\n  je     11b0 <func0+0x90>\n  cmp    $0x2,%r13d\n  jne    11a0 <func0+0x80>\n  cltq\n  movb   $0x5f,(%rdx)\n  movb   $0x5f,(%r14,%rax,1)\n  lea    0x2(%r12),%eax\n  movzbl 0x0(%rbp,%rbx,1),%edx\n  lea    0x1(%rax),%r12d\n  cltq\n  xor    %r13d,%r13d\n  movslq %r12d,%r15\n  mov    %dl,(%r14,%rax,1)\n  add    $0x1,%rbx\n  mov    %rbp,%rdi\n  call   1050 <strlen@plt>\n  lea    (%r14,%r15,1),%rdx\n  cmp    %rbx,%rax\n  jbe    11b8 <func0+0x98>\n  cmpb   $0x20,0x0(%rbp,%rbx,1)\n  jne    1148 <func0+0x28>\n  add    $0x1,%r13d\n  jmp    117d <func0+0x5d>\n  nop\n  jle    120c <func0+0xec>\n  movb   $0x2d,(%rdx)\n  jmp    1168 <func0+0x48>\n  nopw   0x0(%rax,%rax,1)\n  movb   $0x5f,(%rdx)\n  jmp    1168 <func0+0x48>\n  nopl   (%rax)\n  cmp    $0x1,%r13d\n  je     1200 <func0+0xe0>\n  cmp    $0x2,%r13d\n  jne    11e0 <func0+0xc0>\n  lea    0x1(%r12),%eax\n  add    $0x2,%r12d\n  movb   $0x5f,(%rdx)\n  cltq\n  movslq %r12d,%r15\n  movb   $0x5f,(%r14,%rax,1)\n  jmp    11ec <func0+0xcc>\n  nopl   0x0(%rax)\n  jle    11ec <func0+0xcc>\n  movb   $0x2d,(%rdx)\n  add    $0x1,%r12d\n  movslq %r12d,%r15\n  movb   $0x0,(%r14,%r15,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  add    $0x1,%r12d\n  movb   $0x5f,(%rdx)\n  movslq %r12d,%r15\n  jmp    11ec <func0+0xcc>\n  mov    %r12d,%eax\n  jmp    1168 <func0+0x48>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x8,%rsp\n  jmp    L0\n  nopl   (%rax)\nL4:\n  lea    0x1(%r12),%eax\n  cmp    $0x1,%r13d\n  je     L1\n  cmp    $0x2,%r13d\n  jne    L2\n  cltq\n  movb   $0x5f,(%rdx)\n  movb   $0x5f,(%r14,%rax,1)\n  lea    0x2(%r12),%eax\nL7:\n  movzbl 0x0(%rbp,%rbx,1),%edx\n  lea    0x1(%rax),%r12d\n  cltq\n  xor    %r13d,%r13d\n  movslq %r12d,%r15\n  mov    %dl,(%r14,%rax,1)\nL5:\n  add    $0x1,%rbx\nL0:\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  lea    (%r14,%r15,1),%rdx\n  cmp    %rbx,%rax\n  jbe    L3\n  cmpb   $0x20,0x0(%rbp,%rbx,1)\n  jne    L4\n  add    $0x1,%r13d\n  jmp    L5\n  nop\nL2:\n  jle    L6\n  movb   $0x2d,(%rdx)\n  jmp    L7\n  nopw   0x0(%rax,%rax,1)\nL1:\n  movb   $0x5f,(%rdx)\n  jmp    L7\n  nopl   (%rax)\nL3:\n  cmp    $0x1,%r13d\n  je     L8\n  cmp    $0x2,%r13d\n  jne    L9\n  lea    0x1(%r12),%eax\n  add    $0x2,%r12d\n  movb   $0x5f,(%rdx)\n  cltq\n  movslq %r12d,%r15\n  movb   $0x5f,(%r14,%rax,1)\n  jmp    L10\n  nopl   0x0(%rax)\nL9:\n  jle    L10\n  movb   $0x2d,(%rdx)\n  add    $0x1,%r12d\n  movslq %r12d,%r15\nL10:\n  movb   $0x0,(%r14,%r15,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  add    $0x1,%r12d\n  movb   $0x5f,(%rdx)\n  movslq %r12d,%r15\n  jmp    L10\nL6:\n  mov    %r12d,%eax\n  jmp    L7",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4481
        },
        "L1": {
          "label": "L1",
          "addr": 4528
        },
        "L2": {
          "label": "L2",
          "addr": 4512
        },
        "L3": {
          "label": "L3",
          "addr": 4536
        },
        "L4": {
          "label": "L4",
          "addr": 4424
        },
        "L5": {
          "label": "L5",
          "addr": 4477
        },
        "L6": {
          "label": "L6",
          "addr": 4620
        },
        "L7": {
          "label": "L7",
          "addr": 4456
        },
        "L8": {
          "label": "L8",
          "addr": 4608
        },
        "L9": {
          "label": "L9",
          "addr": 4576
        },
        "L10": {
          "label": "L10",
          "addr": 4588
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s, char *t) {\n  int i = 0, j = 0, k = 0, n = 0;\n  for (i = 0; i < strlen(s); i++) {\n    if (s[i] == ' ') {\n      n++;\n    } else {\n      if (n == 1) {\n        t[j++] = '_';\n      } else if (n == 2) {\n        t[j++] = '_';\n        t[j++] = '_';\n      } else if (n > 0) {\n        t[j++] = '-';\n      }\n      t[j++] = s[i];\n      n = 0;\n    }\n  }\n  if (n == 1) {\n    t[j++] = '_';\n  } else if (n == 2) {\n    t[j++] = '_';\n    t[j++] = '_';\n  } else if (n > 0) {\n    t[j++] = '-';\n  }\n  t[j] = '\\0';\n}"
    },
    {
      "task_id": 137,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
      "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strdup@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   10b0 <strdup@plt>\n  movzbl (%r12),%edx\n  mov    %rax,%r13\n  test   %dl,%dl\n  je     11e5 <func0+0x65>\n  mov    %r12,%rax\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x2c,%dl\n  je     12c0 <func0+0x140>\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11d0 <func0+0x50>\n  movzbl 0x0(%r13),%edx\n  test   %dl,%dl\n  je     120d <func0+0x8d>\n  mov    %r13,%rax\n  nopl   0x0(%rax)\n  cmp    $0x2c,%dl\n  je     12e0 <func0+0x160>\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11f8 <func0+0x78>\n  lea    0x10(%rsp),%r14\n  mov    %r12,%rdi\n  mov    %r14,%rsi\n  call   1090 <strtod@plt>\n  mov    0x10(%rsp),%rax\n  movq   %xmm0,%r15\n  cmpb   $0x0,(%rax)\n  jne    1288 <func0+0x108>\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   1090 <strtod@plt>\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    1288 <func0+0x108>\n  mov    %r12,%rdi\n  movsd  %xmm0,0x8(%rsp)\n  call   1080 <free@plt>\n  mov    %r13,%rdi\n  call   1080 <free@plt>\n  movsd  0x8(%rsp),%xmm0\n  movq   %r15,%xmm1\n  ucomisd %xmm0,%xmm1\n  jp     1271 <func0+0xf1>\n  lea    0xd9f(%rip),%rax        # 200e <_fini+0xd0e>\n  je     129f <func0+0x11f>\n  movq   %r15,%xmm2\n  mov    %rbx,%rax\n  comisd %xmm0,%xmm2\n  cmova  %rbp,%rax\n  jmp    129f <func0+0x11f>\n  nopl   0x0(%rax,%rax,1)\n  mov    %r12,%rdi\n  call   1080 <free@plt>\n  mov    %r13,%rdi\n  call   1080 <free@plt>\n  lea    0xd61(%rip),%rax        # 2000 <_fini+0xd00>\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12f8 <func0+0x178>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11d0 <func0+0x50>\n  jmp    11e5 <func0+0x65>\n  nopl   0x0(%rax,%rax,1)\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11f8 <func0+0x78>\n  jmp    120d <func0+0x8d>\n  call   10a0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strdup@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strdup@plt>\n  movzbl (%r12),%edx\n  mov    %rax,%r13\n  test   %dl,%dl\n  je     L0\n  mov    %r12,%rax\n  nopw   0x0(%rax,%rax,1)\nL2:\n  cmp    $0x2c,%dl\n  je     L1\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L2\nL0:\n  movzbl 0x0(%r13),%edx\n  test   %dl,%dl\n  je     L3\n  mov    %r13,%rax\n  nopl   0x0(%rax)\nL5:\n  cmp    $0x2c,%dl\n  je     L4\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L5\nL3:\n  lea    0x10(%rsp),%r14\n  mov    %r12,%rdi\n  mov    %r14,%rsi\n  call   <strtod@plt>\n  mov    0x10(%rsp),%rax\n  movq   %xmm0,%r15\n  cmpb   $0x0,(%rax)\n  jne    L6\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   <strtod@plt>\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    L6\n  mov    %r12,%rdi\n  movsd  %xmm0,0x8(%rsp)\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  movsd  0x8(%rsp),%xmm0\n  movq   %r15,%xmm1\n  ucomisd %xmm0,%xmm1\n  jp     L7\n  lea    D0(%rip),%rax\n  je     L8\nL7:\n  movq   %r15,%xmm2\n  mov    %rbx,%rax\n  comisd %xmm0,%xmm2\n  cmova  %rbp,%rax\n  jmp    L8\n  nopl   0x0(%rax,%rax,1)\nL6:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  lea    D1(%rip),%rax\nL8:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L9\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\nL1:\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L2\n  jmp    L0\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L5\n  jmp    L3\nL9:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8206,
          "bias": [
            3487
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3425
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4581
        },
        "L1": {
          "label": "L1",
          "addr": 4800
        },
        "L2": {
          "label": "L2",
          "addr": 4560
        },
        "L3": {
          "label": "L3",
          "addr": 4621
        },
        "L4": {
          "label": "L4",
          "addr": 4832
        },
        "L5": {
          "label": "L5",
          "addr": 4600
        },
        "L6": {
          "label": "L6",
          "addr": 4744
        },
        "L7": {
          "label": "L7",
          "addr": 4721
        },
        "L8": {
          "label": "L8",
          "addr": 4767
        },
        "L9": {
          "label": "L9",
          "addr": 4856
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "496e76616c696420696e707574004e6f6e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Invalid input\""
          },
          "0x200e": {
            "type": "string",
            "value": "\"None\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char *arg0, char *arg1) {\n  char *tmp_arg0 = strdup(arg0);\n  char *tmp_arg1 = strdup(arg1);\n  char *tmp_ptr;\n  double tmp_d0, tmp_d1;\n  for (char *tmp_ptr = tmp_arg0; *tmp_ptr; tmp_ptr++)\n    if (*tmp_ptr == ',')\n      *tmp_ptr = '.';\n  for (char *tmp_ptr = tmp_arg1; *tmp_ptr; tmp_ptr++)\n    if (*tmp_ptr == ',')\n      *tmp_ptr = '.';\n  tmp_d0 = strtod(tmp_arg0, &tmp_ptr);\n  if (*tmp_ptr) {\n    free(tmp_arg0);\n    free(tmp_arg1);\n    return \"Invalid input\";\n  }\n  tmp_d1 = strtod(tmp_arg1, &tmp_ptr);\n  if (*tmp_ptr) {\n    free(tmp_arg0);\n    free(tmp_arg1);\n    return \"Invalid input\";\n  }\n  free(tmp_arg0);\n  free(tmp_arg1);\n  if (tmp_d0 == tmp_d1)\n    return \"None\";\n  else if (tmp_d0 > tmp_d1)\n    return arg0;\n  else\n    return arg1;\n}"
    },
    {
      "task_id": 142,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1160 <func0+0x60>\n  movslq %esi,%rsi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  jmp    1127 <func0+0x27>\n  nopw   0x0(%rax,%rax,1)\n  imul   %edx,%edx\n  add    %edx,%r8d\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     1150 <func0+0x50>\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  mov    (%rdi,%rax,4),%edx\n  jbe    1118 <func0+0x18>\n  test   $0x3,%al\n  jne    1158 <func0+0x58>\n  mov    %edx,%ecx\n  add    $0x1,%rax\n  imul   %edx,%ecx\n  imul   %ecx,%edx\n  add    %edx,%r8d\n  cmp    %rsi,%rax\n  jne    1127 <func0+0x27>\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\n  add    %edx,%r8d\n  jmp    111e <func0+0x1e>\n  nopl   (%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rsi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  imul   %edx,%edx\n  add    %edx,%r8d\nL5:\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     L2\nL1:\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  mov    (%rdi,%rax,4),%edx\n  jbe    L3\n  test   $0x3,%al\n  jne    L4\n  mov    %edx,%ecx\n  add    $0x1,%rax\n  imul   %edx,%ecx\n  imul   %ecx,%edx\n  add    %edx,%r8d\n  cmp    %rsi,%rax\n  jne    L1\nL2:\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\nL4:\n  add    %edx,%r8d\n  jmp    L5\n  nopl   (%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4448
        },
        "L1": {
          "label": "L1",
          "addr": 4391
        },
        "L2": {
          "label": "L2",
          "addr": 4432
        },
        "L3": {
          "label": "L3",
          "addr": 4376
        },
        "L4": {
          "label": "L4",
          "addr": 4440
        },
        "L5": {
          "label": "L5",
          "addr": 4382
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int sum = 0;\n  for (int i = 0; i < len; i++) {\n    if (i % 3 == 0) {\n      sum += arr[i] * arr[i] * arr[i];\n    } else if (i % 4 == 0) {\n      sum += arr[i] * arr[i];\n    } else {\n      sum += arr[i];\n    }\n  }\n  return sum;\n}"
    },
    {
      "task_id": 141,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x4,-0xc(%rbp)\n  jg     1178 <func0+0x3f>\n  lea    0xe8d(%rip),%rax        # 2000 <_fini+0xd78>\n  jmp    1286 <func0+0x14d>\n  mov    -0x28(%rbp),%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x19(%rbp)\n  cmpb   $0x40,-0x19(%rbp)\n  jle    119a <func0+0x61>\n  cmpb   $0x5a,-0x19(%rbp)\n  jle    1194 <func0+0x5b>\n  cmpb   $0x60,-0x19(%rbp)\n  jle    119a <func0+0x61>\n  cmpb   $0x7a,-0x19(%rbp)\n  jle    11a6 <func0+0x6d>\n  lea    0xe5f(%rip),%rax        # 2000 <_fini+0xd78>\n  jmp    1286 <func0+0x14d>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  lea    0xe3e(%rip),%rdx        # 2003 <_fini+0xd7b>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1211 <func0+0xd8>\n  mov    -0x8(%rbp),%rax\n  lea    0xe29(%rip),%rdx        # 2008 <_fini+0xd80>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1211 <func0+0xd8>\n  mov    -0x8(%rbp),%rax\n  lea    0xe14(%rip),%rdx        # 200d <_fini+0xd85>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1211 <func0+0xd8>\n  lea    0xdf1(%rip),%rax        # 2000 <_fini+0xd78>\n  jmp    1286 <func0+0x14d>\n  movl   $0x0,-0x10(%rbp)\n  jmp    1262 <func0+0x129>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    1246 <func0+0x10d>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jg     1246 <func0+0x10d>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2e,%al\n  jne    125e <func0+0x125>\n  addl   $0x1,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     121a <func0+0xe1>\n  cmpl   $0x3,-0x18(%rbp)\n  jg     1276 <func0+0x13d>\n  cmpl   $0x1,-0x14(%rbp)\n  je     127f <func0+0x146>\n  lea    0xd83(%rip),%rax        # 2000 <_fini+0xd78>\n  jmp    1286 <func0+0x14d>\n  lea    0xd8c(%rip),%rax        # 2012 <_fini+0xd8a>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x4,-0xc(%rbp)\n  jg     L0\n  lea    D0(%rip),%rax\n  jmp    L1\nL0:\n  mov    -0x28(%rbp),%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x19(%rbp)\n  cmpb   $0x40,-0x19(%rbp)\n  jle    L2\n  cmpb   $0x5a,-0x19(%rbp)\n  jle    L3\n  cmpb   $0x60,-0x19(%rbp)\n  jle    L2\nL3:\n  cmpb   $0x7a,-0x19(%rbp)\n  jle    L4\nL2:\n  lea    D0(%rip),%rax\n  jmp    L1\nL4:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L5\n  mov    -0x8(%rbp),%rax\n  lea    D2(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L5\n  mov    -0x8(%rbp),%rax\n  lea    D3(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L5\n  lea    D0(%rip),%rax\n  jmp    L1\nL5:\n  movl   $0x0,-0x10(%rbp)\n  jmp    L6\nL9:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    L7\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jg     L7\n  addl   $0x1,-0x18(%rbp)\nL7:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2e,%al\n  jne    L8\n  addl   $0x1,-0x14(%rbp)\nL8:\n  addl   $0x1,-0x10(%rbp)\nL6:\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L9\n  cmpl   $0x3,-0x18(%rbp)\n  jg     L10\n  cmpl   $0x1,-0x14(%rbp)\n  je     L11\nL10:\n  lea    D0(%rip),%rax\n  jmp    L1\nL11:\n  lea    D4(%rip),%rax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3725,
            3679,
            3569,
            3459
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8195,
          "bias": [
            3646
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3625
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8205,
          "bias": [
            3604
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8210,
          "bias": [
            3468
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4472
        },
        "L1": {
          "label": "L1",
          "addr": 4742
        },
        "L2": {
          "label": "L2",
          "addr": 4506
        },
        "L3": {
          "label": "L3",
          "addr": 4500
        },
        "L4": {
          "label": "L4",
          "addr": 4518
        },
        "L5": {
          "label": "L5",
          "addr": 4625
        },
        "L6": {
          "label": "L6",
          "addr": 4706
        },
        "L7": {
          "label": "L7",
          "addr": 4678
        },
        "L8": {
          "label": "L8",
          "addr": 4702
        },
        "L9": {
          "label": "L9",
          "addr": 4634
        },
        "L10": {
          "label": "L10",
          "addr": 4726
        },
        "L11": {
          "label": "L11",
          "addr": 4735
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e6f002e747874002e657865002e646c6c0059657300",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"No\""
          },
          "0x2003": {
            "type": "string",
            "value": "\".txt\""
          },
          "0x2008": {
            "type": "string",
            "value": "\".exe\""
          },
          "0x200d": {
            "type": "string",
            "value": "\".dll\""
          },
          "0x2012": {
            "type": "string",
            "value": "\"Yes\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *str) {\n  int len, i, digit = 0, dot = 0;\n  char *ptr, ch;\n  len = strlen(str);\n  if (len < 5)\n    return \"No\";\n  ch = str[0];\n  if (!((ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z')))\n    return \"No\";\n  ptr = str + len - 4;\n  if (strcmp(ptr, \".txt\") && strcmp(ptr, \".exe\") && strcmp(ptr, \".dll\"))\n    return \"No\";\n  for (i = 0; i < len; i++) {\n    if (str[i] >= '0' && str[i] <= '9')\n      digit++;\n    if (str[i] == '.')\n      dot++;\n  }\n  if (digit < 4 && dot != 1)\n    return \"No\";\n  return \"Yes\";\n}"
    },
    {
      "task_id": 141,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1060 <strlen@plt>\n  mov    %rax,%rbp\n  lea    0xead(%rip),%rax        # 2000 <_fini+0xddc>\n  cmp    $0x4,%ebp\n  jle    121c <func0+0xe3>\n  movzbl (%rbx),%eax\n  lea    -0x5b(%rax),%edx\n  cmp    $0x5,%dl\n  jbe    1215 <func0+0xdc>\n  sub    $0x41,%eax\n  cmp    $0x39,%al\n  ja     1215 <func0+0xdc>\n  movslq %ebp,%rax\n  lea    -0x4(%rbx,%rax,1),%r12\n  lea    0xe82(%rip),%rsi        # 2007 <_fini+0xde3>\n  mov    %r12,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     11c0 <func0+0x87>\n  lea    0xe74(%rip),%rsi        # 200c <_fini+0xde8>\n  mov    %r12,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     11c0 <func0+0x87>\n  lea    0xe66(%rip),%rsi        # 2011 <_fini+0xded>\n  mov    %r12,%rdi\n  call   1070 <strcmp@plt>\n  mov    %eax,%edx\n  lea    0xe44(%rip),%rax        # 2000 <_fini+0xddc>\n  test   %edx,%edx\n  jne    121c <func0+0xe3>\n  mov    %rbx,%rax\n  lea    -0x1(%rbp),%edx\n  lea    0x1(%rbx,%rdx,1),%r8\n  mov    $0x0,%edi\n  mov    $0x0,%esi\n  jmp    11eb <func0+0xb2>\n  cmp    $0x2e,%dl\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%edi\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  je     11fb <func0+0xc2>\n  movzbl (%rax),%edx\n  lea    -0x30(%rdx),%ecx\n  cmp    $0x9,%cl\n  ja     11d7 <func0+0x9e>\n  add    $0x1,%esi\n  jmp    11e2 <func0+0xa9>\n  cmp    $0x3,%esi\n  jg     120c <func0+0xd3>\n  lea    0xdfc(%rip),%rax        # 2003 <_fini+0xddf>\n  cmp    $0x1,%edi\n  je     121c <func0+0xe3>\n  lea    0xded(%rip),%rax        # 2000 <_fini+0xddc>\n  jmp    121c <func0+0xe3>\n  lea    0xde4(%rip),%rax        # 2000 <_fini+0xddc>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  lea    D0(%rip),%rax\n  cmp    $0x4,%ebp\n  jle    L0\n  movzbl (%rbx),%eax\n  lea    -0x5b(%rax),%edx\n  cmp    $0x5,%dl\n  jbe    L1\n  sub    $0x41,%eax\n  cmp    $0x39,%al\n  ja     L1\n  movslq %ebp,%rax\n  lea    -0x4(%rbx,%rax,1),%r12\n  lea    D1(%rip),%rsi\n  mov    %r12,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L2\n  lea    D2(%rip),%rsi\n  mov    %r12,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L2\n  lea    D3(%rip),%rsi\n  mov    %r12,%rdi\n  call   <strcmp@plt>\n  mov    %eax,%edx\n  lea    D0(%rip),%rax\n  test   %edx,%edx\n  jne    L0\nL2:\n  mov    %rbx,%rax\n  lea    -0x1(%rbp),%edx\n  lea    0x1(%rbx,%rdx,1),%r8\n  mov    $0x0,%edi\n  mov    $0x0,%esi\n  jmp    L3\nL5:\n  cmp    $0x2e,%dl\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%edi\nL6:\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  je     L4\nL3:\n  movzbl (%rax),%edx\n  lea    -0x30(%rdx),%ecx\n  cmp    $0x9,%cl\n  ja     L5\n  add    $0x1,%esi\n  jmp    L6\nL4:\n  cmp    $0x3,%esi\n  jg     L7\n  lea    D4(%rip),%rax\n  cmp    $0x1,%edi\n  je     L0\nL7:\n  lea    D0(%rip),%rax\n  jmp    L0\nL1:\n  lea    D0(%rip),%rax\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3757,
            3652,
            3565,
            3556
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8199,
          "bias": [
            3714
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8204,
          "bias": [
            3700
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8209,
          "bias": [
            3686
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8195,
          "bias": [
            3580
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4636
        },
        "L1": {
          "label": "L1",
          "addr": 4629
        },
        "L2": {
          "label": "L2",
          "addr": 4544
        },
        "L3": {
          "label": "L3",
          "addr": 4587
        },
        "L4": {
          "label": "L4",
          "addr": 4603
        },
        "L5": {
          "label": "L5",
          "addr": 4567
        },
        "L6": {
          "label": "L6",
          "addr": 4578
        },
        "L7": {
          "label": "L7",
          "addr": 4620
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e6f00596573002e747874002e657865002e646c6c00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"No\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"Yes\""
          },
          "0x2007": {
            "type": "string",
            "value": "\".txt\""
          },
          "0x200c": {
            "type": "string",
            "value": "\".exe\""
          },
          "0x2011": {
            "type": "string",
            "value": "\".dll\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *c) {\n  int i;\n  int num_len = 0;\n  int dot_num = 0;\n  int len = strlen(c);\n  if (len < 5)\n    return \"No\";\n  if (c[0] < 'A' || (c[0] > 'Z' && c[0] < 'a') || c[0] > 'z')\n    return \"No\";\n  if (!strcmp(c + len - 4, \".txt\") || !strcmp(c + len - 4, \".exe\") || !strcmp(c + len - 4, \".dll\")) {\n    for (i = 0; i < len - 4; i++) {\n      if (c[i] >= '0' && c[i] <= '9')\n        num_len++;\n      if (c[i] == '.')\n        dot_num++;\n    }\n    if (num_len < 4 || dot_num != 1)\n      return \"No\";\n    else\n      return \"Yes\";\n  }\n  return \"No\";\n}"
    },
    {
      "task_id": 141,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    0xeaf(%rip),%r12        # 2000 <_fini+0xdc8>\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1060 <strlen@plt>\n  cmp    $0x4,%eax\n  jle    11e3 <func0+0xa3>\n  movzbl (%rbx),%r13d\n  mov    %rax,%rbp\n  lea    -0x5b(%r13),%eax\n  cmp    $0x5,%al\n  jbe    11f0 <func0+0xb0>\n  lea    -0x41(%r13),%eax\n  cmp    $0x39,%al\n  ja     11f0 <func0+0xb0>\n  movslq %ebp,%rax\n  lea    0xe82(%rip),%rsi        # 2007 <_fini+0xdcf>\n  lea    -0x4(%rbx,%rax,1),%r14\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  jne    1208 <func0+0xc8>\n  lea    -0x1(%rbp),%ecx\n  mov    %rbx,%rax\n  xor    %edi,%edi\n  xor    %esi,%esi\n  add    %rbx,%rcx\n  jmp    11b9 <func0+0x79>\n  nopl   (%rax)\n  add    $0x1,%esi\n  cmp    %rax,%rcx\n  je     11d2 <func0+0x92>\n  movzbl 0x1(%rax),%r13d\n  add    $0x1,%rax\n  lea    -0x30(%r13),%edx\n  cmp    $0x9,%dl\n  jbe    11a8 <func0+0x68>\n  xor    %edx,%edx\n  cmp    $0x2e,%r13b\n  sete   %dl\n  add    %edx,%edi\n  cmp    %rax,%rcx\n  jne    11b0 <func0+0x70>\n  cmp    $0x3,%esi\n  jg     11f0 <func0+0xb0>\n  lea    0xe25(%rip),%r12        # 2003 <_fini+0xdcb>\n  cmp    $0x1,%edi\n  jne    11f0 <func0+0xb0>\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nop\n  lea    0xe09(%rip),%r12        # 2000 <_fini+0xdc8>\n  pop    %rbx\n  pop    %rbp\n  mov    %r12,%rax\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax,%rax,1)\n  lea    0xdfd(%rip),%rsi        # 200c <_fini+0xdd4>\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1196 <func0+0x56>\n  lea    0xdeb(%rip),%rsi        # 2011 <_fini+0xdd9>\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1196 <func0+0x56>\n  jmp    11e3 <func0+0xa3>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    D0(%rip),%r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  cmp    $0x4,%eax\n  jle    L0\n  movzbl (%rbx),%r13d\n  mov    %rax,%rbp\n  lea    -0x5b(%r13),%eax\n  cmp    $0x5,%al\n  jbe    L1\n  lea    -0x41(%r13),%eax\n  cmp    $0x39,%al\n  ja     L1\n  movslq %ebp,%rax\n  lea    D1(%rip),%rsi\n  lea    -0x4(%rbx,%rax,1),%r14\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L2\nL7:\n  lea    -0x1(%rbp),%ecx\n  mov    %rbx,%rax\n  xor    %edi,%edi\n  xor    %esi,%esi\n  add    %rbx,%rcx\n  jmp    L3\n  nopl   (%rax)\nL5:\n  add    $0x1,%esi\n  cmp    %rax,%rcx\n  je     L4\nL6:\n  movzbl 0x1(%rax),%r13d\n  add    $0x1,%rax\nL3:\n  lea    -0x30(%r13),%edx\n  cmp    $0x9,%dl\n  jbe    L5\n  xor    %edx,%edx\n  cmp    $0x2e,%r13b\n  sete   %dl\n  add    %edx,%edi\n  cmp    %rax,%rcx\n  jne    L6\nL4:\n  cmp    $0x3,%esi\n  jg     L1\n  lea    D2(%rip),%r12\n  cmp    $0x1,%edi\n  jne    L1\nL0:\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nop\nL1:\n  lea    D0(%rip),%r12\n  pop    %rbx\n  pop    %rbp\n  mov    %r12,%rax\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  lea    D3(%rip),%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L7\n  lea    D4(%rip),%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L7\n  jmp    L0",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3759,
            3593
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8199,
          "bias": [
            3714
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8195,
          "bias": [
            3621
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8204,
          "bias": [
            3581
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8209,
          "bias": [
            3563
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4579
        },
        "L1": {
          "label": "L1",
          "addr": 4592
        },
        "L2": {
          "label": "L2",
          "addr": 4616
        },
        "L3": {
          "label": "L3",
          "addr": 4537
        },
        "L4": {
          "label": "L4",
          "addr": 4562
        },
        "L5": {
          "label": "L5",
          "addr": 4520
        },
        "L6": {
          "label": "L6",
          "addr": 4528
        },
        "L7": {
          "label": "L7",
          "addr": 4502
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e6f00596573002e747874002e657865002e646c6c00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"No\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"Yes\""
          },
          "0x2007": {
            "type": "string",
            "value": "\".txt\""
          },
          "0x200c": {
            "type": "string",
            "value": "\".exe\""
          },
          "0x2011": {
            "type": "string",
            "value": "\".dll\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *c) {\n  int len = strlen(c);\n  if (len < 5)\n    return \"No\";\n  if (c[0] >= 'A' && c[0] <= 'Z')\n    return \"No\";\n  if (c[0] >= 'a' && c[0] <= 'z')\n    return \"No\";\n  if (c[0] >= '[' && c[0] <= '`')\n    return \"No\";\n  if (c[0] >= '{' && c[0] <= '~')\n    return \"No\";\n  if (strcmp(&c[len - 4], \".txt\") != 0 && strcmp(&c[len - 4], \".exe\") != 0 && strcmp(&c[len - 4], \".dll\") != 0)\n    return \"No\";\n  int i, digit = 0, dot = 0;\n  for (i = 0; i < len - 1; i++) {\n    if (c[i] >= '0' && c[i] <= '9')\n      digit++;\n    if (c[i] == '.')\n      dot++;\n  }\n  if (digit < 4)\n    return \"No\";\n  if (dot != 1)\n    return \"No\";\n  return \"Yes\";\n}"
    },
    {
      "task_id": 143,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     11e2 <func0+0xc2>\n  mov    %rdi,%rbp\n  xor    %r13d,%r13d\n  xor    %ecx,%ecx\n  xor    %ebx,%ebx\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%ecx\n  add    $0x1,%rbx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  je     117c <func0+0x5c>\n  cmp    $0x20,%al\n  jne    1150 <func0+0x30>\n  cmp    $0x1,%ecx\n  jg     11f8 <func0+0xd8>\n  add    $0x1,%rbx\n  xor    %ecx,%ecx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  jne    1160 <func0+0x40>\n  cmp    $0x1,%ecx\n  jle    11dc <func0+0xbc>\n  cmp    $0x3,%ecx\n  jle    11ad <func0+0x8d>\n  mov    $0x2,%esi\n  test   $0x1,%cl\n  jne    11a1 <func0+0x81>\n  jmp    11dc <func0+0xbc>\n  nopw   0x0(%rax,%rax,1)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     11dc <func0+0xbc>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1198 <func0+0x78>\n  test   %r13d,%r13d\n  je     1260 <func0+0x140>\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rcx,%rax,1),%r13d\n  add    %r12,%rdi\n  movslq %ecx,%rdx\n  sub    %rdx,%rbx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  call   1050 <memcpy@plt>\n  movslq %r13d,%r13\n  add    %r13,%r12\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x3,%ecx\n  jle    1229 <func0+0x109>\n  test   $0x1,%cl\n  je     116d <func0+0x4d>\n  mov    $0x2,%esi\n  jmp    121d <func0+0xfd>\n  nopl   (%rax)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     116d <func0+0x4d>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1210 <func0+0xf0>\n  test   %r13d,%r13d\n  je     1270 <func0+0x150>\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rax,%rcx,1),%r13d\n  add    %r12,%rdi\n  movslq %ecx,%rdx\n  mov    %rbx,%rsi\n  sub    %rdx,%rsi\n  add    %rbp,%rsi\n  call   1050 <memcpy@plt>\n  xor    %ecx,%ecx\n  jmp    1153 <func0+0x33>\n  nopl   0x0(%rax)\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    11cc <func0+0xac>\n  nopl   0x0(%rax,%rax,1)\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    1244 <func0+0x124>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  mov    %rdi,%rbp\n  xor    %r13d,%r13d\n  xor    %ecx,%ecx\n  xor    %ebx,%ebx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%ecx\nL15:\n  add    $0x1,%rbx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  je     L2\nL1:\n  cmp    $0x20,%al\n  jne    L3\n  cmp    $0x1,%ecx\n  jg     L4\nL11:\n  add    $0x1,%rbx\n  xor    %ecx,%ecx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  jne    L1\nL2:\n  cmp    $0x1,%ecx\n  jle    L5\n  cmp    $0x3,%ecx\n  jle    L6\n  mov    $0x2,%esi\n  test   $0x1,%cl\n  jne    L7\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L5\nL7:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L8\nL6:\n  test   %r13d,%r13d\n  je     L9\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rcx,%rax,1),%r13d\n  add    %r12,%rdi\nL16:\n  movslq %ecx,%rdx\n  sub    %rdx,%rbx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  call   <memcpy@plt>\nL5:\n  movslq %r13d,%r13\n  add    %r13,%r12\nL0:\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    $0x3,%ecx\n  jle    L10\n  test   $0x1,%cl\n  je     L11\n  mov    $0x2,%esi\n  jmp    L12\n  nopl   (%rax)\nL13:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L11\nL12:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L13\nL10:\n  test   %r13d,%r13d\n  je     L14\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rax,%rcx,1),%r13d\n  add    %r12,%rdi\nL17:\n  movslq %ecx,%rdx\n  mov    %rbx,%rsi\n  sub    %rdx,%rsi\n  add    %rbp,%rsi\n  call   <memcpy@plt>\n  xor    %ecx,%ecx\n  jmp    L15\n  nopl   0x0(%rax)\nL9:\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    L16\n  nopl   0x0(%rax,%rax,1)\nL14:\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    L17",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4578
        },
        "L1": {
          "label": "L1",
          "addr": 4448
        },
        "L2": {
          "label": "L2",
          "addr": 4476
        },
        "L3": {
          "label": "L3",
          "addr": 4432
        },
        "L4": {
          "label": "L4",
          "addr": 4600
        },
        "L5": {
          "label": "L5",
          "addr": 4572
        },
        "L6": {
          "label": "L6",
          "addr": 4525
        },
        "L7": {
          "label": "L7",
          "addr": 4513
        },
        "L8": {
          "label": "L8",
          "addr": 4504
        },
        "L9": {
          "label": "L9",
          "addr": 4704
        },
        "L10": {
          "label": "L10",
          "addr": 4649
        },
        "L11": {
          "label": "L11",
          "addr": 4461
        },
        "L12": {
          "label": "L12",
          "addr": 4637
        },
        "L13": {
          "label": "L13",
          "addr": 4624
        },
        "L14": {
          "label": "L14",
          "addr": 4720
        },
        "L15": {
          "label": "L15",
          "addr": 4435
        },
        "L16": {
          "label": "L16",
          "addr": 4556
        },
        "L17": {
          "label": "L17",
          "addr": 4676
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *s, char *d) {\n  int i = 0, j = 0, k = 0, len = 0;\n  while (s[i] != '\\0') {\n    if (s[i] == ' ') {\n      if (len > 1) {\n        for (j = 2; j * j <= len; j++) {\n          if (len % j == 0) {\n            goto end;\n          }\n        }\n        if (k) {\n          d[k++] = ' ';\n        }\n        memcpy(d + k, s + i - len, len);\n        k += len;\n      }\n      len = 0;\n    } else {\n      len++;\n    }\n    i++;\n  }\n  if (len > 1) {\n    for (j = 2; j * j <= len; j++) {\n      if (len % j == 0) {\n        goto end;\n      }\n    }\n    if (k) {\n      d[k++] = ' ';\n    }\n    memcpy(d + k, s + i - len, len);\n    k += len;\n  }\nend:\n  d[k] = '\\0';\n}"
    },
    {
      "task_id": 143,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     11e2 <func0+0xc2>\n  mov    %rdi,%rbp\n  xor    %r13d,%r13d\n  xor    %ecx,%ecx\n  xor    %ebx,%ebx\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%ecx\n  add    $0x1,%rbx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  je     117c <func0+0x5c>\n  cmp    $0x20,%al\n  jne    1150 <func0+0x30>\n  cmp    $0x1,%ecx\n  jg     11f8 <func0+0xd8>\n  add    $0x1,%rbx\n  xor    %ecx,%ecx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  jne    1160 <func0+0x40>\n  cmp    $0x1,%ecx\n  jle    11dc <func0+0xbc>\n  cmp    $0x3,%ecx\n  jle    11ad <func0+0x8d>\n  mov    $0x2,%esi\n  test   $0x1,%cl\n  jne    11a1 <func0+0x81>\n  jmp    11dc <func0+0xbc>\n  nopw   0x0(%rax,%rax,1)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     11dc <func0+0xbc>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1198 <func0+0x78>\n  test   %r13d,%r13d\n  je     1260 <func0+0x140>\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rcx,%rax,1),%r13d\n  add    %r12,%rdi\n  movslq %ecx,%rdx\n  sub    %rdx,%rbx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  call   1050 <memcpy@plt>\n  movslq %r13d,%r13\n  add    %r13,%r12\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x3,%ecx\n  jle    1229 <func0+0x109>\n  test   $0x1,%cl\n  je     116d <func0+0x4d>\n  mov    $0x2,%esi\n  jmp    121d <func0+0xfd>\n  nopl   (%rax)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     116d <func0+0x4d>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1210 <func0+0xf0>\n  test   %r13d,%r13d\n  je     1270 <func0+0x150>\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rax,%rcx,1),%r13d\n  add    %r12,%rdi\n  movslq %ecx,%rdx\n  mov    %rbx,%rsi\n  sub    %rdx,%rsi\n  add    %rbp,%rsi\n  call   1050 <memcpy@plt>\n  xor    %ecx,%ecx\n  jmp    1153 <func0+0x33>\n  nopl   0x0(%rax)\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    11cc <func0+0xac>\n  nopl   0x0(%rax,%rax,1)\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    1244 <func0+0x124>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  mov    %rdi,%rbp\n  xor    %r13d,%r13d\n  xor    %ecx,%ecx\n  xor    %ebx,%ebx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%ecx\nL15:\n  add    $0x1,%rbx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  je     L2\nL1:\n  cmp    $0x20,%al\n  jne    L3\n  cmp    $0x1,%ecx\n  jg     L4\nL11:\n  add    $0x1,%rbx\n  xor    %ecx,%ecx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  jne    L1\nL2:\n  cmp    $0x1,%ecx\n  jle    L5\n  cmp    $0x3,%ecx\n  jle    L6\n  mov    $0x2,%esi\n  test   $0x1,%cl\n  jne    L7\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L5\nL7:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L8\nL6:\n  test   %r13d,%r13d\n  je     L9\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rcx,%rax,1),%r13d\n  add    %r12,%rdi\nL16:\n  movslq %ecx,%rdx\n  sub    %rdx,%rbx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  call   <memcpy@plt>\nL5:\n  movslq %r13d,%r13\n  add    %r13,%r12\nL0:\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    $0x3,%ecx\n  jle    L10\n  test   $0x1,%cl\n  je     L11\n  mov    $0x2,%esi\n  jmp    L12\n  nopl   (%rax)\nL13:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L11\nL12:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L13\nL10:\n  test   %r13d,%r13d\n  je     L14\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rax,%rcx,1),%r13d\n  add    %r12,%rdi\nL17:\n  movslq %ecx,%rdx\n  mov    %rbx,%rsi\n  sub    %rdx,%rsi\n  add    %rbp,%rsi\n  call   <memcpy@plt>\n  xor    %ecx,%ecx\n  jmp    L15\n  nopl   0x0(%rax)\nL9:\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    L16\n  nopl   0x0(%rax,%rax,1)\nL14:\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    L17",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4578
        },
        "L1": {
          "label": "L1",
          "addr": 4448
        },
        "L2": {
          "label": "L2",
          "addr": 4476
        },
        "L3": {
          "label": "L3",
          "addr": 4432
        },
        "L4": {
          "label": "L4",
          "addr": 4600
        },
        "L5": {
          "label": "L5",
          "addr": 4572
        },
        "L6": {
          "label": "L6",
          "addr": 4525
        },
        "L7": {
          "label": "L7",
          "addr": 4513
        },
        "L8": {
          "label": "L8",
          "addr": 4504
        },
        "L9": {
          "label": "L9",
          "addr": 4704
        },
        "L10": {
          "label": "L10",
          "addr": 4649
        },
        "L11": {
          "label": "L11",
          "addr": 4461
        },
        "L12": {
          "label": "L12",
          "addr": 4637
        },
        "L13": {
          "label": "L13",
          "addr": 4624
        },
        "L14": {
          "label": "L14",
          "addr": 4720
        },
        "L15": {
          "label": "L15",
          "addr": 4435
        },
        "L16": {
          "label": "L16",
          "addr": 4556
        },
        "L17": {
          "label": "L17",
          "addr": 4676
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *s, char *d) {\n  int i = 0, j = 0, k = 0, len = 0;\n  while (s[i] != '\\0') {\n    if (s[i] == ' ') {\n      if (len > 1) {\n        for (j = 2; j * j <= len; j++) {\n          if (len % j == 0) {\n            goto end;\n          }\n        }\n        if (k) {\n          d[k++] = ' ';\n        }\n        memcpy(d + k, s + i - len, len);\n        k += len;\n      }\n      len = 0;\n    } else {\n      len++;\n    }\n    i++;\n  }\n  if (len > 1) {\n    for (j = 2; j * j <= len; j++) {\n      if (len % j == 0) {\n        goto end;\n      }\n    }\n    if (k) {\n      d[k++] = ' ';\n    }\n    memcpy(d + k, s + i - len, len);\n    k += len;\n  }\nend:\n  d[k] = '\\0';\n}"
    },
    {
      "task_id": 143,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rsi,%r14\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     11ca <func0+0xb1>\n  mov    %rdi,%r12\n  mov    $0x0,%r13d\n  mov    $0x0,%ebx\n  mov    $0x0,%ebp\n  jmp    115f <func0+0x46>\n  cmp    $0x1,%ebx\n  jg     1168 <func0+0x4f>\n  mov    $0x0,%ebx\n  add    $0x1,%rbp\n  movzbl (%r12,%rbp,1),%eax\n  test   %al,%al\n  je     119f <func0+0x86>\n  cmp    $0x20,%al\n  je     1148 <func0+0x2f>\n  add    $0x1,%ebx\n  jmp    1152 <func0+0x39>\n  cmp    $0x3,%ebx\n  jle    120c <func0+0xf3>\n  test   $0x1,%bl\n  je     1198 <func0+0x7f>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     120c <func0+0xf3>\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    117b <func0+0x62>\n  mov    %edx,%ebx\n  jmp    1152 <func0+0x39>\n  mov    $0x0,%ebx\n  jmp    1152 <func0+0x39>\n  cmp    $0x1,%ebx\n  jle    11fb <func0+0xe2>\n  cmp    $0x3,%ebx\n  jle    11d2 <func0+0xb9>\n  test   $0x1,%bl\n  je     11fb <func0+0xe2>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     11d2 <func0+0xb9>\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    11b3 <func0+0x9a>\n  jmp    11fb <func0+0xe2>\n  mov    $0x0,%r13d\n  jmp    11fb <func0+0xe2>\n  test   %r13d,%r13d\n  jle    11e3 <func0+0xca>\n  movslq %r13d,%rax\n  movb   $0x20,(%r14,%rax,1)\n  lea    0x1(%r13),%r13d\n  movslq %ebx,%rdx\n  movslq %r13d,%rdi\n  add    %r14,%rdi\n  sub    %rdx,%rbp\n  lea    (%r12,%rbp,1),%rsi\n  call   1050 <memcpy@plt>\n  add    %ebx,%r13d\n  movslq %r13d,%r13\n  movb   $0x0,(%r14,%r13,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  test   %r13d,%r13d\n  jle    121d <func0+0x104>\n  movslq %r13d,%rax\n  movb   $0x20,(%r14,%rax,1)\n  lea    0x1(%r13),%r13d\n  movslq %ebx,%rdx\n  movslq %r13d,%rdi\n  add    %r14,%rdi\n  mov    %rbp,%rsi\n  sub    %rdx,%rsi\n  add    %r12,%rsi\n  call   1050 <memcpy@plt>\n  add    %ebx,%r13d\n  mov    $0x0,%ebx\n  jmp    1152 <func0+0x39>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rsi,%r14\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  mov    %rdi,%r12\n  mov    $0x0,%r13d\n  mov    $0x0,%ebx\n  mov    $0x0,%ebp\n  jmp    L1\nL4:\n  cmp    $0x1,%ebx\n  jg     L2\n  mov    $0x0,%ebx\nL5:\n  add    $0x1,%rbp\n  movzbl (%r12,%rbp,1),%eax\n  test   %al,%al\n  je     L3\nL1:\n  cmp    $0x20,%al\n  je     L4\n  add    $0x1,%ebx\n  jmp    L5\nL2:\n  cmp    $0x3,%ebx\n  jle    L6\n  test   $0x1,%bl\n  je     L7\n  mov    $0x2,%ecx\nL8:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     L6\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L8\n  mov    %edx,%ebx\n  jmp    L5\nL7:\n  mov    $0x0,%ebx\n  jmp    L5\nL3:\n  cmp    $0x1,%ebx\n  jle    L9\n  cmp    $0x3,%ebx\n  jle    L10\n  test   $0x1,%bl\n  je     L9\n  mov    $0x2,%ecx\nL11:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     L10\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L11\n  jmp    L9\nL0:\n  mov    $0x0,%r13d\n  jmp    L9\nL10:\n  test   %r13d,%r13d\n  jle    L12\n  movslq %r13d,%rax\n  movb   $0x20,(%r14,%rax,1)\n  lea    0x1(%r13),%r13d\nL12:\n  movslq %ebx,%rdx\n  movslq %r13d,%rdi\n  add    %r14,%rdi\n  sub    %rdx,%rbp\n  lea    (%r12,%rbp,1),%rsi\n  call   <memcpy@plt>\n  add    %ebx,%r13d\nL9:\n  movslq %r13d,%r13\n  movb   $0x0,(%r14,%r13,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL6:\n  test   %r13d,%r13d\n  jle    L13\n  movslq %r13d,%rax\n  movb   $0x20,(%r14,%rax,1)\n  lea    0x1(%r13),%r13d\nL13:\n  movslq %ebx,%rdx\n  movslq %r13d,%rdi\n  add    %r14,%rdi\n  mov    %rbp,%rsi\n  sub    %rdx,%rsi\n  add    %r12,%rsi\n  call   <memcpy@plt>\n  add    %ebx,%r13d\n  mov    $0x0,%ebx\n  jmp    L5",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4554
        },
        "L1": {
          "label": "L1",
          "addr": 4447
        },
        "L2": {
          "label": "L2",
          "addr": 4456
        },
        "L3": {
          "label": "L3",
          "addr": 4511
        },
        "L4": {
          "label": "L4",
          "addr": 4424
        },
        "L5": {
          "label": "L5",
          "addr": 4434
        },
        "L6": {
          "label": "L6",
          "addr": 4620
        },
        "L7": {
          "label": "L7",
          "addr": 4504
        },
        "L8": {
          "label": "L8",
          "addr": 4475
        },
        "L9": {
          "label": "L9",
          "addr": 4603
        },
        "L10": {
          "label": "L10",
          "addr": 4562
        },
        "L11": {
          "label": "L11",
          "addr": 4531
        },
        "L12": {
          "label": "L12",
          "addr": 4579
        },
        "L13": {
          "label": "L13",
          "addr": 4637
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *p, char *q) {\n  int i = 0, j = 0, k = 0, n = 0;\n  while (p[i] != '\\0') {\n    if (p[i] == ' ') {\n      if (j > 1) {\n        if (j > 3) {\n          for (k = 2; k * k <= j; k++)\n            if (j % k == 0)\n              break;\n        }\n        if (k * k > j) {\n          if (n > 0)\n            q[n++] = ' ';\n          memcpy(q + n, p + i - j, j);\n          n += j;\n        }\n      }\n      j = 0;\n    } else\n      j++;\n    i++;\n  }\n  if (j > 1) {\n    if (j > 3) {\n      for (k = 2; k * k <= j; k++)\n        if (j % k == 0)\n          break;\n    }\n    if (k * k > j) {\n      if (n > 0)\n        q[n++] = ' ';\n      memcpy(q + n, p + i - j, j);\n      n += j;\n    }\n  }\n  q[n] = '\\0';\n}"
    },
    {
      "task_id": 146,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11f1 <func0+0xf8>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0xa,%eax\n  jle    11ed <func0+0xf4>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x8(%rbp),%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x8(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    11b7 <func0+0xbe>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x9,-0xc(%rbp)\n  jg     1197 <func0+0x9e>\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    11ed <func0+0xf4>\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    11ed <func0+0xf4>\n  addl   $0x1,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     111b <func0+0x22>\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL4:\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0xa,%eax\n  jle    L1\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x8(%rbp),%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x8(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    L2\nL3:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0xc(%rbp)\nL2:\n  cmpl   $0x9,-0xc(%rbp)\n  jg     L3\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  addl   $0x1,-0x14(%rbp)\nL1:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L4\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4593
        },
        "L1": {
          "label": "L1",
          "addr": 4589
        },
        "L2": {
          "label": "L2",
          "addr": 4535
        },
        "L3": {
          "label": "L3",
          "addr": 4503
        },
        "L4": {
          "label": "L4",
          "addr": 4379
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int *array, int len) {\n  int count = 0;\n  for (int i = 0; i < len; i++) {\n    if (array[i] > 10) {\n      int a = array[i] % 10;\n      int b = array[i];\n      while (b >= 10) {\n        b /= 10;\n      }\n      int c = b;\n      if (c % 2 == 1 && a % 2 == 1) {\n        count++;\n      }\n    }\n  }\n  return count;\n}"
    },
    {
      "task_id": 143,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    120f <func0+0xf6>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     116b <func0+0x52>\n  addl   $0x1,-0x14(%rbp)\n  jmp    120b <func0+0xf2>\n  cmpl   $0x1,-0x14(%rbp)\n  jle    11a2 <func0+0x89>\n  movb   $0x1,-0x15(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    1195 <func0+0x7c>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1191 <func0+0x78>\n  movb   $0x0,-0x15(%rbp)\n  jmp    11a6 <func0+0x8d>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    117e <func0+0x65>\n  jmp    11a6 <func0+0x8d>\n  movb   $0x0,-0x15(%rbp)\n  cmpb   $0x0,-0x15(%rbp)\n  je     1204 <func0+0xeb>\n  cmpl   $0x0,-0x10(%rbp)\n  jle    11c8 <func0+0xaf>\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  mov    %rdx,%rsi\n  sub    %rcx,%rsi\n  mov    -0x28(%rbp),%rdx\n  add    %rdx,%rsi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x30(%rbp),%rdx\n  add    %rdx,%rcx\n  mov    %rax,%rdx\n  mov    %rcx,%rdi\n  call   1050 <memcpy@plt>\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    114e <func0+0x35>\n  cmpl   $0x1,-0x14(%rbp)\n  jle    125e <func0+0x145>\n  movb   $0x1,-0x15(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    1251 <func0+0x138>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    124d <func0+0x134>\n  movb   $0x0,-0x15(%rbp)\n  jmp    1262 <func0+0x149>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    123a <func0+0x121>\n  jmp    1262 <func0+0x149>\n  movb   $0x0,-0x15(%rbp)\n  cmpb   $0x0,-0x15(%rbp)\n  je     12c0 <func0+0x1a7>\n  cmpl   $0x0,-0x10(%rbp)\n  jle    1284 <func0+0x16b>\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  mov    %rdx,%rsi\n  sub    %rcx,%rsi\n  mov    -0x28(%rbp),%rdx\n  add    %rdx,%rsi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x30(%rbp),%rdx\n  add    %rdx,%rcx\n  mov    %rax,%rdx\n  mov    %rcx,%rdi\n  call   1050 <memcpy@plt>\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL10:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L1\n  addl   $0x1,-0x14(%rbp)\n  jmp    L2\nL1:\n  cmpl   $0x1,-0x14(%rbp)\n  jle    L3\n  movb   $0x1,-0x15(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    L4\nL7:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L5\n  movb   $0x0,-0x15(%rbp)\n  jmp    L6\nL5:\n  addl   $0x1,-0x8(%rbp)\nL4:\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L7\n  jmp    L6\nL3:\n  movb   $0x0,-0x15(%rbp)\nL6:\n  cmpb   $0x0,-0x15(%rbp)\n  je     L8\n  cmpl   $0x0,-0x10(%rbp)\n  jle    L9\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\nL9:\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  mov    %rdx,%rsi\n  sub    %rcx,%rsi\n  mov    -0x28(%rbp),%rdx\n  add    %rdx,%rsi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x30(%rbp),%rdx\n  add    %rdx,%rcx\n  mov    %rax,%rdx\n  mov    %rcx,%rdi\n  call   <memcpy@plt>\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x10(%rbp)\nL8:\n  movl   $0x0,-0x14(%rbp)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L10\n  cmpl   $0x1,-0x14(%rbp)\n  jle    L11\n  movb   $0x1,-0x15(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    L12\nL15:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L13\n  movb   $0x0,-0x15(%rbp)\n  jmp    L14\nL13:\n  addl   $0x1,-0x8(%rbp)\nL12:\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L15\n  jmp    L14\nL11:\n  movb   $0x0,-0x15(%rbp)\nL14:\n  cmpb   $0x0,-0x15(%rbp)\n  je     L16\n  cmpl   $0x0,-0x10(%rbp)\n  jle    L17\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\nL17:\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  mov    %rdx,%rsi\n  sub    %rcx,%rsi\n  mov    -0x28(%rbp),%rdx\n  add    %rdx,%rsi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x30(%rbp),%rdx\n  add    %rdx,%rcx\n  mov    %rax,%rdx\n  mov    %rcx,%rdi\n  call   <memcpy@plt>\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x10(%rbp)\nL16:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4623
        },
        "L1": {
          "label": "L1",
          "addr": 4459
        },
        "L2": {
          "label": "L2",
          "addr": 4619
        },
        "L3": {
          "label": "L3",
          "addr": 4514
        },
        "L4": {
          "label": "L4",
          "addr": 4501
        },
        "L5": {
          "label": "L5",
          "addr": 4497
        },
        "L6": {
          "label": "L6",
          "addr": 4518
        },
        "L7": {
          "label": "L7",
          "addr": 4478
        },
        "L8": {
          "label": "L8",
          "addr": 4612
        },
        "L9": {
          "label": "L9",
          "addr": 4552
        },
        "L10": {
          "label": "L10",
          "addr": 4430
        },
        "L11": {
          "label": "L11",
          "addr": 4702
        },
        "L12": {
          "label": "L12",
          "addr": 4689
        },
        "L13": {
          "label": "L13",
          "addr": 4685
        },
        "L14": {
          "label": "L14",
          "addr": 4706
        },
        "L15": {
          "label": "L15",
          "addr": 4666
        },
        "L16": {
          "label": "L16",
          "addr": 4800
        },
        "L17": {
          "label": "L17",
          "addr": 4740
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *s, char *d) {\n  int i, j, k, len, flag;\n  len = 0;\n  k = 0;\n  i = 0;\n  while (s[i] != '\\0') {\n    if (s[i] != ' ') {\n      len++;\n    } else {\n      if (len > 1) {\n        flag = 1;\n        for (j = 2; j * j <= len; j++) {\n          if (len % j == 0) {\n            flag = 0;\n            break;\n          }\n        }\n      } else {\n        flag = 0;\n      }\n      if (flag) {\n        if (k > 0) {\n          d[k++] = ' ';\n        }\n        memcpy(d + k, s + i - len, len);\n        k += len;\n      }\n      len = 0;\n    }\n    i++;\n  }\n  if (len > 1) {\n    flag = 1;\n    for (j = 2; j * j <= len; j++) {\n      if (len % j == 0) {\n        flag = 0;\n        break;\n      }\n    }\n  } else {\n    flag = 0;\n  }\n  if (flag) {\n    if (k > 0) {\n      d[k++] = ' ';\n    }\n    memcpy(d + k, s + i - len, len);\n    k += len;\n  }\n  d[k] = '\\0';\n}"
    },
    {
      "task_id": 144,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x110,%rsp\n  mov    %rdi,-0x108(%rbp)\n  mov    %rsi,-0x110(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0xf8(%rbp)\n  jmp    119d <func0+0x64>\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf8(%rbp),%eax\n  cltq\n  mov    %dl,-0xe0(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jne    1171 <func0+0x38>\n  mov    -0xf8(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe0(%rbp,%rax,1)\n  lea    -0xe0(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <atoi@plt>\n  mov    %eax,-0xf0(%rbp)\n  movl   $0x0,-0xf4(%rbp)\n  addl   $0x1,-0xf8(%rbp)\n  jmp    121f <func0+0xe6>\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf4(%rbp),%eax\n  cltq\n  mov    %dl,-0x70(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  addl   $0x1,-0xf4(%rbp)\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11ef <func0+0xb6>\n  mov    -0xf4(%rbp),%eax\n  cltq\n  movb   $0x0,-0x70(%rbp,%rax,1)\n  lea    -0x70(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <atoi@plt>\n  mov    %eax,-0xec(%rbp)\n  movl   $0x0,-0xf8(%rbp)\n  jmp    1290 <func0+0x157>\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf8(%rbp),%eax\n  cltq\n  mov    %dl,-0xe0(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jne    1264 <func0+0x12b>\n  mov    -0xf8(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe0(%rbp,%rax,1)\n  lea    -0xe0(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <atoi@plt>\n  mov    %eax,-0xe8(%rbp)\n  movl   $0x0,-0xf4(%rbp)\n  addl   $0x1,-0xf8(%rbp)\n  jmp    1312 <func0+0x1d9>\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf4(%rbp),%eax\n  cltq\n  mov    %dl,-0x70(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  addl   $0x1,-0xf4(%rbp)\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    12e2 <func0+0x1a9>\n  mov    -0xf4(%rbp),%eax\n  cltq\n  movb   $0x0,-0x70(%rbp,%rax,1)\n  lea    -0x70(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <atoi@plt>\n  mov    %eax,-0xe4(%rbp)\n  mov    -0xf0(%rbp),%eax\n  imul   -0xe8(%rbp),%eax\n  mov    -0xec(%rbp),%edx\n  mov    %edx,%ecx\n  imul   -0xe4(%rbp),%ecx\n  cltd\n  idiv   %ecx\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1377 <func0+0x23e>\n  mov    $0x1,%eax\n  jmp    137c <func0+0x243>\n  mov    $0x0,%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     1390 <func0+0x257>\n  call   1060 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x110,%rsp\n  mov    %rdi,-0x108(%rbp)\n  mov    %rsi,-0x110(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0xf8(%rbp)\n  jmp    L0\nL1:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf8(%rbp),%eax\n  cltq\n  mov    %dl,-0xe0(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\nL0:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jne    L1\n  mov    -0xf8(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe0(%rbp,%rax,1)\n  lea    -0xe0(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0xf0(%rbp)\n  movl   $0x0,-0xf4(%rbp)\n  addl   $0x1,-0xf8(%rbp)\n  jmp    L2\nL3:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf4(%rbp),%eax\n  cltq\n  mov    %dl,-0x70(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  addl   $0x1,-0xf4(%rbp)\nL2:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L3\n  mov    -0xf4(%rbp),%eax\n  cltq\n  movb   $0x0,-0x70(%rbp,%rax,1)\n  lea    -0x70(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0xec(%rbp)\n  movl   $0x0,-0xf8(%rbp)\n  jmp    L4\nL5:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf8(%rbp),%eax\n  cltq\n  mov    %dl,-0xe0(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\nL4:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jne    L5\n  mov    -0xf8(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe0(%rbp,%rax,1)\n  lea    -0xe0(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0xe8(%rbp)\n  movl   $0x0,-0xf4(%rbp)\n  addl   $0x1,-0xf8(%rbp)\n  jmp    L6\nL7:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf4(%rbp),%eax\n  cltq\n  mov    %dl,-0x70(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  addl   $0x1,-0xf4(%rbp)\nL6:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L7\n  mov    -0xf4(%rbp),%eax\n  cltq\n  movb   $0x0,-0x70(%rbp,%rax,1)\n  lea    -0x70(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0xe4(%rbp)\n  mov    -0xf0(%rbp),%eax\n  imul   -0xe8(%rbp),%eax\n  mov    -0xec(%rbp),%edx\n  mov    %edx,%ecx\n  imul   -0xe4(%rbp),%ecx\n  cltd\n  idiv   %ecx\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L8\n  mov    $0x1,%eax\n  jmp    L9\nL8:\n  mov    $0x0,%eax\nL9:\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L10\n  call   <__stack_chk_fail@plt>\nL10:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4509
        },
        "L1": {
          "label": "L1",
          "addr": 4465
        },
        "L2": {
          "label": "L2",
          "addr": 4639
        },
        "L3": {
          "label": "L3",
          "addr": 4591
        },
        "L4": {
          "label": "L4",
          "addr": 4752
        },
        "L5": {
          "label": "L5",
          "addr": 4708
        },
        "L6": {
          "label": "L6",
          "addr": 4882
        },
        "L7": {
          "label": "L7",
          "addr": 4834
        },
        "L8": {
          "label": "L8",
          "addr": 4983
        },
        "L9": {
          "label": "L9",
          "addr": 4988
        },
        "L10": {
          "label": "L10",
          "addr": 5008
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *a, char *b) {\n  int i, j;\n  char str[100];\n  char str2[100];\n  i = 0;\n  while (a[i] != '/') {\n    str[i] = a[i];\n    i++;\n  }\n  str[i] = '\\0';\n  int num1 = atoi(str);\n  j = 0;\n  i++;\n  while (a[i] != '\\0') {\n    str2[j] = a[i];\n    i++;\n    j++;\n  }\n  str2[j] = '\\0';\n  int num2 = atoi(str2);\n  i = 0;\n  while (b[i] != '/') {\n    str[i] = b[i];\n    i++;\n  }\n  str[i] = '\\0';\n  int num3 = atoi(str);\n  j = 0;\n  i++;\n  while (b[i] != '\\0') {\n    str2[j] = b[i];\n    i++;\n    j++;\n  }\n  str2[j] = '\\0';\n  int num4 = atoi(str2);\n  if (num1 * num3 % (num2 * num4) == 0)\n    return 1;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 146,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    118e <func0+0x95>\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%r10d\n  jmp    1121 <func0+0x28>\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  je     1194 <func0+0x9b>\n  mov    (%r8),%edi\n  cmp    $0xa,%edi\n  jle    1118 <func0+0x1f>\n  mov    %edi,%edx\n  mov    %edx,%ecx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  cmp    $0x63,%ecx\n  jg     112b <func0+0x32>\n  shr    $0x1f,%eax\n  add    %eax,%edx\n  and    $0x1,%edx\n  sub    %eax,%edx\n  cmp    $0x1,%edx\n  jne    1118 <func0+0x1f>\n  movslq %edi,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edi,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  sub    %eax,%edi\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%edi\n  and    $0x1,%edi\n  sub    %eax,%edi\n  cmp    $0x1,%edi\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r10d\n  jmp    1118 <func0+0x1f>\n  mov    $0x0,%r10d\n  mov    %r10d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%r10d\n  jmp    L1\nL3:\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  je     L2\nL1:\n  mov    (%r8),%edi\n  cmp    $0xa,%edi\n  jle    L3\n  mov    %edi,%edx\nL4:\n  mov    %edx,%ecx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  cmp    $0x63,%ecx\n  jg     L4\n  shr    $0x1f,%eax\n  add    %eax,%edx\n  and    $0x1,%edx\n  sub    %eax,%edx\n  cmp    $0x1,%edx\n  jne    L3\n  movslq %edi,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edi,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  sub    %eax,%edi\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%edi\n  and    $0x1,%edi\n  sub    %eax,%edi\n  cmp    $0x1,%edi\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r10d\n  jmp    L3\nL0:\n  mov    $0x0,%r10d\nL2:\n  mov    %r10d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4494
        },
        "L1": {
          "label": "L1",
          "addr": 4385
        },
        "L2": {
          "label": "L2",
          "addr": 4500
        },
        "L3": {
          "label": "L3",
          "addr": 4376
        },
        "L4": {
          "label": "L4",
          "addr": 4395
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *a, int n) {\n  int i, j, c = 0;\n  for (i = 0; i < n; i++) {\n    j = a[i];\n    while (j > 10) {\n      j /= 10;\n      if (j % 2 == 1) {\n        if (a[i] % 10 % 2 == 1)\n          c++;\n      }\n    }\n  }\n  return c;\n}"
    },
    {
      "task_id": 141,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    0xeaf(%rip),%r12        # 2000 <_fini+0x8e0>\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1060 <strlen@plt>\n  cmp    $0x4,%eax\n  jle    15ef <func0+0x4af>\n  movzbl (%rbx),%r13d\n  mov    %rax,%rbp\n  lea    -0x5b(%r13),%eax\n  cmp    $0x5,%al\n  jbe    15e8 <func0+0x4a8>\n  lea    -0x41(%r13),%eax\n  cmp    $0x39,%al\n  ja     15e8 <func0+0x4a8>\n  movslq %ebp,%rax\n  lea    0xe7a(%rip),%rsi        # 2007 <_fini+0x8e7>\n  lea    -0x4(%rbx,%rax,1),%r14\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  jne    1600 <func0+0x4c0>\n  lea    -0x1(%rbp),%eax\n  cmp    $0xe,%eax\n  jbe    16e0 <func0+0x5a0>\n  mov    %ebp,%edx\n  pxor   %xmm2,%xmm2\n  movdqa 0xe63(%rip),%xmm8        # 2020 <_fini+0x900>\n  movdqa 0xe6b(%rip),%xmm7        # 2030 <_fini+0x910>\n  shr    $0x4,%edx\n  movdqa %xmm2,%xmm10\n  pxor   %xmm4,%xmm4\n  mov    %rbx,%rax\n  sub    $0x1,%edx\n  movdqa 0xe61(%rip),%xmm6        # 2040 <_fini+0x920>\n  movdqa 0xe69(%rip),%xmm5        # 2050 <_fini+0x930>\n  pxor   %xmm3,%xmm3\n  shl    $0x4,%rdx\n  lea    0x10(%rbx,%rdx,1),%rdx\n  nopl   0x0(%rax)\n  movdqu (%rax),%xmm0\n  movdqu (%rax),%xmm9\n  movdqa %xmm4,%xmm11\n  add    $0x10,%rax\n  paddb  %xmm8,%xmm0\n  pcmpeqb %xmm6,%xmm9\n  psubusb %xmm7,%xmm0\n  pcmpeqb %xmm4,%xmm0\n  movdqa %xmm0,%xmm1\n  pand   %xmm5,%xmm0\n  pcmpeqb %xmm4,%xmm1\n  pand   %xmm9,%xmm1\n  pcmpgtb %xmm1,%xmm11\n  movdqa %xmm1,%xmm9\n  punpcklbw %xmm11,%xmm9\n  punpckhbw %xmm11,%xmm1\n  movdqa %xmm3,%xmm11\n  pcmpgtw %xmm9,%xmm11\n  movdqa %xmm9,%xmm12\n  punpcklwd %xmm11,%xmm12\n  punpckhwd %xmm11,%xmm9\n  movdqa %xmm1,%xmm11\n  psubd  %xmm12,%xmm2\n  psubd  %xmm9,%xmm2\n  movdqa %xmm3,%xmm9\n  pcmpgtw %xmm1,%xmm9\n  punpcklwd %xmm9,%xmm11\n  punpckhwd %xmm9,%xmm1\n  movdqa %xmm0,%xmm9\n  psubd  %xmm11,%xmm2\n  movdqa %xmm3,%xmm11\n  psubd  %xmm1,%xmm2\n  movdqa %xmm4,%xmm1\n  pcmpgtb %xmm0,%xmm1\n  punpcklbw %xmm1,%xmm9\n  punpckhbw %xmm1,%xmm0\n  pcmpgtw %xmm9,%xmm11\n  movdqa %xmm9,%xmm1\n  punpcklwd %xmm11,%xmm1\n  punpckhwd %xmm11,%xmm9\n  paddd  %xmm10,%xmm1\n  movdqa %xmm0,%xmm10\n  paddd  %xmm9,%xmm1\n  movdqa %xmm3,%xmm9\n  pcmpgtw %xmm0,%xmm9\n  punpcklwd %xmm9,%xmm10\n  punpckhwd %xmm9,%xmm0\n  paddd  %xmm10,%xmm1\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm10\n  cmp    %rdx,%rax\n  jne    11f8 <func0+0xb8>\n  movdqa %xmm1,%xmm0\n  mov    %ebp,%ecx\n  psrldq $0x8,%xmm0\n  and    $0xfffffff0,%ecx\n  paddd  %xmm0,%xmm10\n  movdqa %xmm10,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm10\n  movdqa %xmm2,%xmm0\n  psrldq $0x8,%xmm0\n  movd   %xmm10,%eax\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%edx\n  test   $0xf,%bpl\n  je     15d0 <func0+0x490>\n  movslq %ecx,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1368 <func0+0x228>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  jmp    136b <func0+0x22b>\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  xor    %eax,%eax\n  nopl   0x0(%rax)\n  add    $0x1,%eax\n  add    $0x1,%ecx\n  cmp    %ecx,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %ecx,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1630 <func0+0x4f0>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x1(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1640 <func0+0x500>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x2(%rcx),%esi\n  cmp    %ebp,%esi\n  jge    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1650 <func0+0x510>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x3(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1660 <func0+0x520>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x4(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1670 <func0+0x530>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x5(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1680 <func0+0x540>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x6(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1690 <func0+0x550>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x7(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    16a0 <func0+0x560>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x8(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    16b0 <func0+0x570>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x9(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    16c0 <func0+0x580>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0xa(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    16d0 <func0+0x590>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0xb(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1700 <func0+0x5c0>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0xc(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1708 <func0+0x5c8>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  add    $0xd,%ecx\n  cmp    %ecx,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %ecx,%rcx\n  movzbl (%rbx,%rcx,1),%ecx\n  lea    -0x30(%rcx),%esi\n  cmp    $0x9,%sil\n  ja     1710 <func0+0x5d0>\n  add    $0x1,%eax\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x3,%eax\n  jg     15e8 <func0+0x4a8>\n  lea    0xa27(%rip),%r12        # 2003 <_fini+0x8e3>\n  cmp    $0x1,%edx\n  je     15ef <func0+0x4af>\n  nopl   0x0(%rax)\n  lea    0xa11(%rip),%r12        # 2000 <_fini+0x8e0>\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax,%rax,1)\n  lea    0xa05(%rip),%rsi        # 200c <_fini+0x8ec>\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     11a2 <func0+0x62>\n  lea    0x9f3(%rip),%rsi        # 2011 <_fini+0x8f1>\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     11a2 <func0+0x62>\n  jmp    15ef <func0+0x4af>\n  add    $0x1,%eax\n  jmp    1398 <func0+0x258>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    13c5 <func0+0x285>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    13f2 <func0+0x2b2>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    141f <func0+0x2df>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    144c <func0+0x30c>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    1479 <func0+0x339>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    14a6 <func0+0x366>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    14d3 <func0+0x393>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    1500 <func0+0x3c0>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    152d <func0+0x3ed>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    155a <func0+0x41a>\n  nopl   0x0(%rax,%rax,1)\n  sub    $0x30,%r13d\n  cmp    $0x9,%r13b\n  jbe    135e <func0+0x21e>\n  xor    %edx,%edx\n  xor    %eax,%eax\n  mov    $0x1,%ecx\n  jmp    1376 <func0+0x236>\n  nopl   0x0(%rax)\n  add    $0x1,%eax\n  jmp    1583 <func0+0x443>\n  add    $0x1,%eax\n  jmp    15ac <func0+0x46c>\n  cmp    $0x2e,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  jmp    15d0 <func0+0x490>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    D0(%rip),%r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  cmp    $0x4,%eax\n  jle    L0\n  movzbl (%rbx),%r13d\n  mov    %rax,%rbp\n  lea    -0x5b(%r13),%eax\n  cmp    $0x5,%al\n  jbe    L1\n  lea    -0x41(%r13),%eax\n  cmp    $0x39,%al\n  ja     L1\n  movslq %ebp,%rax\n  lea    D1(%rip),%rsi\n  lea    -0x4(%rbx,%rax,1),%r14\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L2\nL22:\n  lea    -0x1(%rbp),%eax\n  cmp    $0xe,%eax\n  jbe    L3\n  mov    %ebp,%edx\n  pxor   %xmm2,%xmm2\n  movdqa D2(%rip),%xmm8\n  movdqa D3(%rip),%xmm7\n  shr    $0x4,%edx\n  movdqa %xmm2,%xmm10\n  pxor   %xmm4,%xmm4\n  mov    %rbx,%rax\n  sub    $0x1,%edx\n  movdqa D4(%rip),%xmm6\n  movdqa D5(%rip),%xmm5\n  pxor   %xmm3,%xmm3\n  shl    $0x4,%rdx\n  lea    0x10(%rbx,%rdx,1),%rdx\n  nopl   0x0(%rax)\nL4:\n  movdqu (%rax),%xmm0\n  movdqu (%rax),%xmm9\n  movdqa %xmm4,%xmm11\n  add    $0x10,%rax\n  paddb  %xmm8,%xmm0\n  pcmpeqb %xmm6,%xmm9\n  psubusb %xmm7,%xmm0\n  pcmpeqb %xmm4,%xmm0\n  movdqa %xmm0,%xmm1\n  pand   %xmm5,%xmm0\n  pcmpeqb %xmm4,%xmm1\n  pand   %xmm9,%xmm1\n  pcmpgtb %xmm1,%xmm11\n  movdqa %xmm1,%xmm9\n  punpcklbw %xmm11,%xmm9\n  punpckhbw %xmm11,%xmm1\n  movdqa %xmm3,%xmm11\n  pcmpgtw %xmm9,%xmm11\n  movdqa %xmm9,%xmm12\n  punpcklwd %xmm11,%xmm12\n  punpckhwd %xmm11,%xmm9\n  movdqa %xmm1,%xmm11\n  psubd  %xmm12,%xmm2\n  psubd  %xmm9,%xmm2\n  movdqa %xmm3,%xmm9\n  pcmpgtw %xmm1,%xmm9\n  punpcklwd %xmm9,%xmm11\n  punpckhwd %xmm9,%xmm1\n  movdqa %xmm0,%xmm9\n  psubd  %xmm11,%xmm2\n  movdqa %xmm3,%xmm11\n  psubd  %xmm1,%xmm2\n  movdqa %xmm4,%xmm1\n  pcmpgtb %xmm0,%xmm1\n  punpcklbw %xmm1,%xmm9\n  punpckhbw %xmm1,%xmm0\n  pcmpgtw %xmm9,%xmm11\n  movdqa %xmm9,%xmm1\n  punpcklwd %xmm11,%xmm1\n  punpckhwd %xmm11,%xmm9\n  paddd  %xmm10,%xmm1\n  movdqa %xmm0,%xmm10\n  paddd  %xmm9,%xmm1\n  movdqa %xmm3,%xmm9\n  pcmpgtw %xmm0,%xmm9\n  punpcklwd %xmm9,%xmm10\n  punpckhwd %xmm9,%xmm0\n  paddd  %xmm10,%xmm1\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm10\n  cmp    %rdx,%rax\n  jne    L4\n  movdqa %xmm1,%xmm0\n  mov    %ebp,%ecx\n  psrldq $0x8,%xmm0\n  and    $0xfffffff0,%ecx\n  paddd  %xmm0,%xmm10\n  movdqa %xmm10,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm10\n  movdqa %xmm2,%xmm0\n  psrldq $0x8,%xmm0\n  movd   %xmm10,%eax\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%edx\n  test   $0xf,%bpl\n  je     L5\n  movslq %ecx,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L6\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  jmp    L7\nL34:\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  xor    %eax,%eax\n  nopl   0x0(%rax)\nL6:\n  add    $0x1,%eax\nL7:\n  add    $0x1,%ecx\n  cmp    %ecx,%ebp\n  jle    L5\nL35:\n  movslq %ecx,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L8\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL23:\n  lea    0x1(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L9\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL24:\n  lea    0x2(%rcx),%esi\n  cmp    %ebp,%esi\n  jge    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L10\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL25:\n  lea    0x3(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L11\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL26:\n  lea    0x4(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L12\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL27:\n  lea    0x5(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L13\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL28:\n  lea    0x6(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L14\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL29:\n  lea    0x7(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L15\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL30:\n  lea    0x8(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L16\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL31:\n  lea    0x9(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L17\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL32:\n  lea    0xa(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L18\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL33:\n  lea    0xb(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L19\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL36:\n  lea    0xc(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L20\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL37:\n  add    $0xd,%ecx\n  cmp    %ecx,%ebp\n  jle    L5\n  movslq %ecx,%rcx\n  movzbl (%rbx,%rcx,1),%ecx\n  lea    -0x30(%rcx),%esi\n  cmp    $0x9,%sil\n  ja     L21\n  add    $0x1,%eax\n  nopw   0x0(%rax,%rax,1)\nL5:\n  cmp    $0x3,%eax\n  jg     L1\n  lea    D6(%rip),%r12\n  cmp    $0x1,%edx\n  je     L0\n  nopl   0x0(%rax)\nL1:\n  lea    D0(%rip),%r12\nL0:\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  lea    D7(%rip),%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L22\n  lea    D8(%rip),%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L22\n  jmp    L0\nL8:\n  add    $0x1,%eax\n  jmp    L23\n  nopl   0x0(%rax,%rax,1)\nL9:\n  add    $0x1,%eax\n  jmp    L24\n  nopl   0x0(%rax,%rax,1)\nL10:\n  add    $0x1,%eax\n  jmp    L25\n  nopl   0x0(%rax,%rax,1)\nL11:\n  add    $0x1,%eax\n  jmp    L26\n  nopl   0x0(%rax,%rax,1)\nL12:\n  add    $0x1,%eax\n  jmp    L27\n  nopl   0x0(%rax,%rax,1)\nL13:\n  add    $0x1,%eax\n  jmp    L28\n  nopl   0x0(%rax,%rax,1)\nL14:\n  add    $0x1,%eax\n  jmp    L29\n  nopl   0x0(%rax,%rax,1)\nL15:\n  add    $0x1,%eax\n  jmp    L30\n  nopl   0x0(%rax,%rax,1)\nL16:\n  add    $0x1,%eax\n  jmp    L31\n  nopl   0x0(%rax,%rax,1)\nL17:\n  add    $0x1,%eax\n  jmp    L32\n  nopl   0x0(%rax,%rax,1)\nL18:\n  add    $0x1,%eax\n  jmp    L33\n  nopl   0x0(%rax,%rax,1)\nL3:\n  sub    $0x30,%r13d\n  cmp    $0x9,%r13b\n  jbe    L34\n  xor    %edx,%edx\n  xor    %eax,%eax\n  mov    $0x1,%ecx\n  jmp    L35\n  nopl   0x0(%rax)\nL19:\n  add    $0x1,%eax\n  jmp    L36\nL20:\n  add    $0x1,%eax\n  jmp    L37\nL21:\n  cmp    $0x2e,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  jmp    L5",
      "num_missing": 4,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3759,
            2577
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8199,
          "bias": [
            3706
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8224,
          "bias": [
            3683
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8240,
          "bias": [
            3691
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8256,
          "bias": [
            3681
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8272,
          "bias": [
            3689
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8195,
          "bias": [
            2599
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8204,
          "bias": [
            2565
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8209,
          "bias": [
            2547
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5615
        },
        "L1": {
          "label": "L1",
          "addr": 5608
        },
        "L2": {
          "label": "L2",
          "addr": 5632
        },
        "L3": {
          "label": "L3",
          "addr": 5856
        },
        "L4": {
          "label": "L4",
          "addr": 4600
        },
        "L5": {
          "label": "L5",
          "addr": 5584
        },
        "L6": {
          "label": "L6",
          "addr": 4968
        },
        "L7": {
          "label": "L7",
          "addr": 4971
        },
        "L8": {
          "label": "L8",
          "addr": 5680
        },
        "L9": {
          "label": "L9",
          "addr": 5696
        },
        "L10": {
          "label": "L10",
          "addr": 5712
        },
        "L11": {
          "label": "L11",
          "addr": 5728
        },
        "L12": {
          "label": "L12",
          "addr": 5744
        },
        "L13": {
          "label": "L13",
          "addr": 5760
        },
        "L14": {
          "label": "L14",
          "addr": 5776
        },
        "L15": {
          "label": "L15",
          "addr": 5792
        },
        "L16": {
          "label": "L16",
          "addr": 5808
        },
        "L17": {
          "label": "L17",
          "addr": 5824
        },
        "L18": {
          "label": "L18",
          "addr": 5840
        },
        "L19": {
          "label": "L19",
          "addr": 5888
        },
        "L20": {
          "label": "L20",
          "addr": 5896
        },
        "L21": {
          "label": "L21",
          "addr": 5904
        },
        "L22": {
          "label": "L22",
          "addr": 4514
        },
        "L23": {
          "label": "L23",
          "addr": 5016
        },
        "L24": {
          "label": "L24",
          "addr": 5061
        },
        "L25": {
          "label": "L25",
          "addr": 5106
        },
        "L26": {
          "label": "L26",
          "addr": 5151
        },
        "L27": {
          "label": "L27",
          "addr": 5196
        },
        "L28": {
          "label": "L28",
          "addr": 5241
        },
        "L29": {
          "label": "L29",
          "addr": 5286
        },
        "L30": {
          "label": "L30",
          "addr": 5331
        },
        "L31": {
          "label": "L31",
          "addr": 5376
        },
        "L32": {
          "label": "L32",
          "addr": 5421
        },
        "L33": {
          "label": "L33",
          "addr": 5466
        },
        "L34": {
          "label": "L34",
          "addr": 4958
        },
        "L35": {
          "label": "L35",
          "addr": 4982
        },
        "L36": {
          "label": "L36",
          "addr": 5507
        },
        "L37": {
          "label": "L37",
          "addr": 5548
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e6f00596573002e747874002e657865002e646c6c0000000000000000000000d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0090909090909090909090909090909092e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e01010101010101010101010101010101",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"No\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"Yes\""
          },
          "0x2007": {
            "type": "string",
            "value": "\".txt\""
          },
          "0x200c": {
            "type": "string",
            "value": "\".exe\""
          },
          "0x2011": {
            "type": "string",
            "value": "\".dll\""
          },
          "0x2020": {
            "type": "byte[16]",
            "value": [
              208,
              208,
              208,
              208,
              208,
              208,
              208,
              208,
              208,
              208,
              208,
              208,
              208,
              208,
              208,
              208
            ]
          },
          "0x2030": {
            "type": "byte[16]",
            "value": [
              9,
              9,
              9,
              9,
              9,
              9,
              9,
              9,
              9,
              9,
              9,
              9,
              9,
              9,
              9,
              9
            ]
          },
          "0x2040": {
            "type": "byte[16]",
            "value": [
              46,
              46,
              46,
              46,
              46,
              46,
              46,
              46,
              46,
              46,
              46,
              46,
              46,
              46,
              46,
              46
            ]
          },
          "0x2050": {
            "type": "byte[16]",
            "value": [
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1,
              1
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *s) {\n  int len = strlen(s);\n  if (len < 5)\n    return \"No\";\n  if (s[0] >= 'A' && s[0] <= 'Z')\n    return \"No\";\n  if (s[0] >= 'a' && s[0] <= 'z')\n    return \"No\";\n  if (strcmp(&s[len - 4], \".txt\") && strcmp(&s[len - 4], \".exe\") && strcmp(&s[len - 4], \".dll\"))\n    return \"No\";\n  int num = 0, other = 0;\n  for (int i = 0; i < len; i++) {\n    if (s[i] >= '0' && s[i] <= '9')\n      num++;\n    else if (s[i] == '.')\n      other++;\n  }\n  if (num >= 4)\n    return \"Yes\";\n  else if (other == 1)\n    return \"Yes\";\n  else\n    return \"No\";\n}"
    },
    {
      "task_id": 145,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x4c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  jmp    12a5 <func0+0x10c>\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  lea    -0x14(%rbp),%rax\n  lea    0xdfc(%rip),%rcx        # 2000 <_fini+0xbfc>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   10d0 <sprintf@plt>\n  movl   $0x0,-0x38(%rbp)\n  lea    -0x14(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,-0x24(%rbp)\n  movl   $0x1,-0x34(%rbp)\n  jmp    124a <func0+0xb1>\n  mov    -0x34(%rbp),%eax\n  cltq\n  movzbl -0x14(%rbp,%rax,1),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x38(%rbp)\n  addl   $0x1,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     1233 <func0+0x9a>\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    127b <func0+0xe2>\n  movzbl -0x14(%rbp),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x38(%rbp)\n  jmp    1288 <func0+0xef>\n  movzbl -0x14(%rbp),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  sub    %eax,-0x38(%rbp)\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x3c(%rbp)\n  mov    -0x3c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     11dc <func0+0x43>\n  movl   $0x0,-0x30(%rbp)\n  jmp    13cf <func0+0x236>\n  movl   $0x1,-0x2c(%rbp)\n  jmp    13bf <func0+0x226>\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x20(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    13bb <func0+0x222>\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x2c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x28(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x2c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x48(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x28(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     12c9 <func0+0x130>\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     12bd <func0+0x124>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    -0x48(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     13ff <func0+0x266>\n  call   10b0 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x4c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  jmp    L0\nL5:\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  lea    -0x14(%rbp),%rax\n  lea    D0(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  movl   $0x0,-0x38(%rbp)\n  lea    -0x14(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x24(%rbp)\n  movl   $0x1,-0x34(%rbp)\n  jmp    L1\nL2:\n  mov    -0x34(%rbp),%eax\n  cltq\n  movzbl -0x14(%rbp,%rax,1),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x38(%rbp)\n  addl   $0x1,-0x34(%rbp)\nL1:\n  mov    -0x34(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     L2\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    L3\n  movzbl -0x14(%rbp),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x38(%rbp)\n  jmp    L4\nL3:\n  movzbl -0x14(%rbp),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  sub    %eax,-0x38(%rbp)\nL4:\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x3c(%rbp)\nL0:\n  mov    -0x3c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     L5\n  movl   $0x0,-0x30(%rbp)\n  jmp    L6\nL10:\n  movl   $0x1,-0x2c(%rbp)\n  jmp    L7\nL9:\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x20(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L8\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x2c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x28(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x2c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x48(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x28(%rbp),%eax\n  mov    %eax,(%rdx)\nL8:\n  addl   $0x1,-0x2c(%rbp)\nL7:\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     L9\n  addl   $0x1,-0x30(%rbp)\nL6:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     L10\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x48(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L11\n  call   <__stack_chk_fail@plt>\nL11:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3580
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4773
        },
        "L1": {
          "label": "L1",
          "addr": 4682
        },
        "L2": {
          "label": "L2",
          "addr": 4659
        },
        "L3": {
          "label": "L3",
          "addr": 4731
        },
        "L4": {
          "label": "L4",
          "addr": 4744
        },
        "L5": {
          "label": "L5",
          "addr": 4572
        },
        "L6": {
          "label": "L6",
          "addr": 5071
        },
        "L7": {
          "label": "L7",
          "addr": 5055
        },
        "L8": {
          "label": "L8",
          "addr": 5051
        },
        "L9": {
          "label": "L9",
          "addr": 4809
        },
        "L10": {
          "label": "L10",
          "addr": 4797
        },
        "L11": {
          "label": "L11",
          "addr": 5119
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *a, int n) {\n  int *b = (int *)malloc(n * sizeof(int));\n  for (int i = 0; i < n; i++) {\n    char buf[12];\n    sprintf(buf, \"%d\", abs(a[i]));\n    int sum = 0;\n    int len = strlen(buf);\n    for (int j = 1; j < len; j++)\n      sum += buf[j] - '0';\n    if (a[i] > 0)\n      sum += buf[0] - '0';\n    else\n      sum -= buf[0] - '0';\n    b[i] = sum;\n  }\n  for (int i = 0; i < n; i++)\n    for (int j = 1; j < n; j++)\n      if (b[j - 1] > b[j]) {\n        int tmp = b[j];\n        b[j] = b[j - 1];\n        b[j - 1] = tmp;\n        tmp = a[j];\n        a[j] = a[j - 1];\n        a[j - 1] = tmp;\n      }\n  free(b);\n  return a;\n}"
    },
    {
      "task_id": 144,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0xf8,%rsp\n  movzbl (%rdi),%edx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xe8(%rsp)\n  xor    %eax,%eax\n  cmp    $0x2f,%dl\n  je     12f0 <func0+0x1b0>\n  mov    $0x1,%eax\n  lea    0xf(%rsp),%rsi\n  nopl   0x0(%rax)\n  mov    %dl,(%rsi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    1188 <func0+0x48>\n  lea    0x1(%rcx),%r15d\n  movslq %r15d,%r14\n  lea    0x10(%rsp),%r13\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rcx,1)\n  mov    %r13,%rdi\n  call   1070 <strtol@plt>\n  mov    %rax,0x8(%rsp)\n  movzbl 0x0(%rbp,%r14,1),%eax\n  test   %al,%al\n  je     1308 <func0+0x1c8>\n  movslq %r15d,%r15\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r15,%rbp\n  nop\n  mov    %al,(%rsi,%rdx,1)\n  movslq %edx,%rcx\n  add    $0x1,%rdx\n  movzbl -0x1(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    11e0 <func0+0xa0>\n  lea    0x80(%rsp),%r14\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x80(%rsp,%rcx,1)\n  mov    %r14,%rdi\n  call   1070 <strtol@plt>\n  movzbl (%r12),%ecx\n  mov    %rax,%rbp\n  cmp    $0x2f,%cl\n  je     1310 <func0+0x1d0>\n  mov    $0x1,%edx\n  lea    0xf(%rsp),%rsi\n  nopl   (%rax)\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  cmp    $0x2f,%cl\n  jne    1230 <func0+0xf0>\n  lea    0x1(%rax),%ebx\n  movslq %ebx,%r15\n  mov    %r13,%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rax,1)\n  call   1070 <strtol@plt>\n  movzbl (%r12,%r15,1),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     1328 <func0+0x1e8>\n  movslq %ebx,%r8\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r8,%r12\n  nop\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  test   %cl,%cl\n  jne    1280 <func0+0x140>\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %r14,%rdi\n  movb   $0x0,0x80(%rsp,%rax,1)\n  call   1070 <strtol@plt>\n  mov    %rax,%r8\n  mov    0x8(%rsp),%eax\n  imul   %r8d,%ebp\n  imul   %r13d,%eax\n  cltd\n  idiv   %ebp\n  xor    %eax,%eax\n  test   %edx,%edx\n  sete   %al\n  mov    0xe8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    132f <func0+0x1ef>\n  add    $0xf8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  mov    $0x1,%r14d\n  mov    $0x1,%r15d\n  xor    %ecx,%ecx\n  jmp    11a3 <func0+0x63>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ecx,%ecx\n  jmp    11f3 <func0+0xb3>\n  nop\n  mov    $0x1,%r15d\n  mov    $0x1,%ebx\n  xor    %eax,%eax\n  jmp    124b <func0+0x10b>\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  jmp    1294 <func0+0x154>\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0xf8,%rsp\n  movzbl (%rdi),%edx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xe8(%rsp)\n  xor    %eax,%eax\n  cmp    $0x2f,%dl\n  je     L0\n  mov    $0x1,%eax\n  lea    0xf(%rsp),%rsi\n  nopl   0x0(%rax)\nL1:\n  mov    %dl,(%rsi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    L1\n  lea    0x1(%rcx),%r15d\n  movslq %r15d,%r14\nL9:\n  lea    0x10(%rsp),%r13\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rcx,1)\n  mov    %r13,%rdi\n  call   <strtol@plt>\n  mov    %rax,0x8(%rsp)\n  movzbl 0x0(%rbp,%r14,1),%eax\n  test   %al,%al\n  je     L2\n  movslq %r15d,%r15\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r15,%rbp\n  nop\nL3:\n  mov    %al,(%rsi,%rdx,1)\n  movslq %edx,%rcx\n  add    $0x1,%rdx\n  movzbl -0x1(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    L3\nL10:\n  lea    0x80(%rsp),%r14\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x80(%rsp,%rcx,1)\n  mov    %r14,%rdi\n  call   <strtol@plt>\n  movzbl (%r12),%ecx\n  mov    %rax,%rbp\n  cmp    $0x2f,%cl\n  je     L4\n  mov    $0x1,%edx\n  lea    0xf(%rsp),%rsi\n  nopl   (%rax)\nL5:\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  cmp    $0x2f,%cl\n  jne    L5\n  lea    0x1(%rax),%ebx\n  movslq %ebx,%r15\nL11:\n  mov    %r13,%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rax,1)\n  call   <strtol@plt>\n  movzbl (%r12,%r15,1),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     L6\n  movslq %ebx,%r8\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r8,%r12\n  nop\nL7:\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  test   %cl,%cl\n  jne    L7\nL12:\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %r14,%rdi\n  movb   $0x0,0x80(%rsp,%rax,1)\n  call   <strtol@plt>\n  mov    %rax,%r8\n  mov    0x8(%rsp),%eax\n  imul   %r8d,%ebp\n  imul   %r13d,%eax\n  cltd\n  idiv   %ebp\n  xor    %eax,%eax\n  test   %edx,%edx\n  sete   %al\n  mov    0xe8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L8\n  add    $0xf8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x1,%r14d\n  mov    $0x1,%r15d\n  xor    %ecx,%ecx\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL2:\n  xor    %ecx,%ecx\n  jmp    L10\n  nop\nL4:\n  mov    $0x1,%r15d\n  mov    $0x1,%ebx\n  xor    %eax,%eax\n  jmp    L11\n  nopw   0x0(%rax,%rax,1)\nL6:\n  xor    %eax,%eax\n  jmp    L12\nL8:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4848
        },
        "L1": {
          "label": "L1",
          "addr": 4488
        },
        "L2": {
          "label": "L2",
          "addr": 4872
        },
        "L3": {
          "label": "L3",
          "addr": 4576
        },
        "L4": {
          "label": "L4",
          "addr": 4880
        },
        "L5": {
          "label": "L5",
          "addr": 4656
        },
        "L6": {
          "label": "L6",
          "addr": 4904
        },
        "L7": {
          "label": "L7",
          "addr": 4736
        },
        "L8": {
          "label": "L8",
          "addr": 4911
        },
        "L9": {
          "label": "L9",
          "addr": 4515
        },
        "L10": {
          "label": "L10",
          "addr": 4595
        },
        "L11": {
          "label": "L11",
          "addr": 4683
        },
        "L12": {
          "label": "L12",
          "addr": 4756
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *p, char *q) {\n  int i = 0;\n  int j = 0;\n  char buf1[100];\n  char buf2[100];\n  char buf3[100];\n  while (p[i] != '/') {\n    buf1[i] = p[i];\n    i++;\n  }\n  buf1[i] = '\\0';\n  long int a = strtol(buf1, NULL, 10);\n  while (p[i] != '\\0') {\n    buf2[j] = p[i];\n    i++;\n    j++;\n  }\n  buf2[j] = '\\0';\n  long int b = strtol(buf2, NULL, 10);\n  i = 0;\n  j = 0;\n  while (q[i] != '/') {\n    buf1[i] = q[i];\n    i++;\n  }\n  buf1[i] = '\\0';\n  long int c = strtol(buf1, NULL, 10);\n  while (q[i] != '\\0') {\n    buf3[j] = q[i];\n    i++;\n    j++;\n  }\n  buf3[j] = '\\0';\n  long int d = strtol(buf3, NULL, 10);\n  if (a * d % (b * c) == 0)\n    return 1;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 146,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1165 <func0+0x65>\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  jmp    1129 <func0+0x29>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     1161 <func0+0x61>\n  mov    (%rdi),%ecx\n  cmp    $0xa,%ecx\n  jle    1120 <func0+0x20>\n  mov    %ecx,%eax\n  nopw   0x0(%rax,%rax,1)\n  mov    %eax,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x63,%edx\n  jg     1138 <func0+0x38>\n  test   $0x1,%al\n  je     1120 <func0+0x20>\n  and    $0x1,%ecx\n  cmp    $0x1,%ecx\n  sbb    $0xffffffff,%r9d\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  jne    1129 <func0+0x29>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     L2\nL1:\n  mov    (%rdi),%ecx\n  cmp    $0xa,%ecx\n  jle    L3\n  mov    %ecx,%eax\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %eax,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x63,%edx\n  jg     L4\n  test   $0x1,%al\n  je     L3\n  and    $0x1,%ecx\n  cmp    $0x1,%ecx\n  sbb    $0xffffffff,%r9d\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  jne    L1\nL2:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4453
        },
        "L1": {
          "label": "L1",
          "addr": 4393
        },
        "L2": {
          "label": "L2",
          "addr": 4449
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4408
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, j, ret = 0;\n  for (i = 0; i < len; i++) {\n    j = arr[i];\n    while (j >= 10) {\n      j /= 10;\n    }\n    if (j % 2 != 0 && arr[i] % 2 != 0)\n      ret++;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 144,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0xf8,%rsp\n  movzbl (%rdi),%edx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xe8(%rsp)\n  xor    %eax,%eax\n  cmp    $0x2f,%dl\n  je     12f0 <func0+0x1b0>\n  mov    $0x1,%eax\n  lea    0xf(%rsp),%rsi\n  nopl   0x0(%rax)\n  mov    %dl,(%rsi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    1188 <func0+0x48>\n  lea    0x1(%rcx),%r15d\n  movslq %r15d,%r14\n  lea    0x10(%rsp),%r13\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rcx,1)\n  mov    %r13,%rdi\n  call   1070 <strtol@plt>\n  mov    %rax,0x8(%rsp)\n  movzbl 0x0(%rbp,%r14,1),%eax\n  test   %al,%al\n  je     1308 <func0+0x1c8>\n  movslq %r15d,%r15\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r15,%rbp\n  nop\n  mov    %al,(%rsi,%rdx,1)\n  movslq %edx,%rcx\n  add    $0x1,%rdx\n  movzbl -0x1(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    11e0 <func0+0xa0>\n  lea    0x80(%rsp),%r14\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x80(%rsp,%rcx,1)\n  mov    %r14,%rdi\n  call   1070 <strtol@plt>\n  movzbl (%r12),%ecx\n  mov    %rax,%rbp\n  cmp    $0x2f,%cl\n  je     1310 <func0+0x1d0>\n  mov    $0x1,%edx\n  lea    0xf(%rsp),%rsi\n  nopl   (%rax)\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  cmp    $0x2f,%cl\n  jne    1230 <func0+0xf0>\n  lea    0x1(%rax),%ebx\n  movslq %ebx,%r15\n  mov    %r13,%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rax,1)\n  call   1070 <strtol@plt>\n  movzbl (%r12,%r15,1),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     1328 <func0+0x1e8>\n  movslq %ebx,%r8\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r8,%r12\n  nop\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  test   %cl,%cl\n  jne    1280 <func0+0x140>\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %r14,%rdi\n  movb   $0x0,0x80(%rsp,%rax,1)\n  call   1070 <strtol@plt>\n  mov    %rax,%r8\n  mov    0x8(%rsp),%eax\n  imul   %r8d,%ebp\n  imul   %r13d,%eax\n  cltd\n  idiv   %ebp\n  xor    %eax,%eax\n  test   %edx,%edx\n  sete   %al\n  mov    0xe8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    132f <func0+0x1ef>\n  add    $0xf8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  mov    $0x1,%r14d\n  mov    $0x1,%r15d\n  xor    %ecx,%ecx\n  jmp    11a3 <func0+0x63>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ecx,%ecx\n  jmp    11f3 <func0+0xb3>\n  nop\n  mov    $0x1,%r15d\n  mov    $0x1,%ebx\n  xor    %eax,%eax\n  jmp    124b <func0+0x10b>\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  jmp    1294 <func0+0x154>\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0xf8,%rsp\n  movzbl (%rdi),%edx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xe8(%rsp)\n  xor    %eax,%eax\n  cmp    $0x2f,%dl\n  je     L0\n  mov    $0x1,%eax\n  lea    0xf(%rsp),%rsi\n  nopl   0x0(%rax)\nL1:\n  mov    %dl,(%rsi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    L1\n  lea    0x1(%rcx),%r15d\n  movslq %r15d,%r14\nL9:\n  lea    0x10(%rsp),%r13\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rcx,1)\n  mov    %r13,%rdi\n  call   <strtol@plt>\n  mov    %rax,0x8(%rsp)\n  movzbl 0x0(%rbp,%r14,1),%eax\n  test   %al,%al\n  je     L2\n  movslq %r15d,%r15\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r15,%rbp\n  nop\nL3:\n  mov    %al,(%rsi,%rdx,1)\n  movslq %edx,%rcx\n  add    $0x1,%rdx\n  movzbl -0x1(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    L3\nL10:\n  lea    0x80(%rsp),%r14\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x80(%rsp,%rcx,1)\n  mov    %r14,%rdi\n  call   <strtol@plt>\n  movzbl (%r12),%ecx\n  mov    %rax,%rbp\n  cmp    $0x2f,%cl\n  je     L4\n  mov    $0x1,%edx\n  lea    0xf(%rsp),%rsi\n  nopl   (%rax)\nL5:\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  cmp    $0x2f,%cl\n  jne    L5\n  lea    0x1(%rax),%ebx\n  movslq %ebx,%r15\nL11:\n  mov    %r13,%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rax,1)\n  call   <strtol@plt>\n  movzbl (%r12,%r15,1),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     L6\n  movslq %ebx,%r8\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r8,%r12\n  nop\nL7:\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  test   %cl,%cl\n  jne    L7\nL12:\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %r14,%rdi\n  movb   $0x0,0x80(%rsp,%rax,1)\n  call   <strtol@plt>\n  mov    %rax,%r8\n  mov    0x8(%rsp),%eax\n  imul   %r8d,%ebp\n  imul   %r13d,%eax\n  cltd\n  idiv   %ebp\n  xor    %eax,%eax\n  test   %edx,%edx\n  sete   %al\n  mov    0xe8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L8\n  add    $0xf8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x1,%r14d\n  mov    $0x1,%r15d\n  xor    %ecx,%ecx\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL2:\n  xor    %ecx,%ecx\n  jmp    L10\n  nop\nL4:\n  mov    $0x1,%r15d\n  mov    $0x1,%ebx\n  xor    %eax,%eax\n  jmp    L11\n  nopw   0x0(%rax,%rax,1)\nL6:\n  xor    %eax,%eax\n  jmp    L12\nL8:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4848
        },
        "L1": {
          "label": "L1",
          "addr": 4488
        },
        "L2": {
          "label": "L2",
          "addr": 4872
        },
        "L3": {
          "label": "L3",
          "addr": 4576
        },
        "L4": {
          "label": "L4",
          "addr": 4880
        },
        "L5": {
          "label": "L5",
          "addr": 4656
        },
        "L6": {
          "label": "L6",
          "addr": 4904
        },
        "L7": {
          "label": "L7",
          "addr": 4736
        },
        "L8": {
          "label": "L8",
          "addr": 4911
        },
        "L9": {
          "label": "L9",
          "addr": 4515
        },
        "L10": {
          "label": "L10",
          "addr": 4595
        },
        "L11": {
          "label": "L11",
          "addr": 4683
        },
        "L12": {
          "label": "L12",
          "addr": 4756
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *p, char *q) {\n  int i = 0;\n  int j = 0;\n  char buf1[100];\n  char buf2[100];\n  char buf3[100];\n  while (p[i] != '/') {\n    buf1[i] = p[i];\n    i++;\n  }\n  buf1[i] = '\\0';\n  long int a = strtol(buf1, NULL, 10);\n  while (p[i] != '\\0') {\n    buf2[j] = p[i];\n    i++;\n    j++;\n  }\n  buf2[j] = '\\0';\n  long int b = strtol(buf2, NULL, 10);\n  i = 0;\n  j = 0;\n  while (q[i] != '/') {\n    buf1[i] = q[i];\n    i++;\n  }\n  buf1[i] = '\\0';\n  long int c = strtol(buf1, NULL, 10);\n  while (q[i] != '\\0') {\n    buf3[j] = q[i];\n    i++;\n    j++;\n  }\n  buf3[j] = '\\0';\n  long int d = strtol(buf3, NULL, 10);\n  if (a * d % (b * c) == 0)\n    return 1;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 146,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1165 <func0+0x65>\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  jmp    1129 <func0+0x29>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     1161 <func0+0x61>\n  mov    (%rdi),%ecx\n  cmp    $0xa,%ecx\n  jle    1120 <func0+0x20>\n  mov    %ecx,%eax\n  nopw   0x0(%rax,%rax,1)\n  mov    %eax,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x63,%edx\n  jg     1138 <func0+0x38>\n  test   $0x1,%al\n  je     1120 <func0+0x20>\n  and    $0x1,%ecx\n  cmp    $0x1,%ecx\n  sbb    $0xffffffff,%r9d\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  jne    1129 <func0+0x29>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     L2\nL1:\n  mov    (%rdi),%ecx\n  cmp    $0xa,%ecx\n  jle    L3\n  mov    %ecx,%eax\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %eax,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x63,%edx\n  jg     L4\n  test   $0x1,%al\n  je     L3\n  and    $0x1,%ecx\n  cmp    $0x1,%ecx\n  sbb    $0xffffffff,%r9d\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  jne    L1\nL2:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4453
        },
        "L1": {
          "label": "L1",
          "addr": 4393
        },
        "L2": {
          "label": "L2",
          "addr": 4449
        },
        "L3": {
          "label": "L3",
          "addr": 4384
        },
        "L4": {
          "label": "L4",
          "addr": 4408
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int *arr, int len) {\n  int i, j, ret = 0;\n  for (i = 0; i < len; i++) {\n    j = arr[i];\n    while (j >= 10) {\n      j /= 10;\n    }\n    if (j % 2 != 0 && arr[i] % 2 != 0)\n      ret++;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 144,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xe0,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xd8(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%edx\n  cmp    $0x2f,%dl\n  je     12cd <func0+0x194>\n  mov    $0x1,%eax\n  lea    -0x1(%rsp),%rcx\n  mov    %dl,(%rcx,%rax,1)\n  mov    %eax,%r13d\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    117b <func0+0x42>\n  movslq %r13d,%rax\n  movb   $0x0,(%rsp,%rax,1)\n  mov    %rsp,%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1070 <strtol@plt>\n  mov    %rax,%r12\n  lea    0x1(%r13),%eax\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%eax\n  test   %al,%al\n  je     12d8 <func0+0x19f>\n  mov    $0x1,%edx\n  lea    0x6f(%rsp),%rsi\n  movslq %r13d,%r13\n  add    %r13,%rbp\n  mov    %al,(%rsi,%rdx,1)\n  mov    %edx,%ecx\n  add    $0x1,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    11ce <func0+0x95>\n  movslq %ecx,%rcx\n  movb   $0x0,0x70(%rsp,%rcx,1)\n  lea    0x70(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1070 <strtol@plt>\n  mov    %rax,%r13\n  movzbl (%rbx),%eax\n  cmp    $0x2f,%al\n  je     12e2 <func0+0x1a9>\n  mov    $0x1,%edx\n  lea    -0x1(%rsp),%rcx\n  mov    %al,(%rcx,%rdx,1)\n  mov    %edx,%ebp\n  add    $0x1,%rdx\n  movzbl -0x1(%rbx,%rdx,1),%eax\n  cmp    $0x2f,%al\n  jne    1214 <func0+0xdb>\n  movslq %ebp,%rax\n  movb   $0x0,(%rsp,%rax,1)\n  mov    %rsp,%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1070 <strtol@plt>\n  mov    %rax,%r14\n  lea    0x1(%rbp),%eax\n  cltq\n  movzbl (%rbx,%rax,1),%eax\n  test   %al,%al\n  je     12ec <func0+0x1b3>\n  mov    $0x1,%edx\n  lea    0x6f(%rsp),%rsi\n  movslq %ebp,%rbp\n  add    %rbp,%rbx\n  mov    %al,(%rsi,%rdx,1)\n  mov    %edx,%ecx\n  add    $0x1,%rdx\n  movzbl (%rbx,%rdx,1),%eax\n  test   %al,%al\n  jne    1263 <func0+0x12a>\n  movslq %ecx,%rcx\n  movb   $0x0,0x70(%rsp,%rcx,1)\n  lea    0x70(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1070 <strtol@plt>\n  mov    %rax,%rdx\n  mov    %r14d,%eax\n  imul   %r12d,%eax\n  imul   %edx,%r13d\n  cltd\n  idiv   %r13d\n  test   %edx,%edx\n  sete   %al\n  movzbl %al,%eax\n  mov    0xd8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12f3 <func0+0x1ba>\n  add    $0xe0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x0,%r13d\n  jmp    118f <func0+0x56>\n  mov    $0x0,%ecx\n  jmp    11e0 <func0+0xa7>\n  mov    $0x0,%ebp\n  jmp    1226 <func0+0xed>\n  mov    $0x0,%ecx\n  jmp    1274 <func0+0x13b>\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xe0,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xd8(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%edx\n  cmp    $0x2f,%dl\n  je     L0\n  mov    $0x1,%eax\n  lea    -0x1(%rsp),%rcx\nL1:\n  mov    %dl,(%rcx,%rax,1)\n  mov    %eax,%r13d\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    L1\nL9:\n  movslq %r13d,%rax\n  movb   $0x0,(%rsp,%rax,1)\n  mov    %rsp,%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%r12\n  lea    0x1(%r13),%eax\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%eax\n  test   %al,%al\n  je     L2\n  mov    $0x1,%edx\n  lea    0x6f(%rsp),%rsi\n  movslq %r13d,%r13\n  add    %r13,%rbp\nL3:\n  mov    %al,(%rsi,%rdx,1)\n  mov    %edx,%ecx\n  add    $0x1,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    L3\nL10:\n  movslq %ecx,%rcx\n  movb   $0x0,0x70(%rsp,%rcx,1)\n  lea    0x70(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%r13\n  movzbl (%rbx),%eax\n  cmp    $0x2f,%al\n  je     L4\n  mov    $0x1,%edx\n  lea    -0x1(%rsp),%rcx\nL5:\n  mov    %al,(%rcx,%rdx,1)\n  mov    %edx,%ebp\n  add    $0x1,%rdx\n  movzbl -0x1(%rbx,%rdx,1),%eax\n  cmp    $0x2f,%al\n  jne    L5\nL11:\n  movslq %ebp,%rax\n  movb   $0x0,(%rsp,%rax,1)\n  mov    %rsp,%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%r14\n  lea    0x1(%rbp),%eax\n  cltq\n  movzbl (%rbx,%rax,1),%eax\n  test   %al,%al\n  je     L6\n  mov    $0x1,%edx\n  lea    0x6f(%rsp),%rsi\n  movslq %ebp,%rbp\n  add    %rbp,%rbx\nL7:\n  mov    %al,(%rsi,%rdx,1)\n  mov    %edx,%ecx\n  add    $0x1,%rdx\n  movzbl (%rbx,%rdx,1),%eax\n  test   %al,%al\n  jne    L7\nL12:\n  movslq %ecx,%rcx\n  movb   $0x0,0x70(%rsp,%rcx,1)\n  lea    0x70(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%rdx\n  mov    %r14d,%eax\n  imul   %r12d,%eax\n  imul   %edx,%r13d\n  cltd\n  idiv   %r13d\n  test   %edx,%edx\n  sete   %al\n  movzbl %al,%eax\n  mov    0xd8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L8\n  add    $0xe0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  mov    $0x0,%r13d\n  jmp    L9\nL2:\n  mov    $0x0,%ecx\n  jmp    L10\nL4:\n  mov    $0x0,%ebp\n  jmp    L11\nL6:\n  mov    $0x0,%ecx\n  jmp    L12\nL8:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4813
        },
        "L1": {
          "label": "L1",
          "addr": 4475
        },
        "L2": {
          "label": "L2",
          "addr": 4824
        },
        "L3": {
          "label": "L3",
          "addr": 4558
        },
        "L4": {
          "label": "L4",
          "addr": 4834
        },
        "L5": {
          "label": "L5",
          "addr": 4628
        },
        "L6": {
          "label": "L6",
          "addr": 4844
        },
        "L7": {
          "label": "L7",
          "addr": 4707
        },
        "L8": {
          "label": "L8",
          "addr": 4851
        },
        "L9": {
          "label": "L9",
          "addr": 4495
        },
        "L10": {
          "label": "L10",
          "addr": 4576
        },
        "L11": {
          "label": "L11",
          "addr": 4646
        },
        "L12": {
          "label": "L12",
          "addr": 4724
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *a, char *b) {\n  int i = 0;\n  int j = 0;\n  char buf[100];\n  char buf2[100];\n  while (a[i] != '/') {\n    buf[i] = a[i];\n    i++;\n  }\n  buf[i] = '\\0';\n  int num = (int)strtol(buf, (char **)0, 10);\n  while (a[i + 1] != '\\0') {\n    buf2[j] = a[i + 1];\n    i++;\n    j++;\n  }\n  buf2[j] = '\\0';\n  int num2 = (int)strtol(buf2, (char **)0, 10);\n  i = 0;\n  j = 0;\n  while (b[i] != '/') {\n    buf[i] = b[i];\n    i++;\n  }\n  buf[i] = '\\0';\n  int num3 = (int)strtol(buf, (char **)0, 10);\n  while (b[i + 1] != '\\0') {\n    buf2[j] = b[i + 1];\n    i++;\n    j++;\n  }\n  buf2[j] = '\\0';\n  int num4 = (int)strtol(buf2, (char **)0, 10);\n  int num5 = num * num3;\n  int num6 = num2 * num4;\n  int num7 = num5 % num6;\n  if (num7 == 0)\n    return 1;\n  else\n    return 0;\n}"
    },
    {
      "task_id": 145,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  movslq %esi,%rdi\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x38,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  call   10c0 <malloc@plt>\n  mov    %rax,(%rsp)\n  test   %ebx,%ebx\n  jle    1358 <func0+0x1b8>\n  mov    %rax,%rbp\n  lea    -0x1(%rbx),%eax\n  mov    %r12,%r15\n  lea    0x4(%r12,%rax,4),%rax\n  lea    0x1c(%rsp),%r13\n  mov    %rax,0x8(%rsp)\n  lea    0xe01(%rip),%r14        # 2000 <_fini+0xc78>\n  jmp    12b5 <func0+0x115>\n  nopl   0x0(%rax)\n  movsbl 0x1d(%rsp),%eax\n  sub    $0x30,%eax\n  cmp    $0x2,%edx\n  je     128e <func0+0xee>\n  movsbl 0x1e(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x3,%edx\n  je     128e <func0+0xee>\n  movsbl 0x1f(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x4,%edx\n  je     128e <func0+0xee>\n  movsbl 0x20(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x5,%edx\n  je     128e <func0+0xee>\n  movsbl 0x21(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x6,%edx\n  je     128e <func0+0xee>\n  movsbl 0x22(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x7,%edx\n  je     128e <func0+0xee>\n  movsbl 0x23(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x8,%edx\n  je     128e <func0+0xee>\n  movsbl 0x24(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x9,%edx\n  je     128e <func0+0xee>\n  movsbl 0x25(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0xb,%edx\n  jne    128e <func0+0xee>\n  movsbl 0x26(%rsp),%edx\n  lea    -0x30(%rax,%rdx,1),%eax\n  movsbl 0x1c(%rsp),%edx\n  sub    $0x30,%edx\n  lea    (%rax,%rdx,1),%ecx\n  sub    %edx,%eax\n  mov    (%r15),%edx\n  test   %edx,%edx\n  cmovg  %ecx,%eax\n  add    $0x4,%r15\n  add    $0x4,%rbp\n  mov    %eax,-0x4(%rbp)\n  cmp    %r15,0x8(%rsp)\n  je     12f8 <func0+0x158>\n  mov    (%r15),%eax\n  mov    $0xc,%edx\n  mov    %r14,%rcx\n  mov    $0x1,%esi\n  mov    %r13,%rdi\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  xor    %eax,%eax\n  call   10d0 <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   10a0 <strlen@plt>\n  mov    %rax,%rdx\n  cmp    $0x1,%rax\n  ja     1208 <func0+0x68>\n  xor    %eax,%eax\n  jmp    128e <func0+0xee>\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x1,%ebx\n  je     1358 <func0+0x1b8>\n  mov    (%rsp),%rdi\n  lea    -0x2(%rbx),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%rdi\n  nopl   0x0(%rax)\n  mov    (%rsp),%rdx\n  mov    %r12,%rcx\n  nopw   0x0(%rax,%rax,1)\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%eax\n  movd   %xmm2,%esi\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%esi\n  jge    1342 <func0+0x1a2>\n  movq   %xmm1,(%rdx)\n  rolq   $0x20,(%rcx)\n  add    $0x4,%rdx\n  add    $0x4,%rcx\n  cmp    %rdx,%rdi\n  jne    1320 <func0+0x180>\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jne    1310 <func0+0x170>\n  mov    (%rsp),%rdi\n  call   1090 <free@plt>\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1383 <func0+0x1e3>\n  add    $0x38,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10b0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  movslq %esi,%rdi\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x38,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  call   <malloc@plt>\n  mov    %rax,(%rsp)\n  test   %ebx,%ebx\n  jle    L0\n  mov    %rax,%rbp\n  lea    -0x1(%rbx),%eax\n  mov    %r12,%r15\n  lea    0x4(%r12,%rax,4),%rax\n  lea    0x1c(%rsp),%r13\n  mov    %rax,0x8(%rsp)\n  lea    D0(%rip),%r14\n  jmp    L1\n  nopl   0x0(%rax)\nL4:\n  movsbl 0x1d(%rsp),%eax\n  sub    $0x30,%eax\n  cmp    $0x2,%edx\n  je     L2\n  movsbl 0x1e(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x3,%edx\n  je     L2\n  movsbl 0x1f(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x4,%edx\n  je     L2\n  movsbl 0x20(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x5,%edx\n  je     L2\n  movsbl 0x21(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x6,%edx\n  je     L2\n  movsbl 0x22(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x7,%edx\n  je     L2\n  movsbl 0x23(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x8,%edx\n  je     L2\n  movsbl 0x24(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x9,%edx\n  je     L2\n  movsbl 0x25(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0xb,%edx\n  jne    L2\n  movsbl 0x26(%rsp),%edx\n  lea    -0x30(%rax,%rdx,1),%eax\nL2:\n  movsbl 0x1c(%rsp),%edx\n  sub    $0x30,%edx\n  lea    (%rax,%rdx,1),%ecx\n  sub    %edx,%eax\n  mov    (%r15),%edx\n  test   %edx,%edx\n  cmovg  %ecx,%eax\n  add    $0x4,%r15\n  add    $0x4,%rbp\n  mov    %eax,-0x4(%rbp)\n  cmp    %r15,0x8(%rsp)\n  je     L3\nL1:\n  mov    (%r15),%eax\n  mov    $0xc,%edx\n  mov    %r14,%rcx\n  mov    $0x1,%esi\n  mov    %r13,%rdi\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  xor    %eax,%eax\n  call   <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rdx\n  cmp    $0x1,%rax\n  ja     L4\n  xor    %eax,%eax\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL3:\n  cmp    $0x1,%ebx\n  je     L0\n  mov    (%rsp),%rdi\n  lea    -0x2(%rbx),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%rdi\n  nopl   0x0(%rax)\nL7:\n  mov    (%rsp),%rdx\n  mov    %r12,%rcx\n  nopw   0x0(%rax,%rax,1)\nL6:\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%eax\n  movd   %xmm2,%esi\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%esi\n  jge    L5\n  movq   %xmm1,(%rdx)\n  rolq   $0x20,(%rcx)\nL5:\n  add    $0x4,%rdx\n  add    $0x4,%rcx\n  cmp    %rdx,%rdi\n  jne    L6\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jne    L7\nL0:\n  mov    (%rsp),%rdi\n  call   <free@plt>\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L8\n  add    $0x38,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3585
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4952
        },
        "L1": {
          "label": "L1",
          "addr": 4789
        },
        "L2": {
          "label": "L2",
          "addr": 4750
        },
        "L3": {
          "label": "L3",
          "addr": 4856
        },
        "L4": {
          "label": "L4",
          "addr": 4616
        },
        "L5": {
          "label": "L5",
          "addr": 4930
        },
        "L6": {
          "label": "L6",
          "addr": 4896
        },
        "L7": {
          "label": "L7",
          "addr": 4880
        },
        "L8": {
          "label": "L8",
          "addr": 4995
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int *a, int n) {\n  int *b = (int *)malloc(n * sizeof(int));\n  int i, j, k, t;\n  char buf[12];\n  for (i = 0; i < n; i++) {\n    __sprintf_chk(buf, 1, sizeof(buf), \"%d\", abs(a[i]));\n    t = 0;\n    for (j = 0; j < strlen(buf); j++)\n      t += buf[j] - '0';\n    if (a[i] > 0)\n      b[i] = t;\n    else\n      b[i] = -t;\n  }\n  for (i = 0; i < n; i++)\n    for (j = 0; j < n - i - 1; j++)\n      if (b[j] > b[j + 1]) {\n        t = b[j];\n        b[j] = b[j + 1];\n        b[j + 1] = t;\n        t = a[j];\n        a[j] = a[j + 1];\n        a[j + 1] = t;\n      }\n  free(b);\n  return a;\n}"
    },
    {
      "task_id": 145,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%rbx\n  mov    %rdi,(%rsp)\n  mov    %esi,%r13d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%r15\n  test   %r13d,%r13d\n  jle    12e1 <func0+0x148>\n  lea    -0x1(%r13),%eax\n  lea    0x4(%rbx,%rax,4),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %r15,%rbp\n  jmp    1213 <func0+0x7a>\n  mov    $0x0,%eax\n  jmp    1274 <func0+0xdb>\n  movsbl 0x1c(%rsp),%edx\n  sub    $0x30,%edx\n  sub    %edx,%eax\n  mov    %eax,0x0(%rbp)\n  add    $0x4,%rbx\n  add    $0x4,%rbp\n  cmp    0x8(%rsp),%rbx\n  je     128c <func0+0xf3>\n  mov    %rbx,%r14\n  lea    0x1c(%rsp),%r12\n  mov    (%rbx),%eax\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  lea    0xdd2(%rip),%rcx        # 2000 <_fini+0xcec>\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    %r12,%rdi\n  mov    $0x0,%eax\n  call   10d0 <__sprintf_chk@plt>\n  mov    %r12,%rdi\n  call   10a0 <strlen@plt>\n  cmp    $0x1,%eax\n  jle    11f0 <func0+0x57>\n  lea    0x1d(%rsp),%rdx\n  lea    -0x2(%rax),%eax\n  lea    0x1e(%rsp,%rax,1),%rsi\n  mov    $0x0,%eax\n  movsbl (%rdx),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    1264 <func0+0xcb>\n  cmpl   $0x0,(%r14)\n  jle    11f7 <func0+0x5e>\n  movsbl 0x1c(%rsp),%edx\n  lea    -0x30(%rax,%rdx,1),%eax\n  jmp    1201 <func0+0x68>\n  lea    -0x2(%r13),%eax\n  lea    0x8(%r15,%rax,4),%rdi\n  mov    $0x0,%r8d\n  jmp    12cd <func0+0x134>\n  add    $0x4,%rax\n  add    $0x4,%rdx\n  cmp    %rdi,%rax\n  je     12c4 <func0+0x12b>\n  mov    -0x4(%rax),%esi\n  mov    (%rax),%ecx\n  cmp    %ecx,%esi\n  jle    129d <func0+0x104>\n  mov    %esi,(%rax)\n  mov    %ecx,-0x4(%rax)\n  mov    (%rdx),%ecx\n  mov    -0x4(%rdx),%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,-0x4(%rdx)\n  jmp    129d <func0+0x104>\n  add    $0x1,%r8d\n  cmp    %r8d,%r13d\n  je     12e1 <func0+0x148>\n  lea    0x4(%r15),%rax\n  mov    (%rsp),%rbx\n  lea    0x4(%rbx),%rdx\n  cmp    $0x1,%r13d\n  jg     12aa <func0+0x111>\n  jmp    12c4 <func0+0x12b>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    130c <func0+0x173>\n  mov    (%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10b0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%rbx\n  mov    %rdi,(%rsp)\n  mov    %esi,%r13d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r15\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%eax\n  lea    0x4(%rbx,%rax,4),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %r15,%rbp\n  jmp    L1\nL4:\n  mov    $0x0,%eax\n  jmp    L2\nL6:\n  movsbl 0x1c(%rsp),%edx\n  sub    $0x30,%edx\n  sub    %edx,%eax\nL7:\n  mov    %eax,0x0(%rbp)\n  add    $0x4,%rbx\n  add    $0x4,%rbp\n  cmp    0x8(%rsp),%rbx\n  je     L3\nL1:\n  mov    %rbx,%r14\n  lea    0x1c(%rsp),%r12\n  mov    (%rbx),%eax\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  lea    D0(%rip),%rcx\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    %r12,%rdi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\n  mov    %r12,%rdi\n  call   <strlen@plt>\n  cmp    $0x1,%eax\n  jle    L4\n  lea    0x1d(%rsp),%rdx\n  lea    -0x2(%rax),%eax\n  lea    0x1e(%rsp,%rax,1),%rsi\n  mov    $0x0,%eax\nL5:\n  movsbl (%rdx),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    L5\nL2:\n  cmpl   $0x0,(%r14)\n  jle    L6\n  movsbl 0x1c(%rsp),%edx\n  lea    -0x30(%rax,%rdx,1),%eax\n  jmp    L7\nL3:\n  lea    -0x2(%r13),%eax\n  lea    0x8(%r15,%rax,4),%rdi\n  mov    $0x0,%r8d\n  jmp    L8\nL10:\n  add    $0x4,%rax\n  add    $0x4,%rdx\n  cmp    %rdi,%rax\n  je     L9\nL11:\n  mov    -0x4(%rax),%esi\n  mov    (%rax),%ecx\n  cmp    %ecx,%esi\n  jle    L10\n  mov    %esi,(%rax)\n  mov    %ecx,-0x4(%rax)\n  mov    (%rdx),%ecx\n  mov    -0x4(%rdx),%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,-0x4(%rdx)\n  jmp    L10\nL9:\n  add    $0x1,%r8d\n  cmp    %r8d,%r13d\n  je     L0\nL8:\n  lea    0x4(%r15),%rax\n  mov    (%rsp),%rbx\n  lea    0x4(%rbx),%rdx\n  cmp    $0x1,%r13d\n  jg     L11\n  jmp    L9\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L12\n  mov    (%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL12:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3538
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4833
        },
        "L1": {
          "label": "L1",
          "addr": 4627
        },
        "L2": {
          "label": "L2",
          "addr": 4724
        },
        "L3": {
          "label": "L3",
          "addr": 4748
        },
        "L4": {
          "label": "L4",
          "addr": 4592
        },
        "L5": {
          "label": "L5",
          "addr": 4708
        },
        "L6": {
          "label": "L6",
          "addr": 4599
        },
        "L7": {
          "label": "L7",
          "addr": 4609
        },
        "L8": {
          "label": "L8",
          "addr": 4813
        },
        "L9": {
          "label": "L9",
          "addr": 4804
        },
        "L10": {
          "label": "L10",
          "addr": 4765
        },
        "L11": {
          "label": "L11",
          "addr": 4778
        },
        "L12": {
          "label": "L12",
          "addr": 4876
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int *func0(int *a, int n) {\n  int i, j, k, t, *b;\n  char buf[12], c;\n  b = (int *)malloc(n * sizeof(int));\n  for (i = 0; i < n; i++) {\n    t = abs(a[i]);\n    __sprintf_chk(buf, 1, sizeof(buf), \"%d\", t);\n    k = 0;\n    for (j = 1; j < strlen(buf); j++) {\n      c = buf[j];\n      k += c - '0';\n    }\n    if (a[i] > 0)\n      b[i] = k + buf[0] - '0';\n    else\n      b[i] = k - (buf[0] - '0');\n  }\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n - 1; j++) {\n      if (b[j] > b[j + 1]) {\n        t = b[j];\n        b[j] = b[j + 1];\n        b[j + 1] = t;\n        t = a[j];\n        a[j] = a[j + 1];\n        a[j + 1] = t;\n      }\n    }\n  }\n  free(b);\n  return a;\n}"
    },
    {
      "task_id": 145,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,(%rsp)\n  movslq %esi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   10c0 <malloc@plt>\n  mov    %rax,%r12\n  test   %ebx,%ebx\n  jle    12fe <func0+0x15e>\n  lea    0x4(%r14),%rdi\n  lea    -0x1(%rbx),%eax\n  mov    %r12,0x10(%rsp)\n  mov    %r14,%r13\n  lea    (%rdi,%rax,4),%rax\n  mov    %rdi,0x8(%rsp)\n  lea    0x2e(%rsp),%rdi\n  mov    %ebx,0x1c(%rsp)\n  lea    0x2c(%rsp),%rbp\n  mov    %r13,%rbx\n  mov    %rdi,%r15\n  lea    0xdea(%rip),%r14        # 2000 <_fini+0xcc4>\n  mov    %rax,%r13\n  nopl   0x0(%rax)\n  mov    (%rbx),%eax\n  mov    %rbp,%rdi\n  mov    %r14,%rcx\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  xor    %eax,%eax\n  call   10d0 <__sprintf_chk@plt>\n  mov    %rbp,%rdi\n  call   10a0 <strlen@plt>\n  cmp    $0x1,%rax\n  jbe    1330 <func0+0x190>\n  lea    -0x2(%rax),%esi\n  lea    0x2d(%rsp),%rdx\n  xor    %eax,%eax\n  add    %r15,%rsi\n  nopw   0x0(%rax,%rax,1)\n  movsbl (%rdx),%ecx\n  add    $0x1,%rdx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    %rsi,%rdx\n  jne    1268 <func0+0xc8>\n  movsbl 0x2c(%rsp),%edx\n  sub    $0x30,%edx\n  lea    (%rax,%rdx,1),%ecx\n  sub    %edx,%eax\n  mov    (%rbx),%edx\n  test   %edx,%edx\n  cmovg  %ecx,%eax\n  add    $0x4,%rbx\n  add    $0x4,%r12\n  mov    %eax,-0x4(%r12)\n  cmp    %r13,%rbx\n  jne    1220 <func0+0x80>\n  mov    0x1c(%rsp),%ebx\n  mov    0x10(%rsp),%r12\n  xor    %r8d,%r8d\n  mov    0x8(%rsp),%r9\n  lea    -0x2(%rbx),%eax\n  lea    0x8(%r12,%rax,4),%rdi\n  nopw   0x0(%rax,%rax,1)\n  lea    0x4(%r12),%rax\n  mov    %r9,%rdx\n  cmp    $0x1,%ebx\n  je     12f5 <func0+0x155>\n  nopl   (%rax)\n  mov    -0x4(%rax),%esi\n  mov    (%rax),%ecx\n  cmp    %ecx,%esi\n  jle    12e8 <func0+0x148>\n  mov    %esi,(%rax)\n  mov    -0x4(%rdx),%esi\n  mov    %ecx,-0x4(%rax)\n  mov    (%rdx),%ecx\n  mov    %esi,(%rdx)\n  mov    %ecx,-0x4(%rdx)\n  add    $0x4,%rax\n  add    $0x4,%rdx\n  cmp    %rax,%rdi\n  jne    12d0 <func0+0x130>\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jne    12c0 <func0+0x120>\n  mov    %r12,%rdi\n  call   1090 <free@plt>\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1337 <func0+0x197>\n  mov    (%rsp),%rax\n  add    $0x48,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  jmp    1278 <func0+0xd8>\n  call   10b0 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,(%rsp)\n  movslq %esi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <malloc@plt>\n  mov    %rax,%r12\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x4(%r14),%rdi\n  lea    -0x1(%rbx),%eax\n  mov    %r12,0x10(%rsp)\n  mov    %r14,%r13\n  lea    (%rdi,%rax,4),%rax\n  mov    %rdi,0x8(%rsp)\n  lea    0x2e(%rsp),%rdi\n  mov    %ebx,0x1c(%rsp)\n  lea    0x2c(%rsp),%rbp\n  mov    %r13,%rbx\n  mov    %rdi,%r15\n  lea    D0(%rip),%r14\n  mov    %rax,%r13\n  nopl   0x0(%rax)\nL3:\n  mov    (%rbx),%eax\n  mov    %rbp,%rdi\n  mov    %r14,%rcx\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  xor    %eax,%eax\n  call   <__sprintf_chk@plt>\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  cmp    $0x1,%rax\n  jbe    L1\n  lea    -0x2(%rax),%esi\n  lea    0x2d(%rsp),%rdx\n  xor    %eax,%eax\n  add    %r15,%rsi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movsbl (%rdx),%ecx\n  add    $0x1,%rdx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    %rsi,%rdx\n  jne    L2\nL9:\n  movsbl 0x2c(%rsp),%edx\n  sub    $0x30,%edx\n  lea    (%rax,%rdx,1),%ecx\n  sub    %edx,%eax\n  mov    (%rbx),%edx\n  test   %edx,%edx\n  cmovg  %ecx,%eax\n  add    $0x4,%rbx\n  add    $0x4,%r12\n  mov    %eax,-0x4(%r12)\n  cmp    %r13,%rbx\n  jne    L3\n  mov    0x1c(%rsp),%ebx\n  mov    0x10(%rsp),%r12\n  xor    %r8d,%r8d\n  mov    0x8(%rsp),%r9\n  lea    -0x2(%rbx),%eax\n  lea    0x8(%r12,%rax,4),%rdi\n  nopw   0x0(%rax,%rax,1)\nL7:\n  lea    0x4(%r12),%rax\n  mov    %r9,%rdx\n  cmp    $0x1,%ebx\n  je     L4\n  nopl   (%rax)\nL6:\n  mov    -0x4(%rax),%esi\n  mov    (%rax),%ecx\n  cmp    %ecx,%esi\n  jle    L5\n  mov    %esi,(%rax)\n  mov    -0x4(%rdx),%esi\n  mov    %ecx,-0x4(%rax)\n  mov    (%rdx),%ecx\n  mov    %esi,(%rdx)\n  mov    %ecx,-0x4(%rdx)\nL5:\n  add    $0x4,%rax\n  add    $0x4,%rdx\n  cmp    %rax,%rdi\n  jne    L6\nL4:\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jne    L7\nL0:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L8\n  mov    (%rsp),%rax\n  add    $0x48,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL1:\n  xor    %eax,%eax\n  jmp    L9\nL8:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3562
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4862
        },
        "L1": {
          "label": "L1",
          "addr": 4912
        },
        "L2": {
          "label": "L2",
          "addr": 4712
        },
        "L3": {
          "label": "L3",
          "addr": 4640
        },
        "L4": {
          "label": "L4",
          "addr": 4853
        },
        "L5": {
          "label": "L5",
          "addr": 4840
        },
        "L6": {
          "label": "L6",
          "addr": 4816
        },
        "L7": {
          "label": "L7",
          "addr": 4800
        },
        "L8": {
          "label": "L8",
          "addr": 4919
        },
        "L9": {
          "label": "L9",
          "addr": 4728
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "256400",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%d\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int *func0(int *a, int size) {\n  int *b = (int *)malloc(size * sizeof(int));\n  int i, j, k, temp, temp1, temp2, temp3, temp4, temp5;\n  char str[12];\n  for (i = 0; i < size; i++) {\n    temp = abs(a[i]);\n    __sprintf_chk(str, 1, sizeof(str), \"%d\", temp);\n    temp2 = strlen(str);\n    temp3 = 0;\n    for (j = 1; j < temp2; j++) {\n      temp3 += str[j] - '0';\n    }\n    temp4 = str[0] - '0';\n    if (a[i] > 0)\n      b[i] = temp3 + temp4;\n    else\n      b[i] = temp3 - temp4;\n  }\n  for (i = 0; i < size; i++) {\n    for (j = i + 1; j < size; j++) {\n      if (b[i] > b[j]) {\n        temp = b[j];\n        b[j] = b[i];\n        b[i] = temp;\n        temp1 = a[j];\n        a[j] = a[i];\n        a[i] = temp1;\n      }\n    }\n  }\n  free(b);\n  return a;\n}"
    },
    {
      "task_id": 150,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %edx,-0x1c(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  cmpl   $0x1,-0x14(%rbp)\n  jg     111e <func0+0x25>\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    113f <func0+0x46>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    113b <func0+0x42>\n  movl   $0x0,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    1127 <func0+0x2e>\n  cmpl   $0x0,-0x8(%rbp)\n  je     1155 <func0+0x5c>\n  mov    -0x18(%rbp),%eax\n  jmp    1158 <func0+0x5f>\n  mov    -0x1c(%rbp),%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %edx,-0x1c(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  cmpl   $0x1,-0x14(%rbp)\n  jg     L0\n  movl   $0x0,-0x8(%rbp)\nL0:\n  movl   $0x2,-0x4(%rbp)\n  jmp    L1\nL3:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L2\n  movl   $0x0,-0x8(%rbp)\nL2:\n  addl   $0x1,-0x4(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L3\n  cmpl   $0x0,-0x8(%rbp)\n  je     L4\n  mov    -0x18(%rbp),%eax\n  jmp    L5\nL4:\n  mov    -0x1c(%rbp),%eax\nL5:\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4382
        },
        "L1": {
          "label": "L1",
          "addr": 4415
        },
        "L2": {
          "label": "L2",
          "addr": 4411
        },
        "L3": {
          "label": "L3",
          "addr": 4391
        },
        "L4": {
          "label": "L4",
          "addr": 4437
        },
        "L5": {
          "label": "L5",
          "addr": 4440
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x, int y, int z) {\n  int i, flag = 1;\n  if (x <= 1)\n    flag = 0;\n  for (i = 2; i * i <= x; i++)\n    if (x % i == 0)\n      flag = 0;\n  if (flag)\n    return y;\n  else\n    return z;\n}"
    },
    {
      "task_id": 150,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  cmp    $0x1,%edi\n  mov    %edx,%r10d\n  setg   %r8b\n  cmp    $0x3,%edi\n  jle    1137 <func0+0x37>\n  mov    $0x2,%ecx\n  xor    %r9d,%r9d\n  xchg   %ax,%ax\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %r9d,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1120 <func0+0x20>\n  test   %r8d,%r8d\n  cmovne %esi,%r10d\n  mov    %r10d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  cmp    $0x1,%edi\n  mov    %edx,%r10d\n  setg   %r8b\n  cmp    $0x3,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  xor    %r9d,%r9d\n  xchg   %ax,%ax\nL1:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %r9d,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L1\nL0:\n  test   %r8d,%r8d\n  cmovne %esi,%r10d\n  mov    %r10d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4407
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int x, int y, int z) {\n  int i, flag = 0;\n  if (x > 1)\n    flag = 1;\n  for (i = 2; i * i <= x; i++)\n    if (x % i == 0)\n      flag = 0;\n  if (flag)\n    return y;\n  else\n    return z;\n}"
    },
    {
      "task_id": 150,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  cmp    $0x1,%edi\n  mov    %edx,%r10d\n  setg   %r8b\n  cmp    $0x3,%edi\n  jle    1137 <func0+0x37>\n  mov    $0x2,%ecx\n  xor    %r9d,%r9d\n  xchg   %ax,%ax\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %r9d,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %eax,%edi\n  jge    1120 <func0+0x20>\n  test   %r8d,%r8d\n  cmovne %esi,%r10d\n  mov    %r10d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  cmp    $0x1,%edi\n  mov    %edx,%r10d\n  setg   %r8b\n  cmp    $0x3,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  xor    %r9d,%r9d\n  xchg   %ax,%ax\nL1:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %r9d,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %eax,%edi\n  jge    L1\nL0:\n  test   %r8d,%r8d\n  cmovne %esi,%r10d\n  mov    %r10d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4407
        },
        "L1": {
          "label": "L1",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(int a, int b, int c) {\n  int i, flag = 0;\n  if (a > 1)\n    flag = 1;\n  for (i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      flag = 0;\n  if (flag)\n    return b;\n  else\n    return c;\n}"
    },
    {
      "task_id": 149,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    -0x48(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x28(%rbp)\n  jmp    11ef <func0+0x96>\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  and    $0x1,%eax\n  test   %rax,%rax\n  jne    11eb <func0+0x92>\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%rax\n  mov    %rax,(%rdx)\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x48(%rbp),%rax\n  mov    %edx,(%rax)\n  addl   $0x1,-0x28(%rbp)\n  mov    -0x28(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     1183 <func0+0x2a>\n  movl   $0x0,-0x28(%rbp)\n  jmp    133c <func0+0x1e3>\n  movl   $0x0,-0x24(%rbp)\n  jmp    1323 <func0+0x1ca>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  cmp    -0x10(%rbp),%rax\n  ja     12b2 <func0+0x159>\n  mov    -0x18(%rbp),%rax\n  cmp    -0x10(%rbp),%rax\n  jne    131f <func0+0x1c6>\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  jle    131f <func0+0x1c6>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x24(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  sub    -0x28(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x24(%rbp)\n  jl     120f <func0+0xb6>\n  addl   $0x1,-0x28(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x28(%rbp)\n  jl     1203 <func0+0xaa>\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  jmp    13a2 <func0+0x249>\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x28(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x28(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x28(%rbp)\n  jl     136f <func0+0x216>\n  mov    -0x20(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    -0x48(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x28(%rbp)\n  jmp    L0\nL2:\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  and    $0x1,%eax\n  test   %rax,%rax\n  jne    L1\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%rax\n  mov    %rax,(%rdx)\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x48(%rbp),%rax\n  mov    %edx,(%rax)\nL1:\n  addl   $0x1,-0x28(%rbp)\nL0:\n  mov    -0x28(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L2\n  movl   $0x0,-0x28(%rbp)\n  jmp    L3\nL8:\n  movl   $0x0,-0x24(%rbp)\n  jmp    L4\nL7:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  cmp    -0x10(%rbp),%rax\n  ja     L5\n  mov    -0x18(%rbp),%rax\n  cmp    -0x10(%rbp),%rax\n  jne    L6\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jle    L6\nL5:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x24(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rax,(%rdx)\nL6:\n  addl   $0x1,-0x24(%rbp)\nL4:\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  sub    -0x28(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x24(%rbp)\n  jl     L7\n  addl   $0x1,-0x28(%rbp)\nL3:\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x28(%rbp)\n  jl     L8\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  jmp    L9\nL10:\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x28(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x28(%rbp)\nL9:\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x28(%rbp)\n  jl     L10\n  mov    -0x20(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4591
        },
        "L1": {
          "label": "L1",
          "addr": 4587
        },
        "L2": {
          "label": "L2",
          "addr": 4483
        },
        "L3": {
          "label": "L3",
          "addr": 4924
        },
        "L4": {
          "label": "L4",
          "addr": 4899
        },
        "L5": {
          "label": "L5",
          "addr": 4786
        },
        "L6": {
          "label": "L6",
          "addr": 4895
        },
        "L7": {
          "label": "L7",
          "addr": 4623
        },
        "L8": {
          "label": "L8",
          "addr": 4611
        },
        "L9": {
          "label": "L9",
          "addr": 5026
        },
        "L10": {
          "label": "L10",
          "addr": 4975
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **x, int n, int *ret_n) {\n  int i, j;\n  char **ret;\n  *ret_n = 0;\n  for (i = 0; i < n; i++)\n    if (strlen(x[i]) % 2 == 0) {\n      x[*ret_n] = x[i];\n      (*ret_n)++;\n    }\n  for (i = 0; i < *ret_n - 1; i++)\n    for (j = 0; j < *ret_n - i - 1; j++) {\n      size_t len0 = strlen(x[j]);\n      size_t len1 = strlen(x[j + 1]);\n      if (len0 > len1 || (len0 == len1 && strcmp(x[j], x[j + 1]) > 0)) {\n        char *tmp = x[j];\n        x[j] = x[j + 1];\n        x[j + 1] = tmp;\n      }\n    }\n  ret = malloc(sizeof(char *) * (*ret_n));\n  for (i = 0; i < *ret_n; i++)\n    ret[i] = x[i];\n  return ret;\n}"
    },
    {
      "task_id": 151,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movq   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    129b <func0+0x182>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  movsd  %xmm2,-0x38(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm3,%xmm3\n  cvtss2sd %xmm0,%xmm3\n  movq   %xmm3,%rax\n  movq   %rax,%xmm0\n  call   1050 <round@plt>\n  movapd %xmm0,%xmm1\n  movsd  -0x38(%rbp),%xmm0\n  subsd  %xmm1,%xmm0\n  movq   0xe56(%rip),%xmm1        # 2000 <_fini+0xd4c>\n  andpd  %xmm0,%xmm1\n  movsd  0xe5a(%rip),%xmm0        # 2010 <_fini+0xd5c>\n  comisd %xmm1,%xmm0\n  jbe    1297 <func0+0x17e>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1297 <func0+0x17e>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm4,%xmm4\n  cvtss2sd %xmm0,%xmm4\n  movq   %xmm4,%rax\n  movq   %rax,%xmm0\n  call   1050 <round@plt>\n  cvttsd2si %xmm0,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1297 <func0+0x17e>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm5,%xmm5\n  cvtss2sd %xmm0,%xmm5\n  movq   %xmm5,%rax\n  movq   %rax,%xmm0\n  call   1050 <round@plt>\n  cvttsd2si %xmm0,%ebx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm6,%xmm6\n  cvtss2sd %xmm0,%xmm6\n  movq   %xmm6,%rax\n  movq   %rax,%xmm0\n  call   1050 <round@plt>\n  cvttsd2si %xmm0,%eax\n  imul   %ebx,%eax\n  cltq\n  add    %rax,-0x18(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1141 <func0+0x28>\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movq   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL2:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  movsd  %xmm2,-0x38(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm3,%xmm3\n  cvtss2sd %xmm0,%xmm3\n  movq   %xmm3,%rax\n  movq   %rax,%xmm0\n  call   <round@plt>\n  movapd %xmm0,%xmm1\n  movsd  -0x38(%rbp),%xmm0\n  subsd  %xmm1,%xmm0\n  movq   D0(%rip),%xmm1\n  andpd  %xmm0,%xmm1\n  movsd  D1(%rip),%xmm0\n  comisd %xmm1,%xmm0\n  jbe    L1\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L1\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm4,%xmm4\n  cvtss2sd %xmm0,%xmm4\n  movq   %xmm4,%rax\n  movq   %rax,%xmm0\n  call   <round@plt>\n  cvttsd2si %xmm0,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm5,%xmm5\n  cvtss2sd %xmm0,%xmm5\n  movq   %xmm5,%rax\n  movq   %rax,%xmm0\n  call   <round@plt>\n  cvttsd2si %xmm0,%ebx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm6,%xmm6\n  cvtss2sd %xmm0,%xmm6\n  movq   %xmm6,%rax\n  movq   %rax,%xmm0\n  call   <round@plt>\n  cvttsd2si %xmm0,%eax\n  imul   %ebx,%eax\n  cltq\n  add    %rax,-0x18(%rbp)\nL1:\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L2\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3670
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3674
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4763
        },
        "L1": {
          "label": "L1",
          "addr": 4759
        },
        "L2": {
          "label": "L2",
          "addr": 4417
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffffffffffff7f00000000000000002d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "qword",
            "value": 9223372036854775807
          },
          "0x2010": {
            "type": "byte[8]",
            "value": [
              45,
              67,
              28,
              235,
              226,
              54,
              26,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " long func0(float *x, int n) {\n  long sum = 0;\n  for (int i = 0; i < n; i++) {\n    if (fabs(x[i] - round(x[i])) < 0.0001 && x[i] > 0 && (int)round(x[i]) % 2 == 1) {\n      sum += (int)round(x[i]) * (int)round(x[i]);\n    }\n  }\n  return sum;\n}"
    },
    {
      "task_id": 149,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  mov    %rdx,%r15\n  movl   $0x0,(%rdx)\n  test   %esi,%esi\n  jle    123b <func0+0xe2>\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r13\n  jmp    1195 <func0+0x3c>\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  je     11b1 <func0+0x58>\n  mov    (%rbx),%rbp\n  mov    %rbp,%rdi\n  call   1070 <strlen@plt>\n  test   $0x1,%al\n  jne    118c <func0+0x33>\n  movslq (%r15),%rax\n  mov    %rbp,(%r12,%rax,8)\n  addl   $0x1,(%r15)\n  jmp    118c <func0+0x33>\n  mov    (%r15),%eax\n  cmp    $0x1,%eax\n  jle    1240 <func0+0xe7>\n  movl   $0x0,0xc(%rsp)\n  jmp    1228 <func0+0xcf>\n  mov    %r14,(%r12,%rbx,8)\n  mov    %r13,0x8(%r12,%rbx,8)\n  add    $0x1,%rbx\n  mov    0xc(%rsp),%eax\n  not    %eax\n  add    (%r15),%eax\n  cmp    %ebx,%eax\n  jle    1215 <func0+0xbc>\n  mov    (%r12,%rbx,8),%r13\n  mov    %r13,%rdi\n  call   1070 <strlen@plt>\n  mov    %rax,%rbp\n  mov    0x8(%r12,%rbx,8),%r14\n  mov    %r14,%rdi\n  call   1070 <strlen@plt>\n  cmp    %rax,%rbp\n  ja     11c7 <func0+0x6e>\n  jne    11d0 <func0+0x77>\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  jg     11c7 <func0+0x6e>\n  jmp    11d0 <func0+0x77>\n  addl   $0x1,0xc(%rsp)\n  mov    0xc(%rsp),%ecx\n  mov    (%r15),%eax\n  lea    -0x1(%rax),%edx\n  cmp    %ecx,%edx\n  jle    1240 <func0+0xe7>\n  mov    (%r15),%eax\n  sub    0xc(%rsp),%eax\n  mov    $0x0,%ebx\n  cmp    $0x1,%eax\n  jg     11e1 <func0+0x88>\n  jmp    1215 <func0+0xbc>\n  mov    $0x0,%eax\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   1090 <malloc@plt>\n  mov    (%r15),%esi\n  test   %esi,%esi\n  jle    126e <func0+0x115>\n  mov    %esi,%esi\n  mov    $0x0,%edx\n  mov    (%r12,%rdx,8),%rcx\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    125d <func0+0x104>\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  mov    %rdx,%r15\n  movl   $0x0,(%rdx)\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r13\n  jmp    L1\nL3:\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  je     L2\nL1:\n  mov    (%rbx),%rbp\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  test   $0x1,%al\n  jne    L3\n  movslq (%r15),%rax\n  mov    %rbp,(%r12,%rax,8)\n  addl   $0x1,(%r15)\n  jmp    L3\nL2:\n  mov    (%r15),%eax\n  cmp    $0x1,%eax\n  jle    L4\n  movl   $0x0,0xc(%rsp)\n  jmp    L5\nL7:\n  mov    %r14,(%r12,%rbx,8)\n  mov    %r13,0x8(%r12,%rbx,8)\nL8:\n  add    $0x1,%rbx\n  mov    0xc(%rsp),%eax\n  not    %eax\n  add    (%r15),%eax\n  cmp    %ebx,%eax\n  jle    L6\nL9:\n  mov    (%r12,%rbx,8),%r13\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  mov    0x8(%r12,%rbx,8),%r14\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbp\n  ja     L7\n  jne    L8\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jg     L7\n  jmp    L8\nL6:\n  addl   $0x1,0xc(%rsp)\n  mov    0xc(%rsp),%ecx\n  mov    (%r15),%eax\n  lea    -0x1(%rax),%edx\n  cmp    %ecx,%edx\n  jle    L4\nL5:\n  mov    (%r15),%eax\n  sub    0xc(%rsp),%eax\n  mov    $0x0,%ebx\n  cmp    $0x1,%eax\n  jg     L9\n  jmp    L6\nL0:\n  mov    $0x0,%eax\nL4:\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   <malloc@plt>\n  mov    (%r15),%esi\n  test   %esi,%esi\n  jle    L10\n  mov    %esi,%esi\n  mov    $0x0,%edx\nL11:\n  mov    (%r12,%rdx,8),%rcx\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    L11\nL10:\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4667
        },
        "L1": {
          "label": "L1",
          "addr": 4501
        },
        "L2": {
          "label": "L2",
          "addr": 4529
        },
        "L3": {
          "label": "L3",
          "addr": 4492
        },
        "L4": {
          "label": "L4",
          "addr": 4672
        },
        "L5": {
          "label": "L5",
          "addr": 4648
        },
        "L6": {
          "label": "L6",
          "addr": 4629
        },
        "L7": {
          "label": "L7",
          "addr": 4551
        },
        "L8": {
          "label": "L8",
          "addr": 4560
        },
        "L9": {
          "label": "L9",
          "addr": 4577
        },
        "L10": {
          "label": "L10",
          "addr": 4718
        },
        "L11": {
          "label": "L11",
          "addr": 4701
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **strs, int n, int *returnSize) {\n  *returnSize = 0;\n  for (int i = 0; i < n; i++) {\n    if (strlen(strs[i]) % 2 == 0) {\n      strs[*returnSize] = strs[i];\n      (*returnSize)++;\n    }\n  }\n  for (int i = 0; i < *returnSize - 1; i++) {\n    for (int j = 0; j < *returnSize - i - 1; j++) {\n      if (strlen(strs[j]) > strlen(strs[j + 1]) || (strlen(strs[j]) == strlen(strs[j + 1]) && strcmp(strs[j], strs[j + 1]) > 0)) {\n        char *tmp = strs[j];\n        strs[j] = strs[j + 1];\n        strs[j + 1] = tmp;\n      }\n    }\n  }\n  char **res = (char **)malloc(sizeof(char *) * *returnSize);\n  for (int i = 0; i < *returnSize; i++) {\n    res[i] = strs[i];\n  }\n  return res;\n}"
    },
    {
      "task_id": 149,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movl   $0x0,(%rdx)\n  mov    %rdi,(%rsp)\n  mov    %rdx,0x10(%rsp)\n  test   %esi,%esi\n  jle    12d4 <func0+0x154>\n  lea    0x8(%rdi),%rdx\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  mov    %rdx,0x8(%rsp)\n  lea    (%rdx,%rax,8),%r12\n  xchg   %ax,%ax\n  mov    (%rbx),%r13\n  mov    %r13,%rdi\n  call   1080 <strlen@plt>\n  test   $0x1,%al\n  jne    11e4 <func0+0x64>\n  mov    (%rsp),%rdx\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  mov    %r13,(%rdx,%rax,8)\n  mov    0x10(%rsp),%rax\n  mov    %ebp,(%rax)\n  add    $0x8,%rbx\n  cmp    %r12,%rbx\n  jne    11c0 <func0+0x40>\n  lea    -0x1(%rbp),%r12d\n  movslq %ebp,%rbp\n  lea    0x0(,%rbp,8),%rax\n  mov    %rax,0x18(%rsp)\n  test   %r12d,%r12d\n  jle    1273 <func0+0xf3>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    0x8(%rsp),%rcx\n  lea    -0x1(%r12),%eax\n  mov    (%rsp),%r15\n  mov    %rax,%r12\n  lea    (%rcx,%rax,8),%rbp\n  jmp    123f <func0+0xbf>\n  nopw   0x0(%rax,%rax,1)\n  je     12b8 <func0+0x138>\n  add    $0x8,%r15\n  cmp    %r15,%rbp\n  je     126e <func0+0xee>\n  mov    (%r15),%r14\n  mov    %r14,%rdi\n  call   1080 <strlen@plt>\n  mov    0x8(%r15),%r13\n  mov    %rax,%rbx\n  mov    %r13,%rdi\n  call   1080 <strlen@plt>\n  cmp    %rax,%rbx\n  jbe    1230 <func0+0xb0>\n  mov    %r13,(%r15)\n  mov    %r14,0x8(%r15)\n  add    $0x8,%r15\n  cmp    %r15,%rbp\n  jne    123f <func0+0xbf>\n  test   %r12d,%r12d\n  jne    1210 <func0+0x90>\n  mov    0x18(%rsp),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r8\n  mov    0x10(%rsp),%rax\n  movslq (%rax),%rax\n  test   %eax,%eax\n  jle    12a3 <func0+0x123>\n  mov    (%rsp),%rsi\n  mov    %r8,%rdi\n  lea    0x0(,%rax,8),%rdx\n  call   10a0 <memcpy@plt>\n  mov    %rax,%r8\n  add    $0x28,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jle    1236 <func0+0xb6>\n  mov    %r13,(%r15)\n  mov    %r14,0x8(%r15)\n  jmp    1265 <func0+0xe5>\n  movq   $0x0,0x18(%rsp)\n  jmp    1273 <func0+0xf3>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movl   $0x0,(%rdx)\n  mov    %rdi,(%rsp)\n  mov    %rdx,0x10(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    0x8(%rdi),%rdx\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  mov    %rdx,0x8(%rsp)\n  lea    (%rdx,%rax,8),%r12\n  xchg   %ax,%ax\nL2:\n  mov    (%rbx),%r13\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  test   $0x1,%al\n  jne    L1\n  mov    (%rsp),%rdx\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  mov    %r13,(%rdx,%rax,8)\n  mov    0x10(%rsp),%rax\n  mov    %ebp,(%rax)\nL1:\n  add    $0x8,%rbx\n  cmp    %r12,%rbx\n  jne    L2\n  lea    -0x1(%rbp),%r12d\n  movslq %ebp,%rbp\n  lea    0x0(,%rbp,8),%rax\n  mov    %rax,0x18(%rsp)\n  test   %r12d,%r12d\n  jle    L3\n  cs nopw 0x0(%rax,%rax,1)\nL8:\n  mov    0x8(%rsp),%rcx\n  lea    -0x1(%r12),%eax\n  mov    (%rsp),%r15\n  mov    %rax,%r12\n  lea    (%rcx,%rax,8),%rbp\n  jmp    L4\n  nopw   0x0(%rax,%rax,1)\nL7:\n  je     L5\nL10:\n  add    $0x8,%r15\n  cmp    %r15,%rbp\n  je     L6\nL4:\n  mov    (%r15),%r14\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  mov    0x8(%r15),%r13\n  mov    %rax,%rbx\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jbe    L7\n  mov    %r13,(%r15)\n  mov    %r14,0x8(%r15)\nL11:\n  add    $0x8,%r15\n  cmp    %r15,%rbp\n  jne    L4\nL6:\n  test   %r12d,%r12d\n  jne    L8\nL3:\n  mov    0x18(%rsp),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  mov    0x10(%rsp),%rax\n  movslq (%rax),%rax\n  test   %eax,%eax\n  jle    L9\n  mov    (%rsp),%rsi\n  mov    %r8,%rdi\n  lea    0x0(,%rax,8),%rdx\n  call   <memcpy@plt>\n  mov    %rax,%r8\nL9:\n  add    $0x28,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\nL5:\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jle    L10\n  mov    %r13,(%r15)\n  mov    %r14,0x8(%r15)\n  jmp    L11\nL0:\n  movq   $0x0,0x18(%rsp)\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4820
        },
        "L1": {
          "label": "L1",
          "addr": 4580
        },
        "L2": {
          "label": "L2",
          "addr": 4544
        },
        "L3": {
          "label": "L3",
          "addr": 4723
        },
        "L4": {
          "label": "L4",
          "addr": 4671
        },
        "L5": {
          "label": "L5",
          "addr": 4792
        },
        "L6": {
          "label": "L6",
          "addr": 4718
        },
        "L7": {
          "label": "L7",
          "addr": 4656
        },
        "L8": {
          "label": "L8",
          "addr": 4624
        },
        "L9": {
          "label": "L9",
          "addr": 4771
        },
        "L10": {
          "label": "L10",
          "addr": 4662
        },
        "L11": {
          "label": "L11",
          "addr": 4709
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **strs, int n, int *returnSize) {\n  *returnSize = 0;\n  int i, j;\n  for (i = 0; i < n; i++) {\n    if (strlen(strs[i]) % 2 == 0) {\n      strs[(*returnSize)++] = strs[i];\n    }\n  }\n  for (i = (*returnSize) - 1; i > 0; i--) {\n    for (j = 0; j < i; j++) {\n      if (strlen(strs[j]) > strlen(strs[j + 1])) {\n        char *tmp = strs[j];\n        strs[j] = strs[j + 1];\n        strs[j + 1] = tmp;\n      } else if (strlen(strs[j]) == strlen(strs[j + 1])) {\n        if (strcmp(strs[j], strs[j + 1]) > 0) {\n          char *tmp = strs[j];\n          strs[j] = strs[j + 1];\n          strs[j + 1] = tmp;\n        }\n      }\n    }\n  }\n  char **res = (char **)malloc(sizeof(char *) * (*returnSize));\n  for (i = 0; i < (*returnSize); i++) {\n    res[i] = strs[i];\n  }\n  return res;\n}"
    },
    {
      "task_id": 149,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  movl   $0x0,(%rdx)\n  mov    %rdi,0x10(%rsp)\n  mov    %rdx,0x20(%rsp)\n  test   %esi,%esi\n  jle    12ee <func0+0x16e>\n  lea    0x8(%rdi),%rdx\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  mov    %rdx,0x18(%rsp)\n  lea    (%rdx,%rax,8),%r12\n  nop\n  mov    (%rbx),%r13\n  mov    %r13,%rdi\n  call   1080 <strlen@plt>\n  test   $0x1,%al\n  jne    11e5 <func0+0x65>\n  mov    0x10(%rsp),%rdx\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  mov    %r13,(%rdx,%rax,8)\n  mov    0x20(%rsp),%rax\n  mov    %ebp,(%rax)\n  add    $0x8,%rbx\n  cmp    %rbx,%r12\n  jne    11c0 <func0+0x40>\n  lea    -0x1(%rbp),%r13d\n  movslq %ebp,%rbp\n  lea    0x0(,%rbp,8),%rax\n  mov    %rax,0x28(%rsp)\n  test   %r13d,%r13d\n  jle    1287 <func0+0x107>\n  nopl   0x0(%rax,%rax,1)\n  mov    0x18(%rsp),%rcx\n  lea    -0x1(%r13),%eax\n  mov    0x10(%rsp),%r15\n  mov    %rax,%r13\n  lea    (%rcx,%rax,8),%r12\n  jmp    123f <func0+0xbf>\n  nopw   0x0(%rax,%rax,1)\n  je     12d0 <func0+0x150>\n  add    $0x8,%r15\n  cmp    %r12,%r15\n  je     1282 <func0+0x102>\n  mov    (%r15),%rbp\n  mov    %rbp,%rdi\n  call   1080 <strlen@plt>\n  mov    0x8(%r15),%r14\n  movq   %rbp,%xmm1\n  mov    %rax,%rbx\n  movq   %r14,%xmm0\n  mov    %r14,%rdi\n  punpcklqdq %xmm1,%xmm0\n  movaps %xmm0,(%rsp)\n  call   1080 <strlen@plt>\n  cmp    %rax,%rbx\n  jbe    1230 <func0+0xb0>\n  movdqa (%rsp),%xmm2\n  movups %xmm2,(%r15)\n  add    $0x8,%r15\n  cmp    %r12,%r15\n  jne    123f <func0+0xbf>\n  test   %r13d,%r13d\n  jne    1210 <func0+0x90>\n  mov    0x28(%rsp),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r8\n  mov    0x20(%rsp),%rax\n  movslq (%rax),%rax\n  test   %eax,%eax\n  jle    12b8 <func0+0x138>\n  mov    0x10(%rsp),%rsi\n  mov    %r8,%rdi\n  lea    0x0(,%rax,8),%rdx\n  call   10a0 <memcpy@plt>\n  mov    %rax,%r8\n  add    $0x38,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %r14,%rsi\n  mov    %rbp,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jle    1236 <func0+0xb6>\n  movdqa (%rsp),%xmm2\n  movups %xmm2,(%r15)\n  jmp    1279 <func0+0xf9>\n  movq   $0x0,0x28(%rsp)\n  jmp    1287 <func0+0x107>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  movl   $0x0,(%rdx)\n  mov    %rdi,0x10(%rsp)\n  mov    %rdx,0x20(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    0x8(%rdi),%rdx\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  mov    %rdx,0x18(%rsp)\n  lea    (%rdx,%rax,8),%r12\n  nop\nL2:\n  mov    (%rbx),%r13\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  test   $0x1,%al\n  jne    L1\n  mov    0x10(%rsp),%rdx\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  mov    %r13,(%rdx,%rax,8)\n  mov    0x20(%rsp),%rax\n  mov    %ebp,(%rax)\nL1:\n  add    $0x8,%rbx\n  cmp    %rbx,%r12\n  jne    L2\n  lea    -0x1(%rbp),%r13d\n  movslq %ebp,%rbp\n  lea    0x0(,%rbp,8),%rax\n  mov    %rax,0x28(%rsp)\n  test   %r13d,%r13d\n  jle    L3\n  nopl   0x0(%rax,%rax,1)\nL8:\n  mov    0x18(%rsp),%rcx\n  lea    -0x1(%r13),%eax\n  mov    0x10(%rsp),%r15\n  mov    %rax,%r13\n  lea    (%rcx,%rax,8),%r12\n  jmp    L4\n  nopw   0x0(%rax,%rax,1)\nL7:\n  je     L5\nL10:\n  add    $0x8,%r15\n  cmp    %r12,%r15\n  je     L6\nL4:\n  mov    (%r15),%rbp\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  mov    0x8(%r15),%r14\n  movq   %rbp,%xmm1\n  mov    %rax,%rbx\n  movq   %r14,%xmm0\n  mov    %r14,%rdi\n  punpcklqdq %xmm1,%xmm0\n  movaps %xmm0,(%rsp)\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jbe    L7\n  movdqa (%rsp),%xmm2\n  movups %xmm2,(%r15)\nL11:\n  add    $0x8,%r15\n  cmp    %r12,%r15\n  jne    L4\nL6:\n  test   %r13d,%r13d\n  jne    L8\nL3:\n  mov    0x28(%rsp),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  mov    0x20(%rsp),%rax\n  movslq (%rax),%rax\n  test   %eax,%eax\n  jle    L9\n  mov    0x10(%rsp),%rsi\n  mov    %r8,%rdi\n  lea    0x0(,%rax,8),%rdx\n  call   <memcpy@plt>\n  mov    %rax,%r8\nL9:\n  add    $0x38,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL5:\n  mov    %r14,%rsi\n  mov    %rbp,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jle    L10\n  movdqa (%rsp),%xmm2\n  movups %xmm2,(%r15)\n  jmp    L11\nL0:\n  movq   $0x0,0x28(%rsp)\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4846
        },
        "L1": {
          "label": "L1",
          "addr": 4581
        },
        "L2": {
          "label": "L2",
          "addr": 4544
        },
        "L3": {
          "label": "L3",
          "addr": 4743
        },
        "L4": {
          "label": "L4",
          "addr": 4671
        },
        "L5": {
          "label": "L5",
          "addr": 4816
        },
        "L6": {
          "label": "L6",
          "addr": 4738
        },
        "L7": {
          "label": "L7",
          "addr": 4656
        },
        "L8": {
          "label": "L8",
          "addr": 4624
        },
        "L9": {
          "label": "L9",
          "addr": 4792
        },
        "L10": {
          "label": "L10",
          "addr": 4662
        },
        "L11": {
          "label": "L11",
          "addr": 4729
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char **strs, int size, int *retsize) {\n  int i, j, k;\n  char *tmp;\n  *retsize = 0;\n  for (i = 0; i < size; i++) {\n    if (strlen(strs[i]) % 2 == 0) {\n      strs[*retsize] = strs[i];\n      (*retsize)++;\n    }\n  }\n  for (i = *retsize - 1; i > 0; i--) {\n    for (j = 0; j < i; j++) {\n      if (strlen(strs[j]) > strlen(strs[j + 1])) {\n        tmp = strs[j];\n        strs[j] = strs[j + 1];\n        strs[j + 1] = tmp;\n      } else if (strlen(strs[j]) == strlen(strs[j + 1])) {\n        if (strcmp(strs[j], strs[j + 1]) > 0) {\n          tmp = strs[j];\n          strs[j] = strs[j + 1];\n          strs[j + 1] = tmp;\n        }\n      }\n    }\n  }\n  char **ret = (char **)malloc(sizeof(char *) * (*retsize));\n  for (i = 0; i < *retsize; i++) {\n    ret[i] = strs[i];\n  }\n  return ret;\n}"
    },
    {
      "task_id": 152,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x2c(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    116a <func0+0x71>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edx\n  sub    %edx,%eax\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1119 <func0+0x20>\n  nop\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x2c(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edx\n  sub    %edx,%eax\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L1\n  nop\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4458
        },
        "L1": {
          "label": "L1",
          "addr": 4377
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int *y, int *z, int n) {\n  int i;\n  for (i = 0; i < n; ++i)\n    z[i] = abs(x[i] - y[i]);\n}"
    },
    {
      "task_id": 151,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    11d0 <func0+0xb0>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x4(%rdi,%rax,4),%rbp\n  nopw   0x0(%rax,%rax,1)\n  movss  (%rbx),%xmm2\n  movaps %xmm2,%xmm0\n  movss  %xmm2,0xc(%rsp)\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm2\n  pxor   %xmm1,%xmm1\n  pxor   %xmm3,%xmm3\n  movsd  0xea0(%rip),%xmm4        # 2010 <_fini+0xe30>\n  cvtss2sd %xmm0,%xmm3\n  cvtss2sd %xmm2,%xmm1\n  subsd  %xmm3,%xmm1\n  andpd  0xe7c(%rip),%xmm1        # 2000 <_fini+0xe20>\n  comisd %xmm1,%xmm4\n  jbe    11b8 <func0+0x98>\n  pxor   %xmm5,%xmm5\n  comiss %xmm5,%xmm2\n  jbe    11b8 <func0+0x98>\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    11b8 <func0+0x98>\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rbx\n  cmp    %rbx,%rbp\n  jne    1148 <func0+0x28>\n  add    $0x10,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   (%rax)\n  add    $0x10,%rsp\n  xor    %r12d,%r12d\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x4(%rdi,%rax,4),%rbp\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movss  (%rbx),%xmm2\n  movaps %xmm2,%xmm0\n  movss  %xmm2,0xc(%rsp)\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm2\n  pxor   %xmm1,%xmm1\n  pxor   %xmm3,%xmm3\n  movsd  D0(%rip),%xmm4\n  cvtss2sd %xmm0,%xmm3\n  cvtss2sd %xmm2,%xmm1\n  subsd  %xmm3,%xmm1\n  andpd  D1(%rip),%xmm1\n  comisd %xmm1,%xmm4\n  jbe    L1\n  pxor   %xmm5,%xmm5\n  comiss %xmm5,%xmm2\n  jbe    L1\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  nopw   0x0(%rax,%rax,1)\nL1:\n  add    $0x4,%rbx\n  cmp    %rbx,%rbp\n  jne    L2\n  add    $0x10,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   (%rax)\nL0:\n  add    $0x10,%rsp\n  xor    %r12d,%r12d\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8208,
          "bias": [
            3744
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3708
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4560
        },
        "L1": {
          "label": "L1",
          "addr": 4536
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffffffffffff7f00000000000000002d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "qword[2]",
            "value": [
              9223372036854775807,
              0
            ]
          },
          "0x2010": {
            "type": "byte[8]",
            "value": [
              45,
              67,
              28,
              235,
              226,
              54,
              26,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " long func0(float *array, int len) {\n  long sum = 0;\n  for (int i = 0; i < len; i++) {\n    float el = array[i];\n    float el_rounded = roundf(el);\n    if (fabs(el - el_rounded) < 0.0001 && el > 0) {\n      int el_rounded_int = (int)el_rounded;\n      if (el_rounded_int % 2 == 1) {\n        sum += el_rounded_int * el_rounded_int;\n      }\n    }\n  }\n  return sum;\n}"
    },
    {
      "task_id": 152,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  test   %ecx,%ecx\n  jle    1128 <func0+0x2f>\n  mov    %ecx,%ecx\n  mov    $0x0,%eax\n  mov    (%r9,%rax,4),%edi\n  sub    (%rsi,%rax,4),%edi\n  mov    %edi,%r8d\n  neg    %r8d\n  cmovns %r8d,%edi\n  mov    %edi,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    110b <func0+0x12>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  test   %ecx,%ecx\n  jle    L0\n  mov    %ecx,%ecx\n  mov    $0x0,%eax\nL1:\n  mov    (%r9,%rax,4),%edi\n  sub    (%rsi,%rax,4),%edi\n  mov    %edi,%r8d\n  neg    %r8d\n  cmovns %r8d,%edi\n  mov    %edi,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    L1\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4392
        },
        "L1": {
          "label": "L1",
          "addr": 4363
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int *y, int *z, int n) {\n  int i;\n  for (i = 0; i < n; ++i)\n    z[i] = abs(x[i] - y[i]);\n}"
    },
    {
      "task_id": 151,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    11b5 <func0+0x9c>\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rbp\n  mov    $0x0,%r12d\n  jmp    1149 <func0+0x30>\n  add    $0x4,%rbx\n  cmp    %rbp,%rbx\n  je     11bb <func0+0xa2>\n  movss  (%rbx),%xmm3\n  movss  %xmm3,0xc(%rsp)\n  movaps %xmm3,%xmm0\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm3\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm3,%xmm1\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  subsd  %xmm2,%xmm1\n  andpd  0xe83(%rip),%xmm1        # 2000 <_fini+0xe38>\n  movsd  0xe8b(%rip),%xmm4        # 2010 <_fini+0xe48>\n  comisd %xmm1,%xmm4\n  jbe    1140 <func0+0x27>\n  comiss 0xe76(%rip),%xmm3        # 2008 <_fini+0xe40>\n  jbe    1140 <func0+0x27>\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    1140 <func0+0x27>\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  jmp    1140 <func0+0x27>\n  mov    $0x0,%r12d\n  mov    %r12,%rax\n  add    $0x10,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rbp\n  mov    $0x0,%r12d\n  jmp    L1\nL3:\n  add    $0x4,%rbx\n  cmp    %rbp,%rbx\n  je     L2\nL1:\n  movss  (%rbx),%xmm3\n  movss  %xmm3,0xc(%rsp)\n  movaps %xmm3,%xmm0\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm3\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm3,%xmm1\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  subsd  %xmm2,%xmm1\n  andpd  D0(%rip),%xmm1\n  movsd  D1(%rip),%xmm4\n  comisd %xmm1,%xmm4\n  jbe    L3\n  comiss D2(%rip),%xmm3\n  jbe    L3\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    L3\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  jmp    L3\nL0:\n  mov    $0x0,%r12d\nL2:\n  mov    %r12,%rax\n  add    $0x10,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 2,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3715
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3723
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8200,
          "bias": [
            3702
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4533
        },
        "L1": {
          "label": "L1",
          "addr": 4425
        },
        "L2": {
          "label": "L2",
          "addr": 4539
        },
        "L3": {
          "label": "L3",
          "addr": 4416
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffffffffffff7f00000000000000002d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "qword[2]",
            "value": [
              9223372036854775807,
              0
            ]
          },
          "0x2010": {
            "type": "byte[8]",
            "value": [
              45,
              67,
              28,
              235,
              226,
              54,
              26,
              63
            ]
          },
          "0x2008": {
            "type": "byte[4]",
            "value": [
              0,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " long func0(float *array, int len) {\n  long int sum = 0;\n  for (int i = 0; i < len; i++) {\n    float el = array[i];\n    float el_rounded = roundf(el);\n    if (fabs(el - el_rounded) < 0.0001 && el > 0) {\n      int el_rounded_int = (int)el_rounded;\n      if (el_rounded_int % 2 == 1) {\n        sum += el_rounded_int * el_rounded_int;\n      }\n    }\n  }\n  return sum;\n}"
    },
    {
      "task_id": 152,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  test   %ecx,%ecx\n  jle    112d <func0+0x2d>\n  movslq %ecx,%rcx\n  xor    %eax,%eax\n  mov    (%r9,%rax,4),%edi\n  sub    (%rsi,%rax,4),%edi\n  mov    %edi,%r8d\n  neg    %r8d\n  cmovns %r8d,%edi\n  mov    %edi,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  jne    1110 <func0+0x10>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  test   %ecx,%ecx\n  jle    L0\n  movslq %ecx,%rcx\n  xor    %eax,%eax\nL1:\n  mov    (%r9,%rax,4),%edi\n  sub    (%rsi,%rax,4),%edi\n  mov    %edi,%r8d\n  neg    %r8d\n  cmovns %r8d,%edi\n  mov    %edi,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  jne    L1\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4397
        },
        "L1": {
          "label": "L1",
          "addr": 4368
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int *y, int *z, int n) {\n  int i;\n  for (i = 0; i < n; ++i)\n    z[i] = abs(x[i] - y[i]);\n}"
    },
    {
      "task_id": 152,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  test   %ecx,%ecx\n  jle    121f <func0+0x11f>\n  lea    0x4(%rdi),%r8\n  mov    %rdx,%rax\n  sub    %r8,%rax\n  cmp    $0x8,%rax\n  lea    -0x1(%rcx),%eax\n  seta   %r8b\n  cmp    $0x2,%eax\n  seta   %al\n  test   %al,%r8b\n  je     11f8 <func0+0xf8>\n  lea    0x4(%rsi),%r8\n  mov    %rdx,%rax\n  sub    %r8,%rax\n  cmp    $0x8,%rax\n  jbe    11f8 <func0+0xf8>\n  mov    %ecx,%r8d\n  xor    %eax,%eax\n  shr    $0x2,%r8d\n  shl    $0x4,%r8\n  nopl   0x0(%rax)\n  movdqu (%rdi,%rax,1),%xmm0\n  movdqu (%rsi,%rax,1),%xmm2\n  psubd  %xmm2,%xmm0\n  movdqa %xmm0,%xmm1\n  psrad  $0x1f,%xmm1\n  pxor   %xmm1,%xmm0\n  psubd  %xmm1,%xmm0\n  movups %xmm0,(%rdx,%rax,1)\n  add    $0x10,%rax\n  cmp    %r8,%rax\n  jne    1158 <func0+0x58>\n  mov    %ecx,%r8d\n  and    $0xfffffffc,%r8d\n  test   $0x3,%cl\n  je     121f <func0+0x11f>\n  mov    %r8d,%r10d\n  mov    (%rdi,%r10,4),%r9d\n  sub    (%rsi,%r10,4),%r9d\n  lea    0x0(,%r10,4),%rax\n  mov    %r9d,%r11d\n  neg    %r11d\n  cmovns %r11d,%r9d\n  mov    %r9d,(%rdx,%r10,4)\n  lea    0x1(%r8),%r9d\n  cmp    %r9d,%ecx\n  jle    121f <func0+0x11f>\n  mov    0x4(%rdi,%rax,1),%r9d\n  sub    0x4(%rsi,%rax,1),%r9d\n  mov    %r9d,%r10d\n  neg    %r10d\n  cmovns %r10d,%r9d\n  add    $0x2,%r8d\n  mov    %r9d,0x4(%rdx,%rax,1)\n  cmp    %r8d,%ecx\n  jle    121f <func0+0x11f>\n  mov    0x8(%rdi,%rax,1),%ecx\n  sub    0x8(%rsi,%rax,1),%ecx\n  mov    %ecx,%esi\n  neg    %esi\n  cmovns %esi,%ecx\n  mov    %ecx,0x8(%rdx,%rax,1)\n  ret\n  nopl   0x0(%rax)\n  mov    %ecx,%ecx\n  xor    %eax,%eax\n  nopl   0x0(%rax)\n  mov    (%rdi,%rax,4),%r8d\n  sub    (%rsi,%rax,4),%r8d\n  mov    %r8d,%r9d\n  neg    %r9d\n  cmovns %r9d,%r8d\n  mov    %r8d,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    1200 <func0+0x100>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  test   %ecx,%ecx\n  jle    L0\n  lea    0x4(%rdi),%r8\n  mov    %rdx,%rax\n  sub    %r8,%rax\n  cmp    $0x8,%rax\n  lea    -0x1(%rcx),%eax\n  seta   %r8b\n  cmp    $0x2,%eax\n  seta   %al\n  test   %al,%r8b\n  je     L1\n  lea    0x4(%rsi),%r8\n  mov    %rdx,%rax\n  sub    %r8,%rax\n  cmp    $0x8,%rax\n  jbe    L1\n  mov    %ecx,%r8d\n  xor    %eax,%eax\n  shr    $0x2,%r8d\n  shl    $0x4,%r8\n  nopl   0x0(%rax)\nL2:\n  movdqu (%rdi,%rax,1),%xmm0\n  movdqu (%rsi,%rax,1),%xmm2\n  psubd  %xmm2,%xmm0\n  movdqa %xmm0,%xmm1\n  psrad  $0x1f,%xmm1\n  pxor   %xmm1,%xmm0\n  psubd  %xmm1,%xmm0\n  movups %xmm0,(%rdx,%rax,1)\n  add    $0x10,%rax\n  cmp    %r8,%rax\n  jne    L2\n  mov    %ecx,%r8d\n  and    $0xfffffffc,%r8d\n  test   $0x3,%cl\n  je     L0\n  mov    %r8d,%r10d\n  mov    (%rdi,%r10,4),%r9d\n  sub    (%rsi,%r10,4),%r9d\n  lea    0x0(,%r10,4),%rax\n  mov    %r9d,%r11d\n  neg    %r11d\n  cmovns %r11d,%r9d\n  mov    %r9d,(%rdx,%r10,4)\n  lea    0x1(%r8),%r9d\n  cmp    %r9d,%ecx\n  jle    L0\n  mov    0x4(%rdi,%rax,1),%r9d\n  sub    0x4(%rsi,%rax,1),%r9d\n  mov    %r9d,%r10d\n  neg    %r10d\n  cmovns %r10d,%r9d\n  add    $0x2,%r8d\n  mov    %r9d,0x4(%rdx,%rax,1)\n  cmp    %r8d,%ecx\n  jle    L0\n  mov    0x8(%rdi,%rax,1),%ecx\n  sub    0x8(%rsi,%rax,1),%ecx\n  mov    %ecx,%esi\n  neg    %esi\n  cmovns %esi,%ecx\n  mov    %ecx,0x8(%rdx,%rax,1)\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    %ecx,%ecx\n  xor    %eax,%eax\n  nopl   0x0(%rax)\nL3:\n  mov    (%rdi,%rax,4),%r8d\n  sub    (%rsi,%rax,4),%r8d\n  mov    %r8d,%r9d\n  neg    %r9d\n  cmovns %r9d,%r8d\n  mov    %r8d,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    L3\nL0:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4639
        },
        "L1": {
          "label": "L1",
          "addr": 4600
        },
        "L2": {
          "label": "L2",
          "addr": 4440
        },
        "L3": {
          "label": "L3",
          "addr": 4608
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int *x, int *y, int *z, int n) {\n  int i;\n  for (i = 0; i < n; ++i)\n    z[i] = abs(x[i] - y[i]);\n}"
    },
    {
      "task_id": 147,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %edi,%r13d\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r14\n  lea    0x1(%r13),%eax\n  cltq\n  lea    0x0(,%rax,8),%rbx\n  mov    %rbx,0x8(%rsp)\n  mov    %rbx,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%rbp\n  mov    %rbx,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%rbx\n  test   %r13d,%r13d\n  js     11e9 <func0+0x90>\n  lea    0x1(%r13),%r15d\n  shl    $0x3,%r15\n  mov    $0x0,%r12d\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    %rax,0x0(%rbp,%r12,1)\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    %rax,(%rbx,%r12,1)\n  add    $0x8,%r12\n  cmp    %r12,%r15\n  jne    11b9 <func0+0x60>\n  mov    0x0(%rbp),%rax\n  movl   $0x0,0x8(%rax)\n  movl   $0x0,0x4(%rax)\n  movl   $0x0,(%rax)\n  mov    (%rbx),%rax\n  movl   $0x0,0x8(%rax)\n  movl   $0x0,0x4(%rax)\n  movl   $0x0,(%rax)\n  test   %r13d,%r13d\n  jle    127e <func0+0x125>\n  lea    0x1(%r13),%esi\n  mov    $0x1,%ecx\n  mov    %ecx,%edx\n  imul   %ecx,%edx\n  sub    %ecx,%edx\n  add    $0x1,%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  lea    (%rax,%rax,2),%edi\n  mov    %edx,%eax\n  sub    %edi,%eax\n  mov    %eax,-0x4(%r14,%rcx,4)\n  mov    -0x8(%rbp,%rcx,8),%rdi\n  mov    0x0(%rbp,%rcx,8),%rdx\n  mov    (%rdi),%r8d\n  mov    %r8d,(%rdx)\n  mov    0x4(%rdi),%r8d\n  mov    %r8d,0x4(%rdx)\n  mov    0x8(%rdi),%edi\n  mov    %edi,0x8(%rdx)\n  cltq\n  addl   $0x1,(%rdx,%rax,4)\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  jne    1226 <func0+0xcd>\n  mov    $0x2,%r10d\n  lea    0x1(%r13),%r9d\n  jmp    133e <func0+0x1e5>\n  add    $0x1,%rcx\n  cmp    %rcx,%r9\n  je     12fd <func0+0x1a4>\n  mov    -0x8(%rbx,%rcx,8),%rax\n  mov    (%rbx,%rcx,8),%rsi\n  mov    (%rax),%edx\n  mov    %edx,(%rsi)\n  mov    0x4(%rax),%edx\n  mov    %edx,0x4(%rsi)\n  mov    0x8(%rax),%eax\n  mov    %eax,0x8(%rsi)\n  test   %ecx,%ecx\n  jle    128d <func0+0x134>\n  mov    -0x4(%r14,%rcx,4),%r8d\n  mov    -0x8(%rbp,%rcx,8),%rdi\n  mov    $0x0,%edx\n  lea    (%r8,%rdx,1),%eax\n  movslq %eax,%r11\n  imul   $0x55555556,%r11,%r11\n  shr    $0x20,%r11\n  mov    %eax,%r12d\n  sar    $0x1f,%r12d\n  sub    %r12d,%r11d\n  lea    (%r11,%r11,2),%r11d\n  sub    %r11d,%eax\n  cltq\n  mov    (%rdi,%rdx,4),%r11d\n  add    %r11d,(%rsi,%rax,4)\n  add    $0x1,%rdx\n  cmp    $0x3,%rdx\n  jne    12c2 <func0+0x169>\n  jmp    128d <func0+0x134>\n  jne    1338 <func0+0x1df>\n  mov    $0x0,%edx\n  mov    (%rbx,%rdx,8),%rax\n  mov    0x0(%rbp,%rdx,8),%rcx\n  mov    (%rax),%esi\n  mov    %esi,(%rcx)\n  movl   $0x0,(%rax)\n  mov    0x4(%rax),%esi\n  mov    %esi,0x4(%rcx)\n  movl   $0x0,0x4(%rax)\n  mov    0x8(%rax),%esi\n  mov    %esi,0x8(%rcx)\n  movl   $0x0,0x8(%rax)\n  add    $0x1,%rdx\n  cmp    %edx,%r13d\n  jge    1302 <func0+0x1a9>\n  sub    $0x1,%r10d\n  je     134d <func0+0x1f4>\n  test   %r13d,%r13d\n  jle    12fb <func0+0x1a2>\n  mov    $0x1,%ecx\n  jmp    1296 <func0+0x13d>\n  mov    0x8(%rsp),%rax\n  mov    -0x8(%rbp,%rax,1),%rax\n  mov    (%rax),%r15d\n  test   %r13d,%r13d\n  js     1389 <func0+0x230>\n  lea    0x1(%r13),%r13d\n  shl    $0x3,%r13\n  mov    $0x0,%r12d\n  mov    0x0(%rbp,%r12,1),%rdi\n  call   1070 <free@plt>\n  mov    (%rbx,%r12,1),%rdi\n  call   1070 <free@plt>\n  add    $0x8,%r12\n  cmp    %r13,%r12\n  jne    136d <func0+0x214>\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  mov    %rbx,%rdi\n  call   1070 <free@plt>\n  mov    %r14,%rdi\n  call   1070 <free@plt>\n  mov    %r15d,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %edi,%r13d\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  lea    0x1(%r13),%eax\n  cltq\n  lea    0x0(,%rax,8),%rbx\n  mov    %rbx,0x8(%rsp)\n  mov    %rbx,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  mov    %rbx,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbx\n  test   %r13d,%r13d\n  js     L0\n  lea    0x1(%r13),%r15d\n  shl    $0x3,%r15\n  mov    $0x0,%r12d\nL1:\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    %rax,0x0(%rbp,%r12,1)\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    %rax,(%rbx,%r12,1)\n  add    $0x8,%r12\n  cmp    %r12,%r15\n  jne    L1\nL0:\n  mov    0x0(%rbp),%rax\n  movl   $0x0,0x8(%rax)\n  movl   $0x0,0x4(%rax)\n  movl   $0x0,(%rax)\n  mov    (%rbx),%rax\n  movl   $0x0,0x8(%rax)\n  movl   $0x0,0x4(%rax)\n  movl   $0x0,(%rax)\n  test   %r13d,%r13d\n  jle    L2\n  lea    0x1(%r13),%esi\n  mov    $0x1,%ecx\nL3:\n  mov    %ecx,%edx\n  imul   %ecx,%edx\n  sub    %ecx,%edx\n  add    $0x1,%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  lea    (%rax,%rax,2),%edi\n  mov    %edx,%eax\n  sub    %edi,%eax\n  mov    %eax,-0x4(%r14,%rcx,4)\n  mov    -0x8(%rbp,%rcx,8),%rdi\n  mov    0x0(%rbp,%rcx,8),%rdx\n  mov    (%rdi),%r8d\n  mov    %r8d,(%rdx)\n  mov    0x4(%rdi),%r8d\n  mov    %r8d,0x4(%rdx)\n  mov    0x8(%rdi),%edi\n  mov    %edi,0x8(%rdx)\n  cltq\n  addl   $0x1,(%rdx,%rax,4)\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  jne    L3\nL2:\n  mov    $0x2,%r10d\n  lea    0x1(%r13),%r9d\n  jmp    L4\nL6:\n  add    $0x1,%rcx\n  cmp    %rcx,%r9\n  je     L5\nL12:\n  mov    -0x8(%rbx,%rcx,8),%rax\n  mov    (%rbx,%rcx,8),%rsi\n  mov    (%rax),%edx\n  mov    %edx,(%rsi)\n  mov    0x4(%rax),%edx\n  mov    %edx,0x4(%rsi)\n  mov    0x8(%rax),%eax\n  mov    %eax,0x8(%rsi)\n  test   %ecx,%ecx\n  jle    L6\n  mov    -0x4(%r14,%rcx,4),%r8d\n  mov    -0x8(%rbp,%rcx,8),%rdi\n  mov    $0x0,%edx\nL7:\n  lea    (%r8,%rdx,1),%eax\n  movslq %eax,%r11\n  imul   $0x55555556,%r11,%r11\n  shr    $0x20,%r11\n  mov    %eax,%r12d\n  sar    $0x1f,%r12d\n  sub    %r12d,%r11d\n  lea    (%r11,%r11,2),%r11d\n  sub    %r11d,%eax\n  cltq\n  mov    (%rdi,%rdx,4),%r11d\n  add    %r11d,(%rsi,%rax,4)\n  add    $0x1,%rdx\n  cmp    $0x3,%rdx\n  jne    L7\n  jmp    L6\nL11:\n  jne    L8\nL5:\n  mov    $0x0,%edx\nL9:\n  mov    (%rbx,%rdx,8),%rax\n  mov    0x0(%rbp,%rdx,8),%rcx\n  mov    (%rax),%esi\n  mov    %esi,(%rcx)\n  movl   $0x0,(%rax)\n  mov    0x4(%rax),%esi\n  mov    %esi,0x4(%rcx)\n  movl   $0x0,0x4(%rax)\n  mov    0x8(%rax),%esi\n  mov    %esi,0x8(%rcx)\n  movl   $0x0,0x8(%rax)\n  add    $0x1,%rdx\n  cmp    %edx,%r13d\n  jge    L9\nL8:\n  sub    $0x1,%r10d\n  je     L10\nL4:\n  test   %r13d,%r13d\n  jle    L11\n  mov    $0x1,%ecx\n  jmp    L12\nL10:\n  mov    0x8(%rsp),%rax\n  mov    -0x8(%rbp,%rax,1),%rax\n  mov    (%rax),%r15d\n  test   %r13d,%r13d\n  js     L13\n  lea    0x1(%r13),%r13d\n  shl    $0x3,%r13\n  mov    $0x0,%r12d\nL14:\n  mov    0x0(%rbp,%r12,1),%rdi\n  call   <free@plt>\n  mov    (%rbx,%r12,1),%rdi\n  call   <free@plt>\n  add    $0x8,%r12\n  cmp    %r13,%r12\n  jne    L14\nL13:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %r14,%rdi\n  call   <free@plt>\n  mov    %r15d,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4585
        },
        "L1": {
          "label": "L1",
          "addr": 4537
        },
        "L2": {
          "label": "L2",
          "addr": 4734
        },
        "L3": {
          "label": "L3",
          "addr": 4646
        },
        "L4": {
          "label": "L4",
          "addr": 4926
        },
        "L5": {
          "label": "L5",
          "addr": 4861
        },
        "L6": {
          "label": "L6",
          "addr": 4749
        },
        "L7": {
          "label": "L7",
          "addr": 4802
        },
        "L8": {
          "label": "L8",
          "addr": 4920
        },
        "L9": {
          "label": "L9",
          "addr": 4866
        },
        "L10": {
          "label": "L10",
          "addr": 4941
        },
        "L11": {
          "label": "L11",
          "addr": 4859
        },
        "L12": {
          "label": "L12",
          "addr": 4758
        },
        "L13": {
          "label": "L13",
          "addr": 5001
        },
        "L14": {
          "label": "L14",
          "addr": 4973
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int *mods = malloc(n * sizeof(int));\n  int **arrs = malloc((n + 1) * sizeof(int *));\n  int **brrs = malloc((n + 1) * sizeof(int *));\n  for (int i = 0; i < n + 1; i++) {\n    arrs[i] = calloc(3, sizeof(int));\n    brrs[i] = calloc(3, sizeof(int));\n  }\n  arrs[0][0] = arrs[0][1] = arrs[0][2] = 0;\n  brrs[0][0] = brrs[0][1] = brrs[0][2] = 0;\n  for (int i = 1; i < n + 1; i++) {\n    mods[i - 1] = ((i * i - i + 1) % 3);\n    for (int j = 0; j < 3; j++) {\n      arrs[i][j] = arrs[i - 1][j];\n    }\n    arrs[i][mods[i - 1]]++;\n  }\n  for (int i = 1; i < 3; i++) {\n    for (int j = 1; j < n + 1; j++) {\n      for (int k = 0; k < 3; k++) {\n        brrs[j][k] = arrs[j - 1][k];\n      }\n      for (int k = 0; k < j; k++) {\n        brrs[j][(mods[j - 1] + mods[k]) % 3] += arrs[j - 1][k];\n      }\n    }\n    for (int j = 0; j < n + 1; j++) {\n      for (int k = 0; k < 3; k++) {\n        arrs[j][k] = brrs[j][k];\n        brrs[j][k] = 0;\n      }\n    }\n  }\n  int ret = arrs[n][0];\n  for (int i = 0; i < n + 1; i++) {\n    free(arrs[i]);\n    free(brrs[i]);\n  }\n  free(arrs);\n  free(brrs);\n  free(mods);\n  return ret;\n}"
    },
    {
      "task_id": 148,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    $0xffffffff,%r15d\n  push   %r14\n  mov    %rdi,%r14\n  lea    0xe68(%rip),%rdi        # 2000 <_fini+0xcf0>\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  mov    $0xffffffff,%ebp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x68,%rsp\n  mov    %rdx,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    0xe40(%rip),%rax        # 2008 <_fini+0xcf8>\n  mov    %rdi,0x10(%rsp)\n  mov    %rax,0x18(%rsp)\n  lea    0xe35(%rip),%rax        # 200e <_fini+0xcfe>\n  mov    %rax,0x20(%rsp)\n  lea    0xe2f(%rip),%rax        # 2014 <_fini+0xd04>\n  mov    %rax,0x28(%rsp)\n  lea    0xe28(%rip),%rax        # 2019 <_fini+0xd09>\n  mov    %rax,0x30(%rsp)\n  lea    0xe24(%rip),%rax        # 2021 <_fini+0xd11>\n  mov    %rax,0x38(%rsp)\n  lea    0xe1f(%rip),%rax        # 2028 <_fini+0xd18>\n  mov    %rax,0x40(%rsp)\n  lea    0xe1a(%rip),%rax        # 202f <_fini+0xd1f>\n  mov    %rax,0x48(%rsp)\n  jmp    1225 <func0+0xa5>\n  nopl   0x0(%rax)\n  mov    0x10(%rsp,%rbx,8),%rdi\n  mov    %r14,%rsi\n  mov    %rdi,(%rsp)\n  call   1090 <strcmp@plt>\n  mov    (%rsp),%rdi\n  mov    %r13,%rsi\n  test   %eax,%eax\n  cmove  %ebx,%ebp\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%r15d\n  add    $0x1,%rbx\n  cmp    $0x8,%rbx\n  jne    1220 <func0+0xa0>\n  cmp    $0xffffffff,%r15d\n  sete   %al\n  cmp    %r15d,%ebp\n  sete   %cl\n  or     %cl,%al\n  jne    12f8 <func0+0x178>\n  cmp    $0xffffffff,%ebp\n  je     12f8 <func0+0x178>\n  cmp    %r15d,%ebp\n  jg     12e8 <func0+0x168>\n  mov    %r15d,%eax\n  mov    0x8(%rsp),%rcx\n  sub    %ebp,%eax\n  sub    $0x1,%eax\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    12f8 <func0+0x178>\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r8\n  lea    0x1(%rbp),%eax\n  cmp    %eax,%r15d\n  jle    12c2 <func0+0x142>\n  lea    -0x2(%r15),%edx\n  cltq\n  mov    %r8,%rdi\n  sub    %ebp,%edx\n  lea    0x10(%rsp,%rax,8),%rsi\n  lea    0x8(,%rdx,8),%rdx\n  call   10a0 <memcpy@plt>\n  mov    %rax,%r8\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1308 <func0+0x188>\n  add    $0x68,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  mov    %ebp,%eax\n  mov    %r15d,%ebp\n  mov    %eax,%r15d\n  jmp    1275 <func0+0xf5>\n  nopw   0x0(%rax,%rax,1)\n  mov    0x8(%rsp),%rax\n  xor    %r8d,%r8d\n  movl   $0x0,(%rax)\n  jmp    12c2 <func0+0x142>\n  call   1080 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    $0xffffffff,%r15d\n  push   %r14\n  mov    %rdi,%r14\n  lea    D0(%rip),%rdi\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  mov    $0xffffffff,%ebp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x68,%rsp\n  mov    %rdx,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    D1(%rip),%rax\n  mov    %rdi,0x10(%rsp)\n  mov    %rax,0x18(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x20(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x28(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x30(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  jmp    L0\n  nopl   0x0(%rax)\nL1:\n  mov    0x10(%rsp,%rbx,8),%rdi\nL0:\n  mov    %r14,%rsi\n  mov    %rdi,(%rsp)\n  call   <strcmp@plt>\n  mov    (%rsp),%rdi\n  mov    %r13,%rsi\n  test   %eax,%eax\n  cmove  %ebx,%ebp\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%r15d\n  add    $0x1,%rbx\n  cmp    $0x8,%rbx\n  jne    L1\n  cmp    $0xffffffff,%r15d\n  sete   %al\n  cmp    %r15d,%ebp\n  sete   %cl\n  or     %cl,%al\n  jne    L2\n  cmp    $0xffffffff,%ebp\n  je     L2\n  cmp    %r15d,%ebp\n  jg     L3\nL6:\n  mov    %r15d,%eax\n  mov    0x8(%rsp),%rcx\n  sub    %ebp,%eax\n  sub    $0x1,%eax\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    L2\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  lea    0x1(%rbp),%eax\n  cmp    %eax,%r15d\n  jle    L4\n  lea    -0x2(%r15),%edx\n  cltq\n  mov    %r8,%rdi\n  sub    %ebp,%edx\n  lea    0x10(%rsp,%rax,8),%rsi\n  lea    0x8(,%rdx,8),%rdx\n  call   <memcpy@plt>\n  mov    %rax,%r8\nL4:\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  add    $0x68,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL3:\n  mov    %ebp,%eax\n  mov    %r15d,%ebp\n  mov    %eax,%r15d\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    0x8(%rsp),%rax\n  xor    %r8d,%r8d\n  movl   $0x0,(%rax)\n  jmp    L4\nL5:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3688
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8200,
          "bias": [
            3648
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8206,
          "bias": [
            3637
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8212,
          "bias": [
            3631
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8217,
          "bias": [
            3624
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8225,
          "bias": [
            3620
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8232,
          "bias": [
            3615
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8239,
          "bias": [
            3610
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4645
        },
        "L1": {
          "label": "L1",
          "addr": 4640
        },
        "L2": {
          "label": "L2",
          "addr": 4856
        },
        "L3": {
          "label": "L3",
          "addr": 4840
        },
        "L4": {
          "label": "L4",
          "addr": 4802
        },
        "L5": {
          "label": "L5",
          "addr": 4872
        },
        "L6": {
          "label": "L6",
          "addr": 4725
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4d6572637572790056656e7573004561727468004d617273004a7570697465720053617475726e005572616e7573004e657074756e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Mercury\""
          },
          "0x2021": {
            "type": "string",
            "value": "\"Saturn\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"Venus\""
          },
          "0x2028": {
            "type": "string",
            "value": "\"Uranus\""
          },
          "0x200e": {
            "type": "string",
            "value": "\"Earth\""
          },
          "0x202f": {
            "type": "string",
            "value": "\"Neptune\""
          },
          "0x2014": {
            "type": "string",
            "value": "\"Mars\""
          },
          "0x2019": {
            "type": "string",
            "value": "\"Jupiter\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char **func0(char *from, char *to, int *len) {\n  char *planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  int from_idx = -1, to_idx = -1;\n  for (int i = 0; i < 8; i++) {\n    if (!strcmp(planets[i], from))\n      from_idx = i;\n    if (!strcmp(planets[i], to))\n      to_idx = i;\n  }\n  if (from_idx == -1 || to_idx == -1 || from_idx == to_idx || from_idx > to_idx) {\n    *len = 0;\n    return NULL;\n  }\n  *len = to_idx - from_idx - 1;\n  char **result = malloc(*len * sizeof(char *));\n  for (int i = from_idx + 1, j = 0; i < to_idx; i++, j++)\n    result[j] = planets[i];\n  return result;\n}"
    },
    {
      "task_id": 147,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  movslq %edi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  mov    %rbx,%r14\n  sub    $0x18,%rsp\n  call   1090 <malloc@plt>\n  mov    %rax,%rbp\n  lea    0x1(%rbx),%eax\n  cltq\n  lea    0x0(,%rax,8),%r15\n  mov    %r15,%rdi\n  mov    %r15,0x8(%rsp)\n  call   1090 <malloc@plt>\n  mov    %r15,%rdi\n  mov    %rax,%r12\n  call   1090 <malloc@plt>\n  mov    %rax,%r13\n  test   %ebx,%ebx\n  js     13fe <func0+0x29e>\n  lea    0x8(,%rbx,8),%rax\n  xor    %r15d,%r15d\n  mov    %rbx,(%rsp)\n  mov    %r15,%rbx\n  mov    %rax,%r15\n  nopl   (%rax)\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  mov    %rax,(%r12,%rbx,1)\n  call   1080 <calloc@plt>\n  mov    %rax,0x0(%r13,%rbx,1)\n  add    $0x8,%rbx\n  cmp    %rbx,%r15\n  jne    11d0 <func0+0x70>\n  mov    (%r12),%r9\n  mov    0x0(%r13),%r10\n  mov    (%rsp),%rbx\n  movq   $0x0,(%r9)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r10)\n  movl   $0x0,0x8(%r10)\n  test   %r14d,%r14d\n  jle    128b <func0+0x12b>\n  mov    %r9,%rdi\n  mov    $0x1,%ecx\n  mov    $0xaaaaaaab,%esi\n  jmp    1247 <func0+0xe7>\n  xchg   %ax,%ax\n  add    $0x1,%rcx\n  mov    %rdx,%rdi\n  lea    -0x1(%rcx),%edx\n  imul   %ecx,%edx\n  lea    0x1(%rdx),%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x21,%rax\n  lea    (%rax,%rax,2),%r8d\n  mov    %edx,%eax\n  mov    (%r12,%rcx,8),%rdx\n  sub    %r8d,%eax\n  mov    (%rdi),%r8d\n  mov    %eax,-0x4(%rbp,%rcx,4)\n  cltq\n  mov    %r8d,(%rdx)\n  mov    0x4(%rdi),%r8d\n  mov    %r8d,0x4(%rdx)\n  mov    0x8(%rdi),%edi\n  mov    %edi,0x8(%rdx)\n  addl   $0x1,(%rdx,%rax,4)\n  cmp    %rbx,%rcx\n  jne    1240 <func0+0xe0>\n  movl   $0x2,(%rsp)\n  test   %r14d,%r14d\n  jle    136a <func0+0x20a>\n  mov    %r9,%r15\n  mov    %r10,%rax\n  mov    $0x1,%r11d\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rax),%edx\n  mov    0x0(%r13,%r11,8),%rcx\n  mov    -0x4(%rbp,%r11,4),%esi\n  mov    %edx,(%rcx)\n  mov    0x4(%rax),%edx\n  mov    %edx,0x4(%rcx)\n  mov    0x8(%rax),%eax\n  xor    %edx,%edx\n  mov    %eax,0x8(%rcx)\n  lea    (%rsi,%rdx,1),%eax\n  movslq %eax,%rdi\n  mov    %eax,%r8d\n  imul   $0x55555556,%rdi,%rdi\n  sar    $0x1f,%r8d\n  shr    $0x20,%rdi\n  sub    %r8d,%edi\n  lea    (%rdi,%rdi,2),%edi\n  sub    %edi,%eax\n  mov    (%r15,%rdx,4),%edi\n  add    $0x1,%rdx\n  cltq\n  add    %edi,(%rcx,%rax,4)\n  cmp    $0x3,%rdx\n  jne    12cc <func0+0x16c>\n  cmp    %rbx,%r11\n  je     1318 <func0+0x1b8>\n  mov    (%r12,%r11,8),%r15\n  mov    %rcx,%rax\n  add    $0x1,%r11\n  jmp    12b0 <func0+0x150>\n  nopl   0x0(%rax)\n  mov    %r9,%rcx\n  mov    %r10,%rax\n  xor    %edx,%edx\n  jmp    1331 <func0+0x1d1>\n  nopw   0x0(%rax,%rax,1)\n  mov    0x0(%r13,%rdx,8),%rax\n  mov    (%r12,%rdx,8),%rcx\n  mov    (%rax),%rsi\n  add    $0x1,%rdx\n  movq   $0x0,(%rax)\n  mov    %rsi,(%rcx)\n  mov    0x8(%rax),%esi\n  movl   $0x0,0x8(%rax)\n  mov    %esi,0x8(%rcx)\n  cmp    %edx,%r14d\n  jge    1328 <func0+0x1c8>\n  cmpl   $0x1,(%rsp)\n  je     1390 <func0+0x230>\n  movl   $0x1,(%rsp)\n  test   %r14d,%r14d\n  jg     129b <func0+0x13b>\n  jne    1354 <func0+0x1f4>\n  mov    (%r10),%rax\n  mov    $0x3,%ecx\n  mov    %r10,%rdi\n  mov    %rax,(%r9)\n  mov    0x8(%r10),%eax\n  mov    %eax,0x8(%r9)\n  mov    %r14d,%eax\n  rep stos %eax,%es:(%rdi)\n  jmp    1354 <func0+0x1f4>\n  nopl   0x0(%rax)\n  mov    0x8(%rsp),%rax\n  mov    -0x8(%r12,%rax,1),%rax\n  mov    (%rax),%r15d\n  test   %r14d,%r14d\n  js     13d4 <func0+0x274>\n  lea    0x8(,%rbx,8),%rbx\n  xor    %r14d,%r14d\n  mov    %r9,%rdi\n  jmp    13bc <func0+0x25c>\n  nopw   0x0(%rax,%rax,1)\n  mov    (%r12,%r14,1),%rdi\n  call   1070 <free@plt>\n  mov    0x0(%r13,%r14,1),%rdi\n  add    $0x8,%r14\n  call   1070 <free@plt>\n  cmp    %rbx,%r14\n  jne    13b8 <func0+0x258>\n  mov    %r12,%rdi\n  call   1070 <free@plt>\n  mov    %r13,%rdi\n  call   1070 <free@plt>\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  add    $0x18,%rsp\n  mov    %r15d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    (%r12),%r9\n  mov    (%rax),%r10\n  movq   $0x0,(%r9)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r10)\n  movl   $0x0,0x8(%r10)\n  jmp    128b <func0+0x12b>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  movslq %edi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  mov    %rbx,%r14\n  sub    $0x18,%rsp\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  lea    0x1(%rbx),%eax\n  cltq\n  lea    0x0(,%rax,8),%r15\n  mov    %r15,%rdi\n  mov    %r15,0x8(%rsp)\n  call   <malloc@plt>\n  mov    %r15,%rdi\n  mov    %rax,%r12\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %ebx,%ebx\n  js     L0\n  lea    0x8(,%rbx,8),%rax\n  xor    %r15d,%r15d\n  mov    %rbx,(%rsp)\n  mov    %r15,%rbx\n  mov    %rax,%r15\n  nopl   (%rax)\nL1:\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  mov    %rax,(%r12,%rbx,1)\n  call   <calloc@plt>\n  mov    %rax,0x0(%r13,%rbx,1)\n  add    $0x8,%rbx\n  cmp    %rbx,%r15\n  jne    L1\n  mov    (%r12),%r9\n  mov    0x0(%r13),%r10\n  mov    (%rsp),%rbx\n  movq   $0x0,(%r9)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r10)\n  movl   $0x0,0x8(%r10)\n  test   %r14d,%r14d\n  jle    L2\n  mov    %r9,%rdi\n  mov    $0x1,%ecx\n  mov    $0xaaaaaaab,%esi\n  jmp    L3\n  xchg   %ax,%ax\nL4:\n  add    $0x1,%rcx\n  mov    %rdx,%rdi\nL3:\n  lea    -0x1(%rcx),%edx\n  imul   %ecx,%edx\n  lea    0x1(%rdx),%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x21,%rax\n  lea    (%rax,%rax,2),%r8d\n  mov    %edx,%eax\n  mov    (%r12,%rcx,8),%rdx\n  sub    %r8d,%eax\n  mov    (%rdi),%r8d\n  mov    %eax,-0x4(%rbp,%rcx,4)\n  cltq\n  mov    %r8d,(%rdx)\n  mov    0x4(%rdi),%r8d\n  mov    %r8d,0x4(%rdx)\n  mov    0x8(%rdi),%edi\n  mov    %edi,0x8(%rdx)\n  addl   $0x1,(%rdx,%rax,4)\n  cmp    %rbx,%rcx\n  jne    L4\nL2:\n  movl   $0x2,(%rsp)\n  test   %r14d,%r14d\n  jle    L5\nL12:\n  mov    %r9,%r15\n  mov    %r10,%rax\n  mov    $0x1,%r11d\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    (%rax),%edx\n  mov    0x0(%r13,%r11,8),%rcx\n  mov    -0x4(%rbp,%r11,4),%esi\n  mov    %edx,(%rcx)\n  mov    0x4(%rax),%edx\n  mov    %edx,0x4(%rcx)\n  mov    0x8(%rax),%eax\n  xor    %edx,%edx\n  mov    %eax,0x8(%rcx)\nL6:\n  lea    (%rsi,%rdx,1),%eax\n  movslq %eax,%rdi\n  mov    %eax,%r8d\n  imul   $0x55555556,%rdi,%rdi\n  sar    $0x1f,%r8d\n  shr    $0x20,%rdi\n  sub    %r8d,%edi\n  lea    (%rdi,%rdi,2),%edi\n  sub    %edi,%eax\n  mov    (%r15,%rdx,4),%edi\n  add    $0x1,%rdx\n  cltq\n  add    %edi,(%rcx,%rax,4)\n  cmp    $0x3,%rdx\n  jne    L6\n  cmp    %rbx,%r11\n  je     L7\n  mov    (%r12,%r11,8),%r15\n  mov    %rcx,%rax\n  add    $0x1,%r11\n  jmp    L8\n  nopl   0x0(%rax)\nL7:\n  mov    %r9,%rcx\n  mov    %r10,%rax\n  xor    %edx,%edx\n  jmp    L9\n  nopw   0x0(%rax,%rax,1)\nL10:\n  mov    0x0(%r13,%rdx,8),%rax\n  mov    (%r12,%rdx,8),%rcx\nL9:\n  mov    (%rax),%rsi\n  add    $0x1,%rdx\n  movq   $0x0,(%rax)\n  mov    %rsi,(%rcx)\n  mov    0x8(%rax),%esi\n  movl   $0x0,0x8(%rax)\n  mov    %esi,0x8(%rcx)\n  cmp    %edx,%r14d\n  jge    L10\nL13:\n  cmpl   $0x1,(%rsp)\n  je     L11\n  movl   $0x1,(%rsp)\n  test   %r14d,%r14d\n  jg     L12\nL5:\n  jne    L13\n  mov    (%r10),%rax\n  mov    $0x3,%ecx\n  mov    %r10,%rdi\n  mov    %rax,(%r9)\n  mov    0x8(%r10),%eax\n  mov    %eax,0x8(%r9)\n  mov    %r14d,%eax\n  rep stos %eax,%es:(%rdi)\n  jmp    L13\n  nopl   0x0(%rax)\nL11:\n  mov    0x8(%rsp),%rax\n  mov    -0x8(%r12,%rax,1),%rax\n  mov    (%rax),%r15d\n  test   %r14d,%r14d\n  js     L14\n  lea    0x8(,%rbx,8),%rbx\n  xor    %r14d,%r14d\n  mov    %r9,%rdi\n  jmp    L15\n  nopw   0x0(%rax,%rax,1)\nL16:\n  mov    (%r12,%r14,1),%rdi\nL15:\n  call   <free@plt>\n  mov    0x0(%r13,%r14,1),%rdi\n  add    $0x8,%r14\n  call   <free@plt>\n  cmp    %rbx,%r14\n  jne    L16\nL14:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  mov    %r15d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  mov    (%r12),%r9\n  mov    (%rax),%r10\n  movq   $0x0,(%r9)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r10)\n  movl   $0x0,0x8(%r10)\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 5118
        },
        "L1": {
          "label": "L1",
          "addr": 4560
        },
        "L2": {
          "label": "L2",
          "addr": 4747
        },
        "L3": {
          "label": "L3",
          "addr": 4679
        },
        "L4": {
          "label": "L4",
          "addr": 4672
        },
        "L5": {
          "label": "L5",
          "addr": 4970
        },
        "L6": {
          "label": "L6",
          "addr": 4812
        },
        "L7": {
          "label": "L7",
          "addr": 4888
        },
        "L8": {
          "label": "L8",
          "addr": 4784
        },
        "L9": {
          "label": "L9",
          "addr": 4913
        },
        "L10": {
          "label": "L10",
          "addr": 4904
        },
        "L11": {
          "label": "L11",
          "addr": 5008
        },
        "L12": {
          "label": "L12",
          "addr": 4763
        },
        "L13": {
          "label": "L13",
          "addr": 4948
        },
        "L14": {
          "label": "L14",
          "addr": 5076
        },
        "L15": {
          "label": "L15",
          "addr": 5052
        },
        "L16": {
          "label": "L16",
          "addr": 5048
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int *a = malloc(n * sizeof(int));\n  int **b = malloc((n + 1) * sizeof(int *));\n  int **c = malloc((n + 1) * sizeof(int *));\n  for (int i = 0; i < n + 1; i++) {\n    b[i] = calloc(3, sizeof(int));\n    c[i] = calloc(3, sizeof(int));\n  }\n  for (int i = 0; i < 3; i++) {\n    b[0][i] = 0;\n    c[0][i] = 0;\n  }\n  for (int i = 0; i < n; i++) {\n    int j = i * (i + 1) / 3;\n    a[i] = (j + 1) % 3;\n    for (int k = 0; k < 3; k++) {\n      b[i + 1][k] = b[i][k];\n    }\n    b[i + 1][a[i]]++;\n  }\n  int flag = 2;\n  while (flag == 2) {\n    flag = 1;\n    for (int i = 0; i < n; i++) {\n      for (int k = 0; k < 3; k++) {\n        c[i + 1][k] = b[i][k];\n      }\n      for (int k = 0; k < 3; k++) {\n        c[i + 1][(a[i] + k) % 3] += b[i + 1][k];\n      }\n    }\n    for (int i = 0; i < n + 1; i++) {\n      for (int k = 0; k < 3; k++) {\n        b[i][k] = c[i][k];\n        c[i][k] = 0;\n      }\n    }\n  }\n  int ret = b[n][0];\n  for (int i = 0; i < n + 1; i++) {\n    free(b[i]);\n    free(c[i]);\n  }\n  free(b);\n  free(c);\n  free(a);\n  return ret;\n}"
    },
    {
      "task_id": 147,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %edi,-0x64(%rbp)\n  mov    -0x64(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x64(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x64(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x54(%rbp)\n  jmp    1209 <func0+0xb0>\n  mov    -0x54(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x54(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    %rax,(%rbx)\n  addl   $0x1,-0x54(%rbp)\n  mov    -0x54(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    11b7 <func0+0x5e>\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%rax\n  lea    0x8(%rax),%rdx\n  movl   $0x0,(%rdx)\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%rax\n  add    $0x4,%rax\n  mov    (%rdx),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rdx\n  mov    (%rdx),%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%rax\n  lea    0x8(%rax),%rdx\n  movl   $0x0,(%rdx)\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%rax\n  add    $0x4,%rax\n  mov    (%rdx),%edx\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rdx\n  mov    (%rdx),%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  movl   $0x1,-0x50(%rbp)\n  jmp    138b <func0+0x232>\n  mov    -0x50(%rbp),%eax\n  imul   %eax,%eax\n  sub    -0x50(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  lea    (%rcx,%rax,1),%rsi\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,(%rsi)\n  movl   $0x0,-0x4c(%rbp)\n  jmp    130e <func0+0x1b5>\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x4c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x50(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x4c(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x4c(%rbp)\n  cmpl   $0x2,-0x4c(%rbp)\n  jle    12be <func0+0x165>\n  mov    -0x50(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x50(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x20(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rcx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rsi\n  mov    -0x28(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x50(%rbp)\n  mov    -0x50(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    1273 <func0+0x11a>\n  movl   $0x1,-0x48(%rbp)\n  jmp    1594 <func0+0x43b>\n  movl   $0x1,-0x44(%rbp)\n  jmp    14e0 <func0+0x387>\n  movl   $0x0,-0x40(%rbp)\n  jmp    1408 <func0+0x2af>\n  mov    -0x44(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x40(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x40(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x40(%rbp)\n  cmpl   $0x2,-0x40(%rbp)\n  jle    13b8 <func0+0x25f>\n  cmpl   $0x0,-0x44(%rbp)\n  jle    14dc <func0+0x383>\n  movl   $0x0,-0x3c(%rbp)\n  jmp    14d2 <func0+0x379>\n  mov    -0x44(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rsi\n  mov    -0x44(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x3c(%rbp),%eax\n  add    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  movslq %eax,%rdx\n  shl    $0x2,%rdx\n  add    %rsi,%rdx\n  mov    (%rdx),%esi\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x3,%rdx\n  lea    -0x8(%rdx),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x3c(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%ecx\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rdi\n  mov    -0x18(%rbp),%rdx\n  add    %rdi,%rdx\n  mov    (%rdx),%rdx\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  lea    (%rsi,%rcx,1),%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x3c(%rbp)\n  cmpl   $0x2,-0x3c(%rbp)\n  jle    1424 <func0+0x2cb>\n  addl   $0x1,-0x44(%rbp)\n  mov    -0x44(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    13af <func0+0x256>\n  movl   $0x0,-0x38(%rbp)\n  jmp    1584 <func0+0x42b>\n  movl   $0x0,-0x34(%rbp)\n  jmp    157a <func0+0x421>\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x38(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x34(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  movl   $0x0,(%rax)\n  addl   $0x1,-0x34(%rbp)\n  cmpl   $0x2,-0x34(%rbp)\n  jle    1501 <func0+0x3a8>\n  addl   $0x1,-0x38(%rbp)\n  mov    -0x38(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    14f8 <func0+0x39f>\n  addl   $0x1,-0x48(%rbp)\n  cmpl   $0x2,-0x48(%rbp)\n  jle    13a3 <func0+0x24a>\n  mov    -0x64(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x2c(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    1605 <func0+0x4ac>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    15c3 <func0+0x46a>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x2c(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %edi,-0x64(%rbp)\n  mov    -0x64(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x64(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x64(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x54(%rbp)\n  jmp    L0\nL1:\n  mov    -0x54(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x54(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    %rax,(%rbx)\n  addl   $0x1,-0x54(%rbp)\nL0:\n  mov    -0x54(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L1\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%rax\n  lea    0x8(%rax),%rdx\n  movl   $0x0,(%rdx)\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%rax\n  add    $0x4,%rax\n  mov    (%rdx),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rdx\n  mov    (%rdx),%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%rax\n  lea    0x8(%rax),%rdx\n  movl   $0x0,(%rdx)\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%rax\n  add    $0x4,%rax\n  mov    (%rdx),%edx\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rdx\n  mov    (%rdx),%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  movl   $0x1,-0x50(%rbp)\n  jmp    L2\nL5:\n  mov    -0x50(%rbp),%eax\n  imul   %eax,%eax\n  sub    -0x50(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  lea    (%rcx,%rax,1),%rsi\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,(%rsi)\n  movl   $0x0,-0x4c(%rbp)\n  jmp    L3\nL4:\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x4c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x50(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x4c(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x4c(%rbp)\nL3:\n  cmpl   $0x2,-0x4c(%rbp)\n  jle    L4\n  mov    -0x50(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x50(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x20(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rcx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rsi\n  mov    -0x28(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x50(%rbp)\nL2:\n  mov    -0x50(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L5\n  movl   $0x1,-0x48(%rbp)\n  jmp    L6\nL18:\n  movl   $0x1,-0x44(%rbp)\n  jmp    L7\nL13:\n  movl   $0x0,-0x40(%rbp)\n  jmp    L8\nL9:\n  mov    -0x44(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x40(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x40(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x40(%rbp)\nL8:\n  cmpl   $0x2,-0x40(%rbp)\n  jle    L9\n  cmpl   $0x0,-0x44(%rbp)\n  jle    L10\n  movl   $0x0,-0x3c(%rbp)\n  jmp    L11\nL12:\n  mov    -0x44(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rsi\n  mov    -0x44(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x3c(%rbp),%eax\n  add    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  movslq %eax,%rdx\n  shl    $0x2,%rdx\n  add    %rsi,%rdx\n  mov    (%rdx),%esi\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x3,%rdx\n  lea    -0x8(%rdx),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x3c(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%ecx\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rdi\n  mov    -0x18(%rbp),%rdx\n  add    %rdi,%rdx\n  mov    (%rdx),%rdx\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  lea    (%rsi,%rcx,1),%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x3c(%rbp)\nL11:\n  cmpl   $0x2,-0x3c(%rbp)\n  jle    L12\nL10:\n  addl   $0x1,-0x44(%rbp)\nL7:\n  mov    -0x44(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L13\n  movl   $0x0,-0x38(%rbp)\n  jmp    L14\nL17:\n  movl   $0x0,-0x34(%rbp)\n  jmp    L15\nL16:\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x38(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x34(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  movl   $0x0,(%rax)\n  addl   $0x1,-0x34(%rbp)\nL15:\n  cmpl   $0x2,-0x34(%rbp)\n  jle    L16\n  addl   $0x1,-0x38(%rbp)\nL14:\n  mov    -0x38(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L17\n  addl   $0x1,-0x48(%rbp)\nL6:\n  cmpl   $0x2,-0x48(%rbp)\n  jle    L18\n  mov    -0x64(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x2c(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    L19\nL20:\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  addl   $0x1,-0x30(%rbp)\nL19:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L20\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x2c(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4617
        },
        "L1": {
          "label": "L1",
          "addr": 4535
        },
        "L2": {
          "label": "L2",
          "addr": 5003
        },
        "L3": {
          "label": "L3",
          "addr": 4878
        },
        "L4": {
          "label": "L4",
          "addr": 4798
        },
        "L5": {
          "label": "L5",
          "addr": 4723
        },
        "L6": {
          "label": "L6",
          "addr": 5524
        },
        "L7": {
          "label": "L7",
          "addr": 5344
        },
        "L8": {
          "label": "L8",
          "addr": 5128
        },
        "L9": {
          "label": "L9",
          "addr": 5048
        },
        "L10": {
          "label": "L10",
          "addr": 5340
        },
        "L11": {
          "label": "L11",
          "addr": 5330
        },
        "L12": {
          "label": "L12",
          "addr": 5156
        },
        "L13": {
          "label": "L13",
          "addr": 5039
        },
        "L14": {
          "label": "L14",
          "addr": 5508
        },
        "L15": {
          "label": "L15",
          "addr": 5498
        },
        "L16": {
          "label": "L16",
          "addr": 5377
        },
        "L17": {
          "label": "L17",
          "addr": 5368
        },
        "L18": {
          "label": "L18",
          "addr": 5027
        },
        "L19": {
          "label": "L19",
          "addr": 5637
        },
        "L20": {
          "label": "L20",
          "addr": 5571
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int *a;\n  int **aa;\n  int **aaa;\n  int i, j, k, l, m, ret;\n  a = (int *)malloc(n * sizeof(int));\n  aa = (int **)malloc((n + 1) * sizeof(int *));\n  aaa = (int **)malloc((n + 1) * sizeof(int *));\n  for (i = 0; i <= n; i++) {\n    aa[i] = (int *)calloc(3, sizeof(int));\n    aaa[i] = (int *)calloc(3, sizeof(int));\n  }\n  aa[0][0] = aa[0][1] = aa[0][2] = 0;\n  aaa[0][0] = aaa[0][1] = aaa[0][2] = 0;\n  for (i = 1; i <= n; i++) {\n    a[i - 1] = ((i * i - i + 1) % 3);\n    for (j = 0; j < 3; j++) {\n      aa[i][j] = aa[i - 1][j];\n    }\n    aaa[i][0] = aaa[i - 1][(a[i - 1] + aa[i - 1][0]) % 3] + 1;\n    for (j = 1; j <= n; j++) {\n      for (k = 0; k < 3; k++) {\n        aaa[j][k] = aaa[j - 1][k];\n      }\n      for (l = 0; l < 3; l++) {\n        aaa[j][(a[j - 1] + aaa[j - 1][l]) % 3] += aa[j - 1][l];\n      }\n    }\n    for (j = 0; j <= n; j++) {\n      for (k = 0; k < 3; k++) {\n        aa[j][k] = aaa[j][k];\n        aaa[j][k] = 0;\n      }\n    }\n  }\n  ret = aa[n][0];\n  for (i = 0; i <= n; i++) {\n    free(aa[i]);\n    free(aaa[i]);\n  }\n  free(aa);\n  free(aaa);\n  free(a);\n  return ret;\n}"
    },
    {
      "task_id": 148,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %rdi,%r15\n  mov    %rsi,(%rsp)\n  mov    %rdx,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    0xe72(%rip),%rax        # 2000 <_fini+0xd1c>\n  mov    %rax,0x10(%rsp)\n  lea    0xe6e(%rip),%rax        # 2008 <_fini+0xd24>\n  mov    %rax,0x18(%rsp)\n  lea    0xe68(%rip),%rax        # 200e <_fini+0xd2a>\n  mov    %rax,0x20(%rsp)\n  lea    0xe62(%rip),%rax        # 2014 <_fini+0xd30>\n  mov    %rax,0x28(%rsp)\n  lea    0xe5b(%rip),%rax        # 2019 <_fini+0xd35>\n  mov    %rax,0x30(%rsp)\n  lea    0xe57(%rip),%rax        # 2021 <_fini+0xd3d>\n  mov    %rax,0x38(%rsp)\n  lea    0xe52(%rip),%rax        # 2028 <_fini+0xd44>\n  mov    %rax,0x40(%rsp)\n  lea    0xe4d(%rip),%rax        # 202f <_fini+0xd4b>\n  mov    %rax,0x48(%rsp)\n  mov    $0x0,%ebx\n  mov    $0xffffffff,%ebp\n  mov    $0xffffffff,%r13d\n  mov    0x10(%rsp,%rbx,8),%r12\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%r13d\n  mov    (%rsp),%rsi\n  mov    %r12,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%ebp\n  add    $0x1,%rbx\n  cmp    $0x8,%rbx\n  jne    11f7 <func0+0x9e>\n  cmp    $0xffffffff,%ebp\n  sete   %al\n  cmp    %ebp,%r13d\n  sete   %dl\n  or     %dl,%al\n  jne    12c0 <func0+0x167>\n  cmp    $0xffffffff,%r13d\n  je     12c0 <func0+0x167>\n  cmp    %ebp,%r13d\n  jle    124f <func0+0xf6>\n  mov    %r13d,%eax\n  mov    %ebp,%r13d\n  mov    %eax,%ebp\n  mov    %ebp,%eax\n  sub    %r13d,%eax\n  sub    $0x1,%eax\n  mov    0x8(%rsp),%rcx\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    12d2 <func0+0x179>\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   1090 <malloc@plt>\n  lea    0x1(%r13),%edx\n  cmp    %edx,%ebp\n  jle    12a1 <func0+0x148>\n  sub    $0x2,%ebp\n  sub    %r13d,%ebp\n  movslq %r13d,%r13\n  lea    0x10(%rsp,%r13,8),%rsi\n  mov    $0x0,%edx\n  mov    0x8(%rsi,%rdx,8),%rcx\n  mov    %rcx,(%rax,%rdx,8)\n  mov    %rdx,%rcx\n  add    $0x1,%rdx\n  cmp    %rbp,%rcx\n  jne    128c <func0+0x133>\n  mov    0x58(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12df <func0+0x186>\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    0x8(%rsp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    12a1 <func0+0x148>\n  movl   $0x0,(%rcx)\n  mov    $0x0,%eax\n  jmp    12a1 <func0+0x148>\n  call   1070 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %rdi,%r15\n  mov    %rsi,(%rsp)\n  mov    %rdx,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,0x10(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x18(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x20(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x28(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x30(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  mov    $0x0,%ebx\n  mov    $0xffffffff,%ebp\n  mov    $0xffffffff,%r13d\nL0:\n  mov    0x10(%rsp,%rbx,8),%r12\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%r13d\n  mov    (%rsp),%rsi\n  mov    %r12,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%ebp\n  add    $0x1,%rbx\n  cmp    $0x8,%rbx\n  jne    L0\n  cmp    $0xffffffff,%ebp\n  sete   %al\n  cmp    %ebp,%r13d\n  sete   %dl\n  or     %dl,%al\n  jne    L1\n  cmp    $0xffffffff,%r13d\n  je     L1\n  cmp    %ebp,%r13d\n  jle    L2\n  mov    %r13d,%eax\n  mov    %ebp,%r13d\n  mov    %eax,%ebp\nL2:\n  mov    %ebp,%eax\n  sub    %r13d,%eax\n  sub    $0x1,%eax\n  mov    0x8(%rsp),%rcx\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    L3\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   <malloc@plt>\n  lea    0x1(%r13),%edx\n  cmp    %edx,%ebp\n  jle    L4\n  sub    $0x2,%ebp\n  sub    %r13d,%ebp\n  movslq %r13d,%r13\n  lea    0x10(%rsp,%r13,8),%rsi\n  mov    $0x0,%edx\nL5:\n  mov    0x8(%rsi,%rdx,8),%rcx\n  mov    %rcx,(%rax,%rdx,8)\n  mov    %rdx,%rcx\n  add    $0x1,%rdx\n  cmp    %rbp,%rcx\n  jne    L5\nL4:\n  mov    0x58(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L6\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL1:\n  mov    0x8(%rsp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    L4\nL3:\n  movl   $0x0,(%rcx)\n  mov    $0x0,%eax\n  jmp    L4\nL6:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3698
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8200,
          "bias": [
            3694
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8206,
          "bias": [
            3688
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8212,
          "bias": [
            3682
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8217,
          "bias": [
            3675
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8225,
          "bias": [
            3671
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8232,
          "bias": [
            3666
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8239,
          "bias": [
            3661
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4599
        },
        "L1": {
          "label": "L1",
          "addr": 4800
        },
        "L2": {
          "label": "L2",
          "addr": 4687
        },
        "L3": {
          "label": "L3",
          "addr": 4818
        },
        "L4": {
          "label": "L4",
          "addr": 4769
        },
        "L5": {
          "label": "L5",
          "addr": 4748
        },
        "L6": {
          "label": "L6",
          "addr": 4831
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4d6572637572790056656e7573004561727468004d617273004a7570697465720053617475726e005572616e7573004e657074756e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Mercury\""
          },
          "0x2021": {
            "type": "string",
            "value": "\"Saturn\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"Venus\""
          },
          "0x2028": {
            "type": "string",
            "value": "\"Uranus\""
          },
          "0x200e": {
            "type": "string",
            "value": "\"Earth\""
          },
          "0x202f": {
            "type": "string",
            "value": "\"Neptune\""
          },
          "0x2014": {
            "type": "string",
            "value": "\"Mars\""
          },
          "0x2019": {
            "type": "string",
            "value": "\"Jupiter\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char *planet0, char *planet1, int *len) {\n  char *planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  int i, j, k, l;\n  char **ret;\n  i = -1;\n  j = -1;\n  for (k = 0; k < 8; k++) {\n    if (!strcmp(planets[k], planet0))\n      i = k;\n    if (!strcmp(planets[k], planet1))\n      j = k;\n  }\n  if (i == -1 || j == -1 || i == j) {\n    *len = 0;\n    return NULL;\n  }\n  if (i > j) {\n    l = i;\n    i = j;\n    j = l;\n  }\n  *len = j - i - 1;\n  if (*len <= 0) {\n    *len = 0;\n    return NULL;\n  }\n  ret = malloc(*len * sizeof(char *));\n  for (k = 0; i + 1 + k < j; k++)\n    ret[k] = planets[i + 1 + k];\n  return ret;\n}"
    },
    {
      "task_id": 151,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    11d0 <func0+0xb0>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x4(%rdi,%rax,4),%rbp\n  nopw   0x0(%rax,%rax,1)\n  movss  (%rbx),%xmm2\n  movaps %xmm2,%xmm0\n  movss  %xmm2,0xc(%rsp)\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm2\n  pxor   %xmm1,%xmm1\n  pxor   %xmm3,%xmm3\n  movsd  0xea0(%rip),%xmm4        # 2010 <_fini+0xe30>\n  cvtss2sd %xmm0,%xmm3\n  cvtss2sd %xmm2,%xmm1\n  subsd  %xmm3,%xmm1\n  andpd  0xe7c(%rip),%xmm1        # 2000 <_fini+0xe20>\n  comisd %xmm1,%xmm4\n  jbe    11b8 <func0+0x98>\n  pxor   %xmm5,%xmm5\n  comiss %xmm5,%xmm2\n  jbe    11b8 <func0+0x98>\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    11b8 <func0+0x98>\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rbx\n  cmp    %rbx,%rbp\n  jne    1148 <func0+0x28>\n  add    $0x10,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   (%rax)\n  add    $0x10,%rsp\n  xor    %r12d,%r12d\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x4(%rdi,%rax,4),%rbp\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movss  (%rbx),%xmm2\n  movaps %xmm2,%xmm0\n  movss  %xmm2,0xc(%rsp)\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm2\n  pxor   %xmm1,%xmm1\n  pxor   %xmm3,%xmm3\n  movsd  D0(%rip),%xmm4\n  cvtss2sd %xmm0,%xmm3\n  cvtss2sd %xmm2,%xmm1\n  subsd  %xmm3,%xmm1\n  andpd  D1(%rip),%xmm1\n  comisd %xmm1,%xmm4\n  jbe    L1\n  pxor   %xmm5,%xmm5\n  comiss %xmm5,%xmm2\n  jbe    L1\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  nopw   0x0(%rax,%rax,1)\nL1:\n  add    $0x4,%rbx\n  cmp    %rbx,%rbp\n  jne    L2\n  add    $0x10,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   (%rax)\nL0:\n  add    $0x10,%rsp\n  xor    %r12d,%r12d\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8208,
          "bias": [
            3744
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3708
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4560
        },
        "L1": {
          "label": "L1",
          "addr": 4536
        },
        "L2": {
          "label": "L2",
          "addr": 4424
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffffffffffff7f00000000000000002d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "qword[2]",
            "value": [
              9223372036854775807,
              0
            ]
          },
          "0x2010": {
            "type": "byte[8]",
            "value": [
              45,
              67,
              28,
              235,
              226,
              54,
              26,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " long func0(float *array, int len) {\n  long sum = 0;\n  for (int i = 0; i < len; i++) {\n    float el = array[i];\n    float el_rounded = roundf(el);\n    if (fabs(el - el_rounded) < 0.0001 && el > 0) {\n      int el_rounded_int = (int)el_rounded;\n      if (el_rounded_int % 2 == 1) {\n        sum += el_rounded_int * el_rounded_int;\n      }\n    }\n  }\n  return sum;\n}"
    },
    {
      "task_id": 148,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x90,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %rsi,-0x80(%rbp)\n  mov    %rdx,-0x88(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    0xe73(%rip),%rax        # 2000 <_fini+0xcd0>\n  mov    %rax,-0x50(%rbp)\n  lea    0xe70(%rip),%rax        # 2008 <_fini+0xcd8>\n  mov    %rax,-0x48(%rbp)\n  lea    0xe6b(%rip),%rax        # 200e <_fini+0xcde>\n  mov    %rax,-0x40(%rbp)\n  lea    0xe66(%rip),%rax        # 2014 <_fini+0xce4>\n  mov    %rax,-0x38(%rbp)\n  lea    0xe60(%rip),%rax        # 2019 <_fini+0xce9>\n  mov    %rax,-0x30(%rbp)\n  lea    0xe5d(%rip),%rax        # 2021 <_fini+0xcf1>\n  mov    %rax,-0x28(%rbp)\n  lea    0xe59(%rip),%rax        # 2028 <_fini+0xcf8>\n  mov    %rax,-0x20(%rbp)\n  lea    0xe55(%rip),%rax        # 202f <_fini+0xcff>\n  mov    %rax,-0x18(%rbp)\n  movl   $0xffffffff,-0x68(%rbp)\n  movl   $0xffffffff,-0x64(%rbp)\n  movl   $0x0,-0x60(%rbp)\n  jmp    123f <func0+0xe6>\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    -0x78(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  jne    1218 <func0+0xbf>\n  mov    -0x60(%rbp),%eax\n  mov    %eax,-0x68(%rbp)\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    -0x80(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  jne    123b <func0+0xe2>\n  mov    -0x60(%rbp),%eax\n  mov    %eax,-0x64(%rbp)\n  addl   $0x1,-0x60(%rbp)\n  cmpl   $0x7,-0x60(%rbp)\n  jle    11f5 <func0+0x9c>\n  cmpl   $0xffffffff,-0x68(%rbp)\n  je     1259 <func0+0x100>\n  cmpl   $0xffffffff,-0x64(%rbp)\n  je     1259 <func0+0x100>\n  mov    -0x68(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jne    1270 <func0+0x117>\n  mov    -0x88(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    1317 <func0+0x1be>\n  mov    -0x68(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    128a <func0+0x131>\n  mov    -0x68(%rbp),%eax\n  mov    %eax,-0x5c(%rbp)\n  mov    -0x64(%rbp),%eax\n  mov    %eax,-0x68(%rbp)\n  mov    -0x5c(%rbp),%eax\n  mov    %eax,-0x64(%rbp)\n  mov    -0x64(%rbp),%eax\n  sub    -0x68(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    -0x88(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jg     12bd <func0+0x164>\n  mov    -0x88(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    1317 <func0+0x1be>\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x58(%rbp)\n  mov    -0x68(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x60(%rbp)\n  jmp    130b <func0+0x1b2>\n  mov    -0x60(%rbp),%eax\n  sub    -0x68(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x60(%rbp)\n  mov    -0x60(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jl     12e3 <func0+0x18a>\n  mov    -0x58(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     132b <func0+0x1d2>\n  call   1070 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x90,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %rsi,-0x80(%rbp)\n  mov    %rdx,-0x88(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,-0x50(%rbp)\n  lea    D1(%rip),%rax\n  mov    %rax,-0x48(%rbp)\n  lea    D2(%rip),%rax\n  mov    %rax,-0x40(%rbp)\n  lea    D3(%rip),%rax\n  mov    %rax,-0x38(%rbp)\n  lea    D4(%rip),%rax\n  mov    %rax,-0x30(%rbp)\n  lea    D5(%rip),%rax\n  mov    %rax,-0x28(%rbp)\n  lea    D6(%rip),%rax\n  mov    %rax,-0x20(%rbp)\n  lea    D7(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  movl   $0xffffffff,-0x68(%rbp)\n  movl   $0xffffffff,-0x64(%rbp)\n  movl   $0x0,-0x60(%rbp)\n  jmp    L0\nL3:\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    -0x78(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L1\n  mov    -0x60(%rbp),%eax\n  mov    %eax,-0x68(%rbp)\nL1:\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    -0x80(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L2\n  mov    -0x60(%rbp),%eax\n  mov    %eax,-0x64(%rbp)\nL2:\n  addl   $0x1,-0x60(%rbp)\nL0:\n  cmpl   $0x7,-0x60(%rbp)\n  jle    L3\n  cmpl   $0xffffffff,-0x68(%rbp)\n  je     L4\n  cmpl   $0xffffffff,-0x64(%rbp)\n  je     L4\n  mov    -0x68(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jne    L5\nL4:\n  mov    -0x88(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    L6\nL5:\n  mov    -0x68(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L7\n  mov    -0x68(%rbp),%eax\n  mov    %eax,-0x5c(%rbp)\n  mov    -0x64(%rbp),%eax\n  mov    %eax,-0x68(%rbp)\n  mov    -0x5c(%rbp),%eax\n  mov    %eax,-0x64(%rbp)\nL7:\n  mov    -0x64(%rbp),%eax\n  sub    -0x68(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    -0x88(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jg     L8\n  mov    -0x88(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    L6\nL8:\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x58(%rbp)\n  mov    -0x68(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x60(%rbp)\n  jmp    L9\nL10:\n  mov    -0x60(%rbp),%eax\n  sub    -0x68(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x60(%rbp)\nL9:\n  mov    -0x60(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jl     L10\n  mov    -0x58(%rbp),%rax\nL6:\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L11\n  call   <__stack_chk_fail@plt>\nL11:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3699
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8200,
          "bias": [
            3696
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8206,
          "bias": [
            3691
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8212,
          "bias": [
            3686
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8217,
          "bias": [
            3680
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8225,
          "bias": [
            3677
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8232,
          "bias": [
            3673
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8239,
          "bias": [
            3669
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4671
        },
        "L1": {
          "label": "L1",
          "addr": 4632
        },
        "L2": {
          "label": "L2",
          "addr": 4667
        },
        "L3": {
          "label": "L3",
          "addr": 4597
        },
        "L4": {
          "label": "L4",
          "addr": 4697
        },
        "L5": {
          "label": "L5",
          "addr": 4720
        },
        "L6": {
          "label": "L6",
          "addr": 4887
        },
        "L7": {
          "label": "L7",
          "addr": 4746
        },
        "L8": {
          "label": "L8",
          "addr": 4797
        },
        "L9": {
          "label": "L9",
          "addr": 4875
        },
        "L10": {
          "label": "L10",
          "addr": 4835
        },
        "L11": {
          "label": "L11",
          "addr": 4907
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4d6572637572790056656e7573004561727468004d617273004a7570697465720053617475726e005572616e7573004e657074756e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Mercury\""
          },
          "0x2021": {
            "type": "string",
            "value": "\"Saturn\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"Venus\""
          },
          "0x2028": {
            "type": "string",
            "value": "\"Uranus\""
          },
          "0x200e": {
            "type": "string",
            "value": "\"Earth\""
          },
          "0x202f": {
            "type": "string",
            "value": "\"Neptune\""
          },
          "0x2014": {
            "type": "string",
            "value": "\"Mars\""
          },
          "0x2019": {
            "type": "string",
            "value": "\"Jupiter\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char *body1, char *body2, int *n) {\n  char *bodies[8] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  int i, j, k;\n  int body1_index = -1, body2_index = -1;\n  for (i = 0; i < 8; i++) {\n    if (!strcmp(bodies[i], body1))\n      body1_index = i;\n    if (!strcmp(bodies[i], body2))\n      body2_index = i;\n  }\n  if (body1_index == -1 || body2_index == -1 || body1_index == body2_index) {\n    *n = 0;\n    return NULL;\n  }\n  if (body1_index > body2_index) {\n    k = body1_index;\n    body1_index = body2_index;\n    body2_index = k;\n  }\n  *n = body2_index - body1_index - 1;\n  if (*n <= 0) {\n    *n = 0;\n    return NULL;\n  }\n  char **result = malloc(*n * sizeof(char *));\n  for (i = body1_index + 1; i < body2_index; i++)\n    result[i - body1_index - 1] = bodies[i];\n  return result;\n}"
    },
    {
      "task_id": 147,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  movslq %edi,%r14\n  push   %r13\n  lea    0x0(,%r14,4),%rdi\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %r14,%rbx\n  sub    $0x18,%rsp\n  call   1090 <malloc@plt>\n  mov    %rax,%r13\n  lea    0x1(%r14),%eax\n  cltq\n  lea    0x0(,%rax,8),%r15\n  mov    %r15,%rdi\n  mov    %r15,0x8(%rsp)\n  call   1090 <malloc@plt>\n  mov    %r15,%rdi\n  xor    %r15d,%r15d\n  mov    %rax,%rbp\n  call   1090 <malloc@plt>\n  mov    %rax,%r12\n  lea    0x8(,%r14,8),%rax\n  mov    %rax,(%rsp)\n  test   %r14d,%r14d\n  js     1426 <func0+0x2c6>\n  nopl   0x0(%rax)\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  mov    %rax,0x0(%rbp,%r15,1)\n  call   1080 <calloc@plt>\n  mov    %rax,(%r12,%r15,1)\n  add    $0x8,%r15\n  cmp    (%rsp),%r15\n  jne    11d0 <func0+0x70>\n  mov    0x0(%rbp),%rax\n  mov    (%r12),%r9\n  movl   $0x0,0x8(%rax)\n  movq   $0x0,(%rax)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r9)\n  test   %ebx,%ebx\n  jle    128a <func0+0x12a>\n  xor    %edx,%edx\n  xor    %edi,%edi\n  mov    $0xaaaaaaab,%esi\n  jmp    123f <func0+0xdf>\n  nopl   (%rax)\n  mov    0x0(%rbp,%rdx,8),%rax\n  mov    (%rax),%edi\n  lea    0x1(%rdx),%ecx\n  imul   %edx,%ecx\n  lea    0x1(%rcx),%eax\n  mov    %rax,%rcx\n  imul   %rsi,%rax\n  shr    $0x21,%rax\n  lea    (%rax,%rax,2),%r10d\n  mov    %ecx,%eax\n  mov    0x8(%rbp,%rdx,8),%rcx\n  sub    %r10d,%eax\n  mov    0x0(%rbp,%rdx,8),%r10\n  mov    %edi,(%rcx)\n  mov    0x4(%r10),%edi\n  mov    %eax,0x0(%r13,%rdx,4)\n  cltq\n  add    $0x1,%rdx\n  mov    %edi,0x4(%rcx)\n  mov    0x8(%r10),%edi\n  mov    %edi,0x8(%rcx)\n  addl   $0x1,(%rcx,%rax,4)\n  cmp    %r14,%rdx\n  jne    1238 <func0+0xd8>\n  mov    $0x2,%r10d\n  mov    %r9,%rdx\n  xor    %esi,%esi\n  test   %ebx,%ebx\n  jle    1394 <func0+0x234>\n  nopl   (%rax)\n  mov    %rdx,%rax\n  mov    0x8(%r12,%rsi,8),%rdx\n  mov    (%rax),%ecx\n  mov    %ecx,(%rdx)\n  mov    0x4(%rax),%ecx\n  mov    %ecx,0x4(%rdx)\n  movslq 0x0(%r13,%rsi,4),%rcx\n  mov    0x8(%rax),%eax\n  mov    %eax,0x8(%rdx)\n  mov    %rcx,%rax\n  imul   $0x55555556,%rcx,%rcx\n  mov    %eax,%edi\n  sar    $0x1f,%edi\n  shr    $0x20,%rcx\n  sub    %edi,%ecx\n  lea    (%rcx,%rcx,2),%edi\n  mov    %eax,%ecx\n  sub    %edi,%ecx\n  mov    0x0(%rbp,%rsi,8),%rdi\n  add    $0x1,%rsi\n  movslq %ecx,%rcx\n  mov    (%rdi),%r11d\n  add    %r11d,(%rdx,%rcx,4)\n  lea    0x1(%rax),%ecx\n  add    $0x2,%eax\n  movslq %ecx,%r11\n  mov    %ecx,%r15d\n  imul   $0x55555556,%r11,%r11\n  sar    $0x1f,%r15d\n  shr    $0x20,%r11\n  sub    %r15d,%r11d\n  lea    (%r11,%r11,2),%r11d\n  sub    %r11d,%ecx\n  mov    0x4(%rdi),%r11d\n  movslq %ecx,%rcx\n  add    %r11d,(%rdx,%rcx,4)\n  movslq %eax,%rcx\n  mov    %eax,%r11d\n  imul   $0x55555556,%rcx,%rcx\n  sar    $0x1f,%r11d\n  shr    $0x20,%rcx\n  sub    %r11d,%ecx\n  lea    (%rcx,%rcx,2),%ecx\n  sub    %ecx,%eax\n  mov    0x8(%rdi),%ecx\n  cltq\n  add    %ecx,(%rdx,%rax,4)\n  cmp    %r14,%rsi\n  jne    12a0 <func0+0x140>\n  xor    %eax,%eax\n  nopl   0x0(%rax)\n  mov    (%r12,%rax,8),%rdx\n  mov    0x0(%rbp,%rax,8),%rcx\n  add    $0x1,%rax\n  mov    (%rdx),%rsi\n  movq   $0x0,(%rdx)\n  mov    %rsi,(%rcx)\n  mov    0x8(%rdx),%esi\n  movl   $0x0,0x8(%rdx)\n  mov    %esi,0x8(%rcx)\n  cmp    %eax,%ebx\n  jge    1350 <func0+0x1f0>\n  cmp    $0x1,%r10d\n  je     13c0 <func0+0x260>\n  mov    $0x1,%r10d\n  mov    %r9,%rdx\n  xor    %esi,%esi\n  test   %ebx,%ebx\n  jg     12a0 <func0+0x140>\n  jne    137b <func0+0x21b>\n  mov    (%r12),%rax\n  mov    0x0(%rbp),%rdx\n  mov    (%rax),%rcx\n  movq   $0x0,(%rax)\n  mov    %rcx,(%rdx)\n  mov    0x8(%rax),%ecx\n  movl   $0x0,0x8(%rax)\n  mov    %ecx,0x8(%rdx)\n  jmp    137b <func0+0x21b>\n  nopw   0x0(%rax,%rax,1)\n  mov    0x8(%rsp),%rax\n  lea    0x8(,%r14,8),%r15\n  xor    %r14d,%r14d\n  mov    -0x8(%rbp,%rax,1),%rax\n  mov    (%rax),%eax\n  mov    %eax,(%rsp)\n  test   %ebx,%ebx\n  js     13fc <func0+0x29c>\n  xchg   %ax,%ax\n  mov    0x0(%rbp,%r14,1),%rdi\n  call   1070 <free@plt>\n  mov    (%r12,%r14,1),%rdi\n  add    $0x8,%r14\n  call   1070 <free@plt>\n  cmp    %r15,%r14\n  jne    13e0 <func0+0x280>\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  mov    %r12,%rdi\n  call   1070 <free@plt>\n  mov    %r13,%rdi\n  call   1070 <free@plt>\n  mov    (%rsp),%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    0x0(%rbp),%rax\n  mov    (%r12),%r9\n  movl   $0x0,0x8(%rax)\n  movq   $0x0,(%rax)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r9)\n  jmp    128a <func0+0x12a>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  movslq %edi,%r14\n  push   %r13\n  lea    0x0(,%r14,4),%rdi\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %r14,%rbx\n  sub    $0x18,%rsp\n  call   <malloc@plt>\n  mov    %rax,%r13\n  lea    0x1(%r14),%eax\n  cltq\n  lea    0x0(,%rax,8),%r15\n  mov    %r15,%rdi\n  mov    %r15,0x8(%rsp)\n  call   <malloc@plt>\n  mov    %r15,%rdi\n  xor    %r15d,%r15d\n  mov    %rax,%rbp\n  call   <malloc@plt>\n  mov    %rax,%r12\n  lea    0x8(,%r14,8),%rax\n  mov    %rax,(%rsp)\n  test   %r14d,%r14d\n  js     L0\n  nopl   0x0(%rax)\nL1:\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  mov    %rax,0x0(%rbp,%r15,1)\n  call   <calloc@plt>\n  mov    %rax,(%r12,%r15,1)\n  add    $0x8,%r15\n  cmp    (%rsp),%r15\n  jne    L1\n  mov    0x0(%rbp),%rax\n  mov    (%r12),%r9\n  movl   $0x0,0x8(%rax)\n  movq   $0x0,(%rax)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r9)\n  test   %ebx,%ebx\n  jle    L2\n  xor    %edx,%edx\n  xor    %edi,%edi\n  mov    $0xaaaaaaab,%esi\n  jmp    L3\n  nopl   (%rax)\nL4:\n  mov    0x0(%rbp,%rdx,8),%rax\n  mov    (%rax),%edi\nL3:\n  lea    0x1(%rdx),%ecx\n  imul   %edx,%ecx\n  lea    0x1(%rcx),%eax\n  mov    %rax,%rcx\n  imul   %rsi,%rax\n  shr    $0x21,%rax\n  lea    (%rax,%rax,2),%r10d\n  mov    %ecx,%eax\n  mov    0x8(%rbp,%rdx,8),%rcx\n  sub    %r10d,%eax\n  mov    0x0(%rbp,%rdx,8),%r10\n  mov    %edi,(%rcx)\n  mov    0x4(%r10),%edi\n  mov    %eax,0x0(%r13,%rdx,4)\n  cltq\n  add    $0x1,%rdx\n  mov    %edi,0x4(%rcx)\n  mov    0x8(%r10),%edi\n  mov    %edi,0x8(%rcx)\n  addl   $0x1,(%rcx,%rax,4)\n  cmp    %r14,%rdx\n  jne    L4\nL2:\n  mov    $0x2,%r10d\n  mov    %r9,%rdx\n  xor    %esi,%esi\n  test   %ebx,%ebx\n  jle    L5\n  nopl   (%rax)\nL6:\n  mov    %rdx,%rax\n  mov    0x8(%r12,%rsi,8),%rdx\n  mov    (%rax),%ecx\n  mov    %ecx,(%rdx)\n  mov    0x4(%rax),%ecx\n  mov    %ecx,0x4(%rdx)\n  movslq 0x0(%r13,%rsi,4),%rcx\n  mov    0x8(%rax),%eax\n  mov    %eax,0x8(%rdx)\n  mov    %rcx,%rax\n  imul   $0x55555556,%rcx,%rcx\n  mov    %eax,%edi\n  sar    $0x1f,%edi\n  shr    $0x20,%rcx\n  sub    %edi,%ecx\n  lea    (%rcx,%rcx,2),%edi\n  mov    %eax,%ecx\n  sub    %edi,%ecx\n  mov    0x0(%rbp,%rsi,8),%rdi\n  add    $0x1,%rsi\n  movslq %ecx,%rcx\n  mov    (%rdi),%r11d\n  add    %r11d,(%rdx,%rcx,4)\n  lea    0x1(%rax),%ecx\n  add    $0x2,%eax\n  movslq %ecx,%r11\n  mov    %ecx,%r15d\n  imul   $0x55555556,%r11,%r11\n  sar    $0x1f,%r15d\n  shr    $0x20,%r11\n  sub    %r15d,%r11d\n  lea    (%r11,%r11,2),%r11d\n  sub    %r11d,%ecx\n  mov    0x4(%rdi),%r11d\n  movslq %ecx,%rcx\n  add    %r11d,(%rdx,%rcx,4)\n  movslq %eax,%rcx\n  mov    %eax,%r11d\n  imul   $0x55555556,%rcx,%rcx\n  sar    $0x1f,%r11d\n  shr    $0x20,%rcx\n  sub    %r11d,%ecx\n  lea    (%rcx,%rcx,2),%ecx\n  sub    %ecx,%eax\n  mov    0x8(%rdi),%ecx\n  cltq\n  add    %ecx,(%rdx,%rax,4)\n  cmp    %r14,%rsi\n  jne    L6\n  xor    %eax,%eax\n  nopl   0x0(%rax)\nL7:\n  mov    (%r12,%rax,8),%rdx\n  mov    0x0(%rbp,%rax,8),%rcx\n  add    $0x1,%rax\n  mov    (%rdx),%rsi\n  movq   $0x0,(%rdx)\n  mov    %rsi,(%rcx)\n  mov    0x8(%rdx),%esi\n  movl   $0x0,0x8(%rdx)\n  mov    %esi,0x8(%rcx)\n  cmp    %eax,%ebx\n  jge    L7\nL9:\n  cmp    $0x1,%r10d\n  je     L8\n  mov    $0x1,%r10d\n  mov    %r9,%rdx\n  xor    %esi,%esi\n  test   %ebx,%ebx\n  jg     L6\nL5:\n  jne    L9\n  mov    (%r12),%rax\n  mov    0x0(%rbp),%rdx\n  mov    (%rax),%rcx\n  movq   $0x0,(%rax)\n  mov    %rcx,(%rdx)\n  mov    0x8(%rax),%ecx\n  movl   $0x0,0x8(%rax)\n  mov    %ecx,0x8(%rdx)\n  jmp    L9\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    0x8(%rsp),%rax\n  lea    0x8(,%r14,8),%r15\n  xor    %r14d,%r14d\n  mov    -0x8(%rbp,%rax,1),%rax\n  mov    (%rax),%eax\n  mov    %eax,(%rsp)\n  test   %ebx,%ebx\n  js     L10\n  xchg   %ax,%ax\nL11:\n  mov    0x0(%rbp,%r14,1),%rdi\n  call   <free@plt>\n  mov    (%r12,%r14,1),%rdi\n  add    $0x8,%r14\n  call   <free@plt>\n  cmp    %r15,%r14\n  jne    L11\nL10:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  mov    (%rsp),%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  mov    0x0(%rbp),%rax\n  mov    (%r12),%r9\n  movl   $0x0,0x8(%rax)\n  movq   $0x0,(%rax)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r9)\n  jmp    L2",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 5158
        },
        "L1": {
          "label": "L1",
          "addr": 4560
        },
        "L2": {
          "label": "L2",
          "addr": 4746
        },
        "L3": {
          "label": "L3",
          "addr": 4671
        },
        "L4": {
          "label": "L4",
          "addr": 4664
        },
        "L5": {
          "label": "L5",
          "addr": 5012
        },
        "L6": {
          "label": "L6",
          "addr": 4768
        },
        "L7": {
          "label": "L7",
          "addr": 4944
        },
        "L8": {
          "label": "L8",
          "addr": 5056
        },
        "L9": {
          "label": "L9",
          "addr": 4987
        },
        "L10": {
          "label": "L10",
          "addr": 5116
        },
        "L11": {
          "label": "L11",
          "addr": 5088
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(int n) {\n  int *a = malloc(n * sizeof(int));\n  int **b = malloc((n + 1) * sizeof(int *));\n  int **c = malloc((n + 1) * sizeof(int *));\n  for (int i = 0; i < n + 1; i++) {\n    b[i] = calloc(3, sizeof(int));\n    c[i] = calloc(3, sizeof(int));\n  }\n  b[0][0] = b[0][1] = b[0][2] = 0;\n  c[0][0] = c[0][1] = c[0][2] = 0;\n  int j = 0;\n  for (int i = 0; i < n; i++) {\n    j = i * (i + 1) / 3;\n    a[i] = j;\n    b[i + 1][0] = b[i][0];\n    b[i + 1][1] = b[i][1];\n    b[i + 1][2] = b[i][2];\n    b[i + 1][j]++;\n  }\n  int k = 0;\n  int l = 2;\n  while (l > 1) {\n    for (int i = 0; i < n; i++) {\n      c[i + 1][0] = c[i][0];\n      c[i + 1][1] = c[i][1];\n      c[i + 1][2] = c[i][2];\n      c[i + 1][a[i]] += b[i][0];\n      c[i + 1][(a[i] + 1) % 3] += b[i][1];\n      c[i + 1][(a[i] + 2) % 3] += b[i][2];\n    }\n    for (int i = 0; i < n + 1; i++) {\n      b[i][0] = c[i][0];\n      b[i][1] = c[i][1];\n      b[i][2] = c[i][2];\n      c[i][0] = c[i][1] = c[i][2] = 0;\n    }\n    l--;\n    if (l == 0) {\n      k = b[n][0];\n      break;\n    }\n  }\n  for (int i = 0; i < n + 1; i++) {\n    free(b[i]);\n    free(c[i]);\n  }\n  free(b);\n  free(c);\n  free(a);\n  return k;\n}"
    },
    {
      "task_id": 155,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    115e <func0+0x65>\n  addl   $0x1,-0xc(%rbp)\n  jmp    1162 <func0+0x69>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     1123 <func0+0x2a>\n  mov    -0x20(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,-0x14(%rbp)\nL2:\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L0\n  addl   $0x1,-0xc(%rbp)\n  jmp    L1\nL0:\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     L2\n  mov    -0x20(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4446
        },
        "L1": {
          "label": "L1",
          "addr": 4450
        },
        "L2": {
          "label": "L2",
          "addr": 4387
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b[2]) {\n  int c = 0, d = 0;\n  a = a > 0 ? a : -a;\n  do {\n    int e = a % 10;\n    if (e % 2 == 0)\n      c++;\n    else\n      d++;\n  } while (a /= 10);\n  b[0] = c;\n  b[1] = d;\n}"
    },
    {
      "task_id": 154,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,-0x10(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    127f <func0+0xe6>\n  mov    -0xc(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   10a0 <strncpy@plt>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xc(%rbp),%eax\n  cltq\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  sub    %rcx,%rax\n  mov    %rax,%rsi\n  mov    -0x8(%rbp),%rax\n  lea    (%rsi,%rax,1),%rcx\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   10a0 <strncpy@plt>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10d0 <strstr@plt>\n  test   %rax,%rax\n  je     127b <func0+0xe2>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    $0x1,%eax\n  jmp    129c <func0+0x103>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     11ed <func0+0x54>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    $0x0,%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x10(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL3:\n  mov    -0xc(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xc(%rbp),%eax\n  cltq\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  sub    %rcx,%rax\n  mov    %rax,%rsi\n  mov    -0x8(%rbp),%rax\n  lea    (%rsi,%rax,1),%rcx\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   <strncpy@plt>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L1\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    $0x1,%eax\n  jmp    L2\nL1:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L3\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    $0x0,%eax\nL2:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4735
        },
        "L1": {
          "label": "L1",
          "addr": 4731
        },
        "L2": {
          "label": "L2",
          "addr": 4764
        },
        "L3": {
          "label": "L3",
          "addr": 4589
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(const char *s, const char *t) {\n  int s_len = strlen(s);\n  int t_len = strlen(t);\n  char *buf = malloc(t_len * 2 + 1);\n  for (int i = 0; i < t_len; i++) {\n    strncpy(buf, t + i, t_len - i);\n    strncpy(buf + t_len - i, t, i);\n    buf[t_len] = '\\0';\n    if (strstr(s, buf)) {\n      free(buf);\n      return 1;\n    }\n  }\n  free(buf);\n  return 0;\n}"
    },
    {
      "task_id": 154,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %rsi,%r13\n  mov    %rsi,%rdi\n  call   10b0 <strlen@plt>\n  mov    %rax,%rbx\n  mov    %eax,%r12d\n  lea    0x1(%rax,%rax,1),%edi\n  movslq %edi,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jle    1228 <func0+0x8f>\n  lea    -0x1(%rbx),%r15d\n  mov    $0x0,%ebx\n  movslq %r12d,%r12\n  jmp    11e3 <func0+0x4a>\n  mov    %rax,%rbx\n  mov    %r12,%rdx\n  sub    %rbx,%rdx\n  lea    0x0(%r13,%rbx,1),%rsi\n  mov    %rbp,%rdi\n  call   10a0 <strncpy@plt>\n  lea    0x0(%rbp,%r12,1),%rdi\n  sub    %rbx,%rdi\n  mov    %rbx,%rdx\n  mov    %r13,%rsi\n  call   10a0 <strncpy@plt>\n  movb   $0x0,0x0(%rbp,%r12,1)\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   10d0 <strstr@plt>\n  test   %rax,%rax\n  jne    1244 <func0+0xab>\n  lea    0x1(%rbx),%rax\n  cmp    %r15,%rbx\n  jne    11e0 <func0+0x47>\n  mov    %rbp,%rdi\n  call   1090 <free@plt>\n  mov    $0x0,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    %rbp,%rdi\n  call   1090 <free@plt>\n  mov    $0x1,%eax\n  jmp    1235 <func0+0x9c>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %rsi,%r13\n  mov    %rsi,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rbx\n  mov    %eax,%r12d\n  lea    0x1(%rax,%rax,1),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jle    L0\n  lea    -0x1(%rbx),%r15d\n  mov    $0x0,%ebx\n  movslq %r12d,%r12\n  jmp    L1\nL3:\n  mov    %rax,%rbx\nL1:\n  mov    %r12,%rdx\n  sub    %rbx,%rdx\n  lea    0x0(%r13,%rbx,1),%rsi\n  mov    %rbp,%rdi\n  call   <strncpy@plt>\n  lea    0x0(%rbp,%r12,1),%rdi\n  sub    %rbx,%rdi\n  mov    %rbx,%rdx\n  mov    %r13,%rsi\n  call   <strncpy@plt>\n  movb   $0x0,0x0(%rbp,%r12,1)\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  jne    L2\n  lea    0x1(%rbx),%rax\n  cmp    %r15,%rbx\n  jne    L3\nL0:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    $0x0,%eax\nL4:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL2:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    $0x1,%eax\n  jmp    L4",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4648
        },
        "L1": {
          "label": "L1",
          "addr": 4579
        },
        "L2": {
          "label": "L2",
          "addr": 4676
        },
        "L3": {
          "label": "L3",
          "addr": 4576
        },
        "L4": {
          "label": "L4",
          "addr": 4661
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char *str, char *sub) {\n  int i;\n  size_t len;\n  char *buf;\n  len = strlen(sub);\n  buf = malloc(len * 2 + 1);\n  for (i = 0; i < len; i++) {\n    strncpy(buf, sub + i, len - i);\n    strncpy(buf + len - i, sub, i);\n    buf[len] = '\\0';\n    if (strstr(str, buf)) {\n      free(buf);\n      return 1;\n    }\n  }\n  free(buf);\n  return 0;\n}"
    },
    {
      "task_id": 155,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  neg    %edx\n  cmovs  %edi,%edx\n  mov    $0x0,%edi\n  mov    $0x0,%r8d\n  jmp    1131 <func0+0x38>\n  add    $0x1,%r8d\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    113b <func0+0x42>\n  mov    %eax,%edx\n  test   $0x1,%dl\n  je     1111 <func0+0x18>\n  add    $0x1,%edi\n  jmp    1115 <func0+0x1c>\n  mov    %r8d,(%rsi)\n  mov    %edi,0x4(%rsi)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  neg    %edx\n  cmovs  %edi,%edx\n  mov    $0x0,%edi\n  mov    $0x0,%r8d\n  jmp    L0\nL2:\n  add    $0x1,%r8d\nL3:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    L1\n  mov    %eax,%edx\nL0:\n  test   $0x1,%dl\n  je     L2\n  add    $0x1,%edi\n  jmp    L3\nL1:\n  mov    %r8d,(%rsi)\n  mov    %edi,0x4(%rsi)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4401
        },
        "L1": {
          "label": "L1",
          "addr": 4411
        },
        "L2": {
          "label": "L2",
          "addr": 4369
        },
        "L3": {
          "label": "L3",
          "addr": 4373
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b[2]) {\n  int c = 0, d = 0;\n  a = abs(a);\n  while (a > 0) {\n    if (a % 2 == 0)\n      c++;\n    else\n      d++;\n    a /= 10;\n  }\n  b[0] = c;\n  b[1] = d;\n}"
    },
    {
      "task_id": 153,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %edx,-0x44(%rbp)\n  mov    %rcx,-0x50(%rbp)\n  movl   $0xfffffc18,-0x20(%rbp)\n  movq   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    11df <func0+0xc6>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x40(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11b1 <func0+0x98>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x21(%rbp)\n  cmpb   $0x40,-0x21(%rbp)\n  jle    119d <func0+0x84>\n  cmpb   $0x5a,-0x21(%rbp)\n  jg     119d <func0+0x84>\n  addl   $0x1,-0x18(%rbp)\n  cmpb   $0x60,-0x21(%rbp)\n  jle    11ad <func0+0x94>\n  cmpb   $0x7a,-0x21(%rbp)\n  jg     11ad <func0+0x94>\n  subl   $0x1,-0x18(%rbp)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    117a <func0+0x61>\n  mov    -0x18(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jle    11db <func0+0xc2>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x20(%rbp)\n  mov    -0x8(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     114f <func0+0x36>\n  mov    -0x10(%rbp),%rcx\n  mov    -0x38(%rbp),%rdx\n  mov    -0x50(%rbp),%rax\n  lea    0xe02(%rip),%rsi        # 2000 <_fini+0xdf0>\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1050 <sprintf@plt>\n  nop\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %edx,-0x44(%rbp)\n  mov    %rcx,-0x50(%rbp)\n  movl   $0xfffffc18,-0x20(%rbp)\n  movq   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL6:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x40(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L1\nL4:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x21(%rbp)\n  cmpb   $0x40,-0x21(%rbp)\n  jle    L2\n  cmpb   $0x5a,-0x21(%rbp)\n  jg     L2\n  addl   $0x1,-0x18(%rbp)\nL2:\n  cmpb   $0x60,-0x21(%rbp)\n  jle    L3\n  cmpb   $0x7a,-0x21(%rbp)\n  jg     L3\n  subl   $0x1,-0x18(%rbp)\nL3:\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L4\n  mov    -0x18(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jle    L5\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x20(%rbp)\n  mov    -0x8(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\nL5:\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     L6\n  mov    -0x10(%rbp),%rcx\n  mov    -0x38(%rbp),%rdx\n  mov    -0x50(%rbp),%rax\n  lea    D0(%rip),%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  nop\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3586
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4575
        },
        "L1": {
          "label": "L1",
          "addr": 4529
        },
        "L2": {
          "label": "L2",
          "addr": 4509
        },
        "L3": {
          "label": "L3",
          "addr": 4525
        },
        "L4": {
          "label": "L4",
          "addr": 4474
        },
        "L5": {
          "label": "L5",
          "addr": 4571
        },
        "L6": {
          "label": "L6",
          "addr": 4431
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "25732e257300",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%s.%s\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, char **b, int c, char *d) {\n  int i, j, k, min = -1000;\n  char *str = NULL;\n  for (i = 0; i < c; i++) {\n    char *tmp = b[i];\n    k = 0;\n    for (j = 0; tmp[j] != '\\0'; j++) {\n      char ch = tmp[j];\n      if (ch >= 'A' && ch <= 'Z')\n        k++;\n      if (ch >= 'a' && ch <= 'z')\n        k--;\n    }\n    if (k > min) {\n      min = k;\n      str = tmp;\n    }\n  }\n  sprintf(d, \"%s.%s\", a, str);\n}"
    },
    {
      "task_id": 153,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r8\n  mov    %rcx,%rbp\n  test   %edx,%edx\n  jle    1197 <func0+0x7e>\n  mov    %rsi,%rdi\n  lea    -0x1(%rdx),%eax\n  lea    0x8(%rsi,%rax,8),%rbx\n  mov    $0x0,%r9d\n  mov    $0xfffffc18,%r11d\n  jmp    1181 <func0+0x68>\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%eax\n  test   %al,%al\n  je     116d <func0+0x54>\n  lea    -0x41(%rax),%esi\n  cmp    $0x19,%sil\n  ja     1146 <func0+0x2d>\n  add    $0x1,%ecx\n  jmp    114e <func0+0x35>\n  mov    $0x0,%ecx\n  cmp    %ecx,%r11d\n  jge    1178 <func0+0x5f>\n  mov    %r10,%r9\n  mov    %ecx,%r11d\n  add    $0x8,%rdi\n  cmp    %rbx,%rdi\n  je     119d <func0+0x84>\n  mov    (%rdi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     1168 <func0+0x4f>\n  lea    0x1(%r10),%rdx\n  mov    $0x0,%ecx\n  jmp    115a <func0+0x41>\n  mov    $0x0,%r9d\n  lea    0xe5c(%rip),%rcx        # 2000 <_fini+0xe3c>\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  mov    %rbp,%rdi\n  mov    $0x0,%eax\n  call   1050 <__sprintf_chk@plt>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r8\n  mov    %rcx,%rbp\n  test   %edx,%edx\n  jle    L0\n  mov    %rsi,%rdi\n  lea    -0x1(%rdx),%eax\n  lea    0x8(%rsi,%rax,8),%rbx\n  mov    $0x0,%r9d\n  mov    $0xfffffc18,%r11d\n  jmp    L1\nL3:\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\nL4:\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%eax\n  test   %al,%al\n  je     L2\nL8:\n  lea    -0x41(%rax),%esi\n  cmp    $0x19,%sil\n  ja     L3\n  add    $0x1,%ecx\n  jmp    L4\nL7:\n  mov    $0x0,%ecx\nL2:\n  cmp    %ecx,%r11d\n  jge    L5\n  mov    %r10,%r9\n  mov    %ecx,%r11d\nL5:\n  add    $0x8,%rdi\n  cmp    %rbx,%rdi\n  je     L6\nL1:\n  mov    (%rdi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     L7\n  lea    0x1(%r10),%rdx\n  mov    $0x0,%ecx\n  jmp    L8\nL0:\n  mov    $0x0,%r9d\nL6:\n  lea    D0(%rip),%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  mov    %rbp,%rdi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3676
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4503
        },
        "L1": {
          "label": "L1",
          "addr": 4481
        },
        "L2": {
          "label": "L2",
          "addr": 4461
        },
        "L3": {
          "label": "L3",
          "addr": 4422
        },
        "L4": {
          "label": "L4",
          "addr": 4430
        },
        "L5": {
          "label": "L5",
          "addr": 4472
        },
        "L6": {
          "label": "L6",
          "addr": 4509
        },
        "L7": {
          "label": "L7",
          "addr": 4456
        },
        "L8": {
          "label": "L8",
          "addr": 4442
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "25732e257300",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%s.%s\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(char *a, char **b, int c, char *d) {\n  int i, j, k, len = -999;\n  char *ptr, *ptr2;\n  for (i = 0; i < c; i++) {\n    ptr = b[i];\n    j = 0;\n    while (*ptr) {\n      if (*ptr >= 'A' && *ptr <= 'Z')\n        j++;\n      else if (*ptr >= 'a' && *ptr <= 'z')\n        j--;\n      ptr++;\n    }\n    if (j > len) {\n      len = j;\n      ptr2 = b[i];\n    }\n  }\n  __sprintf_chk(d, 1, -1, \"%s.%s\", ptr2);\n}"
    },
    {
      "task_id": 154,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  mov    %rsi,%rdi\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   10b0 <strlen@plt>\n  lea    0x1(%rax,%rax,1),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    1258 <func0+0xb8>\n  movslq %ebx,%r14\n  lea    (%rax,%r14,1),%r12\n  lea    -0x1(%rbx),%eax\n  xor    %ebx,%ebx\n  mov    %rax,0x8(%rsp)\n  jmp    11fe <func0+0x5e>\n  nopl   (%rax)\n  lea    0x1(%rbx),%rax\n  cmp    0x8(%rsp),%rbx\n  je     1258 <func0+0xb8>\n  mov    %rax,%rbx\n  mov    %r14,%rdx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  mov    %r15,%rdi\n  sub    %rbx,%rdx\n  call   10a0 <strncpy@plt>\n  mov    %r12,%rdi\n  mov    %rbp,%rsi\n  mov    %rbx,%rdx\n  sub    %rbx,%rdi\n  call   10a0 <strncpy@plt>\n  movb   $0x0,(%r12)\n  mov    %r15,%rsi\n  mov    %r13,%rdi\n  call   10d0 <strstr@plt>\n  test   %rax,%rax\n  je     11f0 <func0+0x50>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  mov    $0x1,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  mov    %rsi,%rdi\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  lea    0x1(%rax,%rax,1),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    L0\n  movslq %ebx,%r14\n  lea    (%rax,%r14,1),%r12\n  lea    -0x1(%rbx),%eax\n  xor    %ebx,%ebx\n  mov    %rax,0x8(%rsp)\n  jmp    L1\n  nopl   (%rax)\nL2:\n  lea    0x1(%rbx),%rax\n  cmp    0x8(%rsp),%rbx\n  je     L0\n  mov    %rax,%rbx\nL1:\n  mov    %r14,%rdx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  mov    %r15,%rdi\n  sub    %rbx,%rdx\n  call   <strncpy@plt>\n  mov    %r12,%rdi\n  mov    %rbp,%rsi\n  mov    %rbx,%rdx\n  sub    %rbx,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,(%r12)\n  mov    %r15,%rsi\n  mov    %r13,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L2\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  mov    $0x1,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4696
        },
        "L1": {
          "label": "L1",
          "addr": 4606
        },
        "L2": {
          "label": "L2",
          "addr": 4592
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *c, char *s) {\n  int i;\n  int len = strlen(s);\n  char *buf = malloc(len * 2 + 1);\n  for (i = 0; i < len; i++) {\n    strncpy(buf, s + i, len - i);\n    strncpy(buf + len - i, s, i);\n    buf[len * 2] = '\\0';\n    if (strstr(c, buf)) {\n      free(buf);\n      return 1;\n    }\n  }\n  free(buf);\n  return 0;\n}"
    },
    {
      "task_id": 155,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  mov    $0xcccccccd,%r8d\n  neg    %edx\n  cmovs  %edi,%edx\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    1132 <func0+0x32>\n  nopw   0x0(%rax,%rax,1)\n  imul   %r8,%rax\n  add    $0x1,%edi\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jle    1149 <func0+0x49>\n  mov    %eax,%edx\n  mov    %edx,%eax\n  test   $0x1,%dl\n  je     1120 <func0+0x20>\n  imul   %r8,%rax\n  add    $0x1,%ecx\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jg     1130 <func0+0x30>\n  mov    %edi,(%rsi)\n  mov    %ecx,0x4(%rsi)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  mov    $0xcccccccd,%r8d\n  neg    %edx\n  cmovs  %edi,%edx\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    L0\n  nopw   0x0(%rax,%rax,1)\nL2:\n  imul   %r8,%rax\n  add    $0x1,%edi\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jle    L1\nL3:\n  mov    %eax,%edx\nL0:\n  mov    %edx,%eax\n  test   $0x1,%dl\n  je     L2\n  imul   %r8,%rax\n  add    $0x1,%ecx\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jg     L3\nL1:\n  mov    %edi,(%rsi)\n  mov    %ecx,0x4(%rsi)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4402
        },
        "L1": {
          "label": "L1",
          "addr": 4425
        },
        "L2": {
          "label": "L2",
          "addr": 4384
        },
        "L3": {
          "label": "L3",
          "addr": 4400
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b[2]) {\n  int i = 0, j = 0;\n  if (a < 0)\n    a = -a;\n  while (a > 0) {\n    if (a % 2 == 0) {\n      i++;\n      a /= 10;\n    } else {\n      j++;\n      a /= 10;\n    }\n  }\n  b[0] = i;\n  b[1] = j;\n}"
    },
    {
      "task_id": 155,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  mov    $0xcccccccd,%r8d\n  neg    %edx\n  cmovs  %edi,%edx\n  xor    %edi,%edi\n  xor    %ecx,%ecx\n  jmp    1132 <func0+0x32>\n  nopw   0x0(%rax,%rax,1)\n  imul   %r8,%rax\n  add    $0x1,%ecx\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jle    1149 <func0+0x49>\n  mov    %eax,%edx\n  mov    %edx,%eax\n  test   $0x1,%dl\n  je     1120 <func0+0x20>\n  imul   %r8,%rax\n  add    $0x1,%edi\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jg     1130 <func0+0x30>\n  movd   %ecx,%xmm0\n  movd   %edi,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rsi)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  mov    $0xcccccccd,%r8d\n  neg    %edx\n  cmovs  %edi,%edx\n  xor    %edi,%edi\n  xor    %ecx,%ecx\n  jmp    L0\n  nopw   0x0(%rax,%rax,1)\nL2:\n  imul   %r8,%rax\n  add    $0x1,%ecx\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jle    L1\nL3:\n  mov    %eax,%edx\nL0:\n  mov    %edx,%eax\n  test   $0x1,%dl\n  je     L2\n  imul   %r8,%rax\n  add    $0x1,%edi\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jg     L3\nL1:\n  movd   %ecx,%xmm0\n  movd   %edi,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rsi)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4402
        },
        "L1": {
          "label": "L1",
          "addr": 4425
        },
        "L2": {
          "label": "L2",
          "addr": 4384
        },
        "L3": {
          "label": "L3",
          "addr": 4400
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int *b) {\n  int even = 0;\n  int odd = 0;\n  while (a < 0)\n    a = -a;\n  while (a > 0) {\n    if (a % 2 == 0)\n      even++;\n    else\n      odd++;\n    a /= 10;\n  }\n  b[0] = even;\n  b[1] = odd;\n}"
    },
    {
      "task_id": 154,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
      "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  mov    %rsi,%rdi\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   10b0 <strlen@plt>\n  lea    0x1(%rax,%rax,1),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    1258 <func0+0xb8>\n  movslq %ebx,%r14\n  lea    (%rax,%r14,1),%r12\n  lea    -0x1(%rbx),%eax\n  xor    %ebx,%ebx\n  mov    %rax,0x8(%rsp)\n  jmp    11fe <func0+0x5e>\n  nopl   (%rax)\n  lea    0x1(%rbx),%rax\n  cmp    0x8(%rsp),%rbx\n  je     1258 <func0+0xb8>\n  mov    %rax,%rbx\n  mov    %r14,%rdx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  mov    %r15,%rdi\n  sub    %rbx,%rdx\n  call   10a0 <strncpy@plt>\n  mov    %r12,%rdi\n  mov    %rbp,%rsi\n  mov    %rbx,%rdx\n  sub    %rbx,%rdi\n  call   10a0 <strncpy@plt>\n  movb   $0x0,(%r12)\n  mov    %r15,%rsi\n  mov    %r13,%rdi\n  call   10d0 <strstr@plt>\n  test   %rax,%rax\n  je     11f0 <func0+0x50>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  mov    $0x1,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  mov    %rsi,%rdi\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  lea    0x1(%rax,%rax,1),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    L0\n  movslq %ebx,%r14\n  lea    (%rax,%r14,1),%r12\n  lea    -0x1(%rbx),%eax\n  xor    %ebx,%ebx\n  mov    %rax,0x8(%rsp)\n  jmp    L1\n  nopl   (%rax)\nL2:\n  lea    0x1(%rbx),%rax\n  cmp    0x8(%rsp),%rbx\n  je     L0\n  mov    %rax,%rbx\nL1:\n  mov    %r14,%rdx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  mov    %r15,%rdi\n  sub    %rbx,%rdx\n  call   <strncpy@plt>\n  mov    %r12,%rdi\n  mov    %rbp,%rsi\n  mov    %rbx,%rdx\n  sub    %rbx,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,(%r12)\n  mov    %r15,%rsi\n  mov    %r13,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L2\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  mov    $0x1,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4696
        },
        "L1": {
          "label": "L1",
          "addr": 4606
        },
        "L2": {
          "label": "L2",
          "addr": 4592
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char *c, char *s) {\n  int i;\n  int len = strlen(s);\n  char *buf = malloc(len * 2 + 1);\n  for (i = 0; i < len; i++) {\n    strncpy(buf, s + i, len - i);\n    strncpy(buf + len - i, s, i);\n    buf[len * 2] = '\\0';\n    if (strstr(c, buf)) {\n      free(buf);\n      return 1;\n    }\n  }\n  free(buf);\n  return 0;\n}"
    },
    {
      "task_id": 153,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%r8\n  mov    %rcx,%r11\n  push   %rbx\n  test   %edx,%edx\n  jle    11c4 <func0+0xa4>\n  lea    -0x1(%rdx),%eax\n  xor    %r9d,%r9d\n  mov    $0xfffffc18,%ebx\n  lea    0x8(%rsi,%rax,8),%rbp\n  nopl   0x0(%rax)\n  mov    (%rsi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     11c0 <func0+0xa0>\n  lea    0x1(%r10),%rdx\n  xor    %ecx,%ecx\n  jmp    116e <func0+0x4e>\n  nopl   0x0(%rax,%rax,1)\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  add    $0x1,%ecx\n  test   %al,%al\n  je     118a <func0+0x6a>\n  lea    -0x41(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    1160 <func0+0x40>\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    116e <func0+0x4e>\n  cmp    %ecx,%ebx\n  jge    1193 <func0+0x73>\n  mov    %r10,%r9\n  mov    %ecx,%ebx\n  add    $0x8,%rsi\n  cmp    %rbp,%rsi\n  jne    1148 <func0+0x28>\n  pop    %rbx\n  lea    0xe5c(%rip),%rcx        # 2000 <_fini+0xe34>\n  mov    $0xffffffffffffffff,%rdx\n  pop    %rbp\n  mov    $0x1,%esi\n  mov    %r11,%rdi\n  xor    %eax,%eax\n  jmp    1050 <__sprintf_chk@plt>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ecx,%ecx\n  jmp    118a <func0+0x6a>\n  xor    %r9d,%r9d\n  jmp    119c <func0+0x7c>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%r8\n  mov    %rcx,%r11\n  push   %rbx\n  test   %edx,%edx\n  jle    L0\n  lea    -0x1(%rdx),%eax\n  xor    %r9d,%r9d\n  mov    $0xfffffc18,%ebx\n  lea    0x8(%rsi,%rax,8),%rbp\n  nopl   0x0(%rax)\nL6:\n  mov    (%rsi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     L1\n  lea    0x1(%r10),%rdx\n  xor    %ecx,%ecx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  add    $0x1,%ecx\n  test   %al,%al\n  je     L3\nL2:\n  lea    -0x41(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    L4\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    L2\nL3:\n  cmp    %ecx,%ebx\n  jge    L5\n  mov    %r10,%r9\n  mov    %ecx,%ebx\nL5:\n  add    $0x8,%rsi\n  cmp    %rbp,%rsi\n  jne    L6\nL7:\n  pop    %rbx\n  lea    D0(%rip),%rcx\n  mov    $0xffffffffffffffff,%rdx\n  pop    %rbp\n  mov    $0x1,%esi\n  mov    %r11,%rdi\n  xor    %eax,%eax\n  jmp    1050 <__sprintf_chk@plt>\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %ecx,%ecx\n  jmp    L3\nL0:\n  xor    %r9d,%r9d\n  jmp    L7",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3676
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4548
        },
        "L1": {
          "label": "L1",
          "addr": 4544
        },
        "L2": {
          "label": "L2",
          "addr": 4462
        },
        "L3": {
          "label": "L3",
          "addr": 4490
        },
        "L4": {
          "label": "L4",
          "addr": 4448
        },
        "L5": {
          "label": "L5",
          "addr": 4499
        },
        "L6": {
          "label": "L6",
          "addr": 4424
        },
        "L7": {
          "label": "L7",
          "addr": 4508
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "25732e257300",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%s.%s\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(const char *s, char **words, int nwords, char *result) {\n  int i, j, min_len = -1000, len;\n  char *min_word = NULL;\n  for (i = 0; i < nwords; i++) {\n    len = 0;\n    for (j = 0; words[i][j] != '\\0'; j++) {\n      if (words[i][j] >= 'A' && words[i][j] <= 'Z')\n        len++;\n      else if (words[i][j] >= 'a' && words[i][j] <= 'z')\n        len--;\n    }\n    if (len < min_len) {\n      min_len = len;\n      min_word = words[i];\n    }\n  }\n  __sprintf_chk(result, 1, -1, \"%s.%s\", min_word, s);\n}"
    },
    {
      "task_id": 153,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%r8\n  mov    %rcx,%r11\n  push   %rbx\n  test   %edx,%edx\n  jle    11c4 <func0+0xa4>\n  lea    -0x1(%rdx),%eax\n  xor    %r9d,%r9d\n  mov    $0xfffffc18,%ebx\n  lea    0x8(%rsi,%rax,8),%rbp\n  nopl   0x0(%rax)\n  mov    (%rsi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     11c0 <func0+0xa0>\n  lea    0x1(%r10),%rdx\n  xor    %ecx,%ecx\n  jmp    116e <func0+0x4e>\n  nopl   0x0(%rax,%rax,1)\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  add    $0x1,%ecx\n  test   %al,%al\n  je     118a <func0+0x6a>\n  lea    -0x41(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    1160 <func0+0x40>\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    116e <func0+0x4e>\n  cmp    %ecx,%ebx\n  jge    1193 <func0+0x73>\n  mov    %r10,%r9\n  mov    %ecx,%ebx\n  add    $0x8,%rsi\n  cmp    %rbp,%rsi\n  jne    1148 <func0+0x28>\n  pop    %rbx\n  lea    0xe5c(%rip),%rcx        # 2000 <_fini+0xe34>\n  mov    $0xffffffffffffffff,%rdx\n  pop    %rbp\n  mov    $0x1,%esi\n  mov    %r11,%rdi\n  xor    %eax,%eax\n  jmp    1050 <__sprintf_chk@plt>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ecx,%ecx\n  jmp    118a <func0+0x6a>\n  xor    %r9d,%r9d\n  jmp    119c <func0+0x7c>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%r8\n  mov    %rcx,%r11\n  push   %rbx\n  test   %edx,%edx\n  jle    L0\n  lea    -0x1(%rdx),%eax\n  xor    %r9d,%r9d\n  mov    $0xfffffc18,%ebx\n  lea    0x8(%rsi,%rax,8),%rbp\n  nopl   0x0(%rax)\nL6:\n  mov    (%rsi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     L1\n  lea    0x1(%r10),%rdx\n  xor    %ecx,%ecx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  add    $0x1,%ecx\n  test   %al,%al\n  je     L3\nL2:\n  lea    -0x41(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    L4\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    L2\nL3:\n  cmp    %ecx,%ebx\n  jge    L5\n  mov    %r10,%r9\n  mov    %ecx,%ebx\nL5:\n  add    $0x8,%rsi\n  cmp    %rbp,%rsi\n  jne    L6\nL7:\n  pop    %rbx\n  lea    D0(%rip),%rcx\n  mov    $0xffffffffffffffff,%rdx\n  pop    %rbp\n  mov    $0x1,%esi\n  mov    %r11,%rdi\n  xor    %eax,%eax\n  jmp    1050 <__sprintf_chk@plt>\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %ecx,%ecx\n  jmp    L3\nL0:\n  xor    %r9d,%r9d\n  jmp    L7",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3676
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4548
        },
        "L1": {
          "label": "L1",
          "addr": 4544
        },
        "L2": {
          "label": "L2",
          "addr": 4462
        },
        "L3": {
          "label": "L3",
          "addr": 4490
        },
        "L4": {
          "label": "L4",
          "addr": 4448
        },
        "L5": {
          "label": "L5",
          "addr": 4499
        },
        "L6": {
          "label": "L6",
          "addr": 4424
        },
        "L7": {
          "label": "L7",
          "addr": 4508
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "25732e257300",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"%s.%s\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(const char *s, char **words, int nwords, char *result) {\n  int i, j, min_len = -1000, len;\n  char *min_word = NULL;\n  for (i = 0; i < nwords; i++) {\n    len = 0;\n    for (j = 0; words[i][j] != '\\0'; j++) {\n      if (words[i][j] >= 'A' && words[i][j] <= 'Z')\n        len++;\n      else if (words[i][j] >= 'a' && words[i][j] <= 'z')\n        len--;\n    }\n    if (len < min_len) {\n      min_len = len;\n      min_word = words[i];\n    }\n  }\n  __sprintf_chk(result, 1, -1, \"%s.%s\", min_word, s);\n}"
    },
    {
      "task_id": 148,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
      "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  lea    0xe70(%rip),%rdi        # 2000 <_fini+0xb74>\n  lea    0xe91(%rip),%r9        # 2028 <_fini+0xb9c>\n  push   %r14\n  movq   %rdi,%xmm0\n  lea    0xe69(%rip),%r14        # 200e <_fini+0xb82>\n  push   %r13\n  lea    0xe6b(%rip),%r13        # 2019 <_fini+0xb8d>\n  push   %r12\n  mov    %rsi,%r12\n  mov    %r15,%rsi\n  push   %rbp\n  lea    0xe4a(%rip),%rbp        # 2008 <_fini+0xb7c>\n  push   %rbx\n  movq   %rbp,%xmm1\n  xor    %ebx,%ebx\n  punpcklqdq %xmm1,%xmm0\n  sub    $0x68,%rsp\n  mov    %rdx,(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  movaps %xmm0,0x10(%rsp)\n  movq   %r14,%xmm0\n  movhps 0x2c15(%rip),%xmm0        # 3e08 <__do_global_dtors_aux_fini_array_entry+0x8>\n  movaps %xmm0,0x20(%rsp)\n  movq   %r13,%xmm0\n  movhps 0x2c0c(%rip),%xmm0        # 3e10 <__do_global_dtors_aux_fini_array_entry+0x10>\n  movaps %xmm0,0x30(%rsp)\n  movq   %r9,%xmm0\n  movhps 0x2c03(%rip),%xmm0        # 3e18 <__do_global_dtors_aux_fini_array_entry+0x18>\n  movaps %xmm0,0x40(%rsp)\n  call   1090 <strcmp@plt>\n  mov    %r12,%rsi\n  lea    0xdd7(%rip),%rdi        # 2000 <_fini+0xb74>\n  test   %eax,%eax\n  setne  %bl\n  call   1090 <strcmp@plt>\n  mov    %rbp,%rdi\n  mov    %r15,%rsi\n  test   %eax,%eax\n  setne  %al\n  neg    %ebx\n  movzbl %al,%eax\n  mov    %eax,0xc(%rsp)\n  call   1090 <strcmp@plt>\n  mov    $0x1,%edx\n  mov    %rbp,%rdi\n  mov    %r12,%rsi\n  test   %eax,%eax\n  cmove  %edx,%ebx\n  call   1090 <strcmp@plt>\n  mov    0xc(%rsp),%ebp\n  mov    %r14,%rdi\n  mov    %r15,%rsi\n  mov    $0x1,%edx\n  neg    %ebp\n  test   %eax,%eax\n  cmove  %edx,%ebp\n  call   1090 <strcmp@plt>\n  mov    $0x2,%edx\n  mov    %r14,%rdi\n  mov    %r12,%rsi\n  test   %eax,%eax\n  mov    $0x4,%r14d\n  cmove  %edx,%ebx\n  call   1090 <strcmp@plt>\n  mov    $0x2,%edx\n  mov    %r15,%rsi\n  test   %eax,%eax\n  lea    0xd6c(%rip),%rdi        # 2014 <_fini+0xb88>\n  cmove  %edx,%ebp\n  call   1090 <strcmp@plt>\n  mov    $0x3,%edx\n  mov    %r12,%rsi\n  test   %eax,%eax\n  lea    0xd53(%rip),%rdi        # 2014 <_fini+0xb88>\n  cmove  %edx,%ebx\n  call   1090 <strcmp@plt>\n  mov    $0x3,%edx\n  mov    %r13,%rdi\n  mov    %r15,%rsi\n  test   %eax,%eax\n  cmove  %edx,%ebp\n  call   1090 <strcmp@plt>\n  mov    %r13,%rdi\n  mov    %r12,%rsi\n  mov    $0x6,%r13d\n  test   %eax,%eax\n  cmove  %r14d,%ebx\n  call   1090 <strcmp@plt>\n  mov    %r15,%rsi\n  lea    0xd22(%rip),%rdi        # 2021 <_fini+0xb95>\n  test   %eax,%eax\n  cmove  %r14d,%ebp\n  mov    $0x5,%r14d\n  call   1090 <strcmp@plt>\n  mov    %r12,%rsi\n  lea    0xd07(%rip),%rdi        # 2021 <_fini+0xb95>\n  test   %eax,%eax\n  cmove  %r14d,%ebx\n  call   1090 <strcmp@plt>\n  lea    0xcfc(%rip),%r9        # 2028 <_fini+0xb9c>\n  mov    %r15,%rsi\n  test   %eax,%eax\n  mov    %r9,%rdi\n  cmove  %r14d,%ebp\n  call   1090 <strcmp@plt>\n  lea    0xce4(%rip),%r9        # 2028 <_fini+0xb9c>\n  mov    %r12,%rsi\n  test   %eax,%eax\n  mov    %r9,%rdi\n  cmove  %r13d,%ebx\n  call   1090 <strcmp@plt>\n  mov    %r15,%rsi\n  lea    0xcd0(%rip),%rdi        # 202f <_fini+0xba3>\n  test   %eax,%eax\n  cmove  %r13d,%ebp\n  call   1090 <strcmp@plt>\n  mov    %r12,%rsi\n  lea    0xcbb(%rip),%rdi        # 202f <_fini+0xba3>\n  test   %eax,%eax\n  je     13a0 <func0+0x220>\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    1460 <func0+0x2e0>\n  cmp    $0x7,%ebx\n  je     1450 <func0+0x2d0>\n  cmp    $0xffffffff,%ebx\n  je     1450 <func0+0x2d0>\n  mov    $0x7,%r12d\n  jmp    13dc <func0+0x25c>\n  nop\n  call   1090 <strcmp@plt>\n  mov    $0x7,%r12d\n  test   %eax,%eax\n  je     1450 <func0+0x2d0>\n  cmp    $0xffffffff,%ebp\n  sete   %al\n  cmp    %ebp,%r12d\n  sete   %dl\n  or     %dl,%al\n  jne    1450 <func0+0x2d0>\n  cmp    $0xffffffff,%r12d\n  je     1450 <func0+0x2d0>\n  cmp    %ebp,%r12d\n  jle    147e <func0+0x2fe>\n  mov    %ebp,%ebx\n  mov    %r12d,%eax\n  mov    (%rsp),%rcx\n  sub    %ebx,%eax\n  sub    $0x1,%eax\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    1450 <func0+0x2d0>\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r8\n  lea    0x1(%rbx),%eax\n  cmp    %eax,%r12d\n  jle    1429 <func0+0x2a9>\n  sub    $0x2,%r12d\n  cltq\n  mov    %r8,%rdi\n  sub    %ebx,%r12d\n  lea    0x10(%rsp,%rax,8),%rsi\n  lea    0x8(,%r12,8),%rdx\n  call   10a0 <memcpy@plt>\n  mov    %rax,%r8\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1479 <func0+0x2f9>\n  add    $0x68,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rsp),%rax\n  xor    %r8d,%r8d\n  movl   $0x0,(%rax)\n  jmp    1429 <func0+0x2a9>\n  nop\n  cmp    $0xffffffff,%ebp\n  mov    %ebx,%r12d\n  sete   %al\n  cmp    %ebp,%r12d\n  sete   %dl\n  or     %dl,%al\n  je     13c7 <func0+0x247>\n  jmp    1450 <func0+0x2d0>\n  call   1080 <__stack_chk_fail@plt>\n  mov    %r12d,%ebx\n  mov    %ebp,%r12d\n  jmp    13dc <func0+0x25c>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  lea    D0(%rip),%rdi\n  lea    D1(%rip),%r9\n  push   %r14\n  movq   %rdi,%xmm0\n  lea    D2(%rip),%r14\n  push   %r13\n  lea    D3(%rip),%r13\n  push   %r12\n  mov    %rsi,%r12\n  mov    %r15,%rsi\n  push   %rbp\n  lea    D4(%rip),%rbp\n  push   %rbx\n  movq   %rbp,%xmm1\n  xor    %ebx,%ebx\n  punpcklqdq %xmm1,%xmm0\n  sub    $0x68,%rsp\n  mov    %rdx,(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  movaps %xmm0,0x10(%rsp)\n  movq   %r14,%xmm0\n  movhps D5(%rip),%xmm0\n  movaps %xmm0,0x20(%rsp)\n  movq   %r13,%xmm0\n  movhps D6(%rip),%xmm0\n  movaps %xmm0,0x30(%rsp)\n  movq   %r9,%xmm0\n  movhps D7(%rip),%xmm0\n  movaps %xmm0,0x40(%rsp)\n  call   <strcmp@plt>\n  mov    %r12,%rsi\n  lea    D0(%rip),%rdi\n  test   %eax,%eax\n  setne  %bl\n  call   <strcmp@plt>\n  mov    %rbp,%rdi\n  mov    %r15,%rsi\n  test   %eax,%eax\n  setne  %al\n  neg    %ebx\n  movzbl %al,%eax\n  mov    %eax,0xc(%rsp)\n  call   <strcmp@plt>\n  mov    $0x1,%edx\n  mov    %rbp,%rdi\n  mov    %r12,%rsi\n  test   %eax,%eax\n  cmove  %edx,%ebx\n  call   <strcmp@plt>\n  mov    0xc(%rsp),%ebp\n  mov    %r14,%rdi\n  mov    %r15,%rsi\n  mov    $0x1,%edx\n  neg    %ebp\n  test   %eax,%eax\n  cmove  %edx,%ebp\n  call   <strcmp@plt>\n  mov    $0x2,%edx\n  mov    %r14,%rdi\n  mov    %r12,%rsi\n  test   %eax,%eax\n  mov    $0x4,%r14d\n  cmove  %edx,%ebx\n  call   <strcmp@plt>\n  mov    $0x2,%edx\n  mov    %r15,%rsi\n  test   %eax,%eax\n  lea    D8(%rip),%rdi\n  cmove  %edx,%ebp\n  call   <strcmp@plt>\n  mov    $0x3,%edx\n  mov    %r12,%rsi\n  test   %eax,%eax\n  lea    D8(%rip),%rdi\n  cmove  %edx,%ebx\n  call   <strcmp@plt>\n  mov    $0x3,%edx\n  mov    %r13,%rdi\n  mov    %r15,%rsi\n  test   %eax,%eax\n  cmove  %edx,%ebp\n  call   <strcmp@plt>\n  mov    %r13,%rdi\n  mov    %r12,%rsi\n  mov    $0x6,%r13d\n  test   %eax,%eax\n  cmove  %r14d,%ebx\n  call   <strcmp@plt>\n  mov    %r15,%rsi\n  lea    D9(%rip),%rdi\n  test   %eax,%eax\n  cmove  %r14d,%ebp\n  mov    $0x5,%r14d\n  call   <strcmp@plt>\n  mov    %r12,%rsi\n  lea    D9(%rip),%rdi\n  test   %eax,%eax\n  cmove  %r14d,%ebx\n  call   <strcmp@plt>\n  lea    D1(%rip),%r9\n  mov    %r15,%rsi\n  test   %eax,%eax\n  mov    %r9,%rdi\n  cmove  %r14d,%ebp\n  call   <strcmp@plt>\n  lea    D1(%rip),%r9\n  mov    %r12,%rsi\n  test   %eax,%eax\n  mov    %r9,%rdi\n  cmove  %r13d,%ebx\n  call   <strcmp@plt>\n  mov    %r15,%rsi\n  lea    D10(%rip),%rdi\n  test   %eax,%eax\n  cmove  %r13d,%ebp\n  call   <strcmp@plt>\n  mov    %r12,%rsi\n  lea    D10(%rip),%rdi\n  test   %eax,%eax\n  je     L0\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L1\n  cmp    $0x7,%ebx\n  je     L2\n  cmp    $0xffffffff,%ebx\n  je     L2\n  mov    $0x7,%r12d\n  jmp    L3\n  nop\nL0:\n  call   <strcmp@plt>\n  mov    $0x7,%r12d\n  test   %eax,%eax\n  je     L2\n  cmp    $0xffffffff,%ebp\n  sete   %al\n  cmp    %ebp,%r12d\n  sete   %dl\n  or     %dl,%al\n  jne    L2\nL7:\n  cmp    $0xffffffff,%r12d\n  je     L2\n  cmp    %ebp,%r12d\n  jle    L4\n  mov    %ebp,%ebx\nL3:\n  mov    %r12d,%eax\n  mov    (%rsp),%rcx\n  sub    %ebx,%eax\n  sub    $0x1,%eax\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    L2\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  lea    0x1(%rbx),%eax\n  cmp    %eax,%r12d\n  jle    L5\n  sub    $0x2,%r12d\n  cltq\n  mov    %r8,%rdi\n  sub    %ebx,%r12d\n  lea    0x10(%rsp,%rax,8),%rsi\n  lea    0x8(,%r12,8),%rdx\n  call   <memcpy@plt>\n  mov    %rax,%r8\nL5:\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x68,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    (%rsp),%rax\n  xor    %r8d,%r8d\n  movl   $0x0,(%rax)\n  jmp    L5\n  nop\nL1:\n  cmp    $0xffffffff,%ebp\n  mov    %ebx,%r12d\n  sete   %al\n  cmp    %ebp,%r12d\n  sete   %dl\n  or     %dl,%al\n  je     L7\n  jmp    L2\nL6:\n  call   <__stack_chk_fail@plt>\nL4:\n  mov    %r12d,%ebx\n  mov    %ebp,%r12d\n  jmp    L3",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3696,
            3543
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8232,
          "bias": [
            3729,
            3324,
            3300
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8206,
          "bias": [
            3689
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8217,
          "bias": [
            3691
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8200,
          "bias": [
            3658
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 15880,
          "bias": [
            11285
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 15888,
          "bias": [
            11276
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 15896,
          "bias": [
            11267
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8212,
          "bias": [
            3436,
            3411
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8225,
          "bias": [
            3362,
            3335
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 8239,
          "bias": [
            3280,
            3259
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5024
        },
        "L1": {
          "label": "L1",
          "addr": 5216
        },
        "L2": {
          "label": "L2",
          "addr": 5200
        },
        "L3": {
          "label": "L3",
          "addr": 5084
        },
        "L4": {
          "label": "L4",
          "addr": 5246
        },
        "L5": {
          "label": "L5",
          "addr": 5161
        },
        "L6": {
          "label": "L6",
          "addr": 5241
        },
        "L7": {
          "label": "L7",
          "addr": 5063
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4d6572637572790056656e7573004561727468004d617273004a7570697465720053617475726e005572616e7573004e657074756e6500",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"Mercury\""
          },
          "0x2021": {
            "type": "string",
            "value": "\"Saturn\""
          },
          "0x2028": {
            "type": "string",
            "value": "\"Uranus\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"Venus\""
          },
          "0x200e": {
            "type": "string",
            "value": "\"Earth\""
          },
          "0x202f": {
            "type": "string",
            "value": "\"Neptune\""
          },
          "0x2014": {
            "type": "string",
            "value": "\"Mars\""
          },
          "0x2019": {
            "type": "string",
            "value": "\"Jupiter\""
          },
          "0x3e08": {
            "type": "byte[8]",
            "value": []
          },
          "0x3e10": {
            "type": "byte[8]",
            "value": []
          },
          "0x3e18": {
            "type": "byte[8]",
            "value": []
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char **func0(char *planeta1, char *planeta2, int *tam) {\n  char *planetas[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n  int tam_planetas = 8;\n  int pos1 = -1, pos2 = -1;\n  int i;\n  for (i = 0; i < tam_planetas; i++) {\n    if (!strcmp(planetas[i], planeta1))\n      pos1 = i;\n    if (!strcmp(planetas[i], planeta2))\n      pos2 = i;\n  }\n  if (pos1 == -1 || pos2 == -1) {\n    *tam = 0;\n    return NULL;\n  }\n  if (pos1 > pos2) {\n    int aux = pos1;\n    pos1 = pos2;\n    pos2 = aux;\n  }\n  if (pos1 == -1 || pos2 == -1) {\n    *tam = 0;\n    return NULL;\n  }\n  *tam = pos2 - pos1 - 1;\n  if (*tam <= 0) {\n    *tam = 0;\n    return NULL;\n  }\n  char **ret = malloc(*tam * sizeof(char *));\n  int j = 0;\n  for (i = pos1 + 1; i < pos2; i++) {\n    ret[j] = planetas[i];\n    j++;\n  }\n  return ret;\n}"
    },
    {
      "task_id": 159,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
      "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    %edx,-0xc(%rbp)\n  mov    %rcx,-0x18(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jle    1134 <func0+0x3b>\n  mov    -0x4(%rbp),%edx\n  mov    -0xc(%rbp),%eax\n  add    %eax,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x0,(%rax)\n  jmp    1152 <func0+0x59>\n  mov    -0x4(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %eax,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    %edx,-0xc(%rbp)\n  mov    %rcx,-0x18(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jle    L0\n  mov    -0x4(%rbp),%edx\n  mov    -0xc(%rbp),%eax\n  add    %eax,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x0,(%rax)\n  jmp    L1\nL0:\n  mov    -0x4(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %eax,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\nL1:\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4404
        },
        "L1": {
          "label": "L1",
          "addr": 4434
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b, int c, int *d) {\n  if (b > c) {\n    d[0] = a + c;\n    d[1] = 0;\n  } else {\n    d[0] = a + b;\n    d[1] = c - b;\n  }\n}"
    },
    {
      "task_id": 159,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
      "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    110e <func0+0x15>\n  add    %edx,%edi\n  mov    $0x0,%edx\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret\n  add    %esi,%edi\n  sub    %esi,%edx\n  jmp    1108 <func0+0xf>",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    L0\n  add    %edx,%edi\n  mov    $0x0,%edx\nL1:\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret\nL0:\n  add    %esi,%edi\n  sub    %esi,%edx\n  jmp    L1",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4366
        },
        "L1": {
          "label": "L1",
          "addr": 4360
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b, int c, int *out) {\n  int d, e;\n  if (b > c) {\n    d = a + c;\n    e = 0;\n  } else {\n    d = a + b;\n    e = c - b;\n  }\n  out[0] = d;\n  out[1] = e;\n}"
    },
    {
      "task_id": 157,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  %xmm2,-0xc(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  0xebc(%rip),%xmm1        # 2000 <_fini+0xdf4>\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  0xeb9(%rip),%xmm0        # 2010 <_fini+0xe04>\n  comisd %xmm1,%xmm0\n  ja     11fb <func0+0x102>\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  0xe6b(%rip),%xmm1        # 2000 <_fini+0xdf4>\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  0xe68(%rip),%xmm0        # 2010 <_fini+0xe04>\n  comisd %xmm1,%xmm0\n  ja     11fb <func0+0x102>\n  movss  -0x8(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  0xe1e(%rip),%xmm1        # 2000 <_fini+0xdf4>\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  0xe1b(%rip),%xmm0        # 2010 <_fini+0xe04>\n  comisd %xmm1,%xmm0\n  jbe    1202 <func0+0x109>\n  mov    $0x1,%eax\n  jmp    1207 <func0+0x10e>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  %xmm2,-0xc(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  D0(%rip),%xmm1\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  D1(%rip),%xmm0\n  comisd %xmm1,%xmm0\n  ja     L0\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  D0(%rip),%xmm1\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  D1(%rip),%xmm0\n  comisd %xmm1,%xmm0\n  ja     L0\n  movss  -0x8(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  D0(%rip),%xmm1\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  D1(%rip),%xmm0\n  comisd %xmm1,%xmm0\n  jbe    L1\nL0:\n  mov    $0x1,%eax\n  jmp    L2\nL1:\n  mov    $0x0,%eax\nL2:\n  pop    %rbp\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3772,
            3691,
            3614
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3769,
            3688,
            3611
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4603
        },
        "L1": {
          "label": "L1",
          "addr": 4610
        },
        "L2": {
          "label": "L2",
          "addr": 4615
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f0000000000000000000000002d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "dword",
            "value": 2147483647
          },
          "0x2010": {
            "type": "byte[8]",
            "value": [
              45,
              67,
              28,
              235,
              226,
              54,
              26,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float a, float b, float c) {\n  if (fabsf(a * a + b * b - c * c) < 0.0001 || fabsf(a * a + c * c - b * b) < 0.0001 || fabsf(b * b + c * c - a * a) < 0.0001)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 159,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
      "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    1118 <func0+0x18>\n  add    %edx,%edi\n  xor    %edx,%edx\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret\n  nopw   0x0(%rax,%rax,1)\n  add    %esi,%edi\n  sub    %esi,%edx\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    L0\n  add    %edx,%edi\n  xor    %edx,%edx\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  add    %esi,%edi\n  sub    %esi,%edx\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4376
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b, int c, int *out) {\n  int var1;\n  int var2;\n  if (b > c) {\n    var1 = a + c;\n    var2 = 0;\n  } else {\n    var1 = a + b;\n    var2 = c - b;\n  }\n  out[0] = var1;\n  out[1] = var2;\n}"
    },
    {
      "task_id": 157,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  movsd  0xf01(%rip),%xmm4        # 2010 <_fini+0xe9c>\n  movss  0xee9(%rip),%xmm5        # 2000 <_fini+0xe8c>\n  mov    $0x1,%eax\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     1170 <func0+0x70>\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     1170 <func0+0x70>\n  addss  %xmm2,%xmm1\n  xor    %eax,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm5,%xmm1\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  movsd  D0(%rip),%xmm4\n  movss  D1(%rip),%xmm5\n  mov    $0x1,%eax\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     L0\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     L0\n  addss  %xmm2,%xmm1\n  xor    %eax,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm5,%xmm1\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\nL0:\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8208,
          "bias": [
            3841
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3817
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4464
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f0000000000000000000000002d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "dword",
            "value": 2147483647
          },
          "0x2010": {
            "type": "byte[8]",
            "value": [
              45,
              67,
              28,
              235,
              226,
              54,
              26,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float a, float b, float c) {\n  if (fabsf(a * a + b * b - c * c) < 0.0001)\n    return 1;\n  if (fabsf(a * a + c * c - b * b) < 0.0001)\n    return 1;\n  if (fabsf(b * b + c * c - a * a) < 0.0001)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 157,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  0xee2(%rip),%xmm0        # 2000 <_fini+0xe90>\n  cvtss2sd %xmm0,%xmm0\n  mov    $0x1,%eax\n  movsd  0xee1(%rip),%xmm4        # 2010 <_fini+0xea0>\n  comisd %xmm0,%xmm4\n  ja     116e <func0+0x75>\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  0xeb9(%rip),%xmm0        # 2000 <_fini+0xe90>\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     116e <func0+0x75>\n  addss  %xmm2,%xmm1\n  subss  %xmm3,%xmm1\n  andps  0xea0(%rip),%xmm1        # 2000 <_fini+0xe90>\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\n  movzbl %al,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  D0(%rip),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  mov    $0x1,%eax\n  movsd  D1(%rip),%xmm4\n  comisd %xmm0,%xmm4\n  ja     L0\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  D0(%rip),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     L0\n  addss  %xmm2,%xmm1\n  subss  %xmm3,%xmm1\n  andps  D0(%rip),%xmm1\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\n  movzbl %al,%eax\nL0:\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3810,
            3769,
            3744
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3809
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4462
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f0000000000000000000000002d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "dword[4]",
            "value": [
              2147483647,
              0,
              0,
              0
            ]
          },
          "0x2010": {
            "type": "byte[8]",
            "value": [
              45,
              67,
              28,
              235,
              226,
              54,
              26,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float a, float b, float c) {\n  if (fabsf(a * a + b * b - c * c) < 0.0001)\n    return 1;\n  if (fabsf(a * a - b * b + c * c) < 0.0001)\n    return 1;\n  if (fabsf(b * b + c * c - a * a) < 0.0001)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 157,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  movsd  0xf01(%rip),%xmm4        # 2010 <_fini+0xe9c>\n  movss  0xee9(%rip),%xmm5        # 2000 <_fini+0xe8c>\n  mov    $0x1,%eax\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     1170 <func0+0x70>\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     1170 <func0+0x70>\n  addss  %xmm2,%xmm1\n  xor    %eax,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm5,%xmm1\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  movsd  D0(%rip),%xmm4\n  movss  D1(%rip),%xmm5\n  mov    $0x1,%eax\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     L0\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     L0\n  addss  %xmm2,%xmm1\n  xor    %eax,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm5,%xmm1\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\nL0:\n  ret",
      "num_missing": 1,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8208,
          "bias": [
            3841
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3817
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4464
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "ffffff7f0000000000000000000000002d431cebe2361a3f",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "dword",
            "value": 2147483647
          },
          "0x2010": {
            "type": "byte[8]",
            "value": [
              45,
              67,
              28,
              235,
              226,
              54,
              26,
              63
            ]
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(float a, float b, float c) {\n  if (fabsf(a * a + b * b - c * c) < 0.0001)\n    return 1;\n  if (fabsf(a * a + c * c - b * b) < 0.0001)\n    return 1;\n  if (fabsf(b * b + c * c - a * a) < 0.0001)\n    return 1;\n  return 0;\n}"
    },
    {
      "task_id": 159,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
      "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    1120 <func0+0x20>\n  lea    (%rdx,%rdi,1),%eax\n  xor    %edx,%edx\n  movd   %eax,%xmm0\n  movd   %edx,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rcx)\n  ret\n  xchg   %ax,%ax\n  lea    (%rsi,%rdi,1),%eax\n  sub    %esi,%edx\n  movd   %eax,%xmm0\n  movd   %edx,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rcx)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    L0\n  lea    (%rdx,%rdi,1),%eax\n  xor    %edx,%edx\n  movd   %eax,%xmm0\n  movd   %edx,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rcx)\n  ret\n  xchg   %ax,%ax\nL0:\n  lea    (%rsi,%rdi,1),%eax\n  sub    %esi,%edx\n  movd   %eax,%xmm0\n  movd   %edx,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rcx)\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4384
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b, int c, int *out) {\n  int d, e;\n  if (b > c) {\n    d = a + c;\n    e = 0;\n  } else {\n    d = a + b;\n    e = c - b;\n  }\n  out[0] = d;\n  out[1] = e;\n}"
    },
    {
      "task_id": 158,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  lea    0xe53(%rip),%rax        # 2000 <_fini+0xcb4>\n  mov    %rax,0x18(%rsp)\n  test   %esi,%esi\n  jle    12c7 <func0+0x147>\n  lea    -0x1(%rsi),%eax\n  movl   $0x0,0xc(%rsp)\n  mov    %rdi,%r12\n  lea    0x20(%rsp),%rbx\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x10(%rsp)\n  nopw   0x0(%rax,%rax,1)\n  mov    (%r12),%r13\n  pxor   %xmm0,%xmm0\n  movaps %xmm0,0x20(%rsp)\n  movzbl 0x0(%r13),%r15d\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  movaps %xmm0,0x60(%rsp)\n  movaps %xmm0,0x70(%rsp)\n  movaps %xmm0,0x80(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movaps %xmm0,0xa0(%rsp)\n  movaps %xmm0,0xb0(%rsp)\n  movaps %xmm0,0xc0(%rsp)\n  movaps %xmm0,0xd0(%rsp)\n  movaps %xmm0,0xe0(%rsp)\n  movaps %xmm0,0xf0(%rsp)\n  movaps %xmm0,0x100(%rsp)\n  movaps %xmm0,0x110(%rsp)\n  test   %r15b,%r15b\n  je     1340 <func0+0x1c0>\n  lea    0x1(%r13),%r14\n  xor    %ebp,%ebp\n  nopw   0x0(%rax,%rax,1)\n  movsbl %r15b,%esi\n  mov    %rbx,%rdi\n  call   10a0 <strchr@plt>\n  test   %rax,%rax\n  je     12f8 <func0+0x178>\n  movzbl (%r14),%r15d\n  add    $0x1,%r14\n  test   %r15b,%r15b\n  jne    1270 <func0+0xf0>\n  cmp    %ebp,0xc(%rsp)\n  jl     1331 <func0+0x1b1>\n  jne    12b8 <func0+0x138>\n  mov    0x18(%rsp),%r14\n  mov    %r13,%rdi\n  mov    %r14,%rsi\n  call   10b0 <strcmp@plt>\n  test   %eax,%eax\n  cmovns %r14,%r13\n  mov    %r13,0x18(%rsp)\n  nopl   (%rax)\n  add    $0x8,%r12\n  cmp    0x10(%rsp),%r12\n  jne    11e0 <func0+0x60>\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1347 <func0+0x1c7>\n  mov    0x18(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  mov    %rbx,%rdi\n  add    $0x1,%r14\n  add    $0x1,%ebp\n  call   1080 <strlen@plt>\n  movslq %eax,%rsi\n  add    $0x1,%eax\n  cltq\n  mov    %r15b,0x20(%rsp,%rsi,1)\n  movb   $0x0,0x20(%rsp,%rax,1)\n  movzbl -0x1(%r14),%r15d\n  test   %r15b,%r15b\n  jne    1270 <func0+0xf0>\n  cmp    %ebp,0xc(%rsp)\n  jge    1298 <func0+0x118>\n  mov    %ebp,0xc(%rsp)\n  mov    %r13,0x18(%rsp)\n  jmp    12b8 <func0+0x138>\n  nop\n  xor    %ebp,%ebp\n  jmp    128e <func0+0x10e>\n  call   1090 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  lea    D0(%rip),%rax\n  mov    %rax,0x18(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movl   $0x0,0xc(%rsp)\n  mov    %rdi,%r12\n  lea    0x20(%rsp),%rbx\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x10(%rsp)\n  nopw   0x0(%rax,%rax,1)\nL6:\n  mov    (%r12),%r13\n  pxor   %xmm0,%xmm0\n  movaps %xmm0,0x20(%rsp)\n  movzbl 0x0(%r13),%r15d\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  movaps %xmm0,0x60(%rsp)\n  movaps %xmm0,0x70(%rsp)\n  movaps %xmm0,0x80(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movaps %xmm0,0xa0(%rsp)\n  movaps %xmm0,0xb0(%rsp)\n  movaps %xmm0,0xc0(%rsp)\n  movaps %xmm0,0xd0(%rsp)\n  movaps %xmm0,0xe0(%rsp)\n  movaps %xmm0,0xf0(%rsp)\n  movaps %xmm0,0x100(%rsp)\n  movaps %xmm0,0x110(%rsp)\n  test   %r15b,%r15b\n  je     L1\n  lea    0x1(%r13),%r14\n  xor    %ebp,%ebp\n  nopw   0x0(%rax,%rax,1)\nL3:\n  movsbl %r15b,%esi\n  mov    %rbx,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L2\n  movzbl (%r14),%r15d\n  add    $0x1,%r14\n  test   %r15b,%r15b\n  jne    L3\nL9:\n  cmp    %ebp,0xc(%rsp)\n  jl     L4\nL8:\n  jne    L5\n  mov    0x18(%rsp),%r14\n  mov    %r13,%rdi\n  mov    %r14,%rsi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmovns %r14,%r13\n  mov    %r13,0x18(%rsp)\n  nopl   (%rax)\nL5:\n  add    $0x8,%r12\n  cmp    0x10(%rsp),%r12\n  jne    L6\nL0:\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  mov    0x18(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL2:\n  mov    %rbx,%rdi\n  add    $0x1,%r14\n  add    $0x1,%ebp\n  call   <strlen@plt>\n  movslq %eax,%rsi\n  add    $0x1,%eax\n  cltq\n  mov    %r15b,0x20(%rsp,%rsi,1)\n  movb   $0x0,0x20(%rsp,%rax,1)\n  movzbl -0x1(%r14),%r15d\n  test   %r15b,%r15b\n  jne    L3\n  cmp    %ebp,0xc(%rsp)\n  jge    L8\nL4:\n  mov    %ebp,0xc(%rsp)\n  mov    %r13,0x18(%rsp)\n  jmp    L5\n  nop\nL1:\n  xor    %ebp,%ebp\n  jmp    L9\nL7:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3667
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4807
        },
        "L1": {
          "label": "L1",
          "addr": 4928
        },
        "L2": {
          "label": "L2",
          "addr": 4856
        },
        "L3": {
          "label": "L3",
          "addr": 4720
        },
        "L4": {
          "label": "L4",
          "addr": 4913
        },
        "L5": {
          "label": "L5",
          "addr": 4792
        },
        "L6": {
          "label": "L6",
          "addr": 4576
        },
        "L7": {
          "label": "L7",
          "addr": 4935
        },
        "L8": {
          "label": "L8",
          "addr": 4760
        },
        "L9": {
          "label": "L9",
          "addr": 4750
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char **strings, int n) {\n  char *ret = \"\";\n  int i, j, k, max = 0;\n  for (i = 0; i < n; i++) {\n    char *s = strings[i];\n    char buf[256] = {0};\n    int len = 0;\n    for (j = 0; s[j]; j++) {\n      if (strchr(buf, s[j]))\n        continue;\n      k = strlen(buf);\n      buf[k] = s[j];\n      buf[k + 1] = 0;\n      len++;\n    }\n    if (len > max || (len == max && strcmp(s, ret) < 0)) {\n      max = len;\n      ret = s;\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 158,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  lea    0xe53(%rip),%rax        # 2000 <_fini+0xcc4>\n  mov    %rax,0x18(%rsp)\n  test   %esi,%esi\n  jle    12ef <func0+0x16f>\n  lea    -0x1(%rsi),%eax\n  movl   $0x0,0xc(%rsp)\n  mov    %rdi,%r12\n  lea    0x20(%rsp),%rbx\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x10(%rsp)\n  nopw   0x0(%rax,%rax,1)\n  mov    (%r12),%r13\n  pxor   %xmm0,%xmm0\n  movaps %xmm0,0x20(%rsp)\n  movzbl 0x0(%r13),%r15d\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  movaps %xmm0,0x60(%rsp)\n  movaps %xmm0,0x70(%rsp)\n  movaps %xmm0,0x80(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movaps %xmm0,0xa0(%rsp)\n  movaps %xmm0,0xb0(%rsp)\n  movaps %xmm0,0xc0(%rsp)\n  movaps %xmm0,0xd0(%rsp)\n  movaps %xmm0,0xe0(%rsp)\n  movaps %xmm0,0xf0(%rsp)\n  movaps %xmm0,0x100(%rsp)\n  movaps %xmm0,0x110(%rsp)\n  test   %r15b,%r15b\n  je     1330 <func0+0x1b0>\n  lea    0x1(%r13),%r14\n  xor    %ebp,%ebp\n  jmp    127d <func0+0xfd>\n  nopl   0x0(%rax)\n  movzbl (%r14),%r15d\n  add    $0x1,%r14\n  test   %r15b,%r15b\n  je     12b9 <func0+0x139>\n  movsbl %r15b,%esi\n  mov    %rbx,%rdi\n  call   10a0 <strchr@plt>\n  test   %rax,%rax\n  jne    1270 <func0+0xf0>\n  mov    %rbx,%rdi\n  add    $0x1,%r14\n  add    $0x1,%ebp\n  call   1080 <strlen@plt>\n  movslq %eax,%rsi\n  add    $0x1,%eax\n  mov    %r15b,0x20(%rsp,%rsi,1)\n  movzbl -0x1(%r14),%r15d\n  cltq\n  movb   $0x0,0x20(%rsp,%rax,1)\n  test   %r15b,%r15b\n  jne    127d <func0+0xfd>\n  cmp    %ebp,0xc(%rsp)\n  jl     1320 <func0+0x1a0>\n  jne    12e0 <func0+0x160>\n  mov    0x18(%rsp),%r14\n  mov    %r13,%rdi\n  mov    %r14,%rsi\n  call   10b0 <strcmp@plt>\n  test   %eax,%eax\n  cmovns %r14,%r13\n  mov    %r13,0x18(%rsp)\n  nopl   0x0(%rax)\n  add    $0x8,%r12\n  cmp    0x10(%rsp),%r12\n  jne    11e0 <func0+0x60>\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1334 <func0+0x1b4>\n  mov    0x18(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  mov    %ebp,0xc(%rsp)\n  mov    %r13,0x18(%rsp)\n  jmp    12e0 <func0+0x160>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ebp,%ebp\n  jmp    12b9 <func0+0x139>\n  call   1090 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  lea    D0(%rip),%rax\n  mov    %rax,0x18(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movl   $0x0,0xc(%rsp)\n  mov    %rdi,%r12\n  lea    0x20(%rsp),%rbx\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x10(%rsp)\n  nopw   0x0(%rax,%rax,1)\nL7:\n  mov    (%r12),%r13\n  pxor   %xmm0,%xmm0\n  movaps %xmm0,0x20(%rsp)\n  movzbl 0x0(%r13),%r15d\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  movaps %xmm0,0x60(%rsp)\n  movaps %xmm0,0x70(%rsp)\n  movaps %xmm0,0x80(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movaps %xmm0,0xa0(%rsp)\n  movaps %xmm0,0xb0(%rsp)\n  movaps %xmm0,0xc0(%rsp)\n  movaps %xmm0,0xd0(%rsp)\n  movaps %xmm0,0xe0(%rsp)\n  movaps %xmm0,0xf0(%rsp)\n  movaps %xmm0,0x100(%rsp)\n  movaps %xmm0,0x110(%rsp)\n  test   %r15b,%r15b\n  je     L1\n  lea    0x1(%r13),%r14\n  xor    %ebp,%ebp\n  jmp    L2\n  nopl   0x0(%rax)\nL4:\n  movzbl (%r14),%r15d\n  add    $0x1,%r14\n  test   %r15b,%r15b\n  je     L3\nL2:\n  movsbl %r15b,%esi\n  mov    %rbx,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L4\n  mov    %rbx,%rdi\n  add    $0x1,%r14\n  add    $0x1,%ebp\n  call   <strlen@plt>\n  movslq %eax,%rsi\n  add    $0x1,%eax\n  mov    %r15b,0x20(%rsp,%rsi,1)\n  movzbl -0x1(%r14),%r15d\n  cltq\n  movb   $0x0,0x20(%rsp,%rax,1)\n  test   %r15b,%r15b\n  jne    L2\nL3:\n  cmp    %ebp,0xc(%rsp)\n  jl     L5\n  jne    L6\n  mov    0x18(%rsp),%r14\n  mov    %r13,%rdi\n  mov    %r14,%rsi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmovns %r14,%r13\n  mov    %r13,0x18(%rsp)\n  nopl   0x0(%rax)\nL6:\n  add    $0x8,%r12\n  cmp    0x10(%rsp),%r12\n  jne    L7\nL0:\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L8\n  mov    0x18(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL5:\n  mov    %ebp,0xc(%rsp)\n  mov    %r13,0x18(%rsp)\n  jmp    L6\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %ebp,%ebp\n  jmp    L3\nL8:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3667
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4847
        },
        "L1": {
          "label": "L1",
          "addr": 4912
        },
        "L2": {
          "label": "L2",
          "addr": 4733
        },
        "L3": {
          "label": "L3",
          "addr": 4793
        },
        "L4": {
          "label": "L4",
          "addr": 4720
        },
        "L5": {
          "label": "L5",
          "addr": 4896
        },
        "L6": {
          "label": "L6",
          "addr": 4832
        },
        "L7": {
          "label": "L7",
          "addr": 4576
        },
        "L8": {
          "label": "L8",
          "addr": 4916
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char **strings, int n) {\n  int i, j, k, max = 0;\n  char *res = \"\";\n  for (i = 0; i < n; i++) {\n    char *str = strings[i];\n    char buf[256] = {0};\n    int count = 0;\n    for (j = 0; str[j] != 0; j++) {\n      if (strchr(buf, str[j]) == NULL) {\n        k = strlen(buf);\n        buf[k] = str[j];\n        buf[k + 1] = 0;\n        count++;\n      }\n    }\n    if (count > max || (count == max && strcmp(str, res) < 0)) {\n      max = count;\n      res = str;\n    }\n  }\n  return res;\n}"
    },
    {
      "task_id": 158,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x140,%rsp\n  mov    %rdi,-0x138(%rbp)\n  mov    %esi,-0x13c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    0xe55(%rip),%rax        # 2000 <_fini+0xb48>\n  mov    %rax,-0x118(%rbp)\n  movl   $0x0,-0x12c(%rbp)\n  movl   $0x0,-0x128(%rbp)\n  jmp    1487 <func0+0x30e>\n  movq   $0x0,-0x110(%rbp)\n  movq   $0x0,-0x108(%rbp)\n  movq   $0x0,-0x100(%rbp)\n  movq   $0x0,-0xf8(%rbp)\n  movq   $0x0,-0xf0(%rbp)\n  movq   $0x0,-0xe8(%rbp)\n  movq   $0x0,-0xe0(%rbp)\n  movq   $0x0,-0xd8(%rbp)\n  movq   $0x0,-0xd0(%rbp)\n  movq   $0x0,-0xc8(%rbp)\n  movq   $0x0,-0xc0(%rbp)\n  movq   $0x0,-0xb8(%rbp)\n  movq   $0x0,-0xb0(%rbp)\n  movq   $0x0,-0xa8(%rbp)\n  movq   $0x0,-0xa0(%rbp)\n  movq   $0x0,-0x98(%rbp)\n  movq   $0x0,-0x90(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  movq   $0x0,-0x68(%rbp)\n  movq   $0x0,-0x60(%rbp)\n  movq   $0x0,-0x58(%rbp)\n  movq   $0x0,-0x50(%rbp)\n  movq   $0x0,-0x48(%rbp)\n  movq   $0x0,-0x40(%rbp)\n  movq   $0x0,-0x38(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movq   $0x0,-0x28(%rbp)\n  movq   $0x0,-0x20(%rbp)\n  movq   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x124(%rbp)\n  movl   $0x0,-0x120(%rbp)\n  jmp    13ce <func0+0x255>\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  lea    -0x110(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   10a0 <strchr@plt>\n  test   %rax,%rax\n  jne    13c7 <func0+0x24e>\n  lea    -0x110(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <strlen@plt>\n  mov    %eax,-0x11c(%rbp)\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x11c(%rbp),%eax\n  cltq\n  mov    %dl,-0x110(%rbp,%rax,1)\n  mov    -0x11c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  movb   $0x0,-0x110(%rbp,%rax,1)\n  addl   $0x1,-0x124(%rbp)\n  addl   $0x1,-0x120(%rbp)\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    131a <func0+0x1a1>\n  mov    -0x124(%rbp),%eax\n  cmp    -0x12c(%rbp),%eax\n  jg     1450 <func0+0x2d7>\n  mov    -0x124(%rbp),%eax\n  cmp    -0x12c(%rbp),%eax\n  jne    1480 <func0+0x307>\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x118(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10b0 <strcmp@plt>\n  test   %eax,%eax\n  jns    1480 <func0+0x307>\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x118(%rbp)\n  mov    -0x124(%rbp),%eax\n  mov    %eax,-0x12c(%rbp)\n  addl   $0x1,-0x128(%rbp)\n  mov    -0x128(%rbp),%eax\n  cmp    -0x13c(%rbp),%eax\n  jl     11cb <func0+0x52>\n  mov    -0x118(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     14b4 <func0+0x33b>\n  call   1090 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x140,%rsp\n  mov    %rdi,-0x138(%rbp)\n  mov    %esi,-0x13c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,-0x118(%rbp)\n  movl   $0x0,-0x12c(%rbp)\n  movl   $0x0,-0x128(%rbp)\n  jmp    L0\nL6:\n  movq   $0x0,-0x110(%rbp)\n  movq   $0x0,-0x108(%rbp)\n  movq   $0x0,-0x100(%rbp)\n  movq   $0x0,-0xf8(%rbp)\n  movq   $0x0,-0xf0(%rbp)\n  movq   $0x0,-0xe8(%rbp)\n  movq   $0x0,-0xe0(%rbp)\n  movq   $0x0,-0xd8(%rbp)\n  movq   $0x0,-0xd0(%rbp)\n  movq   $0x0,-0xc8(%rbp)\n  movq   $0x0,-0xc0(%rbp)\n  movq   $0x0,-0xb8(%rbp)\n  movq   $0x0,-0xb0(%rbp)\n  movq   $0x0,-0xa8(%rbp)\n  movq   $0x0,-0xa0(%rbp)\n  movq   $0x0,-0x98(%rbp)\n  movq   $0x0,-0x90(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  movq   $0x0,-0x68(%rbp)\n  movq   $0x0,-0x60(%rbp)\n  movq   $0x0,-0x58(%rbp)\n  movq   $0x0,-0x50(%rbp)\n  movq   $0x0,-0x48(%rbp)\n  movq   $0x0,-0x40(%rbp)\n  movq   $0x0,-0x38(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movq   $0x0,-0x28(%rbp)\n  movq   $0x0,-0x20(%rbp)\n  movq   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x124(%rbp)\n  movl   $0x0,-0x120(%rbp)\n  jmp    L1\nL3:\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  lea    -0x110(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\n  lea    -0x110(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x11c(%rbp)\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x11c(%rbp),%eax\n  cltq\n  mov    %dl,-0x110(%rbp,%rax,1)\n  mov    -0x11c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  movb   $0x0,-0x110(%rbp,%rax,1)\n  addl   $0x1,-0x124(%rbp)\nL2:\n  addl   $0x1,-0x120(%rbp)\nL1:\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L3\n  mov    -0x124(%rbp),%eax\n  cmp    -0x12c(%rbp),%eax\n  jg     L4\n  mov    -0x124(%rbp),%eax\n  cmp    -0x12c(%rbp),%eax\n  jne    L5\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x118(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jns    L5\nL4:\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x118(%rbp)\n  mov    -0x124(%rbp),%eax\n  mov    %eax,-0x12c(%rbp)\nL5:\n  addl   $0x1,-0x128(%rbp)\nL0:\n  mov    -0x128(%rbp),%eax\n  cmp    -0x13c(%rbp),%eax\n  jl     L6\n  mov    -0x118(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L7\n  call   <__stack_chk_fail@plt>\nL7:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3669
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5255
        },
        "L1": {
          "label": "L1",
          "addr": 5070
        },
        "L2": {
          "label": "L2",
          "addr": 5063
        },
        "L3": {
          "label": "L3",
          "addr": 4890
        },
        "L4": {
          "label": "L4",
          "addr": 5200
        },
        "L5": {
          "label": "L5",
          "addr": 5248
        },
        "L6": {
          "label": "L6",
          "addr": 4555
        },
        "L7": {
          "label": "L7",
          "addr": 5300
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " char *func0(char **words, int words_n) {\n  char *ret = \"\";\n  int max_len = 0;\n  for (int i = 0; i < words_n; i++) {\n    char used[256] = {0};\n    int used_n = 0;\n    for (int j = 0; words[i][j]; j++) {\n      if (strchr(used, words[i][j]) == NULL) {\n        int len = strlen(used);\n        used[len] = words[i][j];\n        used[len + 1] = '\\0';\n        used_n++;\n      }\n    }\n    if (used_n > max_len || (used_n == max_len && strcmp(words[i], ret) < 0)) {\n      ret = words[i];\n      max_len = used_n;\n    }\n  }\n  return ret;\n}"
    },
    {
      "task_id": 158,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  xor    %eax,%eax\n  lea    0xe58(%rip),%rax        # 2000 <_fini+0xbf0>\n  mov    %rax,0x10(%rsp)\n  test   %esi,%esi\n  jle    13de <func0+0x265>\n  mov    %rdi,%r14\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x18(%rsp)\n  movl   $0x0,0xc(%rsp)\n  lea    0x20(%rsp),%r12\n  jmp    1264 <func0+0xeb>\n  mov    %r12,%rdi\n  call   1080 <strlen@plt>\n  movslq %eax,%rdx\n  mov    %bl,0x20(%rsp,%rdx,1)\n  add    $0x1,%eax\n  cltq\n  movb   $0x0,0x20(%rsp,%rax,1)\n  add    $0x1,%r13d\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     1218 <func0+0x9f>\n  movsbl %bl,%esi\n  mov    %r12,%rdi\n  call   10a0 <strchr@plt>\n  test   %rax,%rax\n  jne    11f4 <func0+0x7b>\n  jmp    11d7 <func0+0x5e>\n  mov    $0x0,%r13d\n  mov    0xc(%rsp),%eax\n  cmp    %r13d,%eax\n  jl     124b <func0+0xd2>\n  jne    1255 <func0+0xdc>\n  mov    0x10(%rsp),%rbx\n  mov    %rbx,%rsi\n  mov    %r15,%rdi\n  call   10b0 <strcmp@plt>\n  test   %eax,%eax\n  cmovns 0xc(%rsp),%r13d\n  mov    %r13d,0xc(%rsp)\n  cmovns %rbx,%r15\n  mov    %r15,0x10(%rsp)\n  jmp    1255 <func0+0xdc>\n  mov    %r13d,0xc(%rsp)\n  mov    %r15,0x10(%rsp)\n  add    $0x8,%r14\n  cmp    0x18(%rsp),%r14\n  je     13de <func0+0x265>\n  movq   $0x0,0x20(%rsp)\n  movq   $0x0,0x28(%rsp)\n  movq   $0x0,0x30(%rsp)\n  movq   $0x0,0x38(%rsp)\n  movq   $0x0,0x40(%rsp)\n  movq   $0x0,0x48(%rsp)\n  movq   $0x0,0x50(%rsp)\n  movq   $0x0,0x58(%rsp)\n  movq   $0x0,0x60(%rsp)\n  movq   $0x0,0x68(%rsp)\n  movq   $0x0,0x70(%rsp)\n  movq   $0x0,0x78(%rsp)\n  movq   $0x0,0x80(%rsp)\n  movq   $0x0,0x88(%rsp)\n  movq   $0x0,0x90(%rsp)\n  movq   $0x0,0x98(%rsp)\n  movq   $0x0,0xa0(%rsp)\n  movq   $0x0,0xa8(%rsp)\n  movq   $0x0,0xb0(%rsp)\n  movq   $0x0,0xb8(%rsp)\n  movq   $0x0,0xc0(%rsp)\n  movq   $0x0,0xc8(%rsp)\n  movq   $0x0,0xd0(%rsp)\n  movq   $0x0,0xd8(%rsp)\n  movq   $0x0,0xe0(%rsp)\n  movq   $0x0,0xe8(%rsp)\n  movq   $0x0,0xf0(%rsp)\n  movq   $0x0,0xf8(%rsp)\n  movq   $0x0,0x100(%rsp)\n  movq   $0x0,0x108(%rsp)\n  movq   $0x0,0x110(%rsp)\n  movq   $0x0,0x118(%rsp)\n  mov    (%r14),%r15\n  movzbl (%r15),%ebx\n  test   %bl,%bl\n  je     1212 <func0+0x99>\n  lea    0x1(%r15),%rbp\n  mov    $0x0,%r13d\n  jmp    1200 <func0+0x87>\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1408 <func0+0x28f>\n  mov    0x10(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   1090 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,0x10(%rsp)\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r14\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x18(%rsp)\n  movl   $0x0,0xc(%rsp)\n  lea    0x20(%rsp),%r12\n  jmp    L1\nL4:\n  mov    %r12,%rdi\n  call   <strlen@plt>\n  movslq %eax,%rdx\n  mov    %bl,0x20(%rsp,%rdx,1)\n  add    $0x1,%eax\n  cltq\n  movb   $0x0,0x20(%rsp,%rax,1)\n  add    $0x1,%r13d\nL3:\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\nL8:\n  movsbl %bl,%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L3\n  jmp    L4\nL7:\n  mov    $0x0,%r13d\nL2:\n  mov    0xc(%rsp),%eax\n  cmp    %r13d,%eax\n  jl     L5\n  jne    L6\n  mov    0x10(%rsp),%rbx\n  mov    %rbx,%rsi\n  mov    %r15,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmovns 0xc(%rsp),%r13d\n  mov    %r13d,0xc(%rsp)\n  cmovns %rbx,%r15\n  mov    %r15,0x10(%rsp)\n  jmp    L6\nL5:\n  mov    %r13d,0xc(%rsp)\n  mov    %r15,0x10(%rsp)\nL6:\n  add    $0x8,%r14\n  cmp    0x18(%rsp),%r14\n  je     L0\nL1:\n  movq   $0x0,0x20(%rsp)\n  movq   $0x0,0x28(%rsp)\n  movq   $0x0,0x30(%rsp)\n  movq   $0x0,0x38(%rsp)\n  movq   $0x0,0x40(%rsp)\n  movq   $0x0,0x48(%rsp)\n  movq   $0x0,0x50(%rsp)\n  movq   $0x0,0x58(%rsp)\n  movq   $0x0,0x60(%rsp)\n  movq   $0x0,0x68(%rsp)\n  movq   $0x0,0x70(%rsp)\n  movq   $0x0,0x78(%rsp)\n  movq   $0x0,0x80(%rsp)\n  movq   $0x0,0x88(%rsp)\n  movq   $0x0,0x90(%rsp)\n  movq   $0x0,0x98(%rsp)\n  movq   $0x0,0xa0(%rsp)\n  movq   $0x0,0xa8(%rsp)\n  movq   $0x0,0xb0(%rsp)\n  movq   $0x0,0xb8(%rsp)\n  movq   $0x0,0xc0(%rsp)\n  movq   $0x0,0xc8(%rsp)\n  movq   $0x0,0xd0(%rsp)\n  movq   $0x0,0xd8(%rsp)\n  movq   $0x0,0xe0(%rsp)\n  movq   $0x0,0xe8(%rsp)\n  movq   $0x0,0xf0(%rsp)\n  movq   $0x0,0xf8(%rsp)\n  movq   $0x0,0x100(%rsp)\n  movq   $0x0,0x108(%rsp)\n  movq   $0x0,0x110(%rsp)\n  movq   $0x0,0x118(%rsp)\n  mov    (%r14),%r15\n  movzbl (%r15),%ebx\n  test   %bl,%bl\n  je     L7\n  lea    0x1(%r15),%rbp\n  mov    $0x0,%r13d\n  jmp    L8\nL0:\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L9\n  mov    0x10(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL9:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3672
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 5086
        },
        "L1": {
          "label": "L1",
          "addr": 4708
        },
        "L2": {
          "label": "L2",
          "addr": 4632
        },
        "L3": {
          "label": "L3",
          "addr": 4596
        },
        "L4": {
          "label": "L4",
          "addr": 4567
        },
        "L5": {
          "label": "L5",
          "addr": 4683
        },
        "L6": {
          "label": "L6",
          "addr": 4693
        },
        "L7": {
          "label": "L7",
          "addr": 4626
        },
        "L8": {
          "label": "L8",
          "addr": 4608
        },
        "L9": {
          "label": "L9",
          "addr": 5128
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *argv[100], int argc) {\n  char *ret = \"\";\n  int i, j, len, max_len = 0;\n  char *p, *max_p;\n  for (i = 0; i < argc; i++) {\n    char visited[256] = {0};\n    p = argv[i];\n    for (j = 0; p[j] != '\\0'; j++) {\n      if (strchr(visited, p[j]) == NULL) {\n        len = strlen(visited);\n        visited[len] = p[j];\n        visited[len + 1] = '\\0';\n      }\n    }\n    if (max_len < len) {\n      max_len = len;\n      max_p = p;\n    } else if (max_len == len) {\n      if (strcmp(p, ret) < 0) {\n        max_len = len;\n        max_p = p;\n      }\n    }\n  }\n  return max_p;\n}"
    },
    {
      "task_id": 150,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  mov    %edx,%r9d\n  cmp    $0x1,%edi\n  setg   %r8b\n  movzbl %r8b,%r8d\n  cmp    $0x3,%edi\n  jle    112c <func0+0x33>\n  mov    $0x2,%ecx\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %edx,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1115 <func0+0x1c>\n  test   %r8d,%r8d\n  cmovne %esi,%r9d\n  mov    %r9d,%eax\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  mov    %edx,%r9d\n  cmp    $0x1,%edi\n  setg   %r8b\n  movzbl %r8b,%r8d\n  cmp    $0x3,%edi\n  jle    L0\n  mov    $0x2,%ecx\nL1:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %edx,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L1\nL0:\n  test   %r8d,%r8d\n  cmovne %esi,%r9d\n  mov    %r9d,%eax\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4396
        },
        "L1": {
          "label": "L1",
          "addr": 4373
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " int func0(int arg0, int arg1, int arg2) {\n  int var0;\n  int var1;\n  int var2;\n  int var3;\n  int var4;\n  int var5;\n  int var6;\n  int var7;\n  int var8;\n  int var9;\n  int var10;\n  int var11;\n  int var12;\n  int var13;\n  int var14;\n  int var15;\n  int var16;\n  int var17;\n  int var18;\n  int var19;\n  int var20;\n  int var21;\n  int var22;\n  int var23;\n  int var24;\n  int var25;\n  int var26;\n  int var27;\n  int var28;\n  int var29;\n  int var30;\n  int var31;\n  int var32;\n  int var33;\n  int var34;\n  int var35;\n  int var36;\n  int var37;\n  int var38;\n  int var39;\n  int var40;\n  int var41;\n  int var42;\n  int var43;\n  int var44;\n  int var45;\n  int var46;\n  int var47;\n  int var48;\n  int var49;\n  int var50;\n  int var51;\n  int var52;\n  int var53;\n  int var54;\n  int var55;\n  int var56;\n  int var57;\n  int var58;\n  int var59;\n  int var60;\n  int var61;\n  int var62;\n  int var63;\n  int var64;\n  int var65;\n  int var66;\n  int var67;\n  int var68;\n  int var69;\n  int var70;\n  int var71;\n  int var72;\n  int var73;\n  int var74;\n  int var75;\n  int var76;\n  int var77;\n  int var78;\n  int var79;\n  int var80;\n  int var81;\n  int var82;\n  int var83;\n  int var84;\n  int var85;\n  int var86;\n  int var87;\n  int var88;\n  int var89;\n  int var90;\n  int var91;\n  int var92;\n  int var93;\n  int var94;\n  int var95;\n  int var96;\n  int var97;\n  int var98;\n  int var99;\n  int var100;\n  int var101;\n  int var102;\n  int var103;\n  int var104;\n  int var105;\n  int var106;\n  int var107;\n  int var108;\n  int var109;\n  int var110;\n  int var111;\n  int var112;\n  int var113;\n  int var114;\n  int var115;\n  int var116;\n  int var117;\n  int var118;\n  int var119;\n  int var120;\n  int var121;\n  int var122;\n  int var123;\n  int var124;\n  int var125;\n  int var126;\n  int var127;\n  int var128;\n  int var129;\n  int var130;\n  int var131;\n  int var132;\n  int var133;\n  int var134;\n  int var135;\n  int var136;\n  int var137;\n  int var138;\n  int var1"
    },
    {
      "task_id": 161,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    12a1 <func0+0x128>\n  call   10b0 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     1299 <func0+0x120>\n  call   10b0 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     123c <func0+0xc3>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   10a0 <tolower@plt>\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  jmp    129d <func0+0x124>\n  call   10b0 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     129d <func0+0x124>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   1080 <toupper@plt>\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  jmp    129d <func0+0x124>\n  addl   $0x1,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     11ab <func0+0x32>\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jne    1324 <func0+0x1ab>\n  movl   $0x0,-0x8(%rbp)\n  jmp    1313 <func0+0x19a>\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x11(%rbp)\n  mov    -0x4(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x4(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x11(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x8(%rbp)\n  jl     12be <func0+0x145>\n  mov    -0x28(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL4:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     L1\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     L2\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   <tolower@plt>\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  jmp    L3\nL2:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     L3\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   <toupper@plt>\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  jmp    L3\nL1:\n  addl   $0x1,-0x10(%rbp)\nL3:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L4\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jne    L5\n  movl   $0x0,-0x8(%rbp)\n  jmp    L6\nL7:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x11(%rbp)\n  mov    -0x4(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x4(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x11(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x8(%rbp)\nL6:\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x8(%rbp)\n  jl     L7\nL5:\n  mov    -0x28(%rbp),%rax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4769
        },
        "L1": {
          "label": "L1",
          "addr": 4761
        },
        "L2": {
          "label": "L2",
          "addr": 4668
        },
        "L3": {
          "label": "L3",
          "addr": 4765
        },
        "L4": {
          "label": "L4",
          "addr": 4523
        },
        "L5": {
          "label": "L5",
          "addr": 4900
        },
        "L6": {
          "label": "L6",
          "addr": 4883
        },
        "L7": {
          "label": "L7",
          "addr": 4798
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(char *src) {\n  int i, j, k, len, count = 0;\n  len = strlen(src);\n  for (i = 0; i < len; i++) {\n    if (((*(const unsigned short *)(__ctype_b_loc() + ((unsigned char)(src[i])) * 2 + 1)) & 0x400)) {\n      if (((*(const unsigned short *)(__ctype_b_loc() + ((unsigned char)(src[i])) * 2 + 1)) & 0x100)) {\n        src[i] = tolower(src[i]);\n      } else if (((*(const unsigned short *)(__ctype_b_loc() + ((unsigned char)(src[i])) * 2 + 1)) & 0x200)) {\n        src[i] = toupper(src[i]);\n      }\n    } else {\n      count++;\n    }\n  }\n  if (count == len) {\n    for (j = 0; j < len / 2; j++) {\n      char tmp = src[j];\n      src[j] = src[len - j - 1];\n      src[len - j - 1] = tmp;\n    }\n  }\n  return src;\n}"
    },
    {
      "task_id": 156,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xd0,%rsp\n  mov    %edi,-0xc4(%rbp)\n  mov    %rsi,-0xd0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    0xe95(%rip),%rax        # 2000 <_fini+0xcfc>\n  mov    %rax,-0x70(%rbp)\n  lea    0xe8c(%rip),%rax        # 2002 <_fini+0xcfe>\n  mov    %rax,-0x68(%rbp)\n  lea    0xe84(%rip),%rax        # 2005 <_fini+0xd01>\n  mov    %rax,-0x60(%rbp)\n  lea    0xe7b(%rip),%rax        # 2007 <_fini+0xd03>\n  mov    %rax,-0x58(%rbp)\n  lea    0xe73(%rip),%rax        # 200a <_fini+0xd06>\n  mov    %rax,-0x50(%rbp)\n  lea    0xe6a(%rip),%rax        # 200c <_fini+0xd08>\n  mov    %rax,-0x48(%rbp)\n  lea    0xe62(%rip),%rax        # 200f <_fini+0xd0b>\n  mov    %rax,-0x40(%rbp)\n  lea    0xe59(%rip),%rax        # 2011 <_fini+0xd0d>\n  mov    %rax,-0x38(%rbp)\n  lea    0xe51(%rip),%rax        # 2014 <_fini+0xd10>\n  mov    %rax,-0x30(%rbp)\n  lea    0xe48(%rip),%rax        # 2016 <_fini+0xd12>\n  mov    %rax,-0x28(%rbp)\n  lea    0xe40(%rip),%rax        # 2019 <_fini+0xd15>\n  mov    %rax,-0x20(%rbp)\n  lea    0xe37(%rip),%rax        # 201b <_fini+0xd17>\n  mov    %rax,-0x18(%rbp)\n  lea    0xe2f(%rip),%rax        # 201e <_fini+0xd1a>\n  mov    %rax,-0x10(%rbp)\n  movl   $0x3e8,-0xb0(%rbp)\n  movl   $0x384,-0xac(%rbp)\n  movl   $0x1f4,-0xa8(%rbp)\n  movl   $0x190,-0xa4(%rbp)\n  movl   $0x64,-0xa0(%rbp)\n  movl   $0x5a,-0x9c(%rbp)\n  movl   $0x32,-0x98(%rbp)\n  movl   $0x28,-0x94(%rbp)\n  movl   $0xa,-0x90(%rbp)\n  movl   $0x9,-0x8c(%rbp)\n  movl   $0x5,-0x88(%rbp)\n  movl   $0x4,-0x84(%rbp)\n  movl   $0x1,-0x80(%rbp)\n  movl   $0x0,-0xb4(%rbp)\n  mov    -0xd0(%rbp),%rax\n  movb   $0x0,(%rax)\n  jmp    12e3 <func0+0x1aa>\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,8),%rdx\n  mov    -0xd0(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strcat@plt>\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0xb0(%rbp,%rax,4),%eax\n  sub    %eax,-0xc4(%rbp)\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0xb0(%rbp,%rax,4),%eax\n  cmp    %eax,-0xc4(%rbp)\n  jge    1288 <func0+0x14f>\n  cmpl   $0x0,-0xc4(%rbp)\n  jle    12e3 <func0+0x1aa>\n  addl   $0x1,-0xb4(%rbp)\n  cmpl   $0x0,-0xc4(%rbp)\n  jg     12bc <func0+0x183>\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     1301 <func0+0x1c8>\n  call   1060 <__stack_chk_fail@plt>\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xd0,%rsp\n  mov    %edi,-0xc4(%rbp)\n  mov    %rsi,-0xd0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,-0x70(%rbp)\n  lea    D1(%rip),%rax\n  mov    %rax,-0x68(%rbp)\n  lea    D2(%rip),%rax\n  mov    %rax,-0x60(%rbp)\n  lea    D3(%rip),%rax\n  mov    %rax,-0x58(%rbp)\n  lea    D4(%rip),%rax\n  mov    %rax,-0x50(%rbp)\n  lea    D5(%rip),%rax\n  mov    %rax,-0x48(%rbp)\n  lea    D6(%rip),%rax\n  mov    %rax,-0x40(%rbp)\n  lea    D7(%rip),%rax\n  mov    %rax,-0x38(%rbp)\n  lea    D8(%rip),%rax\n  mov    %rax,-0x30(%rbp)\n  lea    D9(%rip),%rax\n  mov    %rax,-0x28(%rbp)\n  lea    D10(%rip),%rax\n  mov    %rax,-0x20(%rbp)\n  lea    D11(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  lea    D12(%rip),%rax\n  mov    %rax,-0x10(%rbp)\n  movl   $0x3e8,-0xb0(%rbp)\n  movl   $0x384,-0xac(%rbp)\n  movl   $0x1f4,-0xa8(%rbp)\n  movl   $0x190,-0xa4(%rbp)\n  movl   $0x64,-0xa0(%rbp)\n  movl   $0x5a,-0x9c(%rbp)\n  movl   $0x32,-0x98(%rbp)\n  movl   $0x28,-0x94(%rbp)\n  movl   $0xa,-0x90(%rbp)\n  movl   $0x9,-0x8c(%rbp)\n  movl   $0x5,-0x88(%rbp)\n  movl   $0x4,-0x84(%rbp)\n  movl   $0x1,-0x80(%rbp)\n  movl   $0x0,-0xb4(%rbp)\n  mov    -0xd0(%rbp),%rax\n  movb   $0x0,(%rax)\n  jmp    L0\nL1:\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,8),%rdx\n  mov    -0xd0(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcat@plt>\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0xb0(%rbp,%rax,4),%eax\n  sub    %eax,-0xc4(%rbp)\nL2:\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0xb0(%rbp,%rax,4),%eax\n  cmp    %eax,-0xc4(%rbp)\n  jge    L1\n  cmpl   $0x0,-0xc4(%rbp)\n  jle    L0\n  addl   $0x1,-0xb4(%rbp)\nL0:\n  cmpl   $0x0,-0xc4(%rbp)\n  jg     L2\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     L3\n  call   <__stack_chk_fail@plt>\nL3:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3733
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8194,
          "bias": [
            3724
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8197,
          "bias": [
            3716
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8199,
          "bias": [
            3707
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8202,
          "bias": [
            3699
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8204,
          "bias": [
            3690
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8207,
          "bias": [
            3682
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8209,
          "bias": [
            3673
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8212,
          "bias": [
            3665
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8214,
          "bias": [
            3656
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 8217,
          "bias": [
            3648
          ]
        },
        "D11": {
          "label": "D11",
          "addr": 8219,
          "bias": [
            3639
          ]
        },
        "D12": {
          "label": "D12",
          "addr": 8222,
          "bias": [
            3631
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4835
        },
        "L1": {
          "label": "L1",
          "addr": 4744
        },
        "L2": {
          "label": "L2",
          "addr": 4796
        },
        "L3": {
          "label": "L3",
          "addr": 4865
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "6d00636d00640063640063007863006c00786c00780069780076006976006900",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"m\""
          },
          "0x2002": {
            "type": "string",
            "value": "\"cm\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"d\""
          },
          "0x2007": {
            "type": "string",
            "value": "\"cd\""
          },
          "0x200a": {
            "type": "string",
            "value": "\"c\""
          },
          "0x200c": {
            "type": "string",
            "value": "\"xc\""
          },
          "0x200f": {
            "type": "string",
            "value": "\"l\""
          },
          "0x2011": {
            "type": "string",
            "value": "\"xl\""
          },
          "0x2014": {
            "type": "string",
            "value": "\"x\""
          },
          "0x2016": {
            "type": "string",
            "value": "\"ix\""
          },
          "0x2019": {
            "type": "string",
            "value": "\"v\""
          },
          "0x201b": {
            "type": "string",
            "value": "\"iv\""
          },
          "0x201e": {
            "type": "string",
            "value": "\"i\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int n, char *s) {\n  char *roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  int value[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  int i = 0;\n  s[0] = '\\0';\n  while (n > 0) {\n    while (n >= value[i]) {\n      strcat(s, roman[i]);\n      n -= value[i];\n    }\n    if (n > 0)\n      i++;\n  }\n}"
    },
    {
      "task_id": 156,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xb0,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  xor    %eax,%eax\n  lea    0xe9b(%rip),%rax        # 2001 <_fini+0xd2d>\n  mov    %rax,0x40(%rsp)\n  lea    0xe8e(%rip),%rax        # 2000 <_fini+0xd2c>\n  mov    %rax,0x48(%rsp)\n  lea    0xe86(%rip),%rax        # 2004 <_fini+0xd30>\n  mov    %rax,0x50(%rsp)\n  lea    0xe79(%rip),%rax        # 2003 <_fini+0xd2f>\n  mov    %rax,0x58(%rsp)\n  lea    0xe71(%rip),%rax        # 2007 <_fini+0xd33>\n  mov    %rax,0x60(%rsp)\n  lea    0xe64(%rip),%rax        # 2006 <_fini+0xd32>\n  mov    %rax,0x68(%rsp)\n  lea    0xe5c(%rip),%rax        # 200a <_fini+0xd36>\n  mov    %rax,0x70(%rsp)\n  lea    0xe4f(%rip),%rax        # 2009 <_fini+0xd35>\n  mov    %rax,0x78(%rsp)\n  lea    0xe47(%rip),%rax        # 200d <_fini+0xd39>\n  mov    %rax,0x80(%rsp)\n  lea    0xe37(%rip),%rax        # 200c <_fini+0xd38>\n  mov    %rax,0x88(%rsp)\n  lea    0xe2c(%rip),%rax        # 2010 <_fini+0xd3c>\n  mov    %rax,0x90(%rsp)\n  lea    0xe1c(%rip),%rax        # 200f <_fini+0xd3b>\n  mov    %rax,0x98(%rsp)\n  lea    0xe10(%rip),%rax        # 2012 <_fini+0xd3e>\n  mov    %rax,0xa0(%rsp)\n  movl   $0x3e8,(%rsp)\n  movl   $0x384,0x4(%rsp)\n  movl   $0x1f4,0x8(%rsp)\n  movl   $0x190,0xc(%rsp)\n  movl   $0x64,0x10(%rsp)\n  movl   $0x5a,0x14(%rsp)\n  movl   $0x32,0x18(%rsp)\n  movl   $0x28,0x1c(%rsp)\n  movl   $0xa,0x20(%rsp)\n  movl   $0x9,0x24(%rsp)\n  movl   $0x5,0x28(%rsp)\n  movl   $0x4,0x2c(%rsp)\n  movl   $0x1,0x30(%rsp)\n  movb   $0x0,(%rsi)\n  test   %edi,%edi\n  jle    12aa <func0+0x171>\n  mov    %edi,%ebx\n  mov    %rsi,%r13\n  mov    %rsp,%r14\n  lea    0x40(%rsp),%r12\n  mov    (%r14),%ebp\n  cmp    %ebx,%ebp\n  jg     129e <func0+0x165>\n  mov    (%r12),%rsi\n  mov    %r13,%rdi\n  call   1070 <strcat@plt>\n  sub    %ebp,%ebx\n  cmp    %ebp,%ebx\n  jge    128c <func0+0x153>\n  add    $0x4,%r14\n  add    $0x8,%r12\n  test   %ebx,%ebx\n  jg     1285 <func0+0x14c>\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12cd <func0+0x194>\n  add    $0xb0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xb0,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x50(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x58(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x60(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x68(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x70(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x78(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x80(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x88(%rsp)\n  lea    D10(%rip),%rax\n  mov    %rax,0x90(%rsp)\n  lea    D11(%rip),%rax\n  mov    %rax,0x98(%rsp)\n  lea    D12(%rip),%rax\n  mov    %rax,0xa0(%rsp)\n  movl   $0x3e8,(%rsp)\n  movl   $0x384,0x4(%rsp)\n  movl   $0x1f4,0x8(%rsp)\n  movl   $0x190,0xc(%rsp)\n  movl   $0x64,0x10(%rsp)\n  movl   $0x5a,0x14(%rsp)\n  movl   $0x32,0x18(%rsp)\n  movl   $0x28,0x1c(%rsp)\n  movl   $0xa,0x20(%rsp)\n  movl   $0x9,0x24(%rsp)\n  movl   $0x5,0x28(%rsp)\n  movl   $0x4,0x2c(%rsp)\n  movl   $0x1,0x30(%rsp)\n  movb   $0x0,(%rsi)\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%ebx\n  mov    %rsi,%r13\n  mov    %rsp,%r14\n  lea    0x40(%rsp),%r12\nL3:\n  mov    (%r14),%ebp\n  cmp    %ebx,%ebp\n  jg     L1\nL2:\n  mov    (%r12),%rsi\n  mov    %r13,%rdi\n  call   <strcat@plt>\n  sub    %ebp,%ebx\n  cmp    %ebp,%ebx\n  jge    L2\nL1:\n  add    $0x4,%r14\n  add    $0x8,%r12\n  test   %ebx,%ebx\n  jg     L3\nL0:\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L4\n  add    $0xb0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL4:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8193,
          "bias": [
            3739
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3726
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8196,
          "bias": [
            3718
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8195,
          "bias": [
            3705
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8199,
          "bias": [
            3697
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8198,
          "bias": [
            3684
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8202,
          "bias": [
            3676
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8201,
          "bias": [
            3663
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8205,
          "bias": [
            3655
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8204,
          "bias": [
            3639
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 8208,
          "bias": [
            3628
          ]
        },
        "D11": {
          "label": "D11",
          "addr": 8207,
          "bias": [
            3612
          ]
        },
        "D12": {
          "label": "D12",
          "addr": 8210,
          "bias": [
            3600
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4778
        },
        "L1": {
          "label": "L1",
          "addr": 4766
        },
        "L2": {
          "label": "L2",
          "addr": 4748
        },
        "L3": {
          "label": "L3",
          "addr": 4741
        },
        "L4": {
          "label": "L4",
          "addr": 4813
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "636d00636400786300786c006978006976006900",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"cm\""
          },
          "0x2001": {
            "type": "string",
            "value": "\"m\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"cd\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"d\""
          },
          "0x2006": {
            "type": "string",
            "value": "\"xc\""
          },
          "0x2007": {
            "type": "string",
            "value": "\"c\""
          },
          "0x2009": {
            "type": "string",
            "value": "\"xl\""
          },
          "0x200a": {
            "type": "string",
            "value": "\"l\""
          },
          "0x200c": {
            "type": "string",
            "value": "\"ix\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"x\""
          },
          "0x200f": {
            "type": "string",
            "value": "\"iv\""
          },
          "0x2010": {
            "type": "string",
            "value": "\"v\""
          },
          "0x2012": {
            "type": "string",
            "value": "\"i\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int n, char *p) {\n  char *num[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  int val[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  int i;\n  *p = '\\0';\n  for (i = 0; n > 0; i++) {\n    while (n >= val[i]) {\n      strcat(p, num[i]);\n      n -= val[i];\n    }\n  }\n}"
    },
    {
      "task_id": 162,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     11fb <func0+0x9b>\n  push   %r12\n  xor    %esi,%esi\n  mov    $0xffffffff,%r8d\n  push   %rbx\n  sub    $0x8,%rsp\n  xchg   %ax,%ax\n  xor    %eax,%r8d\n  mov    $0x8,%eax\n  nopl   0x0(%rax,%rax,1)\n  mov    %r8d,%ecx\n  shr    %r8d\n  mov    %r8d,%edx\n  and    $0x1,%ecx\n  xor    $0xedb88320,%edx\n  test   %ecx,%ecx\n  cmovne %edx,%r8d\n  sub    $0x1,%eax\n  jne    1190 <func0+0x30>\n  lea    0x1(%rsi),%eax\n  mov    %rax,%rsi\n  movzbl (%rdi,%rax,1),%eax\n  test   %al,%al\n  jne    1180 <func0+0x20>\n  mov    $0x9,%edi\n  mov    %r8d,%ebx\n  call   1070 <malloc@plt>\n  not    %ebx\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     11f0 <func0+0x90>\n  mov    %rax,%rdi\n  mov    %ebx,%r8d\n  lea    0xe26(%rip),%rcx        # 2005 <_fini+0xdfd>\n  xor    %eax,%eax\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  call   1090 <__sprintf_chk@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %r12\n  ret\n  lea    0xdfe(%rip),%rdi        # 2000 <_fini+0xdf8>\n  jmp    1080 <strdup@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  push   %r12\n  xor    %esi,%esi\n  mov    $0xffffffff,%r8d\n  push   %rbx\n  sub    $0x8,%rsp\n  xchg   %ax,%ax\nL2:\n  xor    %eax,%r8d\n  mov    $0x8,%eax\n  nopl   0x0(%rax,%rax,1)\nL1:\n  mov    %r8d,%ecx\n  shr    %r8d\n  mov    %r8d,%edx\n  and    $0x1,%ecx\n  xor    $0xedb88320,%edx\n  test   %ecx,%ecx\n  cmovne %edx,%r8d\n  sub    $0x1,%eax\n  jne    L1\n  lea    0x1(%rsi),%eax\n  mov    %rax,%rsi\n  movzbl (%rdi,%rax,1),%eax\n  test   %al,%al\n  jne    L2\n  mov    $0x9,%edi\n  mov    %r8d,%ebx\n  call   <malloc@plt>\n  not    %ebx\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     L3\n  mov    %rax,%rdi\n  mov    %ebx,%r8d\n  lea    D0(%rip),%rcx\n  xor    %eax,%eax\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  call   <__sprintf_chk@plt>\nL3:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %r12\n  ret\nL0:\n  lea    D1(%rip),%rdi\n  jmp    1080 <strdup@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8197,
          "bias": [
            3622
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3582
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4603
        },
        "L1": {
          "label": "L1",
          "addr": 4496
        },
        "L2": {
          "label": "L2",
          "addr": 4480
        },
        "L3": {
          "label": "L3",
          "addr": 4592
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e6f6e65002530385800",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"None\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"%08X\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *arg0) {\n  unsigned int crc = 0xFFFFFFFF;\n  unsigned char *p = (unsigned char *)arg0;\n  unsigned int i;\n  for (i = 0; arg0[i]; i++) {\n    crc = crc ^ arg0[i];\n    for (int j = 0; j < 8; j++) {\n      if (crc & 1) {\n        crc = (crc >> 1) ^ 0xEDB88320;\n      } else {\n        crc >>= 1;\n      }\n    }\n  }\n  crc = ~crc;\n  char *ret = malloc(9);\n  if (ret)\n    __sprintf_chk(ret, 1, 9, \"%08X\", crc);\n  return ret;\n}"
    },
    {
      "task_id": 163,
      "type": "O1",
      "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  cmp    %edi,%esi\n  jge    1116 <func0+0x1d>\n  mov    %edi,%eax\n  mov    %esi,%edi\n  mov    %eax,%esi\n  jmp    1116 <func0+0x1d>\n  add    $0x1,%edi\n  cmp    %edi,%esi\n  jl     1131 <func0+0x38>\n  cmp    $0x9,%edi\n  jg     110f <func0+0x16>\n  test   $0x1,%dil\n  jne    110f <func0+0x16>\n  mov    (%rcx),%eax\n  lea    0x1(%rax),%r8d\n  mov    %r8d,(%rcx)\n  cltq\n  mov    %edi,(%rdx,%rax,4)\n  jmp    110f <func0+0x16>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  cmp    %edi,%esi\n  jge    L0\n  mov    %edi,%eax\n  mov    %esi,%edi\n  mov    %eax,%esi\n  jmp    L0\nL2:\n  add    $0x1,%edi\n  cmp    %edi,%esi\n  jl     L1\nL0:\n  cmp    $0x9,%edi\n  jg     L2\n  test   $0x1,%dil\n  jne    L2\n  mov    (%rcx),%eax\n  lea    0x1(%rax),%r8d\n  mov    %r8d,(%rcx)\n  cltq\n  mov    %edi,(%rdx,%rax,4)\n  jmp    L2\nL1:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4374
        },
        "L1": {
          "label": "L1",
          "addr": 4401
        },
        "L2": {
          "label": "L2",
          "addr": 4367
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b, int *c, int *d) {\n  *d = 0;\n  for (; a < b; a++) {\n    for (int i = 0; i < 10; i++) {\n      if (a % 2 == 0) {\n        c[*d] = a;\n        (*d)++;\n      }\n    }\n  }\n}"
    },
    {
      "task_id": 163,
      "type": "O0",
      "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %rdx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jge    1133 <func0+0x3a>\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    1174 <func0+0x7b>\n  cmpl   $0x9,-0x8(%rbp)\n  jg     1170 <func0+0x77>\n  mov    -0x8(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    1170 <func0+0x77>\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    113b <func0+0x42>\n  nop\n  nop\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %rdx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jge    L0\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    L1\nL3:\n  cmpl   $0x9,-0x8(%rbp)\n  jg     L2\n  mov    -0x8(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L2\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    L3\n  nop\n  nop\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4403
        },
        "L1": {
          "label": "L1",
          "addr": 4468
        },
        "L2": {
          "label": "L2",
          "addr": 4464
        },
        "L3": {
          "label": "L3",
          "addr": 4411
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " void func0(int x, int y, int *ary, int *sz) {\n  int i;\n  *sz = 0;\n  if (y < x) {\n    int tmp = x;\n    x = y;\n    y = tmp;\n  }\n  for (i = x; i <= y; i++) {\n    if (i < 10 && i % 2 == 0) {\n      ary[(*sz)++] = i;\n    }\n  }\n}"
    },
    {
      "task_id": 163,
      "type": "O2",
      "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  cmp    %edi,%esi\n  jge    1118 <func0+0x18>\n  mov    %edi,%eax\n  mov    %esi,%edi\n  mov    %eax,%esi\n  nopl   0x0(%rax)\n  cmp    $0x9,%edi\n  jg     1130 <func0+0x30>\n  test   $0x1,%dil\n  jne    1130 <func0+0x30>\n  movslq (%rcx),%rax\n  lea    0x1(%rax),%r8d\n  mov    %r8d,(%rcx)\n  mov    %edi,(%rdx,%rax,4)\n  add    $0x1,%edi\n  cmp    %edi,%esi\n  jge    1118 <func0+0x18>\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  cmp    %edi,%esi\n  jge    L0\n  mov    %edi,%eax\n  mov    %esi,%edi\n  mov    %eax,%esi\n  nopl   0x0(%rax)\nL0:\n  cmp    $0x9,%edi\n  jg     L1\n  test   $0x1,%dil\n  jne    L1\n  movslq (%rcx),%rax\n  lea    0x1(%rax),%r8d\n  mov    %r8d,(%rcx)\n  mov    %edi,(%rdx,%rax,4)\nL1:\n  add    $0x1,%edi\n  cmp    %edi,%esi\n  jge    L0\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4376
        },
        "L1": {
          "label": "L1",
          "addr": 4400
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b, int *arr, int *sz) {\n  *sz = 0;\n  for (int i = a; i < b + 1; i++) {\n    if (i < 10 && i % 2 == 0) {\n      arr[(*sz)++] = i;\n    }\n  }\n}"
    },
    {
      "task_id": 162,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  mov    $0x0,%esi\n  mov    $0xffffffff,%r8d\n  test   %al,%al\n  jne    1193 <func0+0x3a>\n  lea    0xe84(%rip),%rdi        # 2000 <_fini+0xe00>\n  call   1080 <strdup@plt>\n  mov    %rax,%rbp\n  jmp    11f6 <func0+0x9d>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  movzbl (%rdi,%rax,1),%eax\n  test   %al,%al\n  je     11be <func0+0x65>\n  movzbl %al,%eax\n  xor    %eax,%r8d\n  mov    $0x8,%edx\n  mov    %r8d,%eax\n  shr    %eax\n  xor    $0xedb88320,%eax\n  mov    %r8d,%ecx\n  shr    %ecx\n  test   $0x1,%r8b\n  cmove  %ecx,%eax\n  mov    %eax,%r8d\n  sub    $0x1,%edx\n  jne    119e <func0+0x45>\n  jmp    1186 <func0+0x2d>\n  mov    %r8d,%ebx\n  not    %ebx\n  mov    $0x9,%edi\n  call   1070 <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     11f6 <func0+0x9d>\n  mov    %ebx,%r8d\n  lea    0xe26(%rip),%rcx        # 2005 <_fini+0xe05>\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1090 <__sprintf_chk@plt>\n  mov    %rbp,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  mov    $0x0,%esi\n  mov    $0xffffffff,%r8d\n  test   %al,%al\n  jne    L0\n  lea    D0(%rip),%rdi\n  call   <strdup@plt>\n  mov    %rax,%rbp\n  jmp    L1\nL4:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  movzbl (%rdi,%rax,1),%eax\n  test   %al,%al\n  je     L2\nL0:\n  movzbl %al,%eax\n  xor    %eax,%r8d\n  mov    $0x8,%edx\nL3:\n  mov    %r8d,%eax\n  shr    %eax\n  xor    $0xedb88320,%eax\n  mov    %r8d,%ecx\n  shr    %ecx\n  test   $0x1,%r8b\n  cmove  %ecx,%eax\n  mov    %eax,%r8d\n  sub    $0x1,%edx\n  jne    L3\n  jmp    L4\nL2:\n  mov    %r8d,%ebx\n  not    %ebx\n  mov    $0x9,%edi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     L1\n  mov    %ebx,%r8d\n  lea    D1(%rip),%rcx\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\nL1:\n  mov    %rbp,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3716
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8197,
          "bias": [
            3622
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4499
        },
        "L1": {
          "label": "L1",
          "addr": 4598
        },
        "L2": {
          "label": "L2",
          "addr": 4542
        },
        "L3": {
          "label": "L3",
          "addr": 4510
        },
        "L4": {
          "label": "L4",
          "addr": 4486
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e6f6e65002530385800",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"None\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"%08X\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *arg0) {\n  unsigned int l_1 = 0xFFFFFFFF;\n  unsigned int l_2 = 0;\n  unsigned int l_3 = 0;\n  char *l_4 = 0;\n  while (((unsigned char)*(arg0 + l_2) != 0x00)) {\n    l_1 = l_1 ^ (unsigned char)*(arg0 + l_2);\n    l_3 = 0;\n    while (l_3 < 8) {\n      if ((l_1 & 1) == 0) {\n        l_1 = l_1 >> 1;\n      } else {\n        l_1 = (l_1 >> 1) ^ 0xEDB88320;\n      }\n      l_3 = l_3 + 1;\n    }\n    l_2 = l_2 + 1;\n  }\n  l_1 = ~l_1;\n  l_4 = strdup(\"None\");\n  if (l_4 == 0) {\n    return 0;\n  }\n  __sprintf_chk(l_4, 1, 9, \"%08X\", l_1);\n  return l_4;\n}"
    },
    {
      "task_id": 156,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  lea    0xeb4(%rip),%rcx        # 2001 <_fini+0xd0d>\n  mov    %rsi,%rdx\n  push   %r14\n  movq   %rcx,%xmm0\n  lea    0xea6(%rip),%rcx        # 2004 <_fini+0xd10>\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  sub    $0xb8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  lea    0xe78(%rip),%rax        # 2000 <_fini+0xd0c>\n  lea    0x40(%rsp),%r15\n  movb   $0x0,(%rsi)\n  mov    %rsp,%r14\n  movl   $0x1,0x30(%rsp)\n  movq   %rax,%xmm1\n  lea    0xe5c(%rip),%rax        # 2003 <_fini+0xd0f>\n  punpcklqdq %xmm1,%xmm0\n  movq   %rax,%xmm2\n  lea    0xe4f(%rip),%rax        # 2006 <_fini+0xd12>\n  movaps %xmm0,0x40(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm3\n  lea    0xe3a(%rip),%rcx        # 2007 <_fini+0xd13>\n  punpcklqdq %xmm2,%xmm0\n  lea    0xe31(%rip),%rax        # 2009 <_fini+0xd15>\n  movaps %xmm0,0x50(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm4\n  lea    0xe1c(%rip),%rcx        # 200a <_fini+0xd16>\n  punpcklqdq %xmm3,%xmm0\n  lea    0xe13(%rip),%rax        # 200c <_fini+0xd18>\n  movaps %xmm0,0x60(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm5\n  lea    0xdfe(%rip),%rcx        # 200d <_fini+0xd19>\n  punpcklqdq %xmm4,%xmm0\n  lea    0xdf5(%rip),%rax        # 200f <_fini+0xd1b>\n  movaps %xmm0,0x70(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm6\n  lea    0xde0(%rip),%rcx        # 2010 <_fini+0xd1c>\n  punpcklqdq %xmm5,%xmm0\n  lea    0xdd7(%rip),%rax        # 2012 <_fini+0xd1e>\n  movaps %xmm0,0x80(%rsp)\n  movq   %rcx,%xmm0\n  punpcklqdq %xmm6,%xmm0\n  mov    %rax,0xa0(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movdqa 0xdbc(%rip),%xmm0        # 2020 <_fini+0xd2c>\n  movaps %xmm0,(%rsp)\n  movdqa 0xdc0(%rip),%xmm0        # 2030 <_fini+0xd3c>\n  movaps %xmm0,0x10(%rsp)\n  movdqa 0xdc3(%rip),%xmm0        # 2040 <_fini+0xd4c>\n  movaps %xmm0,0x20(%rsp)\n  test   %edi,%edi\n  jle    12bc <func0+0x17c>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    (%r14,%r13,4),%ebp\n  cmp    %ebx,%ebp\n  jg     12e8 <func0+0x1a8>\n  mov    (%r15,%r13,8),%r12\n  nopl   0x0(%rax)\n  mov    %rdx,%rdi\n  mov    %r12,%rsi\n  sub    %ebp,%ebx\n  call   1070 <strcat@plt>\n  mov    %rax,%rdx\n  cmp    %ebp,%ebx\n  jge    12a0 <func0+0x160>\n  add    $0x1,%r13\n  test   %ebx,%ebx\n  jne    1290 <func0+0x150>\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12ee <func0+0x1ae>\n  add    $0xb8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  add    $0x1,%r13\n  jmp    1290 <func0+0x150>\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  lea    D0(%rip),%rcx\n  mov    %rsi,%rdx\n  push   %r14\n  movq   %rcx,%xmm0\n  lea    D1(%rip),%rcx\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  sub    $0xb8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  lea    D2(%rip),%rax\n  lea    0x40(%rsp),%r15\n  movb   $0x0,(%rsi)\n  mov    %rsp,%r14\n  movl   $0x1,0x30(%rsp)\n  movq   %rax,%xmm1\n  lea    D3(%rip),%rax\n  punpcklqdq %xmm1,%xmm0\n  movq   %rax,%xmm2\n  lea    D4(%rip),%rax\n  movaps %xmm0,0x40(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm3\n  lea    D5(%rip),%rcx\n  punpcklqdq %xmm2,%xmm0\n  lea    D6(%rip),%rax\n  movaps %xmm0,0x50(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm4\n  lea    D7(%rip),%rcx\n  punpcklqdq %xmm3,%xmm0\n  lea    D8(%rip),%rax\n  movaps %xmm0,0x60(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm5\n  lea    D9(%rip),%rcx\n  punpcklqdq %xmm4,%xmm0\n  lea    D10(%rip),%rax\n  movaps %xmm0,0x70(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm6\n  lea    D11(%rip),%rcx\n  punpcklqdq %xmm5,%xmm0\n  lea    D12(%rip),%rax\n  movaps %xmm0,0x80(%rsp)\n  movq   %rcx,%xmm0\n  punpcklqdq %xmm6,%xmm0\n  mov    %rax,0xa0(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movdqa D13(%rip),%xmm0\n  movaps %xmm0,(%rsp)\n  movdqa D14(%rip),%xmm0\n  movaps %xmm0,0x10(%rsp)\n  movdqa D15(%rip),%xmm0\n  movaps %xmm0,0x20(%rsp)\n  test   %edi,%edi\n  jle    L0\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    (%r14,%r13,4),%ebp\n  cmp    %ebx,%ebp\n  jg     L1\n  mov    (%r15,%r13,8),%r12\n  nopl   0x0(%rax)\nL2:\n  mov    %rdx,%rdi\n  mov    %r12,%rsi\n  sub    %ebp,%ebx\n  call   <strcat@plt>\n  mov    %rax,%rdx\n  cmp    %ebp,%ebx\n  jge    L2\n  add    $0x1,%r13\n  test   %ebx,%ebx\n  jne    L3\nL0:\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L4\n  add    $0xb8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL1:\n  add    $0x1,%r13\n  jmp    L3\nL4:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 3,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8193,
          "bias": [
            3764
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8196,
          "bias": [
            3750
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8192,
          "bias": [
            3704
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8195,
          "bias": [
            3676
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8198,
          "bias": [
            3663
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8199,
          "bias": [
            3642
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8201,
          "bias": [
            3633
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8202,
          "bias": [
            3612
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8204,
          "bias": [
            3603
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8205,
          "bias": [
            3582
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 8207,
          "bias": [
            3573
          ]
        },
        "D11": {
          "label": "D11",
          "addr": 8208,
          "bias": [
            3552
          ]
        },
        "D12": {
          "label": "D12",
          "addr": 8210,
          "bias": [
            3543
          ]
        },
        "D13": {
          "label": "D13",
          "addr": 8224,
          "bias": [
            3516
          ]
        },
        "D14": {
          "label": "D14",
          "addr": 8240,
          "bias": [
            3520
          ]
        },
        "D15": {
          "label": "D15",
          "addr": 8256,
          "bias": [
            3523
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4796
        },
        "L1": {
          "label": "L1",
          "addr": 4840
        },
        "L2": {
          "label": "L2",
          "addr": 4768
        },
        "L3": {
          "label": "L3",
          "addr": 4752
        },
        "L4": {
          "label": "L4",
          "addr": 4846
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "636d00636400786300786c006978006976006900000000000000000000000000e803000084030000f401000090010000640000005a00000032000000280000000a000000090000000500000004000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"cm\""
          },
          "0x2001": {
            "type": "string",
            "value": "\"m\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"cd\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"d\""
          },
          "0x2006": {
            "type": "string",
            "value": "\"xc\""
          },
          "0x2007": {
            "type": "string",
            "value": "\"c\""
          },
          "0x2009": {
            "type": "string",
            "value": "\"xl\""
          },
          "0x200a": {
            "type": "string",
            "value": "\"l\""
          },
          "0x200c": {
            "type": "string",
            "value": "\"ix\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"x\""
          },
          "0x200f": {
            "type": "string",
            "value": "\"iv\""
          },
          "0x2010": {
            "type": "string",
            "value": "\"v\""
          },
          "0x2012": {
            "type": "string",
            "value": "\"i\""
          },
          "0x2020": {
            "type": "byte[16]",
            "value": [
              232,
              3,
              0,
              0,
              132,
              3,
              0,
              0,
              244,
              1,
              0,
              0,
              144,
              1,
              0,
              0
            ]
          },
          "0x2030": {
            "type": "byte[16]",
            "value": [
              100,
              0,
              0,
              0,
              90,
              0,
              0,
              0,
              50,
              0,
              0,
              0,
              40,
              0,
              0,
              0
            ]
          },
          "0x2040": {
            "type": "byte[16]",
            "value": [
              10,
              0,
              0,
              0,
              9,
              0,
              0,
              0,
              5,
              0,
              0,
              0,
              4,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int n, char *s) {\n  int i, j;\n  char *t;\n  int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  char *roman[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  *s = '\\0';\n  t = s;\n  for (i = 0; i < 13 && n > 0; i++) {\n    for (j = num[i]; j <= n; j += num[i]) {\n      t = strcat(t, roman[i]);\n      n -= num[i];\n    }\n  }\n}"
    },
    {
      "task_id": 162,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1188 <func0+0x2f>\n  lea    0xe85(%rip),%rax        # 2000 <_fini+0xdd0>\n  mov    %rax,%rdi\n  call   1090 <strdup@plt>\n  jmp    122d <func0+0xd4>\n  movl   $0xffffffff,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11e2 <func0+0x89>\n  mov    -0x10(%rbp),%edx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x15(%rbp)\n  movzbl -0x15(%rbp),%eax\n  xor    %eax,-0x14(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11d8 <func0+0x7f>\n  mov    -0x14(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  je     11d1 <func0+0x78>\n  mov    -0x14(%rbp),%eax\n  shr    %eax\n  xor    $0xedb88320,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    11d4 <func0+0x7b>\n  shrl   -0x14(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  cmpl   $0x7,-0xc(%rbp)\n  jbe    11b8 <func0+0x5f>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%edx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1198 <func0+0x3f>\n  notl   -0x14(%rbp)\n  mov    $0x9,%edi\n  call   1070 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  je     1229 <func0+0xd0>\n  mov    -0x14(%rbp),%edx\n  mov    -0x8(%rbp),%rax\n  lea    0xdec(%rip),%rcx        # 2005 <_fini+0xdd5>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1080 <sprintf@plt>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L0\n  lea    D0(%rip),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  jmp    L1\nL0:\n  movl   $0xffffffff,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L2\nL7:\n  mov    -0x10(%rbp),%edx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x15(%rbp)\n  movzbl -0x15(%rbp),%eax\n  xor    %eax,-0x14(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L3\nL6:\n  mov    -0x14(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  je     L4\n  mov    -0x14(%rbp),%eax\n  shr    %eax\n  xor    $0xedb88320,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    L5\nL4:\n  shrl   -0x14(%rbp)\nL5:\n  addl   $0x1,-0xc(%rbp)\nL3:\n  cmpl   $0x7,-0xc(%rbp)\n  jbe    L6\n  addl   $0x1,-0x10(%rbp)\nL2:\n  mov    -0x10(%rbp),%edx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L7\n  notl   -0x14(%rbp)\n  mov    $0x9,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  je     L8\n  mov    -0x14(%rbp),%edx\n  mov    -0x8(%rbp),%rax\n  lea    D1(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\nL8:\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3717
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8197,
          "bias": [
            3564
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4488
        },
        "L1": {
          "label": "L1",
          "addr": 4653
        },
        "L2": {
          "label": "L2",
          "addr": 4578
        },
        "L3": {
          "label": "L3",
          "addr": 4568
        },
        "L4": {
          "label": "L4",
          "addr": 4561
        },
        "L5": {
          "label": "L5",
          "addr": 4564
        },
        "L6": {
          "label": "L6",
          "addr": 4536
        },
        "L7": {
          "label": "L7",
          "addr": 4504
        },
        "L8": {
          "label": "L8",
          "addr": 4649
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e6f6e65002530385800",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"None\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"%08X\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *arg0) {\n  unsigned int l1;\n  unsigned int l2;\n  unsigned char l3;\n  unsigned int l4;\n  char *l5;\n  if ((*arg0) == (char)000) {\n    l1 = 0;\n    l1 = l1 - 1;\n    l1 = l1 * 1;\n    l1 = l1 + 0xEDB88320;\n    l1 = l1 + 0;\n    return strdup(\"None\");\n  } else {\n    l1 = 4278222720U;\n    l2 = 0;\n    while ((*((arg0) + (l2))) != (char)000) {\n      l3 = *((arg0) + (l2));\n      l1 = l1 ^ (unsigned int)l3;\n      l4 = 0;\n      while (l4 < 8) {\n        if ((l1 & 1) == 1) {\n          l1 = (l1 >> 1) ^ 3921149961U;\n        } else {\n          l1 = l1 >> 1;\n        }\n        l4 = l4 + 1;\n      }\n      l2 = l2 + 1;\n    }\n    l1 = 4294967295U - l1;\n    l5 = malloc(9);\n    if (l5) {\n      sprintf(l5, \"%08X\", l1);\n    }\n    return l5;\n  }\n}"
    },
    {
      "task_id": 162,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     1267 <func0+0x107>\n  push   %r12\n  xor    %esi,%esi\n  mov    $0xffffffff,%r8d\n  push   %rbx\n  sub    $0x8,%rsp\n  xchg   %ax,%ax\n  movzbl %al,%eax\n  xor    %r8d,%eax\n  mov    %eax,%ecx\n  shr    %ecx\n  mov    %ecx,%edx\n  xor    $0xedb88320,%edx\n  test   $0x1,%al\n  cmovne %edx,%ecx\n  mov    %ecx,%edx\n  shr    %edx\n  mov    %edx,%eax\n  xor    $0xedb88320,%eax\n  and    $0x1,%ecx\n  cmovne %eax,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%edx\n  shr    %edx\n  mov    %edx,%ecx\n  xor    $0xedb88320,%ecx\n  test   $0x1,%al\n  cmovne %ecx,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%edx\n  shr    %edx\n  mov    %edx,%ecx\n  xor    $0xedb88320,%ecx\n  test   $0x1,%al\n  cmovne %ecx,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%r8d\n  shr    %r8d\n  mov    %r8d,%edx\n  xor    $0xedb88320,%edx\n  test   $0x1,%al\n  lea    0x1(%rsi),%eax\n  mov    %rax,%rsi\n  movzbl (%rdi,%rax,1),%eax\n  cmovne %edx,%r8d\n  test   %al,%al\n  jne    1180 <func0+0x20>\n  mov    $0x9,%edi\n  mov    %r8d,%ebx\n  call   1070 <malloc@plt>\n  not    %ebx\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     125c <func0+0xfc>\n  mov    %rax,%rdi\n  mov    %ebx,%r8d\n  lea    0xdba(%rip),%rcx        # 2005 <_fini+0xd91>\n  xor    %eax,%eax\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  call   1090 <__sprintf_chk@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %r12\n  ret\n  lea    0xd92(%rip),%rdi        # 2000 <_fini+0xd8c>\n  jmp    1080 <strdup@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  push   %r12\n  xor    %esi,%esi\n  mov    $0xffffffff,%r8d\n  push   %rbx\n  sub    $0x8,%rsp\n  xchg   %ax,%ax\nL1:\n  movzbl %al,%eax\n  xor    %r8d,%eax\n  mov    %eax,%ecx\n  shr    %ecx\n  mov    %ecx,%edx\n  xor    $0xedb88320,%edx\n  test   $0x1,%al\n  cmovne %edx,%ecx\n  mov    %ecx,%edx\n  shr    %edx\n  mov    %edx,%eax\n  xor    $0xedb88320,%eax\n  and    $0x1,%ecx\n  cmovne %eax,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%edx\n  shr    %edx\n  mov    %edx,%ecx\n  xor    $0xedb88320,%ecx\n  test   $0x1,%al\n  cmovne %ecx,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%edx\n  shr    %edx\n  mov    %edx,%ecx\n  xor    $0xedb88320,%ecx\n  test   $0x1,%al\n  cmovne %ecx,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%r8d\n  shr    %r8d\n  mov    %r8d,%edx\n  xor    $0xedb88320,%edx\n  test   $0x1,%al\n  lea    0x1(%rsi),%eax\n  mov    %rax,%rsi\n  movzbl (%rdi,%rax,1),%eax\n  cmovne %edx,%r8d\n  test   %al,%al\n  jne    L1\n  mov    $0x9,%edi\n  mov    %r8d,%ebx\n  call   <malloc@plt>\n  not    %ebx\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     L2\n  mov    %rax,%rdi\n  mov    %ebx,%r8d\n  lea    D0(%rip),%rcx\n  xor    %eax,%eax\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  call   <__sprintf_chk@plt>\nL2:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %r12\n  ret\nL0:\n  lea    D1(%rip),%rdi\n  jmp    1080 <strdup@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8197,
          "bias": [
            3514
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3474
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4711
        },
        "L1": {
          "label": "L1",
          "addr": 4480
        },
        "L2": {
          "label": "L2",
          "addr": 4700
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "4e6f6e65002530385800",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"None\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"%08X\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " char *func0(const char *arg0) {\n  unsigned int crc = 0xFFFFFFFF;\n  unsigned char *p = (unsigned char *)arg0;\n  unsigned int i = 0;\n  while (p[i] != 0) {\n    crc = crc ^ p[i];\n    for (int j = 0; j < 8; j++) {\n      if (crc & 1) {\n        crc = (crc >> 1) ^ 0xEDB88320;\n      } else {\n        crc = crc >> 1;\n      }\n    }\n    i++;\n  }\n  crc = ~crc;\n  char *ret = (char *)malloc(9);\n  if (ret)\n    __sprintf_chk(ret, 1, 9, \"%08X\", crc);\n  return ret;\n}"
    },
    {
      "task_id": 163,
      "type": "O3",
      "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
      "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  mov    %edi,%eax\n  cmp    %edi,%esi\n  jge    1114 <func0+0x14>\n  mov    %esi,%eax\n  mov    %edi,%esi\n  cmp    $0x9,%eax\n  jg     1148 <func0+0x48>\n  mov    $0x9,%edi\n  cmp    %edi,%esi\n  cmovg  %edi,%esi\n  nopl   0x0(%rax,%rax,1)\n  test   $0x1,%al\n  jne    1139 <func0+0x39>\n  movslq (%rcx),%rdi\n  lea    0x1(%rdi),%r8d\n  mov    %r8d,(%rcx)\n  mov    %eax,(%rdx,%rdi,4)\n  add    $0x1,%eax\n  cmp    %esi,%eax\n  jle    1128 <func0+0x28>\n  ret\n  nopl   0x0(%rax)\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  mov    %edi,%eax\n  cmp    %edi,%esi\n  jge    L0\n  mov    %esi,%eax\n  mov    %edi,%esi\nL0:\n  cmp    $0x9,%eax\n  jg     L1\n  mov    $0x9,%edi\n  cmp    %edi,%esi\n  cmovg  %edi,%esi\n  nopl   0x0(%rax,%rax,1)\nL3:\n  test   $0x1,%al\n  jne    L2\n  movslq (%rcx),%rdi\n  lea    0x1(%rdi),%r8d\n  mov    %r8d,(%rcx)\n  mov    %eax,(%rdx,%rdi,4)\nL2:\n  add    $0x1,%eax\n  cmp    %esi,%eax\n  jle    L3\n  ret\n  nopl   0x0(%rax)\nL1:\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4372
        },
        "L1": {
          "label": "L1",
          "addr": 4424
        },
        "L2": {
          "label": "L2",
          "addr": 4409
        },
        "L3": {
          "label": "L3",
          "addr": 4392
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int a, int b, int *c, int *d) {\n  *d = 0;\n  if (a > b) {\n    int tmp = a;\n    a = b;\n    b = tmp;\n  }\n  for (int i = a; i <= ({\n                __typeof__(a) _a = (a);\n                __typeof__(b) _b = (b);\n                _a < _b ? _a : _b;\n              });\n       i++) {\n    if (i % 2 == 0) {\n      c[(*d)++] = i;\n    }\n  }\n}"
    },
    {
      "task_id": 160,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  movslq %ecx,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  lea    0x0(,%r13,4),%rbx\n  sub    $0x28,%rsp\n  mov    %rdi,0x18(%rsp)\n  mov    %rbx,%rdi\n  mov    %edx,0x14(%rsp)\n  call   10a0 <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   10a0 <malloc@plt>\n  mov    %rax,%rbp\n  test   %r13d,%r13d\n  jle    11e5 <func0+0x65>\n  mov    %rbx,%rdx\n  mov    %r14,%rsi\n  mov    %r12,%rdi\n  call   1090 <memcpy@plt>\n  xor    %eax,%eax\n  nopl   0x0(%rax)\n  mov    %eax,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %r13,%rax\n  jne    11d8 <func0+0x58>\n  mov    0x14(%rsp),%eax\n  test   %eax,%eax\n  jle    1443 <func0+0x2c3>\n  mov    0x14(%rsp),%eax\n  mov    0x18(%rsp),%r14\n  lea    0x4(%rbp),%rdx\n  sub    $0x1,%eax\n  mov    %r14,%r13\n  lea    0x8(%r14,%rax,8),%rbx\n  nopl   0x0(%rax)\n  mov    (%r14),%rax\n  cmpb   $0x2a,(%rax)\n  jne    12c0 <func0+0x140>\n  cmpb   $0x2a,0x1(%rax)\n  jne    12c0 <func0+0x140>\n  cmpb   $0x0,0x2(%rax)\n  jne    12c0 <func0+0x140>\n  movslq -0x4(%rdx),%rax\n  mov    %rax,%r15\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%r15d\n  je     1251 <func0+0xd1>\n  cltq\n  mov    %eax,-0x4(%rdx)\n  mov    %rax,%r15\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %r15d,%eax\n  jne    1240 <func0+0xc0>\n  movslq (%rdx),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     1287 <func0+0x107>\n  nopw   0x0(%rax,%rax,1)\n  movslq %eax,%rcx\n  mov    %eax,(%rdx)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    1270 <func0+0xf0>\n  movslq %r15d,%rax\n  pxor   %xmm0,%xmm0\n  pxor   %xmm1,%xmm1\n  mov    %rdx,0x8(%rsp)\n  cvtsi2sdl (%r12,%r9,1),%xmm1\n  lea    (%r12,%rax,4),%rax\n  cvtsi2sdl (%rax),%xmm0\n  mov    %rax,(%rsp)\n  call   10b0 <pow@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%rdx\n  cvttsd2si %xmm0,%ecx\n  mov    %r15d,(%rdx)\n  mov    %ecx,(%rax)\n  add    $0x8,%r14\n  add    $0x4,%rdx\n  cmp    %r14,%rbx\n  jne    1210 <func0+0x90>\n  mov    0x14(%rsp),%r14d\n  mov    0x18(%rsp),%rbx\n  mov    %rbp,%rdi\n  mov    %rbp,%rsi\n  lea    0x0(%rbp,%r14,4),%r8\n  cs nopw 0x0(%rax,%rax,1)\n  mov    (%rbx),%r11\n  movzbl (%r11),%r10d\n  cmp    $0x2a,%r10d\n  jne    1488 <func0+0x308>\n  cmpb   $0x0,0x1(%r11)\n  jne    1488 <func0+0x308>\n  movslq (%rsi),%rax\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     132f <func0+0x1af>\n  nopw   0x0(%rax,%rax,1)\n  cltq\n  mov    %eax,(%rsi)\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %ecx,%eax\n  jne    1320 <func0+0x1a0>\n  movslq 0x4(%rsi),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r14\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     136a <func0+0x1ea>\n  cs nopw 0x0(%rax,%rax,1)\n  movslq %eax,%rdx\n  mov    %eax,0x4(%rsi)\n  mov    %eax,%r9d\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r14\n  cmp    %r9d,%eax\n  jne    1350 <func0+0x1d0>\n  sub    $0x2a,%r10d\n  jne    1375 <func0+0x1f5>\n  movzbl 0x1(%r11),%r10d\n  add    %r12,%r14\n  movslq %ecx,%rax\n  test   %r10d,%r10d\n  jne    14c0 <func0+0x340>\n  lea    (%r12,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   (%r14),%eax\n  mov    %eax,(%rdx)\n  mov    %ecx,0x4(%rsi)\n  add    $0x4,%rsi\n  add    $0x8,%rbx\n  cmp    %rsi,%r8\n  jne    12f0 <func0+0x170>\n  nopl   0x0(%rax)\n  mov    0x0(%r13),%rax\n  movzbl (%rax),%r10d\n  cmp    $0x2b,%r10d\n  jne    1470 <func0+0x2f0>\n  cmpb   $0x0,0x1(%rax)\n  jne    1470 <func0+0x2f0>\n  movslq (%rdi),%rax\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     13e7 <func0+0x267>\n  nopw   0x0(%rax,%rax,1)\n  cltq\n  mov    %eax,(%rdi)\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    13d8 <func0+0x258>\n  movslq 0x4(%rdi),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     1418 <func0+0x298>\n  xchg   %ax,%ax\n  movslq %eax,%rcx\n  mov    %eax,0x4(%rdi)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    1400 <func0+0x280>\n  add    %r12,%r9\n  movslq %edx,%rax\n  mov    (%r9),%ecx\n  cmp    $0x2b,%r10d\n  jne    14b0 <func0+0x330>\n  add    %ecx,(%r12,%rax,4)\n  mov    %edx,0x4(%rdi)\n  add    $0x4,%rdi\n  add    $0x8,%r13\n  cmp    %rdi,%r8\n  jne    13a8 <func0+0x228>\n  mov    %r12,%rdi\n  mov    (%r12),%r13d\n  call   1080 <free@plt>\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  add    $0x28,%rsp\n  mov    %r13d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  cmp    $0x2d,%r10d\n  jne    1432 <func0+0x2b2>\n  cmpb   $0x0,0x1(%rax)\n  je     13c4 <func0+0x244>\n  jmp    1432 <func0+0x2b2>\n  nopw   0x0(%rax,%rax,1)\n  cmpb   $0x2f,(%r11)\n  jne    1393 <func0+0x213>\n  cmpb   $0x2f,0x1(%r11)\n  jne    1393 <func0+0x213>\n  cmpb   $0x0,0x2(%r11)\n  je     130c <func0+0x18c>\n  jmp    1393 <func0+0x213>\n  nopl   (%rax)\n  sub    %ecx,(%r12,%rax,4)\n  jmp    142f <func0+0x2af>\n  nopl   0x0(%rax)\n  lea    (%r12,%rax,4),%r9\n  mov    (%r9),%eax\n  cltd\n  idivl  (%r14)\n  mov    %eax,(%r9)\n  jmp    1390 <func0+0x210>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  movslq %ecx,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  lea    0x0(,%r13,4),%rbx\n  sub    $0x28,%rsp\n  mov    %rdi,0x18(%rsp)\n  mov    %rbx,%rdi\n  mov    %edx,0x14(%rsp)\n  call   <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %r13d,%r13d\n  jle    L0\n  mov    %rbx,%rdx\n  mov    %r14,%rsi\n  mov    %r12,%rdi\n  call   <memcpy@plt>\n  xor    %eax,%eax\n  nopl   0x0(%rax)\nL1:\n  mov    %eax,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %r13,%rax\n  jne    L1\nL0:\n  mov    0x14(%rsp),%eax\n  test   %eax,%eax\n  jle    L2\n  mov    0x14(%rsp),%eax\n  mov    0x18(%rsp),%r14\n  lea    0x4(%rbp),%rdx\n  sub    $0x1,%eax\n  mov    %r14,%r13\n  lea    0x8(%r14,%rax,8),%rbx\n  nopl   0x0(%rax)\nL8:\n  mov    (%r14),%rax\n  cmpb   $0x2a,(%rax)\n  jne    L3\n  cmpb   $0x2a,0x1(%rax)\n  jne    L3\n  cmpb   $0x0,0x2(%rax)\n  jne    L3\n  movslq -0x4(%rdx),%rax\n  mov    %rax,%r15\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%r15d\n  je     L4\nL5:\n  cltq\n  mov    %eax,-0x4(%rdx)\n  mov    %rax,%r15\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %r15d,%eax\n  jne    L5\nL4:\n  movslq (%rdx),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L6\n  nopw   0x0(%rax,%rax,1)\nL7:\n  movslq %eax,%rcx\n  mov    %eax,(%rdx)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    L7\nL6:\n  movslq %r15d,%rax\n  pxor   %xmm0,%xmm0\n  pxor   %xmm1,%xmm1\n  mov    %rdx,0x8(%rsp)\n  cvtsi2sdl (%r12,%r9,1),%xmm1\n  lea    (%r12,%rax,4),%rax\n  cvtsi2sdl (%rax),%xmm0\n  mov    %rax,(%rsp)\n  call   <pow@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%rdx\n  cvttsd2si %xmm0,%ecx\n  mov    %r15d,(%rdx)\n  mov    %ecx,(%rax)\nL3:\n  add    $0x8,%r14\n  add    $0x4,%rdx\n  cmp    %r14,%rbx\n  jne    L8\n  mov    0x14(%rsp),%r14d\n  mov    0x18(%rsp),%rbx\n  mov    %rbp,%rdi\n  mov    %rbp,%rsi\n  lea    0x0(%rbp,%r14,4),%r8\n  cs nopw 0x0(%rax,%rax,1)\nL16:\n  mov    (%rbx),%r11\n  movzbl (%r11),%r10d\n  cmp    $0x2a,%r10d\n  jne    L9\n  cmpb   $0x0,0x1(%r11)\n  jne    L9\nL27:\n  movslq (%rsi),%rax\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L10\n  nopw   0x0(%rax,%rax,1)\nL11:\n  cltq\n  mov    %eax,(%rsi)\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %ecx,%eax\n  jne    L11\nL10:\n  movslq 0x4(%rsi),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r14\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     L12\n  cs nopw 0x0(%rax,%rax,1)\nL13:\n  movslq %eax,%rdx\n  mov    %eax,0x4(%rsi)\n  mov    %eax,%r9d\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r14\n  cmp    %r9d,%eax\n  jne    L13\nL12:\n  sub    $0x2a,%r10d\n  jne    L14\n  movzbl 0x1(%r11),%r10d\nL14:\n  add    %r12,%r14\n  movslq %ecx,%rax\n  test   %r10d,%r10d\n  jne    L15\n  lea    (%r12,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   (%r14),%eax\n  mov    %eax,(%rdx)\nL29:\n  mov    %ecx,0x4(%rsi)\nL26:\n  add    $0x4,%rsi\n  add    $0x8,%rbx\n  cmp    %rsi,%r8\n  jne    L16\n  nopl   0x0(%rax)\nL23:\n  mov    0x0(%r13),%rax\n  movzbl (%rax),%r10d\n  cmp    $0x2b,%r10d\n  jne    L17\n  cmpb   $0x0,0x1(%rax)\n  jne    L17\nL25:\n  movslq (%rdi),%rax\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     L18\n  nopw   0x0(%rax,%rax,1)\nL19:\n  cltq\n  mov    %eax,(%rdi)\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    L19\nL18:\n  movslq 0x4(%rdi),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L20\n  xchg   %ax,%ax\nL21:\n  movslq %eax,%rcx\n  mov    %eax,0x4(%rdi)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    L21\nL20:\n  add    %r12,%r9\n  movslq %edx,%rax\n  mov    (%r9),%ecx\n  cmp    $0x2b,%r10d\n  jne    L22\n  add    %ecx,(%r12,%rax,4)\nL28:\n  mov    %edx,0x4(%rdi)\nL24:\n  add    $0x4,%rdi\n  add    $0x8,%r13\n  cmp    %rdi,%r8\n  jne    L23\nL2:\n  mov    %r12,%rdi\n  mov    (%r12),%r13d\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  add    $0x28,%rsp\n  mov    %r13d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL17:\n  cmp    $0x2d,%r10d\n  jne    L24\n  cmpb   $0x0,0x1(%rax)\n  je     L25\n  jmp    L24\n  nopw   0x0(%rax,%rax,1)\nL9:\n  cmpb   $0x2f,(%r11)\n  jne    L26\n  cmpb   $0x2f,0x1(%r11)\n  jne    L26\n  cmpb   $0x0,0x2(%r11)\n  je     L27\n  jmp    L26\n  nopl   (%rax)\nL22:\n  sub    %ecx,(%r12,%rax,4)\n  jmp    L28\n  nopl   0x0(%rax)\nL15:\n  lea    (%r12,%rax,4),%r9\n  mov    (%r9),%eax\n  cltd\n  idivl  (%r14)\n  mov    %eax,(%r9)\n  jmp    L29",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4581
        },
        "L1": {
          "label": "L1",
          "addr": 4568
        },
        "L2": {
          "label": "L2",
          "addr": 5187
        },
        "L3": {
          "label": "L3",
          "addr": 4800
        },
        "L4": {
          "label": "L4",
          "addr": 4689
        },
        "L5": {
          "label": "L5",
          "addr": 4672
        },
        "L6": {
          "label": "L6",
          "addr": 4743
        },
        "L7": {
          "label": "L7",
          "addr": 4720
        },
        "L8": {
          "label": "L8",
          "addr": 4624
        },
        "L9": {
          "label": "L9",
          "addr": 5256
        },
        "L10": {
          "label": "L10",
          "addr": 4911
        },
        "L11": {
          "label": "L11",
          "addr": 4896
        },
        "L12": {
          "label": "L12",
          "addr": 4970
        },
        "L13": {
          "label": "L13",
          "addr": 4944
        },
        "L14": {
          "label": "L14",
          "addr": 4981
        },
        "L15": {
          "label": "L15",
          "addr": 5312
        },
        "L16": {
          "label": "L16",
          "addr": 4848
        },
        "L17": {
          "label": "L17",
          "addr": 5232
        },
        "L18": {
          "label": "L18",
          "addr": 5095
        },
        "L19": {
          "label": "L19",
          "addr": 5080
        },
        "L20": {
          "label": "L20",
          "addr": 5144
        },
        "L21": {
          "label": "L21",
          "addr": 5120
        },
        "L22": {
          "label": "L22",
          "addr": 5296
        },
        "L23": {
          "label": "L23",
          "addr": 5032
        },
        "L24": {
          "label": "L24",
          "addr": 5170
        },
        "L25": {
          "label": "L25",
          "addr": 5060
        },
        "L26": {
          "label": "L26",
          "addr": 5011
        },
        "L27": {
          "label": "L27",
          "addr": 4876
        },
        "L28": {
          "label": "L28",
          "addr": 5167
        },
        "L29": {
          "label": "L29",
          "addr": 5008
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char **s, int *a, int n, int m) {\n  int *b = (int *)malloc(m * sizeof(int));\n  int *c = (int *)malloc(m * sizeof(int));\n  for (int i = 0; i < m; i++)\n    b[i] = a[i];\n  for (int i = 0; i < n; i++) {\n    if (s[i][0] == '*' && s[i][1] == '*' && s[i][2] == '\\0') {\n      int x = c[i];\n      while (x != c[x])\n        x = c[x];\n      int y = c[i];\n      while (y != c[y])\n        y = c[y] = c[c[y]];\n      b[x] = pow((double)b[x], (double)b[y]);\n      c[i] = x;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (s[i][0] == '*' && s[i][1] == '\\0') {\n      int x = c[i];\n      while (x != c[x])\n        x = c[x];\n      int y = c[i];\n      while (y != c[y])\n        y = c[y] = c[c[y]];\n      if (s[i][0] - '*')\n        b[x] *= b[y];\n      else\n        b[x] /= b[y];\n      c[i] = x;\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (s[i][0] == '+' && s[i][1] == '\\0') {\n      int x = c[i];\n      while (x != c[x])\n        x = c[x];\n      int y = c[i];\n      while (y != c[y])\n        y = c[y] = c[c[y]];\n      if (s[i][0] - '+')\n        b[x] += b[y];\n      else\n        b[x] -= b[y];\n      c[i] = x;\n    }\n  }\n  int ret = b[0];\n  free(b);\n  free(c);\n  return ret;\n}"
    },
    {
      "task_id": 160,
      "type": "O0",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %edx,-0x44(%rbp)\n  mov    %ecx,-0x48(%rbp)\n  mov    -0x48(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   10a0 <malloc@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x48(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   10a0 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    1210 <func0+0x97>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x40(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x24(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x10(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x24(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     11c6 <func0+0x4d>\n  movl   $0x0,-0x20(%rbp)\n  jmp    1452 <func0+0x2d9>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0xdbe(%rip),%rdx        # 2000 <_fini+0x568>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    144e <func0+0x2d5>\n  jmp    1297 <func0+0x11e>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    1257 <func0+0xde>\n  jmp    1328 <func0+0x1af>\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    12e0 <func0+0x167>\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  pxor   %xmm0,%xmm0\n  cvtsi2sd %eax,%xmm0\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %eax,%xmm2\n  movq   %xmm2,%rax\n  movapd %xmm0,%xmm1\n  movq   %rax,%xmm0\n  call   10b0 <pow@plt>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  cvttsd2si %xmm0,%eax\n  mov    %eax,(%rdx)\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x20(%rbp)\n  mov    -0x20(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     1224 <func0+0xab>\n  movl   $0x0,-0x1c(%rbp)\n  jmp    175f <func0+0x5e6>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0xb7b(%rip),%rdx        # 2003 <_fini+0x56b>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  je     150a <func0+0x391>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0xb50(%rip),%rdx        # 2005 <_fini+0x56d>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    175b <func0+0x5e2>\n  jmp    150a <func0+0x391>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    14ca <func0+0x351>\n  jmp    159b <func0+0x422>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    1553 <func0+0x3da>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x9fb(%rip),%rdx        # 2003 <_fini+0x56b>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    16a4 <func0+0x52b>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    -0x8(%rbp),%rdx\n  add    %rsi,%rdx\n  mov    (%rdx),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    -0x10(%rbp),%rdx\n  add    %rsi,%rdx\n  imul   %ecx,%eax\n  mov    %eax,(%rdx)\n  jmp    172a <func0+0x5b1>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x10(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edi\n  mov    -0x1c(%rbp),%ecx\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,4),%rsi\n  mov    -0x8(%rbp),%rcx\n  add    %rsi,%rcx\n  mov    (%rcx),%ecx\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,4),%rsi\n  mov    -0x10(%rbp),%rcx\n  add    %rsi,%rcx\n  cltd\n  idiv   %edi\n  mov    %eax,(%rcx)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     146a <func0+0x2f1>\n  movl   $0x0,-0x18(%rbp)\n  jmp    1a64 <func0+0x8eb>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x873(%rip),%rdx        # 2008 <_fini+0x570>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  je     1817 <func0+0x69e>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x848(%rip),%rdx        # 200a <_fini+0x572>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    1a60 <func0+0x8e7>\n  jmp    1817 <func0+0x69e>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    17d7 <func0+0x65e>\n  jmp    18a8 <func0+0x72f>\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    1860 <func0+0x6e7>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x6f3(%rip),%rdx        # 2008 <_fini+0x570>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    19ae <func0+0x835>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x8(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x10(%rbp),%rax\n  add    %rsi,%rax\n  add    %ecx,%edx\n  mov    %edx,(%rax)\n  jmp    1a2f <func0+0x8b6>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x10(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%ecx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x8(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x10(%rbp),%rax\n  add    %rsi,%rax\n  sub    %ecx,%edx\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     1777 <func0+0x5fe>\n  mov    -0x10(%rbp),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x14(%rbp),%eax\n  leave\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %edx,-0x44(%rbp)\n  mov    %ecx,-0x48(%rbp)\n  mov    -0x48(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x48(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L0\nL1:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x40(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x24(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x10(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x24(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x24(%rbp)\nL0:\n  mov    -0x24(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     L1\n  movl   $0x0,-0x20(%rbp)\n  jmp    L2\nL8:\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D0(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L3\n  jmp    L4\nL5:\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL4:\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L5\n  jmp    L6\nL7:\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL6:\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L7\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  pxor   %xmm0,%xmm0\n  cvtsi2sd %eax,%xmm0\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %eax,%xmm2\n  movq   %xmm2,%rax\n  movapd %xmm0,%xmm1\n  movq   %rax,%xmm0\n  call   <pow@plt>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  cvttsd2si %xmm0,%eax\n  mov    %eax,(%rdx)\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL3:\n  addl   $0x1,-0x20(%rbp)\nL2:\n  mov    -0x20(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     L8\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L9\nL17:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L10\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D2(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L11\n  jmp    L10\nL12:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL10:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L12\n  jmp    L13\nL14:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL13:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L14\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L15\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    -0x8(%rbp),%rdx\n  add    %rsi,%rdx\n  mov    (%rdx),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    -0x10(%rbp),%rdx\n  add    %rsi,%rdx\n  imul   %ecx,%eax\n  mov    %eax,(%rdx)\n  jmp    L16\nL15:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x10(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edi\n  mov    -0x1c(%rbp),%ecx\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,4),%rsi\n  mov    -0x8(%rbp),%rcx\n  add    %rsi,%rcx\n  mov    (%rcx),%ecx\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,4),%rsi\n  mov    -0x10(%rbp),%rcx\n  add    %rsi,%rcx\n  cltd\n  idiv   %edi\n  mov    %eax,(%rcx)\nL16:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL11:\n  addl   $0x1,-0x1c(%rbp)\nL9:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     L17\n  movl   $0x0,-0x18(%rbp)\n  jmp    L18\nL26:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D3(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L19\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D4(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L20\n  jmp    L19\nL21:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL19:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L21\n  jmp    L22\nL23:\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL22:\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L23\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D3(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L24\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x8(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x10(%rbp),%rax\n  add    %rsi,%rax\n  add    %ecx,%edx\n  mov    %edx,(%rax)\n  jmp    L25\nL24:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x10(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%ecx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x8(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x10(%rbp),%rax\n  add    %rsi,%rax\n  sub    %ecx,%edx\n  mov    %edx,(%rax)\nL25:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL20:\n  addl   $0x1,-0x18(%rbp)\nL18:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     L26\n  mov    -0x10(%rbp),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x14(%rbp),%eax\n  leave\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3518
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8195,
          "bias": [
            2939,
            2555
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8197,
          "bias": [
            2896
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8200,
          "bias": [
            2163,
            1779
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8202,
          "bias": [
            2120
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4624
        },
        "L1": {
          "label": "L1",
          "addr": 4550
        },
        "L2": {
          "label": "L2",
          "addr": 5202
        },
        "L3": {
          "label": "L3",
          "addr": 5198
        },
        "L4": {
          "label": "L4",
          "addr": 4759
        },
        "L5": {
          "label": "L5",
          "addr": 4695
        },
        "L6": {
          "label": "L6",
          "addr": 4904
        },
        "L7": {
          "label": "L7",
          "addr": 4832
        },
        "L8": {
          "label": "L8",
          "addr": 4644
        },
        "L9": {
          "label": "L9",
          "addr": 5983
        },
        "L10": {
          "label": "L10",
          "addr": 5386
        },
        "L11": {
          "label": "L11",
          "addr": 5979
        },
        "L12": {
          "label": "L12",
          "addr": 5322
        },
        "L13": {
          "label": "L13",
          "addr": 5531
        },
        "L14": {
          "label": "L14",
          "addr": 5459
        },
        "L15": {
          "label": "L15",
          "addr": 5796
        },
        "L16": {
          "label": "L16",
          "addr": 5930
        },
        "L17": {
          "label": "L17",
          "addr": 5226
        },
        "L18": {
          "label": "L18",
          "addr": 6756
        },
        "L19": {
          "label": "L19",
          "addr": 6167
        },
        "L20": {
          "label": "L20",
          "addr": 6752
        },
        "L21": {
          "label": "L21",
          "addr": 6103
        },
        "L22": {
          "label": "L22",
          "addr": 6312
        },
        "L23": {
          "label": "L23",
          "addr": 6240
        },
        "L24": {
          "label": "L24",
          "addr": 6574
        },
        "L25": {
          "label": "L25",
          "addr": 6703
        },
        "L26": {
          "label": "L26",
          "addr": 6007
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "2a2a002a002f2f002b002d00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"**\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"*\""
          },
          "0x2005": {
            "type": "string",
            "value": "\"//\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"+\""
          },
          "0x200a": {
            "type": "string",
            "value": "\"-\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char **tokens, int *values, int ntokens, int nvalues) {\n  int *vals = malloc(nvalues * sizeof(int));\n  int *stack = malloc(nvalues * sizeof(int));\n  for (int i = 0; i < nvalues; i++) {\n    vals[i] = values[i];\n    stack[i] = i;\n  }\n  for (int i = 0; i < ntokens; i++) {\n    if (!strcmp(tokens[i], \"**\")) {\n      while (stack[i] != stack[i])\n        stack[i] = stack[stack[i]];\n      while (stack[i + 1] != stack[i + 1])\n        stack[i + 1] = stack[stack[i + 1]];\n      if (!strcmp(tokens[i], \"**\")) {\n        vals[stack[i]] = vals[stack[i]] * vals[stack[i + 1]];\n      } else {\n        vals[stack[i]] = vals[stack[i]] / vals[stack[i + 1]];\n      }\n      stack[i + 1] = stack[i];\n    }\n  }\n  for (int i = 0; i < ntokens; i++) {\n    if (!strcmp(tokens[i], \"*\") || !strcmp(tokens[i], \"//\")) {\n      while (stack[i] != stack[i])\n        stack[i] = stack[stack[i]];\n      while (stack[i + 1] != stack[i + 1])\n        stack[i + 1] = stack[stack[i + 1]];\n      if (!strcmp(tokens[i], \"*\")) {\n        vals[stack[i]] = vals[stack[i]] + vals[stack[i + 1]];\n      } else {\n        vals[stack[i]] = vals[stack[i]] - vals[stack[i + 1]];\n      }\n      stack[i + 1] = stack[i];\n    }\n  }\n  int ret = vals[0];\n  free(vals);\n  free(stack);\n  return ret;\n}"
    },
    {
      "task_id": 156,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xb0,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  lea    0xe96(%rip),%rax        # 2001 <_fini+0xd11>\n  movb   $0x0,(%rsi)\n  mov    %rax,0x40(%rsp)\n  lea    0xe86(%rip),%rax        # 2000 <_fini+0xd10>\n  mov    %rax,0x48(%rsp)\n  lea    0xe7e(%rip),%rax        # 2004 <_fini+0xd14>\n  mov    %rax,0x50(%rsp)\n  lea    0xe71(%rip),%rax        # 2003 <_fini+0xd13>\n  mov    %rax,0x58(%rsp)\n  lea    0xe69(%rip),%rax        # 2007 <_fini+0xd17>\n  mov    %rax,0x60(%rsp)\n  lea    0xe5c(%rip),%rax        # 2006 <_fini+0xd16>\n  mov    %rax,0x68(%rsp)\n  lea    0xe54(%rip),%rax        # 200a <_fini+0xd1a>\n  mov    %rax,0x70(%rsp)\n  lea    0xe47(%rip),%rax        # 2009 <_fini+0xd19>\n  mov    %rax,0x78(%rsp)\n  lea    0xe3f(%rip),%rax        # 200d <_fini+0xd1d>\n  mov    %rax,0x80(%rsp)\n  lea    0xe2f(%rip),%rax        # 200c <_fini+0xd1c>\n  mov    %rax,0x88(%rsp)\n  lea    0xe24(%rip),%rax        # 2010 <_fini+0xd20>\n  mov    %rax,0x90(%rsp)\n  lea    0xe14(%rip),%rax        # 200f <_fini+0xd1f>\n  mov    %rax,0x98(%rsp)\n  lea    0xe08(%rip),%rax        # 2012 <_fini+0xd22>\n  mov    %rax,0xa0(%rsp)\n  movabs $0x1f400000384,%rax\n  mov    %rax,0x4(%rsp)\n  movabs $0x6400000190,%rax\n  mov    %rax,0xc(%rsp)\n  movabs $0x320000005a,%rax\n  mov    %rax,0x14(%rsp)\n  movabs $0xa00000028,%rax\n  mov    %rax,0x1c(%rsp)\n  movabs $0x500000009,%rax\n  mov    %rax,0x24(%rsp)\n  movabs $0x100000004,%rax\n  mov    %rax,0x2c(%rsp)\n  test   %edi,%edi\n  jle    12c8 <func0+0x188>\n  mov    %edi,%ebx\n  mov    $0x3e8,%ebp\n  mov    %rsi,%rdx\n  xor    %r13d,%r13d\n  lea    0x40(%rsp),%r14\n  cmp    %ebx,%ebp\n  jg     12bc <func0+0x17c>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    (%r14,%r13,2),%r12\n  nopl   0x0(%rax)\n  mov    %rdx,%rdi\n  mov    %r12,%rsi\n  sub    %ebp,%ebx\n  call   1070 <strcat@plt>\n  mov    %rax,%rdx\n  cmp    %ebx,%ebp\n  jle    1298 <func0+0x158>\n  add    $0x4,%r13\n  test   %ebx,%ebx\n  je     12c8 <func0+0x188>\n  mov    (%rsp,%r13,1),%ebp\n  cmp    %ebx,%ebp\n  jle    1290 <func0+0x150>\n  add    $0x4,%r13\n  jmp    12b4 <func0+0x174>\n  nopw   0x0(%rax,%rax,1)\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12eb <func0+0x1ab>\n  add    $0xb0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  call   1060 <__stack_chk_fail@plt>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xb0,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  lea    D0(%rip),%rax\n  movb   $0x0,(%rsi)\n  mov    %rax,0x40(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x50(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x58(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x60(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x68(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x70(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x78(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x80(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x88(%rsp)\n  lea    D10(%rip),%rax\n  mov    %rax,0x90(%rsp)\n  lea    D11(%rip),%rax\n  mov    %rax,0x98(%rsp)\n  lea    D12(%rip),%rax\n  mov    %rax,0xa0(%rsp)\n  movabs $0x1f400000384,%rax\n  mov    %rax,0x4(%rsp)\n  movabs $0x6400000190,%rax\n  mov    %rax,0xc(%rsp)\n  movabs $0x320000005a,%rax\n  mov    %rax,0x14(%rsp)\n  movabs $0xa00000028,%rax\n  mov    %rax,0x1c(%rsp)\n  movabs $0x500000009,%rax\n  mov    %rax,0x24(%rsp)\n  movabs $0x100000004,%rax\n  mov    %rax,0x2c(%rsp)\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%ebx\n  mov    $0x3e8,%ebp\n  mov    %rsi,%rdx\n  xor    %r13d,%r13d\n  lea    0x40(%rsp),%r14\n  cmp    %ebx,%ebp\n  jg     L1\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    (%r14,%r13,2),%r12\n  nopl   0x0(%rax)\nL2:\n  mov    %rdx,%rdi\n  mov    %r12,%rsi\n  sub    %ebp,%ebx\n  call   <strcat@plt>\n  mov    %rax,%rdx\n  cmp    %ebx,%ebp\n  jle    L2\n  add    $0x4,%r13\n  test   %ebx,%ebx\n  je     L0\nL4:\n  mov    (%rsp,%r13,1),%ebp\n  cmp    %ebx,%ebp\n  jle    L3\nL1:\n  add    $0x4,%r13\n  jmp    L4\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  add    $0xb0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL5:\n  call   <__stack_chk_fail@plt>",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8193,
          "bias": [
            3734
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8192,
          "bias": [
            3718
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8196,
          "bias": [
            3710
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8195,
          "bias": [
            3697
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8199,
          "bias": [
            3689
          ]
        },
        "D5": {
          "label": "D5",
          "addr": 8198,
          "bias": [
            3676
          ]
        },
        "D6": {
          "label": "D6",
          "addr": 8202,
          "bias": [
            3668
          ]
        },
        "D7": {
          "label": "D7",
          "addr": 8201,
          "bias": [
            3655
          ]
        },
        "D8": {
          "label": "D8",
          "addr": 8205,
          "bias": [
            3647
          ]
        },
        "D9": {
          "label": "D9",
          "addr": 8204,
          "bias": [
            3631
          ]
        },
        "D10": {
          "label": "D10",
          "addr": 8208,
          "bias": [
            3620
          ]
        },
        "D11": {
          "label": "D11",
          "addr": 8207,
          "bias": [
            3604
          ]
        },
        "D12": {
          "label": "D12",
          "addr": 8210,
          "bias": [
            3592
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4808
        },
        "L1": {
          "label": "L1",
          "addr": 4796
        },
        "L2": {
          "label": "L2",
          "addr": 4760
        },
        "L3": {
          "label": "L3",
          "addr": 4752
        },
        "L4": {
          "label": "L4",
          "addr": 4788
        },
        "L5": {
          "label": "L5",
          "addr": 4843
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "636d00636400786300786c006978006976006900",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"cm\""
          },
          "0x2001": {
            "type": "string",
            "value": "\"m\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"cd\""
          },
          "0x2004": {
            "type": "string",
            "value": "\"d\""
          },
          "0x2006": {
            "type": "string",
            "value": "\"xc\""
          },
          "0x2007": {
            "type": "string",
            "value": "\"c\""
          },
          "0x2009": {
            "type": "string",
            "value": "\"xl\""
          },
          "0x200a": {
            "type": "string",
            "value": "\"l\""
          },
          "0x200c": {
            "type": "string",
            "value": "\"ix\""
          },
          "0x200d": {
            "type": "string",
            "value": "\"x\""
          },
          "0x200f": {
            "type": "string",
            "value": "\"iv\""
          },
          "0x2010": {
            "type": "string",
            "value": "\"v\""
          },
          "0x2012": {
            "type": "string",
            "value": "\"i\""
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " void func0(int n, char *s) {\n  char *num[] = {\"\", \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n  int val[] = {0, 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n  int i = 0;\n  *s = '\\0';\n  while (n > 0) {\n    while (n >= val[i]) {\n      s = strcat(s, num[i]);\n      n -= val[i];\n    }\n    i++;\n  }\n}"
    },
    {
      "task_id": 160,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rsi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %ecx,%rbp\n  push   %rbx\n  mov    %rbp,%r13\n  shl    $0x2,%rbp\n  sub    $0x28,%rsp\n  mov    %rdi,0x18(%rsp)\n  mov    %rbp,%rdi\n  mov    %edx,0x14(%rsp)\n  call   10a0 <malloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r12\n  call   10a0 <malloc@plt>\n  mov    %rax,%rbp\n  test   %r13d,%r13d\n  jle    1258 <func0+0xd8>\n  mov    %r13d,%edx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  shl    $0x2,%rdx\n  call   1090 <memcpy@plt>\n  lea    -0x1(%r13),%eax\n  cmp    $0x2,%eax\n  jbe    1553 <func0+0x3d3>\n  mov    %r13d,%edx\n  movdqa 0xe0f(%rip),%xmm0        # 2000 <_fini+0xaa4>\n  movdqa 0xe17(%rip),%xmm2        # 2010 <_fini+0xab4>\n  mov    %rbp,%rax\n  shr    $0x2,%edx\n  shl    $0x4,%rdx\n  add    %rbp,%rdx\n  cs nopw 0x0(%rax,%rax,1)\n  movdqa %xmm0,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm2,%xmm0\n  movups %xmm1,-0x10(%rax)\n  cmp    %rax,%rdx\n  jne    1210 <func0+0x90>\n  mov    %r13d,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%r13b\n  je     1258 <func0+0xd8>\n  movslq %eax,%rdx\n  mov    %eax,0x0(%rbp,%rdx,4)\n  lea    0x0(,%rdx,4),%rcx\n  lea    0x1(%rax),%edx\n  cmp    %edx,%r13d\n  jle    1258 <func0+0xd8>\n  add    $0x2,%eax\n  mov    %edx,0x4(%rbp,%rcx,1)\n  cmp    %eax,%r13d\n  jle    1258 <func0+0xd8>\n  mov    %eax,0x8(%rbp,%rcx,1)\n  mov    0x14(%rsp),%eax\n  test   %eax,%eax\n  jle    14c3 <func0+0x343>\n  mov    0x14(%rsp),%eax\n  mov    0x18(%rsp),%r14\n  lea    0x4(%rbp),%r15\n  sub    $0x1,%eax\n  mov    %r14,%r13\n  lea    0x8(%r14,%rax,8),%rbx\n  nopl   0x0(%rax)\n  mov    (%r14),%rax\n  cmpb   $0x2a,(%rax)\n  jne    134e <func0+0x1ce>\n  cmpb   $0x2a,0x1(%rax)\n  jne    134e <func0+0x1ce>\n  cmpb   $0x0,0x2(%rax)\n  jne    134e <func0+0x1ce>\n  movslq -0x4(%r15),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r8\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     12d9 <func0+0x159>\n  nopw   0x0(%rax,%rax,1)\n  movslq %eax,%rdx\n  mov    %eax,-0x4(%r15)\n  mov    %eax,%ecx\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r8\n  cmp    %ecx,%eax\n  jne    12c0 <func0+0x140>\n  movslq (%r15),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%edx\n  je     1317 <func0+0x197>\n  nop\n  movslq %eax,%rdx\n  mov    %eax,(%r15)\n  mov    %eax,%ecx\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r9\n  cmp    %ecx,%eax\n  jne    12f0 <func0+0x170>\n  movslq -0x4(%r15),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r8\n  add    %r12,%r8\n  pxor   %xmm0,%xmm0\n  pxor   %xmm1,%xmm1\n  mov    %ecx,0x10(%rsp)\n  cvtsi2sdl (%r8),%xmm0\n  mov    %r8,0x8(%rsp)\n  cvtsi2sdl (%r12,%r9,1),%xmm1\n  call   10b0 <pow@plt>\n  mov    0x8(%rsp),%r8\n  mov    0x10(%rsp),%ecx\n  cvttsd2si %xmm0,%edx\n  mov    %ecx,(%r15)\n  mov    %edx,(%r8)\n  add    $0x8,%r14\n  add    $0x4,%r15\n  cmp    %r14,%rbx\n  jne    1280 <func0+0x100>\n  mov    0x14(%rsp),%r14d\n  mov    0x18(%rsp),%rbx\n  mov    %rbp,%rdi\n  mov    %rbp,%rsi\n  lea    0x0(%rbp,%r14,4),%r8\n  nopl   0x0(%rax)\n  mov    (%rbx),%r11\n  movzbl (%r11),%r10d\n  cmp    $0x2a,%r10d\n  jne    1508 <func0+0x388>\n  cmpb   $0x0,0x1(%r11)\n  jne    1508 <func0+0x388>\n  movslq (%rsi),%rax\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     13b7 <func0+0x237>\n  nopw   0x0(%rax,%rax,1)\n  cltq\n  mov    %eax,(%rsi)\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %ecx,%eax\n  jne    13a8 <func0+0x228>\n  movslq 0x4(%rsi),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r14\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     13ea <func0+0x26a>\n  xchg   %ax,%ax\n  movslq %eax,%rdx\n  mov    %eax,0x4(%rsi)\n  mov    %eax,%r9d\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r14\n  cmp    %r9d,%eax\n  jne    13d0 <func0+0x250>\n  sub    $0x2a,%r10d\n  jne    13f5 <func0+0x275>\n  movzbl 0x1(%r11),%r10d\n  add    %r12,%r14\n  movslq %ecx,%rax\n  test   %r10d,%r10d\n  jne    1540 <func0+0x3c0>\n  lea    (%r12,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   (%r14),%eax\n  mov    %eax,(%rdx)\n  mov    %ecx,0x4(%rsi)\n  add    $0x4,%rsi\n  add    $0x8,%rbx\n  cmp    %rsi,%r8\n  jne    1378 <func0+0x1f8>\n  nopl   0x0(%rax)\n  mov    0x0(%r13),%rax\n  movzbl (%rax),%r10d\n  cmp    $0x2b,%r10d\n  jne    14f0 <func0+0x370>\n  cmpb   $0x0,0x1(%rax)\n  jne    14f0 <func0+0x370>\n  movslq (%rdi),%rax\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     1467 <func0+0x2e7>\n  nopw   0x0(%rax,%rax,1)\n  cltq\n  mov    %eax,(%rdi)\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    1458 <func0+0x2d8>\n  movslq 0x4(%rdi),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     1498 <func0+0x318>\n  xchg   %ax,%ax\n  movslq %eax,%rcx\n  mov    %eax,0x4(%rdi)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    1480 <func0+0x300>\n  add    %r12,%r9\n  movslq %edx,%rax\n  mov    (%r9),%ecx\n  cmp    $0x2b,%r10d\n  jne    1530 <func0+0x3b0>\n  add    %ecx,(%r12,%rax,4)\n  mov    %edx,0x4(%rdi)\n  add    $0x4,%rdi\n  add    $0x8,%r13\n  cmp    %rdi,%r8\n  jne    1428 <func0+0x2a8>\n  mov    %r12,%rdi\n  mov    (%r12),%r13d\n  call   1080 <free@plt>\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  add    $0x28,%rsp\n  mov    %r13d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  cmp    $0x2d,%r10d\n  jne    14b2 <func0+0x332>\n  cmpb   $0x0,0x1(%rax)\n  je     1444 <func0+0x2c4>\n  jmp    14b2 <func0+0x332>\n  nopw   0x0(%rax,%rax,1)\n  cmpb   $0x2f,(%r11)\n  jne    1413 <func0+0x293>\n  cmpb   $0x2f,0x1(%r11)\n  jne    1413 <func0+0x293>\n  cmpb   $0x0,0x2(%r11)\n  je     1394 <func0+0x214>\n  jmp    1413 <func0+0x293>\n  nopl   (%rax)\n  sub    %ecx,(%r12,%rax,4)\n  jmp    14af <func0+0x32f>\n  nopl   0x0(%rax)\n  lea    (%r12,%rax,4),%r9\n  mov    (%r9),%eax\n  cltd\n  idivl  (%r14)\n  mov    %eax,(%r9)\n  jmp    1410 <func0+0x290>\n  xor    %eax,%eax\n  jmp    1231 <func0+0xb1>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rsi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %ecx,%rbp\n  push   %rbx\n  mov    %rbp,%r13\n  shl    $0x2,%rbp\n  sub    $0x28,%rsp\n  mov    %rdi,0x18(%rsp)\n  mov    %rbp,%rdi\n  mov    %edx,0x14(%rsp)\n  call   <malloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r12\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %r13d,%r13d\n  jle    L0\n  mov    %r13d,%edx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  shl    $0x2,%rdx\n  call   <memcpy@plt>\n  lea    -0x1(%r13),%eax\n  cmp    $0x2,%eax\n  jbe    L1\n  mov    %r13d,%edx\n  movdqa D0(%rip),%xmm0\n  movdqa D1(%rip),%xmm2\n  mov    %rbp,%rax\n  shr    $0x2,%edx\n  shl    $0x4,%rdx\n  add    %rbp,%rdx\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  movdqa %xmm0,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm2,%xmm0\n  movups %xmm1,-0x10(%rax)\n  cmp    %rax,%rdx\n  jne    L2\n  mov    %r13d,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%r13b\n  je     L0\nL31:\n  movslq %eax,%rdx\n  mov    %eax,0x0(%rbp,%rdx,4)\n  lea    0x0(,%rdx,4),%rcx\n  lea    0x1(%rax),%edx\n  cmp    %edx,%r13d\n  jle    L0\n  add    $0x2,%eax\n  mov    %edx,0x4(%rbp,%rcx,1)\n  cmp    %eax,%r13d\n  jle    L0\n  mov    %eax,0x8(%rbp,%rcx,1)\nL0:\n  mov    0x14(%rsp),%eax\n  test   %eax,%eax\n  jle    L3\n  mov    0x14(%rsp),%eax\n  mov    0x18(%rsp),%r14\n  lea    0x4(%rbp),%r15\n  sub    $0x1,%eax\n  mov    %r14,%r13\n  lea    0x8(%r14,%rax,8),%rbx\n  nopl   0x0(%rax)\nL9:\n  mov    (%r14),%rax\n  cmpb   $0x2a,(%rax)\n  jne    L4\n  cmpb   $0x2a,0x1(%rax)\n  jne    L4\n  cmpb   $0x0,0x2(%rax)\n  jne    L4\n  movslq -0x4(%r15),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r8\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L5\n  nopw   0x0(%rax,%rax,1)\nL6:\n  movslq %eax,%rdx\n  mov    %eax,-0x4(%r15)\n  mov    %eax,%ecx\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r8\n  cmp    %ecx,%eax\n  jne    L6\nL5:\n  movslq (%r15),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L7\n  nop\nL8:\n  movslq %eax,%rdx\n  mov    %eax,(%r15)\n  mov    %eax,%ecx\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r9\n  cmp    %ecx,%eax\n  jne    L8\n  movslq -0x4(%r15),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r8\nL7:\n  add    %r12,%r8\n  pxor   %xmm0,%xmm0\n  pxor   %xmm1,%xmm1\n  mov    %ecx,0x10(%rsp)\n  cvtsi2sdl (%r8),%xmm0\n  mov    %r8,0x8(%rsp)\n  cvtsi2sdl (%r12,%r9,1),%xmm1\n  call   <pow@plt>\n  mov    0x8(%rsp),%r8\n  mov    0x10(%rsp),%ecx\n  cvttsd2si %xmm0,%edx\n  mov    %ecx,(%r15)\n  mov    %edx,(%r8)\nL4:\n  add    $0x8,%r14\n  add    $0x4,%r15\n  cmp    %r14,%rbx\n  jne    L9\n  mov    0x14(%rsp),%r14d\n  mov    0x18(%rsp),%rbx\n  mov    %rbp,%rdi\n  mov    %rbp,%rsi\n  lea    0x0(%rbp,%r14,4),%r8\n  nopl   0x0(%rax)\nL17:\n  mov    (%rbx),%r11\n  movzbl (%r11),%r10d\n  cmp    $0x2a,%r10d\n  jne    L10\n  cmpb   $0x0,0x1(%r11)\n  jne    L10\nL28:\n  movslq (%rsi),%rax\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L11\n  nopw   0x0(%rax,%rax,1)\nL12:\n  cltq\n  mov    %eax,(%rsi)\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %ecx,%eax\n  jne    L12\nL11:\n  movslq 0x4(%rsi),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r14\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     L13\n  xchg   %ax,%ax\nL14:\n  movslq %eax,%rdx\n  mov    %eax,0x4(%rsi)\n  mov    %eax,%r9d\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r14\n  cmp    %r9d,%eax\n  jne    L14\nL13:\n  sub    $0x2a,%r10d\n  jne    L15\n  movzbl 0x1(%r11),%r10d\nL15:\n  add    %r12,%r14\n  movslq %ecx,%rax\n  test   %r10d,%r10d\n  jne    L16\n  lea    (%r12,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   (%r14),%eax\n  mov    %eax,(%rdx)\nL30:\n  mov    %ecx,0x4(%rsi)\nL27:\n  add    $0x4,%rsi\n  add    $0x8,%rbx\n  cmp    %rsi,%r8\n  jne    L17\n  nopl   0x0(%rax)\nL24:\n  mov    0x0(%r13),%rax\n  movzbl (%rax),%r10d\n  cmp    $0x2b,%r10d\n  jne    L18\n  cmpb   $0x0,0x1(%rax)\n  jne    L18\nL26:\n  movslq (%rdi),%rax\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     L19\n  nopw   0x0(%rax,%rax,1)\nL20:\n  cltq\n  mov    %eax,(%rdi)\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    L20\nL19:\n  movslq 0x4(%rdi),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L21\n  xchg   %ax,%ax\nL22:\n  movslq %eax,%rcx\n  mov    %eax,0x4(%rdi)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    L22\nL21:\n  add    %r12,%r9\n  movslq %edx,%rax\n  mov    (%r9),%ecx\n  cmp    $0x2b,%r10d\n  jne    L23\n  add    %ecx,(%r12,%rax,4)\nL29:\n  mov    %edx,0x4(%rdi)\nL25:\n  add    $0x4,%rdi\n  add    $0x8,%r13\n  cmp    %rdi,%r8\n  jne    L24\nL3:\n  mov    %r12,%rdi\n  mov    (%r12),%r13d\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  add    $0x28,%rsp\n  mov    %r13d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL18:\n  cmp    $0x2d,%r10d\n  jne    L25\n  cmpb   $0x0,0x1(%rax)\n  je     L26\n  jmp    L25\n  nopw   0x0(%rax,%rax,1)\nL10:\n  cmpb   $0x2f,(%r11)\n  jne    L27\n  cmpb   $0x2f,0x1(%r11)\n  jne    L27\n  cmpb   $0x0,0x2(%r11)\n  je     L28\n  jmp    L27\n  nopl   (%rax)\nL23:\n  sub    %ecx,(%r12,%rax,4)\n  jmp    L29\n  nopl   0x0(%rax)\nL16:\n  lea    (%r12,%rax,4),%r9\n  mov    (%r9),%eax\n  cltd\n  idivl  (%r14)\n  mov    %eax,(%r9)\n  jmp    L30\nL1:\n  xor    %eax,%eax\n  jmp    L31",
      "num_missing": 2,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3599
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8208,
          "bias": [
            3607
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4696
        },
        "L1": {
          "label": "L1",
          "addr": 5459
        },
        "L2": {
          "label": "L2",
          "addr": 4624
        },
        "L3": {
          "label": "L3",
          "addr": 5315
        },
        "L4": {
          "label": "L4",
          "addr": 4942
        },
        "L5": {
          "label": "L5",
          "addr": 4825
        },
        "L6": {
          "label": "L6",
          "addr": 4800
        },
        "L7": {
          "label": "L7",
          "addr": 4887
        },
        "L8": {
          "label": "L8",
          "addr": 4848
        },
        "L9": {
          "label": "L9",
          "addr": 4736
        },
        "L10": {
          "label": "L10",
          "addr": 5384
        },
        "L11": {
          "label": "L11",
          "addr": 5047
        },
        "L12": {
          "label": "L12",
          "addr": 5032
        },
        "L13": {
          "label": "L13",
          "addr": 5098
        },
        "L14": {
          "label": "L14",
          "addr": 5072
        },
        "L15": {
          "label": "L15",
          "addr": 5109
        },
        "L16": {
          "label": "L16",
          "addr": 5440
        },
        "L17": {
          "label": "L17",
          "addr": 4984
        },
        "L18": {
          "label": "L18",
          "addr": 5360
        },
        "L19": {
          "label": "L19",
          "addr": 5223
        },
        "L20": {
          "label": "L20",
          "addr": 5208
        },
        "L21": {
          "label": "L21",
          "addr": 5272
        },
        "L22": {
          "label": "L22",
          "addr": 5248
        },
        "L23": {
          "label": "L23",
          "addr": 5424
        },
        "L24": {
          "label": "L24",
          "addr": 5160
        },
        "L25": {
          "label": "L25",
          "addr": 5298
        },
        "L26": {
          "label": "L26",
          "addr": 5188
        },
        "L27": {
          "label": "L27",
          "addr": 5139
        },
        "L28": {
          "label": "L28",
          "addr": 5012
        },
        "L29": {
          "label": "L29",
          "addr": 5295
        },
        "L30": {
          "label": "L30",
          "addr": 5136
        },
        "L31": {
          "label": "L31",
          "addr": 4657
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "0000000001000000020000000300000004000000040000000400000004000000",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "byte[16]",
            "value": [
              0,
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              2,
              0,
              0,
              0,
              3,
              0,
              0,
              0
            ]
          },
          "0x2010": {
            "type": "byte[16]",
            "value": [
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0,
              4,
              0,
              0,
              0
            ]
          }
        }
      },
      "structs": [],
      "run": 0,
      "compile": 1,
      "c_func_decompile": " int func0(char **a, int *b, int c, int d) {\n  int *x = malloc(d * sizeof(int));\n  int *y = malloc(d * sizeof(int));\n  for (int i = 0; i < d; i++)\n    x[i] = b[i];\n  for (int i = 0; i < d; i++)\n    y[i] = i;\n  for (int i = 0; i < c; i++) {\n    if (a[i][0] == '*' && a[i][1] == '*') {\n      while (y[i] != y[y[i]])\n        y[i] = y[y[i]];\n      while (y[i + 1] != y[y[i + 1]])\n        y[i + 1] = y[y[i + 1]];\n      x[y[i]] = pow((double)x[y[i]], (double)x[y[i + 1]]);\n      y[i + 1] = y[i];\n    }\n  }\n  for (int i = 0; i < c; i++) {\n    if (a[i][0] == '*' && a[i][1] == '\\0') {\n      while (y[i] != y[y[i]])\n        y[i] = y[y[i]];\n      while (y[i + 1] != y[y[i + 1]])\n        y[i + 1] = y[y[i + 1]];\n      if (a[i][0] == '*')\n        x[y[i]] *= x[y[i + 1]];\n      else\n        x[y[i]] /= x[y[i + 1]];\n      y[i + 1] = y[i];\n    }\n  }\n  for (int i = 0; i < c; i++) {\n    if (a[i][0] == '+' && a[i][1] == '\\0') {\n      while (y[i] != y[y[i]])\n        y[i] = y[y[i]];\n      while (y[i + 1] != y[y[i + 1]])\n        y[i + 1] = y[y[i + 1]];\n      if (a[i][0] == '+')\n        x[y[i]] += x[y[i + 1]];\n      else\n        x[y[i]] -= x[y[i + 1]];\n      y[i + 1] = y[i];\n    }\n  }\n  int ret = x[0];\n  free(x);\n  free(y);\n  return ret;\n}"
    },
    {
      "task_id": 160,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
      "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x28(%rsp)\n  mov    %rsi,%r12\n  mov    %edx,%ebp\n  mov    %ecx,%r14d\n  movslq %ecx,%rbx\n  shl    $0x2,%rbx\n  mov    %rbx,%rdi\n  call   10a0 <malloc@plt>\n  mov    %rax,%r13\n  mov    %rbx,%rdi\n  call   10a0 <malloc@plt>\n  mov    %rax,%rbx\n  test   %r14d,%r14d\n  jle    11d7 <func0+0x5e>\n  mov    %r14d,%ecx\n  mov    $0x0,%eax\n  mov    (%r12,%rax,4),%edx\n  mov    %edx,0x0(%r13,%rax,4)\n  mov    %eax,(%rbx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    11c2 <func0+0x49>\n  test   %ebp,%ebp\n  jle    146a <func0+0x2f1>\n  mov    0x28(%rsp),%r15\n  mov    %r15,0x18(%rsp)\n  mov    %rbx,%r14\n  mov    %ebp,%ebp\n  lea    (%rbx,%rbp,4),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %rbx,%r12\n  jmp    1248 <func0+0xcf>\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x10(%rsp)\n  cltq\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rdi,0x20(%rsp)\n  pxor   %xmm0,%xmm0\n  cvtsi2sdl (%rdi),%xmm0\n  pxor   %xmm1,%xmm1\n  cvtsi2sdl 0x0(%r13,%rsi,1),%xmm1\n  call   10b0 <pow@plt>\n  cvttsd2si %xmm0,%eax\n  mov    0x20(%rsp),%rdi\n  mov    %eax,(%rdi)\n  mov    0x10(%rsp),%eax\n  mov    %eax,0x4(%rbp)\n  add    $0x8,%r15\n  add    $0x4,%r12\n  cmp    0x8(%rsp),%r12\n  je     12af <func0+0x136>\n  lea    0xdb1(%rip),%rsi        # 2000 <_fini+0xb70>\n  mov    (%r15),%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    1239 <func0+0xc0>\n  mov    %r12,%rbp\n  mov    (%r12),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     127a <func0+0x101>\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    126c <func0+0xf3>\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%rsi\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     11fc <func0+0x83>\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    1293 <func0+0x11a>\n  jmp    11fc <func0+0x83>\n  mov    %rbx,%r15\n  mov    0x28(%rsp),%rax\n  mov    %rax,0x20(%rsp)\n  jmp    134e <func0+0x1d5>\n  mov    %r15,%rbp\n  mov    (%r15),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     12df <func0+0x166>\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    12d1 <func0+0x158>\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%r12\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     130b <func0+0x192>\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%r12\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    12f4 <func0+0x17b>\n  lea    0xcef(%rip),%rsi        # 2001 <_fini+0xb71>\n  mov    0x10(%rsp),%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    138c <func0+0x213>\n  movslq 0x0(%rbp),%rax\n  lea    0x0(%r13,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   0x0(%r13,%r12,1),%eax\n  mov    %eax,(%rdx)\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x4(%rbp)\n  addq   $0x8,0x20(%rsp)\n  add    $0x4,%r15\n  cmp    0x8(%rsp),%r15\n  je     1423 <func0+0x2aa>\n  mov    0x20(%rsp),%rax\n  mov    (%rax),%rax\n  mov    %rax,0x10(%rsp)\n  lea    0xc9f(%rip),%rsi        # 2001 <_fini+0xb71>\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  je     12c1 <func0+0x148>\n  lea    0xc8a(%rip),%rsi        # 2003 <_fini+0xb73>\n  mov    0x10(%rsp),%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    1339 <func0+0x1c0>\n  jmp    12c1 <func0+0x148>\n  movslq 0x0(%rbp),%rax\n  lea    0x0(%r13,%rax,4),%rcx\n  mov    (%rcx),%eax\n  cltd\n  idivl  0x0(%r13,%r12,1)\n  mov    %eax,(%rcx)\n  jmp    1333 <func0+0x1ba>\n  mov    %r14,%rbp\n  mov    (%r14),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     13bf <func0+0x246>\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    13b1 <func0+0x238>\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%r12\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     13eb <func0+0x272>\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%r12\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    13d4 <func0+0x25b>\n  lea    0xc14(%rip),%rsi        # 2006 <_fini+0xb76>\n  mov    %r15,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    145a <func0+0x2e1>\n  movslq 0x0(%rbp),%rax\n  mov    0x0(%r13,%r12,1),%edx\n  add    %edx,0x0(%r13,%rax,4)\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x4(%rbp)\n  addq   $0x8,0x18(%rsp)\n  add    $0x4,%r14\n  cmp    0x8(%rsp),%r14\n  je     146a <func0+0x2f1>\n  mov    0x18(%rsp),%rax\n  mov    (%rax),%r15\n  lea    0xbd4(%rip),%rsi        # 2006 <_fini+0xb76>\n  mov    %r15,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  je     13a1 <func0+0x228>\n  lea    0xbbf(%rip),%rsi        # 2008 <_fini+0xb78>\n  mov    %r15,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    1412 <func0+0x299>\n  jmp    13a1 <func0+0x228>\n  movslq 0x0(%rbp),%rax\n  mov    0x0(%r13,%r12,1),%edx\n  sub    %edx,0x0(%r13,%rax,4)\n  jmp    140c <func0+0x293>\n  mov    0x0(%r13),%ebp\n  mov    %r13,%rdi\n  call   1080 <free@plt>\n  mov    %rbx,%rdi\n  call   1080 <free@plt>\n  mov    %ebp,%eax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x28(%rsp)\n  mov    %rsi,%r12\n  mov    %edx,%ebp\n  mov    %ecx,%r14d\n  movslq %ecx,%rbx\n  shl    $0x2,%rbx\n  mov    %rbx,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  mov    %rbx,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbx\n  test   %r14d,%r14d\n  jle    L0\n  mov    %r14d,%ecx\n  mov    $0x0,%eax\nL1:\n  mov    (%r12,%rax,4),%edx\n  mov    %edx,0x0(%r13,%rax,4)\n  mov    %eax,(%rbx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    L1\nL0:\n  test   %ebp,%ebp\n  jle    L2\n  mov    0x28(%rsp),%r15\n  mov    %r15,0x18(%rsp)\n  mov    %rbx,%r14\n  mov    %ebp,%ebp\n  lea    (%rbx,%rbp,4),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %rbx,%r12\n  jmp    L3\nL8:\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x10(%rsp)\n  cltq\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rdi,0x20(%rsp)\n  pxor   %xmm0,%xmm0\n  cvtsi2sdl (%rdi),%xmm0\n  pxor   %xmm1,%xmm1\n  cvtsi2sdl 0x0(%r13,%rsi,1),%xmm1\n  call   <pow@plt>\n  cvttsd2si %xmm0,%eax\n  mov    0x20(%rsp),%rdi\n  mov    %eax,(%rdi)\n  mov    0x10(%rsp),%eax\n  mov    %eax,0x4(%rbp)\nL5:\n  add    $0x8,%r15\n  add    $0x4,%r12\n  cmp    0x8(%rsp),%r12\n  je     L4\nL3:\n  lea    D0(%rip),%rsi\n  mov    (%r15),%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L5\n  mov    %r12,%rbp\n  mov    (%r12),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L6\nL7:\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    L7\nL6:\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%rsi\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L8\nL9:\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    L9\n  jmp    L8\nL4:\n  mov    %rbx,%r15\n  mov    0x28(%rsp),%rax\n  mov    %rax,0x20(%rsp)\n  jmp    L10\nL17:\n  mov    %r15,%rbp\n  mov    (%r15),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L11\nL12:\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    L12\nL11:\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%r12\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L13\nL14:\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%r12\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    L14\nL13:\n  lea    D1(%rip),%rsi\n  mov    0x10(%rsp),%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L15\n  movslq 0x0(%rbp),%rax\n  lea    0x0(%r13,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   0x0(%r13,%r12,1),%eax\n  mov    %eax,(%rdx)\nL19:\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x4(%rbp)\nL18:\n  addq   $0x8,0x20(%rsp)\n  add    $0x4,%r15\n  cmp    0x8(%rsp),%r15\n  je     L16\nL10:\n  mov    0x20(%rsp),%rax\n  mov    (%rax),%rax\n  mov    %rax,0x10(%rsp)\n  lea    D1(%rip),%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L17\n  lea    D2(%rip),%rsi\n  mov    0x10(%rsp),%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L18\n  jmp    L17\nL15:\n  movslq 0x0(%rbp),%rax\n  lea    0x0(%r13,%rax,4),%rcx\n  mov    (%rcx),%eax\n  cltd\n  idivl  0x0(%r13,%r12,1)\n  mov    %eax,(%rcx)\n  jmp    L19\nL25:\n  mov    %r14,%rbp\n  mov    (%r14),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L20\nL21:\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    L21\nL20:\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%r12\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L22\nL23:\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%r12\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    L23\nL22:\n  lea    D3(%rip),%rsi\n  mov    %r15,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L24\n  movslq 0x0(%rbp),%rax\n  mov    0x0(%r13,%r12,1),%edx\n  add    %edx,0x0(%r13,%rax,4)\nL27:\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x4(%rbp)\nL26:\n  addq   $0x8,0x18(%rsp)\n  add    $0x4,%r14\n  cmp    0x8(%rsp),%r14\n  je     L2\nL16:\n  mov    0x18(%rsp),%rax\n  mov    (%rax),%r15\n  lea    D3(%rip),%rsi\n  mov    %r15,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L25\n  lea    D4(%rip),%rsi\n  mov    %r15,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L26\n  jmp    L25\nL24:\n  movslq 0x0(%rbp),%rax\n  mov    0x0(%r13,%r12,1),%edx\n  sub    %edx,0x0(%r13,%rax,4)\n  jmp    L27\nL2:\n  mov    0x0(%r13),%ebp\n  mov    %r13,%rdi\n  call   <free@plt>\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %ebp,%eax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
      "num_missing": 0,
      "address_mapping": {
        "D0": {
          "label": "D0",
          "addr": 8192,
          "bias": [
            3505
          ]
        },
        "D1": {
          "label": "D1",
          "addr": 8193,
          "bias": [
            3311,
            3231
          ]
        },
        "D2": {
          "label": "D2",
          "addr": 8195,
          "bias": [
            3210
          ]
        },
        "D3": {
          "label": "D3",
          "addr": 8198,
          "bias": [
            3092,
            3028
          ]
        },
        "D4": {
          "label": "D4",
          "addr": 8200,
          "bias": [
            3007
          ]
        },
        "L0": {
          "label": "L0",
          "addr": 4567
        },
        "L1": {
          "label": "L1",
          "addr": 4546
        },
        "L2": {
          "label": "L2",
          "addr": 5226
        },
        "L3": {
          "label": "L3",
          "addr": 4680
        },
        "L4": {
          "label": "L4",
          "addr": 4783
        },
        "L5": {
          "label": "L5",
          "addr": 4665
        },
        "L6": {
          "label": "L6",
          "addr": 4730
        },
        "L7": {
          "label": "L7",
          "addr": 4716
        },
        "L8": {
          "label": "L8",
          "addr": 4604
        },
        "L9": {
          "label": "L9",
          "addr": 4755
        },
        "L10": {
          "label": "L10",
          "addr": 4942
        },
        "L11": {
          "label": "L11",
          "addr": 4831
        },
        "L12": {
          "label": "L12",
          "addr": 4817
        },
        "L13": {
          "label": "L13",
          "addr": 4875
        },
        "L14": {
          "label": "L14",
          "addr": 4852
        },
        "L15": {
          "label": "L15",
          "addr": 5004
        },
        "L16": {
          "label": "L16",
          "addr": 5155
        },
        "L17": {
          "label": "L17",
          "addr": 4801
        },
        "L18": {
          "label": "L18",
          "addr": 4921
        },
        "L19": {
          "label": "L19",
          "addr": 4915
        },
        "L20": {
          "label": "L20",
          "addr": 5055
        },
        "L21": {
          "label": "L21",
          "addr": 5041
        },
        "L22": {
          "label": "L22",
          "addr": 5099
        },
        "L23": {
          "label": "L23",
          "addr": 5076
        },
        "L24": {
          "label": "L24",
          "addr": 5210
        },
        "L25": {
          "label": "L25",
          "addr": 5025
        },
        "L26": {
          "label": "L26",
          "addr": 5138
        },
        "L27": {
          "label": "L27",
          "addr": 5132
        }
      },
      "rodata_addr": 8192,
      "rodata_data": "2a2a002f2f002b002d00",
      "rodata_parsed": {
        "func0": {
          "0x2000": {
            "type": "string",
            "value": "\"**\""
          },
          "0x2001": {
            "type": "string",
            "value": "\"*\""
          },
          "0x2003": {
            "type": "string",
            "value": "\"//\""
          },
          "0x2006": {
            "type": "string",
            "value": "\"+\""
          },
          "0x2008": {
            "type": "string",
            "value": "\"-\""
          }
        }
      },
      "structs": [],
      "run": 1,
      "compile": 1,
      "c_func_decompile": " int func0(char **a, int *b, int n, int m) {\n  int *c = malloc(m * sizeof(int));\n  int *d = malloc(m * sizeof(int));\n  for (int i = 0; i < m; i++) {\n    c[i] = b[i];\n    d[i] = i;\n  }\n  for (int i = 0; i < n; i++) {\n    if (!strcmp(a[i], \"**\")) {\n      while (d[d[i]] != d[i])\n        d[i] = d[d[i]];\n      while (d[d[i + 1]] != d[i + 1])\n        d[i + 1] = d[d[i + 1]];\n      c[d[i]] = pow((double)c[d[i]], (double)c[d[i + 1]]);\n      d[i + 1] = d[i];\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (!strcmp(a[i], \"*\") || !strcmp(a[i], \"//\")) {\n      while (d[d[i]] != d[i])\n        d[i] = d[d[i]];\n      while (d[d[i + 1]] != d[i + 1])\n        d[i + 1] = d[d[i + 1]];\n      if (!strcmp(a[i], \"*\"))\n        c[d[i]] *= c[d[i + 1]];\n      else\n        c[d[i]] /= c[d[i + 1]];\n      d[i + 1] = d[i];\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    if (!strcmp(a[i], \"+\") || !strcmp(a[i], \"-\")) {\n      while (d[d[i]] != d[i])\n        d[i] = d[d[i]];\n      while (d[d[i + 1]] != d[i + 1])\n        d[i + 1] = d[d[i + 1]];\n      if (!strcmp(a[i], \"+\"))\n        c[d[i]] += c[d[i + 1]];\n      else\n        c[d[i]] -= c[d[i + 1]];\n      d[i + 1] = d[i];\n    }\n  }\n  int ret = c[0];\n  free(c);\n  free(d);\n  return ret;\n}"
    },
    {
      "task_id": 161,
      "type": "O1",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  call   1090 <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    1208 <func0+0x8f>\n  mov    %rax,%r14\n  call   10b0 <__ctype_b_loc@plt>\n  mov    %rax,%r13\n  mov    %r12,%rbx\n  lea    -0x1(%r14),%eax\n  lea    0x1(%r12,%rax,1),%r15\n  mov    $0x0,%r14d\n  jmp    11e0 <func0+0x67>\n  test   $0x2,%ah\n  je     11d7 <func0+0x5e>\n  call   1080 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    (%rsp),%rsi\n  mov    %al,(%rsi)\n  jmp    11d7 <func0+0x5e>\n  add    $0x1,%r14d\n  add    $0x1,%rbx\n  cmp    %r15,%rbx\n  je     120e <func0+0x95>\n  mov    %rbx,(%rsp)\n  movzbl (%rbx),%ebp\n  mov    0x0(%r13),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  je     11d3 <func0+0x5a>\n  test   $0x1,%ah\n  je     11bb <func0+0x42>\n  call   10a0 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    11d7 <func0+0x5e>\n  mov    $0x0,%r14d\n  cmp    %r14d,0x8(%rsp)\n  je     1227 <func0+0xae>\n  mov    %r12,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    0x8(%rsp),%rax\n  mov    %eax,%edi\n  shr    $0x1f,%edi\n  add    %eax,%edi\n  sar    %edi\n  cmp    $0x1,%eax\n  jle    1215 <func0+0x9c>\n  cltq\n  lea    -0x1(%r12,%rax,1),%rdx\n  mov    $0x0,%eax\n  movzbl (%r12,%rax,1),%ecx\n  movzbl (%rdx),%esi\n  mov    %sil,(%r12,%rax,1)\n  mov    %cl,(%rdx)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%edi\n  jg     1246 <func0+0xcd>\n  jmp    1215 <func0+0x9c>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  call   <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r14\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r13\n  mov    %r12,%rbx\n  lea    -0x1(%r14),%eax\n  lea    0x1(%r12,%rax,1),%r15\n  mov    $0x0,%r14d\n  jmp    L1\nL5:\n  test   $0x2,%ah\n  je     L2\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    (%rsp),%rsi\n  mov    %al,(%rsi)\n  jmp    L2\nL4:\n  add    $0x1,%r14d\nL2:\n  add    $0x1,%rbx\n  cmp    %r15,%rbx\n  je     L3\nL1:\n  mov    %rbx,(%rsp)\n  movzbl (%rbx),%ebp\n  mov    0x0(%r13),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  je     L4\n  test   $0x1,%ah\n  je     L5\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    L2\nL0:\n  mov    $0x0,%r14d\nL3:\n  cmp    %r14d,0x8(%rsp)\n  je     L6\nL7:\n  mov    %r12,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL6:\n  mov    0x8(%rsp),%rax\n  mov    %eax,%edi\n  shr    $0x1f,%edi\n  add    %eax,%edi\n  sar    %edi\n  cmp    $0x1,%eax\n  jle    L7\n  cltq\n  lea    -0x1(%r12,%rax,1),%rdx\n  mov    $0x0,%eax\nL8:\n  movzbl (%r12,%rax,1),%ecx\n  movzbl (%rdx),%esi\n  mov    %sil,(%r12,%rax,1)\n  mov    %cl,(%rdx)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%edi\n  jg     L8\n  jmp    L7",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4616
        },
        "L1": {
          "label": "L1",
          "addr": 4576
        },
        "L2": {
          "label": "L2",
          "addr": 4567
        },
        "L3": {
          "label": "L3",
          "addr": 4622
        },
        "L4": {
          "label": "L4",
          "addr": 4563
        },
        "L5": {
          "label": "L5",
          "addr": 4539
        },
        "L6": {
          "label": "L6",
          "addr": 4647
        },
        "L7": {
          "label": "L7",
          "addr": 4629
        },
        "L8": {
          "label": "L8",
          "addr": 4678
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " char *func0(char *a0) {\n  int a1 = strlen(a0);\n  int a2 = 0;\n  int a3 = 0;\n  int a4 = 0;\n  int a5 = 0;\n  int a6 = 0;\n  int a7 = 0;\n  int a8 = 0;\n  int a9 = 0;\n  int a10 = 0;\n  int a11 = 0;\n  int a12 = 0;\n  int a13 = 0;\n  int a14 = 0;\n  int a15 = 0;\n  int a16 = 0;\n  int a17 = 0;\n  int a18 = 0;\n  int a19 = 0;\n  int a20 = 0;\n  int a21 = 0;\n  int a22 = 0;\n  int a23 = 0;\n  int a24 = 0;\n  int a25 = 0;\n  int a26 = 0;\n  int a27 = 0;\n  int a28 = 0;\n  int a29 = 0;\n  int a30 = 0;\n  int a31 = 0;\n  int a32 = 0;\n  int a33 = 0;\n  int a34 = 0;\n  int a35 = 0;\n  int a36 = 0;\n  int a37 = 0;\n  int a38 = 0;\n  int a39 = 0;\n  int a40 = 0;\n  int a41 = 0;\n  int a42 = 0;\n  int a43 = 0;\n  int a44 = 0;\n  int a45 = 0;\n  int a46 = 0;\n  int a47 = 0;\n  int a48 = 0;\n  int a49 = 0;\n  int a50 = 0;\n  int a51 = 0;\n  int a52 = 0;\n  int a53 = 0;\n  int a54 = 0;\n  int a55 = 0;\n  int a56 = 0;\n  int a57 = 0;\n  int a58 = 0;\n  int a59 = 0;\n  int a60 = 0;\n  int a61 = 0;\n  int a62 = 0;\n  int a63 = 0;\n  int a64 = 0;\n  int a65 = 0;\n  int a66 = 0;\n  int a67 = 0;\n  int a68 = 0;\n  int a69 = 0;\n  int a70 = 0;\n  int a71 = 0;\n  int a72 = 0;\n  int a73 = 0;\n  int a74 = 0;\n  int a75 = 0;\n  int a76 = 0;\n  int a77 = 0;\n  int a78 = 0;\n  int a79 = 0;\n  int a80 = 0;\n  int a81 = 0;\n  int a82 = 0;\n  int a83 = 0;\n  int a84 = 0;\n  int a85 = 0;\n  int a86 = 0;\n  int a87 = 0;\n  int a88 = 0;\n  int a89 = 0;\n  int a90 = 0;\n  int a91 = 0;\n  int a92 = 0;\n  int a93 = 0;\n  int a94 = 0;\n  int a95 = 0;\n  int a96 = 0;\n  int a97 = 0;\n  int a98 = 0;\n  int a99 = 0;\n  int a100 = 0;\n  int a101 = 0;\n  int a102 = 0;\n  int a103 = 0;\n  int a104 = 0;\n  int a105 = 0;\n  int a106 = 0;\n  int a107 = 0;\n  int a108 = 0;\n  int a109 = 0;\n  int a110 = 0;\n  int a111 = 0;\n  int a112"
    },
    {
      "task_id": 161,
      "type": "O2",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   1090 <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    1280 <func0+0x100>\n  mov    %rax,%r15\n  mov    %r12,%rbx\n  call   10b0 <__ctype_b_loc@plt>\n  mov    %rax,%r14\n  lea    -0x1(%r15),%eax\n  xor    %r15d,%r15d\n  lea    0x1(%r12,%rax,1),%r13\n  jmp    11e3 <func0+0x63>\n  nopl   0x0(%rax,%rax,1)\n  test   $0x1,%ah\n  je     1220 <func0+0xa0>\n  call   10a0 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     11ff <func0+0x7f>\n  movzbl (%rbx),%ebp\n  mov    (%r14),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  jne    11c8 <func0+0x48>\n  add    $0x1,%rbx\n  add    $0x1,%r15d\n  cmp    %r13,%rbx\n  jne    11e3 <func0+0x63>\n  cmp    %r15d,0x8(%rsp)\n  je     1238 <func0+0xb8>\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  test   $0x2,%ah\n  je     11da <func0+0x5a>\n  call   1080 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    11da <func0+0x5a>\n  nopl   0x0(%rax)\n  mov    0x8(%rsp),%rax\n  mov    %eax,%ecx\n  sar    %ecx\n  je     1206 <func0+0x86>\n  movslq %eax,%r13\n  sub    $0x1,%ecx\n  mov    %r12,%rdx\n  lea    -0x2(%r12,%r13,1),%rdi\n  lea    -0x1(%r12,%r13,1),%rax\n  sub    %rcx,%rdi\n  nopl   0x0(%rax)\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    1260 <func0+0xe0>\n  jmp    1206 <func0+0x86>\n  nopl   0x0(%rax)\n  xor    %r15d,%r15d\n  jmp    11ff <func0+0x7f>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r15\n  mov    %r12,%rbx\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r14\n  lea    -0x1(%r15),%eax\n  xor    %r15d,%r15d\n  lea    0x1(%r12,%rax,1),%r13\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL4:\n  test   $0x1,%ah\n  je     L2\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\nL6:\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L3\nL1:\n  movzbl (%rbx),%ebp\n  mov    (%r14),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  jne    L4\n  add    $0x1,%rbx\n  add    $0x1,%r15d\n  cmp    %r13,%rbx\n  jne    L1\nL3:\n  cmp    %r15d,0x8(%rsp)\n  je     L5\nL7:\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  test   $0x2,%ah\n  je     L6\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    L6\n  nopl   0x0(%rax)\nL5:\n  mov    0x8(%rsp),%rax\n  mov    %eax,%ecx\n  sar    %ecx\n  je     L7\n  movslq %eax,%r13\n  sub    $0x1,%ecx\n  mov    %r12,%rdx\n  lea    -0x2(%r12,%r13,1),%rdi\n  lea    -0x1(%r12,%r13,1),%rax\n  sub    %rcx,%rdi\n  nopl   0x0(%rax)\nL8:\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    L8\n  jmp    L7\n  nopl   0x0(%rax)\nL0:\n  xor    %r15d,%r15d\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4736
        },
        "L1": {
          "label": "L1",
          "addr": 4579
        },
        "L2": {
          "label": "L2",
          "addr": 4640
        },
        "L3": {
          "label": "L3",
          "addr": 4607
        },
        "L4": {
          "label": "L4",
          "addr": 4552
        },
        "L5": {
          "label": "L5",
          "addr": 4664
        },
        "L6": {
          "label": "L6",
          "addr": 4570
        },
        "L7": {
          "label": "L7",
          "addr": 4614
        },
        "L8": {
          "label": "L8",
          "addr": 4704
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " char *func0(char *a0) {\n  int32_t a1;\n  int32_t a2;\n  int32_t a3;\n  int32_t a4;\n  int32_t a5;\n  int32_t a6;\n  int32_t a7;\n  int32_t a8;\n  int32_t a9;\n  int32_t a10;\n  int32_t a11;\n  int32_t a12;\n  int32_t a13;\n  int32_t a14;\n  int32_t a15;\n  int32_t a16;\n  int32_t a17;\n  int32_t a18;\n  int32_t a19;\n  int32_t a20;\n  int32_t a21;\n  int32_t a22;\n  int32_t a23;\n  int32_t a24;\n  int32_t a25;\n  int32_t a26;\n  int32_t a27;\n  int32_t a28;\n  int32_t a29;\n  int32_t a30;\n  int32_t a31;\n  int32_t a32;\n  int32_t a33;\n  int32_t a34;\n  int32_t a35;\n  int32_t a36;\n  int32_t a37;\n  int32_t a38;\n  int32_t a39;\n  int32_t a40;\n  int32_t a41;\n  int32_t a42;\n  int32_t a43;\n  int32_t a44;\n  int32_t a45;\n  int32_t a46;\n  int32_t a47;\n  int32_t a48;\n  int32_t a49;\n  int32_t a50;\n  int32_t a51;\n  int32_t a52;\n  int32_t a53;\n  int32_t a54;\n  int32_t a55;\n  int32_t a56;\n  int32_t a57;\n  int32_t a58;\n  int32_t a59;\n  int32_t a60;\n  int32_t a61;\n  int32_t a62;\n  int32_t a63;\n  int32_t a64;\n  int32_t a65;\n  int32_t a66;\n  int32_t a67;\n  int32_t a68;\n  int32_t a69;\n  int32_t a70;\n  int32_t a71;\n  int32_t a72;\n  int32_t a73;\n  int32_t a74;\n  int32_t a75;\n  int32_t a76;\n  int32_t a77;\n  int32_t a78;\n  int32_t a79;\n  int32_t a80;\n  int32_t a81;\n  int32_t a82;\n  int32_t a83;\n  int32_t a84;\n  int32_t a85;\n  int32_t a86;\n  int32_t a87;\n  int32_t a88;\n  int32_t a89;\n  int32_t a90;\n  int32_t a91;\n  int32_t a92;\n  int32_t a93"
    },
    {
      "task_id": 161,
      "type": "O3",
      "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
      "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
      "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   1090 <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    1280 <func0+0x100>\n  mov    %rax,%r15\n  mov    %r12,%rbx\n  call   10b0 <__ctype_b_loc@plt>\n  mov    %rax,%r14\n  lea    -0x1(%r15),%eax\n  xor    %r15d,%r15d\n  lea    0x1(%r12,%rax,1),%r13\n  jmp    11e3 <func0+0x63>\n  nopl   0x0(%rax,%rax,1)\n  test   $0x1,%ah\n  je     1220 <func0+0xa0>\n  call   10a0 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     11ff <func0+0x7f>\n  movzbl (%rbx),%ebp\n  mov    (%r14),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  jne    11c8 <func0+0x48>\n  add    $0x1,%rbx\n  add    $0x1,%r15d\n  cmp    %rbx,%r13\n  jne    11e3 <func0+0x63>\n  cmp    %r15d,0x8(%rsp)\n  je     1238 <func0+0xb8>\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  test   $0x2,%ah\n  je     11da <func0+0x5a>\n  call   1080 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    11da <func0+0x5a>\n  nopl   0x0(%rax)\n  mov    0x8(%rsp),%rax\n  mov    %eax,%ecx\n  sar    %ecx\n  je     1206 <func0+0x86>\n  movslq %eax,%r13\n  sub    $0x1,%ecx\n  mov    %r12,%rdx\n  lea    -0x2(%r12,%r13,1),%rdi\n  lea    -0x1(%r12,%r13,1),%rax\n  sub    %rcx,%rdi\n  nopl   0x0(%rax)\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    1260 <func0+0xe0>\n  jmp    1206 <func0+0x86>\n  nopl   0x0(%rax)\n  xor    %r15d,%r15d\n  jmp    11ff <func0+0x7f>",
      "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r15\n  mov    %r12,%rbx\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r14\n  lea    -0x1(%r15),%eax\n  xor    %r15d,%r15d\n  lea    0x1(%r12,%rax,1),%r13\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL4:\n  test   $0x1,%ah\n  je     L2\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\nL6:\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     L3\nL1:\n  movzbl (%rbx),%ebp\n  mov    (%r14),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  jne    L4\n  add    $0x1,%rbx\n  add    $0x1,%r15d\n  cmp    %rbx,%r13\n  jne    L1\nL3:\n  cmp    %r15d,0x8(%rsp)\n  je     L5\nL7:\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  test   $0x2,%ah\n  je     L6\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    L6\n  nopl   0x0(%rax)\nL5:\n  mov    0x8(%rsp),%rax\n  mov    %eax,%ecx\n  sar    %ecx\n  je     L7\n  movslq %eax,%r13\n  sub    $0x1,%ecx\n  mov    %r12,%rdx\n  lea    -0x2(%r12,%r13,1),%rdi\n  lea    -0x1(%r12,%r13,1),%rax\n  sub    %rcx,%rdi\n  nopl   0x0(%rax)\nL8:\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    L8\n  jmp    L7\n  nopl   0x0(%rax)\nL0:\n  xor    %r15d,%r15d\n  jmp    L3",
      "num_missing": 0,
      "address_mapping": {
        "L0": {
          "label": "L0",
          "addr": 4736
        },
        "L1": {
          "label": "L1",
          "addr": 4579
        },
        "L2": {
          "label": "L2",
          "addr": 4640
        },
        "L3": {
          "label": "L3",
          "addr": 4607
        },
        "L4": {
          "label": "L4",
          "addr": 4552
        },
        "L5": {
          "label": "L5",
          "addr": 4664
        },
        "L6": {
          "label": "L6",
          "addr": 4570
        },
        "L7": {
          "label": "L7",
          "addr": 4614
        },
        "L8": {
          "label": "L8",
          "addr": 4704
        }
      },
      "rodata_addr": null,
      "rodata_data": null,
      "rodata_parsed": {},
      "structs": [],
      "run": 0,
      "compile": 0,
      "c_func_decompile": " char *func0(char *a0) {\n  int32_t a1;\n  int32_t a2;\n  int32_t a3;\n  int32_t a4;\n  int32_t a5;\n  int32_t a6;\n  int32_t a7;\n  int32_t a8;\n  int32_t a9;\n  int32_t a10;\n  int32_t a11;\n  int32_t a12;\n  int32_t a13;\n  int32_t a14;\n  int32_t a15;\n  int32_t a16;\n  int32_t a17;\n  int32_t a18;\n  int32_t a19;\n  int32_t a20;\n  int32_t a21;\n  int32_t a22;\n  int32_t a23;\n  int32_t a24;\n  int32_t a25;\n  int32_t a26;\n  int32_t a27;\n  int32_t a28;\n  int32_t a29;\n  int32_t a30;\n  int32_t a31;\n  int32_t a32;\n  int32_t a33;\n  int32_t a34;\n  int32_t a35;\n  int32_t a36;\n  int32_t a37;\n  int32_t a38;\n  int32_t a39;\n  int32_t a40;\n  int32_t a41;\n  int32_t a42;\n  int32_t a43;\n  int32_t a44;\n  int32_t a45;\n  int32_t a46;\n  int32_t a47;\n  int32_t a48;\n  int32_t a49;\n  int32_t a50;\n  int32_t a51;\n  int32_t a52;\n  int32_t a53;\n  int32_t a54;\n  int32_t a55;\n  int32_t a56;\n  int32_t a57;\n  int32_t a58;\n  int32_t a59;\n  int32_t a60;\n  int32_t a61;\n  int32_t a62;\n  int32_t a63;\n  int32_t a64;\n  int32_t a65;\n  int32_t a66;\n  int32_t a67;\n  int32_t a68;\n  int32_t a69;\n  int32_t a70;\n  int32_t a71;\n  int32_t a72;\n  int32_t a73;\n  int32_t a74;\n  int32_t a75;\n  int32_t a76;\n  int32_t a77;\n  int32_t a78;\n  int32_t a79;\n  int32_t a80;\n  int32_t a81;\n  int32_t a82;\n  int32_t a83;\n  int32_t a84;\n  int32_t a85;\n  int32_t a86;\n  int32_t a87;\n  int32_t a88;\n  int32_t a89;\n  int32_t a90;\n  int32_t a91;\n  int32_t a92;\n  int32_t a93"
    }
  ]