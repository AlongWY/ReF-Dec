[
    {
        "task_id": 0,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movss  %xmm0,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1181 <func0+0x88>\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    1175 <func0+0x7c>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  subss  %xmm1,%xmm0\n  movss  0xea3(%rip),%xmm1        # 2000 <_fini+0xe70>\n  andps  %xmm0,%xmm1\n  movss  -0x20(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    1171 <func0+0x78>\n  mov    $0x1,%eax\n  jmp    118e <func0+0x95>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1121 <func0+0x28>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1116 <func0+0x1d>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movss  %xmm0,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL5:\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    L1\nL4:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  subss  %xmm1,%xmm0\n  movss  D0(%rip),%xmm1\n  andps  %xmm0,%xmm1\n  movss  -0x20(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    L2\n  mov    $0x1,%eax\n  jmp    L3\nL2:\n  addl   $0x1,-0x4(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    $0x0,%eax\nL3:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3747
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4481
            },
            "L1": {
                "label": "L1",
                "addr": 4469
            },
            "L2": {
                "label": "L2",
                "addr": 4465
            },
            "L3": {
                "label": "L3",
                "addr": 4494
            },
            "L4": {
                "label": "L4",
                "addr": 4385
            },
            "L5": {
                "label": "L5",
                "addr": 4374
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "dword",
                    "value": 2147483647
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 0,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    113c <func0+0x43>\n  mov    %esi,%ecx\n  mov    $0x1,%edx\n  movss  0xef0(%rip),%xmm3        # 2000 <_fini+0xeb0>\n  cmp    %rcx,%rdx\n  je     1142 <func0+0x49>\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  ja     1148 <func0+0x4f>\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     111e <func0+0x25>\n  add    $0x1,%rdx\n  jmp    1110 <func0+0x17>\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%ecx\n  mov    $0x1,%edx\n  movss  D0(%rip),%xmm3\nL4:\n  cmp    %rcx,%rdx\n  je     L1\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\nL3:\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  ja     L2\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L3\n  add    $0x1,%rdx\n  jmp    L4\nL0:\n  mov    $0x0,%eax\n  ret\nL1:\n  mov    $0x0,%eax\n  ret\nL2:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3824
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4412
            },
            "L1": {
                "label": "L1",
                "addr": 4418
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            },
            "L3": {
                "label": "L3",
                "addr": 4382
            },
            "L4": {
                "label": "L4",
                "addr": 4368
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "dword",
                    "value": 2147483647
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 0,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1159 <func0+0x59>\n  movslq %esi,%rcx\n  mov    $0x1,%edx\n  movss  0xee8(%rip),%xmm3        # 2000 <_fini+0xea4>\n  cmp    %rcx,%rdx\n  je     1159 <func0+0x59>\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\n  jmp    1138 <func0+0x38>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1150 <func0+0x50>\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1130 <func0+0x30>\n  mov    $0x1,%eax\n  ret\n  xchg   %ax,%ax\n  add    $0x1,%rdx\n  cmp    %rcx,%rdx\n  jne    111d <func0+0x1d>\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rcx\n  mov    $0x1,%edx\n  movss  D0(%rip),%xmm3\n  cmp    %rcx,%rdx\n  je     L0\nL4:\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L2\nL1:\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L3\n  mov    $0x1,%eax\n  ret\n  xchg   %ax,%ax\nL2:\n  add    $0x1,%rdx\n  cmp    %rcx,%rdx\n  jne    L4\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3816
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4441
            },
            "L1": {
                "label": "L1",
                "addr": 4408
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4400
            },
            "L4": {
                "label": "L4",
                "addr": 4381
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "dword",
                    "value": 2147483647
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 0,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(float numbers[], int size, float threshold) {\n    int i, j;\n\n    for (i = 0; i < size; i++)\n        for (j = i + 1; j < size; j++)\n            if (fabs(numbers[i] - numbers[j]) < threshold)\n                return 1;\n\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main(){\n    float a[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    assert(func0(a, 6, 0.3) == 1);\n    assert(func0(a, 6, 0.05) == 0);\n\n    float b[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    assert(func0(b, 5, 0.95) == 1);\n    assert(func0(b, 5, 0.8) == 0);\n    \n    float c[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(func0(c, 5, 2.0) == 1);\n\n    float d[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    assert(func0(d, 5, 1.0) == 1);\n    assert(func0(d, 5, 0.5) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1159 <func0+0x59>\n  movslq %esi,%rcx\n  mov    $0x1,%edx\n  movss  0xee8(%rip),%xmm3        # 2000 <_fini+0xea4>\n  cmp    %rdx,%rcx\n  je     1159 <func0+0x59>\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\n  jmp    1138 <func0+0x38>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1150 <func0+0x50>\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1130 <func0+0x30>\n  mov    $0x1,%eax\n  ret\n  xchg   %ax,%ax\n  add    $0x1,%rdx\n  cmp    %rdx,%rcx\n  jne    111d <func0+0x1d>\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rcx\n  mov    $0x1,%edx\n  movss  D0(%rip),%xmm3\n  cmp    %rdx,%rcx\n  je     L0\nL4:\n  movss  -0x4(%rdi,%rdx,4),%xmm2\n  mov    %rdx,%rax\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L2\nL1:\n  movaps %xmm2,%xmm1\n  subss  (%rdi,%rax,4),%xmm1\n  andps  %xmm3,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L3\n  mov    $0x1,%eax\n  ret\n  xchg   %ax,%ax\nL2:\n  add    $0x1,%rdx\n  cmp    %rdx,%rcx\n  jne    L4\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3816
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4441
            },
            "L1": {
                "label": "L1",
                "addr": 4408
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4400
            },
            "L4": {
                "label": "L4",
                "addr": 4381
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "dword",
                    "value": 2147483647
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 1,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,-0x24(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movl   $0xa,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x24(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  mov    -0x50(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x28(%rbp)\n  jmp    12f8 <func0+0x15f>\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x35(%rbp)\n  cmpb   $0x28,-0x35(%rbp)\n  jne    124c <func0+0xb3>\n  addl   $0x1,-0x34(%rbp)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x35(%rbp),%eax\n  mov    %al,(%rdx)\n  jmp    12f4 <func0+0x15b>\n  cmpb   $0x29,-0x35(%rbp)\n  jne    12f4 <func0+0x15b>\n  subl   $0x1,-0x34(%rbp)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x35(%rbp),%eax\n  mov    %al,(%rdx)\n  cmpl   $0x0,-0x34(%rbp)\n  jne    12f4 <func0+0x15b>\n  mov    -0x2c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strdup@plt>\n  mov    %rax,(%rbx)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x50(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x30(%rbp)\n  jg     12ed <func0+0x154>\n  shll   -0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10c0 <realloc@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  addl   $0x1,-0x28(%rbp)\n  mov    -0x28(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     1211 <func0+0x78>\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x24(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movl   $0xa,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x24(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  mov    -0x50(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x28(%rbp)\n  jmp    L0\nL4:\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x35(%rbp)\n  cmpb   $0x28,-0x35(%rbp)\n  jne    L1\n  addl   $0x1,-0x34(%rbp)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x35(%rbp),%eax\n  mov    %al,(%rdx)\n  jmp    L2\nL1:\n  cmpb   $0x29,-0x35(%rbp)\n  jne    L2\n  subl   $0x1,-0x34(%rbp)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x35(%rbp),%eax\n  mov    %al,(%rdx)\n  cmpl   $0x0,-0x34(%rbp)\n  jne    L2\n  mov    -0x2c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,(%rbx)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x50(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x50(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x30(%rbp)\n  jg     L3\n  shll   -0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x20(%rbp)\nL3:\n  movl   $0x0,-0x2c(%rbp)\nL2:\n  addl   $0x1,-0x28(%rbp)\nL0:\n  mov    -0x28(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     L4\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4856
            },
            "L1": {
                "label": "L1",
                "addr": 4684
            },
            "L2": {
                "label": "L2",
                "addr": 4852
            },
            "L3": {
                "label": "L3",
                "addr": 4845
            },
            "L4": {
                "label": "L4",
                "addr": 4625
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 1,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r13\n  mov    %rsi,%r14\n  call   10a0 <strlen@plt>\n  mov    %rax,%rbp\n  mov    $0x50,%edi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r15\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r12\n  movl   $0x0,(%r14)\n  test   %ebp,%ebp\n  jle    1288 <func0+0xef>\n  mov    %r13,%rbx\n  lea    -0x1(%rbp),%eax\n  lea    0x1(%r13,%rax,1),%r13\n  mov    $0x0,%edx\n  movl   $0xa,0x4(%rsp)\n  mov    $0x0,%ebp\n  jmp    1219 <func0+0x80>\n  add    $0x1,%ebp\n  movslq %edx,%rax\n  movb   $0x28,(%r12,%rax,1)\n  lea    0x1(%rdx),%edx\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     1288 <func0+0xef>\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  je     1202 <func0+0x69>\n  cmp    $0x29,%al\n  jne    1210 <func0+0x77>\n  lea    0x1(%rdx),%eax\n  movslq %edx,%rdx\n  movb   $0x29,(%r12,%rdx,1)\n  mov    %eax,%edx\n  sub    $0x1,%ebp\n  jne    1210 <func0+0x77>\n  cltq\n  movb   $0x0,(%r12,%rax,1)\n  movslq (%r14),%rax\n  lea    (%r15,%rax,8),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %r12,%rdi\n  call   10d0 <strdup@plt>\n  mov    0x8(%rsp),%rcx\n  mov    %rax,(%rcx)\n  mov    (%r14),%eax\n  add    $0x1,%eax\n  mov    %eax,(%r14)\n  mov    %ebp,%edx\n  cmp    0x4(%rsp),%eax\n  jl     1210 <func0+0x77>\n  shll   0x4(%rsp)\n  mov    0x4(%rsp),%eax\n  movslq %eax,%rsi\n  shl    $0x3,%rsi\n  mov    %r15,%rdi\n  call   10c0 <realloc@plt>\n  mov    %rax,%r15\n  mov    %ebp,%edx\n  jmp    1210 <func0+0x77>\n  mov    %r12,%rdi\n  call   1090 <free@plt>\n  mov    %r15,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r13\n  mov    %rsi,%r14\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  mov    $0x50,%edi\n  call   <malloc@plt>\n  mov    %rax,%r15\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r12\n  movl   $0x0,(%r14)\n  test   %ebp,%ebp\n  jle    L0\n  mov    %r13,%rbx\n  lea    -0x1(%rbp),%eax\n  lea    0x1(%r13,%rax,1),%r13\n  mov    $0x0,%edx\n  movl   $0xa,0x4(%rsp)\n  mov    $0x0,%ebp\n  jmp    L1\nL2:\n  add    $0x1,%ebp\n  movslq %edx,%rax\n  movb   $0x28,(%r12,%rax,1)\n  lea    0x1(%rdx),%edx\nL3:\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  je     L2\n  cmp    $0x29,%al\n  jne    L3\n  lea    0x1(%rdx),%eax\n  movslq %edx,%rdx\n  movb   $0x29,(%r12,%rdx,1)\n  mov    %eax,%edx\n  sub    $0x1,%ebp\n  jne    L3\n  cltq\n  movb   $0x0,(%r12,%rax,1)\n  movslq (%r14),%rax\n  lea    (%r15,%rax,8),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %r12,%rdi\n  call   <strdup@plt>\n  mov    0x8(%rsp),%rcx\n  mov    %rax,(%rcx)\n  mov    (%r14),%eax\n  add    $0x1,%eax\n  mov    %eax,(%r14)\n  mov    %ebp,%edx\n  cmp    0x4(%rsp),%eax\n  jl     L3\n  shll   0x4(%rsp)\n  mov    0x4(%rsp),%eax\n  movslq %eax,%rsi\n  shl    $0x3,%rsi\n  mov    %r15,%rdi\n  call   <realloc@plt>\n  mov    %rax,%r15\n  mov    %ebp,%edx\n  jmp    L3\nL0:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    %r15,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4744
            },
            "L1": {
                "label": "L1",
                "addr": 4633
            },
            "L2": {
                "label": "L2",
                "addr": 4610
            },
            "L3": {
                "label": "L3",
                "addr": 4624
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 1,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   10a0 <strlen@plt>\n  mov    $0x50,%edi\n  mov    %rax,%rbp\n  call   10b0 <malloc@plt>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r14\n  call   10b0 <malloc@plt>\n  mov    (%rsp),%rdx\n  mov    %rax,%r15\n  movl   $0x0,(%rdx)\n  test   %ebp,%ebp\n  jle    122c <func0+0x8c>\n  lea    -0x1(%rbp),%eax\n  mov    $0xa,%ecx\n  xor    %ebp,%ebp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%r13\n  jmp    120d <func0+0x6d>\n  xchg   %ax,%ax\n  cmp    $0x29,%al\n  je     1250 <func0+0xb0>\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     122c <func0+0x8c>\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  jne    1200 <func0+0x60>\n  movslq %ebp,%rax\n  add    $0x1,%rbx\n  add    $0x1,%r12d\n  add    $0x1,%ebp\n  movb   $0x28,(%r15,%rax,1)\n  cmp    %r13,%rbx\n  jne    120d <func0+0x6d>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  movb   $0x29,(%r15,%rax,1)\n  sub    $0x1,%r12d\n  jne    1204 <func0+0x64>\n  movslq (%rdx),%rax\n  movslq %ebp,%rbp\n  mov    %r15,%rdi\n  mov    %ecx,0x8(%rsp)\n  movb   $0x0,(%r15,%rbp,1)\n  mov    %rdx,(%rsp)\n  lea    (%r14,%rax,8),%rbp\n  call   10d0 <strdup@plt>\n  mov    (%rsp),%rdx\n  mov    0x8(%rsp),%ecx\n  mov    %rax,0x0(%rbp)\n  xor    %ebp,%ebp\n  mov    (%rdx),%eax\n  add    $0x1,%eax\n  mov    %eax,(%rdx)\n  cmp    %ecx,%eax\n  jl     1204 <func0+0x64>\n  add    %ecx,%ecx\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  movslq %ecx,%rsi\n  mov    %ecx,(%rsp)\n  shl    $0x3,%rsi\n  call   10c0 <realloc@plt>\n  mov    0x8(%rsp),%rdx\n  mov    (%rsp),%ecx\n  mov    %rax,%r14\n  jmp    1204 <func0+0x64>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   <strlen@plt>\n  mov    $0x50,%edi\n  mov    %rax,%rbp\n  call   <malloc@plt>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r14\n  call   <malloc@plt>\n  mov    (%rsp),%rdx\n  mov    %rax,%r15\n  movl   $0x0,(%rdx)\n  test   %ebp,%ebp\n  jle    L0\n  lea    -0x1(%rbp),%eax\n  mov    $0xa,%ecx\n  xor    %ebp,%ebp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%r13\n  jmp    L1\n  xchg   %ax,%ax\nL3:\n  cmp    $0x29,%al\n  je     L2\nL4:\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  jne    L3\n  movslq %ebp,%rax\n  add    $0x1,%rbx\n  add    $0x1,%r12d\n  add    $0x1,%ebp\n  movb   $0x28,(%r15,%rax,1)\n  cmp    %r13,%rbx\n  jne    L1\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  movb   $0x29,(%r15,%rax,1)\n  sub    $0x1,%r12d\n  jne    L4\n  movslq (%rdx),%rax\n  movslq %ebp,%rbp\n  mov    %r15,%rdi\n  mov    %ecx,0x8(%rsp)\n  movb   $0x0,(%r15,%rbp,1)\n  mov    %rdx,(%rsp)\n  lea    (%r14,%rax,8),%rbp\n  call   <strdup@plt>\n  mov    (%rsp),%rdx\n  mov    0x8(%rsp),%ecx\n  mov    %rax,0x0(%rbp)\n  xor    %ebp,%ebp\n  mov    (%rdx),%eax\n  add    $0x1,%eax\n  mov    %eax,(%rdx)\n  cmp    %ecx,%eax\n  jl     L4\n  add    %ecx,%ecx\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  movslq %ecx,%rsi\n  mov    %ecx,(%rsp)\n  shl    $0x3,%rsi\n  call   <realloc@plt>\n  mov    0x8(%rsp),%rdx\n  mov    (%rsp),%ecx\n  mov    %rax,%r14\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4652
            },
            "L1": {
                "label": "L1",
                "addr": 4621
            },
            "L2": {
                "label": "L2",
                "addr": 4688
            },
            "L3": {
                "label": "L3",
                "addr": 4608
            },
            "L4": {
                "label": "L4",
                "addr": 4612
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 1,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* paren_string, int* group_count) {\n    int length = strlen(paren_string);\n    int level = 0;\n    int capacity = 10;\n    char** groups = malloc(capacity * sizeof(char*));\n    char* buffer = malloc(length + 1);\n    int buffer_index = 0;\n    *group_count = 0;\n\n    for (int i = 0; i < length; ++i) {\n        char chr = paren_string[i];\n        if (chr == '(') {\n            level++;\n            buffer[buffer_index++] = chr;\n        } else if (chr == ')') {\n            level--;\n            buffer[buffer_index++] = chr;\n            if (level == 0) {\n                buffer[buffer_index] = '\\0';\n                groups[*group_count] = strdup(buffer);\n                (*group_count)++;\n                if (*group_count >= capacity) {\n                    capacity *= 2;\n                    groups = realloc(groups, capacity * sizeof(char*));\n                }\n                buffer_index = 0;\n            }\n        }\n    }\n\n    free(buffer);\n    return groups;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char** a, int a_size, const char* b[], int b_size) {\n    if (a_size != b_size) {\n        return 0;\n    }\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nvoid free_groups(char** groups, int size) {\n    for (int i = 0; i < size; i++) {\n        free(groups[i]);\n    }\n    free(groups);\n}\n\nint main() {\n    int group_count;\n    char** result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &group_count);\n    const char* expected1[] = {\"(()())\", \"((()))\", \"()\", \"((())()())\"};\n    assert(issame(result, group_count, expected1, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"() (()) ((())) (((())))\", &group_count);\n    const char* expected2[] = {\"()\", \"(())\", \"((()))\", \"(((())))\"};\n    assert(issame(result, group_count, expected2, 4));\n    free_groups(result, group_count);\n\n    result = func0(\"(()(())((())))\", &group_count);\n    const char* expected3[] = {\"(()(())((())))\"};\n    assert(issame(result, group_count, expected3, 1));\n    free_groups(result, group_count);\n\n    result = func0(\"( ) (( )) (( )( ))\", &group_count);\n    const char* expected4[] = {\"()\", \"(())\", \"(()())\"};\n    assert(issame(result, group_count, expected4, 3));\n    free_groups(result, group_count);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   10a0 <strlen@plt>\n  mov    $0x50,%edi\n  mov    %rax,%rbp\n  call   10b0 <malloc@plt>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r14\n  call   10b0 <malloc@plt>\n  mov    (%rsp),%rdx\n  mov    %rax,%r15\n  movl   $0x0,(%rdx)\n  test   %ebp,%ebp\n  jle    122c <func0+0x8c>\n  lea    -0x1(%rbp),%eax\n  mov    $0xa,%ecx\n  xor    %ebp,%ebp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%r13\n  jmp    120d <func0+0x6d>\n  xchg   %ax,%ax\n  cmp    $0x29,%al\n  je     1250 <func0+0xb0>\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     122c <func0+0x8c>\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  jne    1200 <func0+0x60>\n  movslq %ebp,%rax\n  add    $0x1,%rbx\n  add    $0x1,%r12d\n  add    $0x1,%ebp\n  movb   $0x28,(%r15,%rax,1)\n  cmp    %r13,%rbx\n  jne    120d <func0+0x6d>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  movb   $0x29,(%r15,%rax,1)\n  sub    $0x1,%r12d\n  jne    1204 <func0+0x64>\n  movslq (%rdx),%rax\n  movslq %ebp,%rbp\n  mov    %r15,%rdi\n  mov    %ecx,0x8(%rsp)\n  movb   $0x0,(%r15,%rbp,1)\n  mov    %rdx,(%rsp)\n  lea    (%r14,%rax,8),%rbp\n  call   10d0 <strdup@plt>\n  mov    (%rsp),%rdx\n  mov    0x8(%rsp),%ecx\n  mov    %rax,0x0(%rbp)\n  xor    %ebp,%ebp\n  mov    (%rdx),%eax\n  add    $0x1,%eax\n  mov    %eax,(%rdx)\n  cmp    %ecx,%eax\n  jl     1204 <func0+0x64>\n  add    %ecx,%ecx\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  movslq %ecx,%rsi\n  mov    %ecx,(%rsp)\n  shl    $0x3,%rsi\n  call   10c0 <realloc@plt>\n  mov    0x8(%rsp),%rdx\n  mov    (%rsp),%ecx\n  mov    %rax,%r14\n  jmp    1204 <func0+0x64>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   <strlen@plt>\n  mov    $0x50,%edi\n  mov    %rax,%rbp\n  call   <malloc@plt>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r14\n  call   <malloc@plt>\n  mov    (%rsp),%rdx\n  mov    %rax,%r15\n  movl   $0x0,(%rdx)\n  test   %ebp,%ebp\n  jle    L0\n  lea    -0x1(%rbp),%eax\n  mov    $0xa,%ecx\n  xor    %ebp,%ebp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%r13\n  jmp    L1\n  xchg   %ax,%ax\nL3:\n  cmp    $0x29,%al\n  je     L2\nL4:\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  movzbl (%rbx),%eax\n  cmp    $0x28,%al\n  jne    L3\n  movslq %ebp,%rax\n  add    $0x1,%rbx\n  add    $0x1,%r12d\n  add    $0x1,%ebp\n  movb   $0x28,(%r15,%rax,1)\n  cmp    %r13,%rbx\n  jne    L1\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  movb   $0x29,(%r15,%rax,1)\n  sub    $0x1,%r12d\n  jne    L4\n  movslq (%rdx),%rax\n  movslq %ebp,%rbp\n  mov    %r15,%rdi\n  mov    %ecx,0x8(%rsp)\n  movb   $0x0,(%r15,%rbp,1)\n  mov    %rdx,(%rsp)\n  lea    (%r14,%rax,8),%rbp\n  call   <strdup@plt>\n  mov    (%rsp),%rdx\n  mov    0x8(%rsp),%ecx\n  mov    %rax,0x0(%rbp)\n  xor    %ebp,%ebp\n  mov    (%rdx),%eax\n  add    $0x1,%eax\n  mov    %eax,(%rdx)\n  cmp    %ecx,%eax\n  jl     L4\n  add    %ecx,%ecx\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  movslq %ecx,%rsi\n  mov    %ecx,(%rsp)\n  shl    $0x3,%rsi\n  call   <realloc@plt>\n  mov    0x8(%rsp),%rdx\n  mov    (%rsp),%ecx\n  mov    %rax,%r14\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4652
            },
            "L1": {
                "label": "L1",
                "addr": 4621
            },
            "L2": {
                "label": "L2",
                "addr": 4688
            },
            "L3": {
                "label": "L3",
                "addr": 4608
            },
            "L4": {
                "label": "L4",
                "addr": 4612
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 2,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  movss  -0x4(%rbp),%xmm0\n  subss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  movss  -0x4(%rbp),%xmm0\n  subss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 2,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 2,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 2,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float number) {\n    return number - (int)number;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(func0(3.5f) == 0.5f);\n    assert(fabs(func0(1.33f) - 0.33f) < 1e-4);\n    assert(fabs(func0(123.456f) - 0.456f) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  cvtsi2ss %eax,%xmm1\n  subss  %xmm1,%xmm0\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 3,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1142 <func0+0x49>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jns    113e <func0+0x45>\n  mov    $0x1,%eax\n  jmp    114f <func0+0x56>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1118 <func0+0x1f>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jns    L1\n  mov    $0x1,%eax\n  jmp    L2\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  mov    $0x0,%eax\nL2:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4418
            },
            "L1": {
                "label": "L1",
                "addr": 4414
            },
            "L2": {
                "label": "L2",
                "addr": 4431
            },
            "L3": {
                "label": "L3",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 3,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1131 <func0+0x38>\n  mov    (%rdi),%edx\n  test   %edx,%edx\n  js     1137 <func0+0x3e>\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%eax\n  lea    (%rdi,%rax,4),%rcx\n  cmp    %rcx,%rdi\n  je     112b <func0+0x32>\n  mov    %edx,%eax\n  add    (%rdi),%eax\n  mov    %eax,%edx\n  add    $0x4,%rdi\n  test   %eax,%eax\n  jns    1112 <func0+0x19>\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    (%rdi),%edx\n  test   %edx,%edx\n  js     L1\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%eax\n  lea    (%rdi,%rax,4),%rcx\nL3:\n  cmp    %rcx,%rdi\n  je     L2\n  mov    %edx,%eax\n  add    (%rdi),%eax\n  mov    %eax,%edx\n  add    $0x4,%rdi\n  test   %eax,%eax\n  jns    L3\n  mov    $0x1,%eax\n  ret\nL2:\n  mov    $0x0,%eax\n  ret\nL0:\n  mov    $0x0,%eax\n  ret\nL1:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4401
            },
            "L1": {
                "label": "L1",
                "addr": 4407
            },
            "L2": {
                "label": "L2",
                "addr": 4395
            },
            "L3": {
                "label": "L3",
                "addr": 4370
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 3,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    112f <func0+0x2f>\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     1138 <func0+0x38>\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%edx\n  lea    (%rdi,%rdx,4),%rdx\n  jmp    112a <func0+0x2a>\n  nopl   0x0(%rax,%rax,1)\n  add    (%rdi),%eax\n  add    $0x4,%rdi\n  test   %eax,%eax\n  js     1138 <func0+0x38>\n  cmp    %rdx,%rdi\n  jne    1120 <func0+0x20>\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     L1\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%edx\n  lea    (%rdi,%rdx,4),%rdx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    (%rdi),%eax\n  add    $0x4,%rdi\n  test   %eax,%eax\n  js     L1\nL2:\n  cmp    %rdx,%rdi\n  jne    L3\nL0:\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4399
            },
            "L1": {
                "label": "L1",
                "addr": 4408
            },
            "L2": {
                "label": "L2",
                "addr": 4394
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 3,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int operations[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        num += operations[i];\n        if (num < 0) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int case1[] = {};\n    assert(func0(case1, 0) == 0);\n\n    int case2[] = {1, 2, -3, 1, 2, -3};\n    assert(func0(case2, 6) == 0);\n\n    int case3[] = {1, 2, -4, 5, 6};\n    assert(func0(case3, 5) == 1);\n\n    int case4[] = {1, -1, 2, -2, 5, -5, 4, -4};\n    assert(func0(case4, 8) == 0);\n\n    int case5[] = {1, -1, 2, -2, 5, -5, 4, -5};\n    assert(func0(case5, 8) == 1);\n\n    int case6[] = {1, -2, 2, -2, 5, -5, 4, -4};\n    assert(func0(case6, 8) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    112f <func0+0x2f>\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     1138 <func0+0x38>\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%edx\n  lea    (%rdi,%rdx,4),%rdx\n  jmp    112a <func0+0x2a>\n  nopl   0x0(%rax,%rax,1)\n  add    (%rdi),%eax\n  add    $0x4,%rdi\n  test   %eax,%eax\n  js     1138 <func0+0x38>\n  cmp    %rdx,%rdi\n  jne    1120 <func0+0x20>\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     L1\n  add    $0x4,%rdi\n  lea    -0x1(%rsi),%edx\n  lea    (%rdi,%rdx,4),%rdx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    (%rdi),%eax\n  add    $0x4,%rdi\n  test   %eax,%eax\n  js     L1\nL2:\n  cmp    %rdx,%rdi\n  jne    L3\nL0:\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4399
            },
            "L1": {
                "label": "L1",
                "addr": 4408
            },
            "L2": {
                "label": "L2",
                "addr": 4394
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 4,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  pxor   %xmm0,%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    114b <func0+0x52>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  -0x10(%rbp),%xmm1\n  addss  %xmm1,%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1121 <func0+0x28>\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x1c(%rbp),%xmm1\n  movss  -0x10(%rbp),%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  pxor   %xmm0,%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    11b6 <func0+0xbd>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  subss  -0x4(%rbp),%xmm0\n  movss  0xe5f(%rip),%xmm1        # 2000 <_fini+0xe2c>\n  andps  %xmm1,%xmm0\n  movss  -0xc(%rbp),%xmm1\n  addss  %xmm1,%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     117c <func0+0x83>\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x1c(%rbp),%xmm1\n  movss  -0xc(%rbp),%xmm0\n  divss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  pxor   %xmm0,%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL1:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  -0x10(%rbp),%xmm1\n  addss  %xmm1,%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L1\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x1c(%rbp),%xmm1\n  movss  -0x10(%rbp),%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  pxor   %xmm0,%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L2\nL3:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  subss  -0x4(%rbp),%xmm0\n  movss  D0(%rip),%xmm1\n  andps  %xmm1,%xmm0\n  movss  -0xc(%rbp),%xmm1\n  addss  %xmm1,%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\nL2:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x1c(%rbp),%xmm1\n  movss  -0xc(%rbp),%xmm0\n  divss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3679
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4427
            },
            "L1": {
                "label": "L1",
                "addr": 4385
            },
            "L2": {
                "label": "L2",
                "addr": 4534
            },
            "L3": {
                "label": "L3",
                "addr": 4476
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "dword",
                    "value": 2147483647
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 4,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1155 <func0+0x5c>\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\n  pxor   %xmm0,%xmm0\n  addss  (%rdi),%xmm0\n  add    $0x4,%rdi\n  cmp    %rdx,%rdi\n  jne    1110 <func0+0x17>\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  divss  %xmm4,%xmm0\n  pxor   %xmm2,%xmm2\n  movss  0xecb(%rip),%xmm3        # 2000 <_fini+0xe9c>\n  movss  (%rax),%xmm1\n  subss  %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  addss  %xmm1,%xmm2\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    1135 <func0+0x3c>\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  pxor   %xmm2,%xmm2\n  jmp    114d <func0+0x54>",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\n  pxor   %xmm0,%xmm0\nL1:\n  addss  (%rdi),%xmm0\n  add    $0x4,%rdi\n  cmp    %rdx,%rdi\n  jne    L1\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  divss  %xmm4,%xmm0\n  pxor   %xmm2,%xmm2\n  movss  D0(%rip),%xmm3\nL2:\n  movss  (%rax),%xmm1\n  subss  %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  addss  %xmm1,%xmm2\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    L2\nL3:\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret\nL0:\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  pxor   %xmm2,%xmm2\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3787
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4437
            },
            "L1": {
                "label": "L1",
                "addr": 4368
            },
            "L2": {
                "label": "L2",
                "addr": 4405
            },
            "L3": {
                "label": "L3",
                "addr": 4429
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "dword",
                    "value": 2147483647
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 4,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  test   %esi,%esi\n  jle    1160 <func0+0x60>\n  lea    -0x1(%rsi),%eax\n  pxor   %xmm0,%xmm0\n  lea    0x4(%rdi,%rax,4),%rdx\n  mov    %rdi,%rax\n  nop\n  addss  (%rax),%xmm0\n  add    $0x4,%rax\n  cmp    %rax,%rdx\n  jne    1120 <func0+0x20>\n  divss  %xmm4,%xmm0\n  pxor   %xmm2,%xmm2\n  movss  0xec3(%rip),%xmm3        # 2000 <_fini+0xe94>\n  nopl   (%rax)\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  subss  %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  addss  %xmm1,%xmm2\n  cmp    %rdi,%rdx\n  jne    1140 <func0+0x40>\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret\n  pxor   %xmm2,%xmm2\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  pxor   %xmm4,%xmm4\n  cvtsi2ss %esi,%xmm4\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  pxor   %xmm0,%xmm0\n  lea    0x4(%rdi,%rax,4),%rdx\n  mov    %rdi,%rax\n  nop\nL1:\n  addss  (%rax),%xmm0\n  add    $0x4,%rax\n  cmp    %rax,%rdx\n  jne    L1\n  divss  %xmm4,%xmm0\n  pxor   %xmm2,%xmm2\n  movss  D0(%rip),%xmm3\n  nopl   (%rax)\nL2:\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  subss  %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  addss  %xmm1,%xmm2\n  cmp    %rdi,%rdx\n  jne    L2\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret\nL0:\n  pxor   %xmm2,%xmm2\n  divss  %xmm4,%xmm2\n  movaps %xmm2,%xmm0\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3779
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4448
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            },
            "L2": {
                "label": "L2",
                "addr": 4416
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "dword",
                    "value": 2147483647
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 4,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float numbers[], int size) {\n    float sum = 0;\n    float avg, msum, mavg;\n    int i = 0;\n\n    for (i = 0; i < size; i++)\n        sum += numbers[i];\n\n    avg = sum / size;\n    msum = 0;\n\n    for (i = 0; i < size; i++)\n        msum += fabs(numbers[i] - avg);\n\n    return msum / size;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint main() {\n    float case1[] = {1.0, 2.0, 3.0};\n    assert(fabs(func0(case1, 3) - 2.0/3.0) < 1e-4);\n\n    float case2[] = {1.0, 2.0, 3.0, 4.0};\n    assert(fabs(func0(case2, 4) - 1.0) < 1e-4);\n\n    float case3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    assert(fabs(func0(case3, 5) - 6.0/5.0) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  pxor   %xmm2,%xmm2\n  mov    %rdi,%rcx\n  mov    %esi,%edx\n  cvtsi2ss %esi,%xmm2\n  test   %esi,%esi\n  jle    1290 <func0+0x190>\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%r8d\n  jbe    12a0 <func0+0x1a0>\n  shr    $0x2,%esi\n  mov    %rdi,%rax\n  pxor   %xmm4,%xmm4\n  sub    $0x1,%esi\n  lea    0x10(%rdi),%rdi\n  movaps %xmm4,%xmm1\n  shl    $0x4,%rsi\n  add    %rdi,%rsi\n  nopw   0x0(%rax,%rax,1)\n  movups (%rax),%xmm0\n  add    $0x10,%rax\n  addss  %xmm0,%xmm1\n  movaps %xmm0,%xmm3\n  shufps $0x55,%xmm0,%xmm3\n  addss  %xmm3,%xmm1\n  movaps %xmm0,%xmm3\n  unpckhps %xmm0,%xmm3\n  shufps $0xff,%xmm0,%xmm0\n  addss  %xmm3,%xmm1\n  addss  %xmm0,%xmm1\n  cmp    %rsi,%rax\n  jne    1148 <func0+0x48>\n  mov    %edx,%eax\n  and    $0xfffffffc,%eax\n  cmp    %eax,%edx\n  je     1280 <func0+0x180>\n  movslq %eax,%rsi\n  addss  (%rcx,%rsi,4),%xmm1\n  lea    0x0(,%rsi,4),%rdi\n  lea    0x1(%rax),%esi\n  cmp    %esi,%edx\n  jle    11ac <func0+0xac>\n  add    $0x2,%eax\n  addss  0x4(%rcx,%rdi,1),%xmm1\n  cmp    %eax,%edx\n  jle    11ac <func0+0xac>\n  addss  0x8(%rcx,%rdi,1),%xmm1\n  movaps %xmm1,%xmm3\n  divss  %xmm2,%xmm3\n  cmp    $0x2,%r8d\n  jbe    1299 <func0+0x199>\n  lea    0x10(%rcx),%rdi\n  mov    %edx,%esi\n  movaps 0xe46(%rip),%xmm5        # 2010 <_fini+0xd60>\n  movaps %xmm3,%xmm6\n  mov    %rcx,%rax\n  shr    $0x2,%esi\n  movaps %xmm4,%xmm0\n  shufps $0x0,%xmm6,%xmm6\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  add    %rdi,%rsi\n  nopl   0x0(%rax)\n  movups (%rax),%xmm1\n  add    $0x10,%rax\n  subps  %xmm6,%xmm1\n  andps  %xmm5,%xmm1\n  addss  %xmm1,%xmm0\n  movaps %xmm1,%xmm4\n  shufps $0x55,%xmm1,%xmm4\n  addss  %xmm0,%xmm4\n  movaps %xmm1,%xmm0\n  unpckhps %xmm1,%xmm0\n  shufps $0xff,%xmm1,%xmm1\n  addss  %xmm4,%xmm0\n  addss  %xmm1,%xmm0\n  cmp    %rax,%rsi\n  jne    11e8 <func0+0xe8>\n  mov    %edx,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%dl\n  je     1278 <func0+0x178>\n  movslq %eax,%rsi\n  movss  0xdd0(%rip),%xmm4        # 2000 <_fini+0xd50>\n  movss  (%rcx,%rsi,4),%xmm1\n  lea    0x0(,%rsi,4),%rdi\n  lea    0x1(%rax),%esi\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\n  cmp    %edx,%esi\n  jge    1278 <func0+0x178>\n  movss  0x4(%rcx,%rdi,1),%xmm1\n  add    $0x2,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\n  cmp    %eax,%edx\n  jle    1278 <func0+0x178>\n  movss  0x8(%rcx,%rdi,1),%xmm1\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\n  divss  %xmm2,%xmm0\n  ret\n  nopl   (%rax)\n  movaps %xmm1,%xmm3\n  divss  %xmm2,%xmm3\n  jmp    11c1 <func0+0xc1>\n  nopl   0x0(%rax)\n  pxor   %xmm0,%xmm0\n  divss  %xmm2,%xmm0\n  ret\n  xor    %eax,%eax\n  movaps %xmm4,%xmm0\n  jmp    1225 <func0+0x125>\n  pxor   %xmm4,%xmm4\n  xor    %eax,%eax\n  movaps %xmm4,%xmm1\n  jmp    1182 <func0+0x82>",
        "asm_labeled": "<func0>:\n  endbr64\n  pxor   %xmm2,%xmm2\n  mov    %rdi,%rcx\n  mov    %esi,%edx\n  cvtsi2ss %esi,%xmm2\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%r8d\n  jbe    L1\n  shr    $0x2,%esi\n  mov    %rdi,%rax\n  pxor   %xmm4,%xmm4\n  sub    $0x1,%esi\n  lea    0x10(%rdi),%rdi\n  movaps %xmm4,%xmm1\n  shl    $0x4,%rsi\n  add    %rdi,%rsi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movups (%rax),%xmm0\n  add    $0x10,%rax\n  addss  %xmm0,%xmm1\n  movaps %xmm0,%xmm3\n  shufps $0x55,%xmm0,%xmm3\n  addss  %xmm3,%xmm1\n  movaps %xmm0,%xmm3\n  unpckhps %xmm0,%xmm3\n  shufps $0xff,%xmm0,%xmm0\n  addss  %xmm3,%xmm1\n  addss  %xmm0,%xmm1\n  cmp    %rsi,%rax\n  jne    L2\n  mov    %edx,%eax\n  and    $0xfffffffc,%eax\n  cmp    %eax,%edx\n  je     L3\nL10:\n  movslq %eax,%rsi\n  addss  (%rcx,%rsi,4),%xmm1\n  lea    0x0(,%rsi,4),%rdi\n  lea    0x1(%rax),%esi\n  cmp    %esi,%edx\n  jle    L4\n  add    $0x2,%eax\n  addss  0x4(%rcx,%rdi,1),%xmm1\n  cmp    %eax,%edx\n  jle    L4\n  addss  0x8(%rcx,%rdi,1),%xmm1\nL4:\n  movaps %xmm1,%xmm3\n  divss  %xmm2,%xmm3\n  cmp    $0x2,%r8d\n  jbe    L5\n  lea    0x10(%rcx),%rdi\nL8:\n  mov    %edx,%esi\n  movaps D0(%rip),%xmm5\n  movaps %xmm3,%xmm6\n  mov    %rcx,%rax\n  shr    $0x2,%esi\n  movaps %xmm4,%xmm0\n  shufps $0x0,%xmm6,%xmm6\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  add    %rdi,%rsi\n  nopl   0x0(%rax)\nL6:\n  movups (%rax),%xmm1\n  add    $0x10,%rax\n  subps  %xmm6,%xmm1\n  andps  %xmm5,%xmm1\n  addss  %xmm1,%xmm0\n  movaps %xmm1,%xmm4\n  shufps $0x55,%xmm1,%xmm4\n  addss  %xmm0,%xmm4\n  movaps %xmm1,%xmm0\n  unpckhps %xmm1,%xmm0\n  shufps $0xff,%xmm1,%xmm1\n  addss  %xmm4,%xmm0\n  addss  %xmm1,%xmm0\n  cmp    %rax,%rsi\n  jne    L6\n  mov    %edx,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%dl\n  je     L7\nL9:\n  movslq %eax,%rsi\n  movss  D1(%rip),%xmm4\n  movss  (%rcx,%rsi,4),%xmm1\n  lea    0x0(,%rsi,4),%rdi\n  lea    0x1(%rax),%esi\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\n  cmp    %edx,%esi\n  jge    L7\n  movss  0x4(%rcx,%rdi,1),%xmm1\n  add    $0x2,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\n  cmp    %eax,%edx\n  jle    L7\n  movss  0x8(%rcx,%rdi,1),%xmm1\n  subss  %xmm3,%xmm1\n  andps  %xmm4,%xmm1\n  addss  %xmm1,%xmm0\nL7:\n  divss  %xmm2,%xmm0\n  ret\n  nopl   (%rax)\nL3:\n  movaps %xmm1,%xmm3\n  divss  %xmm2,%xmm3\n  jmp    L8\n  nopl   0x0(%rax)\nL0:\n  pxor   %xmm0,%xmm0\n  divss  %xmm2,%xmm0\n  ret\nL5:\n  xor    %eax,%eax\n  movaps %xmm4,%xmm0\n  jmp    L9\nL1:\n  pxor   %xmm4,%xmm4\n  xor    %eax,%eax\n  movaps %xmm4,%xmm1\n  jmp    L10",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8208,
                "bias": [
                    3654
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3536
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4752
            },
            "L1": {
                "label": "L1",
                "addr": 4768
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            },
            "L3": {
                "label": "L3",
                "addr": 4736
            },
            "L4": {
                "label": "L4",
                "addr": 4524
            },
            "L5": {
                "label": "L5",
                "addr": 4761
            },
            "L6": {
                "label": "L6",
                "addr": 4584
            },
            "L7": {
                "label": "L7",
                "addr": 4728
            },
            "L8": {
                "label": "L8",
                "addr": 4545
            },
            "L9": {
                "label": "L9",
                "addr": 4645
            },
            "L10": {
                "label": "L10",
                "addr": 4482
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f000000000000000000000000ffffff7fffffff7fffffff7fffffff7f",
        "rodata_parsed": {
            "func0": {
                "0x2010": {
                    "type": "dword[4]",
                    "value": [
                        2147483647,
                        2147483647,
                        2147483647,
                        2147483647
                    ]
                },
                "0x2000": {
                    "type": "dword",
                    "value": 2147483647
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 5,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    1143 <func0+0x2a>\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  lea    -0x1(%rax),%edx\n  jmp    1148 <func0+0x2f>\n  mov    $0x0,%edx\n  mov    -0x28(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    1178 <func0+0x5f>\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,(%rax)\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  jmp    11de <func0+0xc5>\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x20(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1188 <func0+0x6f>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    L0\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  lea    -0x1(%rax),%edx\n  jmp    L1\nL0:\n  mov    $0x0,%edx\nL1:\n  mov    -0x28(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    L2\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,(%rax)\nL2:\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  jmp    L3\nL4:\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x20(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\nL3:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4419
            },
            "L1": {
                "label": "L1",
                "addr": 4424
            },
            "L2": {
                "label": "L2",
                "addr": 4472
            },
            "L3": {
                "label": "L3",
                "addr": 4574
            },
            "L4": {
                "label": "L4",
                "addr": 4488
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 5,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    1169 <func0+0x50>\n  mov    %rdi,%rbx\n  mov    %esi,%r12d\n  mov    %edx,%ebp\n  lea    -0x1(%rsi,%rsi,1),%edi\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    (%rbx),%edx\n  mov    %edx,(%rax)\n  cmp    $0x1,%r12d\n  jle    1164 <func0+0x4b>\n  mov    %r12d,%esi\n  mov    $0x1,%edx\n  mov    %ebp,-0x4(%rax,%rdx,8)\n  mov    (%rbx,%rdx,4),%ecx\n  mov    %ecx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    1151 <func0+0x38>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  movl   $0x0,(%rcx)\n  mov    $0x0,%edi\n  call   1050 <malloc@plt>\n  jmp    1164 <func0+0x4b>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  mov    %esi,%r12d\n  mov    %edx,%ebp\n  lea    -0x1(%rsi,%rsi,1),%edi\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    (%rbx),%edx\n  mov    %edx,(%rax)\n  cmp    $0x1,%r12d\n  jle    L1\n  mov    %r12d,%esi\n  mov    $0x1,%edx\nL2:\n  mov    %ebp,-0x4(%rax,%rdx,8)\n  mov    (%rbx,%rdx,4),%ecx\n  mov    %ecx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    L2\nL1:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL0:\n  movl   $0x0,(%rcx)\n  mov    $0x0,%edi\n  call   <malloc@plt>\n  jmp    L1",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4457
            },
            "L1": {
                "label": "L1",
                "addr": 4452
            },
            "L2": {
                "label": "L2",
                "addr": 4433
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 5,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1180 <func0+0x60>\n  push   %r12\n  mov    %edx,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  lea    -0x1(%rsi,%rsi,1),%edi\n  push   %rbx\n  mov    %esi,%ebx\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    0x0(%rbp),%edx\n  mov    %edx,(%rax)\n  cmp    $0x1,%ebx\n  je     1175 <func0+0x55>\n  movslq %ebx,%rsi\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\n  mov    0x0(%rbp,%rdx,4),%ecx\n  mov    %r12d,-0x4(%rax,%rdx,8)\n  mov    %ecx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    1160 <func0+0x40>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  movl   $0x0,(%rcx)\n  xor    %edi,%edi\n  jmp    1050 <malloc@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %r12\n  mov    %edx,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  lea    -0x1(%rsi,%rsi,1),%edi\n  push   %rbx\n  mov    %esi,%ebx\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    0x0(%rbp),%edx\n  mov    %edx,(%rax)\n  cmp    $0x1,%ebx\n  je     L1\n  movslq %ebx,%rsi\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    0x0(%rbp,%rdx,4),%ecx\n  mov    %r12d,-0x4(%rax,%rdx,8)\n  mov    %ecx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    L2\nL1:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  movl   $0x0,(%rcx)\n  xor    %edi,%edi\n  jmp    1050 <malloc@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4480
            },
            "L1": {
                "label": "L1",
                "addr": 4469
            },
            "L2": {
                "label": "L2",
                "addr": 4448
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 5,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(const int numbers[], int size, int delimiter, int *out_size) {\n    *out_size = size > 0 ? (size * 2) - 1 : 0;\n    int *out = (int *)malloc(*out_size * sizeof(int));\n    if (size > 0) out[0] = numbers[0];\n    for (int i = 1, j = 1; i < size; ++i) {\n        out[j++] = delimiter;\n        out[j++] = numbers[i];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int a[], const int b[], int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n\n    // Test with an empty array\n    int *result_empty = func0((const int[]){}, 0, 7, &out_size);\n    assert(issame(result_empty, (const int[]){}, out_size, 0));\n    free(result_empty);\n\n    // Test with an array with elements\n    int result_expected1[] = {5, 8, 6, 8, 3, 8, 2};\n    int *result1 = func0((const int[]){5, 6, 3, 2}, 4, 8, &out_size);\n    assert(issame(result1, result_expected1, out_size, 7));\n    free(result1);\n\n    // Test with an array with delimiters equal to elements\n    int result_expected2[] = {2, 2, 2, 2, 2};\n    int *result2 = func0((const int[]){2, 2, 2}, 3, 2, &out_size);\n    assert(issame(result2, result_expected2, out_size, 5));\n    free(result2);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1230 <func0+0x110>\n  push   %r12\n  mov    %edx,%r12d\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi,%rsi,1),%edi\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r8\n  mov    (%rbx),%eax\n  mov    %eax,(%r8)\n  cmp    $0x1,%ebp\n  je     1223 <func0+0x103>\n  lea    -0x2(%rbp),%eax\n  lea    -0x1(%rbp),%esi\n  cmp    $0x2,%eax\n  jbe    123d <func0+0x11d>\n  mov    %esi,%ecx\n  movd   %r12d,%xmm4\n  xor    %eax,%eax\n  shr    $0x2,%ecx\n  pshufd $0x0,%xmm4,%xmm0\n  shl    $0x4,%rcx\n  nop\n  movdqu 0x4(%rbx,%rax,1),%xmm2\n  movdqa %xmm0,%xmm1\n  punpckldq %xmm2,%xmm1\n  movups %xmm1,0x4(%r8,%rax,2)\n  movdqa %xmm0,%xmm1\n  punpckhdq %xmm2,%xmm1\n  movups %xmm1,0x14(%r8,%rax,2)\n  add    $0x10,%rax\n  cmp    %rax,%rcx\n  jne    1180 <func0+0x60>\n  mov    %esi,%ecx\n  and    $0xfffffffc,%ecx\n  lea    0x1(%rcx),%eax\n  lea    0x1(%rcx,%rcx,1),%edx\n  cmp    %ecx,%esi\n  je     1223 <func0+0x103>\n  movslq %eax,%rcx\n  movd   %r12d,%xmm0\n  movslq %edx,%rdx\n  lea    0x0(,%rcx,4),%rdi\n  mov    (%rbx,%rcx,4),%ecx\n  lea    0x0(,%rdx,4),%rsi\n  movd   %ecx,%xmm5\n  punpckldq %xmm5,%xmm0\n  movq   %xmm0,(%r8,%rdx,4)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%ebp\n  jle    1223 <func0+0x103>\n  movd   0x4(%rbx,%rdi,1),%xmm6\n  movd   %r12d,%xmm0\n  add    $0x2,%eax\n  punpckldq %xmm6,%xmm0\n  movq   %xmm0,0x8(%r8,%rsi,1)\n  cmp    %eax,%ebp\n  jle    1223 <func0+0x103>\n  mov    0x8(%rbx,%rdi,1),%eax\n  movd   %r12d,%xmm0\n  movd   %eax,%xmm7\n  punpckldq %xmm7,%xmm0\n  movq   %xmm0,0x10(%r8,%rsi,1)\n  pop    %rbx\n  mov    %r8,%rax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\n  movl   $0x0,(%rcx)\n  xor    %edi,%edi\n  jmp    1050 <malloc@plt>\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  jmp    11bb <func0+0x9b>",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %r12\n  mov    %edx,%r12d\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi,%rsi,1),%edi\n  mov    %edi,(%rcx)\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  mov    (%rbx),%eax\n  mov    %eax,(%r8)\n  cmp    $0x1,%ebp\n  je     L1\n  lea    -0x2(%rbp),%eax\n  lea    -0x1(%rbp),%esi\n  cmp    $0x2,%eax\n  jbe    L2\n  mov    %esi,%ecx\n  movd   %r12d,%xmm4\n  xor    %eax,%eax\n  shr    $0x2,%ecx\n  pshufd $0x0,%xmm4,%xmm0\n  shl    $0x4,%rcx\n  nop\nL3:\n  movdqu 0x4(%rbx,%rax,1),%xmm2\n  movdqa %xmm0,%xmm1\n  punpckldq %xmm2,%xmm1\n  movups %xmm1,0x4(%r8,%rax,2)\n  movdqa %xmm0,%xmm1\n  punpckhdq %xmm2,%xmm1\n  movups %xmm1,0x14(%r8,%rax,2)\n  add    $0x10,%rax\n  cmp    %rax,%rcx\n  jne    L3\n  mov    %esi,%ecx\n  and    $0xfffffffc,%ecx\n  lea    0x1(%rcx),%eax\n  lea    0x1(%rcx,%rcx,1),%edx\n  cmp    %ecx,%esi\n  je     L1\nL4:\n  movslq %eax,%rcx\n  movd   %r12d,%xmm0\n  movslq %edx,%rdx\n  lea    0x0(,%rcx,4),%rdi\n  mov    (%rbx,%rcx,4),%ecx\n  lea    0x0(,%rdx,4),%rsi\n  movd   %ecx,%xmm5\n  punpckldq %xmm5,%xmm0\n  movq   %xmm0,(%r8,%rdx,4)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%ebp\n  jle    L1\n  movd   0x4(%rbx,%rdi,1),%xmm6\n  movd   %r12d,%xmm0\n  add    $0x2,%eax\n  punpckldq %xmm6,%xmm0\n  movq   %xmm0,0x8(%r8,%rsi,1)\n  cmp    %eax,%ebp\n  jle    L1\n  mov    0x8(%rbx,%rdi,1),%eax\n  movd   %r12d,%xmm0\n  movd   %eax,%xmm7\n  punpckldq %xmm7,%xmm0\n  movq   %xmm0,0x10(%r8,%rsi,1)\nL1:\n  pop    %rbx\n  mov    %r8,%rax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  movl   $0x0,(%rcx)\n  xor    %edi,%edi\n  jmp    1050 <malloc@plt>\nL2:\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4656
            },
            "L1": {
                "label": "L1",
                "addr": 4643
            },
            "L2": {
                "label": "L2",
                "addr": 4669
            },
            "L3": {
                "label": "L3",
                "addr": 4480
            },
            "L4": {
                "label": "L4",
                "addr": 4539
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 6,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movq   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11e7 <func0+0xce>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x19(%rbp)\n  cmpb   $0x28,-0x19(%rbp)\n  jne    118a <func0+0x71>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    11e3 <func0+0xca>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    11e3 <func0+0xca>\n  cmpb   $0x29,-0x19(%rbp)\n  jne    11e3 <func0+0xca>\n  subl   $0x1,-0x18(%rbp)\n  cmpl   $0x0,-0x18(%rbp)\n  jne    11e3 <func0+0xca>\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1050 <realloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  movl   $0x0,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    115d <func0+0x44>\n  mov    -0x30(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movq   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL3:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x19(%rbp)\n  cmpb   $0x28,-0x19(%rbp)\n  jne    L1\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    L2\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    L2\nL1:\n  cmpb   $0x29,-0x19(%rbp)\n  jne    L2\n  subl   $0x1,-0x18(%rbp)\n  cmpl   $0x0,-0x18(%rbp)\n  jne    L2\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  movl   $0x0,-0x14(%rbp)\nL2:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L3\n  mov    -0x30(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4583
            },
            "L1": {
                "label": "L1",
                "addr": 4490
            },
            "L2": {
                "label": "L2",
                "addr": 4579
            },
            "L3": {
                "label": "L3",
                "addr": 4445
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 6,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rsi,%r13\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     1196 <func0+0x7d>\n  lea    0x1(%rdi),%rbx\n  mov    $0x0,%r14d\n  mov    $0x0,%r12d\n  mov    $0x0,%ebp\n  mov    $0x0,%eax\n  jmp    1167 <func0+0x4e>\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\n  add    $0x1,%rbx\n  movzbl -0x1(%rbx),%edx\n  test   %dl,%dl\n  je     11a1 <func0+0x88>\n  cmp    $0x28,%dl\n  je     1151 <func0+0x38>\n  cmp    $0x29,%dl\n  jne    115b <func0+0x42>\n  sub    $0x1,%ebp\n  jne    115b <func0+0x42>\n  add    $0x1,%r14d\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  call   1050 <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  mov    %ebp,%r12d\n  jmp    115b <func0+0x42>\n  mov    $0x0,%r14d\n  mov    $0x0,%eax\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rsi,%r13\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     L0\n  lea    0x1(%rdi),%rbx\n  mov    $0x0,%r14d\n  mov    $0x0,%r12d\n  mov    $0x0,%ebp\n  mov    $0x0,%eax\n  jmp    L1\nL3:\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\nL4:\n  add    $0x1,%rbx\n  movzbl -0x1(%rbx),%edx\n  test   %dl,%dl\n  je     L2\nL1:\n  cmp    $0x28,%dl\n  je     L3\n  cmp    $0x29,%dl\n  jne    L4\n  sub    $0x1,%ebp\n  jne    L4\n  add    $0x1,%r14d\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  mov    %ebp,%r12d\n  jmp    L4\nL0:\n  mov    $0x0,%r14d\n  mov    $0x0,%eax\nL2:\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4502
            },
            "L1": {
                "label": "L1",
                "addr": 4455
            },
            "L2": {
                "label": "L2",
                "addr": 4513
            },
            "L3": {
                "label": "L3",
                "addr": 4433
            },
            "L4": {
                "label": "L4",
                "addr": 4443
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 6,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     11b8 <func0+0x98>\n  lea    0x1(%rdi),%rbx\n  xor    %r14d,%r14d\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  xor    %eax,%eax\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax)\n  cmp    $0x29,%dl\n  je     1190 <func0+0x70>\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  je     117a <func0+0x5a>\n  cmp    $0x28,%dl\n  jne    1150 <func0+0x30>\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  jne    1160 <func0+0x40>\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\n  sub    $0x1,%ebp\n  jne    1155 <func0+0x35>\n  add    $0x1,%r14d\n  mov    %rax,%rdi\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  call   1050 <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  xor    %r12d,%r12d\n  jmp    1155 <func0+0x35>\n  nopl   (%rax)\n  xor    %r14d,%r14d\n  xor    %eax,%eax\n  jmp    117a <func0+0x5a>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     L0\n  lea    0x1(%rdi),%rbx\n  xor    %r14d,%r14d\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  xor    %eax,%eax\n  jmp    L1\n  nopl   0x0(%rax)\nL4:\n  cmp    $0x29,%dl\n  je     L2\nL5:\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  je     L3\nL1:\n  cmp    $0x28,%dl\n  jne    L4\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  jne    L1\nL3:\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\nL2:\n  sub    $0x1,%ebp\n  jne    L5\n  add    $0x1,%r14d\n  mov    %rax,%rdi\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  call   <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  xor    %r12d,%r12d\n  jmp    L5\n  nopl   (%rax)\nL0:\n  xor    %r14d,%r14d\n  xor    %eax,%eax\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4536
            },
            "L1": {
                "label": "L1",
                "addr": 4448
            },
            "L2": {
                "label": "L2",
                "addr": 4496
            },
            "L3": {
                "label": "L3",
                "addr": 4474
            },
            "L4": {
                "label": "L4",
                "addr": 4432
            },
            "L5": {
                "label": "L5",
                "addr": 4437
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 6,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(const char* paren_string, int* returnSize) {\n    int* all_levels = NULL;\n    int level = 0, max_level = 0, i = 0, count = 0;\n    char chr;\n    for (i = 0; paren_string[i] != '\\0'; i++) {\n        chr = paren_string[i];\n        if (chr == '(') {\n            level += 1;\n            if (level > max_level) max_level = level;\n        } else if (chr == ')') {\n            level -= 1;\n            if (level == 0) {\n                all_levels = (int*)realloc(all_levels, sizeof(int) * (count + 1));\n                all_levels[count++] = max_level;\n                max_level = 0;\n            }\n        }\n    }\n    *returnSize = count;\n    return all_levels;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int* a, const int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int returnSize;\n    int* result;\n\n    result = func0(\"(()()) ((())) () ((())()())\", &returnSize);\n    assert(issame(result, (const int[]){2, 3, 1, 3}, returnSize, 4));\n    free(result);\n\n    result = func0(\"() (()) ((())) (((())))\", &returnSize);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, returnSize, 4));\n    free(result);\n\n    result = func0(\"(()(())((())))\", &returnSize);\n    assert(issame(result, (const int[]){4}, returnSize, 1));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     11b8 <func0+0x98>\n  lea    0x1(%rdi),%rbx\n  xor    %r14d,%r14d\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  xor    %eax,%eax\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax)\n  cmp    $0x29,%dl\n  je     1190 <func0+0x70>\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  je     117a <func0+0x5a>\n  cmp    $0x28,%dl\n  jne    1150 <func0+0x30>\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  jne    1160 <func0+0x40>\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\n  sub    $0x1,%ebp\n  jne    1155 <func0+0x35>\n  add    $0x1,%r14d\n  mov    %rax,%rdi\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  call   1050 <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  xor    %r12d,%r12d\n  jmp    1155 <func0+0x35>\n  nopl   (%rax)\n  xor    %r14d,%r14d\n  xor    %eax,%eax\n  jmp    117a <func0+0x5a>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%edx\n  test   %dl,%dl\n  je     L0\n  lea    0x1(%rdi),%rbx\n  xor    %r14d,%r14d\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  xor    %eax,%eax\n  jmp    L1\n  nopl   0x0(%rax)\nL4:\n  cmp    $0x29,%dl\n  je     L2\nL5:\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  je     L3\nL1:\n  cmp    $0x28,%dl\n  jne    L4\n  add    $0x1,%ebp\n  cmp    %ebp,%r12d\n  cmovl  %ebp,%r12d\n  movzbl (%rbx),%edx\n  add    $0x1,%rbx\n  test   %dl,%dl\n  jne    L1\nL3:\n  mov    %r14d,0x0(%r13)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\nL2:\n  sub    $0x1,%ebp\n  jne    L5\n  add    $0x1,%r14d\n  mov    %rax,%rdi\n  movslq %r14d,%r15\n  shl    $0x2,%r15\n  mov    %r15,%rsi\n  call   <realloc@plt>\n  mov    %r12d,-0x4(%rax,%r15,1)\n  xor    %r12d,%r12d\n  jmp    L5\n  nopl   (%rax)\nL0:\n  xor    %r14d,%r14d\n  xor    %eax,%eax\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4536
            },
            "L1": {
                "label": "L1",
                "addr": 4448
            },
            "L2": {
                "label": "L2",
                "addr": 4496
            },
            "L3": {
                "label": "L3",
                "addr": 4474
            },
            "L4": {
                "label": "L4",
                "addr": 4432
            },
            "L5": {
                "label": "L5",
                "addr": 4437
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 7,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %rcx,-0x30(%rbp)\n  movq   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11f4 <func0+0xbb>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strstr@plt>\n  test   %rax,%rax\n  je     11f0 <func0+0xb7>\n  mov    -0x10(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1060 <realloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     116f <func0+0x36>\n  mov    -0x30(%rbp),%rax\n  mov    -0x10(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %rcx,-0x30(%rbp)\n  movq   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL2:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L1\n  mov    -0x10(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\nL1:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0x30(%rbp),%rax\n  mov    -0x10(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4596
            },
            "L1": {
                "label": "L1",
                "addr": 4592
            },
            "L2": {
                "label": "L2",
                "addr": 4463
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 7,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdx,(%rsp)\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    11ad <func0+0x74>\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r15\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\n  jmp    1179 <func0+0x40>\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  je     11b8 <func0+0x7f>\n  mov    (%rbx),%r13\n  mov    (%rsp),%rsi\n  mov    %r13,%rdi\n  call   1070 <strstr@plt>\n  test   %rax,%rax\n  je     1170 <func0+0x37>\n  add    $0x1,%r14d\n  movslq %r14d,%r12\n  shl    $0x3,%r12\n  mov    %r12,%rsi\n  mov    %rbp,%rdi\n  call   1060 <realloc@plt>\n  mov    %rax,%rbp\n  mov    %r13,-0x8(%rax,%r12,1)\n  jmp    1170 <func0+0x37>\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\n  mov    0x8(%rsp),%rax\n  mov    %r14d,(%rax)\n  mov    %rbp,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdx,(%rsp)\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r15\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\n  jmp    L1\nL3:\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  je     L2\nL1:\n  mov    (%rbx),%r13\n  mov    (%rsp),%rsi\n  mov    %r13,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L3\n  add    $0x1,%r14d\n  movslq %r14d,%r12\n  shl    $0x3,%r12\n  mov    %r12,%rsi\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  mov    %r13,-0x8(%rax,%r12,1)\n  jmp    L3\nL0:\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\nL2:\n  mov    0x8(%rsp),%rax\n  mov    %r14d,(%rax)\n  mov    %rbp,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4525
            },
            "L1": {
                "label": "L1",
                "addr": 4473
            },
            "L2": {
                "label": "L2",
                "addr": 4536
            },
            "L3": {
                "label": "L3",
                "addr": 4464
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 7,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    11d8 <func0+0x98>\n  lea    -0x1(%rsi),%eax\n  mov    %rdx,%r13\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%rax\n  xor    %ebp,%ebp\n  mov    %rax,(%rsp)\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx),%r14\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   1070 <strstr@plt>\n  test   %rax,%rax\n  je     11ad <func0+0x6d>\n  add    $0x1,%r12d\n  mov    %rbp,%rdi\n  movslq %r12d,%rdx\n  lea    0x0(,%rdx,8),%r15\n  mov    %r15,%rsi\n  call   1060 <realloc@plt>\n  mov    %r14,-0x8(%rax,%r15,1)\n  mov    %rax,%rbp\n  add    $0x8,%rbx\n  cmp    (%rsp),%rbx\n  jne    1178 <func0+0x38>\n  mov    0x8(%rsp),%rax\n  mov    %r12d,(%rax)\n  add    $0x18,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  jmp    11b7 <func0+0x77>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdx,%r13\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%rax\n  xor    %ebp,%ebp\n  mov    %rax,(%rsp)\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    (%rbx),%r14\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L1\n  add    $0x1,%r12d\n  mov    %rbp,%rdi\n  movslq %r12d,%rdx\n  lea    0x0(,%rdx,8),%r15\n  mov    %r15,%rsi\n  call   <realloc@plt>\n  mov    %r14,-0x8(%rax,%r15,1)\n  mov    %rax,%rbp\nL1:\n  add    $0x8,%rbx\n  cmp    (%rsp),%rbx\n  jne    L2\nL3:\n  mov    0x8(%rsp),%rax\n  mov    %r12d,(%rax)\n  add    $0x18,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4568
            },
            "L1": {
                "label": "L1",
                "addr": 4525
            },
            "L2": {
                "label": "L2",
                "addr": 4472
            },
            "L3": {
                "label": "L3",
                "addr": 4535
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 7,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char **strings, int size, const char *substring, int *out_size) {\n    char **out = NULL;\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (strstr(strings[i], substring) != NULL) {\n            out = (char **)realloc(out, sizeof(char *) * (count + 1));\n            out[count] = strings[i];\n            count++;\n        }\n    }\n    *out_size = count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int out_size;\n    char **result;\n\n    // First test case with empty array and substring \"john\"\n    result = func0(NULL, 0, \"john\", &out_size);\n    assert(out_size == 0 && result == NULL);\n\n    // Second test case\n    char *strings1[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected1[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings1, 6, \"xxx\", &out_size);\n    assert(issame(result, expected1, out_size, 3));\n    free(result);\n\n    // Third test case\n    char *strings2[] = {\"xxx\", \"asd\", \"aaaxxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char *expected2[] = {\"xxx\", \"aaaxxy\", \"xxxAAA\", \"xxx\"};\n    result = func0(strings2, 6, \"xx\", &out_size);\n    assert(issame(result, expected2, out_size, 4));\n    free(result);\n\n    // Fourth test case\n    char *strings3[] = {\"grunt\", \"trumpet\", \"prune\", \"gruesome\"};\n    char *expected3[] = {\"grunt\", \"prune\"};\n    result = func0(strings3, 4, \"run\", &out_size);\n    assert(issame(result, expected3, out_size, 2));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    11d8 <func0+0x98>\n  lea    -0x1(%rsi),%eax\n  mov    %rdx,%r13\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%rax\n  xor    %ebp,%ebp\n  mov    %rax,(%rsp)\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx),%r14\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   1070 <strstr@plt>\n  test   %rax,%rax\n  je     11ad <func0+0x6d>\n  add    $0x1,%r12d\n  mov    %rbp,%rdi\n  movslq %r12d,%rdx\n  lea    0x0(,%rdx,8),%r15\n  mov    %r15,%rsi\n  call   1060 <realloc@plt>\n  mov    %r14,-0x8(%rax,%r15,1)\n  mov    %rax,%rbp\n  add    $0x8,%rbx\n  cmp    (%rsp),%rbx\n  jne    1178 <func0+0x38>\n  mov    0x8(%rsp),%rax\n  mov    %r12d,(%rax)\n  add    $0x18,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  jmp    11b7 <func0+0x77>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdx,%r13\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%rax\n  xor    %ebp,%ebp\n  mov    %rax,(%rsp)\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    (%rbx),%r14\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L1\n  add    $0x1,%r12d\n  mov    %rbp,%rdi\n  movslq %r12d,%rdx\n  lea    0x0(,%rdx,8),%r15\n  mov    %r15,%rsi\n  call   <realloc@plt>\n  mov    %r14,-0x8(%rax,%r15,1)\n  mov    %rax,%rbp\nL1:\n  add    $0x8,%rbx\n  cmp    (%rsp),%rbx\n  jne    L2\nL3:\n  mov    0x8(%rsp),%rax\n  mov    %r12d,(%rax)\n  add    $0x18,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %r12d,%r12d\n  xor    %ebp,%ebp\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4568
            },
            "L1": {
                "label": "L1",
                "addr": 4525
            },
            "L2": {
                "label": "L2",
                "addr": 4472
            },
            "L3": {
                "label": "L3",
                "addr": 4535
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 8,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    115f <func0+0x66>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x8(%rbp),%edx\n  imul   %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1123 <func0+0x2a>\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x8(%rbp),%edx\n  imul   %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L1\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4447
            },
            "L1": {
                "label": "L1",
                "addr": 4387
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 8,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    112c <func0+0x33>\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%ecx\n  lea    0x4(%rdi,%rcx,4),%r8\n  mov    $0x1,%esi\n  mov    $0x0,%edi\n  mov    (%rax),%ecx\n  add    %ecx,%edi\n  imul   %ecx,%esi\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  jne    1116 <func0+0x1d>\n  mov    %edi,(%rdx)\n  mov    %esi,0x4(%rdx)\n  ret\n  mov    $0x1,%esi\n  mov    $0x0,%edi\n  jmp    1126 <func0+0x2d>",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%ecx\n  lea    0x4(%rdi,%rcx,4),%r8\n  mov    $0x1,%esi\n  mov    $0x0,%edi\nL1:\n  mov    (%rax),%ecx\n  add    %ecx,%edi\n  imul   %ecx,%esi\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  jne    L1\nL2:\n  mov    %edi,(%rdx)\n  mov    %esi,0x4(%rdx)\n  ret\nL0:\n  mov    $0x1,%esi\n  mov    $0x0,%edi\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4396
            },
            "L1": {
                "label": "L1",
                "addr": 4374
            },
            "L2": {
                "label": "L2",
                "addr": 4390
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 8,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1140 <func0+0x40>\n  lea    -0x1(%rsi),%eax\n  mov    $0x1,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rdi),%eax\n  add    $0x4,%rdi\n  imul   %eax,%ecx\n  add    %eax,%esi\n  cmp    %r8,%rdi\n  jne    1120 <func0+0x20>\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  mov    $0x1,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    $0x1,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    (%rdi),%eax\n  add    $0x4,%rdi\n  imul   %eax,%ecx\n  add    %eax,%esi\n  cmp    %r8,%rdi\n  jne    L1\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 8,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *numbers, int size, int *result) {\n    int sum = 0, product = 1;\n    for (int i = 0; i < size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    result[0] = sum;\n    result[1] = product;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int *a, const int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[2];\n\n    // First test case\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    // Second test case\n    func0((const int[]){1, 1, 1}, 3, result);\n    assert(issame(result, (const int[]){3, 1}, 2));\n\n    // Third test case\n    func0((const int[]){100, 0}, 2, result);\n    assert(issame(result, (const int[]){100, 0}, 2));\n\n    // Fourth test case\n    func0((const int[]){3, 5, 7}, 3, result);\n    assert(issame(result, (const int[]){3 + 5 + 7, 3 * 5 * 7}, 2));\n\n    // Fifth test case\n    func0((const int[]){10}, 1, result);\n    assert(issame(result, (const int[]){10, 10}, 2));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  mov    %esi,%r8d\n  test   %esi,%esi\n  jle    1200 <func0+0x100>\n  lea    -0x1(%rsi),%eax\n  cmp    $0x15,%eax\n  jbe    120d <func0+0x10d>\n  mov    %esi,%ecx\n  movdqa 0xed8(%rip),%xmm0        # 2000 <_fini+0xde8>\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  shr    $0x2,%ecx\n  sub    $0x1,%ecx\n  shl    $0x4,%rcx\n  lea    0x10(%rdi,%rcx,1),%rcx\n  xchg   %ax,%ax\n  movdqu (%rax),%xmm2\n  movdqa %xmm0,%xmm3\n  psrlq  $0x20,%xmm0\n  add    $0x10,%rax\n  pmuludq %xmm2,%xmm3\n  paddd  %xmm2,%xmm1\n  psrlq  $0x20,%xmm2\n  pmuludq %xmm2,%xmm0\n  pshufd $0x8,%xmm3,%xmm2\n  pshufd $0x8,%xmm0,%xmm3\n  movdqa %xmm2,%xmm0\n  punpckldq %xmm3,%xmm0\n  cmp    %rcx,%rax\n  jne    1140 <func0+0x40>\n  movdqa %xmm0,%xmm2\n  mov    %r8d,%ecx\n  psrldq $0x8,%xmm2\n  and    $0xfffffffc,%ecx\n  movdqa %xmm2,%xmm3\n  psrlq  $0x20,%xmm2\n  pmuludq %xmm0,%xmm3\n  psrlq  $0x20,%xmm0\n  pmuludq %xmm0,%xmm2\n  pshufd $0x8,%xmm3,%xmm3\n  pshufd $0x8,%xmm2,%xmm2\n  punpckldq %xmm2,%xmm3\n  movdqa %xmm3,%xmm0\n  psrldq $0x4,%xmm0\n  pmuludq %xmm3,%xmm0\n  movd   %xmm0,%edi\n  movdqa %xmm1,%xmm0\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%r8b\n  je     11fa <func0+0xfa>\n  movslq %ecx,%rcx\n  nopl   0x0(%rax)\n  mov    (%r9,%rcx,4),%esi\n  add    $0x1,%rcx\n  imul   %esi,%edi\n  add    %esi,%eax\n  cmp    %ecx,%r8d\n  jg     11e8 <func0+0xe8>\n  mov    %eax,(%rdx)\n  mov    %edi,0x4(%rdx)\n  ret\n  mov    $0x1,%edi\n  xor    %eax,%eax\n  mov    %eax,(%rdx)\n  mov    %edi,0x4(%rdx)\n  ret\n  xor    %ecx,%ecx\n  mov    $0x1,%edi\n  xor    %eax,%eax\n  jmp    11e1 <func0+0xe1>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  mov    %esi,%r8d\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cmp    $0x15,%eax\n  jbe    L1\n  mov    %esi,%ecx\n  movdqa D0(%rip),%xmm0\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  shr    $0x2,%ecx\n  sub    $0x1,%ecx\n  shl    $0x4,%rcx\n  lea    0x10(%rdi,%rcx,1),%rcx\n  xchg   %ax,%ax\nL2:\n  movdqu (%rax),%xmm2\n  movdqa %xmm0,%xmm3\n  psrlq  $0x20,%xmm0\n  add    $0x10,%rax\n  pmuludq %xmm2,%xmm3\n  paddd  %xmm2,%xmm1\n  psrlq  $0x20,%xmm2\n  pmuludq %xmm2,%xmm0\n  pshufd $0x8,%xmm3,%xmm2\n  pshufd $0x8,%xmm0,%xmm3\n  movdqa %xmm2,%xmm0\n  punpckldq %xmm3,%xmm0\n  cmp    %rcx,%rax\n  jne    L2\n  movdqa %xmm0,%xmm2\n  mov    %r8d,%ecx\n  psrldq $0x8,%xmm2\n  and    $0xfffffffc,%ecx\n  movdqa %xmm2,%xmm3\n  psrlq  $0x20,%xmm2\n  pmuludq %xmm0,%xmm3\n  psrlq  $0x20,%xmm0\n  pmuludq %xmm0,%xmm2\n  pshufd $0x8,%xmm3,%xmm3\n  pshufd $0x8,%xmm2,%xmm2\n  punpckldq %xmm2,%xmm3\n  movdqa %xmm3,%xmm0\n  psrldq $0x4,%xmm0\n  pmuludq %xmm3,%xmm0\n  movd   %xmm0,%edi\n  movdqa %xmm1,%xmm0\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%r8b\n  je     L3\nL5:\n  movslq %ecx,%rcx\n  nopl   0x0(%rax)\nL4:\n  mov    (%r9,%rcx,4),%esi\n  add    $0x1,%rcx\n  imul   %esi,%edi\n  add    %esi,%eax\n  cmp    %ecx,%r8d\n  jg     L4\nL3:\n  mov    %eax,(%rdx)\n  mov    %edi,0x4(%rdx)\n  ret\nL0:\n  mov    $0x1,%edi\n  xor    %eax,%eax\n  mov    %eax,(%rdx)\n  mov    %edi,0x4(%rdx)\n  ret\nL1:\n  xor    %ecx,%ecx\n  mov    $0x1,%edi\n  xor    %eax,%eax\n  jmp    L5",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3800
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4608
            },
            "L1": {
                "label": "L1",
                "addr": 4621
            },
            "L2": {
                "label": "L2",
                "addr": 4416
            },
            "L3": {
                "label": "L3",
                "addr": 4602
            },
            "L4": {
                "label": "L4",
                "addr": 4584
            },
            "L5": {
                "label": "L5",
                "addr": 4577
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "01000000010000000100000001000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 9,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jg     113c <func0+0x23>\n  mov    $0x0,%eax\n  jmp    11ce <func0+0xb5>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    115f <func0+0x46>\n  mov    $0x0,%eax\n  jmp    11ce <func0+0xb5>\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11c2 <func0+0xa9>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    11a5 <func0+0x8c>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x10(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1171 <func0+0x58>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jg     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L2\n  mov    $0x0,%eax\n  jmp    L1\nL2:\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L3\nL5:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    L4\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\nL4:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x10(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\nL3:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4412
            },
            "L1": {
                "label": "L1",
                "addr": 4558
            },
            "L2": {
                "label": "L2",
                "addr": 4447
            },
            "L3": {
                "label": "L3",
                "addr": 4546
            },
            "L4": {
                "label": "L4",
                "addr": 4517
            },
            "L5": {
                "label": "L5",
                "addr": 4465
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 9,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  test   %esi,%esi\n  jle    1166 <func0+0x4d>\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %esi,%ebp\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  test   %rax,%rax\n  je     115f <func0+0x46>\n  mov    (%rbx),%ecx\n  mov    %ebp,%edi\n  mov    $0x0,%edx\n  mov    (%rbx,%rdx,4),%esi\n  cmp    %esi,%ecx\n  cmovl  %esi,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdi,%rdx\n  jne    114b <func0+0x32>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  test   %esi,%esi\n  jle    L0\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %esi,%ebp\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L1\n  mov    (%rbx),%ecx\n  mov    %ebp,%edi\n  mov    $0x0,%edx\nL2:\n  mov    (%rbx,%rdx,4),%esi\n  cmp    %esi,%ecx\n  cmovl  %esi,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdi,%rdx\n  jne    L2\nL1:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4454
            },
            "L1": {
                "label": "L1",
                "addr": 4447
            },
            "L2": {
                "label": "L2",
                "addr": 4427
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 9,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1180 <func0+0x60>\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  test   %rax,%rax\n  je     1174 <func0+0x54>\n  mov    (%rbx),%ecx\n  lea    -0x1(%rbp),%edi\n  xor    %edx,%edx\n  shl    $0x2,%rdi\n  mov    %ecx,%esi\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax,%rax,1)\n  mov    0x4(%rbx,%rdx,1),%esi\n  add    $0x4,%rdx\n  cmp    %esi,%ecx\n  cmovl  %esi,%ecx\n  mov    %ecx,(%rax,%rdx,1)\n  cmp    %rdi,%rdx\n  jne    1158 <func0+0x38>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  add    $0x8,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L1\n  mov    (%rbx),%ecx\n  lea    -0x1(%rbp),%edi\n  xor    %edx,%edx\n  shl    $0x2,%rdi\n  mov    %ecx,%esi\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    0x4(%rbx,%rdx,1),%esi\n  add    $0x4,%rdx\nL2:\n  cmp    %esi,%ecx\n  cmovl  %esi,%ecx\n  mov    %ecx,(%rax,%rdx,1)\n  cmp    %rdi,%rdx\n  jne    L3\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL1:\n  add    $0x8,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4480
            },
            "L1": {
                "label": "L1",
                "addr": 4468
            },
            "L2": {
                "label": "L2",
                "addr": 4448
            },
            "L3": {
                "label": "L3",
                "addr": 4440
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 9,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *numbers, int size) {\n    if (size <= 0) {\n        return NULL;\n    }\n    \n    int *out = malloc(size * sizeof(int));\n    if (!out) {\n        return NULL;\n    }\n    \n    int max = numbers[0];\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] > max) max = numbers[i];\n        out[i] = max;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n\n    // First test case\n    result = func0((const int[]){}, 0);\n    assert(result == NULL);\n    free(result);\n\n    // Second test case\n    int test1[] = {1, 2, 3, 4};\n    result = func0(test1, 4);\n    assert(issame(result, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    // Third test case\n    int test2[] = {4, 3, 2, 1};\n    result = func0(test2, 4);\n    assert(issame(result, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    // Fourth test case\n    int test3[] = {3, 2, 3, 100, 3};\n    result = func0(test3, 5);\n    assert(issame(result, (const int[]){3, 3, 3, 100, 100}, 5));\n    free(result);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1178 <func0+0x58>\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  movslq %esi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  test   %rax,%rax\n  je     116c <func0+0x4c>\n  mov    0x0(%rbp),%ecx\n  xor    %edx,%edx\n  nopl   0x0(%rax,%rax,1)\n  mov    0x0(%rbp,%rdx,4),%edi\n  cmp    %edi,%ecx\n  cmovl  %edi,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rbx\n  jne    1150 <func0+0x30>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  add    $0x8,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  movslq %esi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L1\n  mov    0x0(%rbp),%ecx\n  xor    %edx,%edx\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    0x0(%rbp,%rdx,4),%edi\n  cmp    %edi,%ecx\n  cmovl  %edi,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rbx\n  jne    L2\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL1:\n  add    $0x8,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4472
            },
            "L1": {
                "label": "L1",
                "addr": 4460
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 10,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    119f <func0+0x46>\n  mov    $0x0,%eax\n  jmp    1302 <func0+0x1a9>\n  movl   $0x0,-0x18(%rbp)\n  jmp    1288 <func0+0x12f>\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11f7 <func0+0x9e>\n  mov    -0x18(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     11f3 <func0+0x9a>\n  movl   $0x0,-0x10(%rbp)\n  jmp    120b <func0+0xb2>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0xc(%rbp),%eax\n  sub    -0x18(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x14(%rbp)\n  jl     11bb <func0+0x62>\n  cmpl   $0x0,-0x10(%rbp)\n  je     1284 <func0+0x12b>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  movl   $0x0,-0x14(%rbp)\n  jmp    1261 <func0+0x108>\n  mov    -0x18(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%ecx\n  mov    -0x14(%rbp),%edx\n  add    %ecx,%edx\n  movslq %edx,%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     1233 <func0+0xda>\n  mov    -0xc(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  jmp    1302 <func0+0x1a9>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     11ab <func0+0x52>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  movl   $0x0,-0x14(%rbp)\n  jmp    12e4 <func0+0x18b>\n  mov    -0xc(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%ecx\n  mov    -0x14(%rbp),%edx\n  add    %ecx,%edx\n  movslq %edx,%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     12b6 <func0+0x15d>\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0x18(%rbp)\n  jmp    L2\nL10:\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L3\nL6:\n  mov    -0x18(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     L4\n  movl   $0x0,-0x10(%rbp)\n  jmp    L5\nL4:\n  addl   $0x1,-0x14(%rbp)\nL3:\n  mov    -0xc(%rbp),%eax\n  sub    -0x18(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x14(%rbp)\n  jl     L6\nL5:\n  cmpl   $0x0,-0x10(%rbp)\n  je     L7\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  movl   $0x0,-0x14(%rbp)\n  jmp    L8\nL9:\n  mov    -0x18(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%ecx\n  mov    -0x14(%rbp),%edx\n  add    %ecx,%edx\n  movslq %edx,%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x14(%rbp)\nL8:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     L9\n  mov    -0xc(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  jmp    L1\nL7:\n  addl   $0x1,-0x18(%rbp)\nL2:\n  mov    -0x18(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L10\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  movl   $0x0,-0x14(%rbp)\n  jmp    L11\nL12:\n  mov    -0xc(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%ecx\n  mov    -0x14(%rbp),%edx\n  add    %ecx,%edx\n  movslq %edx,%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x14(%rbp)\nL11:\n  mov    -0x14(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L12\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4511
            },
            "L1": {
                "label": "L1",
                "addr": 4866
            },
            "L2": {
                "label": "L2",
                "addr": 4744
            },
            "L3": {
                "label": "L3",
                "addr": 4599
            },
            "L4": {
                "label": "L4",
                "addr": 4595
            },
            "L5": {
                "label": "L5",
                "addr": 4619
            },
            "L6": {
                "label": "L6",
                "addr": 4539
            },
            "L7": {
                "label": "L7",
                "addr": 4740
            },
            "L8": {
                "label": "L8",
                "addr": 4705
            },
            "L9": {
                "label": "L9",
                "addr": 4659
            },
            "L10": {
                "label": "L10",
                "addr": 4523
            },
            "L11": {
                "label": "L11",
                "addr": 4836
            },
            "L12": {
                "label": "L12",
                "addr": 4790
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 10,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%rbp\n  call   1080 <strlen@plt>\n  mov    %rax,%r14\n  mov    %eax,%r13d\n  lea    (%rax,%rax,1),%eax\n  mov    %eax,0xc(%rsp)\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r15\n  test   %rax,%rax\n  je     1209 <func0+0xb0>\n  test   %r14d,%r14d\n  jle    11b8 <func0+0x5f>\n  mov    %r14d,%r8d\n  lea    -0x1(%r14),%r12d\n  mov    %rbp,%rsi\n  mov    $0x0,%ebx\n  movslq %r14d,%rdi\n  sub    $0x1,%rdi\n  jmp    1227 <func0+0xce>\n  mov    %r12d,%ebx\n  jmp    125e <func0+0x105>\n  movslq %r14d,%rdx\n  mov    %rbp,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  jmp    11ff <func0+0xa6>\n  movslq %ebx,%rbx\n  mov    %rbx,%rdx\n  mov    %rbp,%rsi\n  mov    %r15,%rdi\n  call   1070 <strncpy@plt>\n  lea    -0x1(%rbp,%rbx,1),%rax\n  lea    (%r15,%rbx,1),%rdx\n  lea    -0x2(%rbp,%rbx,1),%rsi\n  mov    %r12d,%r12d\n  sub    %r12,%rsi\n  movzbl (%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    11ed <func0+0x94>\n  movslq 0xc(%rsp),%rax\n  movb   $0x0,(%r15,%rax,1)\n  mov    %r15,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  add    $0x1,%ebx\n  add    $0x1,%rsi\n  cmp    %ebx,%r13d\n  je     11c8 <func0+0x6f>\n  mov    %r8d,%eax\n  sub    %ebx,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    %r12d,%ebx\n  je     11b0 <func0+0x57>\n  lea    0x0(%rbp,%rdi,1),%rdx\n  mov    $0x0,%eax\n  movzbl (%rdx),%r9d\n  cmp    %r9b,(%rsi,%rax,1)\n  jne    121b <func0+0xc2>\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     1248 <func0+0xef>\n  movslq %r14d,%r12\n  mov    %r12,%rdx\n  mov    %rbp,%rsi\n  mov    %r15,%rdi\n  call   1070 <strncpy@plt>\n  test   %ebx,%ebx\n  jle    129c <func0+0x143>\n  movslq %ebx,%rcx\n  lea    -0x1(%rbp,%rcx,1),%rax\n  lea    (%r15,%r12,1),%rdx\n  lea    -0x2(%rbp,%rcx,1),%rsi\n  lea    -0x1(%rbx),%ecx\n  sub    %rcx,%rsi\n  movzbl (%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    128a <func0+0x131>\n  lea    (%rbx,%r14,1),%eax\n  cltq\n  movb   $0x0,(%r15,%rax,1)\n  jmp    1209 <func0+0xb0>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%rbp\n  call   <strlen@plt>\n  mov    %rax,%r14\n  mov    %eax,%r13d\n  lea    (%rax,%rax,1),%eax\n  mov    %eax,0xc(%rsp)\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r15\n  test   %rax,%rax\n  je     L0\n  test   %r14d,%r14d\n  jle    L1\n  mov    %r14d,%r8d\n  lea    -0x1(%r14),%r12d\n  mov    %rbp,%rsi\n  mov    $0x0,%ebx\n  movslq %r14d,%rdi\n  sub    $0x1,%rdi\n  jmp    L2\nL7:\n  mov    %r12d,%ebx\n  jmp    L3\nL1:\n  movslq %r14d,%rdx\n  mov    %rbp,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  jmp    L4\nL6:\n  movslq %ebx,%rbx\n  mov    %rbx,%rdx\n  mov    %rbp,%rsi\n  mov    %r15,%rdi\n  call   <strncpy@plt>\n  lea    -0x1(%rbp,%rbx,1),%rax\n  lea    (%r15,%rbx,1),%rdx\n  lea    -0x2(%rbp,%rbx,1),%rsi\n  mov    %r12d,%r12d\n  sub    %r12,%rsi\nL5:\n  movzbl (%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    L5\nL4:\n  movslq 0xc(%rsp),%rax\n  movb   $0x0,(%r15,%rax,1)\nL0:\n  mov    %r15,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  add    $0x1,%ebx\n  add    $0x1,%rsi\n  cmp    %ebx,%r13d\n  je     L6\nL2:\n  mov    %r8d,%eax\n  sub    %ebx,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    %r12d,%ebx\n  je     L7\n  lea    0x0(%rbp,%rdi,1),%rdx\n  mov    $0x0,%eax\nL9:\n  movzbl (%rdx),%r9d\n  cmp    %r9b,(%rsi,%rax,1)\n  jne    L8\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     L9\nL3:\n  movslq %r14d,%r12\n  mov    %r12,%rdx\n  mov    %rbp,%rsi\n  mov    %r15,%rdi\n  call   <strncpy@plt>\n  test   %ebx,%ebx\n  jle    L10\n  movslq %ebx,%rcx\n  lea    -0x1(%rbp,%rcx,1),%rax\n  lea    (%r15,%r12,1),%rdx\n  lea    -0x2(%rbp,%rcx,1),%rsi\n  lea    -0x1(%rbx),%ecx\n  sub    %rcx,%rsi\nL11:\n  movzbl (%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    L11\nL10:\n  lea    (%rbx,%r14,1),%eax\n  cltq\n  movb   $0x0,(%r15,%rax,1)\n  jmp    L0",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4617
            },
            "L1": {
                "label": "L1",
                "addr": 4536
            },
            "L2": {
                "label": "L2",
                "addr": 4647
            },
            "L3": {
                "label": "L3",
                "addr": 4702
            },
            "L4": {
                "label": "L4",
                "addr": 4607
            },
            "L5": {
                "label": "L5",
                "addr": 4589
            },
            "L6": {
                "label": "L6",
                "addr": 4552
            },
            "L7": {
                "label": "L7",
                "addr": 4528
            },
            "L8": {
                "label": "L8",
                "addr": 4635
            },
            "L9": {
                "label": "L9",
                "addr": 4680
            },
            "L10": {
                "label": "L10",
                "addr": 4764
            },
            "L11": {
                "label": "L11",
                "addr": 4746
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 10,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   1080 <strlen@plt>\n  lea    (%rax,%rax,1),%ebx\n  mov    %rax,%r12\n  mov    %eax,%r15d\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     1260 <func0+0x100>\n  movslq %r12d,%r14\n  test   %r12d,%r12d\n  jle    12c5 <func0+0x165>\n  xor    %ebp,%ebp\n  mov    %r12d,%edx\n  lea    -0x1(%r12),%edi\n  mov    %r13,%rax\n  sub    %ebp,%edx\n  mov    %r12d,%r10d\n  movslq %edi,%rdi\n  mov    %edx,%ecx\n  sar    %ecx\n  je     1210 <func0+0xb0>\n  nopl   0x0(%rax)\n  lea    0x1(%rax),%r9\n  sub    $0x1,%ecx\n  lea    0x0(%r13,%rdi,1),%rdx\n  add    %r9,%rcx\n  jmp    11ed <func0+0x8d>\n  nopl   0x0(%rax)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %rcx,%rax\n  je     1210 <func0+0xb0>\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rax)\n  je     11e0 <func0+0x80>\n  add    $0x1,%ebp\n  cmp    %ebp,%r15d\n  je     1272 <func0+0x112>\n  mov    %r12d,%edx\n  mov    %r9,%rax\n  sub    %ebp,%edx\n  mov    %edx,%ecx\n  sar    %ecx\n  jne    11c8 <func0+0x68>\n  nopl   0x0(%rax,%rax,1)\n  mov    %r8,%rdi\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  call   1070 <strncpy@plt>\n  mov    %rax,%r8\n  test   %ebp,%ebp\n  je     1254 <func0+0xf4>\n  movslq %ebp,%rdx\n  add    %r8,%r14\n  lea    -0x2(%r13,%rdx,1),%rcx\n  lea    -0x1(%r13,%rdx,1),%rax\n  lea    -0x1(%rbp),%edx\n  sub    %rdx,%rcx\n  nopl   0x0(%rax,%rax,1)\n  movzbl (%rax),%edx\n  sub    $0x1,%rax\n  add    $0x1,%r14\n  mov    %dl,-0x1(%r14)\n  cmp    %rcx,%rax\n  jne    1240 <func0+0xe0>\n  lea    0x0(%rbp,%r12,1),%eax\n  cltq\n  movb   $0x0,(%r8,%rax,1)\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %r8,%rdi\n  mov    %r10d,0xc(%rsp)\n  call   1070 <strncpy@plt>\n  mov    0xc(%rsp),%r10d\n  lea    -0x2(%r13,%r14,1),%rsi\n  mov    %rax,%r8\n  lea    -0x1(%r13,%r14,1),%rax\n  lea    -0x1(%r10),%ecx\n  lea    (%r8,%r14,1),%rdx\n  sub    %rcx,%rsi\n  nopw   0x0(%rax,%rax,1)\n  movzbl (%rax),%ecx\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %cl,-0x1(%rdx)\n  cmp    %rax,%rsi\n  jne    12a8 <func0+0x148>\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\n  jmp    1260 <func0+0x100>\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  mov    %rax,%r8\n  jmp    12bb <func0+0x15b>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  lea    (%rax,%rax,1),%ebx\n  mov    %rax,%r12\n  mov    %eax,%r15d\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L0\n  movslq %r12d,%r14\n  test   %r12d,%r12d\n  jle    L1\n  xor    %ebp,%ebp\n  mov    %r12d,%edx\n  lea    -0x1(%r12),%edi\n  mov    %r13,%rax\n  sub    %ebp,%edx\n  mov    %r12d,%r10d\n  movslq %edi,%rdi\n  mov    %edx,%ecx\n  sar    %ecx\n  je     L2\n  nopl   0x0(%rax)\nL6:\n  lea    0x1(%rax),%r9\n  sub    $0x1,%ecx\n  lea    0x0(%r13,%rdi,1),%rdx\n  add    %r9,%rcx\n  jmp    L3\n  nopl   0x0(%rax)\nL4:\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %rcx,%rax\n  je     L2\nL3:\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rax)\n  je     L4\n  add    $0x1,%ebp\n  cmp    %ebp,%r15d\n  je     L5\n  mov    %r12d,%edx\n  mov    %r9,%rax\n  sub    %ebp,%edx\n  mov    %edx,%ecx\n  sar    %ecx\n  jne    L6\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    %r8,%rdi\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  call   <strncpy@plt>\n  mov    %rax,%r8\n  test   %ebp,%ebp\n  je     L7\n  movslq %ebp,%rdx\n  add    %r8,%r14\n  lea    -0x2(%r13,%rdx,1),%rcx\n  lea    -0x1(%r13,%rdx,1),%rax\n  lea    -0x1(%rbp),%edx\n  sub    %rdx,%rcx\n  nopl   0x0(%rax,%rax,1)\nL8:\n  movzbl (%rax),%edx\n  sub    $0x1,%rax\n  add    $0x1,%r14\n  mov    %dl,-0x1(%r14)\n  cmp    %rcx,%rax\n  jne    L8\nL7:\n  lea    0x0(%rbp,%r12,1),%eax\n  cltq\n  movb   $0x0,(%r8,%rax,1)\nL0:\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL5:\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %r8,%rdi\n  mov    %r10d,0xc(%rsp)\n  call   <strncpy@plt>\n  mov    0xc(%rsp),%r10d\n  lea    -0x2(%r13,%r14,1),%rsi\n  mov    %rax,%r8\n  lea    -0x1(%r13,%r14,1),%rax\n  lea    -0x1(%r10),%ecx\n  lea    (%r8,%r14,1),%rdx\n  sub    %rcx,%rsi\n  nopw   0x0(%rax,%rax,1)\nL9:\n  movzbl (%rax),%ecx\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %cl,-0x1(%rdx)\n  cmp    %rax,%rsi\n  jne    L9\nL10:\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\n  jmp    L0\nL1:\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  mov    %rax,%r8\n  jmp    L10",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4704
            },
            "L1": {
                "label": "L1",
                "addr": 4805
            },
            "L2": {
                "label": "L2",
                "addr": 4624
            },
            "L3": {
                "label": "L3",
                "addr": 4589
            },
            "L4": {
                "label": "L4",
                "addr": 4576
            },
            "L5": {
                "label": "L5",
                "addr": 4722
            },
            "L6": {
                "label": "L6",
                "addr": 4552
            },
            "L7": {
                "label": "L7",
                "addr": 4692
            },
            "L8": {
                "label": "L8",
                "addr": 4672
            },
            "L9": {
                "label": "L9",
                "addr": 4776
            },
            "L10": {
                "label": "L10",
                "addr": 4795
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 10,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *str) {\n    int len = strlen(str), i, j;\n    char *result = (char *)malloc(2 * len + 1);\n    if (!result) {\n        return NULL; \n    }\n\n    for (i = 0; i < len; i++) {\n        int is_palindrome = 1;\n        for (j = 0; j < (len - i) / 2; j++) {\n            if (str[i + j] != str[len - 1 - j]) {\n                is_palindrome = 0;\n                break;\n            }\n        }\n        if (is_palindrome) {\n            strncpy(result, str, len);\n            for (j = 0; j < i; j++) {\n                result[len + j] = str[i - j - 1];\n            }\n            result[len + i] = '\\0';\n            return result;\n        }\n    }\n\n    strncpy(result, str, len);\n    for (j = 0; j < len; j++) {\n        result[len + j] = str[len - j - 1];\n    }\n    result[2 * len] = '\\0';\n    return result;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *palindrome;\n\n    // First test case\n    palindrome = func0(\"\");\n    assert(strcmp(palindrome, \"\") == 0);\n    free(palindrome);\n\n    // Second test case\n    palindrome = func0(\"x\");\n    assert(strcmp(palindrome, \"x\") == 0);\n    free(palindrome);\n\n    // Third test case\n    palindrome = func0(\"xyz\");\n    assert(strcmp(palindrome, \"xyzyx\") == 0);\n    free(palindrome);\n\n    // Fourth test case\n    palindrome = func0(\"xyx\");\n    assert(strcmp(palindrome, \"xyx\") == 0);\n    free(palindrome);\n\n    // Fifth test case\n    palindrome = func0(\"jerry\");\n    assert(strcmp(palindrome, \"jerryrrej\") == 0);\n    free(palindrome);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   1080 <strlen@plt>\n  lea    (%rax,%rax,1),%ebx\n  mov    %rax,%r12\n  mov    %eax,%r15d\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     1260 <func0+0x100>\n  movslq %r12d,%r14\n  test   %r12d,%r12d\n  jle    12c5 <func0+0x165>\n  xor    %ebp,%ebp\n  mov    %r12d,%edx\n  lea    -0x1(%r12),%edi\n  mov    %r13,%rax\n  sub    %ebp,%edx\n  mov    %r12d,%r10d\n  movslq %edi,%rdi\n  mov    %edx,%ecx\n  sar    %ecx\n  je     1210 <func0+0xb0>\n  nopl   0x0(%rax)\n  lea    0x1(%rax),%r9\n  sub    $0x1,%ecx\n  lea    0x0(%r13,%rdi,1),%rdx\n  add    %r9,%rcx\n  jmp    11ed <func0+0x8d>\n  nopl   0x0(%rax)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %rcx,%rax\n  je     1210 <func0+0xb0>\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rax)\n  je     11e0 <func0+0x80>\n  add    $0x1,%ebp\n  cmp    %ebp,%r15d\n  je     1272 <func0+0x112>\n  mov    %r12d,%edx\n  mov    %r9,%rax\n  sub    %ebp,%edx\n  mov    %edx,%ecx\n  sar    %ecx\n  jne    11c8 <func0+0x68>\n  nopl   0x0(%rax,%rax,1)\n  mov    %r8,%rdi\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  call   1070 <strncpy@plt>\n  mov    %rax,%r8\n  test   %ebp,%ebp\n  je     1254 <func0+0xf4>\n  movslq %ebp,%rdx\n  add    %r8,%r14\n  lea    -0x2(%r13,%rdx,1),%rcx\n  lea    -0x1(%r13,%rdx,1),%rax\n  lea    -0x1(%rbp),%edx\n  sub    %rdx,%rcx\n  nopl   0x0(%rax,%rax,1)\n  movzbl (%rax),%edx\n  sub    $0x1,%rax\n  add    $0x1,%r14\n  mov    %dl,-0x1(%r14)\n  cmp    %rax,%rcx\n  jne    1240 <func0+0xe0>\n  lea    0x0(%rbp,%r12,1),%eax\n  cltq\n  movb   $0x0,(%r8,%rax,1)\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %r8,%rdi\n  mov    %r10d,0xc(%rsp)\n  call   1070 <strncpy@plt>\n  mov    0xc(%rsp),%r10d\n  lea    -0x2(%r13,%r14,1),%rsi\n  mov    %rax,%r8\n  lea    -0x1(%r13,%r14,1),%rax\n  lea    -0x1(%r10),%ecx\n  lea    (%r8,%r14,1),%rdx\n  sub    %rcx,%rsi\n  nopw   0x0(%rax,%rax,1)\n  movzbl (%rax),%ecx\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %cl,-0x1(%rdx)\n  cmp    %rax,%rsi\n  jne    12a8 <func0+0x148>\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\n  jmp    1260 <func0+0x100>\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  mov    %rax,%r8\n  jmp    12bb <func0+0x15b>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  lea    (%rax,%rax,1),%ebx\n  mov    %rax,%r12\n  mov    %eax,%r15d\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L0\n  movslq %r12d,%r14\n  test   %r12d,%r12d\n  jle    L1\n  xor    %ebp,%ebp\n  mov    %r12d,%edx\n  lea    -0x1(%r12),%edi\n  mov    %r13,%rax\n  sub    %ebp,%edx\n  mov    %r12d,%r10d\n  movslq %edi,%rdi\n  mov    %edx,%ecx\n  sar    %ecx\n  je     L2\n  nopl   0x0(%rax)\nL6:\n  lea    0x1(%rax),%r9\n  sub    $0x1,%ecx\n  lea    0x0(%r13,%rdi,1),%rdx\n  add    %r9,%rcx\n  jmp    L3\n  nopl   0x0(%rax)\nL4:\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %rcx,%rax\n  je     L2\nL3:\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rax)\n  je     L4\n  add    $0x1,%ebp\n  cmp    %ebp,%r15d\n  je     L5\n  mov    %r12d,%edx\n  mov    %r9,%rax\n  sub    %ebp,%edx\n  mov    %edx,%ecx\n  sar    %ecx\n  jne    L6\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    %r8,%rdi\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  call   <strncpy@plt>\n  mov    %rax,%r8\n  test   %ebp,%ebp\n  je     L7\n  movslq %ebp,%rdx\n  add    %r8,%r14\n  lea    -0x2(%r13,%rdx,1),%rcx\n  lea    -0x1(%r13,%rdx,1),%rax\n  lea    -0x1(%rbp),%edx\n  sub    %rdx,%rcx\n  nopl   0x0(%rax,%rax,1)\nL8:\n  movzbl (%rax),%edx\n  sub    $0x1,%rax\n  add    $0x1,%r14\n  mov    %dl,-0x1(%r14)\n  cmp    %rax,%rcx\n  jne    L8\nL7:\n  lea    0x0(%rbp,%r12,1),%eax\n  cltq\n  movb   $0x0,(%r8,%rax,1)\nL0:\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL5:\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %r8,%rdi\n  mov    %r10d,0xc(%rsp)\n  call   <strncpy@plt>\n  mov    0xc(%rsp),%r10d\n  lea    -0x2(%r13,%r14,1),%rsi\n  mov    %rax,%r8\n  lea    -0x1(%r13,%r14,1),%rax\n  lea    -0x1(%r10),%ecx\n  lea    (%r8,%r14,1),%rdx\n  sub    %rcx,%rsi\n  nopw   0x0(%rax,%rax,1)\nL9:\n  movzbl (%rax),%ecx\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %cl,-0x1(%rdx)\n  cmp    %rax,%rsi\n  jne    L9\nL10:\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\n  jmp    L0\nL1:\n  mov    %r14,%rdx\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  mov    %rax,%r8\n  jmp    L10",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4704
            },
            "L1": {
                "label": "L1",
                "addr": 4805
            },
            "L2": {
                "label": "L2",
                "addr": 4624
            },
            "L3": {
                "label": "L3",
                "addr": 4589
            },
            "L4": {
                "label": "L4",
                "addr": 4576
            },
            "L5": {
                "label": "L5",
                "addr": 4722
            },
            "L6": {
                "label": "L6",
                "addr": 4552
            },
            "L7": {
                "label": "L7",
                "addr": 4692
            },
            "L8": {
                "label": "L8",
                "addr": 4672
            },
            "L9": {
                "label": "L9",
                "addr": 4776
            },
            "L10": {
                "label": "L10",
                "addr": 4795
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 11,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %eax,-0x14(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    119b <func0+0x62>\n  mov    $0x0,%eax\n  jmp    1203 <func0+0xca>\n  movl   $0x0,-0x18(%rbp)\n  jmp    11e7 <func0+0xae>\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    11cf <func0+0x96>\n  mov    $0x30,%edx\n  jmp    11d4 <func0+0x9b>\n  mov    $0x31,%edx\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     11a4 <func0+0x6b>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x14(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0x18(%rbp)\n  jmp    L2\nL5:\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    L3\n  mov    $0x30,%edx\n  jmp    L4\nL3:\n  mov    $0x31,%edx\nL4:\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  addl   $0x1,-0x18(%rbp)\nL2:\n  mov    -0x18(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L5\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4507
            },
            "L1": {
                "label": "L1",
                "addr": 4611
            },
            "L2": {
                "label": "L2",
                "addr": 4583
            },
            "L3": {
                "label": "L3",
                "addr": 4559
            },
            "L4": {
                "label": "L4",
                "addr": 4564
            },
            "L5": {
                "label": "L5",
                "addr": 4516
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 11,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rsi,%rbp\n  call   1060 <strlen@plt>\n  mov    %rax,%r12\n  mov    %rbp,%rdi\n  call   1060 <strlen@plt>\n  cmp    %eax,%r12d\n  cmovg  %eax,%r12d\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   1070 <malloc@plt>\n  test   %rax,%rax\n  je     11a0 <func0+0x67>\n  test   %r12d,%r12d\n  jle    1198 <func0+0x5f>\n  mov    %r12d,%esi\n  mov    $0x0,%edx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%rbx,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%rax,%rdx,1)\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    117d <func0+0x44>\n  movslq %r12d,%r12\n  movb   $0x0,(%rax,%r12,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rsi,%rbp\n  call   <strlen@plt>\n  mov    %rax,%r12\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  cmp    %eax,%r12d\n  cmovg  %eax,%r12d\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L0\n  test   %r12d,%r12d\n  jle    L1\n  mov    %r12d,%esi\n  mov    $0x0,%edx\nL2:\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%rbx,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%rax,%rdx,1)\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    L2\nL1:\n  movslq %r12d,%r12\n  movb   $0x0,(%rax,%r12,1)\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4512
            },
            "L1": {
                "label": "L1",
                "addr": 4504
            },
            "L2": {
                "label": "L2",
                "addr": 4477
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 11,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  call   1060 <strlen@plt>\n  mov    %r12,%rdi\n  mov    %rax,%rbx\n  call   1060 <strlen@plt>\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   1070 <malloc@plt>\n  test   %rax,%rax\n  je     119f <func0+0x5f>\n  movslq %ebx,%rsi\n  xor    %edx,%edx\n  test   %ebx,%ebx\n  jle    119b <func0+0x5b>\n  nopl   0x0(%rax)\n  movzbl (%r12,%rdx,1),%ebx\n  cmp    %bl,0x0(%rbp,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%rax,%rdx,1)\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    1180 <func0+0x40>\n  movb   $0x0,(%rax,%rsi,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  call   <strlen@plt>\n  mov    %r12,%rdi\n  mov    %rax,%rbx\n  call   <strlen@plt>\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L0\n  movslq %ebx,%rsi\n  xor    %edx,%edx\n  test   %ebx,%ebx\n  jle    L1\n  nopl   0x0(%rax)\nL2:\n  movzbl (%r12,%rdx,1),%ebx\n  cmp    %bl,0x0(%rbp,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%rax,%rdx,1)\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    L2\nL1:\n  movb   $0x0,(%rax,%rsi,1)\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4511
            },
            "L1": {
                "label": "L1",
                "addr": 4507
            },
            "L2": {
                "label": "L2",
                "addr": 4480
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 11,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int min_len = len_a < len_b ? len_a : len_b;\n    char *output = malloc((min_len + 1) * sizeof(char));\n    if (!output) return NULL;\n\n    for (int i = 0; i < min_len; i++) {\n        output[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    output[min_len] = '\\0';\n    return output;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *result;\n\n    result = func0(\"111000\", \"101010\");\n    assert(strcmp(result, \"010010\") == 0);\n    free(result);\n\n    result = func0(\"1\", \"1\");\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(\"0101\", \"0000\");\n    assert(strcmp(result, \"0101\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  call   1060 <strlen@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%rbx\n  call   1060 <strlen@plt>\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     13c8 <func0+0x288>\n  test   %ebx,%ebx\n  jle    13c0 <func0+0x280>\n  lea    -0x1(%rbx),%eax\n  cmp    $0xe,%eax\n  jbe    13d0 <func0+0x290>\n  mov    %ebx,%edx\n  movdqa 0xe68(%rip),%xmm3        # 2000 <_fini+0xc28>\n  movdqa 0xe70(%rip),%xmm2        # 2010 <_fini+0xc38>\n  xor    %eax,%eax\n  shr    $0x4,%edx\n  shl    $0x4,%rdx\n  nopl   0x0(%rax)\n  movdqu (%r12,%rax,1),%xmm0\n  movdqu 0x0(%rbp,%rax,1),%xmm4\n  movdqa %xmm3,%xmm1\n  pcmpeqb %xmm4,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm2,%xmm0\n  por    %xmm1,%xmm0\n  movups %xmm0,(%r8,%rax,1)\n  add    $0x10,%rax\n  cmp    %rdx,%rax\n  jne    11b0 <func0+0x70>\n  mov    %ebx,%eax\n  and    $0xfffffff0,%eax\n  test   $0xf,%bl\n  je     13c0 <func0+0x280>\n  movslq %eax,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl (%r12,%rdx,1),%esi\n  cmp    %sil,0x0(%rbp,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x2(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x3(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x4(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x5(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x6(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x7(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x8(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x9(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xa(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xb(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xc(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xd(%rax),%edx\n  cmp    %edx,%ebx\n  jle    13c0 <func0+0x280>\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0xe,%eax\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  cmp    %eax,%ebx\n  jle    13c0 <func0+0x280>\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%esi\n  cmp    %sil,(%r12,%rax,1)\n  setne  %dl\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rax,1)\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\n  pop    %rbx\n  mov    %r8,%rax\n  pop    %rbp\n  pop    %r12\n  ret\n  xor    %eax,%eax\n  jmp    11ec <func0+0xac>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  call   <strlen@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%rbx\n  call   <strlen@plt>\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L0\n  test   %ebx,%ebx\n  jle    L1\n  lea    -0x1(%rbx),%eax\n  cmp    $0xe,%eax\n  jbe    L2\n  mov    %ebx,%edx\n  movdqa D0(%rip),%xmm3\n  movdqa D1(%rip),%xmm2\n  xor    %eax,%eax\n  shr    $0x4,%edx\n  shl    $0x4,%rdx\n  nopl   0x0(%rax)\nL3:\n  movdqu (%r12,%rax,1),%xmm0\n  movdqu 0x0(%rbp,%rax,1),%xmm4\n  movdqa %xmm3,%xmm1\n  pcmpeqb %xmm4,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm2,%xmm0\n  por    %xmm1,%xmm0\n  movups %xmm0,(%r8,%rax,1)\n  add    $0x10,%rax\n  cmp    %rdx,%rax\n  jne    L3\n  mov    %ebx,%eax\n  and    $0xfffffff0,%eax\n  test   $0xf,%bl\n  je     L1\nL4:\n  movslq %eax,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl (%r12,%rdx,1),%esi\n  cmp    %sil,0x0(%rbp,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x2(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x3(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x4(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x5(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x6(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x7(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x8(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0x9(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xa(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xb(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%esi\n  cmp    %sil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xc(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  lea    0xd(%rax),%edx\n  cmp    %edx,%ebx\n  jle    L1\n  movslq %edx,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%edi\n  cmp    %dil,(%r12,%rdx,1)\n  setne  %cl\n  add    $0xe,%eax\n  add    $0x30,%ecx\n  mov    %cl,(%r8,%rdx,1)\n  cmp    %eax,%ebx\n  jle    L1\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%esi\n  cmp    %sil,(%r12,%rax,1)\n  setne  %dl\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rax,1)\nL1:\n  movslq %ebx,%rbx\n  movb   $0x0,(%r8,%rbx,1)\nL0:\n  pop    %rbx\n  mov    %r8,%rax\n  pop    %rbp\n  pop    %r12\n  ret\nL2:\n  xor    %eax,%eax\n  jmp    L4",
        "num_missing": 2,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3688
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3696
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5064
            },
            "L1": {
                "label": "L1",
                "addr": 5056
            },
            "L2": {
                "label": "L2",
                "addr": 5072
            },
            "L3": {
                "label": "L3",
                "addr": 4528
            },
            "L4": {
                "label": "L4",
                "addr": 4588
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "3030303030303030303030303030303031313131313131313131313131313131",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        48,
                        48,
                        48,
                        48,
                        48,
                        48,
                        48,
                        48,
                        48,
                        48,
                        48,
                        48,
                        48,
                        48,
                        48,
                        48
                    ]
                },
                "0x2010": {
                    "type": "byte[16]",
                    "value": [
                        49,
                        49,
                        49,
                        49,
                        49,
                        49,
                        49,
                        49,
                        49,
                        49,
                        49,
                        49,
                        49,
                        49,
                        49,
                        49
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 12,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  lea    0xecd(%rip),%rax        # 2000 <_fini+0xe5c>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    1196 <func0+0x7d>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    1192 <func0+0x79>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1147 <func0+0x2e>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL2:\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    L1\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\nL1:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L2\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3789
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4502
            },
            "L1": {
                "label": "L1",
                "addr": 4498
            },
            "L2": {
                "label": "L2",
                "addr": 4423
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 12,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  lea    0xed4(%rip),%r14        # 2000 <_fini+0xe90>\n  test   %esi,%esi\n  jle    1164 <func0+0x4b>\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r13\n  mov    $0x0,%r12d\n  jmp    114c <func0+0x33>\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  je     1164 <func0+0x4b>\n  mov    (%rbx),%rbp\n  mov    %rbp,%rdi\n  call   1050 <strlen@plt>\n  cmp    %r12d,%eax\n  jle    1143 <func0+0x2a>\n  mov    %eax,%r12d\n  mov    %rbp,%r14\n  jmp    1143 <func0+0x2a>\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  lea    D0(%rip),%r14\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r13\n  mov    $0x0,%r12d\n  jmp    L1\nL2:\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  mov    (%rbx),%rbp\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  cmp    %r12d,%eax\n  jle    L2\n  mov    %eax,%r12d\n  mov    %rbp,%r14\n  jmp    L2\nL0:\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3796
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4452
            },
            "L1": {
                "label": "L1",
                "addr": 4428
            },
            "L2": {
                "label": "L2",
                "addr": 4419
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 12,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    0xecf(%rip),%r12        # 2000 <_fini+0xe8c>\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    1165 <func0+0x45>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax)\n  mov    (%rbx),%r14\n  mov    %r14,%rdi\n  call   1050 <strlen@plt>\n  cmp    %ebp,%eax\n  jle    115c <func0+0x3c>\n  mov    %eax,%ebp\n  mov    %r14,%r12\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  jne    1148 <func0+0x28>\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    D0(%rip),%r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax)\nL2:\n  mov    (%rbx),%r14\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  cmp    %ebp,%eax\n  jle    L1\n  mov    %eax,%ebp\n  mov    %r14,%r12\nL1:\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  jne    L2\nL0:\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3791
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4453
            },
            "L1": {
                "label": "L1",
                "addr": 4444
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 12,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char **strings, int count) {\n    char *out = \"\";\n    int longest_length = 0;\n    for (int i = 0; i < count; i++) {\n        int current_length = strlen(strings[i]);\n        if (current_length > longest_length) {\n            out = strings[i];\n            longest_length = current_length;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char *empty_array[] = {\"\"};\n    char *array1[] = {\"x\", \"y\", \"z\"};\n    char *array2[] = {\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"};\n\n    assert(strcmp(func0(empty_array, 0), \"\") == 0);\n    assert(strcmp(func0(array1, 3), \"x\") == 0);\n    assert(strcmp(func0(array2, 6), \"zzzz\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    0xecf(%rip),%r12        # 2000 <_fini+0xe8c>\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    1165 <func0+0x45>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax)\n  mov    (%rbx),%r14\n  mov    %r14,%rdi\n  call   1050 <strlen@plt>\n  cmp    %ebp,%eax\n  jle    115c <func0+0x3c>\n  mov    %eax,%ebp\n  mov    %r14,%r12\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  jne    1148 <func0+0x28>\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    D0(%rip),%r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax)\nL2:\n  mov    (%rbx),%r14\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  cmp    %ebp,%eax\n  jle    L1\n  mov    %eax,%ebp\n  mov    %r14,%r12\nL1:\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  jne    L2\nL0:\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3791
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4453
            },
            "L1": {
                "label": "L1",
                "addr": 4444
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 13,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  jmp    111f <func0+0x26>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x18(%rbp)\n  mov    %edx,-0x4(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\n  cmpl   $0x0,-0x18(%rbp)\n  jne    1109 <func0+0x10>\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  jmp    L0\nL1:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x18(%rbp)\n  mov    %edx,-0x4(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\nL0:\n  cmpl   $0x0,-0x18(%rbp)\n  jne    L1\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4383
            },
            "L1": {
                "label": "L1",
                "addr": 4361
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 13,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  test   %esi,%esi\n  je     1113 <func0+0x1a>\n  mov    %esi,%ecx\n  cltd\n  idiv   %esi\n  mov    %edx,%esi\n  mov    %ecx,%eax\n  test   %edx,%edx\n  jne    1103 <func0+0xa>\n  mov    %ecx,%eax\n  ret\n  mov    %edi,%ecx\n  jmp    1110 <func0+0x17>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  test   %esi,%esi\n  je     L0\nL1:\n  mov    %esi,%ecx\n  cltd\n  idiv   %esi\n  mov    %edx,%esi\n  mov    %ecx,%eax\n  test   %edx,%edx\n  jne    L1\nL2:\n  mov    %ecx,%eax\n  ret\nL0:\n  mov    %edi,%ecx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4371
            },
            "L1": {
                "label": "L1",
                "addr": 4355
            },
            "L2": {
                "label": "L2",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 13,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     1128 <func0+0x28>\n  nopl   0x0(%rax)\n  mov    %edx,%r8d\n  cltd\n  idiv   %r8d\n  mov    %r8d,%eax\n  test   %edx,%edx\n  jne    1110 <func0+0x10>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     L0\n  nopl   0x0(%rax)\nL1:\n  mov    %edx,%r8d\n  cltd\n  idiv   %r8d\n  mov    %r8d,%eax\n  test   %edx,%edx\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    %edi,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4392
            },
            "L1": {
                "label": "L1",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 13,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int a, int b) {\n    while (b != 0) {\n        int m = a % b;\n        a = b;\n        b = m;\n    }\n    return a;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 7) == 1);\n    assert(func0(10, 15) == 5);\n    assert(func0(49, 14) == 7);\n    assert(func0(144, 60) == 12);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     1128 <func0+0x28>\n  nopl   0x0(%rax)\n  mov    %edx,%r8d\n  cltd\n  idiv   %r8d\n  mov    %r8d,%eax\n  test   %edx,%edx\n  jne    1110 <func0+0x10>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     L0\n  nopl   0x0(%rax)\nL1:\n  mov    %edx,%r8d\n  cltd\n  idiv   %r8d\n  mov    %r8d,%eax\n  test   %edx,%edx\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    %edi,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4392
            },
            "L1": {
                "label": "L1",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 14,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x2c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0x30(%rbp)\n  jmp    12ae <func0+0x115>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  lea    0x2(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10d0 <realloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x28(%rbp),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x18(%rbp),%rax\n  lea    0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  add    $0x1,%rax\n  mov    -0x30(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  lea    (%rcx,%rdx,1),%rbx\n  mov    %rax,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10a0 <strcpy@plt>\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     11f9 <func0+0x60>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x2c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0x30(%rbp)\n  jmp    L0\nL1:\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  lea    0x2(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x28(%rbp),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x18(%rbp),%rax\n  lea    0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  add    $0x1,%rax\n  mov    -0x30(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  lea    (%rcx,%rdx,1),%rbx\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  addl   $0x1,-0x30(%rbp)\nL0:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L1\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4782
            },
            "L1": {
                "label": "L1",
                "addr": 4601
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 14,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r14\n  mov    %rsi,(%rsp)\n  call   10b0 <strlen@plt>\n  mov    %rax,%r15\n  mov    %rax,0x8(%rsp)\n  movslq %eax,%rdi\n  shl    $0x3,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%r13\n  lea    0x1(%r15),%edi\n  movslq %edi,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%rbx\n  movb   $0x0,(%rax)\n  test   %r15d,%r15d\n  jle    1243 <func0+0xaa>\n  lea    -0x1(%r15),%r15d\n  mov    $0x0,%r12d\n  mov    %rbx,%rdi\n  call   10b0 <strlen@plt>\n  mov    %rax,%rbp\n  lea    0x2(%rax),%rsi\n  mov    %rbx,%rdi\n  call   10d0 <realloc@plt>\n  mov    %rax,%rbx\n  movzbl (%r14,%r12,1),%eax\n  mov    %al,(%rbx,%rbp,1)\n  movb   $0x0,0x1(%rbx,%rbp,1)\n  mov    %rbx,%rdi\n  call   10b0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13,%r12,8)\n  mov    %rbx,%rsi\n  call   10a0 <strcpy@plt>\n  mov    %r12,%rax\n  add    $0x1,%r12\n  cmp    %r15,%rax\n  jne    11ef <func0+0x56>\n  mov    %rbx,%rdi\n  call   1090 <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%edx\n  mov    %edx,(%rax)\n  mov    %r13,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r14\n  mov    %rsi,(%rsp)\n  call   <strlen@plt>\n  mov    %rax,%r15\n  mov    %rax,0x8(%rsp)\n  movslq %eax,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  lea    0x1(%r15),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbx\n  movb   $0x0,(%rax)\n  test   %r15d,%r15d\n  jle    L0\n  lea    -0x1(%r15),%r15d\n  mov    $0x0,%r12d\nL1:\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  lea    0x2(%rax),%rsi\n  mov    %rbx,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbx\n  movzbl (%r14,%r12,1),%eax\n  mov    %al,(%rbx,%rbp,1)\n  movb   $0x0,0x1(%rbx,%rbp,1)\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13,%r12,8)\n  mov    %rbx,%rsi\n  call   <strcpy@plt>\n  mov    %r12,%rax\n  add    $0x1,%r12\n  cmp    %r15,%rax\n  jne    L1\nL0:\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%edx\n  mov    %edx,(%rax)\n  mov    %r13,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4675
            },
            "L1": {
                "label": "L1",
                "addr": 4591
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 14,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   10a0 <strlen@plt>\n  movslq %eax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x8(%rsp)\n  shl    $0x3,%rdi\n  call   10c0 <malloc@plt>\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r12\n  call   10c0 <malloc@plt>\n  movb   $0x0,(%rax)\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    124b <func0+0xab>\n  lea    -0x1(%rbx),%r13d\n  xor    %ebx,%ebx\n  mov    %r15,%rdi\n  call   10a0 <strlen@plt>\n  mov    %r15,%rdi\n  lea    0x2(%rax),%rsi\n  mov    %rax,%r14\n  call   10d0 <realloc@plt>\n  mov    %rax,%r15\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movb   $0x0,0x1(%r15,%r14,1)\n  mov    %r15,%rdi\n  mov    %al,(%r15,%r14,1)\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%r14\n  mov    %r14,%rdi\n  call   10c0 <malloc@plt>\n  mov    %r14,%rdx\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  mov    %rax,(%r12,%rbx,8)\n  call   10b0 <memcpy@plt>\n  mov    %rbx,%rax\n  add    $0x1,%rbx\n  cmp    %r13,%rax\n  jne    11f0 <func0+0x50>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   <strlen@plt>\n  movslq %eax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x8(%rsp)\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r12\n  call   <malloc@plt>\n  movb   $0x0,(%rax)\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    L0\n  lea    -0x1(%rbx),%r13d\n  xor    %ebx,%ebx\nL1:\n  mov    %r15,%rdi\n  call   <strlen@plt>\n  mov    %r15,%rdi\n  lea    0x2(%rax),%rsi\n  mov    %rax,%r14\n  call   <realloc@plt>\n  mov    %rax,%r15\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movb   $0x0,0x1(%r15,%r14,1)\n  mov    %r15,%rdi\n  mov    %al,(%r15,%r14,1)\n  call   <strlen@plt>\n  lea    0x1(%rax),%r14\n  mov    %r14,%rdi\n  call   <malloc@plt>\n  mov    %r14,%rdx\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  mov    %rax,(%r12,%rbx,8)\n  call   <memcpy@plt>\n  mov    %rbx,%rax\n  add    $0x1,%rbx\n  cmp    %r13,%rax\n  jne    L1\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4683
            },
            "L1": {
                "label": "L1",
                "addr": 4592
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 14,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(const char *str, int *count) {\n    int len = strlen(str);\n    char **out = malloc(len * sizeof(char *));\n    \n    char *current = malloc(len + 1);\n    current[0] = '\\0';\n\n    for (int i = 0; i < len; ++i) {\n        size_t current_len = strlen(current);\n        current = realloc(current, current_len + 2);\n        current[current_len] = str[i];\n        current[current_len + 1] = '\\0';\n\n        out[i] = malloc(strlen(current) + 1);\n        strcpy(out[i], current);\n    }\n    free(current);\n    \n    *count = len;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_prefixes(char **prefixes, int count) {\n    for (int i = 0; i < count; i++) {\n        free(prefixes[i]);\n    }\n    free(prefixes);\n}\n\nint main() {\n    int count;\n    char **result;\n    \n    result = func0(\"\", &count);\n    assert(issame(result, 0, NULL, 0));\n    free_prefixes(result, count);\n\n    char *expected1[] = {\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\"};\n    result = func0(\"asdfgh\", &count);\n    assert(issame(result, count, expected1, 6));\n    free_prefixes(result, count);\n\n    char *expected2[] = {\"W\", \"WW\", \"WWW\"};\n    result = func0(\"WWW\", &count);\n    assert(issame(result, count, expected2, 3));\n    free_prefixes(result, count);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   10a0 <strlen@plt>\n  movslq %eax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x8(%rsp)\n  shl    $0x3,%rdi\n  call   10c0 <malloc@plt>\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r12\n  call   10c0 <malloc@plt>\n  movb   $0x0,(%rax)\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    124b <func0+0xab>\n  lea    -0x1(%rbx),%r13d\n  xor    %ebx,%ebx\n  mov    %r15,%rdi\n  call   10a0 <strlen@plt>\n  mov    %r15,%rdi\n  lea    0x2(%rax),%rsi\n  mov    %rax,%r14\n  call   10d0 <realloc@plt>\n  mov    %rax,%r15\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movb   $0x0,0x1(%r15,%r14,1)\n  mov    %r15,%rdi\n  mov    %al,(%r15,%r14,1)\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%r14\n  mov    %r14,%rdi\n  call   10c0 <malloc@plt>\n  mov    %r14,%rdx\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  mov    %rax,(%r12,%rbx,8)\n  call   10b0 <memcpy@plt>\n  mov    %rbx,%rax\n  add    $0x1,%rbx\n  cmp    %rax,%r13\n  jne    11f0 <func0+0x50>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,(%rsp)\n  call   <strlen@plt>\n  movslq %eax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x8(%rsp)\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  lea    0x1(%rbx),%edi\n  movslq %edi,%rdi\n  mov    %rax,%r12\n  call   <malloc@plt>\n  movb   $0x0,(%rax)\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    L0\n  lea    -0x1(%rbx),%r13d\n  xor    %ebx,%ebx\nL1:\n  mov    %r15,%rdi\n  call   <strlen@plt>\n  mov    %r15,%rdi\n  lea    0x2(%rax),%rsi\n  mov    %rax,%r14\n  call   <realloc@plt>\n  mov    %rax,%r15\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movb   $0x0,0x1(%r15,%r14,1)\n  mov    %r15,%rdi\n  mov    %al,(%r15,%r14,1)\n  call   <strlen@plt>\n  lea    0x1(%rax),%r14\n  mov    %r14,%rdi\n  call   <malloc@plt>\n  mov    %r14,%rdx\n  mov    %r15,%rsi\n  mov    %rax,%rdi\n  mov    %rax,(%r12,%rbx,8)\n  call   <memcpy@plt>\n  mov    %rbx,%rax\n  add    $0x1,%rbx\n  cmp    %rax,%r13\n  jne    L1\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4683
            },
            "L1": {
                "label": "L1",
                "addr": 4592
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 15,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  movl   $0x2,-0x1c(%rbp)\n  movl   $0x1,-0x18(%rbp)\n  jmp    11a2 <func0+0x49>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,%ecx\n  lea    0xe7c(%rip),%rax        # 2000 <_fini+0xdcc>\n  mov    %rax,%rdx\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  mov    $0x0,%eax\n  call   1070 <snprintf@plt>\n  add    %eax,-0x1c(%rbp)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    1178 <func0+0x1f>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  mov    %rax,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    11c9 <func0+0x70>\n  mov    $0x0,%eax\n  jmp    122f <func0+0xd6>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  lea    0xe28(%rip),%rdx        # 2004 <_fini+0xdd0>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1090 <sprintf@plt>\n  cltq\n  add    %rax,-0x10(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    1223 <func0+0xca>\n  mov    -0x14(%rbp),%edx\n  mov    -0x10(%rbp),%rax\n  lea    0xdf7(%rip),%rcx        # 2000 <_fini+0xdcc>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1090 <sprintf@plt>\n  cltq\n  add    %rax,-0x10(%rbp)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    11fb <func0+0xa2>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  movl   $0x2,-0x1c(%rbp)\n  movl   $0x1,-0x18(%rbp)\n  jmp    L0\nL1:\n  mov    -0x18(%rbp),%eax\n  mov    %eax,%ecx\n  lea    D0(%rip),%rax\n  mov    %rax,%rdx\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  mov    $0x0,%eax\n  call   <snprintf@plt>\n  add    %eax,-0x1c(%rbp)\n  addl   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    L1\n  mov    -0x1c(%rbp),%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L2\n  mov    $0x0,%eax\n  jmp    L3\nL2:\n  mov    -0x8(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  cltq\n  add    %rax,-0x10(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    L4\nL5:\n  mov    -0x14(%rbp),%edx\n  mov    -0x10(%rbp),%rax\n  lea    D0(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  cltq\n  add    %rax,-0x10(%rbp)\n  addl   $0x1,-0x14(%rbp)\nL4:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    L5\n  mov    -0x8(%rbp),%rax\nL3:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3708,
                    3575
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3624
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4514
            },
            "L1": {
                "label": "L1",
                "addr": 4472
            },
            "L2": {
                "label": "L2",
                "addr": 4553
            },
            "L3": {
                "label": "L3",
                "addr": 4655
            },
            "L4": {
                "label": "L4",
                "addr": 4643
            },
            "L5": {
                "label": "L5",
                "addr": 4603
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "202564003000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\" %d\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"0\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 15,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    1213 <func0+0xba>\n  mov    %edi,%r12d\n  lea    0x1(%rdi),%r14d\n  mov    $0x1,%ebx\n  mov    $0x2,%ebp\n  lea    0xe7b(%rip),%r13        # 2000 <_fini+0xdd4>\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  mov    $0x1,%edx\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  mov    $0x0,%eax\n  call   1070 <__snprintf_chk@plt>\n  add    %eax,%ebp\n  add    $0x1,%ebx\n  cmp    %r14d,%ebx\n  jne    1185 <func0+0x2c>\n  movslq %ebp,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%r14\n  test   %rax,%rax\n  je     1207 <func0+0xae>\n  movw   $0x30,(%r14)\n  lea    0x1(%r14),%rbp\n  mov    $0x1,%ebx\n  lea    0xe25(%rip),%r13        # 2000 <_fini+0xdd4>\n  mov    %ebx,%r8d\n  mov    %r13,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  mov    %rbp,%rdi\n  mov    $0x0,%eax\n  call   1090 <__sprintf_chk@plt>\n  cltq\n  add    %rax,%rbp\n  add    $0x1,%ebx\n  cmp    %ebx,%r12d\n  jge    11db <func0+0x82>\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x2,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r14\n  test   %rax,%rax\n  je     1207 <func0+0xae>\n  movw   $0x30,(%rax)\n  jmp    1207 <func0+0xae>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%r12d\n  lea    0x1(%rdi),%r14d\n  mov    $0x1,%ebx\n  mov    $0x2,%ebp\n  lea    D0(%rip),%r13\nL1:\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  mov    $0x1,%edx\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  mov    $0x0,%eax\n  call   <__snprintf_chk@plt>\n  add    %eax,%ebp\n  add    $0x1,%ebx\n  cmp    %r14d,%ebx\n  jne    L1\n  movslq %ebp,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %rax,%rax\n  je     L2\n  movw   $0x30,(%r14)\n  lea    0x1(%r14),%rbp\n  mov    $0x1,%ebx\n  lea    D0(%rip),%r13\nL3:\n  mov    %ebx,%r8d\n  mov    %r13,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  mov    %rbp,%rdi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\n  cltq\n  add    %rax,%rbp\n  add    $0x1,%ebx\n  cmp    %ebx,%r12d\n  jge    L3\nL2:\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  mov    $0x2,%edi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %rax,%rax\n  je     L2\n  movw   $0x30,(%rax)\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3707,
                    3621
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4627
            },
            "L1": {
                "label": "L1",
                "addr": 4485
            },
            "L2": {
                "label": "L2",
                "addr": 4615
            },
            "L3": {
                "label": "L3",
                "addr": 4571
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "20256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\" %d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 15,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    1220 <func0+0xc0>\n  lea    0x1(%rdi),%ebp\n  mov    $0x1,%ebx\n  mov    $0x2,%r12d\n  lea    0xe77(%rip),%r13        # 2000 <_fini+0xdb4>\n  nopl   0x0(%rax)\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  xor    %esi,%esi\n  mov    $0x1,%edx\n  xor    %edi,%edi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   1070 <__snprintf_chk@plt>\n  add    %eax,%r12d\n  cmp    %ebp,%ebx\n  jne    1190 <func0+0x30>\n  movslq %r12d,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     1246 <func0+0xe6>\n  mov    $0x30,%eax\n  lea    0x1(%r13),%r14\n  mov    $0x1,%ebx\n  mov    %ax,0x0(%r13)\n  lea    0xe1f(%rip),%r12        # 2000 <_fini+0xdb4>\n  nopl   0x0(%rax)\n  mov    %ebx,%r8d\n  mov    %r14,%rdi\n  mov    %r12,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   1090 <__sprintf_chk@plt>\n  cltq\n  add    %rax,%r14\n  cmp    %ebp,%ebx\n  jne    11e8 <func0+0x88>\n  pop    %rbx\n  mov    %r13,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\n  mov    $0x2,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     1246 <func0+0xe6>\n  mov    $0x30,%edx\n  mov    %dx,(%rax)\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r13d,%r13d\n  jmp    1210 <func0+0xb0>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    L0\n  lea    0x1(%rdi),%ebp\n  mov    $0x1,%ebx\n  mov    $0x2,%r12d\n  lea    D0(%rip),%r13\n  nopl   0x0(%rax)\nL1:\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  xor    %esi,%esi\n  mov    $0x1,%edx\n  xor    %edi,%edi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   <__snprintf_chk@plt>\n  add    %eax,%r12d\n  cmp    %ebp,%ebx\n  jne    L1\n  movslq %r12d,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     L2\n  mov    $0x30,%eax\n  lea    0x1(%r13),%r14\n  mov    $0x1,%ebx\n  mov    %ax,0x0(%r13)\n  lea    D0(%rip),%r12\n  nopl   0x0(%rax)\nL3:\n  mov    %ebx,%r8d\n  mov    %r14,%rdi\n  mov    %r12,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   <__sprintf_chk@plt>\n  cltq\n  add    %rax,%r14\n  cmp    %ebp,%ebx\n  jne    L3\nL4:\n  pop    %rbx\n  mov    %r13,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x2,%edi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     L2\n  mov    $0x30,%edx\n  mov    %dx,(%rax)\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL2:\n  xor    %r13d,%r13d\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3703,
                    3615
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4640
            },
            "L1": {
                "label": "L1",
                "addr": 4496
            },
            "L2": {
                "label": "L2",
                "addr": 4678
            },
            "L3": {
                "label": "L3",
                "addr": 4584
            },
            "L4": {
                "label": "L4",
                "addr": 4624
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "20256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\" %d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 15,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar *func0(int n) {\n    int len = 2; \n    for (int i = 1; i <= n; ++i) {\n        len += snprintf(NULL, 0, \" %d\", i);\n    }\n\n    char *out = malloc(len);\n    if (!out) {\n        return NULL;\n    }\n    \n    char *ptr = out;\n    ptr += sprintf(ptr, \"0\");\n    for (int i = 1; i <= n; ++i) {\n        ptr += sprintf(ptr, \" %d\", i);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *result;\n\n    result = func0(0);\n    assert(strcmp(result, \"0\") == 0);\n    free(result);\n\n    result = func0(3);\n    assert(strcmp(result, \"0 1 2 3\") == 0);\n    free(result);\n\n    result = func0(10);\n    assert(strcmp(result, \"0 1 2 3 4 5 6 7 8 9 10\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    1220 <func0+0xc0>\n  lea    0x1(%rdi),%ebp\n  mov    $0x1,%ebx\n  mov    $0x2,%r12d\n  lea    0xe77(%rip),%r13        # 2000 <_fini+0xdb4>\n  nopl   0x0(%rax)\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  xor    %esi,%esi\n  mov    $0x1,%edx\n  xor    %edi,%edi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   1070 <__snprintf_chk@plt>\n  add    %eax,%r12d\n  cmp    %ebp,%ebx\n  jne    1190 <func0+0x30>\n  movslq %r12d,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     1246 <func0+0xe6>\n  mov    $0x30,%eax\n  lea    0x1(%r13),%r14\n  mov    $0x1,%ebx\n  mov    %ax,0x0(%r13)\n  lea    0xe1f(%rip),%r12        # 2000 <_fini+0xdb4>\n  nopl   0x0(%rax)\n  mov    %ebx,%r8d\n  mov    %r14,%rdi\n  mov    %r12,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   1090 <__sprintf_chk@plt>\n  cltq\n  add    %rax,%r14\n  cmp    %ebp,%ebx\n  jne    11e8 <func0+0x88>\n  pop    %rbx\n  mov    %r13,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\n  mov    $0x2,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     1246 <func0+0xe6>\n  mov    $0x30,%edx\n  mov    %dx,(%rax)\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r13d,%r13d\n  jmp    1210 <func0+0xb0>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %edi,%edi\n  jle    L0\n  lea    0x1(%rdi),%ebp\n  mov    $0x1,%ebx\n  mov    $0x2,%r12d\n  lea    D0(%rip),%r13\n  nopl   0x0(%rax)\nL1:\n  mov    %ebx,%r9d\n  mov    %r13,%r8\n  mov    $0xffffffffffffffff,%rcx\n  xor    %esi,%esi\n  mov    $0x1,%edx\n  xor    %edi,%edi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   <__snprintf_chk@plt>\n  add    %eax,%r12d\n  cmp    %ebp,%ebx\n  jne    L1\n  movslq %r12d,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     L2\n  mov    $0x30,%eax\n  lea    0x1(%r13),%r14\n  mov    $0x1,%ebx\n  mov    %ax,0x0(%r13)\n  lea    D0(%rip),%r12\n  nopl   0x0(%rax)\nL3:\n  mov    %ebx,%r8d\n  mov    %r14,%rdi\n  mov    %r12,%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%ebx\n  call   <__sprintf_chk@plt>\n  cltq\n  add    %rax,%r14\n  cmp    %ebp,%ebx\n  jne    L3\nL4:\n  pop    %rbx\n  mov    %r13,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x2,%edi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %rax,%rax\n  je     L2\n  mov    $0x30,%edx\n  mov    %dx,(%rax)\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL2:\n  xor    %r13d,%r13d\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3703,
                    3615
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4640
            },
            "L1": {
                "label": "L1",
                "addr": 4496
            },
            "L2": {
                "label": "L2",
                "addr": 4678
            },
            "L3": {
                "label": "L3",
                "addr": 4584
            },
            "L4": {
                "label": "L4",
                "addr": 4624
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "20256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\" %d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 16,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x430,%rsp\n  mov    %rdi,-0x428(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x418(%rbp)\n  lea    -0x410(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x80,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x414(%rbp)\n  jmp    1231 <func0+0xd8>\n  mov    -0x414(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x428(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   1080 <tolower@plt>\n  mov    %al,-0x419(%rbp)\n  movsbl -0x419(%rbp),%eax\n  cltq\n  mov    -0x410(%rbp,%rax,4),%eax\n  test   %eax,%eax\n  jne    122a <func0+0xd1>\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x419(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     122a <func0+0xd1>\n  movsbl -0x419(%rbp),%eax\n  cltq\n  movl   $0x1,-0x410(%rbp,%rax,4)\n  addl   $0x1,-0x418(%rbp)\n  addl   $0x1,-0x414(%rbp)\n  mov    -0x414(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x428(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11ae <func0+0x55>\n  mov    -0x418(%rbp),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     1269 <func0+0x110>\n  call   1070 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x430,%rsp\n  mov    %rdi,-0x428(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x418(%rbp)\n  lea    -0x410(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x80,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x414(%rbp)\n  jmp    L0\nL2:\n  mov    -0x414(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x428(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   <tolower@plt>\n  mov    %al,-0x419(%rbp)\n  movsbl -0x419(%rbp),%eax\n  cltq\n  mov    -0x410(%rbp,%rax,4),%eax\n  test   %eax,%eax\n  jne    L1\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x419(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     L1\n  movsbl -0x419(%rbp),%eax\n  cltq\n  movl   $0x1,-0x410(%rbp,%rax,4)\n  addl   $0x1,-0x418(%rbp)\nL1:\n  addl   $0x1,-0x414(%rbp)\nL0:\n  mov    -0x414(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x428(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\n  mov    -0x418(%rbp),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L3\n  call   <__stack_chk_fail@plt>\nL3:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4657
            },
            "L1": {
                "label": "L1",
                "addr": 4650
            },
            "L2": {
                "label": "L2",
                "addr": 4526
            },
            "L3": {
                "label": "L3",
                "addr": 4713
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 16,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  mov    %rdi,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x80,%ecx\n  rep stos %rax,%es:(%rdi)\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     11ed <func0+0x94>\n  call   1080 <__ctype_tolower_loc@plt>\n  mov    (%rax),%r12\n  add    $0x1,%rbp\n  mov    $0x0,%r13d\n  jmp    11b5 <func0+0x5c>\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     11f3 <func0+0x9a>\n  movzbl %bl,%ebx\n  mov    (%r12,%rbx,4),%ebx\n  movsbl %bl,%r14d\n  movsbq %bl,%rax\n  cmpl   $0x0,(%rsp,%rax,4)\n  jne    11a9 <func0+0x50>\n  call   1090 <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     11a9 <func0+0x50>\n  movslq %r14d,%r14\n  movl   $0x1,(%rsp,%r14,4)\n  add    $0x1,%r13d\n  jmp    11a9 <func0+0x50>\n  mov    $0x0,%r13d\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1219 <func0+0xc0>\n  mov    %r13d,%eax\n  add    $0x410,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  mov    %rdi,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x80,%ecx\n  rep stos %rax,%es:(%rdi)\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     L0\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%r12\n  add    $0x1,%rbp\n  mov    $0x0,%r13d\n  jmp    L1\nL3:\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\nL1:\n  movzbl %bl,%ebx\n  mov    (%r12,%rbx,4),%ebx\n  movsbl %bl,%r14d\n  movsbq %bl,%rax\n  cmpl   $0x0,(%rsp,%rax,4)\n  jne    L3\n  call   <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     L3\n  movslq %r14d,%r14\n  movl   $0x1,(%rsp,%r14,4)\n  add    $0x1,%r13d\n  jmp    L3\nL0:\n  mov    $0x0,%r13d\nL2:\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L4\n  mov    %r13d,%eax\n  add    $0x410,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL4:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4589
            },
            "L1": {
                "label": "L1",
                "addr": 4533
            },
            "L2": {
                "label": "L2",
                "addr": 4595
            },
            "L3": {
                "label": "L3",
                "addr": 4521
            },
            "L4": {
                "label": "L4",
                "addr": 4633
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 16,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    $0x80,%ecx\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  movzbl 0x0(%rbp),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  test   %bl,%bl\n  je     1210 <func0+0xb0>\n  call   1080 <__ctype_tolower_loc@plt>\n  add    $0x1,%rbp\n  xor    %r12d,%r12d\n  mov    (%rax),%r14\n  nopl   0x0(%rax,%rax,1)\n  mov    (%r14,%rbx,4),%ebx\n  movsbq %bl,%r13\n  mov    (%rsp,%r13,4),%eax\n  test   %eax,%eax\n  jne    11de <func0+0x7e>\n  call   1090 <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     11de <func0+0x7e>\n  movl   $0x1,(%rsp,%r13,4)\n  add    $0x1,%r12d\n  movzbl 0x0(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  jne    11b0 <func0+0x50>\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1215 <func0+0xb5>\n  add    $0x410,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r12d,%r12d\n  jmp    11ea <func0+0x8a>\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    $0x80,%ecx\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  movzbl 0x0(%rbp),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  test   %bl,%bl\n  je     L0\n  call   <__ctype_tolower_loc@plt>\n  add    $0x1,%rbp\n  xor    %r12d,%r12d\n  mov    (%rax),%r14\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    (%r14,%rbx,4),%ebx\n  movsbq %bl,%r13\n  mov    (%rsp,%r13,4),%eax\n  test   %eax,%eax\n  jne    L1\n  call   <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     L1\n  movl   $0x1,(%rsp,%r13,4)\n  add    $0x1,%r12d\nL1:\n  movzbl 0x0(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  jne    L2\nL4:\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  add    $0x410,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  xor    %r12d,%r12d\n  jmp    L4\nL3:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4624
            },
            "L1": {
                "label": "L1",
                "addr": 4574
            },
            "L2": {
                "label": "L2",
                "addr": 4528
            },
            "L3": {
                "label": "L3",
                "addr": 4629
            },
            "L4": {
                "label": "L4",
                "addr": 4586
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 16,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *str) {\n    int count = 0;\n    int char_map[256] = {0};\n    int index;\n    \n    for (index = 0; str[index]; index++) {\n        char ch = tolower((unsigned char)str[index]);\n        if (char_map[ch] == 0 && isalpha((unsigned char)ch)) {\n            char_map[ch] = 1;\n            count++;\n        }\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abcde\") == 5);\n    assert(func0(\"abcdecadeCADE\") == 5);\n    assert(func0(\"aaaaAAAAaaaa\") == 1);\n    assert(func0(\"Jerry jERRY JeRRRY\") == 4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    $0x80,%ecx\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  movzbl 0x0(%rbp),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  test   %bl,%bl\n  je     1210 <func0+0xb0>\n  call   1080 <__ctype_tolower_loc@plt>\n  add    $0x1,%rbp\n  xor    %r12d,%r12d\n  mov    (%rax),%r14\n  nopl   0x0(%rax,%rax,1)\n  mov    (%r14,%rbx,4),%ebx\n  movsbq %bl,%r13\n  mov    (%rsp,%r13,4),%eax\n  test   %eax,%eax\n  jne    11de <func0+0x7e>\n  call   1090 <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     11de <func0+0x7e>\n  movl   $0x1,(%rsp,%r13,4)\n  add    $0x1,%r12d\n  movzbl 0x0(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  jne    11b0 <func0+0x50>\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1215 <func0+0xb5>\n  add    $0x410,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r12d,%r12d\n  jmp    11ea <func0+0x8a>\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    $0x80,%ecx\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x410,%rsp\n  movzbl 0x0(%rbp),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x408(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  test   %bl,%bl\n  je     L0\n  call   <__ctype_tolower_loc@plt>\n  add    $0x1,%rbp\n  xor    %r12d,%r12d\n  mov    (%rax),%r14\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    (%r14,%rbx,4),%ebx\n  movsbq %bl,%r13\n  mov    (%rsp,%r13,4),%eax\n  test   %eax,%eax\n  jne    L1\n  call   <__ctype_b_loc@plt>\n  movzbl %bl,%ebx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rbx,2)\n  je     L1\n  movl   $0x1,(%rsp,%r13,4)\n  add    $0x1,%r12d\nL1:\n  movzbl 0x0(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  jne    L2\nL4:\n  mov    0x408(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  add    $0x410,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  xor    %r12d,%r12d\n  jmp    L4\nL3:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4624
            },
            "L1": {
                "label": "L1",
                "addr": 4574
            },
            "L2": {
                "label": "L2",
                "addr": 4528
            },
            "L3": {
                "label": "L3",
                "addr": 4629
            },
            "L4": {
                "label": "L4",
                "addr": 4586
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 17,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movw   $0x0,-0xb(%rbp)\n  movb   $0x0,-0x9(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strlen@plt>\n  add    $0x1,%eax\n  mov    %eax,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   1100 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x48(%rbp),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10c0 <strcpy@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strlen@plt>\n  mov    %rax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movw   $0x20,(%rax)\n  movl   $0x0,-0x30(%rbp)\n  jmp    1444 <func0+0x26b>\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  jne    13ff <func0+0x226>\n  lea    -0xb(%rbp),%rax\n  lea    0xd61(%rip),%rdx        # 2000 <_fini+0xb80>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    130b <func0+0x132>\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    12eb <func0+0x112>\n  cmpl   $0x0,-0x34(%rbp)\n  jle    12c3 <func0+0xea>\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    12c8 <func0+0xef>\n  mov    $0x4,%eax\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x4,(%rax)\n  lea    -0xb(%rbp),%rax\n  lea    0xcec(%rip),%rdx        # 2002 <_fini+0xb82>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    1382 <func0+0x1a9>\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    1362 <func0+0x189>\n  cmpl   $0x0,-0x34(%rbp)\n  jle    133a <func0+0x161>\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    133f <func0+0x166>\n  mov    $0x4,%eax\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x2,(%rax)\n  lea    -0xb(%rbp),%rax\n  lea    0xc78(%rip),%rdx        # 2005 <_fini+0xb85>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    13f9 <func0+0x220>\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    13d9 <func0+0x200>\n  cmpl   $0x0,-0x34(%rbp)\n  jle    13b1 <func0+0x1d8>\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    13b6 <func0+0x1dd>\n  mov    $0x4,%eax\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x1,(%rax)\n  movb   $0x0,-0xb(%rbp)\n  jmp    1440 <func0+0x267>\n  lea    -0xb(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  cmpq   $0x1,-0x18(%rbp)\n  ja     1440 <func0+0x267>\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  lea    -0xb(%rbp),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    %al,(%rdx)\n  mov    -0x18(%rbp),%rax\n  add    $0x1,%rax\n  movb   $0x0,-0xb(%rbp,%rax,1)\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     127c <func0+0xa3>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <free@plt>\n  mov    -0x50(%rbp),%rax\n  mov    -0x38(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     147d <func0+0x2a4>\n  call   10e0 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movw   $0x0,-0xb(%rbp)\n  movb   $0x0,-0x9(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  add    $0x1,%eax\n  mov    %eax,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x48(%rbp),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movw   $0x20,(%rax)\n  movl   $0x0,-0x30(%rbp)\n  jmp    L0\nL15:\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  jne    L1\n  lea    -0xb(%rbp),%rax\n  lea    D0(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L2\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    L3\n  cmpl   $0x0,-0x34(%rbp)\n  jle    L4\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    L5\nL4:\n  mov    $0x4,%eax\nL5:\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x28(%rbp)\nL3:\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x4,(%rax)\nL2:\n  lea    -0xb(%rbp),%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L6\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    L7\n  cmpl   $0x0,-0x34(%rbp)\n  jle    L8\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    L9\nL8:\n  mov    $0x4,%eax\nL9:\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x28(%rbp)\nL7:\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x2,(%rax)\nL6:\n  lea    -0xb(%rbp),%rax\n  lea    D2(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L10\n  mov    -0x38(%rbp),%eax\n  cmp    -0x34(%rbp),%eax\n  jne    L11\n  cmpl   $0x0,-0x34(%rbp)\n  jle    L12\n  mov    -0x34(%rbp),%eax\n  add    %eax,%eax\n  jmp    L13\nL12:\n  mov    $0x4,%eax\nL13:\n  mov    %eax,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x28(%rbp)\nL11:\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x1,(%rax)\nL10:\n  movb   $0x0,-0xb(%rbp)\n  jmp    L14\nL1:\n  lea    -0xb(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  cmpq   $0x1,-0x18(%rbp)\n  ja     L14\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  lea    -0xb(%rbp),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    %al,(%rdx)\n  mov    -0x18(%rbp),%rax\n  add    $0x1,%rax\n  movb   $0x0,-0xb(%rbp,%rax,1)\nL14:\n  addl   $0x1,-0x30(%rbp)\nL0:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L15\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x50(%rbp),%rax\n  mov    -0x38(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L16\n  call   <__stack_chk_fail@plt>\nL16:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3425
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8194,
                "bias": [
                    3308
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8197,
                "bias": [
                    3192
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5188
            },
            "L1": {
                "label": "L1",
                "addr": 5119
            },
            "L2": {
                "label": "L2",
                "addr": 4875
            },
            "L3": {
                "label": "L3",
                "addr": 4843
            },
            "L4": {
                "label": "L4",
                "addr": 4803
            },
            "L5": {
                "label": "L5",
                "addr": 4808
            },
            "L6": {
                "label": "L6",
                "addr": 4994
            },
            "L7": {
                "label": "L7",
                "addr": 4962
            },
            "L8": {
                "label": "L8",
                "addr": 4922
            },
            "L9": {
                "label": "L9",
                "addr": 4927
            },
            "L10": {
                "label": "L10",
                "addr": 5113
            },
            "L11": {
                "label": "L11",
                "addr": 5081
            },
            "L12": {
                "label": "L12",
                "addr": 5041
            },
            "L13": {
                "label": "L13",
                "addr": 5046
            },
            "L14": {
                "label": "L14",
                "addr": 5184
            },
            "L15": {
                "label": "L15",
                "addr": 4732
            },
            "L16": {
                "label": "L16",
                "addr": 5245
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6f006f7c002e7c00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"o\""
                },
                "0x2002": {
                    "type": "string",
                    "value": "\"o|\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\".|\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 17,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  movw   $0x0,0x25(%rsp)\n  movb   $0x0,0x27(%rsp)\n  call   10d0 <strlen@plt>\n  mov    %rax,%rbp\n  lea    0x2(%rax),%edi\n  movslq %edi,%rdi\n  call   1100 <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  mov    %rbx,%rsi\n  mov    %rax,%rbx\n  mov    %rax,%rdi\n  call   10c0 <strcpy@plt>\n  mov    %rbx,%rdi\n  call   10d0 <strlen@plt>\n  movw   $0x20,(%rbx,%rax,1)\n  lea    0x1(%rbp),%eax\n  test   %eax,%eax\n  jle    13bb <func0+0x1e2>\n  mov    %ebp,%ebp\n  lea    0x1(%rbx,%rbp,1),%r15\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\n  movq   $0x0,0x8(%rsp)\n  lea    0x25(%rsp),%r13\n  jmp    130f <func0+0x136>\n  lea    0xd86(%rip),%rsi        # 2000 <_fini+0xbfc>\n  mov    %r13,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    12a1 <func0+0xc8>\n  cmp    %r14d,%ebp\n  je     1337 <func0+0x15e>\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x4,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\n  lea    0xd5a(%rip),%rsi        # 2002 <_fini+0xbfe>\n  mov    %r13,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    12cf <func0+0xf6>\n  cmp    %r14d,%ebp\n  je     1363 <func0+0x18a>\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x2,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\n  lea    0xd2f(%rip),%rsi        # 2005 <_fini+0xc01>\n  mov    %r13,%rdi\n  call   10f0 <strcmp@plt>\n  test   %eax,%eax\n  jne    12fd <func0+0x124>\n  cmp    %r14d,%ebp\n  je     138f <func0+0x1b6>\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x1,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\n  movb   $0x0,0x25(%rsp)\n  add    $0x1,%rbx\n  cmp    %r15,%rbx\n  je     13c9 <func0+0x1f0>\n  movzbl (%rbx),%r12d\n  cmp    $0x20,%r12b\n  je     1273 <func0+0x9a>\n  mov    %r13,%rdi\n  call   10d0 <strlen@plt>\n  cmp    $0x1,%rax\n  ja     1302 <func0+0x129>\n  mov    %r12b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\n  jmp    1302 <func0+0x129>\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    128f <func0+0xb6>\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    12bd <func0+0xe4>\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   1110 <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    12eb <func0+0x112>\n  mov    $0x0,%ebp\n  movq   $0x0,0x8(%rsp)\n  mov    0x10(%rsp),%rdi\n  call   10b0 <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %ebp,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    13fe <func0+0x225>\n  mov    0x8(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10e0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  movw   $0x0,0x25(%rsp)\n  movb   $0x0,0x27(%rsp)\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  lea    0x2(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  mov    %rbx,%rsi\n  mov    %rax,%rbx\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  movw   $0x20,(%rbx,%rax,1)\n  lea    0x1(%rbp),%eax\n  test   %eax,%eax\n  jle    L0\n  mov    %ebp,%ebp\n  lea    0x1(%rbx,%rbp,1),%r15\n  mov    $0x0,%r14d\n  mov    $0x0,%ebp\n  movq   $0x0,0x8(%rsp)\n  lea    0x25(%rsp),%r13\n  jmp    L1\nL9:\n  lea    D0(%rip),%rsi\n  mov    %r13,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L2\n  cmp    %r14d,%ebp\n  je     L3\nL11:\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x4,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\nL2:\n  lea    D1(%rip),%rsi\n  mov    %r13,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L4\n  cmp    %r14d,%ebp\n  je     L5\nL12:\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x2,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\nL4:\n  lea    D2(%rip),%rsi\n  mov    %r13,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L6\n  cmp    %r14d,%ebp\n  je     L7\nL13:\n  movslq %ebp,%rax\n  mov    0x8(%rsp),%rcx\n  movl   $0x1,(%rcx,%rax,4)\n  lea    0x1(%rbp),%ebp\nL6:\n  movb   $0x0,0x25(%rsp)\nL10:\n  add    $0x1,%rbx\n  cmp    %r15,%rbx\n  je     L8\nL1:\n  movzbl (%rbx),%r12d\n  cmp    $0x20,%r12b\n  je     L9\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  cmp    $0x1,%rax\n  ja     L10\n  mov    %r12b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\n  jmp    L10\nL3:\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    L11\nL5:\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    L12\nL7:\n  lea    (%r14,%r14,1),%eax\n  test   %r14d,%r14d\n  mov    $0x4,%r14d\n  cmovg  %eax,%r14d\n  movslq %r14d,%rsi\n  shl    $0x2,%rsi\n  mov    0x8(%rsp),%rdi\n  call   <realloc@plt>\n  mov    %rax,0x8(%rsp)\n  jmp    L13\nL0:\n  mov    $0x0,%ebp\n  movq   $0x0,0x8(%rsp)\nL8:\n  mov    0x10(%rsp),%rdi\n  call   <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %ebp,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L14\n  mov    0x8(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL14:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3462
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8194,
                "bias": [
                    3418
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8197,
                "bias": [
                    3375
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5051
            },
            "L1": {
                "label": "L1",
                "addr": 4879
            },
            "L2": {
                "label": "L2",
                "addr": 4769
            },
            "L3": {
                "label": "L3",
                "addr": 4919
            },
            "L4": {
                "label": "L4",
                "addr": 4815
            },
            "L5": {
                "label": "L5",
                "addr": 4963
            },
            "L6": {
                "label": "L6",
                "addr": 4861
            },
            "L7": {
                "label": "L7",
                "addr": 5007
            },
            "L8": {
                "label": "L8",
                "addr": 5065
            },
            "L9": {
                "label": "L9",
                "addr": 4723
            },
            "L10": {
                "label": "L10",
                "addr": 4866
            },
            "L11": {
                "label": "L11",
                "addr": 4751
            },
            "L12": {
                "label": "L12",
                "addr": 4797
            },
            "L13": {
                "label": "L13",
                "addr": 4843
            },
            "L14": {
                "label": "L14",
                "addr": 5118
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6f006f7c002e7c00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"o\""
                },
                "0x2002": {
                    "type": "string",
                    "value": "\"o|\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\".|\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 17,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  movb   $0x0,0x27(%rsp)\n  mov    %ax,0x25(%rsp)\n  call   10b0 <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbp\n  movslq %edi,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rbp,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x10(%rsp)\n  call   10d0 <memcpy@plt>\n  mov    $0x20,%edx\n  lea    0x1(%rbp),%eax\n  mov    %dx,(%rbx,%rbp,1)\n  test   %eax,%eax\n  jle    1400 <func0+0x240>\n  mov    %ebp,%ebp\n  movl   $0x0,0xc(%rsp)\n  xor    %r15d,%r15d\n  lea    0x25(%rsp),%r14\n  lea    0x1(%rbx,%rbp,1),%r12\n  xor    %ebp,%ebp\n  jmp    1275 <func0+0xb5>\n  xchg   %ax,%ax\n  mov    %r14,%rdi\n  call   10b0 <strlen@plt>\n  cmp    $0x2,%rax\n  je     1268 <func0+0xa8>\n  mov    %r13b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\n  add    $0x1,%rbx\n  cmp    %rbx,%r12\n  je     1314 <func0+0x154>\n  movzbl (%rbx),%r13d\n  cmp    $0x20,%r13b\n  jne    1250 <func0+0x90>\n  cmpb   $0x6f,(%r14)\n  jne    12a6 <func0+0xe6>\n  cmpb   $0x0,0x1(%r14)\n  jne    12a6 <func0+0xe6>\n  cmp    0xc(%rsp),%r15d\n  je     1350 <func0+0x190>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x4,0x0(%rbp,%rax,4)\n  cmpb   $0x6f,(%r14)\n  jne    12d4 <func0+0x114>\n  cmpb   $0x7c,0x1(%r14)\n  jne    12d4 <func0+0x114>\n  cmpb   $0x0,0x2(%r14)\n  jne    12d4 <func0+0x114>\n  cmp    0xc(%rsp),%r15d\n  je     13a0 <func0+0x1e0>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x2,0x0(%rbp,%rax,4)\n  cmpb   $0x2e,(%r14)\n  jne    1302 <func0+0x142>\n  cmpb   $0x7c,0x1(%r14)\n  jne    1302 <func0+0x142>\n  cmpb   $0x0,0x2(%r14)\n  jne    1302 <func0+0x142>\n  cmp    0xc(%rsp),%r15d\n  je     1378 <func0+0x1b8>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x1,0x0(%rbp,%rax,4)\n  add    $0x1,%rbx\n  movb   $0x0,0x25(%rsp)\n  cmp    %rbx,%r12\n  jne    1275 <func0+0xb5>\n  mov    0x10(%rsp),%rdi\n  call   10a0 <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    140a <func0+0x24a>\n  add    $0x38,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13c8 <func0+0x208>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    1297 <func0+0xd7>\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13f0 <func0+0x230>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    12f3 <func0+0x133>\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13e0 <func0+0x220>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    12c5 <func0+0x105>\n  nopl   0x0(%rax)\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    1364 <func0+0x1a4>\n  nopw   0x0(%rax,%rax,1)\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    13b4 <func0+0x1f4>\n  nop\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    138c <func0+0x1cc>\n  nop\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  jmp    1314 <func0+0x154>\n  call   10c0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  movb   $0x0,0x27(%rsp)\n  mov    %ax,0x25(%rsp)\n  call   <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbp\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rbp,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x10(%rsp)\n  call   <memcpy@plt>\n  mov    $0x20,%edx\n  lea    0x1(%rbp),%eax\n  mov    %dx,(%rbx,%rbp,1)\n  test   %eax,%eax\n  jle    L0\n  mov    %ebp,%ebp\n  movl   $0x0,0xc(%rsp)\n  xor    %r15d,%r15d\n  lea    0x25(%rsp),%r14\n  lea    0x1(%rbx,%rbp,1),%r12\n  xor    %ebp,%ebp\n  jmp    L1\n  xchg   %ax,%ax\nL4:\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  cmp    $0x2,%rax\n  je     L2\n  mov    %r13b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\nL2:\n  add    $0x1,%rbx\n  cmp    %rbx,%r12\n  je     L3\nL1:\n  movzbl (%rbx),%r13d\n  cmp    $0x20,%r13b\n  jne    L4\n  cmpb   $0x6f,(%r14)\n  jne    L5\n  cmpb   $0x0,0x1(%r14)\n  jne    L5\n  cmp    0xc(%rsp),%r15d\n  je     L6\nL13:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x4,0x0(%rbp,%rax,4)\nL5:\n  cmpb   $0x6f,(%r14)\n  jne    L7\n  cmpb   $0x7c,0x1(%r14)\n  jne    L7\n  cmpb   $0x0,0x2(%r14)\n  jne    L7\n  cmp    0xc(%rsp),%r15d\n  je     L8\nL17:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x2,0x0(%rbp,%rax,4)\nL7:\n  cmpb   $0x2e,(%r14)\n  jne    L9\n  cmpb   $0x7c,0x1(%r14)\n  jne    L9\n  cmpb   $0x0,0x2(%r14)\n  jne    L9\n  cmp    0xc(%rsp),%r15d\n  je     L10\nL15:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x1,0x0(%rbp,%rax,4)\nL9:\n  add    $0x1,%rbx\n  movb   $0x0,0x25(%rsp)\n  cmp    %rbx,%r12\n  jne    L1\nL3:\n  mov    0x10(%rsp),%rdi\n  call   <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L11\n  add    $0x38,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL6:\n  test   %r15d,%r15d\n  jle    L12\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL18:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L13\n  nopl   0x0(%rax)\nL10:\n  test   %r15d,%r15d\n  jle    L14\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL20:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L15\n  nopl   0x0(%rax)\nL8:\n  test   %r15d,%r15d\n  jle    L16\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL19:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L17\n  nopl   0x0(%rax)\nL12:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L18\n  nopw   0x0(%rax,%rax,1)\nL16:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L19\n  nop\nL14:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L20\n  nop\nL0:\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  jmp    L3\nL11:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 5120
            },
            "L1": {
                "label": "L1",
                "addr": 4725
            },
            "L2": {
                "label": "L2",
                "addr": 4712
            },
            "L3": {
                "label": "L3",
                "addr": 4884
            },
            "L4": {
                "label": "L4",
                "addr": 4688
            },
            "L5": {
                "label": "L5",
                "addr": 4774
            },
            "L6": {
                "label": "L6",
                "addr": 4944
            },
            "L7": {
                "label": "L7",
                "addr": 4820
            },
            "L8": {
                "label": "L8",
                "addr": 5024
            },
            "L9": {
                "label": "L9",
                "addr": 4866
            },
            "L10": {
                "label": "L10",
                "addr": 4984
            },
            "L11": {
                "label": "L11",
                "addr": 5130
            },
            "L12": {
                "label": "L12",
                "addr": 5064
            },
            "L13": {
                "label": "L13",
                "addr": 4759
            },
            "L14": {
                "label": "L14",
                "addr": 5104
            },
            "L15": {
                "label": "L15",
                "addr": 4851
            },
            "L16": {
                "label": "L16",
                "addr": 5088
            },
            "L17": {
                "label": "L17",
                "addr": 4805
            },
            "L18": {
                "label": "L18",
                "addr": 4964
            },
            "L19": {
                "label": "L19",
                "addr": 5044
            },
            "L20": {
                "label": "L20",
                "addr": 5004
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 17,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint *func0(const char *music_string, int *count) {\n    int *out = NULL;\n    int size = 0;\n    int capacity = 0;\n\n    char current[3] = \"\";\n    int music_string_length = strlen(music_string) + 1;\n    char *temp_music_string = malloc(music_string_length + 1);\n    strcpy(temp_music_string, music_string);\n    strcat(temp_music_string, \" \");\n\n    for (int i = 0; i < music_string_length; i++) {\n        if (temp_music_string[i] == ' ') {\n            if (strcmp(current, \"o\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 4;\n            }\n            if (strcmp(current, \"o|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 2;\n            }\n            if (strcmp(current, \".|\") == 0) {\n                if (size == capacity) {\n                    capacity = capacity > 0 ? 2 * capacity : 4;\n                    out = realloc(out, capacity * sizeof(int));\n                }\n                out[size++] = 1;\n            }\n            strcpy(current, \"\");\n        } else {\n            size_t len = strlen(current);\n            if (len < sizeof(current) - 1) {\n                current[len] = temp_music_string[i];\n                current[len + 1] = '\\0';\n            }\n        }\n    }\n    free(temp_music_string);\n    *count = size;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int *result;\n\n    result = func0(\"\", &count);\n    assert(issame(result, count, (const int[]){}, 0));\n    free(result);\n\n    result = func0(\"o o o o\", &count);\n    assert(issame(result, count, (const int[]){4, 4, 4, 4}, 4));\n    free(result);\n\n    result = func0(\".| .| .| .|\", &count);\n    assert(issame(result, count, (const int[]){1, 1, 1, 1}, 4));\n    free(result);\n\n    result = func0(\"o| o| .| .| o o o o\", &count);\n    assert(issame(result, count, (const int[]){2, 2, 1, 1, 4, 4, 4, 4}, 8));\n    free(result);\n\n    result = func0(\"o| .| o| .| o o| o o|\", &count);\n    assert(issame(result, count, (const int[]){2, 1, 2, 1, 4, 2, 4, 2}, 8));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  movb   $0x0,0x27(%rsp)\n  mov    %ax,0x25(%rsp)\n  call   10b0 <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbp\n  movslq %edi,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rbp,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x10(%rsp)\n  call   10d0 <memcpy@plt>\n  mov    $0x20,%edx\n  lea    0x1(%rbp),%eax\n  mov    %dx,(%rbx,%rbp,1)\n  test   %eax,%eax\n  jle    1400 <func0+0x240>\n  mov    %ebp,%ebp\n  movl   $0x0,0xc(%rsp)\n  xor    %r15d,%r15d\n  lea    0x25(%rsp),%r14\n  lea    0x1(%rbx,%rbp,1),%r12\n  xor    %ebp,%ebp\n  jmp    1275 <func0+0xb5>\n  xchg   %ax,%ax\n  mov    %r14,%rdi\n  call   10b0 <strlen@plt>\n  cmp    $0x2,%rax\n  je     1268 <func0+0xa8>\n  mov    %r13b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\n  add    $0x1,%rbx\n  cmp    %r12,%rbx\n  je     1314 <func0+0x154>\n  movzbl (%rbx),%r13d\n  cmp    $0x20,%r13b\n  jne    1250 <func0+0x90>\n  cmpb   $0x6f,(%r14)\n  jne    12a6 <func0+0xe6>\n  cmpb   $0x0,0x1(%r14)\n  jne    12a6 <func0+0xe6>\n  cmp    0xc(%rsp),%r15d\n  je     1350 <func0+0x190>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x4,0x0(%rbp,%rax,4)\n  cmpb   $0x6f,(%r14)\n  jne    12d4 <func0+0x114>\n  cmpb   $0x7c,0x1(%r14)\n  jne    12d4 <func0+0x114>\n  cmpb   $0x0,0x2(%r14)\n  jne    12d4 <func0+0x114>\n  cmp    0xc(%rsp),%r15d\n  je     13a0 <func0+0x1e0>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x2,0x0(%rbp,%rax,4)\n  cmpb   $0x2e,(%r14)\n  jne    1302 <func0+0x142>\n  cmpb   $0x7c,0x1(%r14)\n  jne    1302 <func0+0x142>\n  cmpb   $0x0,0x2(%r14)\n  jne    1302 <func0+0x142>\n  cmp    0xc(%rsp),%r15d\n  je     1378 <func0+0x1b8>\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x1,0x0(%rbp,%rax,4)\n  add    $0x1,%rbx\n  movb   $0x0,0x25(%rsp)\n  cmp    %r12,%rbx\n  jne    1275 <func0+0xb5>\n  mov    0x10(%rsp),%rdi\n  call   10a0 <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    140a <func0+0x24a>\n  add    $0x38,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13c8 <func0+0x208>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    1297 <func0+0xd7>\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13f0 <func0+0x230>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    12f3 <func0+0x133>\n  nopl   0x0(%rax)\n  test   %r15d,%r15d\n  jle    13e0 <func0+0x220>\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\n  mov    %rbp,%rdi\n  call   10f0 <realloc@plt>\n  mov    %rax,%rbp\n  jmp    12c5 <func0+0x105>\n  nopl   0x0(%rax)\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    1364 <func0+0x1a4>\n  nopw   0x0(%rax,%rax,1)\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    13b4 <func0+0x1f4>\n  nop\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    138c <func0+0x1cc>\n  nop\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  jmp    1314 <func0+0x154>\n  call   10c0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rsi,0x18(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  movb   $0x0,0x27(%rsp)\n  mov    %ax,0x25(%rsp)\n  call   <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbp\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rbp,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  mov    %rax,%rbx\n  mov    %rax,0x10(%rsp)\n  call   <memcpy@plt>\n  mov    $0x20,%edx\n  lea    0x1(%rbp),%eax\n  mov    %dx,(%rbx,%rbp,1)\n  test   %eax,%eax\n  jle    L0\n  mov    %ebp,%ebp\n  movl   $0x0,0xc(%rsp)\n  xor    %r15d,%r15d\n  lea    0x25(%rsp),%r14\n  lea    0x1(%rbx,%rbp,1),%r12\n  xor    %ebp,%ebp\n  jmp    L1\n  xchg   %ax,%ax\nL4:\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  cmp    $0x2,%rax\n  je     L2\n  mov    %r13b,0x25(%rsp,%rax,1)\n  movb   $0x0,0x26(%rsp,%rax,1)\nL2:\n  add    $0x1,%rbx\n  cmp    %r12,%rbx\n  je     L3\nL1:\n  movzbl (%rbx),%r13d\n  cmp    $0x20,%r13b\n  jne    L4\n  cmpb   $0x6f,(%r14)\n  jne    L5\n  cmpb   $0x0,0x1(%r14)\n  jne    L5\n  cmp    0xc(%rsp),%r15d\n  je     L6\nL13:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x4,0x0(%rbp,%rax,4)\nL5:\n  cmpb   $0x6f,(%r14)\n  jne    L7\n  cmpb   $0x7c,0x1(%r14)\n  jne    L7\n  cmpb   $0x0,0x2(%r14)\n  jne    L7\n  cmp    0xc(%rsp),%r15d\n  je     L8\nL17:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x2,0x0(%rbp,%rax,4)\nL7:\n  cmpb   $0x2e,(%r14)\n  jne    L9\n  cmpb   $0x7c,0x1(%r14)\n  jne    L9\n  cmpb   $0x0,0x2(%r14)\n  jne    L9\n  cmp    0xc(%rsp),%r15d\n  je     L10\nL15:\n  movslq %r15d,%rax\n  add    $0x1,%r15d\n  movl   $0x1,0x0(%rbp,%rax,4)\nL9:\n  add    $0x1,%rbx\n  movb   $0x0,0x25(%rsp)\n  cmp    %r12,%rbx\n  jne    L1\nL3:\n  mov    0x10(%rsp),%rdi\n  call   <free@plt>\n  mov    0x18(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L11\n  add    $0x38,%rsp\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL6:\n  test   %r15d,%r15d\n  jle    L12\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL18:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L13\n  nopl   0x0(%rax)\nL10:\n  test   %r15d,%r15d\n  jle    L14\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL20:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L15\n  nopl   0x0(%rax)\nL8:\n  test   %r15d,%r15d\n  jle    L16\n  lea    (%r15,%r15,1),%eax\n  mov    %eax,0xc(%rsp)\n  movslq %eax,%rsi\n  shl    $0x2,%rsi\nL19:\n  mov    %rbp,%rdi\n  call   <realloc@plt>\n  mov    %rax,%rbp\n  jmp    L17\n  nopl   0x0(%rax)\nL12:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L18\n  nopw   0x0(%rax,%rax,1)\nL16:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L19\n  nop\nL14:\n  movl   $0x4,0xc(%rsp)\n  mov    $0x10,%esi\n  jmp    L20\n  nop\nL0:\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  jmp    L3\nL11:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 5120
            },
            "L1": {
                "label": "L1",
                "addr": 4725
            },
            "L2": {
                "label": "L2",
                "addr": 4712
            },
            "L3": {
                "label": "L3",
                "addr": 4884
            },
            "L4": {
                "label": "L4",
                "addr": 4688
            },
            "L5": {
                "label": "L5",
                "addr": 4774
            },
            "L6": {
                "label": "L6",
                "addr": 4944
            },
            "L7": {
                "label": "L7",
                "addr": 4820
            },
            "L8": {
                "label": "L8",
                "addr": 5024
            },
            "L9": {
                "label": "L9",
                "addr": 4866
            },
            "L10": {
                "label": "L10",
                "addr": 4984
            },
            "L11": {
                "label": "L11",
                "addr": 5130
            },
            "L12": {
                "label": "L12",
                "addr": 5064
            },
            "L13": {
                "label": "L13",
                "addr": 4759
            },
            "L14": {
                "label": "L14",
                "addr": 5104
            },
            "L15": {
                "label": "L15",
                "addr": 4851
            },
            "L16": {
                "label": "L16",
                "addr": 5088
            },
            "L17": {
                "label": "L17",
                "addr": 4805
            },
            "L18": {
                "label": "L18",
                "addr": 4964
            },
            "L19": {
                "label": "L19",
                "addr": 5044
            },
            "L20": {
                "label": "L20",
                "addr": 5004
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 18,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jne    117f <func0+0x46>\n  mov    $0x0,%eax\n  jmp    11c4 <func0+0x8b>\n  movl   $0x0,-0xc(%rbp)\n  jmp    11b6 <func0+0x7d>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rcx\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   1060 <strncmp@plt>\n  test   %eax,%eax\n  jne    11b2 <func0+0x79>\n  addl   $0x1,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0x8(%rbp),%eax\n  sub    -0x4(%rbp),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    1188 <func0+0x4f>\n  mov    -0x10(%rbp),%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0xc(%rbp)\n  jmp    L2\nL4:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rcx\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   <strncmp@plt>\n  test   %eax,%eax\n  jne    L3\n  addl   $0x1,-0x10(%rbp)\nL3:\n  addl   $0x1,-0xc(%rbp)\nL2:\n  mov    -0x8(%rbp),%eax\n  sub    -0x4(%rbp),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L4\n  mov    -0x10(%rbp),%eax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4479
            },
            "L1": {
                "label": "L1",
                "addr": 4548
            },
            "L2": {
                "label": "L2",
                "addr": 4534
            },
            "L3": {
                "label": "L3",
                "addr": 4530
            },
            "L4": {
                "label": "L4",
                "addr": 4488
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 18,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %rsi,%r12\n  call   1070 <strlen@plt>\n  mov    %eax,%ebp\n  test   %eax,%eax\n  je     1193 <func0+0x5a>\n  mov    %r12,%rdi\n  call   1070 <strlen@plt>\n  mov    %ebp,%edx\n  sub    %eax,%edx\n  js     119e <func0+0x65>\n  mov    %r14,%rbx\n  mov    %edx,%edx\n  lea    0x1(%r14,%rdx,1),%r14\n  mov    $0x0,%ebp\n  movslq %eax,%r13\n  mov    %r13,%rdx\n  mov    %r12,%rsi\n  mov    %rbx,%rdi\n  call   1060 <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%ebp\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    1176 <func0+0x3d>\n  mov    %ebp,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x0,%ebp\n  jmp    1193 <func0+0x5a>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %rsi,%r12\n  call   <strlen@plt>\n  mov    %eax,%ebp\n  test   %eax,%eax\n  je     L0\n  mov    %r12,%rdi\n  call   <strlen@plt>\n  mov    %ebp,%edx\n  sub    %eax,%edx\n  js     L1\n  mov    %r14,%rbx\n  mov    %edx,%edx\n  lea    0x1(%r14,%rdx,1),%r14\n  mov    $0x0,%ebp\n  movslq %eax,%r13\nL2:\n  mov    %r13,%rdx\n  mov    %r12,%rsi\n  mov    %rbx,%rdi\n  call   <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%ebp\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    L2\nL0:\n  mov    %ebp,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL1:\n  mov    $0x0,%ebp\n  jmp    L0",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4499
            },
            "L1": {
                "label": "L1",
                "addr": 4510
            },
            "L2": {
                "label": "L2",
                "addr": 4470
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 18,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1070 <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     119e <func0+0x5e>\n  mov    %r13,%rdi\n  mov    %rax,%r14\n  call   1070 <strlen@plt>\n  sub    %eax,%r14d\n  js     11b0 <func0+0x70>\n  movslq %r14d,%r14\n  movslq %eax,%rbp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%r14,1),%r14\n  nopl   0x0(%rax)\n  mov    %rbx,%rdi\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  call   1060 <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%r12d\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    1180 <func0+0x40>\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r12d,%r12d\n  jmp    119e <func0+0x5e>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     L0\n  mov    %r13,%rdi\n  mov    %rax,%r14\n  call   <strlen@plt>\n  sub    %eax,%r14d\n  js     L1\n  movslq %r14d,%r14\n  movslq %eax,%rbp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%r14,1),%r14\n  nopl   0x0(%rax)\nL2:\n  mov    %rbx,%rdi\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  call   <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%r12d\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    L2\nL0:\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  xor    %r12d,%r12d\n  jmp    L0",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4510
            },
            "L1": {
                "label": "L1",
                "addr": 4528
            },
            "L2": {
                "label": "L2",
                "addr": 4480
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 18,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str, const char *substring) {\n    int out = 0;\n    int str_len = strlen(str);\n    int sub_len = strlen(substring);\n    if (str_len == 0) return 0;\n    for (int i = 0; i <= str_len - sub_len; i++) {\n        if (strncmp(&str[i], substring, sub_len) == 0)\n            out++;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\", \"x\") == 0);\n    assert(func0(\"xyxyxyx\", \"x\") == 4);\n    assert(func0(\"cacacacac\", \"cac\") == 4);\n    assert(func0(\"john doe\", \"john\") == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1070 <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     119e <func0+0x5e>\n  mov    %r13,%rdi\n  mov    %rax,%r14\n  call   1070 <strlen@plt>\n  sub    %eax,%r14d\n  js     11b0 <func0+0x70>\n  movslq %r14d,%r14\n  movslq %eax,%rbp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%r14,1),%r14\n  nopl   0x0(%rax)\n  mov    %rbx,%rdi\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  call   1060 <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%r12d\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    1180 <func0+0x40>\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r12d,%r12d\n  jmp    119e <func0+0x5e>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     L0\n  mov    %r13,%rdi\n  mov    %rax,%r14\n  call   <strlen@plt>\n  sub    %eax,%r14d\n  js     L1\n  movslq %r14d,%r14\n  movslq %eax,%rbp\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%r14,1),%r14\n  nopl   0x0(%rax)\nL2:\n  mov    %rbx,%rdi\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  call   <strncmp@plt>\n  cmp    $0x1,%eax\n  adc    $0x0,%r12d\n  add    $0x1,%rbx\n  cmp    %r14,%rbx\n  jne    L2\nL0:\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  xor    %r12d,%r12d\n  jmp    L0",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4510
            },
            "L1": {
                "label": "L1",
                "addr": 4528
            },
            "L2": {
                "label": "L2",
                "addr": 4480
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 19,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xb0,%rsp\n  mov    %rdi,-0xa8(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x90(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  lea    0xe6d(%rip),%rax        # 2000 <_fini+0xbd0>\n  mov    %rax,-0x60(%rbp)\n  lea    0xe67(%rip),%rax        # 2005 <_fini+0xbd5>\n  mov    %rax,-0x58(%rbp)\n  lea    0xe60(%rip),%rax        # 2009 <_fini+0xbd9>\n  mov    %rax,-0x50(%rbp)\n  lea    0xe59(%rip),%rax        # 200d <_fini+0xbdd>\n  mov    %rax,-0x48(%rbp)\n  lea    0xe54(%rip),%rax        # 2013 <_fini+0xbe3>\n  mov    %rax,-0x40(%rbp)\n  lea    0xe4e(%rip),%rax        # 2018 <_fini+0xbe8>\n  mov    %rax,-0x38(%rbp)\n  lea    0xe48(%rip),%rax        # 201d <_fini+0xbed>\n  mov    %rax,-0x30(%rbp)\n  lea    0xe41(%rip),%rax        # 2021 <_fini+0xbf1>\n  mov    %rax,-0x28(%rbp)\n  lea    0xe3c(%rip),%rax        # 2027 <_fini+0xbf7>\n  mov    %rax,-0x20(%rbp)\n  lea    0xe37(%rip),%rax        # 202d <_fini+0xbfd>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0xa0(%rbp)\n  mov    -0xa8(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     1314 <func0+0x1db>\n  movl   $0x0,-0x9c(%rbp)\n  jmp    124b <func0+0x112>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    %dl,-0xe(%rbp,%rax,1)\n  addl   $0x1,-0x9c(%rbp)\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     127f <func0+0x146>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1222 <func0+0xe9>\n  mov    -0x9c(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe(%rbp,%rax,1)\n  movl   $0x0,-0x98(%rbp)\n  jmp    12e2 <func0+0x1a9>\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  lea    -0xe(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  jne    12db <func0+0x1a2>\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    -0x90(%rbp,%rax,4),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    %edx,-0x90(%rbp,%rax,4)\n  jmp    12eb <func0+0x1b2>\n  addl   $0x1,-0x98(%rbp)\n  cmpl   $0x9,-0x98(%rbp)\n  jle    1298 <func0+0x15f>\n  mov    -0x9c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  add    %rax,-0xa8(%rbp)\n  mov    -0xa8(%rbp),%rax\n  sub    $0x1,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1216 <func0+0xdd>\n  movl   $0x0,-0x9c(%rbp)\n  jmp    13dd <func0+0x2a4>\n  movl   $0x0,-0x98(%rbp)\n  jmp    13bb <func0+0x282>\n  movl   $0x0,-0x94(%rbp)\n  jmp    1379 <func0+0x240>\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  mov    -0x94(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xa0(%rbp),%eax\n  cltq\n  lea    0x2cf8(%rip),%rcx        # 4060 <out.0>\n  mov    %dl,(%rax,%rcx,1)\n  addl   $0x1,-0x94(%rbp)\n  addl   $0x1,-0xa0(%rbp)\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  mov    -0x94(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    133e <func0+0x205>\n  mov    -0xa0(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xa0(%rbp)\n  cltq\n  lea    0x2cb0(%rip),%rdx        # 4060 <out.0>\n  movb   $0x20,(%rax,%rdx,1)\n  addl   $0x1,-0x98(%rbp)\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x90(%rbp,%rax,4),%eax\n  cmp    %eax,-0x98(%rbp)\n  jl     1332 <func0+0x1f9>\n  addl   $0x1,-0x9c(%rbp)\n  cmpl   $0x9,-0x9c(%rbp)\n  jle    1323 <func0+0x1ea>\n  cmpl   $0x0,-0xa0(%rbp)\n  jle    140b <func0+0x2d2>\n  mov    -0xa0(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  lea    0x2c5b(%rip),%rdx        # 4060 <out.0>\n  movb   $0x0,(%rax,%rdx,1)\n  jmp    1412 <func0+0x2d9>\n  movb   $0x0,0x2c4e(%rip)        # 4060 <out.0>\n  lea    0x2c47(%rip),%rax        # 4060 <out.0>\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     142d <func0+0x2f4>\n  call   1060 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xb0,%rsp\n  mov    %rdi,-0xa8(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x90(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x60(%rbp)\n  lea    D1(%rip),%rax\n  mov    %rax,-0x58(%rbp)\n  lea    D2(%rip),%rax\n  mov    %rax,-0x50(%rbp)\n  lea    D3(%rip),%rax\n  mov    %rax,-0x48(%rbp)\n  lea    D4(%rip),%rax\n  mov    %rax,-0x40(%rbp)\n  lea    D5(%rip),%rax\n  mov    %rax,-0x38(%rbp)\n  lea    D6(%rip),%rax\n  mov    %rax,-0x30(%rbp)\n  lea    D7(%rip),%rax\n  mov    %rax,-0x28(%rbp)\n  lea    D8(%rip),%rax\n  mov    %rax,-0x20(%rbp)\n  lea    D9(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0xa0(%rbp)\n  mov    -0xa8(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L0\nL8:\n  movl   $0x0,-0x9c(%rbp)\n  jmp    L1\nL3:\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    %dl,-0xe(%rbp,%rax,1)\n  addl   $0x1,-0x9c(%rbp)\nL1:\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L2\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L3\nL2:\n  mov    -0x9c(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe(%rbp,%rax,1)\n  movl   $0x0,-0x98(%rbp)\n  jmp    L4\nL7:\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  lea    -0xe(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L5\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    -0x90(%rbp,%rax,4),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x98(%rbp),%eax\n  cltq\n  mov    %edx,-0x90(%rbp,%rax,4)\n  jmp    L6\nL5:\n  addl   $0x1,-0x98(%rbp)\nL4:\n  cmpl   $0x9,-0x98(%rbp)\n  jle    L7\nL6:\n  mov    -0x9c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  add    %rax,-0xa8(%rbp)\n  mov    -0xa8(%rbp),%rax\n  sub    $0x1,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L8\nL0:\n  movl   $0x0,-0x9c(%rbp)\n  jmp    L9\nL14:\n  movl   $0x0,-0x98(%rbp)\n  jmp    L10\nL13:\n  movl   $0x0,-0x94(%rbp)\n  jmp    L11\nL12:\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  mov    -0x94(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xa0(%rbp),%eax\n  cltq\n  lea    D10(%rip),%rcx\n  mov    %dl,(%rax,%rcx,1)\n  addl   $0x1,-0x94(%rbp)\n  addl   $0x1,-0xa0(%rbp)\nL11:\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x60(%rbp,%rax,8),%rdx\n  mov    -0x94(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L12\n  mov    -0xa0(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xa0(%rbp)\n  cltq\n  lea    D10(%rip),%rdx\n  movb   $0x20,(%rax,%rdx,1)\n  addl   $0x1,-0x98(%rbp)\nL10:\n  mov    -0x9c(%rbp),%eax\n  cltq\n  mov    -0x90(%rbp,%rax,4),%eax\n  cmp    %eax,-0x98(%rbp)\n  jl     L13\n  addl   $0x1,-0x9c(%rbp)\nL9:\n  cmpl   $0x9,-0x9c(%rbp)\n  jle    L14\n  cmpl   $0x0,-0xa0(%rbp)\n  jle    L15\n  mov    -0xa0(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  lea    D10(%rip),%rdx\n  movb   $0x0,(%rax,%rdx,1)\n  jmp    L16\nL15:\n  movb   $0x0,D10(%rip)\nL16:\n  lea    D10(%rip),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L17\n  call   <__stack_chk_fail@plt>\nL17:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3693
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8197,
                "bias": [
                    3687
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8201,
                "bias": [
                    3680
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8205,
                "bias": [
                    3673
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8211,
                "bias": [
                    3668
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8216,
                "bias": [
                    3662
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8221,
                "bias": [
                    3656
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8225,
                "bias": [
                    3649
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8231,
                "bias": [
                    3644
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8237,
                "bias": [
                    3639
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 16480,
                "bias": [
                    11512,
                    11440,
                    11355,
                    11342,
                    11335
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4884
            },
            "L1": {
                "label": "L1",
                "addr": 4683
            },
            "L2": {
                "label": "L2",
                "addr": 4735
            },
            "L3": {
                "label": "L3",
                "addr": 4642
            },
            "L4": {
                "label": "L4",
                "addr": 4834
            },
            "L5": {
                "label": "L5",
                "addr": 4827
            },
            "L6": {
                "label": "L6",
                "addr": 4843
            },
            "L7": {
                "label": "L7",
                "addr": 4760
            },
            "L8": {
                "label": "L8",
                "addr": 4630
            },
            "L9": {
                "label": "L9",
                "addr": 5085
            },
            "L10": {
                "label": "L10",
                "addr": 5051
            },
            "L11": {
                "label": "L11",
                "addr": 4985
            },
            "L12": {
                "label": "L12",
                "addr": 4926
            },
            "L13": {
                "label": "L13",
                "addr": 4914
            },
            "L14": {
                "label": "L14",
                "addr": 4899
            },
            "L15": {
                "label": "L15",
                "addr": 5131
            },
            "L16": {
                "label": "L16",
                "addr": 5138
            },
            "L17": {
                "label": "L17",
                "addr": 5165
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "7a65726f006f6e650074776f00746872656500666f757200666976650073697800736576656e006569676874006e696e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"zero\""
                },
                "0x2021": {
                    "type": "string",
                    "value": "\"seven\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"one\""
                },
                "0x2027": {
                    "type": "string",
                    "value": "\"eight\""
                },
                "0x2009": {
                    "type": "string",
                    "value": "\"two\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"three\""
                },
                "0x202d": {
                    "type": "string",
                    "value": "\"nine\""
                },
                "0x2013": {
                    "type": "string",
                    "value": "\"four\""
                },
                "0x2018": {
                    "type": "string",
                    "value": "\"five\""
                },
                "0x201d": {
                    "type": "string",
                    "value": "\"six\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 19,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,(%rsp)\n  movq   $0x0,0x8(%rsp)\n  movq   $0x0,0x10(%rsp)\n  movq   $0x0,0x18(%rsp)\n  movq   $0x0,0x20(%rsp)\n  lea    0xe6c(%rip),%rax        # 2000 <_fini+0xc98>\n  mov    %rax,0x30(%rsp)\n  lea    0xe65(%rip),%rax        # 2005 <_fini+0xc9d>\n  mov    %rax,0x38(%rsp)\n  lea    0xe5d(%rip),%rax        # 2009 <_fini+0xca1>\n  mov    %rax,0x40(%rsp)\n  lea    0xe55(%rip),%rax        # 200d <_fini+0xca5>\n  mov    %rax,0x48(%rsp)\n  lea    0xe4f(%rip),%rax        # 2013 <_fini+0xcab>\n  mov    %rax,0x50(%rsp)\n  lea    0xe48(%rip),%rax        # 2018 <_fini+0xcb0>\n  mov    %rax,0x58(%rsp)\n  lea    0xe41(%rip),%rax        # 201d <_fini+0xcb5>\n  mov    %rax,0x60(%rsp)\n  lea    0xe39(%rip),%rax        # 2021 <_fini+0xcb9>\n  mov    %rax,0x68(%rsp)\n  lea    0xe33(%rip),%rax        # 2027 <_fini+0xcbf>\n  mov    %rax,0x70(%rsp)\n  lea    0xe2d(%rip),%rax        # 202d <_fini+0xcc5>\n  mov    %rax,0x78(%rsp)\n  cmpb   $0x0,(%rdi)\n  je     1295 <func0+0x15c>\n  mov    %rdi,%rbp\n  lea    0x81(%rsp),%r15\n  lea    0x82(%rsp),%r14\n  jmp    1243 <func0+0x10a>\n  mov    $0x0,%ecx\n  mov    $0x0,%r13d\n  jmp    1268 <func0+0x12f>\n  movslq %ebx,%r12\n  addl   $0x1,(%rsp,%r12,4)\n  lea    0x1(%rbp,%r13,1),%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     1295 <func0+0x15c>\n  movzbl 0x0(%rbp),%edx\n  test   $0xdf,%dl\n  je     1223 <func0+0xea>\n  mov    $0x1,%eax\n  mov    %dl,(%r15,%rax,1)\n  mov    %eax,%ecx\n  movzbl 0x0(%rbp,%rax,1),%edx\n  mov    %rax,%r13\n  add    $0x1,%rax\n  test   $0xdf,%dl\n  jne    1251 <func0+0x118>\n  movslq %ecx,%rcx\n  movb   $0x0,0x82(%rsp,%rcx,1)\n  mov    $0x0,%ebx\n  mov    0x30(%rsp,%rbx,8),%rsi\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1230 <func0+0xf7>\n  add    $0x1,%rbx\n  cmp    $0xa,%rbx\n  jne    1278 <func0+0x13f>\n  jmp    1238 <func0+0xff>\n  mov    $0x0,%r12d\n  mov    $0x0,%r8d\n  lea    0x2db7(%rip),%rdi        # 405f <completed.0+0x1f>\n  lea    0x1(%rdi),%rbp\n  jmp    12fb <func0+0x1c2>\n  mov    %dl,(%rax,%rdi,1)\n  mov    %eax,%ecx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    12ae <func0+0x175>\n  lea    0x1(%rcx),%r8d\n  movslq %ecx,%rcx\n  movb   $0x20,0x0(%rbp,%rcx,1)\n  add    $0x1,%r9d\n  cmp    %r11d,%r9d\n  je     12f1 <func0+0x1b8>\n  lea    0x1(%r8),%eax\n  cltq\n  mov    %r10d,%edx\n  movslq %r8d,%rcx\n  mov    %rbx,%rsi\n  sub    %rcx,%rsi\n  mov    %r8d,%ecx\n  test   %r10b,%r10b\n  jne    12ae <func0+0x175>\n  jmp    12c0 <func0+0x187>\n  add    $0x1,%r12\n  cmp    $0xa,%r12\n  je     1315 <func0+0x1dc>\n  mov    (%rsp,%r12,4),%r11d\n  test   %r11d,%r11d\n  jle    12f1 <func0+0x1b8>\n  mov    0x30(%rsp,%r12,8),%rbx\n  movzbl (%rbx),%r10d\n  mov    $0x0,%r9d\n  jmp    12d5 <func0+0x19c>\n  test   %r8d,%r8d\n  jle    1357 <func0+0x21e>\n  lea    -0x1(%r8),%eax\n  cltq\n  lea    0x2d39(%rip),%rdx        # 4060 <out.0>\n  movb   $0x0,(%rdx,%rax,1)\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1360 <func0+0x227>\n  lea    0x2d1b(%rip),%rax        # 4060 <out.0>\n  add    $0x98,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  movb   $0x0,0x2d02(%rip)        # 4060 <out.0>\n  jmp    132b <func0+0x1f2>\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,(%rsp)\n  movq   $0x0,0x8(%rsp)\n  movq   $0x0,0x10(%rsp)\n  movq   $0x0,0x18(%rsp)\n  movq   $0x0,0x20(%rsp)\n  lea    D0(%rip),%rax\n  mov    %rax,0x30(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x50(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x58(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x60(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x68(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x70(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x78(%rsp)\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    %rdi,%rbp\n  lea    0x81(%rsp),%r15\n  lea    0x82(%rsp),%r14\n  jmp    L1\nL3:\n  mov    $0x0,%ecx\n  mov    $0x0,%r13d\n  jmp    L2\nL5:\n  movslq %ebx,%r12\n  addl   $0x1,(%rsp,%r12,4)\nL7:\n  lea    0x1(%rbp,%r13,1),%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     L0\nL1:\n  movzbl 0x0(%rbp),%edx\n  test   $0xdf,%dl\n  je     L3\n  mov    $0x1,%eax\nL4:\n  mov    %dl,(%r15,%rax,1)\n  mov    %eax,%ecx\n  movzbl 0x0(%rbp,%rax,1),%edx\n  mov    %rax,%r13\n  add    $0x1,%rax\n  test   $0xdf,%dl\n  jne    L4\nL2:\n  movslq %ecx,%rcx\n  movb   $0x0,0x82(%rsp,%rcx,1)\n  mov    $0x0,%ebx\nL6:\n  mov    0x30(%rsp,%rbx,8),%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L5\n  add    $0x1,%rbx\n  cmp    $0xa,%rbx\n  jne    L6\n  jmp    L7\nL0:\n  mov    $0x0,%r12d\n  mov    $0x0,%r8d\n  lea    D10(%rip),%rdi\n  lea    0x1(%rdi),%rbp\n  jmp    L8\nL9:\n  mov    %dl,(%rax,%rdi,1)\n  mov    %eax,%ecx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    L9\nL11:\n  lea    0x1(%rcx),%r8d\n  movslq %ecx,%rcx\n  movb   $0x20,0x0(%rbp,%rcx,1)\n  add    $0x1,%r9d\n  cmp    %r11d,%r9d\n  je     L10\nL13:\n  lea    0x1(%r8),%eax\n  cltq\n  mov    %r10d,%edx\n  movslq %r8d,%rcx\n  mov    %rbx,%rsi\n  sub    %rcx,%rsi\n  mov    %r8d,%ecx\n  test   %r10b,%r10b\n  jne    L9\n  jmp    L11\nL10:\n  add    $0x1,%r12\n  cmp    $0xa,%r12\n  je     L12\nL8:\n  mov    (%rsp,%r12,4),%r11d\n  test   %r11d,%r11d\n  jle    L10\n  mov    0x30(%rsp,%r12,8),%rbx\n  movzbl (%rbx),%r10d\n  mov    $0x0,%r9d\n  jmp    L13\nL12:\n  test   %r8d,%r8d\n  jle    L14\n  lea    -0x1(%r8),%eax\n  cltq\n  lea    D11(%rip),%rdx\n  movb   $0x0,(%rdx,%rax,1)\nL16:\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L15\n  lea    D11(%rip),%rax\n  add    $0x98,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL14:\n  movb   $0x0,D11(%rip)\n  jmp    L16\nL15:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3692
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8197,
                "bias": [
                    3685
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8201,
                "bias": [
                    3677
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8205,
                "bias": [
                    3669
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8211,
                "bias": [
                    3663
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8216,
                "bias": [
                    3656
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8221,
                "bias": [
                    3649
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8225,
                "bias": [
                    3641
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8231,
                "bias": [
                    3635
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8237,
                "bias": [
                    3629
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 16479,
                "bias": [
                    11703
                ]
            },
            "D11": {
                "label": "D11",
                "addr": 16480,
                "bias": [
                    11577,
                    11547,
                    11522
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4757
            },
            "L1": {
                "label": "L1",
                "addr": 4675
            },
            "L2": {
                "label": "L2",
                "addr": 4712
            },
            "L3": {
                "label": "L3",
                "addr": 4643
            },
            "L4": {
                "label": "L4",
                "addr": 4689
            },
            "L5": {
                "label": "L5",
                "addr": 4656
            },
            "L6": {
                "label": "L6",
                "addr": 4728
            },
            "L7": {
                "label": "L7",
                "addr": 4664
            },
            "L8": {
                "label": "L8",
                "addr": 4859
            },
            "L9": {
                "label": "L9",
                "addr": 4782
            },
            "L10": {
                "label": "L10",
                "addr": 4849
            },
            "L11": {
                "label": "L11",
                "addr": 4800
            },
            "L12": {
                "label": "L12",
                "addr": 4885
            },
            "L13": {
                "label": "L13",
                "addr": 4821
            },
            "L14": {
                "label": "L14",
                "addr": 4951
            },
            "L15": {
                "label": "L15",
                "addr": 4960
            },
            "L16": {
                "label": "L16",
                "addr": 4907
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "7a65726f006f6e650074776f00746872656500666f757200666976650073697800736576656e006569676874006e696e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"zero\""
                },
                "0x2021": {
                    "type": "string",
                    "value": "\"seven\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"one\""
                },
                "0x2027": {
                    "type": "string",
                    "value": "\"eight\""
                },
                "0x2009": {
                    "type": "string",
                    "value": "\"two\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"three\""
                },
                "0x202d": {
                    "type": "string",
                    "value": "\"nine\""
                },
                "0x2013": {
                    "type": "string",
                    "value": "\"four\""
                },
                "0x2018": {
                    "type": "string",
                    "value": "\"five\""
                },
                "0x201d": {
                    "type": "string",
                    "value": "\"six\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 19,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  pxor   %xmm0,%xmm0\n  xor    %r10d,%r10d\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  lea    0xe8a(%rip),%rax        # 2000 <_fini+0xca0>\n  movaps %xmm0,(%rsp)\n  mov    %rax,0x30(%rsp)\n  lea    0xe7f(%rip),%rax        # 2005 <_fini+0xca5>\n  mov    %rax,0x38(%rsp)\n  lea    0xe77(%rip),%rax        # 2009 <_fini+0xca9>\n  mov    %rax,0x40(%rsp)\n  lea    0xe6f(%rip),%rax        # 200d <_fini+0xcad>\n  mov    %rax,0x48(%rsp)\n  lea    0xe69(%rip),%rax        # 2013 <_fini+0xcb3>\n  mov    %rax,0x50(%rsp)\n  lea    0xe62(%rip),%rax        # 2018 <_fini+0xcb8>\n  mov    %rax,0x58(%rsp)\n  lea    0xe5b(%rip),%rax        # 201d <_fini+0xcbd>\n  mov    %rax,0x60(%rsp)\n  lea    0xe53(%rip),%rax        # 2021 <_fini+0xcc1>\n  mov    %rax,0x68(%rsp)\n  lea    0xe4d(%rip),%rax        # 2027 <_fini+0xcc7>\n  mov    %rax,0x70(%rsp)\n  lea    0xe47(%rip),%rax        # 202d <_fini+0xccd>\n  mov    %rax,0x78(%rsp)\n  movzbl (%rdi),%eax\n  movq   $0x0,0x20(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  test   %al,%al\n  je     129a <func0+0x15a>\n  mov    %rdi,%rbp\n  lea    0x82(%rsp),%r13\n  mov    $0x1,%ebx\n  lea    0x81(%rsp),%r14\n  test   $0xdf,%al\n  je     1284 <func0+0x144>\n  mov    %al,(%r14,%rbx,1)\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movslq %ebx,%rdx\n  add    $0x1,%rbx\n  test   $0xdf,%al\n  jne    1220 <func0+0xe0>\n  movb   $0x0,0x82(%rsp,%rdx,1)\n  xor    %r15d,%r15d\n  lea    0xdba(%rip),%rsi        # 2000 <_fini+0xca0>\n  jmp    1255 <func0+0x115>\n  nopl   0x0(%rax,%rax,1)\n  mov    0x30(%rsp,%r15,8),%rsi\n  mov    %r13,%rdi\n  movslq %r15d,%r12\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1288 <func0+0x148>\n  add    $0x1,%r15\n  cmp    $0xa,%r15\n  jne    1250 <func0+0x110>\n  add    %rbx,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     1296 <func0+0x156>\n  movzbl 0x0(%rbp),%eax\n  mov    $0x1,%ebx\n  test   $0xdf,%al\n  jne    1220 <func0+0xe0>\n  xor    %edx,%edx\n  jmp    1234 <func0+0xf4>\n  add    %rbx,%rbp\n  addl   $0x1,(%rsp,%r12,4)\n  cmpb   $0x0,-0x1(%rbp)\n  jne    1277 <func0+0x137>\n  mov    (%rsp),%r10d\n  lea    0x2dbf(%rip),%r11        # 4060 <out.0>\n  xor    %ebp,%ebp\n  xor    %esi,%esi\n  lea    -0x1(%r11),%rdi\n  nopl   0x0(%rax)\n  test   %r10d,%r10d\n  jle    130c <func0+0x1cc>\n  mov    0x30(%rsp,%rbp,2),%rbx\n  xor    %r8d,%r8d\n  movzbl (%rbx),%r9d\n  nopl   0x0(%rax)\n  movslq %esi,%rcx\n  test   %r9b,%r9b\n  je     12fb <func0+0x1bb>\n  lea    0x1(%rsi),%eax\n  movslq %esi,%rcx\n  mov    %rbx,%rsi\n  mov    %r9d,%edx\n  cltq\n  sub    %rcx,%rsi\n  nopl   0x0(%rax)\n  mov    %dl,(%rdi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    12e8 <func0+0x1a8>\n  add    $0x1,%r8d\n  movb   $0x20,(%r11,%rcx,1)\n  lea    0x1(%rcx),%esi\n  cmp    %r10d,%r8d\n  jne    12c8 <func0+0x188>\n  add    $0x4,%rbp\n  cmp    $0x28,%rbp\n  je     131c <func0+0x1dc>\n  mov    (%rsp,%rbp,1),%r10d\n  jmp    12b0 <func0+0x170>\n  test   %esi,%esi\n  je     1352 <func0+0x212>\n  lea    -0x1(%rsi),%eax\n  cltq\n  movb   $0x0,(%r11,%rax,1)\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    135b <func0+0x21b>\n  add    $0x98,%rsp\n  mov    %r11,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  movb   $0x0,0x2d07(%rip)        # 4060 <out.0>\n  jmp    132a <func0+0x1ea>\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  pxor   %xmm0,%xmm0\n  xor    %r10d,%r10d\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  movaps %xmm0,(%rsp)\n  mov    %rax,0x30(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x50(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x58(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x60(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x68(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x70(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x78(%rsp)\n  movzbl (%rdi),%eax\n  movq   $0x0,0x20(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  test   %al,%al\n  je     L0\n  mov    %rdi,%rbp\n  lea    0x82(%rsp),%r13\n  mov    $0x1,%ebx\n  lea    0x81(%rsp),%r14\n  test   $0xdf,%al\n  je     L1\nL2:\n  mov    %al,(%r14,%rbx,1)\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  movslq %ebx,%rdx\n  add    $0x1,%rbx\n  test   $0xdf,%al\n  jne    L2\nL7:\n  movb   $0x0,0x82(%rsp,%rdx,1)\n  xor    %r15d,%r15d\n  lea    D0(%rip),%rsi\n  jmp    L3\n  nopl   0x0(%rax,%rax,1)\nL5:\n  mov    0x30(%rsp,%r15,8),%rsi\nL3:\n  mov    %r13,%rdi\n  movslq %r15d,%r12\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L4\n  add    $0x1,%r15\n  cmp    $0xa,%r15\n  jne    L5\n  add    %rbx,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     L6\nL8:\n  movzbl 0x0(%rbp),%eax\n  mov    $0x1,%ebx\n  test   $0xdf,%al\n  jne    L2\nL1:\n  xor    %edx,%edx\n  jmp    L7\nL4:\n  add    %rbx,%rbp\n  addl   $0x1,(%rsp,%r12,4)\n  cmpb   $0x0,-0x1(%rbp)\n  jne    L8\nL6:\n  mov    (%rsp),%r10d\nL0:\n  lea    D10(%rip),%r11\n  xor    %ebp,%ebp\n  xor    %esi,%esi\n  lea    -0x1(%r11),%rdi\n  nopl   0x0(%rax)\nL14:\n  test   %r10d,%r10d\n  jle    L9\n  mov    0x30(%rsp,%rbp,2),%rbx\n  xor    %r8d,%r8d\n  movzbl (%rbx),%r9d\n  nopl   0x0(%rax)\nL12:\n  movslq %esi,%rcx\n  test   %r9b,%r9b\n  je     L10\n  lea    0x1(%rsi),%eax\n  movslq %esi,%rcx\n  mov    %rbx,%rsi\n  mov    %r9d,%edx\n  cltq\n  sub    %rcx,%rsi\n  nopl   0x0(%rax)\nL11:\n  mov    %dl,(%rdi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    L11\nL10:\n  add    $0x1,%r8d\n  movb   $0x20,(%r11,%rcx,1)\n  lea    0x1(%rcx),%esi\n  cmp    %r10d,%r8d\n  jne    L12\nL9:\n  add    $0x4,%rbp\n  cmp    $0x28,%rbp\n  je     L13\n  mov    (%rsp,%rbp,1),%r10d\n  jmp    L14\nL13:\n  test   %esi,%esi\n  je     L15\n  lea    -0x1(%rsi),%eax\n  cltq\n  movb   $0x0,(%r11,%rax,1)\nL17:\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L16\n  add    $0x98,%rsp\n  mov    %r11,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL15:\n  movb   $0x0,D10(%rip)\n  jmp    L17\nL16:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3722,
                    3514
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8197,
                "bias": [
                    3711
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8201,
                "bias": [
                    3703
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8205,
                "bias": [
                    3695
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8211,
                "bias": [
                    3689
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8216,
                "bias": [
                    3682
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8221,
                "bias": [
                    3675
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8225,
                "bias": [
                    3667
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8231,
                "bias": [
                    3661
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8237,
                "bias": [
                    3655
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 16480,
                "bias": [
                    11711,
                    11527
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4762
            },
            "L1": {
                "label": "L1",
                "addr": 4740
            },
            "L2": {
                "label": "L2",
                "addr": 4640
            },
            "L3": {
                "label": "L3",
                "addr": 4693
            },
            "L4": {
                "label": "L4",
                "addr": 4744
            },
            "L5": {
                "label": "L5",
                "addr": 4688
            },
            "L6": {
                "label": "L6",
                "addr": 4758
            },
            "L7": {
                "label": "L7",
                "addr": 4660
            },
            "L8": {
                "label": "L8",
                "addr": 4727
            },
            "L9": {
                "label": "L9",
                "addr": 4876
            },
            "L10": {
                "label": "L10",
                "addr": 4859
            },
            "L11": {
                "label": "L11",
                "addr": 4840
            },
            "L12": {
                "label": "L12",
                "addr": 4808
            },
            "L13": {
                "label": "L13",
                "addr": 4892
            },
            "L14": {
                "label": "L14",
                "addr": 4784
            },
            "L15": {
                "label": "L15",
                "addr": 4946
            },
            "L16": {
                "label": "L16",
                "addr": 4955
            },
            "L17": {
                "label": "L17",
                "addr": 4906
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "7a65726f006f6e650074776f00746872656500666f757200666976650073697800736576656e006569676874006e696e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"zero\""
                },
                "0x2021": {
                    "type": "string",
                    "value": "\"seven\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"one\""
                },
                "0x2027": {
                    "type": "string",
                    "value": "\"eight\""
                },
                "0x2009": {
                    "type": "string",
                    "value": "\"two\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"three\""
                },
                "0x202d": {
                    "type": "string",
                    "value": "\"nine\""
                },
                "0x2013": {
                    "type": "string",
                    "value": "\"four\""
                },
                "0x2018": {
                    "type": "string",
                    "value": "\"five\""
                },
                "0x201d": {
                    "type": "string",
                    "value": "\"six\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 19,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* numbers) {\n    int count[10] = {0};\n    const char* numto[10] = {\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\n    int index, i, j, k;\n    static char out[1000]; \n    char current[6]; \n\n    index = 0;\n    if (*numbers) {\n        do {\n            for (i = 0; numbers[i] != ' ' && numbers[i] != '\\0'; ++i) {\n                current[i] = numbers[i];\n            }\n            current[i] = '\\0';\n            for (j = 0; j < 10; ++j) {\n                if (strcmp(current, numto[j]) == 0) {\n                    count[j]++;\n                    break;\n                }\n            }\n            numbers += i + 1;\n        } while (numbers[-1]);\n    }\n\n    for (i = 0; i < 10; ++i) {\n        for (j = 0; j < count[i]; ++j) {\n            for (k = 0; numto[i][k] != '\\0'; ++k, ++index) {\n                out[index] = numto[i][k];\n            }\n            out[index++] = ' '; \n        }\n    }\n\n    if (index > 0) {\n        out[index - 1] = '\\0'; \n    } else {\n        out[0] = '\\0';\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"\"), \"\") == 0);\n    assert(strcmp(func0(\"three\"), \"three\") == 0);\n    assert(strcmp(func0(\"three five nine\"), \"three five nine\") == 0);\n    assert(strcmp(func0(\"five zero four seven nine eight\"), \"zero four five seven eight nine\") == 0);\n    assert(strcmp(func0(\"six five four three two one zero\"), \"zero one two three four five six\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  lea    0xebc(%rip),%r15        # 2009 <_fini+0xad1>\n  pxor   %xmm0,%xmm0\n  push   %r14\n  lea    0xeb3(%rip),%r14        # 200d <_fini+0xad5>\n  movq   %r15,%xmm4\n  push   %r13\n  lea    0xe98(%rip),%r13        # 2000 <_fini+0xac8>\n  movq   %r14,%xmm6\n  push   %r12\n  movq   %r13,%xmm5\n  punpcklqdq %xmm6,%xmm4\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  movq   0x2c67(%rip),%xmm3        # 3df0 <__do_global_dtors_aux_fini_array_entry+0x10>\n  movq   0x2c6f(%rip),%xmm2        # 3e00 <__do_global_dtors_aux_fini_array_entry+0x20>\n  movq   0x2c77(%rip),%xmm1        # 3e10 <__do_global_dtors_aux_fini_array_entry+0x30>\n  movhps 0x2c48(%rip),%xmm5        # 3de8 <__do_global_dtors_aux_fini_array_entry+0x8>\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%eax\n  movhps 0x2c3b(%rip),%xmm3        # 3df8 <__do_global_dtors_aux_fini_array_entry+0x18>\n  movaps %xmm0,(%rsp)\n  movhps 0x2c40(%rip),%xmm2        # 3e08 <__do_global_dtors_aux_fini_array_entry+0x28>\n  movhps 0x2c49(%rip),%xmm1        # 3e18 <__do_global_dtors_aux_fini_array_entry+0x38>\n  movaps %xmm0,0x10(%rsp)\n  movq   $0x0,0x20(%rsp)\n  movaps %xmm5,0x30(%rsp)\n  movaps %xmm4,0x40(%rsp)\n  movaps %xmm3,0x50(%rsp)\n  movaps %xmm2,0x60(%rsp)\n  movaps %xmm1,0x70(%rsp)\n  test   %al,%al\n  je     139b <func0+0x25b>\n  mov    %rdi,%rbp\n  lea    0x82(%rsp),%rbx\n  jmp    1372 <func0+0x232>\n  mov    %al,0x82(%rsp)\n  movzbl 0x1(%rbp),%eax\n  test   $0xdf,%al\n  je     1458 <func0+0x318>\n  mov    %al,0x83(%rsp)\n  movzbl 0x2(%rbp),%eax\n  test   $0xdf,%al\n  je     1468 <func0+0x328>\n  mov    %al,0x84(%rsp)\n  movzbl 0x3(%rbp),%eax\n  test   $0xdf,%al\n  je     1481 <func0+0x341>\n  mov    %al,0x85(%rsp)\n  movzbl 0x4(%rbp),%eax\n  test   $0xdf,%al\n  je     1491 <func0+0x351>\n  mov    %al,0x86(%rsp)\n  movzbl 0x5(%rbp),%eax\n  test   $0xdf,%al\n  je     14a1 <func0+0x361>\n  mov    %al,0x87(%rsp)\n  mov    $0x6,%r12d\n  mov    $0x6,%eax\n  add    $0x1,%r12\n  mov    %r13,%rsi\n  mov    %rbx,%rdi\n  movb   $0x0,0x82(%rsp,%rax,1)\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     138c <func0+0x24c>\n  lea    0xd60(%rip),%rsi        # 2005 <_fini+0xacd>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1387 <func0+0x247>\n  mov    %r15,%rsi\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     14c1 <func0+0x381>\n  mov    %r14,%rsi\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     14b1 <func0+0x371>\n  lea    0xd31(%rip),%rsi        # 2013 <_fini+0xadb>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     14e1 <func0+0x3a1>\n  lea    0xd1f(%rip),%rsi        # 2018 <_fini+0xae0>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     14d1 <func0+0x391>\n  lea    0xd0d(%rip),%rsi        # 201d <_fini+0xae5>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1501 <func0+0x3c1>\n  lea    0xcfa(%rip),%rsi        # 2021 <_fini+0xae9>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1511 <func0+0x3d1>\n  lea    0xce9(%rip),%rsi        # 2027 <_fini+0xaef>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1521 <func0+0x3e1>\n  lea    0xcd8(%rip),%rsi        # 202d <_fini+0xaf5>\n  mov    %rbx,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     14f1 <func0+0x3b1>\n  add    %r12,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     139b <func0+0x25b>\n  movzbl 0x0(%rbp),%eax\n  test   $0xdf,%al\n  jne    120e <func0+0xce>\n  mov    $0x1,%r12d\n  xor    %eax,%eax\n  jmp    1283 <func0+0x143>\n  mov    $0x1,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  add    %r12,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  jne    136e <func0+0x22e>\n  lea    0x2cbe(%rip),%r12        # 4060 <out.0>\n  xor    %ebx,%ebx\n  xor    %esi,%esi\n  mov    %rsp,%rbp\n  lea    -0x1(%r12),%rdi\n  xchg   %ax,%ax\n  mov    0x0(%rbp,%rbx,4),%r10d\n  test   %r10d,%r10d\n  jle    1414 <func0+0x2d4>\n  mov    0x30(%rsp,%rbx,8),%r11\n  xor    %r8d,%r8d\n  movzbl (%r11),%r9d\n  cs nopw 0x0(%rax,%rax,1)\n  movslq %esi,%rcx\n  test   %r9b,%r9b\n  je     1403 <func0+0x2c3>\n  lea    0x1(%rsi),%eax\n  movslq %esi,%rcx\n  mov    %r11,%rsi\n  mov    %r9d,%edx\n  cltq\n  sub    %rcx,%rsi\n  nopl   0x0(%rax)\n  mov    %dl,(%rdi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    13f0 <func0+0x2b0>\n  add    $0x1,%r8d\n  movb   $0x20,(%r12,%rcx,1)\n  lea    0x1(%rcx),%esi\n  cmp    %r8d,%r10d\n  jne    13d0 <func0+0x290>\n  add    $0x1,%rbx\n  cmp    $0xa,%rbx\n  jne    13b0 <func0+0x270>\n  test   %esi,%esi\n  je     1478 <func0+0x338>\n  lea    -0x1(%rsi),%eax\n  cltq\n  movb   $0x0,(%r12,%rax,1)\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1531 <func0+0x3f1>\n  add    $0x98,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    $0x1,%eax\n  mov    $0x1,%r12d\n  jmp    127f <func0+0x13f>\n  mov    $0x2,%eax\n  mov    $0x2,%r12d\n  jmp    127f <func0+0x13f>\n  movb   $0x0,0x2be1(%rip)        # 4060 <out.0>\n  jmp    142c <func0+0x2ec>\n  mov    $0x3,%eax\n  mov    $0x3,%r12d\n  jmp    127f <func0+0x13f>\n  mov    $0x4,%eax\n  mov    $0x4,%r12d\n  jmp    127f <func0+0x13f>\n  mov    $0x5,%eax\n  mov    $0x5,%r12d\n  jmp    127f <func0+0x13f>\n  mov    $0x3,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x2,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x5,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x4,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x9,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x6,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x7,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  mov    $0x8,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    1392 <func0+0x252>\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  lea    D0(%rip),%r15\n  pxor   %xmm0,%xmm0\n  push   %r14\n  lea    D1(%rip),%r14\n  movq   %r15,%xmm4\n  push   %r13\n  lea    D2(%rip),%r13\n  movq   %r14,%xmm6\n  push   %r12\n  movq   %r13,%xmm5\n  punpcklqdq %xmm6,%xmm4\n  push   %rbp\n  push   %rbx\n  sub    $0x98,%rsp\n  movq   D3(%rip),%xmm3\n  movq   D4(%rip),%xmm2\n  movq   D5(%rip),%xmm1\n  movhps D6(%rip),%xmm5\n  mov    %fs:0x28,%rax\n  mov    %rax,0x88(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%eax\n  movhps D7(%rip),%xmm3\n  movaps %xmm0,(%rsp)\n  movhps D8(%rip),%xmm2\n  movhps D9(%rip),%xmm1\n  movaps %xmm0,0x10(%rsp)\n  movq   $0x0,0x20(%rsp)\n  movaps %xmm5,0x30(%rsp)\n  movaps %xmm4,0x40(%rsp)\n  movaps %xmm3,0x50(%rsp)\n  movaps %xmm2,0x60(%rsp)\n  movaps %xmm1,0x70(%rsp)\n  test   %al,%al\n  je     L0\n  mov    %rdi,%rbp\n  lea    0x82(%rsp),%rbx\n  jmp    L1\nL17:\n  mov    %al,0x82(%rsp)\n  movzbl 0x1(%rbp),%eax\n  test   $0xdf,%al\n  je     L2\n  mov    %al,0x83(%rsp)\n  movzbl 0x2(%rbp),%eax\n  test   $0xdf,%al\n  je     L3\n  mov    %al,0x84(%rsp)\n  movzbl 0x3(%rbp),%eax\n  test   $0xdf,%al\n  je     L4\n  mov    %al,0x85(%rsp)\n  movzbl 0x4(%rbp),%eax\n  test   $0xdf,%al\n  je     L5\n  mov    %al,0x86(%rsp)\n  movzbl 0x5(%rbp),%eax\n  test   $0xdf,%al\n  je     L6\n  mov    %al,0x87(%rsp)\n  mov    $0x6,%r12d\n  mov    $0x6,%eax\nL27:\n  add    $0x1,%r12\nL18:\n  mov    %r13,%rsi\n  mov    %rbx,%rdi\n  movb   $0x0,0x82(%rsp,%rax,1)\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L7\n  lea    D10(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L8\n  mov    %r15,%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L9\n  mov    %r14,%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L10\n  lea    D11(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L11\n  lea    D12(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L12\n  lea    D13(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L13\n  lea    D14(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L14\n  lea    D15(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L15\n  lea    D16(%rip),%rsi\n  mov    %rbx,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L16\n  add    %r12,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  je     L0\nL19:\n  movzbl 0x0(%rbp),%eax\nL1:\n  test   $0xdf,%al\n  jne    L17\n  mov    $0x1,%r12d\n  xor    %eax,%eax\n  jmp    L18\nL8:\n  mov    $0x1,%eax\nL7:\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\nL29:\n  add    %r12,%rbp\n  cmpb   $0x0,-0x1(%rbp)\n  jne    L19\nL0:\n  lea    D17(%rip),%r12\n  xor    %ebx,%ebx\n  xor    %esi,%esi\n  mov    %rsp,%rbp\n  lea    -0x1(%r12),%rdi\n  xchg   %ax,%ax\nL24:\n  mov    0x0(%rbp,%rbx,4),%r10d\n  test   %r10d,%r10d\n  jle    L20\n  mov    0x30(%rsp,%rbx,8),%r11\n  xor    %r8d,%r8d\n  movzbl (%r11),%r9d\n  cs nopw 0x0(%rax,%rax,1)\nL23:\n  movslq %esi,%rcx\n  test   %r9b,%r9b\n  je     L21\n  lea    0x1(%rsi),%eax\n  movslq %esi,%rcx\n  mov    %r11,%rsi\n  mov    %r9d,%edx\n  cltq\n  sub    %rcx,%rsi\n  nopl   0x0(%rax)\nL22:\n  mov    %dl,(%rdi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rsi,%rax,1),%edx\n  test   %dl,%dl\n  jne    L22\nL21:\n  add    $0x1,%r8d\n  movb   $0x20,(%r12,%rcx,1)\n  lea    0x1(%rcx),%esi\n  cmp    %r8d,%r10d\n  jne    L23\nL20:\n  add    $0x1,%rbx\n  cmp    $0xa,%rbx\n  jne    L24\n  test   %esi,%esi\n  je     L25\n  lea    -0x1(%rsi),%eax\n  cltq\n  movb   $0x0,(%r12,%rax,1)\nL28:\n  mov    0x88(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L26\n  add    $0x98,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL2:\n  mov    $0x1,%eax\n  mov    $0x1,%r12d\n  jmp    L27\nL3:\n  mov    $0x2,%eax\n  mov    $0x2,%r12d\n  jmp    L27\nL25:\n  movb   $0x0,D17(%rip)\n  jmp    L28\nL4:\n  mov    $0x3,%eax\n  mov    $0x3,%r12d\n  jmp    L27\nL5:\n  mov    $0x4,%eax\n  mov    $0x4,%r12d\n  jmp    L27\nL6:\n  mov    $0x5,%eax\n  mov    $0x5,%r12d\n  jmp    L27\nL10:\n  mov    $0x3,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL9:\n  mov    $0x2,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL12:\n  mov    $0x5,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL11:\n  mov    $0x4,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL16:\n  mov    $0x9,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL13:\n  mov    $0x6,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL14:\n  mov    $0x7,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL15:\n  mov    $0x8,%eax\n  cltq\n  addl   $0x1,(%rsp,%rax,4)\n  jmp    L29\nL26:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 7,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8201,
                "bias": [
                    3772
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8205,
                "bias": [
                    3763
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8192,
                "bias": [
                    3736
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 15856,
                "bias": [
                    11367
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 15872,
                "bias": [
                    11375
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 15888,
                "bias": [
                    11383
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 15848,
                "bias": [
                    11336
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 15864,
                "bias": [
                    11323
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 15880,
                "bias": [
                    11328
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 15896,
                "bias": [
                    11337
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 8197,
                "bias": [
                    3424
                ]
            },
            "D11": {
                "label": "D11",
                "addr": 8211,
                "bias": [
                    3377
                ]
            },
            "D12": {
                "label": "D12",
                "addr": 8216,
                "bias": [
                    3359
                ]
            },
            "D13": {
                "label": "D13",
                "addr": 8221,
                "bias": [
                    3341
                ]
            },
            "D14": {
                "label": "D14",
                "addr": 8225,
                "bias": [
                    3322
                ]
            },
            "D15": {
                "label": "D15",
                "addr": 8231,
                "bias": [
                    3305
                ]
            },
            "D16": {
                "label": "D16",
                "addr": 8237,
                "bias": [
                    3288
                ]
            },
            "D17": {
                "label": "D17",
                "addr": 16480,
                "bias": [
                    11454,
                    11233
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5019
            },
            "L1": {
                "label": "L1",
                "addr": 4978
            },
            "L2": {
                "label": "L2",
                "addr": 5208
            },
            "L3": {
                "label": "L3",
                "addr": 5224
            },
            "L4": {
                "label": "L4",
                "addr": 5249
            },
            "L5": {
                "label": "L5",
                "addr": 5265
            },
            "L6": {
                "label": "L6",
                "addr": 5281
            },
            "L7": {
                "label": "L7",
                "addr": 5004
            },
            "L8": {
                "label": "L8",
                "addr": 4999
            },
            "L9": {
                "label": "L9",
                "addr": 5313
            },
            "L10": {
                "label": "L10",
                "addr": 5297
            },
            "L11": {
                "label": "L11",
                "addr": 5345
            },
            "L12": {
                "label": "L12",
                "addr": 5329
            },
            "L13": {
                "label": "L13",
                "addr": 5377
            },
            "L14": {
                "label": "L14",
                "addr": 5393
            },
            "L15": {
                "label": "L15",
                "addr": 5409
            },
            "L16": {
                "label": "L16",
                "addr": 5361
            },
            "L17": {
                "label": "L17",
                "addr": 4622
            },
            "L18": {
                "label": "L18",
                "addr": 4739
            },
            "L19": {
                "label": "L19",
                "addr": 4974
            },
            "L20": {
                "label": "L20",
                "addr": 5140
            },
            "L21": {
                "label": "L21",
                "addr": 5123
            },
            "L22": {
                "label": "L22",
                "addr": 5104
            },
            "L23": {
                "label": "L23",
                "addr": 5072
            },
            "L24": {
                "label": "L24",
                "addr": 5040
            },
            "L25": {
                "label": "L25",
                "addr": 5240
            },
            "L26": {
                "label": "L26",
                "addr": 5425
            },
            "L27": {
                "label": "L27",
                "addr": 4735
            },
            "L28": {
                "label": "L28",
                "addr": 5164
            },
            "L29": {
                "label": "L29",
                "addr": 5010
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "7a65726f006f6e650074776f00746872656500666f757200666976650073697800736576656e006569676874006e696e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"zero\""
                },
                "0x2021": {
                    "type": "string",
                    "value": "\"seven\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"one\""
                },
                "0x2027": {
                    "type": "string",
                    "value": "\"eight\""
                },
                "0x2009": {
                    "type": "string",
                    "value": "\"two\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"three\""
                },
                "0x202d": {
                    "type": "string",
                    "value": "\"nine\""
                },
                "0x2013": {
                    "type": "string",
                    "value": "\"four\""
                },
                "0x2018": {
                    "type": "string",
                    "value": "\"five\""
                },
                "0x201d": {
                    "type": "string",
                    "value": "\"six\""
                },
                "0x3df0": {
                    "type": "byte[8]",
                    "value": []
                },
                "0x3e00": {
                    "type": "byte[8]",
                    "value": []
                },
                "0x3e10": {
                    "type": "byte[8]",
                    "value": []
                },
                "0x3de8": {
                    "type": "byte[8]",
                    "value": []
                },
                "0x3df8": {
                    "type": "byte[8]",
                    "value": []
                },
                "0x3e08": {
                    "type": "byte[8]",
                    "value": []
                },
                "0x3e18": {
                    "type": "byte[8]",
                    "value": []
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 20,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  movss  0xeec(%rip),%xmm0        # 2000 <_fini+0xd9c>\n  movss  %xmm0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0x38(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  movss  0x4(%rax),%xmm0\n  movss  %xmm0,(%rdx)\n  movl   $0x0,-0x10(%rbp)\n  jmp    1209 <func0+0x110>\n  mov    -0x10(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    11f9 <func0+0x100>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  subss  %xmm1,%xmm0\n  movss  0xe7c(%rip),%xmm1        # 2010 <_fini+0xdac>\n  andps  %xmm1,%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  movss  -0x14(%rbp),%xmm0\n  comiss -0x4(%rbp),%xmm0\n  jbe    11f5 <func0+0xfc>\n  movss  -0x4(%rbp),%xmm0\n  movss  %xmm0,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1158 <func0+0x5f>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     114a <func0+0x51>\n  mov    -0x38(%rbp),%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  ja     1230 <func0+0x137>\n  jmp    125f <func0+0x166>\n  mov    -0x38(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  mov    -0x38(%rbp),%rax\n  movss  0x4(%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  -0x8(%rbp),%xmm0\n  movss  %xmm0,(%rax)\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  movss  D0(%rip),%xmm0\n  movss  %xmm0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0x38(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  movss  0x4(%rax),%xmm0\n  movss  %xmm0,(%rdx)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL4:\n  mov    -0x10(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    L1\nL3:\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  subss  %xmm1,%xmm0\n  movss  D1(%rip),%xmm1\n  andps  %xmm1,%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  movss  -0x14(%rbp),%xmm0\n  comiss -0x4(%rbp),%xmm0\n  jbe    L2\n  movss  -0x4(%rbp),%xmm0\n  movss  %xmm0,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL1:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L3\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L4\n  mov    -0x38(%rbp),%rax\n  movss  (%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  ja     L5\n  jmp    L6\nL5:\n  mov    -0x38(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  mov    -0x38(%rbp),%rax\n  movss  0x4(%rax),%xmm0\n  mov    -0x38(%rbp),%rax\n  movss  %xmm0,(%rax)\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movss  -0x8(%rbp),%xmm0\n  movss  %xmm0,(%rax)\nL6:\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3820
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3708
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4617
            },
            "L1": {
                "label": "L1",
                "addr": 4601
            },
            "L2": {
                "label": "L2",
                "addr": 4597
            },
            "L3": {
                "label": "L3",
                "addr": 4440
            },
            "L4": {
                "label": "L4",
                "addr": 4426
            },
            "L5": {
                "label": "L5",
                "addr": 4656
            },
            "L6": {
                "label": "L6",
                "addr": 4703
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffff7f7f000000000000000000000000ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2010": {
                    "type": "dword",
                    "value": 2147483647
                },
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        255,
                        255,
                        127,
                        127
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 20,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdx,%rcx\n  movss  (%rdi),%xmm0\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm0\n  movss  %xmm0,0x4(%rdx)\n  test   %esi,%esi\n  jle    118d <func0+0x94>\n  lea    0x4(%rdi),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r9d\n  mov    $0x1,%r8d\n  movss  0xed1(%rip),%xmm2        # 2000 <_fini+0xe58>\n  add    $0x8,%rdi\n  movss  0xed5(%rip),%xmm3        # 2010 <_fini+0xe68>\n  jmp    1174 <func0+0x7b>\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     116c <func0+0x73>\n  movss  -0x4(%rdx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rax),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    113d <func0+0x44>\n  movss  %xmm1,(%rcx)\n  movss  (%rax),%xmm1\n  movss  %xmm1,0x4(%rcx)\n  movaps %xmm0,%xmm2\n  jmp    113d <func0+0x44>\n  add    $0x1,%r8\n  add    $0x4,%rdx\n  cmp    %r9,%r8\n  je     118d <func0+0x94>\n  mov    %r10d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rdi,%rax,4),%rsi\n  mov    %rdx,%rax\n  jmp    1146 <func0+0x4d>\n  movss  (%rcx),%xmm0\n  movss  0x4(%rcx),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    11a4 <func0+0xab>\n  movss  %xmm1,(%rcx)\n  movss  %xmm0,0x4(%rcx)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdx,%rcx\n  movss  (%rdi),%xmm0\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm0\n  movss  %xmm0,0x4(%rdx)\n  test   %esi,%esi\n  jle    L0\n  lea    0x4(%rdi),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r9d\n  mov    $0x1,%r8d\n  movss  D0(%rip),%xmm2\n  add    $0x8,%rdi\n  movss  D1(%rip),%xmm3\n  jmp    L1\nL3:\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     L2\nL4:\n  movss  -0x4(%rdx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rax),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    L3\n  movss  %xmm1,(%rcx)\n  movss  (%rax),%xmm1\n  movss  %xmm1,0x4(%rcx)\n  movaps %xmm0,%xmm2\n  jmp    L3\nL2:\n  add    $0x1,%r8\n  add    $0x4,%rdx\nL1:\n  cmp    %r9,%r8\n  je     L0\n  mov    %r10d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rdi,%rax,4),%rsi\n  mov    %rdx,%rax\n  jmp    L4\nL0:\n  movss  (%rcx),%xmm0\n  movss  0x4(%rcx),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L5\n  movss  %xmm1,(%rcx)\n  movss  %xmm0,0x4(%rcx)\nL5:\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3793
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3797
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4493
            },
            "L1": {
                "label": "L1",
                "addr": 4468
            },
            "L2": {
                "label": "L2",
                "addr": 4460
            },
            "L3": {
                "label": "L3",
                "addr": 4413
            },
            "L4": {
                "label": "L4",
                "addr": 4422
            },
            "L5": {
                "label": "L5",
                "addr": 4516
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffff7f7f000000000000000000000000ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2010": {
                    "type": "dword",
                    "value": 2147483647
                },
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        255,
                        255,
                        127,
                        127
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 20,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  mov    %rdx,%rcx\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm1\n  movss  %xmm1,0x4(%rdx)\n  test   %esi,%esi\n  jle    11ab <func0+0xab>\n  mov    %esi,%r9d\n  lea    0x4(%rdi),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    $0x1,%r8d\n  movss  0xec6(%rip),%xmm2        # 2000 <_fini+0xe44>\n  add    $0x8,%rdi\n  movss  0xeca(%rip),%xmm3        # 2010 <_fini+0xe54>\n  cmp    %r9,%r8\n  je     11a2 <func0+0xa2>\n  nopl   0x0(%rax,%rax,1)\n  mov    %r10d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rdi,%rax,4),%rsi\n  mov    %rdx,%rax\n  nopw   0x0(%rax,%rax,1)\n  movss  -0x4(%rdx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rax),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    118c <func0+0x8c>\n  movss  %xmm1,(%rcx)\n  movss  (%rax),%xmm1\n  movaps %xmm0,%xmm2\n  movss  %xmm1,0x4(%rcx)\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  jne    1168 <func0+0x68>\n  add    $0x1,%r8\n  add    $0x4,%rdx\n  cmp    %r9,%r8\n  jne    1150 <func0+0x50>\n  movss  (%rcx),%xmm0\n  movss  0x4(%rcx),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    11b9 <func0+0xb9>\n  movss  %xmm1,(%rcx)\n  movss  %xmm0,0x4(%rcx)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  mov    %rdx,%rcx\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm1\n  movss  %xmm1,0x4(%rdx)\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%r9d\n  lea    0x4(%rdi),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    $0x1,%r8d\n  movss  D0(%rip),%xmm2\n  add    $0x8,%rdi\n  movss  D1(%rip),%xmm3\n  cmp    %r9,%r8\n  je     L1\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    %r10d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rdi,%rax,4),%rsi\n  mov    %rdx,%rax\n  nopw   0x0(%rax,%rax,1)\nL3:\n  movss  -0x4(%rdx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rax),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    L2\n  movss  %xmm1,(%rcx)\n  movss  (%rax),%xmm1\n  movaps %xmm0,%xmm2\n  movss  %xmm1,0x4(%rcx)\nL2:\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  jne    L3\n  add    $0x1,%r8\n  add    $0x4,%rdx\n  cmp    %r9,%r8\n  jne    L4\nL1:\n  movss  (%rcx),%xmm0\n  movss  0x4(%rcx),%xmm1\nL0:\n  comiss %xmm1,%xmm0\n  jbe    L5\n  movss  %xmm1,(%rcx)\n  movss  %xmm0,0x4(%rcx)\nL5:\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3782
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3786
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4523
            },
            "L1": {
                "label": "L1",
                "addr": 4514
            },
            "L2": {
                "label": "L2",
                "addr": 4492
            },
            "L3": {
                "label": "L3",
                "addr": 4456
            },
            "L4": {
                "label": "L4",
                "addr": 4432
            },
            "L5": {
                "label": "L5",
                "addr": 4537
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffff7f7f000000000000000000000000ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2010": {
                    "type": "dword",
                    "value": 2147483647
                },
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        255,
                        255,
                        127,
                        127
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 20,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n\nvoid func0(float numbers[], int size, float out[2]) {\n    float min_diff = FLT_MAX;\n    int i, j;\n\n    out[0] = numbers[0];\n    out[1] = numbers[1];\n\n    for (i = 0; i < size; i++) {\n        for (j = i + 1; j < size; j++) {\n            float diff = fabs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                out[0] = numbers[i];\n                out[1] = numbers[j];\n            }\n        }\n    }\n\n    if (out[0] > out[1]) {\n        float temp = out[0];\n        out[0] = out[1];\n        out[1] = temp;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\nint issame(float a[], float b[], int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float result[2];\n\n    float test1[] = {1.0, 2.0, 3.9, 4.0, 5.0, 2.2};\n    float expected1[] = {3.9, 4.0};\n    func0(test1, 6, result);\n    assert(issame(result, expected1, 2));\n\n    float test2[] = {1.0, 2.0, 5.9, 4.0, 5.0};\n    float expected2[] = {5.0, 5.9};\n    func0(test2, 5, result);\n    assert(issame(result, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.2};\n    float expected3[] = {2.0, 2.2};\n    func0(test3, 6, result);\n    assert(issame(result, expected3, 2));\n\n    float test4[] = {1.0, 2.0, 3.0, 4.0, 5.0, 2.0};\n    float expected4[] = {2.0, 2.0};\n    func0(test4, 6, result);\n    assert(issame(result, expected4, 2));\n\n    float test5[] = {1.1, 2.2, 3.1, 4.1, 5.1};\n    float expected5[] = {2.2, 3.1};\n    func0(test5, 5, result);\n    assert(issame(result, expected5, 2));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm1\n  movss  %xmm1,0x4(%rdx)\n  test   %esi,%esi\n  jle    118b <func0+0x8b>\n  cmp    $0x1,%esi\n  je     1182 <func0+0x82>\n  movss  0xed9(%rip),%xmm2        # 2000 <_fini+0xe64>\n  mov    %rdi,%rcx\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  movss  0xed5(%rip),%xmm3        # 2010 <_fini+0xe74>\n  nopl   0x0(%rax,%rax,1)\n  mov    %r8,%rax\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rcx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rdi,%rax,4),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    116d <func0+0x6d>\n  movss  %xmm1,(%rdx)\n  movss  (%rdi,%rax,4),%xmm1\n  movaps %xmm0,%xmm2\n  movss  %xmm1,0x4(%rdx)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     1148 <func0+0x48>\n  add    $0x1,%r8\n  add    $0x4,%rcx\n  cmp    %r8,%r9\n  jne    1140 <func0+0x40>\n  movss  (%rdx),%xmm0\n  movss  0x4(%rdx),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1199 <func0+0x99>\n  movss  %xmm1,(%rdx)\n  movss  %xmm0,0x4(%rdx)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  movss  %xmm0,(%rdx)\n  movss  0x4(%rdi),%xmm1\n  movss  %xmm1,0x4(%rdx)\n  test   %esi,%esi\n  jle    L0\n  cmp    $0x1,%esi\n  je     L1\n  movss  D0(%rip),%xmm2\n  mov    %rdi,%rcx\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  movss  D1(%rip),%xmm3\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    %r8,%rax\n  nopl   0x0(%rax,%rax,1)\nL3:\n  movss  (%rcx),%xmm1\n  movaps %xmm1,%xmm0\n  subss  (%rdi,%rax,4),%xmm0\n  andps  %xmm3,%xmm0\n  comiss %xmm0,%xmm2\n  jbe    L2\n  movss  %xmm1,(%rdx)\n  movss  (%rdi,%rax,4),%xmm1\n  movaps %xmm0,%xmm2\n  movss  %xmm1,0x4(%rdx)\nL2:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L3\n  add    $0x1,%r8\n  add    $0x4,%rcx\n  cmp    %r8,%r9\n  jne    L4\nL1:\n  movss  (%rdx),%xmm0\n  movss  0x4(%rdx),%xmm1\nL0:\n  comiss %xmm1,%xmm0\n  jbe    L5\n  movss  %xmm1,(%rdx)\n  movss  %xmm0,0x4(%rdx)\nL5:\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3801
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3797
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4491
            },
            "L1": {
                "label": "L1",
                "addr": 4482
            },
            "L2": {
                "label": "L2",
                "addr": 4461
            },
            "L3": {
                "label": "L3",
                "addr": 4424
            },
            "L4": {
                "label": "L4",
                "addr": 4416
            },
            "L5": {
                "label": "L5",
                "addr": 4505
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffff7f7f000000000000000000000000ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2010": {
                    "type": "dword",
                    "value": 2147483647
                },
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        255,
                        255,
                        127,
                        127
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 21,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x18(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  jmp    11a9 <func0+0xb0>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  movss  -0x10(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    116a <func0+0x71>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss -0xc(%rbp),%xmm0\n  jbe    11a5 <func0+0xac>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     112b <func0+0x32>\n  movl   $0x0,-0x4(%rbp)\n  jmp    1205 <func0+0x10c>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  subss  -0x10(%rbp),%xmm0\n  movss  -0xc(%rbp),%xmm1\n  subss  -0x10(%rbp),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     11be <func0+0xc5>\n  nop\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x18(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  jmp    L0\nL3:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  movss  -0x10(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    L1\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x10(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss -0xc(%rbp),%xmm0\n  jbe    L2\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\nL2:\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  movl   $0x0,-0x4(%rbp)\n  jmp    L4\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  subss  -0x10(%rbp),%xmm0\n  movss  -0xc(%rbp),%xmm1\n  subss  -0x10(%rbp),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x4(%rbp)\nL4:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  nop\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4521
            },
            "L1": {
                "label": "L1",
                "addr": 4458
            },
            "L2": {
                "label": "L2",
                "addr": 4517
            },
            "L3": {
                "label": "L3",
                "addr": 4395
            },
            "L4": {
                "label": "L4",
                "addr": 4613
            },
            "L5": {
                "label": "L5",
                "addr": 4542
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 21,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm1\n  cmp    $0x1,%esi\n  jle    1157 <func0+0x5e>\n  lea    0x4(%rdi),%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x8(%rdi,%rdx,4),%rdx\n  movaps %xmm1,%xmm0\n  movss  (%rax),%xmm2\n  movaps %xmm2,%xmm3\n  minss  %xmm1,%xmm3\n  movaps %xmm3,%xmm1\n  maxss  %xmm0,%xmm2\n  movaps %xmm2,%xmm0\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    1115 <func0+0x1c>\n  mov    $0x0,%eax\n  subss  %xmm3,%xmm2\n  movss  (%rdi,%rax,4),%xmm0\n  subss  %xmm1,%xmm0\n  divss  %xmm2,%xmm0\n  movss  %xmm0,(%rdi,%rax,4)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     113c <func0+0x43>\n  ret\n  je     115a <func0+0x61>\n  ret\n  movss  (%rdi),%xmm0\n  subss  %xmm1,%xmm0\n  subss  %xmm1,%xmm1\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  jmp    1159 <func0+0x60>",
        "asm_labeled": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm1\n  cmp    $0x1,%esi\n  jle    L0\n  lea    0x4(%rdi),%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x8(%rdi,%rdx,4),%rdx\n  movaps %xmm1,%xmm0\nL1:\n  movss  (%rax),%xmm2\n  movaps %xmm2,%xmm3\n  minss  %xmm1,%xmm3\n  movaps %xmm3,%xmm1\n  maxss  %xmm0,%xmm2\n  movaps %xmm2,%xmm0\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    L1\n  mov    $0x0,%eax\n  subss  %xmm3,%xmm2\nL2:\n  movss  (%rdi,%rax,4),%xmm0\n  subss  %xmm1,%xmm0\n  divss  %xmm2,%xmm0\n  movss  %xmm0,(%rdi,%rax,4)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L2\n  ret\nL0:\n  je     L3\nL4:\n  ret\nL3:\n  movss  (%rdi),%xmm0\n  subss  %xmm1,%xmm0\n  subss  %xmm1,%xmm1\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4439
            },
            "L1": {
                "label": "L1",
                "addr": 4373
            },
            "L2": {
                "label": "L2",
                "addr": 4412
            },
            "L3": {
                "label": "L3",
                "addr": 4442
            },
            "L4": {
                "label": "L4",
                "addr": 4441
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 21,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  cmp    $0x1,%esi\n  jle    1170 <func0+0x70>\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi),%rax\n  movaps %xmm0,%xmm1\n  lea    0x8(%rdi,%rdx,4),%rdx\n  movaps %xmm0,%xmm2\n  nop\n  movss  (%rax),%xmm3\n  add    $0x4,%rax\n  movaps %xmm3,%xmm4\n  maxss  %xmm1,%xmm3\n  minss  %xmm2,%xmm4\n  movaps %xmm3,%xmm1\n  movaps %xmm4,%xmm2\n  cmp    %rax,%rdx\n  jne    1120 <func0+0x20>\n  subss  %xmm2,%xmm1\n  xor    %eax,%eax\n  jmp    1155 <func0+0x55>\n  cs nopw 0x0(%rax,%rax,1)\n  movss  (%rdi,%rax,4),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi,%rax,4)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     1150 <func0+0x50>\n  ret\n  nopl   0x0(%rax,%rax,1)\n  jne    116a <func0+0x6a>\n  movaps %xmm0,%xmm1\n  movaps %xmm0,%xmm2\n  jmp    113e <func0+0x3e>",
        "asm_labeled": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm0\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi),%rax\n  movaps %xmm0,%xmm1\n  lea    0x8(%rdi,%rdx,4),%rdx\n  movaps %xmm0,%xmm2\n  nop\nL1:\n  movss  (%rax),%xmm3\n  add    $0x4,%rax\n  movaps %xmm3,%xmm4\n  maxss  %xmm1,%xmm3\n  minss  %xmm2,%xmm4\n  movaps %xmm3,%xmm1\n  movaps %xmm4,%xmm2\n  cmp    %rax,%rdx\n  jne    L1\nL5:\n  subss  %xmm2,%xmm1\n  xor    %eax,%eax\n  jmp    L2\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  movss  (%rdi,%rax,4),%xmm0\nL2:\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi,%rax,4)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L3\nL4:\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  jne    L4\n  movaps %xmm0,%xmm1\n  movaps %xmm0,%xmm2\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4464
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            },
            "L2": {
                "label": "L2",
                "addr": 4437
            },
            "L3": {
                "label": "L3",
                "addr": 4432
            },
            "L4": {
                "label": "L4",
                "addr": 4458
            },
            "L5": {
                "label": "L5",
                "addr": 4414
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 21,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nvoid func0(float *numbers, int size) {\n    float min = numbers[0], max = numbers[0];\n    for (int i = 1; i < size; i++) {\n        if (numbers[i] < min) min = numbers[i];\n        if (numbers[i] > max) max = numbers[i];\n    }\n    for (int i = 0; i < size; i++) {\n        numbers[i] = (numbers[i] - min) / (max - min);\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(float *a, float *b, int size) {\n    const float EPSILON = 1e-4;\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > EPSILON) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {2.0, 49.9};\n    float expected1[] = {0.0, 1.0};\n    func0(test1, 2);\n    assert(issame(test1, expected1, 2));\n\n    float test2[] = {100.0, 49.9};\n    float expected2[] = {1.0, 0.0};\n    func0(test2, 2);\n    assert(issame(test2, expected2, 2));\n\n    float test3[] = {1.0, 2.0, 3.0, 4.0, 5.0};\n    float expected3[] = {0.0, 0.25, 0.5, 0.75, 1.0};\n    func0(test3, 5);\n    assert(issame(test3, expected3, 5));\n\n    float test4[] = {2.0, 1.0, 5.0, 3.0, 4.0};\n    float expected4[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test4, 5);\n    assert(issame(test4, expected4, 5));\n\n    float test5[] = {12.0, 11.0, 15.0, 13.0, 14.0};\n    float expected5[] = {0.25, 0.0, 1.0, 0.5, 0.75};\n    func0(test5, 5);\n    assert(issame(test5, expected5, 5));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm3\n  mov    %rdi,%rdx\n  movaps %xmm3,%xmm2\n  cmp    $0x1,%esi\n  jle    1208 <func0+0x108>\n  lea    -0x2(%rsi),%ecx\n  lea    0x4(%rdi),%rax\n  movaps %xmm3,%xmm1\n  lea    0x8(%rdi,%rcx,4),%rcx\n  cs nopw 0x0(%rax,%rax,1)\n  movss  (%rax),%xmm0\n  add    $0x4,%rax\n  movaps %xmm0,%xmm5\n  maxss  %xmm1,%xmm0\n  minss  %xmm2,%xmm5\n  movaps %xmm0,%xmm1\n  movaps %xmm5,%xmm2\n  cmp    %rcx,%rax\n  jne    1130 <func0+0x30>\n  test   %esi,%esi\n  mov    $0x1,%edi\n  subss  %xmm5,%xmm1\n  cmovg  %esi,%edi\n  cmp    $0x3,%esi\n  jle    120b <func0+0x10b>\n  mov    %edi,%ecx\n  movaps %xmm5,%xmm4\n  mov    %rdx,%rax\n  shr    $0x2,%ecx\n  movaps %xmm1,%xmm3\n  shufps $0x0,%xmm4,%xmm4\n  sub    $0x1,%ecx\n  shufps $0x0,%xmm3,%xmm3\n  shl    $0x4,%rcx\n  lea    0x10(%rdx,%rcx,1),%rcx\n  nopw   0x0(%rax,%rax,1)\n  movups (%rax),%xmm0\n  add    $0x10,%rax\n  subps  %xmm4,%xmm0\n  divps  %xmm3,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rcx,%rax\n  jne    1190 <func0+0x90>\n  mov    %edi,%eax\n  and    $0xfffffffc,%eax\n  and    $0x3,%edi\n  je     120a <func0+0x10a>\n  movslq %eax,%rcx\n  add    $0x1,%eax\n  shl    $0x2,%rcx\n  lea    (%rdx,%rcx,1),%rdi\n  movss  (%rdi),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  cmp    %esi,%eax\n  jge    120a <func0+0x10a>\n  lea    0x4(%rdx,%rcx,1),%rdi\n  add    $0x1,%eax\n  movss  (%rdi),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  cmp    %esi,%eax\n  jge    120a <func0+0x10a>\n  lea    0x8(%rdx,%rcx,1),%rax\n  movss  (%rax),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  ret\n  nopl   0x0(%rax)\n  je     1220 <func0+0x120>\n  ret\n  subss  %xmm5,%xmm3\n  mov    $0x1,%eax\n  xor    %ecx,%ecx\n  divss  %xmm1,%xmm3\n  movss  %xmm3,(%rdx)\n  jmp    11d2 <func0+0xd2>\n  subss  %xmm3,%xmm3\n  divss  %xmm3,%xmm3\n  movss  %xmm3,(%rdi)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movss  (%rdi),%xmm3\n  mov    %rdi,%rdx\n  movaps %xmm3,%xmm2\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%ecx\n  lea    0x4(%rdi),%rax\n  movaps %xmm3,%xmm1\n  lea    0x8(%rdi,%rcx,4),%rcx\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  movss  (%rax),%xmm0\n  add    $0x4,%rax\n  movaps %xmm0,%xmm5\n  maxss  %xmm1,%xmm0\n  minss  %xmm2,%xmm5\n  movaps %xmm0,%xmm1\n  movaps %xmm5,%xmm2\n  cmp    %rcx,%rax\n  jne    L1\n  test   %esi,%esi\n  mov    $0x1,%edi\n  subss  %xmm5,%xmm1\n  cmovg  %esi,%edi\n  cmp    $0x3,%esi\n  jle    L2\n  mov    %edi,%ecx\n  movaps %xmm5,%xmm4\n  mov    %rdx,%rax\n  shr    $0x2,%ecx\n  movaps %xmm1,%xmm3\n  shufps $0x0,%xmm4,%xmm4\n  sub    $0x1,%ecx\n  shufps $0x0,%xmm3,%xmm3\n  shl    $0x4,%rcx\n  lea    0x10(%rdx,%rcx,1),%rcx\n  nopw   0x0(%rax,%rax,1)\nL3:\n  movups (%rax),%xmm0\n  add    $0x10,%rax\n  subps  %xmm4,%xmm0\n  divps  %xmm3,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rcx,%rax\n  jne    L3\n  mov    %edi,%eax\n  and    $0xfffffffc,%eax\n  and    $0x3,%edi\n  je     L4\n  movslq %eax,%rcx\n  add    $0x1,%eax\n  shl    $0x2,%rcx\n  lea    (%rdx,%rcx,1),%rdi\n  movss  (%rdi),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  cmp    %esi,%eax\n  jge    L4\nL6:\n  lea    0x4(%rdx,%rcx,1),%rdi\n  add    $0x1,%eax\n  movss  (%rdi),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rdi)\n  cmp    %esi,%eax\n  jge    L4\n  lea    0x8(%rdx,%rcx,1),%rax\n  movss  (%rax),%xmm0\n  subss  %xmm2,%xmm0\n  divss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  ret\n  nopl   0x0(%rax)\nL0:\n  je     L5\nL4:\n  ret\nL2:\n  subss  %xmm5,%xmm3\n  mov    $0x1,%eax\n  xor    %ecx,%ecx\n  divss  %xmm1,%xmm3\n  movss  %xmm3,(%rdx)\n  jmp    L6\nL5:\n  subss  %xmm3,%xmm3\n  divss  %xmm3,%xmm3\n  movss  %xmm3,(%rdi)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4616
            },
            "L1": {
                "label": "L1",
                "addr": 4400
            },
            "L2": {
                "label": "L2",
                "addr": 4619
            },
            "L3": {
                "label": "L3",
                "addr": 4496
            },
            "L4": {
                "label": "L4",
                "addr": 4618
            },
            "L5": {
                "label": "L5",
                "addr": 4640
            },
            "L6": {
                "label": "L6",
                "addr": 4562
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 22,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x20(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  jmp    1269 <func0+0x110>\n  addq   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     11d3 <func0+0x7a>\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x800,%eax\n  test   %eax,%eax\n  jne    11d3 <func0+0x7a>\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2d,%al\n  jne    1190 <func0+0x37>\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     127a <func0+0x121>\n  lea    -0x18(%rbp),%rcx\n  mov    -0x10(%rbp),%rax\n  mov    $0xa,%edx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   1080 <strtol@plt>\n  mov    %eax,-0x1c(%rbp)\n  mov    -0x18(%rbp),%rax\n  cmp    %rax,-0x10(%rbp)\n  je     124b <func0+0xf2>\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  je     121d <func0+0xc4>\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    124b <func0+0xf2>\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  lea    0x2e29(%rip),%rdx        # 4060 <out.0>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rcx,%rdx,1)\n  jmp    1261 <func0+0x108>\n  mov    -0x18(%rbp),%rax\n  add    $0x1,%rax\n  mov    %rax,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     1261 <func0+0x108>\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    123f <func0+0xe6>\n  mov    -0x18(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1195 <func0+0x3c>\n  jmp    127b <func0+0x122>\n  nop\n  mov    -0x30(%rbp),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  lea    0x2dd5(%rip),%rax        # 4060 <out.0>\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     129f <func0+0x146>\n  call   1070 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x20(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  jmp    L0\nL2:\n  addq   $0x1,-0x10(%rbp)\nL8:\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L1\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x800,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2d,%al\n  jne    L2\nL1:\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L3\n  lea    -0x18(%rbp),%rcx\n  mov    -0x10(%rbp),%rax\n  mov    $0xa,%edx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strtol@plt>\n  mov    %eax,-0x1c(%rbp)\n  mov    -0x18(%rbp),%rax\n  cmp    %rax,-0x10(%rbp)\n  je     L4\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  je     L5\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L4\nL5:\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  lea    D0(%rip),%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rcx,%rdx,1)\n  jmp    L6\nL7:\n  mov    -0x18(%rbp),%rax\n  add    $0x1,%rax\n  mov    %rax,-0x18(%rbp)\nL4:\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L6\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    L7\nL6:\n  mov    -0x18(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L8\n  jmp    L9\nL3:\n  nop\nL9:\n  mov    -0x30(%rbp),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  lea    D0(%rip),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L10\n  call   <__stack_chk_fail@plt>\nL10:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 16480,
                "bias": [
                    11817,
                    11733
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4713
            },
            "L1": {
                "label": "L1",
                "addr": 4563
            },
            "L2": {
                "label": "L2",
                "addr": 4496
            },
            "L3": {
                "label": "L3",
                "addr": 4730
            },
            "L4": {
                "label": "L4",
                "addr": 4683
            },
            "L5": {
                "label": "L5",
                "addr": 4637
            },
            "L6": {
                "label": "L6",
                "addr": 4705
            },
            "L7": {
                "label": "L7",
                "addr": 4671
            },
            "L8": {
                "label": "L8",
                "addr": 4501
            },
            "L9": {
                "label": "L9",
                "addr": 4731
            },
            "L10": {
                "label": "L10",
                "addr": 4767
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 22,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,%r15\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%ebx\n  mov    $0x0,%r13d\n  test   %bl,%bl\n  je     1207 <func0+0xae>\n  mov    %rdi,%rbp\n  call   1090 <__ctype_b_loc@plt>\n  mov    %rax,%r12\n  mov    $0x0,%r13d\n  lea    0x2ebd(%rip),%r14        # 4060 <out.0>\n  jmp    11e7 <func0+0x8e>\n  test   %bl,%bl\n  je     1207 <func0+0xae>\n  mov    %rsp,%rsi\n  mov    $0xa,%edx\n  mov    %rbp,%rdi\n  call   1080 <strtol@plt>\n  mov    (%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     1230 <func0+0xd7>\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     11ce <func0+0x75>\n  test   %cl,%cl\n  jne    123c <func0+0xe3>\n  movslq %r13d,%rdx\n  mov    %eax,(%r14,%rdx,4)\n  lea    0x1(%r13),%r13d\n  mov    (%rsp),%rax\n  movzbl (%rax),%ebx\n  test   %bl,%bl\n  je     1207 <func0+0xae>\n  mov    %rax,%rbp\n  movsbq %bl,%rax\n  mov    (%r12),%rdx\n  testb  $0x8,0x1(%rdx,%rax,2)\n  jne    11a5 <func0+0x4c>\n  cmp    $0x2d,%bl\n  je     11a5 <func0+0x4c>\n  lea    0x1(%rbp),%rax\n  movzbl 0x1(%rbp),%ebx\n  test   %bl,%bl\n  jne    11e4 <func0+0x8b>\n  mov    %r13d,(%r15)\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1256 <func0+0xfd>\n  lea    0x2e3f(%rip),%rax        # 4060 <out.0>\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  movzbl 0x0(%rbp),%eax\n  test   %al,%al\n  je     11d9 <func0+0x80>\n  cmp    $0x2c,%al\n  je     11d9 <func0+0x80>\n  lea    0x1(%rdx),%rax\n  mov    %rax,(%rsp)\n  movzbl (%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  je     11d9 <func0+0x80>\n  cmp    $0x2c,%dl\n  jne    1240 <func0+0xe7>\n  jmp    11d9 <func0+0x80>\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,%r15\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%ebx\n  mov    $0x0,%r13d\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r12\n  mov    $0x0,%r13d\n  lea    D0(%rip),%r14\n  jmp    L1\nL5:\n  test   %bl,%bl\n  je     L0\n  mov    %rsp,%rsi\n  mov    $0xa,%edx\n  mov    %rbp,%rdi\n  call   <strtol@plt>\n  mov    (%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     L2\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     L3\n  test   %cl,%cl\n  jne    L4\nL3:\n  movslq %r13d,%rdx\n  mov    %eax,(%r14,%rdx,4)\n  lea    0x1(%r13),%r13d\nL8:\n  mov    (%rsp),%rax\n  movzbl (%rax),%ebx\n  test   %bl,%bl\n  je     L0\nL6:\n  mov    %rax,%rbp\nL1:\n  movsbq %bl,%rax\n  mov    (%r12),%rdx\n  testb  $0x8,0x1(%rdx,%rax,2)\n  jne    L5\n  cmp    $0x2d,%bl\n  je     L5\n  lea    0x1(%rbp),%rax\n  movzbl 0x1(%rbp),%ebx\n  test   %bl,%bl\n  jne    L6\nL0:\n  mov    %r13d,(%r15)\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  lea    D0(%rip),%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL2:\n  movzbl 0x0(%rbp),%eax\n  test   %al,%al\n  je     L8\n  cmp    $0x2c,%al\n  je     L8\nL4:\n  lea    0x1(%rdx),%rax\nL9:\n  mov    %rax,(%rsp)\n  movzbl (%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  je     L8\n  cmp    $0x2c,%dl\n  jne    L9\n  jmp    L8\nL7:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 16480,
                "bias": [
                    11965,
                    11839
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4615
            },
            "L1": {
                "label": "L1",
                "addr": 4583
            },
            "L2": {
                "label": "L2",
                "addr": 4656
            },
            "L3": {
                "label": "L3",
                "addr": 4558
            },
            "L4": {
                "label": "L4",
                "addr": 4668
            },
            "L5": {
                "label": "L5",
                "addr": 4517
            },
            "L6": {
                "label": "L6",
                "addr": 4580
            },
            "L7": {
                "label": "L7",
                "addr": 4694
            },
            "L8": {
                "label": "L8",
                "addr": 4569
            },
            "L9": {
                "label": "L9",
                "addr": 4672
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 22,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  lea    0x2eee(%rip),%r14        # 4060 <out.0>\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rsi,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    %rdi,%rbp\n  xor    %r15d,%r15d\n  lea    0x10(%rsp),%r13\n  call   1090 <__ctype_b_loc@plt>\n  lea    0x2ead(%rip),%r14        # 4060 <out.0>\n  mov    (%rax),%rcx\n  mov    %rax,%r12\n  jmp    11d4 <func0+0x74>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x2d,%bl\n  je     11df <func0+0x7f>\n  movzbl 0x1(%rbp),%ebx\n  lea    0x1(%rbp),%rdx\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    %rdx,%rbp\n  movsbq %bl,%rax\n  testb  $0x8,0x1(%rcx,%rax,2)\n  je     11c0 <func0+0x60>\n  mov    $0xa,%edx\n  mov    %r13,%rsi\n  mov    %rbp,%rdi\n  call   1080 <strtol@plt>\n  mov    0x10(%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     1220 <func0+0xc0>\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     1205 <func0+0xa5>\n  test   %cl,%cl\n  jne    122d <func0+0xcd>\n  movslq %r15d,%rcx\n  add    $0x1,%r15d\n  mov    %eax,(%r14,%rcx,4)\n  movzbl (%rdx),%ebx\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    (%r12),%rcx\n  jmp    11d1 <func0+0x71>\n  nopl   (%rax)\n  movzbl 0x0(%rbp),%ebx\n  cmp    $0x2c,%bl\n  je     127a <func0+0x11a>\n  test   %bl,%bl\n  je     127a <func0+0x11a>\n  lea    0x1(%rdx),%rax\n  jmp    123d <func0+0xdd>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x2c,%bl\n  je     1213 <func0+0xb3>\n  mov    %rax,0x10(%rsp)\n  movzbl (%rax),%ebx\n  mov    %rax,%rdx\n  add    $0x1,%rax\n  test   %bl,%bl\n  jne    1238 <func0+0xd8>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    127f <func0+0x11f>\n  add    $0x28,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    %rbp,%rdx\n  jmp    1213 <func0+0xb3>\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  lea    D0(%rip),%r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rsi,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  xor    %r15d,%r15d\n  lea    0x10(%rsp),%r13\n  call   <__ctype_b_loc@plt>\n  lea    D0(%rip),%r14\n  mov    (%rax),%rcx\n  mov    %rax,%r12\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    $0x2d,%bl\n  je     L2\n  movzbl 0x1(%rbp),%ebx\n  lea    0x1(%rbp),%rdx\n  test   %bl,%bl\n  je     L0\nL7:\n  mov    %rdx,%rbp\nL1:\n  movsbq %bl,%rax\n  testb  $0x8,0x1(%rcx,%rax,2)\n  je     L3\nL2:\n  mov    $0xa,%edx\n  mov    %r13,%rsi\n  mov    %rbp,%rdi\n  call   <strtol@plt>\n  mov    0x10(%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     L4\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     L5\n  test   %cl,%cl\n  jne    L6\nL5:\n  movslq %r15d,%rcx\n  add    $0x1,%r15d\n  mov    %eax,(%r14,%rcx,4)\n  movzbl (%rdx),%ebx\nL10:\n  test   %bl,%bl\n  je     L0\n  mov    (%r12),%rcx\n  jmp    L7\n  nopl   (%rax)\nL4:\n  movzbl 0x0(%rbp),%ebx\n  cmp    $0x2c,%bl\n  je     L8\n  test   %bl,%bl\n  je     L8\nL6:\n  lea    0x1(%rdx),%rax\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL11:\n  cmp    $0x2c,%bl\n  je     L10\nL9:\n  mov    %rax,0x10(%rsp)\n  movzbl (%rax),%ebx\n  mov    %rax,%rdx\n  add    $0x1,%rax\n  test   %bl,%bl\n  jne    L11\nL0:\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L12\n  add    $0x28,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  mov    %rbp,%rdx\n  jmp    L10\nL12:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 16480,
                "bias": [
                    12014,
                    11949
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4688
            },
            "L1": {
                "label": "L1",
                "addr": 4564
            },
            "L2": {
                "label": "L2",
                "addr": 4575
            },
            "L3": {
                "label": "L3",
                "addr": 4544
            },
            "L4": {
                "label": "L4",
                "addr": 4640
            },
            "L5": {
                "label": "L5",
                "addr": 4613
            },
            "L6": {
                "label": "L6",
                "addr": 4653
            },
            "L7": {
                "label": "L7",
                "addr": 4561
            },
            "L8": {
                "label": "L8",
                "addr": 4730
            },
            "L9": {
                "label": "L9",
                "addr": 4669
            },
            "L10": {
                "label": "L10",
                "addr": 4627
            },
            "L11": {
                "label": "L11",
                "addr": 4664
            },
            "L12": {
                "label": "L12",
                "addr": 4735
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 22,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint *func0(const char *values, int *size) {\n    static int out[256];\n    int count = 0;\n    const char *start = values;\n    char *end;\n    while (*start) {\n        while (*start && !isdigit(*start) && *start != '-') {\n            start++;\n        }\n        if (!*start) {\n            break;\n        }\n        int val = (int) strtol(start, &end, 10);\n        if (start != end && (*end == ',' || *end == '\\0')) {\n            out[count++] = val;\n        } else {\n            while (*end && *end != ',') {\n                end++;\n            }\n        }\n        start = end;\n    }\n    *size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test 1\n    int *result1 = func0(\"\", &size);\n    assert(issame(result1, size, (const int[]){}, 0));\n\n    // Test 2\n    int *result2 = func0(\"4,,23.2,9,adasd\", &size);\n    assert(issame(result2, size, (const int[]){4, 9}, 2));\n\n    // Test 3\n    int *result3 = func0(\"3,c,3,3,a,b\", &size);\n    assert(issame(result3, size, (const int[]){3, 3, 3}, 3));\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  lea    0x2eee(%rip),%r14        # 4060 <out.0>\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rsi,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    %rdi,%rbp\n  xor    %r15d,%r15d\n  lea    0x10(%rsp),%r13\n  call   1090 <__ctype_b_loc@plt>\n  lea    0x2ead(%rip),%r14        # 4060 <out.0>\n  mov    (%rax),%rcx\n  mov    %rax,%r12\n  jmp    11d4 <func0+0x74>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x2d,%bl\n  je     11df <func0+0x7f>\n  movzbl 0x1(%rbp),%ebx\n  lea    0x1(%rbp),%rdx\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    %rdx,%rbp\n  movsbq %bl,%rax\n  testb  $0x8,0x1(%rcx,%rax,2)\n  je     11c0 <func0+0x60>\n  mov    $0xa,%edx\n  mov    %r13,%rsi\n  mov    %rbp,%rdi\n  call   1080 <strtol@plt>\n  mov    0x10(%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     1220 <func0+0xc0>\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     1205 <func0+0xa5>\n  test   %cl,%cl\n  jne    122d <func0+0xcd>\n  movslq %r15d,%rcx\n  add    $0x1,%r15d\n  mov    %eax,(%r14,%rcx,4)\n  movzbl (%rdx),%ebx\n  test   %bl,%bl\n  je     1250 <func0+0xf0>\n  mov    (%r12),%rcx\n  jmp    11d1 <func0+0x71>\n  nopl   (%rax)\n  movzbl 0x0(%rbp),%ebx\n  cmp    $0x2c,%bl\n  je     127a <func0+0x11a>\n  test   %bl,%bl\n  je     127a <func0+0x11a>\n  lea    0x1(%rdx),%rax\n  jmp    123d <func0+0xdd>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x2c,%bl\n  je     1213 <func0+0xb3>\n  mov    %rax,0x10(%rsp)\n  movzbl (%rax),%ebx\n  mov    %rax,%rdx\n  add    $0x1,%rax\n  test   %bl,%bl\n  jne    1238 <func0+0xd8>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    127f <func0+0x11f>\n  add    $0x28,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    %rbp,%rdx\n  jmp    1213 <func0+0xb3>\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  lea    D0(%rip),%r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rsi,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  xor    %r15d,%r15d\n  lea    0x10(%rsp),%r13\n  call   <__ctype_b_loc@plt>\n  lea    D0(%rip),%r14\n  mov    (%rax),%rcx\n  mov    %rax,%r12\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    $0x2d,%bl\n  je     L2\n  movzbl 0x1(%rbp),%ebx\n  lea    0x1(%rbp),%rdx\n  test   %bl,%bl\n  je     L0\nL7:\n  mov    %rdx,%rbp\nL1:\n  movsbq %bl,%rax\n  testb  $0x8,0x1(%rcx,%rax,2)\n  je     L3\nL2:\n  mov    $0xa,%edx\n  mov    %r13,%rsi\n  mov    %rbp,%rdi\n  call   <strtol@plt>\n  mov    0x10(%rsp),%rdx\n  cmp    %rbp,%rdx\n  je     L4\n  movzbl (%rdx),%ecx\n  cmp    $0x2c,%cl\n  je     L5\n  test   %cl,%cl\n  jne    L6\nL5:\n  movslq %r15d,%rcx\n  add    $0x1,%r15d\n  mov    %eax,(%r14,%rcx,4)\n  movzbl (%rdx),%ebx\nL10:\n  test   %bl,%bl\n  je     L0\n  mov    (%r12),%rcx\n  jmp    L7\n  nopl   (%rax)\nL4:\n  movzbl 0x0(%rbp),%ebx\n  cmp    $0x2c,%bl\n  je     L8\n  test   %bl,%bl\n  je     L8\nL6:\n  lea    0x1(%rdx),%rax\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL11:\n  cmp    $0x2c,%bl\n  je     L10\nL9:\n  mov    %rax,0x10(%rsp)\n  movzbl (%rax),%ebx\n  mov    %rax,%rdx\n  add    $0x1,%rax\n  test   %bl,%bl\n  jne    L11\nL0:\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L12\n  add    $0x28,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  mov    %rbp,%rdx\n  jmp    L10\nL12:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 16480,
                "bias": [
                    12014,
                    11949
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4688
            },
            "L1": {
                "label": "L1",
                "addr": 4564
            },
            "L2": {
                "label": "L2",
                "addr": 4575
            },
            "L3": {
                "label": "L3",
                "addr": 4544
            },
            "L4": {
                "label": "L4",
                "addr": 4640
            },
            "L5": {
                "label": "L5",
                "addr": 4613
            },
            "L6": {
                "label": "L6",
                "addr": 4653
            },
            "L7": {
                "label": "L7",
                "addr": 4561
            },
            "L8": {
                "label": "L8",
                "addr": 4730
            },
            "L9": {
                "label": "L9",
                "addr": 4669
            },
            "L10": {
                "label": "L10",
                "addr": 4627
            },
            "L11": {
                "label": "L11",
                "addr": 4664
            },
            "L12": {
                "label": "L12",
                "addr": 4735
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 23,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1112 <func0+0x19>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    110e <func0+0x15>\n  mov    -0x4(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L1\n  mov    -0x4(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4370
            },
            "L1": {
                "label": "L1",
                "addr": 4366
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 23,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     1117 <func0+0x1e>\n  mov    $0x1,%eax\n  mov    %eax,%edx\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    1107 <func0+0xe>\n  mov    %edx,%eax\n  ret\n  mov    $0x0,%edx\n  jmp    1114 <func0+0x1b>",
        "asm_labeled": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    $0x1,%eax\nL1:\n  mov    %eax,%edx\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    L1\nL2:\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x0,%edx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4375
            },
            "L1": {
                "label": "L1",
                "addr": 4359
            },
            "L2": {
                "label": "L2",
                "addr": 4372
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 23,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     1128 <func0+0x28>\n  mov    $0x1,%eax\n  xchg   %ax,%ax\n  mov    %eax,%r8d\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    1110 <func0+0x10>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    $0x1,%eax\n  xchg   %ax,%ax\nL1:\n  mov    %eax,%r8d\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4392
            },
            "L1": {
                "label": "L1",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 23,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(const char *str) {\n    int length = 0;\n    while (str[length] != '\\0') {\n        length++;\n    }\n    return length;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"x\") == 1);\n    assert(func0(\"asdasnakj\") == 9);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     1128 <func0+0x28>\n  mov    $0x1,%eax\n  xchg   %ax,%ax\n  mov    %eax,%r8d\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    1110 <func0+0x10>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    $0x1,%eax\n  xchg   %ax,%ax\nL1:\n  mov    %eax,%r8d\n  add    $0x1,%rax\n  cmpb   $0x0,-0x1(%rdi,%rax,1)\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4392
            },
            "L1": {
                "label": "L1",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 24,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    1127 <func0+0x2e>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1123 <func0+0x2a>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  jmp    1137 <func0+0x3e>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    110d <func0+0x14>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  jmp    L2\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L3\n  mov    $0x1,%eax\nL2:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4391
            },
            "L1": {
                "label": "L1",
                "addr": 4387
            },
            "L2": {
                "label": "L2",
                "addr": 4407
            },
            "L3": {
                "label": "L3",
                "addr": 4365
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 24,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    1135 <func0+0x3c>\n  test   $0x1,%dil\n  je     1128 <func0+0x2f>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     112f <func0+0x36>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    110d <func0+0x14>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret\n  mov    $0x2,%ecx\n  jmp    1122 <func0+0x29>\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    L0\n  test   $0x1,%dil\n  je     L1\n  mov    $0x2,%ecx\nL3:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     L2\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L3\nL4:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret\nL1:\n  mov    $0x2,%ecx\n  jmp    L4\nL2:\n  mov    $0x1,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4405
            },
            "L1": {
                "label": "L1",
                "addr": 4392
            },
            "L2": {
                "label": "L2",
                "addr": 4399
            },
            "L3": {
                "label": "L3",
                "addr": 4365
            },
            "L4": {
                "label": "L4",
                "addr": 4386
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 24,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    1135 <func0+0x35>\n  mov    $0x2,%ecx\n  test   $0x1,%dil\n  jne    1129 <func0+0x29>\n  jmp    1140 <func0+0x40>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1140 <func0+0x40>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  test   $0x1,%dil\n  jne    L1\n  jmp    L2\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\nL1:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L3\nL0:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4405
            },
            "L1": {
                "label": "L1",
                "addr": 4393
            },
            "L2": {
                "label": "L2",
                "addr": 4416
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 24,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return n / i;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3) == 1);\n    assert(func0(7) == 1);\n    assert(func0(10) == 5);\n    assert(func0(100) == 50);\n    assert(func0(49) == 7);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    1135 <func0+0x35>\n  mov    $0x2,%ecx\n  test   $0x1,%dil\n  jne    1129 <func0+0x29>\n  jmp    1140 <func0+0x40>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1140 <func0+0x40>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x3,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  test   $0x1,%dil\n  jne    L1\n  jmp    L2\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\nL1:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L3\nL0:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4405
            },
            "L1": {
                "label": "L1",
                "addr": 4393
            },
            "L2": {
                "label": "L2",
                "addr": 4416
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 25,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    $0x100,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x20(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x2,-0xc(%rbp)\n  jmp    118d <func0+0x74>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %eax,-0x14(%rbp)\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x20(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  je     114d <func0+0x34>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    117c <func0+0x63>\n  cmpl   $0x1,-0x14(%rbp)\n  jle    11c3 <func0+0xaa>\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x20(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    $0x100,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x20(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x2,-0xc(%rbp)\n  jmp    L0\nL1:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %eax,-0x14(%rbp)\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x20(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  je     L1\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L2\n  cmpl   $0x1,-0x14(%rbp)\n  jle    L3\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x20(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\nL3:\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4493
            },
            "L1": {
                "label": "L1",
                "addr": 4429
            },
            "L2": {
                "label": "L2",
                "addr": 4476
            },
            "L3": {
                "label": "L3",
                "addr": 4547
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 25,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %edi,%ebx\n  mov    %rsi,%rbp\n  mov    $0x100,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,%r10\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  cmp    $0x3,%ebx\n  jg     119e <func0+0x85>\n  cmp    $0x1,%ebx\n  jle    115a <func0+0x41>\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  cltq\n  mov    %ebx,(%r10,%rax,4)\n  mov    %r10,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  cltq\n  lea    (%r10,%rax,4),%rsi\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%ebx\n  mov    %edi,%r9d\n  mov    %ecx,(%rsi)\n  add    $0x1,%rdi\n  add    $0x4,%rsi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1173 <func0+0x5a>\n  mov    %r9d,0x0(%rbp)\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     1146 <func0+0x2d>\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1164 <func0+0x4b>\n  jmp    1192 <func0+0x79>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %edi,%ebx\n  mov    %rsi,%rbp\n  mov    $0x100,%edi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  cmp    $0x3,%ebx\n  jg     L0\nL3:\n  cmp    $0x1,%ebx\n  jle    L1\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  cltq\n  mov    %ebx,(%r10,%rax,4)\nL1:\n  mov    %r10,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL4:\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  cltq\n  lea    (%r10,%rax,4),%rsi\nL2:\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%ebx\n  mov    %edi,%r9d\n  mov    %ecx,(%rsi)\n  add    $0x1,%rdi\n  add    $0x4,%rsi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\n  mov    %r9d,0x0(%rbp)\nL5:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     L3\nL0:\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L4\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4510
            },
            "L1": {
                "label": "L1",
                "addr": 4442
            },
            "L2": {
                "label": "L2",
                "addr": 4467
            },
            "L3": {
                "label": "L3",
                "addr": 4422
            },
            "L4": {
                "label": "L4",
                "addr": 4452
            },
            "L5": {
                "label": "L5",
                "addr": 4498
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 25,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x100,%edi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  mov    %rax,%r8\n  cmp    $0x3,%ebx\n  jle    1190 <func0+0x70>\n  nopl   (%rax)\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    1184 <func0+0x64>\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%esi\n  movslq %esi,%rsi\n  nopw   0x0(%rax,%rax,1)\n  mov    %ebx,%eax\n  mov    %ecx,-0x4(%r8,%rsi,4)\n  mov    %esi,%edi\n  add    $0x1,%rsi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%ebx\n  idiv   %ecx\n  test   %edx,%edx\n  je     1168 <func0+0x48>\n  mov    %edi,0x0(%rbp)\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jle    1150 <func0+0x30>\n  cmp    $0x1,%ebx\n  jle    11a3 <func0+0x83>\n  movslq 0x0(%rbp),%rax\n  lea    0x1(%rax),%edx\n  mov    %ebx,(%r8,%rax,4)\n  mov    %edx,0x0(%rbp)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x100,%edi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  mov    %rax,%r8\n  cmp    $0x3,%ebx\n  jle    L0\n  nopl   (%rax)\nL3:\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L1\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%esi\n  movslq %esi,%rsi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    %ebx,%eax\n  mov    %ecx,-0x4(%r8,%rsi,4)\n  mov    %esi,%edi\n  add    $0x1,%rsi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%ebx\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\n  mov    %edi,0x0(%rbp)\nL1:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jle    L3\nL0:\n  cmp    $0x1,%ebx\n  jle    L4\n  movslq 0x0(%rbp),%rax\n  lea    0x1(%rax),%edx\n  mov    %ebx,(%r8,%rax,4)\n  mov    %edx,0x0(%rbp)\nL4:\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4496
            },
            "L1": {
                "label": "L1",
                "addr": 4484
            },
            "L2": {
                "label": "L2",
                "addr": 4456
            },
            "L3": {
                "label": "L3",
                "addr": 4432
            },
            "L4": {
                "label": "L4",
                "addr": 4515
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 25,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n, int* size) {\n    int* out = malloc(sizeof(int) * 64);\n    *size = 0;\n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            n = n / i;\n            out[(*size)++] = i;\n        }\n    }\n    if (n > 1) {\n        out[(*size)++] = n;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int* result;\n\n    result = func0(2, &size);\n    assert(issame(result, size, (const int[]){2}, 1));\n    free(result);\n\n    result = func0(4, &size);\n    assert(issame(result, size, (const int[]){2, 2}, 2));\n    free(result);\n\n    result = func0(8, &size);\n    assert(issame(result, size, (const int[]){2, 2, 2}, 3));\n    free(result);\n\n    result = func0(3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19}, 2));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 19 * 3 * 19 * 3 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 3, 3, 19, 19, 19}, 6));\n    free(result);\n\n    result = func0(3 * 19 * 19 * 19, &size);\n    assert(issame(result, size, (const int[]){3, 19, 19, 19}, 4));\n    free(result);\n\n    result = func0(3 * 2 * 3, &size);\n    assert(issame(result, size, (const int[]){2, 3, 3}, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x100,%edi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  mov    %rax,%r8\n  cmp    $0x3,%ebx\n  jle    1190 <func0+0x70>\n  nopl   (%rax)\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    1184 <func0+0x64>\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%esi\n  movslq %esi,%rsi\n  nopw   0x0(%rax,%rax,1)\n  mov    %ebx,%eax\n  mov    %ecx,-0x4(%r8,%rsi,4)\n  mov    %esi,%edi\n  add    $0x1,%rsi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%ebx\n  idiv   %ecx\n  test   %edx,%edx\n  je     1168 <func0+0x48>\n  mov    %edi,0x0(%rbp)\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jle    1150 <func0+0x30>\n  cmp    $0x1,%ebx\n  jle    11a3 <func0+0x83>\n  movslq 0x0(%rbp),%rax\n  lea    0x1(%rax),%edx\n  mov    %ebx,(%r8,%rax,4)\n  mov    %edx,0x0(%rbp)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x100,%edi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  mov    $0x2,%ecx\n  mov    %rax,%r8\n  cmp    $0x3,%ebx\n  jle    L0\n  nopl   (%rax)\nL3:\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L1\n  mov    0x0(%rbp),%eax\n  lea    0x1(%rax),%esi\n  movslq %esi,%rsi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    %ebx,%eax\n  mov    %ecx,-0x4(%r8,%rsi,4)\n  mov    %esi,%edi\n  add    $0x1,%rsi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%ebx\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\n  mov    %edi,0x0(%rbp)\nL1:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jle    L3\nL0:\n  cmp    $0x1,%ebx\n  jle    L4\n  movslq 0x0(%rbp),%rax\n  lea    0x1(%rax),%edx\n  mov    %ebx,(%r8,%rax,4)\n  mov    %edx,0x0(%rbp)\nL4:\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4496
            },
            "L1": {
                "label": "L1",
                "addr": 4484
            },
            "L2": {
                "label": "L2",
                "addr": 4456
            },
            "L3": {
                "label": "L3",
                "addr": 4432
            },
            "L4": {
                "label": "L4",
                "addr": 4515
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 26,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x70,%rsp\n  mov    %rdi,-0x58(%rbp)\n  mov    %esi,-0x5c(%rbp)\n  mov    %rdx,-0x68(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   1080 <calloc@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   1080 <calloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x4c(%rbp)\n  movl   $0x0,-0x48(%rbp)\n  movl   $0x0,-0x44(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  jmp    12c2 <func0+0x169>\n  mov    -0x40(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x1c(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  jmp    1223 <func0+0xca>\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x1c(%rbp)\n  jne    121f <func0+0xc6>\n  movl   $0x1,-0x3c(%rbp)\n  jmp    122b <func0+0xd2>\n  addl   $0x1,-0x38(%rbp)\n  mov    -0x38(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     11fb <func0+0xa2>\n  cmpl   $0x0,-0x3c(%rbp)\n  jne    12bd <func0+0x164>\n  movl   $0x0,-0x34(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    126d <func0+0x114>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x1c(%rbp)\n  jne    1269 <func0+0x110>\n  movl   $0x1,-0x34(%rbp)\n  jmp    1275 <func0+0x11c>\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     1245 <func0+0xec>\n  cmpl   $0x0,-0x34(%rbp)\n  je     129c <func0+0x143>\n  mov    -0x48(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x48(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    12be <func0+0x165>\n  mov    -0x4c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x4c(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    12be <func0+0x165>\n  nop\n  addl   $0x1,-0x40(%rbp)\n  mov    -0x40(%rbp),%eax\n  cmp    -0x5c(%rbp),%eax\n  jl     11d2 <func0+0x79>\n  movl   $0x0,-0x2c(%rbp)\n  jmp    135c <func0+0x203>\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x20(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    132b <func0+0x1d2>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x20(%rbp)\n  jne    1327 <func0+0x1ce>\n  movl   $0x1,-0x28(%rbp)\n  jmp    1333 <func0+0x1da>\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     1303 <func0+0x1aa>\n  cmpl   $0x0,-0x28(%rbp)\n  jne    1358 <func0+0x1ff>\n  mov    -0x44(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x44(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x20(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x5c(%rbp),%eax\n  jl     12da <func0+0x181>\n  mov    -0x68(%rbp),%rax\n  mov    -0x44(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x18(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x70,%rsp\n  mov    %rdi,-0x58(%rbp)\n  mov    %esi,-0x5c(%rbp)\n  mov    %rdx,-0x68(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   <calloc@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   <calloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x4c(%rbp)\n  movl   $0x0,-0x48(%rbp)\n  movl   $0x0,-0x44(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  jmp    L0\nL12:\n  mov    -0x40(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x1c(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  jmp    L1\nL4:\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x1c(%rbp)\n  jne    L2\n  movl   $0x1,-0x3c(%rbp)\n  jmp    L3\nL2:\n  addl   $0x1,-0x38(%rbp)\nL1:\n  mov    -0x38(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     L4\nL3:\n  cmpl   $0x0,-0x3c(%rbp)\n  jne    L5\n  movl   $0x0,-0x34(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    L6\nL9:\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x1c(%rbp)\n  jne    L7\n  movl   $0x1,-0x34(%rbp)\n  jmp    L8\nL7:\n  addl   $0x1,-0x30(%rbp)\nL6:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     L9\nL8:\n  cmpl   $0x0,-0x34(%rbp)\n  je     L10\n  mov    -0x48(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x48(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    L11\nL10:\n  mov    -0x4c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x4c(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    L11\nL5:\n  nop\nL11:\n  addl   $0x1,-0x40(%rbp)\nL0:\n  mov    -0x40(%rbp),%eax\n  cmp    -0x5c(%rbp),%eax\n  jl     L12\n  movl   $0x0,-0x2c(%rbp)\n  jmp    L13\nL19:\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x20(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L14\nL17:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x20(%rbp)\n  jne    L15\n  movl   $0x1,-0x28(%rbp)\n  jmp    L16\nL15:\n  addl   $0x1,-0x24(%rbp)\nL14:\n  mov    -0x24(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     L17\nL16:\n  cmpl   $0x0,-0x28(%rbp)\n  jne    L18\n  mov    -0x44(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x44(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x20(%rbp),%eax\n  mov    %eax,(%rdx)\nL18:\n  addl   $0x1,-0x2c(%rbp)\nL13:\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x5c(%rbp),%eax\n  jl     L19\n  mov    -0x68(%rbp),%rax\n  mov    -0x44(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x18(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4802
            },
            "L1": {
                "label": "L1",
                "addr": 4643
            },
            "L2": {
                "label": "L2",
                "addr": 4639
            },
            "L3": {
                "label": "L3",
                "addr": 4651
            },
            "L4": {
                "label": "L4",
                "addr": 4603
            },
            "L5": {
                "label": "L5",
                "addr": 4797
            },
            "L6": {
                "label": "L6",
                "addr": 4717
            },
            "L7": {
                "label": "L7",
                "addr": 4713
            },
            "L8": {
                "label": "L8",
                "addr": 4725
            },
            "L9": {
                "label": "L9",
                "addr": 4677
            },
            "L10": {
                "label": "L10",
                "addr": 4764
            },
            "L11": {
                "label": "L11",
                "addr": 4798
            },
            "L12": {
                "label": "L12",
                "addr": 4562
            },
            "L13": {
                "label": "L13",
                "addr": 4956
            },
            "L14": {
                "label": "L14",
                "addr": 4907
            },
            "L15": {
                "label": "L15",
                "addr": 4903
            },
            "L16": {
                "label": "L16",
                "addr": 4915
            },
            "L17": {
                "label": "L17",
                "addr": 4867
            },
            "L18": {
                "label": "L18",
                "addr": 4952
            },
            "L19": {
                "label": "L19",
                "addr": 4826
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 26,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %esi,%r15d\n  mov    %rdx,%r13\n  movslq %esi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r12\n  mov    $0x4,%esi\n  mov    %rbx,%rdi\n  call   1080 <calloc@plt>\n  mov    %rax,%rbp\n  mov    $0x4,%esi\n  mov    %rbx,%rdi\n  call   1080 <calloc@plt>\n  mov    %rax,%rbx\n  test   %r15d,%r15d\n  jle    11df <func0+0x86>\n  mov    %r14,%rsi\n  lea    -0x1(%r15),%eax\n  lea    0x4(%r14,%rax,4),%rdi\n  mov    $0x0,%r8d\n  mov    $0x0,%r9d\n  lea    0x4(%rbp),%r11\n  lea    0x4(%rbx),%r10\n  jmp    124b <func0+0xf2>\n  lea    -0x1(%r8),%eax\n  lea    0x4(%rbx,%rax,4),%rcx\n  mov    $0x0,%r9d\n  jmp    121f <func0+0xc6>\n  mov    $0x0,%r9d\n  mov    %r9d,0x0(%r13)\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  mov    %rbx,%rdi\n  call   1070 <free@plt>\n  mov    %r12,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  movslq %r9d,%rax\n  mov    %edx,(%r12,%rax,4)\n  lea    0x1(%r9),%r9d\n  add    $0x4,%rsi\n  cmp    %rdi,%rsi\n  je     11e5 <func0+0x8c>\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  jle    120b <func0+0xb2>\n  mov    %rbx,%rax\n  cmp    %edx,(%rax)\n  je     1216 <func0+0xbd>\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  jne    1229 <func0+0xd0>\n  jmp    120b <func0+0xb2>\n  movslq %r8d,%rax\n  mov    %edx,(%rbx,%rax,4)\n  lea    0x1(%r8),%r8d\n  add    $0x4,%r14\n  cmp    %rdi,%r14\n  je     11ce <func0+0x75>\n  mov    (%r14),%edx\n  test   %r8d,%r8d\n  jle    126b <func0+0x112>\n  mov    %rbx,%rax\n  lea    -0x1(%r8),%ecx\n  lea    (%r10,%rcx,4),%rcx\n  cmp    %edx,(%rax)\n  je     1242 <func0+0xe9>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    125e <func0+0x105>\n  test   %r9d,%r9d\n  jle    1288 <func0+0x12f>\n  mov    %rbp,%rax\n  lea    -0x1(%r9),%ecx\n  lea    (%r11,%rcx,4),%rcx\n  cmp    %edx,(%rax)\n  je     1238 <func0+0xdf>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    127b <func0+0x122>\n  movslq %r9d,%rax\n  mov    %edx,0x0(%rbp,%rax,4)\n  lea    0x1(%r9),%r9d\n  jmp    1242 <func0+0xe9>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %esi,%r15d\n  mov    %rdx,%r13\n  movslq %esi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r12\n  mov    $0x4,%esi\n  mov    %rbx,%rdi\n  call   <calloc@plt>\n  mov    %rax,%rbp\n  mov    $0x4,%esi\n  mov    %rbx,%rdi\n  call   <calloc@plt>\n  mov    %rax,%rbx\n  test   %r15d,%r15d\n  jle    L0\n  mov    %r14,%rsi\n  lea    -0x1(%r15),%eax\n  lea    0x4(%r14,%rax,4),%rdi\n  mov    $0x0,%r8d\n  mov    $0x0,%r9d\n  lea    0x4(%rbp),%r11\n  lea    0x4(%rbx),%r10\n  jmp    L1\nL7:\n  lea    -0x1(%r8),%eax\n  lea    0x4(%rbx,%rax,4),%rcx\n  mov    $0x0,%r9d\n  jmp    L2\nL0:\n  mov    $0x0,%r9d\nL3:\n  mov    %r9d,0x0(%r13)\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %r12,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL4:\n  movslq %r9d,%rax\n  mov    %edx,(%r12,%rax,4)\n  lea    0x1(%r9),%r9d\nL5:\n  add    $0x4,%rsi\n  cmp    %rdi,%rsi\n  je     L3\nL2:\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  jle    L4\n  mov    %rbx,%rax\nL6:\n  cmp    %edx,(%rax)\n  je     L5\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  jne    L6\n  jmp    L4\nL12:\n  movslq %r8d,%rax\n  mov    %edx,(%rbx,%rax,4)\n  lea    0x1(%r8),%r8d\nL9:\n  add    $0x4,%r14\n  cmp    %rdi,%r14\n  je     L7\nL1:\n  mov    (%r14),%edx\n  test   %r8d,%r8d\n  jle    L8\n  mov    %rbx,%rax\n  lea    -0x1(%r8),%ecx\n  lea    (%r10,%rcx,4),%rcx\nL10:\n  cmp    %edx,(%rax)\n  je     L9\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L10\nL8:\n  test   %r9d,%r9d\n  jle    L11\n  mov    %rbp,%rax\n  lea    -0x1(%r9),%ecx\n  lea    (%r11,%rcx,4),%rcx\nL13:\n  cmp    %edx,(%rax)\n  je     L12\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L13\nL11:\n  movslq %r9d,%rax\n  mov    %edx,0x0(%rbp,%rax,4)\n  lea    0x1(%r9),%r9d\n  jmp    L9",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4575
            },
            "L1": {
                "label": "L1",
                "addr": 4683
            },
            "L2": {
                "label": "L2",
                "addr": 4639
            },
            "L3": {
                "label": "L3",
                "addr": 4581
            },
            "L4": {
                "label": "L4",
                "addr": 4619
            },
            "L5": {
                "label": "L5",
                "addr": 4630
            },
            "L6": {
                "label": "L6",
                "addr": 4649
            },
            "L7": {
                "label": "L7",
                "addr": 4558
            },
            "L8": {
                "label": "L8",
                "addr": 4715
            },
            "L9": {
                "label": "L9",
                "addr": 4674
            },
            "L10": {
                "label": "L10",
                "addr": 4702
            },
            "L11": {
                "label": "L11",
                "addr": 4744
            },
            "L12": {
                "label": "L12",
                "addr": 4664
            },
            "L13": {
                "label": "L13",
                "addr": 4731
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 26,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  lea    0x0(,%r13,4),%rdi\n  mov    %r13,%r14\n  push   %rbp\n  push   %rbx\n  mov    %rdx,%rbx\n  sub    $0x8,%rsp\n  call   1090 <malloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%r12\n  call   1080 <calloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%rbp\n  call   1080 <calloc@plt>\n  mov    %rax,%r13\n  test   %r14d,%r14d\n  jle    12e5 <func0+0x185>\n  lea    -0x1(%r14),%eax\n  mov    %r15,%rsi\n  mov    %r15,%rdi\n  xor    %r8d,%r8d\n  lea    0x4(%r15,%rax,4),%r9\n  xor    %r10d,%r10d\n  lea    0x4(%r13),%r11\n  lea    0x4(%rbp),%r14\n  nopl   0x0(%rax)\n  mov    (%rdi),%edx\n  test   %r8d,%r8d\n  je     1260 <func0+0x100>\n  lea    -0x1(%r8),%ecx\n  mov    %r13,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    11f9 <func0+0x99>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     1260 <func0+0x100>\n  cmp    %edx,(%rax)\n  jne    11f0 <func0+0x90>\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  lea    -0x1(%r8),%eax\n  xor    %edi,%edi\n  lea    (%r11,%rax,4),%rcx\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  je     12a8 <func0+0x148>\n  mov    %r13,%rax\n  jmp    1229 <func0+0xc9>\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  je     12a8 <func0+0x148>\n  cmp    %edx,(%rax)\n  jne    1220 <func0+0xc0>\n  add    $0x4,%rsi\n  cmp    %r9,%rsi\n  jne    1210 <func0+0xb0>\n  mov    %edi,(%rbx)\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  mov    %r13,%rdi\n  call   1070 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  test   %r10d,%r10d\n  je     12c8 <func0+0x168>\n  lea    -0x1(%r10),%ecx\n  mov    %rbp,%rax\n  lea    (%r14,%rcx,4),%rcx\n  jmp    1281 <func0+0x121>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     12c8 <func0+0x168>\n  cmp    %edx,(%rax)\n  jne    1278 <func0+0x118>\n  movslq %r8d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r8d\n  mov    %edx,0x0(%r13,%rax,4)\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  jmp    1206 <func0+0xa6>\n  nopl   0x0(%rax,%rax,1)\n  movslq %edi,%rax\n  add    $0x4,%rsi\n  add    $0x1,%edi\n  mov    %edx,(%r12,%rax,4)\n  cmp    %r9,%rsi\n  jne    1210 <func0+0xb0>\n  jmp    1236 <func0+0xd6>\n  nopl   0x0(%rax)\n  movslq %r10d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r10d\n  mov    %edx,0x0(%rbp,%rax,4)\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  jmp    1206 <func0+0xa6>\n  xor    %edi,%edi\n  jmp    1236 <func0+0xd6>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  lea    0x0(,%r13,4),%rdi\n  mov    %r13,%r14\n  push   %rbp\n  push   %rbx\n  mov    %rdx,%rbx\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%r12\n  call   <calloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%rbp\n  call   <calloc@plt>\n  mov    %rax,%r13\n  test   %r14d,%r14d\n  jle    L0\n  lea    -0x1(%r14),%eax\n  mov    %r15,%rsi\n  mov    %r15,%rdi\n  xor    %r8d,%r8d\n  lea    0x4(%r15,%rax,4),%r9\n  xor    %r10d,%r10d\n  lea    0x4(%r13),%r11\n  lea    0x4(%rbp),%r14\n  nopl   0x0(%rax)\nL4:\n  mov    (%rdi),%edx\n  test   %r8d,%r8d\n  je     L1\n  lea    -0x1(%r8),%ecx\n  mov    %r13,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    L2\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    L4\nL12:\n  lea    -0x1(%r8),%eax\n  xor    %edi,%edi\n  lea    (%r11,%rax,4),%rcx\nL8:\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  je     L5\n  mov    %r13,%rax\n  jmp    L6\nL7:\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  je     L5\nL6:\n  cmp    %edx,(%rax)\n  jne    L7\n  add    $0x4,%rsi\n  cmp    %r9,%rsi\n  jne    L8\nL13:\n  mov    %edi,(%rbx)\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  test   %r10d,%r10d\n  je     L9\n  lea    -0x1(%r10),%ecx\n  mov    %rbp,%rax\n  lea    (%r14,%rcx,4),%rcx\n  jmp    L10\n  nopw   0x0(%rax,%rax,1)\nL11:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L9\nL10:\n  cmp    %edx,(%rax)\n  jne    L11\n  movslq %r8d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r8d\n  mov    %edx,0x0(%r13,%rax,4)\n  cmp    %r9,%rdi\n  jne    L4\n  jmp    L12\n  nopl   0x0(%rax,%rax,1)\nL5:\n  movslq %edi,%rax\n  add    $0x4,%rsi\n  add    $0x1,%edi\n  mov    %edx,(%r12,%rax,4)\n  cmp    %r9,%rsi\n  jne    L8\n  jmp    L13\n  nopl   0x0(%rax)\nL9:\n  movslq %r10d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r10d\n  mov    %edx,0x0(%rbp,%rax,4)\n  cmp    %r9,%rdi\n  jne    L4\n  jmp    L12\nL0:\n  xor    %edi,%edi\n  jmp    L13",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4837
            },
            "L1": {
                "label": "L1",
                "addr": 4704
            },
            "L2": {
                "label": "L2",
                "addr": 4601
            },
            "L3": {
                "label": "L3",
                "addr": 4592
            },
            "L4": {
                "label": "L4",
                "addr": 4568
            },
            "L5": {
                "label": "L5",
                "addr": 4776
            },
            "L6": {
                "label": "L6",
                "addr": 4649
            },
            "L7": {
                "label": "L7",
                "addr": 4640
            },
            "L8": {
                "label": "L8",
                "addr": 4624
            },
            "L9": {
                "label": "L9",
                "addr": 4808
            },
            "L10": {
                "label": "L10",
                "addr": 4737
            },
            "L11": {
                "label": "L11",
                "addr": 4728
            },
            "L12": {
                "label": "L12",
                "addr": 4614
            },
            "L13": {
                "label": "L13",
                "addr": 4662
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 26,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int* numbers, int size, int* new_size) {\n    int* out = (int*)malloc(size * sizeof(int));\n    int* has1 = (int*)calloc(size, sizeof(int));\n    int* has2 = (int*)calloc(size, sizeof(int));\n    int has1_count = 0;\n    int has2_count = 0;\n    int out_count = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (in_has2) continue;\n\n        int in_has1 = 0;\n        for (int j = 0; j < has1_count; j++) {\n            if (has1[j] == num) {\n                in_has1 = 1;\n                break;\n            }\n        }\n        if (in_has1) {\n            has2[has2_count++] = num;\n        } else {\n            has1[has1_count++] = num;\n        }\n    }\n\n    for (int i = 0; i < size; i++) {\n        int num = numbers[i];\n        int in_has2 = 0;\n        for (int j = 0; j < has2_count; j++) {\n            if (has2[j] == num) {\n                in_has2 = 1;\n                break;\n            }\n        }\n        if (!in_has2) {\n            out[out_count++] = num;\n        }\n    }\n\n    *new_size = out_count;\n    free(has1);\n    free(has2);\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int new_size;\n    int* result;\n\n    result = func0((const int[]){}, 0, &new_size);\n    assert(issame(result, new_size, (const int[]){}, 0));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 4}, 4, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 2, 3, 4}, 4));\n    free(result);\n\n    result = func0((const int[]){1, 2, 3, 2, 4, 3, 5}, 7, &new_size);\n    assert(issame(result, new_size, (const int[]){1, 4, 5}, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  lea    0x0(,%r13,4),%rdi\n  mov    %r13,%r14\n  push   %rbp\n  push   %rbx\n  mov    %rdx,%rbx\n  sub    $0x8,%rsp\n  call   1090 <malloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%r12\n  call   1080 <calloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%rbp\n  call   1080 <calloc@plt>\n  mov    %rax,%r13\n  test   %r14d,%r14d\n  jle    12e5 <func0+0x185>\n  lea    -0x1(%r14),%eax\n  mov    %r15,%rsi\n  mov    %r15,%rdi\n  xor    %r8d,%r8d\n  lea    0x4(%r15,%rax,4),%r9\n  xor    %r10d,%r10d\n  lea    0x4(%r13),%r11\n  lea    0x4(%rbp),%r14\n  nopl   0x0(%rax)\n  mov    (%rdi),%edx\n  test   %r8d,%r8d\n  je     1260 <func0+0x100>\n  lea    -0x1(%r8),%ecx\n  mov    %r13,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    11f9 <func0+0x99>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     1260 <func0+0x100>\n  cmp    %edx,(%rax)\n  jne    11f0 <func0+0x90>\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  lea    -0x1(%r8),%eax\n  xor    %edi,%edi\n  lea    (%r11,%rax,4),%rcx\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  je     12a8 <func0+0x148>\n  mov    %r13,%rax\n  jmp    1229 <func0+0xc9>\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  je     12a8 <func0+0x148>\n  cmp    %edx,(%rax)\n  jne    1220 <func0+0xc0>\n  add    $0x4,%rsi\n  cmp    %r9,%rsi\n  jne    1210 <func0+0xb0>\n  mov    %edi,(%rbx)\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  mov    %r13,%rdi\n  call   1070 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  test   %r10d,%r10d\n  je     12c8 <func0+0x168>\n  lea    -0x1(%r10),%ecx\n  mov    %rbp,%rax\n  lea    (%r14,%rcx,4),%rcx\n  jmp    1281 <func0+0x121>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     12c8 <func0+0x168>\n  cmp    %edx,(%rax)\n  jne    1278 <func0+0x118>\n  movslq %r8d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r8d\n  mov    %edx,0x0(%r13,%rax,4)\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  jmp    1206 <func0+0xa6>\n  nopl   0x0(%rax,%rax,1)\n  movslq %edi,%rax\n  add    $0x4,%rsi\n  add    $0x1,%edi\n  mov    %edx,(%r12,%rax,4)\n  cmp    %r9,%rsi\n  jne    1210 <func0+0xb0>\n  jmp    1236 <func0+0xd6>\n  nopl   0x0(%rax)\n  movslq %r10d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r10d\n  mov    %edx,0x0(%rbp,%rax,4)\n  cmp    %r9,%rdi\n  jne    11d8 <func0+0x78>\n  jmp    1206 <func0+0xa6>\n  xor    %edi,%edi\n  jmp    1236 <func0+0xd6>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  lea    0x0(,%r13,4),%rdi\n  mov    %r13,%r14\n  push   %rbp\n  push   %rbx\n  mov    %rdx,%rbx\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%r12\n  call   <calloc@plt>\n  mov    %r13,%rdi\n  mov    $0x4,%esi\n  mov    %rax,%rbp\n  call   <calloc@plt>\n  mov    %rax,%r13\n  test   %r14d,%r14d\n  jle    L0\n  lea    -0x1(%r14),%eax\n  mov    %r15,%rsi\n  mov    %r15,%rdi\n  xor    %r8d,%r8d\n  lea    0x4(%r15,%rax,4),%r9\n  xor    %r10d,%r10d\n  lea    0x4(%r13),%r11\n  lea    0x4(%rbp),%r14\n  nopl   0x0(%rax)\nL4:\n  mov    (%rdi),%edx\n  test   %r8d,%r8d\n  je     L1\n  lea    -0x1(%r8),%ecx\n  mov    %r13,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    L2\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    L4\nL12:\n  lea    -0x1(%r8),%eax\n  xor    %edi,%edi\n  lea    (%r11,%rax,4),%rcx\nL8:\n  mov    (%rsi),%edx\n  test   %r8d,%r8d\n  je     L5\n  mov    %r13,%rax\n  jmp    L6\nL7:\n  add    $0x4,%rax\n  cmp    %rax,%rcx\n  je     L5\nL6:\n  cmp    %edx,(%rax)\n  jne    L7\n  add    $0x4,%rsi\n  cmp    %r9,%rsi\n  jne    L8\nL13:\n  mov    %edi,(%rbx)\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  test   %r10d,%r10d\n  je     L9\n  lea    -0x1(%r10),%ecx\n  mov    %rbp,%rax\n  lea    (%r14,%rcx,4),%rcx\n  jmp    L10\n  nopw   0x0(%rax,%rax,1)\nL11:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L9\nL10:\n  cmp    %edx,(%rax)\n  jne    L11\n  movslq %r8d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r8d\n  mov    %edx,0x0(%r13,%rax,4)\n  cmp    %r9,%rdi\n  jne    L4\n  jmp    L12\n  nopl   0x0(%rax,%rax,1)\nL5:\n  movslq %edi,%rax\n  add    $0x4,%rsi\n  add    $0x1,%edi\n  mov    %edx,(%r12,%rax,4)\n  cmp    %r9,%rsi\n  jne    L8\n  jmp    L13\n  nopl   0x0(%rax)\nL9:\n  movslq %r10d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r10d\n  mov    %edx,0x0(%rbp,%rax,4)\n  cmp    %r9,%rdi\n  jne    L4\n  jmp    L12\nL0:\n  xor    %edi,%edi\n  jmp    L13",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4837
            },
            "L1": {
                "label": "L1",
                "addr": 4704
            },
            "L2": {
                "label": "L2",
                "addr": 4601
            },
            "L3": {
                "label": "L3",
                "addr": 4592
            },
            "L4": {
                "label": "L4",
                "addr": 4568
            },
            "L5": {
                "label": "L5",
                "addr": 4776
            },
            "L6": {
                "label": "L6",
                "addr": 4649
            },
            "L7": {
                "label": "L7",
                "addr": 4640
            },
            "L8": {
                "label": "L8",
                "addr": 4624
            },
            "L9": {
                "label": "L9",
                "addr": 4808
            },
            "L10": {
                "label": "L10",
                "addr": 4737
            },
            "L11": {
                "label": "L11",
                "addr": 4728
            },
            "L12": {
                "label": "L12",
                "addr": 4614
            },
            "L13": {
                "label": "L13",
                "addr": 4662
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 27,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    119d <func0+0x84>\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x9(%rbp)\n  cmpb   $0x60,-0x9(%rbp)\n  jle    1170 <func0+0x57>\n  cmpb   $0x7a,-0x9(%rbp)\n  jg     1170 <func0+0x57>\n  movzbl -0x9(%rbp),%eax\n  sub    $0x20,%eax\n  mov    %al,-0x9(%rbp)\n  jmp    1186 <func0+0x6d>\n  cmpb   $0x40,-0x9(%rbp)\n  jle    1186 <func0+0x6d>\n  cmpb   $0x5a,-0x9(%rbp)\n  jg     1186 <func0+0x6d>\n  movzbl -0x9(%rbp),%eax\n  add    $0x20,%eax\n  mov    %al,-0x9(%rbp)\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x9(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     1145 <func0+0x2c>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL3:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x9(%rbp)\n  cmpb   $0x60,-0x9(%rbp)\n  jle    L1\n  cmpb   $0x7a,-0x9(%rbp)\n  jg     L1\n  movzbl -0x9(%rbp),%eax\n  sub    $0x20,%eax\n  mov    %al,-0x9(%rbp)\n  jmp    L2\nL1:\n  cmpb   $0x40,-0x9(%rbp)\n  jle    L2\n  cmpb   $0x5a,-0x9(%rbp)\n  jg     L2\n  movzbl -0x9(%rbp),%eax\n  add    $0x20,%eax\n  mov    %al,-0x9(%rbp)\nL2:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x9(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L3\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4509
            },
            "L1": {
                "label": "L1",
                "addr": 4464
            },
            "L2": {
                "label": "L2",
                "addr": 4486
            },
            "L3": {
                "label": "L3",
                "addr": 4421
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 27,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  call   1050 <strlen@plt>\n  test   %eax,%eax\n  jle    116e <func0+0x55>\n  lea    -0x1(%rax),%r8d\n  mov    $0x0,%ecx\n  jmp    1159 <func0+0x40>\n  lea    -0x41(%rdx),%edi\n  add    $0x20,%esi\n  cmp    $0x1a,%dil\n  cmovb  %esi,%edx\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %r8,%rcx\n  je     116e <func0+0x55>\n  mov    %rdx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%edx\n  mov    %edx,%esi\n  lea    -0x61(%rdx),%edi\n  cmp    $0x19,%dil\n  ja     113d <func0+0x24>\n  sub    $0x20,%edx\n  jmp    114a <func0+0x31>\n  cltq\n  movb   $0x0,(%rbx,%rax,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  call   <strlen@plt>\n  test   %eax,%eax\n  jle    L0\n  lea    -0x1(%rax),%r8d\n  mov    $0x0,%ecx\n  jmp    L1\nL2:\n  lea    -0x41(%rdx),%edi\n  add    $0x20,%esi\n  cmp    $0x1a,%dil\n  cmovb  %esi,%edx\nL3:\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %r8,%rcx\n  je     L0\n  mov    %rdx,%rcx\nL1:\n  movzbl 0x0(%rbp,%rcx,1),%edx\n  mov    %edx,%esi\n  lea    -0x61(%rdx),%edi\n  cmp    $0x19,%dil\n  ja     L2\n  sub    $0x20,%edx\n  jmp    L3\nL0:\n  cltq\n  movb   $0x0,(%rbx,%rax,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4462
            },
            "L1": {
                "label": "L1",
                "addr": 4441
            },
            "L2": {
                "label": "L2",
                "addr": 4413
            },
            "L3": {
                "label": "L3",
                "addr": 4426
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 27,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  test   %eax,%eax\n  jle    117b <func0+0x5b>\n  lea    -0x1(%rax),%esi\n  xor    %ecx,%ecx\n  jmp    1152 <func0+0x32>\n  sub    $0x20,%edx\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %rcx,%rsi\n  je     117b <func0+0x5b>\n  mov    %rdx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%edx\n  lea    -0x61(%rdx),%r8d\n  cmp    $0x19,%r8b\n  jbe    1140 <func0+0x20>\n  lea    -0x41(%rdx),%r8d\n  lea    0x20(%rdx),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%edx\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %rcx,%rsi\n  jne    114f <func0+0x2f>\n  cltq\n  movb   $0x0,(%rbx,%rax,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  test   %eax,%eax\n  jle    L0\n  lea    -0x1(%rax),%esi\n  xor    %ecx,%ecx\n  jmp    L1\nL2:\n  sub    $0x20,%edx\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %rcx,%rsi\n  je     L0\nL3:\n  mov    %rdx,%rcx\nL1:\n  movzbl 0x0(%rbp,%rcx,1),%edx\n  lea    -0x61(%rdx),%r8d\n  cmp    $0x19,%r8b\n  jbe    L2\n  lea    -0x41(%rdx),%r8d\n  lea    0x20(%rdx),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%edx\n  mov    %dl,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rdx\n  cmp    %rcx,%rsi\n  jne    L3\nL0:\n  cltq\n  movb   $0x0,(%rbx,%rax,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4475
            },
            "L1": {
                "label": "L1",
                "addr": 4434
            },
            "L2": {
                "label": "L2",
                "addr": 4416
            },
            "L3": {
                "label": "L3",
                "addr": 4431
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 27,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* str, char* out) {\n    int length = strlen(str);\n    for (int i = 0; i < length; i++) {\n        char w = str[i];\n        if (w >= 'a' && w <= 'z') {\n            w -= 32;\n        } else if (w >= 'A' && w <= 'Z') {\n            w += 32;\n        }\n        out[i] = w;\n    }\n    out[length] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100]; // Buffer large enough for test cases\n\n    func0(\"\", result);\n    assert(strcmp(result, \"\") == 0);\n\n    func0(\"Hello!\", result);\n    assert(strcmp(result, \"hELLO!\") == 0);\n\n    func0(\"These violent delights have violent ends\", result);\n    assert(strcmp(result, \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  mov    %rax,%rdx\n  test   %eax,%eax\n  jle    148b <func0+0x36b>\n  lea    0x1(%rbp),%rsi\n  mov    %rbx,%rcx\n  lea    -0x1(%rax),%eax\n  sub    %rsi,%rcx\n  cmp    $0xe,%rcx\n  jbe    14a0 <func0+0x380>\n  cmp    $0xe,%eax\n  jbe    14a0 <func0+0x380>\n  mov    %edx,%ecx\n  movdqa 0xeb6(%rip),%xmm5        # 2020 <_fini+0x9f0>\n  xor    %eax,%eax\n  pxor   %xmm4,%xmm4\n  shr    $0x4,%ecx\n  movdqa 0xeb5(%rip),%xmm7        # 2030 <_fini+0xa00>\n  movdqa 0xe7c(%rip),%xmm9        # 2000 <_fini+0x9d0>\n  movdqa 0xe83(%rip),%xmm8        # 2010 <_fini+0x9e0>\n  movdqa 0xeab(%rip),%xmm6        # 2040 <_fini+0xa10>\n  shl    $0x4,%rcx\n  nopl   0x0(%rax)\n  movdqu 0x0(%rbp,%rax,1),%xmm3\n  movdqa %xmm3,%xmm0\n  movdqa %xmm3,%xmm1\n  paddb  %xmm8,%xmm0\n  paddb  %xmm9,%xmm1\n  movdqa %xmm0,%xmm2\n  psubusb %xmm5,%xmm1\n  pminub %xmm5,%xmm2\n  pcmpeqb %xmm4,%xmm1\n  pcmpeqb %xmm0,%xmm2\n  psubusb %xmm5,%xmm0\n  pcmpeqb %xmm4,%xmm0\n  movdqa %xmm1,%xmm10\n  pcmpeqb %xmm4,%xmm10\n  pcmpeqb %xmm4,%xmm0\n  pand   %xmm10,%xmm2\n  pand   %xmm10,%xmm0\n  movdqa %xmm3,%xmm10\n  paddb  %xmm7,%xmm10\n  pand   %xmm1,%xmm10\n  pandn  %xmm3,%xmm1\n  por    %xmm10,%xmm1\n  movdqa %xmm3,%xmm10\n  paddb  %xmm6,%xmm3\n  pand   %xmm0,%xmm10\n  pandn  %xmm1,%xmm0\n  pand   %xmm2,%xmm3\n  por    %xmm10,%xmm0\n  pandn  %xmm0,%xmm2\n  por    %xmm3,%xmm2\n  movups %xmm2,(%rbx,%rax,1)\n  add    $0x10,%rax\n  cmp    %rcx,%rax\n  jne    11a0 <func0+0x80>\n  mov    %edx,%eax\n  and    $0xfffffff0,%eax\n  test   $0xf,%dl\n  je     148b <func0+0x36b>\n  movslq %eax,%rsi\n  movzbl 0x0(%rbp,%rsi,1),%ecx\n  lea    -0x61(%rcx),%edi\n  cmp    $0x19,%dil\n  jbe    14e0 <func0+0x3c0>\n  lea    -0x41(%rcx),%r8d\n  lea    0x20(%rcx),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%ecx\n  mov    %cl,(%rbx,%rsi,1)\n  lea    0x1(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     14f0 <func0+0x3d0>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x2(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1508 <func0+0x3e8>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x3(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1520 <func0+0x400>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1538 <func0+0x418>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x5(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1550 <func0+0x430>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x6(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1568 <func0+0x448>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x7(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  jbe    1580 <func0+0x460>\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x8(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1590 <func0+0x470>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x9(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     15a8 <func0+0x488>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xa(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     15c0 <func0+0x4a0>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xb(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     15d8 <func0+0x4b8>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xc(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     15f0 <func0+0x4d0>\n  sub    $0x20,%esi\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xd(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    148b <func0+0x36b>\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     1608 <func0+0x4e8>\n  sub    $0x20,%esi\n  add    $0xe,%eax\n  mov    %sil,(%rbx,%rcx,1)\n  cmp    %eax,%edx\n  jle    148b <func0+0x36b>\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%ecx\n  lea    -0x61(%rcx),%esi\n  cmp    $0x19,%sil\n  ja     161b <func0+0x4fb>\n  sub    $0x20,%ecx\n  mov    %cl,(%rbx,%rax,1)\n  movslq %edx,%rdx\n  movb   $0x0,(%rbx,%rdx,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   0x0(%rax)\n  mov    %eax,%esi\n  xor    %ecx,%ecx\n  jmp    14c2 <func0+0x3a2>\n  cs nopw 0x0(%rax,%rax,1)\n  sub    $0x20,%eax\n  mov    %al,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rax\n  cmp    %rsi,%rcx\n  je     148b <func0+0x36b>\n  mov    %rax,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%eax\n  lea    -0x61(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    14b0 <func0+0x390>\n  lea    -0x41(%rax),%r8d\n  lea    0x20(%rax),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%eax\n  jmp    14b3 <func0+0x393>\n  sub    $0x20,%ecx\n  jmp    1269 <func0+0x149>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    128f <func0+0x16f>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    12b6 <func0+0x196>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    12dd <func0+0x1bd>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    1304 <func0+0x1e4>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    132b <func0+0x20b>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    1352 <func0+0x232>\n  nopl   0x0(%rax,%rax,1)\n  sub    $0x20,%esi\n  jmp    1384 <func0+0x264>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    13ab <func0+0x28b>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    13d2 <func0+0x2b2>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    13f9 <func0+0x2d9>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    1420 <func0+0x300>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    1443 <func0+0x323>\n  nopl   0x0(%rax,%rax,1)\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    1466 <func0+0x346>\n  lea    -0x41(%rcx),%edi\n  lea    0x20(%rcx),%esi\n  cmp    $0x1a,%dil\n  cmovb  %esi,%ecx\n  jmp    1488 <func0+0x368>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    %rax,%rdx\n  test   %eax,%eax\n  jle    L0\n  lea    0x1(%rbp),%rsi\n  mov    %rbx,%rcx\n  lea    -0x1(%rax),%eax\n  sub    %rsi,%rcx\n  cmp    $0xe,%rcx\n  jbe    L1\n  cmp    $0xe,%eax\n  jbe    L1\n  mov    %edx,%ecx\n  movdqa D0(%rip),%xmm5\n  xor    %eax,%eax\n  pxor   %xmm4,%xmm4\n  shr    $0x4,%ecx\n  movdqa D1(%rip),%xmm7\n  movdqa D2(%rip),%xmm9\n  movdqa D3(%rip),%xmm8\n  movdqa D4(%rip),%xmm6\n  shl    $0x4,%rcx\n  nopl   0x0(%rax)\nL2:\n  movdqu 0x0(%rbp,%rax,1),%xmm3\n  movdqa %xmm3,%xmm0\n  movdqa %xmm3,%xmm1\n  paddb  %xmm8,%xmm0\n  paddb  %xmm9,%xmm1\n  movdqa %xmm0,%xmm2\n  psubusb %xmm5,%xmm1\n  pminub %xmm5,%xmm2\n  pcmpeqb %xmm4,%xmm1\n  pcmpeqb %xmm0,%xmm2\n  psubusb %xmm5,%xmm0\n  pcmpeqb %xmm4,%xmm0\n  movdqa %xmm1,%xmm10\n  pcmpeqb %xmm4,%xmm10\n  pcmpeqb %xmm4,%xmm0\n  pand   %xmm10,%xmm2\n  pand   %xmm10,%xmm0\n  movdqa %xmm3,%xmm10\n  paddb  %xmm7,%xmm10\n  pand   %xmm1,%xmm10\n  pandn  %xmm3,%xmm1\n  por    %xmm10,%xmm1\n  movdqa %xmm3,%xmm10\n  paddb  %xmm6,%xmm3\n  pand   %xmm0,%xmm10\n  pandn  %xmm1,%xmm0\n  pand   %xmm2,%xmm3\n  por    %xmm10,%xmm0\n  pandn  %xmm0,%xmm2\n  por    %xmm3,%xmm2\n  movups %xmm2,(%rbx,%rax,1)\n  add    $0x10,%rax\n  cmp    %rcx,%rax\n  jne    L2\n  mov    %edx,%eax\n  and    $0xfffffff0,%eax\n  test   $0xf,%dl\n  je     L0\n  movslq %eax,%rsi\n  movzbl 0x0(%rbp,%rsi,1),%ecx\n  lea    -0x61(%rcx),%edi\n  cmp    $0x19,%dil\n  jbe    L3\n  lea    -0x41(%rcx),%r8d\n  lea    0x20(%rcx),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%ecx\nL21:\n  mov    %cl,(%rbx,%rsi,1)\n  lea    0x1(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L4\n  sub    $0x20,%esi\nL22:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x2(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L5\n  sub    $0x20,%esi\nL23:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x3(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L6\n  sub    $0x20,%esi\nL24:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L7\n  sub    $0x20,%esi\nL25:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x5(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L8\n  sub    $0x20,%esi\nL26:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x6(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L9\n  sub    $0x20,%esi\nL27:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x7(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  jbe    L10\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\nL28:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x8(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L11\n  sub    $0x20,%esi\nL29:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0x9(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L12\n  sub    $0x20,%esi\nL30:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xa(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L13\n  sub    $0x20,%esi\nL31:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xb(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L14\n  sub    $0x20,%esi\nL32:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xc(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L15\n  sub    $0x20,%esi\nL33:\n  mov    %sil,(%rbx,%rcx,1)\n  lea    0xd(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L0\n  movslq %ecx,%rcx\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  lea    -0x61(%rsi),%edi\n  cmp    $0x19,%dil\n  ja     L16\n  sub    $0x20,%esi\nL34:\n  add    $0xe,%eax\n  mov    %sil,(%rbx,%rcx,1)\n  cmp    %eax,%edx\n  jle    L0\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%ecx\n  lea    -0x61(%rcx),%esi\n  cmp    $0x19,%sil\n  ja     L17\n  sub    $0x20,%ecx\nL35:\n  mov    %cl,(%rbx,%rax,1)\nL0:\n  movslq %edx,%rdx\n  movb   $0x0,(%rbx,%rdx,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    %eax,%esi\n  xor    %ecx,%ecx\n  jmp    L18\n  cs nopw 0x0(%rax,%rax,1)\nL19:\n  sub    $0x20,%eax\nL20:\n  mov    %al,(%rbx,%rcx,1)\n  lea    0x1(%rcx),%rax\n  cmp    %rsi,%rcx\n  je     L0\n  mov    %rax,%rcx\nL18:\n  movzbl 0x0(%rbp,%rcx,1),%eax\n  lea    -0x61(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    L19\n  lea    -0x41(%rax),%r8d\n  lea    0x20(%rax),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%eax\n  jmp    L20\nL3:\n  sub    $0x20,%ecx\n  jmp    L21\n  nopl   0x0(%rax,%rax,1)\nL4:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L22\n  nopl   0x0(%rax,%rax,1)\nL5:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L23\n  nopl   0x0(%rax,%rax,1)\nL6:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L24\n  nopl   0x0(%rax,%rax,1)\nL7:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L25\n  nopl   0x0(%rax,%rax,1)\nL8:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L26\n  nopl   0x0(%rax,%rax,1)\nL9:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L27\n  nopl   0x0(%rax,%rax,1)\nL10:\n  sub    $0x20,%esi\n  jmp    L28\n  nopl   0x0(%rax,%rax,1)\nL11:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L29\n  nopl   0x0(%rax,%rax,1)\nL12:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L30\n  nopl   0x0(%rax,%rax,1)\nL13:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L31\n  nopl   0x0(%rax,%rax,1)\nL14:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L32\n  nopl   0x0(%rax,%rax,1)\nL15:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L33\n  nopl   0x0(%rax,%rax,1)\nL16:\n  lea    -0x41(%rsi),%r8d\n  lea    0x20(%rsi),%edi\n  cmp    $0x1a,%r8b\n  cmovb  %edi,%esi\n  jmp    L34\nL17:\n  lea    -0x41(%rcx),%edi\n  lea    0x20(%rcx),%esi\n  cmp    $0x1a,%dil\n  cmovb  %esi,%ecx\n  jmp    L35",
        "num_missing": 5,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8224,
                "bias": [
                    3766
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8240,
                "bias": [
                    3765
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8192,
                "bias": [
                    3708
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8208,
                "bias": [
                    3715
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8256,
                "bias": [
                    3755
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5259
            },
            "L1": {
                "label": "L1",
                "addr": 5280
            },
            "L2": {
                "label": "L2",
                "addr": 4512
            },
            "L3": {
                "label": "L3",
                "addr": 5344
            },
            "L4": {
                "label": "L4",
                "addr": 5360
            },
            "L5": {
                "label": "L5",
                "addr": 5384
            },
            "L6": {
                "label": "L6",
                "addr": 5408
            },
            "L7": {
                "label": "L7",
                "addr": 5432
            },
            "L8": {
                "label": "L8",
                "addr": 5456
            },
            "L9": {
                "label": "L9",
                "addr": 5480
            },
            "L10": {
                "label": "L10",
                "addr": 5504
            },
            "L11": {
                "label": "L11",
                "addr": 5520
            },
            "L12": {
                "label": "L12",
                "addr": 5544
            },
            "L13": {
                "label": "L13",
                "addr": 5568
            },
            "L14": {
                "label": "L14",
                "addr": 5592
            },
            "L15": {
                "label": "L15",
                "addr": 5616
            },
            "L16": {
                "label": "L16",
                "addr": 5640
            },
            "L17": {
                "label": "L17",
                "addr": 5659
            },
            "L18": {
                "label": "L18",
                "addr": 5314
            },
            "L19": {
                "label": "L19",
                "addr": 5296
            },
            "L20": {
                "label": "L20",
                "addr": 5299
            },
            "L21": {
                "label": "L21",
                "addr": 4713
            },
            "L22": {
                "label": "L22",
                "addr": 4751
            },
            "L23": {
                "label": "L23",
                "addr": 4790
            },
            "L24": {
                "label": "L24",
                "addr": 4829
            },
            "L25": {
                "label": "L25",
                "addr": 4868
            },
            "L26": {
                "label": "L26",
                "addr": 4907
            },
            "L27": {
                "label": "L27",
                "addr": 4946
            },
            "L28": {
                "label": "L28",
                "addr": 4996
            },
            "L29": {
                "label": "L29",
                "addr": 5035
            },
            "L30": {
                "label": "L30",
                "addr": 5074
            },
            "L31": {
                "label": "L31",
                "addr": 5113
            },
            "L32": {
                "label": "L32",
                "addr": 5152
            },
            "L33": {
                "label": "L33",
                "addr": 5187
            },
            "L34": {
                "label": "L34",
                "addr": 5222
            },
            "L35": {
                "label": "L35",
                "addr": 5256
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "9f9f9f9f9f9f9f9f9f9f9f9f9f9f9f9fbfbfbfbfbfbfbfbfbfbfbfbfbfbfbfbf19191919191919191919191919191919e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e020202020202020202020202020202020",
        "rodata_parsed": {
            "func0": {
                "0x2020": {
                    "type": "byte[16]",
                    "value": [
                        25,
                        25,
                        25,
                        25,
                        25,
                        25,
                        25,
                        25,
                        25,
                        25,
                        25,
                        25,
                        25,
                        25,
                        25,
                        25
                    ]
                },
                "0x2030": {
                    "type": "byte[16]",
                    "value": [
                        224,
                        224,
                        224,
                        224,
                        224,
                        224,
                        224,
                        224,
                        224,
                        224,
                        224,
                        224,
                        224,
                        224,
                        224,
                        224
                    ]
                },
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        159,
                        159,
                        159,
                        159,
                        159,
                        159,
                        159,
                        159,
                        159,
                        159,
                        159,
                        159,
                        159,
                        159,
                        159,
                        159
                    ]
                },
                "0x2010": {
                    "type": "byte[16]",
                    "value": [
                        191,
                        191,
                        191,
                        191,
                        191,
                        191,
                        191,
                        191,
                        191,
                        191,
                        191,
                        191,
                        191,
                        191,
                        191,
                        191
                    ]
                },
                "0x2040": {
                    "type": "byte[16]",
                    "value": [
                        32,
                        32,
                        32,
                        32,
                        32,
                        32,
                        32,
                        32,
                        32,
                        32,
                        32,
                        32,
                        32,
                        32,
                        32,
                        32
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 28,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11a9 <func0+0x50>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     117c <func0+0x23>\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    11d3 <func0+0x7a>\n  mov    $0x0,%eax\n  jmp    1219 <func0+0xc0>\n  mov    -0x8(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  jmp    120d <func0+0xb4>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcat@plt>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     11e3 <func0+0x8a>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL1:\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L1\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L2\n  mov    $0x0,%eax\n  jmp    L3\nL2:\n  mov    -0x8(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L4\nL5:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcat@plt>\n  addl   $0x1,-0xc(%rbp)\nL4:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L5\n  mov    -0x8(%rbp),%rax\nL3:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4521
            },
            "L1": {
                "label": "L1",
                "addr": 4476
            },
            "L2": {
                "label": "L2",
                "addr": 4563
            },
            "L3": {
                "label": "L3",
                "addr": 4633
            },
            "L4": {
                "label": "L4",
                "addr": 4621
            },
            "L5": {
                "label": "L5",
                "addr": 4579
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 28,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    11d0 <func0+0x77>\n  mov    %rdi,%r13\n  mov    %esi,%r12d\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r14\n  mov    $0x0,%ebp\n  mov    (%rbx),%rdi\n  call   1070 <strlen@plt>\n  add    %eax,%ebp\n  add    $0x8,%rbx\n  cmp    %r14,%rbx\n  jne    117f <func0+0x26>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     11c4 <func0+0x6b>\n  movb   $0x0,0x0(%rbp)\n  mov    $0x0,%ebx\n  mov    0x0(%r13,%rbx,8),%rsi\n  mov    %rbp,%rdi\n  call   1090 <strcat@plt>\n  add    $0x1,%rbx\n  cmp    %ebx,%r12d\n  jg     11ae <func0+0x55>\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x1,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     11c4 <func0+0x6b>\n  movb   $0x0,(%rax)\n  jmp    11c4 <func0+0x6b>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r13\n  mov    %esi,%r12d\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r14\n  mov    $0x0,%ebp\nL1:\n  mov    (%rbx),%rdi\n  call   <strlen@plt>\n  add    %eax,%ebp\n  add    $0x8,%rbx\n  cmp    %r14,%rbx\n  jne    L1\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,0x0(%rbp)\n  mov    $0x0,%ebx\nL3:\n  mov    0x0(%r13,%rbx,8),%rsi\n  mov    %rbp,%rdi\n  call   <strcat@plt>\n  add    $0x1,%rbx\n  cmp    %ebx,%r12d\n  jg     L3\nL2:\n  mov    %rbp,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  mov    $0x1,%edi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,(%rax)\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4560
            },
            "L1": {
                "label": "L1",
                "addr": 4479
            },
            "L2": {
                "label": "L2",
                "addr": 4548
            },
            "L3": {
                "label": "L3",
                "addr": 4526
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 28,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    11e8 <func0+0x88>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  mov    %rdi,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax,%rax,1)\n  mov    0x0(%rbp),%rdi\n  add    $0x8,%rbp\n  call   1070 <strlen@plt>\n  add    %eax,%r12d\n  cmp    %r13,%rbp\n  jne    1188 <func0+0x28>\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     120b <func0+0xab>\n  movb   $0x0,(%r8)\n  cs nopw 0x0(%rax,%rax,1)\n  mov    (%rbx),%rsi\n  mov    %r8,%rdi\n  add    $0x8,%rbx\n  call   1090 <strcat@plt>\n  mov    %rax,%r8\n  cmp    %r13,%rbx\n  jne    11c0 <func0+0x60>\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   (%rax)\n  mov    $0x1,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     120b <func0+0xab>\n  movb   $0x0,(%rax)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  xor    %r8d,%r8d\n  jmp    11d7 <func0+0x77>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  mov    %rdi,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax,%rax,1)\nL1:\n  mov    0x0(%rbp),%rdi\n  add    $0x8,%rbp\n  call   <strlen@plt>\n  add    %eax,%r12d\n  cmp    %r13,%rbp\n  jne    L1\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,(%r8)\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    (%rbx),%rsi\n  mov    %r8,%rdi\n  add    $0x8,%rbx\n  call   <strcat@plt>\n  mov    %rax,%r8\n  cmp    %r13,%rbx\n  jne    L3\nL4:\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   (%rax)\nL0:\n  mov    $0x1,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,(%rax)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL2:\n  xor    %r8d,%r8d\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4584
            },
            "L1": {
                "label": "L1",
                "addr": 4488
            },
            "L2": {
                "label": "L2",
                "addr": 4619
            },
            "L3": {
                "label": "L3",
                "addr": 4544
            },
            "L4": {
                "label": "L4",
                "addr": 4567
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 28,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(char** strings, int count) {\n    int length = 0;\n    for (int i = 0; i < count; i++) {\n        length += strlen(strings[i]);\n    }\n    \n    char* out = (char*)malloc(length + 1);\n    if (!out) {\n        return NULL; \n    }\n    \n    out[0] = '\\0';\n\n    for (int i = 0; i < count; i++) {\n        strcat(out, strings[i]);\n    }\n    \n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n    char* empty_strings[] = {};\n    result = func0(empty_strings, 0);\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    char* strings1[] = {\"x\", \"y\", \"z\"};\n    result = func0(strings1, 3);\n    assert(strcmp(result, \"xyz\") == 0);\n    free(result);\n\n    char* strings2[] = {\"x\", \"y\", \"z\", \"w\", \"k\"};\n    result = func0(strings2, 5);\n    assert(strcmp(result, \"xyzwk\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    11e8 <func0+0x88>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  mov    %rdi,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax,%rax,1)\n  mov    0x0(%rbp),%rdi\n  add    $0x8,%rbp\n  call   1070 <strlen@plt>\n  add    %eax,%r12d\n  cmp    %rbp,%r13\n  jne    1188 <func0+0x28>\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     120b <func0+0xab>\n  movb   $0x0,(%r8)\n  cs nopw 0x0(%rax,%rax,1)\n  mov    (%rbx),%rsi\n  mov    %r8,%rdi\n  add    $0x8,%rbx\n  call   1090 <strcat@plt>\n  mov    %rax,%r8\n  cmp    %rbx,%r13\n  jne    11c0 <func0+0x60>\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   (%rax)\n  mov    $0x1,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     120b <func0+0xab>\n  movb   $0x0,(%rax)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  xor    %r8d,%r8d\n  jmp    11d7 <func0+0x77>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  mov    %rdi,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rdi,%rax,8),%r13\n  nopl   0x0(%rax,%rax,1)\nL1:\n  mov    0x0(%rbp),%rdi\n  add    $0x8,%rbp\n  call   <strlen@plt>\n  add    %eax,%r12d\n  cmp    %rbp,%r13\n  jne    L1\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,(%r8)\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    (%rbx),%rsi\n  mov    %r8,%rdi\n  add    $0x8,%rbx\n  call   <strcat@plt>\n  mov    %rax,%r8\n  cmp    %rbx,%r13\n  jne    L3\nL4:\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   (%rax)\nL0:\n  mov    $0x1,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %rax,%rax\n  je     L2\n  movb   $0x0,(%rax)\n  add    $0x8,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL2:\n  xor    %r8d,%r8d\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4584
            },
            "L1": {
                "label": "L1",
                "addr": 4488
            },
            "L2": {
                "label": "L2",
                "addr": 4619
            },
            "L3": {
                "label": "L3",
                "addr": 4544
            },
            "L4": {
                "label": "L4",
                "addr": 4567
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 29,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %rcx,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x30(%rbp),%rax\n  mov    %rdx,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1217 <func0+0xbe>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncmp@plt>\n  test   %eax,%eax\n  jne    1213 <func0+0xba>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%rsi\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  shl    $0x3,%rax\n  lea    (%rsi,%rax,1),%rdx\n  mov    (%rcx),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     11ae <func0+0x55>\n  mov    -0xc(%rbp),%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %rcx,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x30(%rbp),%rax\n  mov    %rdx,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rax\n  mov    -0x28(%rbp),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncmp@plt>\n  test   %eax,%eax\n  jne    L1\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%rsi\n  mov    -0xc(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  shl    $0x3,%rax\n  lea    (%rsi,%rax,1),%rdx\n  mov    (%rcx),%rax\n  mov    %rax,(%rdx)\nL1:\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0xc(%rbp),%eax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4631
            },
            "L1": {
                "label": "L1",
                "addr": 4627
            },
            "L2": {
                "label": "L2",
                "addr": 4526
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 29,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rdi\n  mov    %rdx,0x8(%rsp)\n  mov    %rcx,%r15\n  call   1080 <strlen@plt>\n  mov    %eax,%r13d\n  movslq %ebp,%rdi\n  shl    $0x3,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,(%r15)\n  test   %ebp,%ebp\n  jle    11dd <func0+0x84>\n  mov    %r12,%rbx\n  lea    -0x1(%rbp),%eax\n  lea    0x8(%r12,%rax,8),%r14\n  mov    $0x0,%r12d\n  movslq %r13d,%r13\n  jmp    11b5 <func0+0x5c>\n  add    $0x8,%rbx\n  cmp    %r14,%rbx\n  je     11e3 <func0+0x8a>\n  mov    (%rbx),%rbp\n  mov    %r13,%rdx\n  mov    0x8(%rsp),%rsi\n  mov    %rbp,%rdi\n  call   1070 <strncmp@plt>\n  test   %eax,%eax\n  jne    11ac <func0+0x53>\n  movslq %r12d,%rdx\n  mov    (%r15),%rax\n  mov    %rbp,(%rax,%rdx,8)\n  lea    0x1(%r12),%r12d\n  jmp    11ac <func0+0x53>\n  mov    $0x0,%r12d\n  mov    %r12d,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rdi\n  mov    %rdx,0x8(%rsp)\n  mov    %rcx,%r15\n  call   <strlen@plt>\n  mov    %eax,%r13d\n  movslq %ebp,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%r15)\n  test   %ebp,%ebp\n  jle    L0\n  mov    %r12,%rbx\n  lea    -0x1(%rbp),%eax\n  lea    0x8(%r12,%rax,8),%r14\n  mov    $0x0,%r12d\n  movslq %r13d,%r13\n  jmp    L1\nL3:\n  add    $0x8,%rbx\n  cmp    %r14,%rbx\n  je     L2\nL1:\n  mov    (%rbx),%rbp\n  mov    %r13,%rdx\n  mov    0x8(%rsp),%rsi\n  mov    %rbp,%rdi\n  call   <strncmp@plt>\n  test   %eax,%eax\n  jne    L3\n  movslq %r12d,%rdx\n  mov    (%r15),%rax\n  mov    %rbp,(%rax,%rdx,8)\n  lea    0x1(%r12),%r12d\n  jmp    L3\nL0:\n  mov    $0x0,%r12d\nL2:\n  mov    %r12d,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4573
            },
            "L1": {
                "label": "L1",
                "addr": 4533
            },
            "L2": {
                "label": "L2",
                "addr": 4579
            },
            "L3": {
                "label": "L3",
                "addr": 4524
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 29,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rcx,%r15\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rdx,%rdi\n  sub    $0x18,%rsp\n  call   1080 <strlen@plt>\n  movslq %r12d,%rdi\n  shl    $0x3,%rdi\n  mov    %rax,%rbp\n  call   1090 <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  mov    %rax,(%r15)\n  test   %r12d,%r12d\n  jle    1200 <func0+0xa0>\n  lea    -0x1(%r12),%eax\n  movslq %ebp,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rbx,%rax,8),%r15\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx),%r14\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   1070 <strncmp@plt>\n  test   %eax,%eax\n  jne    11dd <func0+0x7d>\n  mov    0x8(%rsp),%rcx\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r14,(%rcx,%rax,8)\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    11b8 <func0+0x58>\n  add    $0x18,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %r12d,%r12d\n  jmp    11e6 <func0+0x86>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rcx,%r15\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rdx,%rdi\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  movslq %r12d,%rdi\n  shl    $0x3,%rdi\n  mov    %rax,%rbp\n  call   <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  mov    %rax,(%r15)\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  movslq %ebp,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rbx,%rax,8),%r15\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    (%rbx),%r14\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   <strncmp@plt>\n  test   %eax,%eax\n  jne    L1\n  mov    0x8(%rsp),%rcx\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r14,(%rcx,%rax,8)\nL1:\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    L2\nL3:\n  add    $0x18,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  xor    %r12d,%r12d\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4608
            },
            "L1": {
                "label": "L1",
                "addr": 4573
            },
            "L2": {
                "label": "L2",
                "addr": 4536
            },
            "L3": {
                "label": "L3",
                "addr": 4582
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 29,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(char** strings, int count, const char* prefix, char*** out) {\n    int prefix_length = strlen(prefix);\n    *out = (char**)malloc(count * sizeof(char*));\n    int out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (strncmp(strings[i], prefix, prefix_length) == 0) {\n            (*out)[out_count++] = strings[i];\n        }\n    }\n\n    return out_count;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n\n// Helper function to compare two arrays of strings\nint issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char** result;\n    int count;\n    const char* empty[] = {};\n    count = func0(empty, 0, \"john\", &result);\n    assert(issame(result, count, empty, 0));\n    free(result);\n\n    char* strings[] = {\"xxx\", \"asd\", \"xxy\", \"john doe\", \"xxxAAA\", \"xxx\"};\n    char* expected[] = {\"xxx\", \"xxxAAA\", \"xxx\"};\n    count = func0(strings, 6, \"xxx\", &result);\n    assert(issame(result, count, expected, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rcx,%r15\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rdx,%rdi\n  sub    $0x18,%rsp\n  call   1080 <strlen@plt>\n  movslq %r12d,%rdi\n  shl    $0x3,%rdi\n  mov    %rax,%rbp\n  call   1090 <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  mov    %rax,(%r15)\n  test   %r12d,%r12d\n  jle    1200 <func0+0xa0>\n  lea    -0x1(%r12),%eax\n  movslq %ebp,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rbx,%rax,8),%r15\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx),%r14\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   1070 <strncmp@plt>\n  test   %eax,%eax\n  jne    11dd <func0+0x7d>\n  mov    0x8(%rsp),%rcx\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r14,(%rcx,%rax,8)\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    11b8 <func0+0x58>\n  add    $0x18,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %r12d,%r12d\n  jmp    11e6 <func0+0x86>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rcx,%r15\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %rdx,%rdi\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  movslq %r12d,%rdi\n  shl    $0x3,%rdi\n  mov    %rax,%rbp\n  call   <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  mov    %rax,(%r15)\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  movslq %ebp,%rbp\n  xor    %r12d,%r12d\n  lea    0x8(%rbx,%rax,8),%r15\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    (%rbx),%r14\n  mov    %rbp,%rdx\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   <strncmp@plt>\n  test   %eax,%eax\n  jne    L1\n  mov    0x8(%rsp),%rcx\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r14,(%rcx,%rax,8)\nL1:\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    L2\nL3:\n  add    $0x18,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  xor    %r12d,%r12d\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4608
            },
            "L1": {
                "label": "L1",
                "addr": 4573
            },
            "L2": {
                "label": "L2",
                "addr": 4536
            },
            "L3": {
                "label": "L3",
                "addr": 4582
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 30,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11ba <func0+0xa1>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    11b6 <func0+0x9d>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rsi\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rsi),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1158 <func0+0x3f>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL2:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L1\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rsi\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rsi),%xmm0\n  movss  %xmm0,(%rax)\nL1:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4538
            },
            "L1": {
                "label": "L1",
                "addr": 4534
            },
            "L2": {
                "label": "L2",
                "addr": 4440
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 30,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x0,(%rbx)\n  test   %ebp,%ebp\n  jle    1177 <func0+0x5e>\n  mov    %r12,%rdx\n  lea    -0x1(%rbp),%ecx\n  lea    0x4(%r12,%rcx,4),%rdi\n  pxor   %xmm1,%xmm1\n  jmp    116c <func0+0x53>\n  mov    (%rbx),%ecx\n  lea    0x1(%rcx),%esi\n  mov    %esi,(%rbx)\n  movslq %ecx,%rcx\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax,%rcx,4)\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  je     1177 <func0+0x5e>\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  ja     1150 <func0+0x37>\n  jmp    1163 <func0+0x4a>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x0,(%rbx)\n  test   %ebp,%ebp\n  jle    L0\n  mov    %r12,%rdx\n  lea    -0x1(%rbp),%ecx\n  lea    0x4(%r12,%rcx,4),%rdi\n  pxor   %xmm1,%xmm1\n  jmp    L1\nL2:\n  mov    (%rbx),%ecx\n  lea    0x1(%rcx),%esi\n  mov    %esi,(%rbx)\n  movslq %ecx,%rcx\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax,%rcx,4)\nL3:\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  je     L0\nL1:\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  ja     L2\n  jmp    L3\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4471
            },
            "L1": {
                "label": "L1",
                "addr": 4460
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4451
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 30,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    1181 <func0+0x61>\n  lea    -0x1(%r12),%ecx\n  mov    %rbx,%rdx\n  pxor   %xmm1,%xmm1\n  lea    0x4(%rbx,%rcx,4),%rdi\n  nopw   0x0(%rax,%rax,1)\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    1178 <func0+0x58>\n  movslq 0x0(%rbp),%rcx\n  lea    0x1(%rcx),%esi\n  movss  %xmm0,(%rax,%rcx,4)\n  mov    %esi,0x0(%rbp)\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    1160 <func0+0x40>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%ecx\n  mov    %rbx,%rdx\n  pxor   %xmm1,%xmm1\n  lea    0x4(%rbx,%rcx,4),%rdi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    L1\n  movslq 0x0(%rbp),%rcx\n  lea    0x1(%rcx),%esi\n  movss  %xmm0,(%rax,%rcx,4)\n  mov    %esi,0x0(%rbp)\nL1:\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    L2\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4481
            },
            "L1": {
                "label": "L1",
                "addr": 4472
            },
            "L2": {
                "label": "L2",
                "addr": 4448
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 30,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nfloat* func0(const float* l, int count, int* out_count) {\n    float* out = (float*)malloc(count * sizeof(float));\n    *out_count = 0;\n\n    for (int i = 0; i < count; i++) {\n        if (l[i] > 0) {\n            out[(*out_count)++] = l[i];\n        }\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n\n// Helper function to compare two arrays of floats\nint issame(const float* a, int a_count, const float* b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    float* result;\n    int count;\n\n    result = func0((const float[]){-1, -2, 4, 5, 6}, 5, &count);\n    assert(issame(result, count, (const float[]){4, 5, 6}, 3));\n    free(result);\n\n    result = func0((const float[]){5, 3, -5, 2, 3, 3, 9, 0, 123, 1, -10}, 11, &count);\n    assert(issame(result, count, (const float[]){5, 3, 2, 3, 3, 9, 123, 1}, 8));\n    free(result);\n\n    result = func0((const float[]){-1, -2}, 2, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    result = func0((const float[]){}, 0, &count);\n    assert(issame(result, count, (const float[]){}, 0));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    1181 <func0+0x61>\n  lea    -0x1(%r12),%ecx\n  mov    %rbx,%rdx\n  pxor   %xmm1,%xmm1\n  lea    0x4(%rbx,%rcx,4),%rdi\n  nopw   0x0(%rax,%rax,1)\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    1178 <func0+0x58>\n  movslq 0x0(%rbp),%rcx\n  lea    0x1(%rcx),%esi\n  movss  %xmm0,(%rax,%rcx,4)\n  mov    %esi,0x0(%rbp)\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    1160 <func0+0x40>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%ecx\n  mov    %rbx,%rdx\n  pxor   %xmm1,%xmm1\n  lea    0x4(%rbx,%rcx,4),%rdi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movss  (%rdx),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    L1\n  movslq 0x0(%rbp),%rcx\n  lea    0x1(%rcx),%esi\n  movss  %xmm0,(%rax,%rcx,4)\n  mov    %esi,0x0(%rbp)\nL1:\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    L2\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4481
            },
            "L1": {
                "label": "L1",
                "addr": 4472
            },
            "L2": {
                "label": "L2",
                "addr": 4448
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 31,
        "type": "O0",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  cmpq   $0x1,-0x18(%rbp)\n  jg     1113 <func0+0x1a>\n  mov    $0x0,%eax\n  jmp    114e <func0+0x55>\n  movq   $0x2,-0x8(%rbp)\n  jmp    113b <func0+0x42>\n  mov    -0x18(%rbp),%rax\n  cqto\n  idivq  -0x8(%rbp)\n  mov    %rdx,%rax\n  test   %rax,%rax\n  jne    1136 <func0+0x3d>\n  mov    $0x0,%eax\n  jmp    114e <func0+0x55>\n  addq   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  imul   %rax,%rax\n  cmp    %rax,-0x18(%rbp)\n  jge    111d <func0+0x24>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  cmpq   $0x1,-0x18(%rbp)\n  jg     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movq   $0x2,-0x8(%rbp)\n  jmp    L2\nL4:\n  mov    -0x18(%rbp),%rax\n  cqto\n  idivq  -0x8(%rbp)\n  mov    %rdx,%rax\n  test   %rax,%rax\n  jne    L3\n  mov    $0x0,%eax\n  jmp    L1\nL3:\n  addq   $0x1,-0x8(%rbp)\nL2:\n  mov    -0x8(%rbp),%rax\n  imul   %rax,%rax\n  cmp    %rax,-0x18(%rbp)\n  jge    L4\n  mov    $0x1,%eax\nL1:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4371
            },
            "L1": {
                "label": "L1",
                "addr": 4430
            },
            "L2": {
                "label": "L2",
                "addr": 4411
            },
            "L3": {
                "label": "L3",
                "addr": 4406
            },
            "L4": {
                "label": "L4",
                "addr": 4381
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 31,
        "type": "O1",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  cmp    $0x1,%rdi\n  jle    113b <func0+0x42>\n  cmp    $0x3,%rdi\n  jle    1142 <func0+0x49>\n  test   $0x1,%dil\n  je     1148 <func0+0x4f>\n  mov    $0x2,%ecx\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jg     113c <func0+0x43>\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  jne    1119 <func0+0x20>\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  cmp    $0x1,%rdi\n  jle    L0\n  cmp    $0x3,%rdi\n  jle    L1\n  test   $0x1,%dil\n  je     L2\n  mov    $0x2,%ecx\nL4:\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jg     L3\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  jne    L4\n  mov    $0x0,%eax\nL0:\n  ret\nL3:\n  mov    $0x1,%eax\n  ret\nL1:\n  mov    $0x1,%eax\n  ret\nL2:\n  mov    $0x0,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4411
            },
            "L1": {
                "label": "L1",
                "addr": 4418
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            },
            "L3": {
                "label": "L3",
                "addr": 4412
            },
            "L4": {
                "label": "L4",
                "addr": 4377
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 31,
        "type": "O2",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%rdi\n  jle    114a <func0+0x4a>\n  cmp    $0x3,%rdi\n  jle    113d <func0+0x3d>\n  test   $0x1,%dil\n  je     114a <func0+0x4a>\n  mov    $0x2,%ecx\n  jmp    112d <func0+0x2d>\n  nop\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  je     1148 <func0+0x48>\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jle    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%rdi\n  jle    L0\n  cmp    $0x3,%rdi\n  jle    L1\n  test   $0x1,%dil\n  je     L0\n  mov    $0x2,%ecx\n  jmp    L2\n  nop\nL4:\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  je     L3\nL2:\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jle    L4\nL1:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  xor    %eax,%eax\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4426
            },
            "L1": {
                "label": "L1",
                "addr": 4413
            },
            "L2": {
                "label": "L2",
                "addr": 4397
            },
            "L3": {
                "label": "L3",
                "addr": 4424
            },
            "L4": {
                "label": "L4",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 31,
        "type": "O3",
        "c_func": "#include <stdbool.h>\n\nbool func0(long long n) {\n    if (n < 2) return false;\n    for (long long i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(6) == false);\n    assert(func0(101) == true);\n    assert(func0(11) == true);\n    assert(func0(13441) == true);\n    assert(func0(61) == true);\n    assert(func0(4) == false);\n    assert(func0(1) == false);\n    assert(func0(5) == true);\n    assert(func0(11) == true);\n    assert(func0(17) == true);\n    assert(func0(5 * 17) == false);\n    assert(func0(11 * 7) == false);\n    assert(func0(13441 * 19) == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%rdi\n  jle    114a <func0+0x4a>\n  cmp    $0x3,%rdi\n  jle    113d <func0+0x3d>\n  test   $0x1,%dil\n  je     114a <func0+0x4a>\n  mov    $0x2,%ecx\n  jmp    112d <func0+0x2d>\n  nop\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  je     1148 <func0+0x48>\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jle    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%rdi\n  jle    L0\n  cmp    $0x3,%rdi\n  jle    L1\n  test   $0x1,%dil\n  je     L0\n  mov    $0x2,%ecx\n  jmp    L2\n  nop\nL4:\n  mov    %rdi,%rax\n  cqto\n  idiv   %rcx\n  test   %rdx,%rdx\n  je     L3\nL2:\n  add    $0x1,%rcx\n  mov    %rcx,%rax\n  imul   %rcx,%rax\n  cmp    %rdi,%rax\n  jle    L4\nL1:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  xor    %eax,%eax\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4426
            },
            "L1": {
                "label": "L1",
                "addr": 4413
            },
            "L2": {
                "label": "L2",
                "addr": 4397
            },
            "L3": {
                "label": "L3",
                "addr": 4424
            },
            "L4": {
                "label": "L4",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 32,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  pxor   %xmm0,%xmm0\n  movsd  %xmm0,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  movsd  (%rax),%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    1187 <func0+0x8e>\n  movsd  0xed1(%rip),%xmm0        # 2000 <_fini+0xd18>\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  jmp    1150 <func0+0x57>\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     113d <func0+0x44>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x18(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     1127 <func0+0x2e>\n  jmp    12b5 <func0+0x1bc>\n  pxor   %xmm0,%xmm0\n  movsd  %xmm0,-0x10(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    1213 <func0+0x11a>\n  movsd  0xe52(%rip),%xmm0        # 2000 <_fini+0xd18>\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x1,-0x28(%rbp)\n  jmp    11cf <func0+0xd6>\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x28(%rbp)\n  mov    -0x28(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     11bc <func0+0xc3>\n  pxor   %xmm1,%xmm1\n  cvtsi2sdl -0x30(%rbp),%xmm1\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  %xmm1,%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x10(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x10(%rbp)\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     11a6 <func0+0xad>\n  movsd  -0x18(%rbp),%xmm0\n  movapd %xmm0,%xmm1\n  divsd  -0x10(%rbp),%xmm1\n  movsd  -0x20(%rbp),%xmm0\n  subsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  movsd  (%rax),%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    12ad <func0+0x1b4>\n  movsd  0xdab(%rip),%xmm0        # 2000 <_fini+0xd18>\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    1276 <func0+0x17d>\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     1263 <func0+0x16a>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x18(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     124d <func0+0x154>\n  movsd  -0x18(%rbp),%xmm0\n  movq   0xd4e(%rip),%xmm1        # 2010 <_fini+0xd28>\n  andpd  %xmm1,%xmm0\n  comisd 0xd52(%rip),%xmm0        # 2020 <_fini+0xd38>\n  ja     1194 <func0+0x9b>\n  movsd  -0x20(%rbp),%xmm0\n  movq   %xmm0,%rax\n  movq   %rax,%xmm0\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  pxor   %xmm0,%xmm0\n  movsd  %xmm0,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  movsd  (%rax),%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    L0\nL3:\n  movsd  D0(%rip),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  jmp    L1\nL2:\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x2c(%rbp)\nL1:\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L2\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x18(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  addl   $0x1,-0x30(%rbp)\nL0:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L3\n  jmp    L4\nL13:\n  pxor   %xmm0,%xmm0\n  movsd  %xmm0,-0x10(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    L5\nL8:\n  movsd  D0(%rip),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x1,-0x28(%rbp)\n  jmp    L6\nL7:\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x28(%rbp)\nL6:\n  mov    -0x28(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L7\n  pxor   %xmm1,%xmm1\n  cvtsi2sdl -0x30(%rbp),%xmm1\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  %xmm1,%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x10(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x10(%rbp)\n  addl   $0x1,-0x30(%rbp)\nL5:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L8\n  movsd  -0x18(%rbp),%xmm0\n  movapd %xmm0,%xmm1\n  divsd  -0x10(%rbp),%xmm1\n  movsd  -0x20(%rbp),%xmm0\n  subsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  movsd  (%rax),%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  movl   $0x1,-0x30(%rbp)\n  jmp    L9\nL12:\n  movsd  D0(%rip),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L10\nL11:\n  movsd  -0x8(%rbp),%xmm0\n  mulsd  -0x20(%rbp),%xmm0\n  movsd  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x24(%rbp)\nL10:\n  mov    -0x24(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L11\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movsd  (%rax),%xmm0\n  mulsd  -0x8(%rbp),%xmm0\n  movsd  -0x18(%rbp),%xmm1\n  addsd  %xmm1,%xmm0\n  movsd  %xmm0,-0x18(%rbp)\n  addl   $0x1,-0x30(%rbp)\nL9:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L12\nL4:\n  movsd  -0x18(%rbp),%xmm0\n  movq   D1(%rip),%xmm1\n  andpd  %xmm1,%xmm0\n  comisd D2(%rip),%xmm0\n  ja     L13\n  movsd  -0x20(%rbp),%xmm0\n  movq   %xmm0,%rax\n  movq   %rax,%xmm0\n  pop    %rbp\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3793,
                    3666,
                    3499
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3406
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8224,
                "bias": [
                    3410
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4487
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            },
            "L2": {
                "label": "L2",
                "addr": 4413
            },
            "L3": {
                "label": "L3",
                "addr": 4391
            },
            "L4": {
                "label": "L4",
                "addr": 4789
            },
            "L5": {
                "label": "L5",
                "addr": 4627
            },
            "L6": {
                "label": "L6",
                "addr": 4559
            },
            "L7": {
                "label": "L7",
                "addr": 4540
            },
            "L8": {
                "label": "L8",
                "addr": 4518
            },
            "L9": {
                "label": "L9",
                "addr": 4781
            },
            "L10": {
                "label": "L10",
                "addr": 4726
            },
            "L11": {
                "label": "L11",
                "addr": 4707
            },
            "L12": {
                "label": "L12",
                "addr": 4685
            },
            "L13": {
                "label": "L13",
                "addr": 4500
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000000000000f03f0000000000000000ffffffffffffff7f00000000000000008dedb5a0f7c6b03e",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f64",
                    "value": 1.0
                },
                "0x2010": {
                    "type": "qword",
                    "value": 9223372036854775807
                },
                "0x2020": {
                    "type": "byte[16]",
                    "value": [
                        141,
                        237,
                        181,
                        160,
                        247,
                        198,
                        176,
                        62
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 32,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  mov    %esi,%r9d\n  movsd  (%rdi),%xmm5\n  cmp    $0x1,%esi\n  jle    1150 <func0+0x57>\n  mov    %esi,%esi\n  movapd %xmm5,%xmm3\n  mov    $0x1,%ecx\n  pxor   %xmm1,%xmm1\n  jmp    113b <func0+0x42>\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    111d <func0+0x24>\n  mulsd  (%r8,%rcx,8),%xmm0\n  addsd  %xmm0,%xmm3\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  je     1154 <func0+0x5b>\n  mov    %ecx,%edx\n  mov    $0x0,%eax\n  movsd  0xeb6(%rip),%xmm0        # 2000 <_fini+0xd94>\n  test   %ecx,%ecx\n  jg     111d <func0+0x24>\n  jmp    1128 <func0+0x2f>\n  movapd %xmm5,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  0xeb0(%rip),%xmm0        # 2010 <_fini+0xda4>\n  pxor   %xmm1,%xmm1\n  comisd 0xe9c(%rip),%xmm0        # 2008 <_fini+0xd9c>\n  jbe    1189 <func0+0x90>\n  mov    $0x1,%r10d\n  movq   0xe94(%rip),%xmm7        # 2010 <_fini+0xda4>\n  movsd  0xe84(%rip),%xmm6        # 2008 <_fini+0xd9c>\n  jmp    1236 <func0+0x13d>\n  pxor   %xmm1,%xmm1\n  movapd %xmm1,%xmm0\n  ret\n  mov    $0x1,%eax\n  movsd  0xe61(%rip),%xmm0        # 2000 <_fini+0xd94>\n  mulsd  %xmm1,%xmm0\n  mov    %eax,%edx\n  add    $0x1,%eax\n  cmp    %edx,%ecx\n  jne    119f <func0+0xa6>\n  add    $0x8,%rdi\n  mov    %esi,%ecx\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %ecx,%xmm2\n  mulsd  (%rdi),%xmm2\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  lea    0x1(%rcx),%esi\n  cmp    %esi,%r9d\n  je     1254 <func0+0x15b>\n  cmp    $0x1,%esi\n  jg     1192 <func0+0x99>\n  movsd  0xe21(%rip),%xmm0        # 2000 <_fini+0xd94>\n  jmp    11ac <func0+0xb3>\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %eax,%edx\n  jne    11e1 <func0+0xe8>\n  mulsd  (%r8,%rcx,8),%xmm0\n  addsd  %xmm0,%xmm3\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  je     1224 <func0+0x12b>\n  mov    %ecx,%edx\n  mov    $0x0,%eax\n  movsd  0xdf2(%rip),%xmm0        # 2000 <_fini+0xd94>\n  test   %ecx,%ecx\n  jg     11e1 <func0+0xe8>\n  jmp    11ec <func0+0xf3>\n  divsd  0xdfc(%rip),%xmm3        # 2018 <_fini+0xdac>\n  subsd  %xmm3,%xmm1\n  movapd %xmm5,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  %xmm7,%xmm0\n  comisd %xmm6,%xmm0\n  jbe    118d <func0+0x94>\n  cmp    $0x1,%r9d\n  jle    1214 <func0+0x11b>\n  lea    0x8(%r8),%rdi\n  mov    %r10d,%ecx\n  pxor   %xmm4,%xmm4\n  movsd  0xdb1(%rip),%xmm0        # 2000 <_fini+0xd94>\n  jmp    11b2 <func0+0xb9>\n  divsd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  lea    0x1(%rcx),%esi\n  movapd %xmm5,%xmm3\n  mov    $0x1,%ecx\n  jmp    11ff <func0+0x106>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  mov    %esi,%r9d\n  movsd  (%rdi),%xmm5\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %esi,%esi\n  movapd %xmm5,%xmm3\n  mov    $0x1,%ecx\n  pxor   %xmm1,%xmm1\n  jmp    L1\nL2:\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L2\nL4:\n  mulsd  (%r8,%rcx,8),%xmm0\n  addsd  %xmm0,%xmm3\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  je     L3\nL1:\n  mov    %ecx,%edx\n  mov    $0x0,%eax\n  movsd  D0(%rip),%xmm0\n  test   %ecx,%ecx\n  jg     L2\n  jmp    L4\nL0:\n  movapd %xmm5,%xmm3\nL3:\n  movapd %xmm3,%xmm0\n  andpd  D1(%rip),%xmm0\n  pxor   %xmm1,%xmm1\n  comisd D2(%rip),%xmm0\n  jbe    L5\n  mov    $0x1,%r10d\n  movq   D1(%rip),%xmm7\n  movsd  D2(%rip),%xmm6\n  jmp    L6\nL5:\n  pxor   %xmm1,%xmm1\nL14:\n  movapd %xmm1,%xmm0\n  ret\nL9:\n  mov    $0x1,%eax\n  movsd  D0(%rip),%xmm0\nL7:\n  mulsd  %xmm1,%xmm0\n  mov    %eax,%edx\n  add    $0x1,%eax\n  cmp    %edx,%ecx\n  jne    L7\nL10:\n  add    $0x8,%rdi\n  mov    %esi,%ecx\nL16:\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %ecx,%xmm2\n  mulsd  (%rdi),%xmm2\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  lea    0x1(%rcx),%esi\n  cmp    %esi,%r9d\n  je     L8\n  cmp    $0x1,%esi\n  jg     L9\n  movsd  D0(%rip),%xmm0\n  jmp    L10\nL11:\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %eax,%edx\n  jne    L11\nL13:\n  mulsd  (%r8,%rcx,8),%xmm0\n  addsd  %xmm0,%xmm3\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  je     L12\nL17:\n  mov    %ecx,%edx\n  mov    $0x0,%eax\n  movsd  D0(%rip),%xmm0\n  test   %ecx,%ecx\n  jg     L11\n  jmp    L13\nL15:\n  divsd  D3(%rip),%xmm3\n  subsd  %xmm3,%xmm1\n  movapd %xmm5,%xmm3\nL12:\n  movapd %xmm3,%xmm0\n  andpd  %xmm7,%xmm0\n  comisd %xmm6,%xmm0\n  jbe    L14\nL6:\n  cmp    $0x1,%r9d\n  jle    L15\n  lea    0x8(%r8),%rdi\n  mov    %r10d,%ecx\n  pxor   %xmm4,%xmm4\n  movsd  D0(%rip),%xmm0\n  jmp    L16\nL8:\n  divsd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  lea    0x1(%rcx),%esi\n  movapd %xmm5,%xmm3\n  mov    $0x1,%ecx\n  jmp    L17",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3766,
                    3681,
                    3617,
                    3570,
                    3505
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3760,
                    3732
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3740,
                    3716
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8216,
                "bias": [
                    3580
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4432
            },
            "L1": {
                "label": "L1",
                "addr": 4411
            },
            "L2": {
                "label": "L2",
                "addr": 4381
            },
            "L3": {
                "label": "L3",
                "addr": 4436
            },
            "L4": {
                "label": "L4",
                "addr": 4392
            },
            "L5": {
                "label": "L5",
                "addr": 4489
            },
            "L6": {
                "label": "L6",
                "addr": 4662
            },
            "L7": {
                "label": "L7",
                "addr": 4511
            },
            "L8": {
                "label": "L8",
                "addr": 4692
            },
            "L9": {
                "label": "L9",
                "addr": 4498
            },
            "L10": {
                "label": "L10",
                "addr": 4524
            },
            "L11": {
                "label": "L11",
                "addr": 4577
            },
            "L12": {
                "label": "L12",
                "addr": 4644
            },
            "L13": {
                "label": "L13",
                "addr": 4588
            },
            "L14": {
                "label": "L14",
                "addr": 4493
            },
            "L15": {
                "label": "L15",
                "addr": 4628
            },
            "L16": {
                "label": "L16",
                "addr": 4530
            },
            "L17": {
                "label": "L17",
                "addr": 4607
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000000000000f03f8dedb5a0f7c6b03effffffffffffff7f0000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f64",
                    "value": 1.0
                },
                "0x2010": {
                    "type": "qword[2]",
                    "value": [
                        9223372036854775807,
                        0
                    ]
                },
                "0x2018": {
                    "type": "f64",
                    "value": 0.0
                },
                "0x2008": {
                    "type": "byte[16]",
                    "value": [
                        141,
                        237,
                        181,
                        160,
                        247,
                        198,
                        176,
                        62,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        127
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 32,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movsd  (%rdi),%xmm7\n  mov    %rdi,%r8\n  mov    %esi,%r9d\n  cmp    $0x1,%esi\n  jle    1279 <func0+0x179>\n  movslq %esi,%rcx\n  movapd %xmm7,%xmm3\n  pxor   %xmm6,%xmm6\n  mov    $0x1,%edx\n  movsd  0xed1(%rip),%xmm1        # 2000 <_fini+0xd78>\n  nop\n  xor    %eax,%eax\n  movapd %xmm1,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\n  mulsd  %xmm6,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    1140 <func0+0x40>\n  mulsd  (%r8,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%rcx\n  jne    1130 <func0+0x30>\n  movq   0xea9(%rip),%xmm9        # 2010 <_fini+0xd88>\n  movapd %xmm3,%xmm0\n  movapd %xmm6,%xmm1\n  movsd  0xe90(%rip),%xmm8        # 2008 <_fini+0xd80>\n  movsd  0xe80(%rip),%xmm5        # 2000 <_fini+0xd78>\n  movslq %r9d,%r10\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  jbe    1252 <func0+0x152>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x1,%r9d\n  jle    1257 <func0+0x157>\n  lea    0x8(%r8),%rdi\n  movapd %xmm6,%xmm4\n  mov    $0x1,%ecx\n  movapd %xmm5,%xmm0\n  nopl   0x0(%rax,%rax,1)\n  pxor   %xmm2,%xmm2\n  lea    0x1(%rcx),%esi\n  cvtsi2sd %ecx,%xmm2\n  mulsd  (%rdi),%xmm2\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  cmp    %esi,%r9d\n  je     11f8 <func0+0xf8>\n  mov    $0x1,%eax\n  movapd %xmm5,%xmm0\n  nopl   (%rax)\n  mulsd  %xmm1,%xmm0\n  mov    %eax,%edx\n  add    $0x1,%eax\n  cmp    %ecx,%edx\n  jne    11e0 <func0+0xe0>\n  add    $0x8,%rdi\n  mov    %esi,%ecx\n  jmp    11b8 <func0+0xb8>\n  nopl   (%rax)\n  divsd  %xmm4,%xmm3\n  mov    $0x1,%edx\n  subsd  %xmm3,%xmm1\n  movapd %xmm7,%xmm3\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    1220 <func0+0x120>\n  mulsd  (%r8,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%r10\n  jne    1210 <func0+0x110>\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     1198 <func0+0x98>\n  movapd %xmm1,%xmm0\n  ret\n  divsd  %xmm6,%xmm3\n  subsd  %xmm3,%xmm1\n  movapd %xmm7,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     1198 <func0+0x98>\n  jmp    1252 <func0+0x152>\n  movapd %xmm7,%xmm3\n  pxor   %xmm6,%xmm6\n  jmp    115e <func0+0x5e>",
        "asm_labeled": "<func0>:\n  endbr64\n  movsd  (%rdi),%xmm7\n  mov    %rdi,%r8\n  mov    %esi,%r9d\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rcx\n  movapd %xmm7,%xmm3\n  pxor   %xmm6,%xmm6\n  mov    $0x1,%edx\n  movsd  D0(%rip),%xmm1\n  nop\nL2:\n  xor    %eax,%eax\n  movapd %xmm1,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  mulsd  %xmm6,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L1\n  mulsd  (%r8,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%rcx\n  jne    L2\nL11:\n  movq   D1(%rip),%xmm9\n  movapd %xmm3,%xmm0\n  movapd %xmm6,%xmm1\n  movsd  D2(%rip),%xmm8\n  movsd  D0(%rip),%xmm5\n  movslq %r9d,%r10\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  jbe    L3\n  nopl   0x0(%rax,%rax,1)\nL10:\n  cmp    $0x1,%r9d\n  jle    L4\n  lea    0x8(%r8),%rdi\n  movapd %xmm6,%xmm4\n  mov    $0x1,%ecx\n  movapd %xmm5,%xmm0\n  nopl   0x0(%rax,%rax,1)\nL7:\n  pxor   %xmm2,%xmm2\n  lea    0x1(%rcx),%esi\n  cvtsi2sd %ecx,%xmm2\n  mulsd  (%rdi),%xmm2\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  cmp    %esi,%r9d\n  je     L5\n  mov    $0x1,%eax\n  movapd %xmm5,%xmm0\n  nopl   (%rax)\nL6:\n  mulsd  %xmm1,%xmm0\n  mov    %eax,%edx\n  add    $0x1,%eax\n  cmp    %ecx,%edx\n  jne    L6\n  add    $0x8,%rdi\n  mov    %esi,%ecx\n  jmp    L7\n  nopl   (%rax)\nL5:\n  divsd  %xmm4,%xmm3\n  mov    $0x1,%edx\n  subsd  %xmm3,%xmm1\n  movapd %xmm7,%xmm3\n  nopl   0x0(%rax)\nL9:\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\nL8:\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L8\n  mulsd  (%r8,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%r10\n  jne    L9\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     L10\nL3:\n  movapd %xmm1,%xmm0\n  ret\nL4:\n  divsd  %xmm6,%xmm3\n  subsd  %xmm3,%xmm1\n  movapd %xmm7,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     L10\n  jmp    L3\nL0:\n  movapd %xmm7,%xmm3\n  pxor   %xmm6,%xmm6\n  jmp    L11",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3793,
                    3712
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3753
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3728
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4729
            },
            "L1": {
                "label": "L1",
                "addr": 4416
            },
            "L2": {
                "label": "L2",
                "addr": 4400
            },
            "L3": {
                "label": "L3",
                "addr": 4690
            },
            "L4": {
                "label": "L4",
                "addr": 4695
            },
            "L5": {
                "label": "L5",
                "addr": 4600
            },
            "L6": {
                "label": "L6",
                "addr": 4576
            },
            "L7": {
                "label": "L7",
                "addr": 4536
            },
            "L8": {
                "label": "L8",
                "addr": 4640
            },
            "L9": {
                "label": "L9",
                "addr": 4624
            },
            "L10": {
                "label": "L10",
                "addr": 4504
            },
            "L11": {
                "label": "L11",
                "addr": 4446
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000000000000f03f8dedb5a0f7c6b03effffffffffffff7f0000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f64",
                    "value": 1.0
                },
                "0x2010": {
                    "type": "qword",
                    "value": 9223372036854775807
                },
                "0x2008": {
                    "type": "byte[8]",
                    "value": [
                        141,
                        237,
                        181,
                        160,
                        247,
                        198,
                        176,
                        62
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 32,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\ndouble func0(const double *xs, int size) {\n    double ans = 0.0;\n    double value, driv, x_pow;\n    int i;\n\n    value = xs[0];\n    for (i = 1; i < size; i++) {\n        x_pow = 1.0;\n        for (int j = 0; j < i; j++) {\n            x_pow *= ans;\n        }\n        value += xs[i] * x_pow;\n    }\n\n    while (fabs(value) > 1e-6) {\n        driv = 0.0;\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 1; j < i; j++) {\n                x_pow *= ans;\n            }\n            driv += i * xs[i] * x_pow;\n        }\n        ans = ans - value / driv;\n\n        value = xs[0];\n        for (i = 1; i < size; i++) {\n            x_pow = 1.0;\n            for (int j = 0; j < i; j++) {\n                x_pow *= ans;\n            }\n            value += xs[i] * x_pow;\n        }\n    }\n\n    return ans;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <math.h>\n\n\ndouble evaluate_polynomial(const double *coeffs, int size, double x) {\n    double result = 0.0;\n    double term = 1.0; \n    for (int i = 0; i < size; i++) {\n        if (i > 0) {\n            term *= x; \n        }\n        result += coeffs[i] * term;\n    }\n    return result;\n}\n\nint main() {\n    double solution;\n    int ncoeff;\n    \n    for (int i = 0; i < 100; i++) {\n        ncoeff = 2 * (1 + rand() % 4);\n        double coeffs[ncoeff];\n        for (int j = 0; j < ncoeff; j++) {\n            double coeff = -10 + rand() % 21;\n            if (coeff == 0) coeff = 1;\n            coeffs[j] = coeff;\n        }\n        \n        solution = func0(coeffs, ncoeff);\n\n        assert(fabs(evaluate_polynomial(coeffs, ncoeff, solution)) < 1e-3);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movsd  (%rdi),%xmm10\n  mov    %esi,%r9d\n  cmp    $0x1,%esi\n  jle    1279 <func0+0x179>\n  movsd  0xee3(%rip),%xmm5        # 2000 <_fini+0xd78>\n  movslq %esi,%r8\n  movapd %xmm10,%xmm3\n  mov    $0x1,%edx\n  pxor   %xmm7,%xmm7\n  xchg   %ax,%ax\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\n  mulsd  %xmm7,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    1140 <func0+0x40>\n  mulsd  (%rdi,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%r8\n  jne    1130 <func0+0x30>\n  movq   0xeaa(%rip),%xmm9        # 2010 <_fini+0xd88>\n  movapd %xmm3,%xmm0\n  movapd %xmm7,%xmm1\n  movsd  0xe91(%rip),%xmm8        # 2008 <_fini+0xd80>\n  movsd  0xe81(%rip),%xmm6        # 2000 <_fini+0xd78>\n  movslq %r9d,%r10\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  jbe    1251 <func0+0x151>\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x1,%r9d\n  jle    1256 <func0+0x156>\n  movsd  0x8(%rdi),%xmm4\n  mov    $0x2,%r8d\n  movapd %xmm6,%xmm5\n  addsd  %xmm7,%xmm4\n  cmp    $0x2,%r9d\n  je     1201 <func0+0x101>\n  mov    %r10,%r8\n  mov    $0x2,%ecx\n  nopl   0x0(%rax,%rax,1)\n  mov    %ecx,%esi\n  mov    %ecx,%edx\n  movapd %xmm6,%xmm0\n  mov    $0x1,%eax\n  nopl   (%rax)\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    11d8 <func0+0xd8>\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %esi,%xmm2\n  mulsd  (%rdi,%rcx,8),%xmm2\n  add    $0x1,%rcx\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  cmp    %rcx,%r10\n  jne    11c8 <func0+0xc8>\n  divsd  %xmm4,%xmm3\n  mov    $0x1,%edx\n  subsd  %xmm3,%xmm1\n  movapd %xmm10,%xmm3\n  nopl   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  xchg   %ax,%ax\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    1220 <func0+0x120>\n  mulsd  (%rdi,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %r8,%rdx\n  jne    1218 <func0+0x118>\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     1198 <func0+0x98>\n  movapd %xmm1,%xmm0\n  ret\n  divsd  %xmm7,%xmm3\n  subsd  %xmm3,%xmm1\n  movapd %xmm10,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     1198 <func0+0x98>\n  jmp    1251 <func0+0x151>\n  movapd %xmm10,%xmm3\n  pxor   %xmm7,%xmm7\n  jmp    115d <func0+0x5d>",
        "asm_labeled": "<func0>:\n  endbr64\n  movsd  (%rdi),%xmm10\n  mov    %esi,%r9d\n  cmp    $0x1,%esi\n  jle    L0\n  movsd  D0(%rip),%xmm5\n  movslq %esi,%r8\n  movapd %xmm10,%xmm3\n  mov    $0x1,%edx\n  pxor   %xmm7,%xmm7\n  xchg   %ax,%ax\nL2:\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  mulsd  %xmm7,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L1\n  mulsd  (%rdi,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %rdx,%r8\n  jne    L2\nL11:\n  movq   D1(%rip),%xmm9\n  movapd %xmm3,%xmm0\n  movapd %xmm7,%xmm1\n  movsd  D2(%rip),%xmm8\n  movsd  D0(%rip),%xmm6\n  movslq %r9d,%r10\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  jbe    L3\n  nopw   0x0(%rax,%rax,1)\nL10:\n  cmp    $0x1,%r9d\n  jle    L4\n  movsd  0x8(%rdi),%xmm4\n  mov    $0x2,%r8d\n  movapd %xmm6,%xmm5\n  addsd  %xmm7,%xmm4\n  cmp    $0x2,%r9d\n  je     L5\n  mov    %r10,%r8\n  mov    $0x2,%ecx\n  nopl   0x0(%rax,%rax,1)\nL7:\n  mov    %ecx,%esi\n  mov    %ecx,%edx\n  movapd %xmm6,%xmm0\n  mov    $0x1,%eax\n  nopl   (%rax)\nL6:\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L6\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %esi,%xmm2\n  mulsd  (%rdi,%rcx,8),%xmm2\n  add    $0x1,%rcx\n  mulsd  %xmm2,%xmm0\n  addsd  %xmm0,%xmm4\n  cmp    %rcx,%r10\n  jne    L7\nL5:\n  divsd  %xmm4,%xmm3\n  mov    $0x1,%edx\n  subsd  %xmm3,%xmm1\n  movapd %xmm10,%xmm3\n  nopl   0x0(%rax,%rax,1)\nL9:\n  xor    %eax,%eax\n  movapd %xmm5,%xmm0\n  xchg   %ax,%ax\nL8:\n  mulsd  %xmm1,%xmm0\n  add    $0x1,%eax\n  cmp    %edx,%eax\n  jne    L8\n  mulsd  (%rdi,%rdx,8),%xmm0\n  add    $0x1,%rdx\n  addsd  %xmm0,%xmm3\n  cmp    %r8,%rdx\n  jne    L9\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     L10\nL3:\n  movapd %xmm1,%xmm0\n  ret\nL4:\n  divsd  %xmm7,%xmm3\n  subsd  %xmm3,%xmm1\n  movapd %xmm10,%xmm3\n  movapd %xmm3,%xmm0\n  andpd  %xmm9,%xmm0\n  comisd %xmm8,%xmm0\n  ja     L10\n  jmp    L3\nL0:\n  movapd %xmm10,%xmm3\n  pxor   %xmm7,%xmm7\n  jmp    L11",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3811,
                    3713
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3754
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3729
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4729
            },
            "L1": {
                "label": "L1",
                "addr": 4416
            },
            "L2": {
                "label": "L2",
                "addr": 4400
            },
            "L3": {
                "label": "L3",
                "addr": 4689
            },
            "L4": {
                "label": "L4",
                "addr": 4694
            },
            "L5": {
                "label": "L5",
                "addr": 4609
            },
            "L6": {
                "label": "L6",
                "addr": 4568
            },
            "L7": {
                "label": "L7",
                "addr": 4552
            },
            "L8": {
                "label": "L8",
                "addr": 4640
            },
            "L9": {
                "label": "L9",
                "addr": 4632
            },
            "L10": {
                "label": "L10",
                "addr": 4504
            },
            "L11": {
                "label": "L11",
                "addr": 4445
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000000000000f03f8dedb5a0f7c6b03effffffffffffff7f0000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f64",
                    "value": 1.0
                },
                "0x2010": {
                    "type": "qword",
                    "value": 9223372036854775807
                },
                "0x2008": {
                    "type": "byte[8]",
                    "value": [
                        141,
                        237,
                        181,
                        160,
                        247,
                        198,
                        176,
                        62
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 33,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    11d1 <func0+0x98>\n  mov    -0x1c(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cmp    %eax,-0x2c(%rbp)\n  jg     1196 <func0+0x5d>\n  movl   $0x0,-0x1c(%rbp)\n  jmp    12a9 <func0+0x170>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x18(%rbp)\n  jmp    1236 <func0+0xfd>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    1232 <func0+0xf9>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     11fc <func0+0xc3>\n  mov    -0x10(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  je     12a5 <func0+0x16c>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x14(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     11eb <func0+0xb2>\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1361 <func0+0x228>\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  test   %eax,%eax\n  jne    1330 <func0+0x1f7>\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  jmp    135d <func0+0x224>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     12c4 <func0+0x18b>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <free@plt>\n  nop\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL1:\n  mov    -0x1c(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cmp    %eax,-0x2c(%rbp)\n  jg     L1\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L2\nL7:\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x18(%rbp)\n  jmp    L3\nL5:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L4\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\nL4:\n  addl   $0x1,-0x18(%rbp)\nL3:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L5\n  mov    -0x10(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  je     L6\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\nL6:\n  addl   $0x1,-0x1c(%rbp)\nL2:\n  mov    -0x14(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     L7\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L8\nL11:\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  test   %eax,%eax\n  jne    L9\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  jmp    L10\nL9:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL10:\n  addl   $0x1,-0x1c(%rbp)\nL8:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L11\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  nop\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4561
            },
            "L1": {
                "label": "L1",
                "addr": 4502
            },
            "L2": {
                "label": "L2",
                "addr": 4777
            },
            "L3": {
                "label": "L3",
                "addr": 4662
            },
            "L4": {
                "label": "L4",
                "addr": 4658
            },
            "L5": {
                "label": "L5",
                "addr": 4604
            },
            "L6": {
                "label": "L6",
                "addr": 4773
            },
            "L7": {
                "label": "L7",
                "addr": 4587
            },
            "L8": {
                "label": "L8",
                "addr": 4961
            },
            "L9": {
                "label": "L9",
                "addr": 4912
            },
            "L10": {
                "label": "L10",
                "addr": 4957
            },
            "L11": {
                "label": "L11",
                "addr": 4804
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 33,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  mov    %rdx,%r12\n  movslq %esi,%rdi\n  imul   $0x55555556,%rdi,%rdi\n  shr    $0x20,%rdi\n  mov    %esi,%eax\n  sar    $0x1f,%eax\n  sub    %eax,%edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    1254 <func0+0x11b>\n  mov    $0x0,%edx\n  mov    $0x0,%eax\n  mov    %eax,%r10d\n  mov    0x0(%rbp,%rdx,4),%ecx\n  mov    %ecx,(%rdi,%rax,4)\n  add    $0x1,%rax\n  add    $0x3,%rdx\n  cmp    %edx,%ebx\n  jg     1188 <func0+0x4f>\n  test   %r10d,%r10d\n  jle    1264 <func0+0x12b>\n  lea    -0x1(%r10),%r13d\n  mov    %r10d,%r9d\n  mov    $0x0,%esi\n  jmp    11c2 <func0+0x89>\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     1264 <func0+0x12b>\n  mov    %esi,%edx\n  mov    %esi,%r11d\n  cmp    %r10d,%esi\n  jge    11b5 <func0+0x7c>\n  lea    0x1(%rsi),%rax\n  mov    %r13d,%ecx\n  sub    %esi,%ecx\n  lea    0x2(%rsi,%rcx,1),%r8\n  movslq %edx,%rcx\n  mov    (%rdi,%rcx,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  jne    11da <func0+0xa1>\n  cmp    %r11d,%edx\n  je     11b5 <func0+0x7c>\n  mov    (%rdi,%rsi,4),%ecx\n  movslq %edx,%rdx\n  lea    (%rdi,%rdx,4),%rax\n  mov    (%rax),%edx\n  mov    %edx,(%rdi,%rsi,4)\n  mov    %ecx,(%rax)\n  jmp    11b5 <func0+0x7c>\n  mov    0x0(%rbp,%rdx,4),%eax\n  mov    %eax,(%r12,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rbx\n  je     1254 <func0+0x11b>\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,2),%eax\n  cmp    %edx,%eax\n  jne    1207 <func0+0xce>\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cltq\n  mov    (%rdi,%rax,4),%eax\n  mov    %eax,(%r12,%rdx,4)\n  jmp    120f <func0+0xd6>\n  call   1060 <free@plt>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  mov    %ebx,%ebx\n  mov    $0x0,%edx\n  jmp    1218 <func0+0xdf>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  mov    %rdx,%r12\n  movslq %esi,%rdi\n  imul   $0x55555556,%rdi,%rdi\n  shr    $0x20,%rdi\n  mov    %esi,%eax\n  sar    $0x1f,%eax\n  sub    %eax,%edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    L0\n  mov    $0x0,%edx\n  mov    $0x0,%eax\nL1:\n  mov    %eax,%r10d\n  mov    0x0(%rbp,%rdx,4),%ecx\n  mov    %ecx,(%rdi,%rax,4)\n  add    $0x1,%rax\n  add    $0x3,%rdx\n  cmp    %edx,%ebx\n  jg     L1\n  test   %r10d,%r10d\n  jle    L2\n  lea    -0x1(%r10),%r13d\n  mov    %r10d,%r9d\n  mov    $0x0,%esi\n  jmp    L3\nL4:\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     L2\nL3:\n  mov    %esi,%edx\n  mov    %esi,%r11d\n  cmp    %r10d,%esi\n  jge    L4\n  lea    0x1(%rsi),%rax\n  mov    %r13d,%ecx\n  sub    %esi,%ecx\n  lea    0x2(%rsi,%rcx,1),%r8\nL5:\n  movslq %edx,%rcx\n  mov    (%rdi,%rcx,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  jne    L5\n  cmp    %r11d,%edx\n  je     L4\n  mov    (%rdi,%rsi,4),%ecx\n  movslq %edx,%rdx\n  lea    (%rdi,%rdx,4),%rax\n  mov    (%rax),%edx\n  mov    %edx,(%rdi,%rsi,4)\n  mov    %ecx,(%rax)\n  jmp    L4\nL6:\n  mov    0x0(%rbp,%rdx,4),%eax\n  mov    %eax,(%r12,%rdx,4)\nL7:\n  add    $0x1,%rdx\n  cmp    %rdx,%rbx\n  je     L0\nL8:\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,2),%eax\n  cmp    %edx,%eax\n  jne    L6\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cltq\n  mov    (%rdi,%rax,4),%eax\n  mov    %eax,(%r12,%rdx,4)\n  jmp    L7\nL0:\n  call   <free@plt>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL2:\n  mov    %ebx,%ebx\n  mov    $0x0,%edx\n  jmp    L8",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4692
            },
            "L1": {
                "label": "L1",
                "addr": 4488
            },
            "L2": {
                "label": "L2",
                "addr": 4708
            },
            "L3": {
                "label": "L3",
                "addr": 4546
            },
            "L4": {
                "label": "L4",
                "addr": 4533
            },
            "L5": {
                "label": "L5",
                "addr": 4570
            },
            "L6": {
                "label": "L6",
                "addr": 4615
            },
            "L7": {
                "label": "L7",
                "addr": 4623
            },
            "L8": {
                "label": "L8",
                "addr": 4632
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 33,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  movslq %esi,%r12\n  push   %rbp\n  mov    %r12d,%eax\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  imul   $0x55555556,%r12,%rdi\n  sar    $0x1f,%eax\n  shr    $0x20,%rdi\n  sub    %eax,%edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    1250 <func0+0x110>\n  mov    %r12,%r13\n  xor    %edx,%edx\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx,%rdx,4),%ecx\n  mov    %rax,%r9\n  add    $0x3,%rdx\n  mov    %eax,%r11d\n  mov    %ecx,(%rdi,%rax,4)\n  lea    0x1(%r9),%rax\n  cmp    %edx,%r13d\n  jg     1190 <func0+0x50>\n  test   %r11d,%r11d\n  je     120b <func0+0xcb>\n  lea    -0x1(%r11),%r13d\n  xor    %esi,%esi\n  nopl   0x0(%rax)\n  mov    %esi,%edx\n  mov    %esi,%r14d\n  lea    0x1(%rsi),%r10\n  cmp    %r11d,%esi\n  jge    1203 <func0+0xc3>\n  mov    %r13d,%ecx\n  mov    %r10,%rax\n  sub    %esi,%ecx\n  lea    0x2(%rsi,%rcx,1),%r8\n  nopl   0x0(%rax,%rax,1)\n  movslq %edx,%rcx\n  mov    (%rdi,%rcx,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  jne    11d8 <func0+0x98>\n  cmp    %edx,%r14d\n  je     1203 <func0+0xc3>\n  movslq %edx,%rdx\n  mov    (%rdi,%rsi,4),%ecx\n  lea    (%rdi,%rdx,4),%rax\n  mov    (%rax),%edx\n  mov    %edx,(%rdi,%rsi,4)\n  mov    %ecx,(%rax)\n  mov    %r10,%rsi\n  cmp    %r9,%r10\n  jne    11b8 <func0+0x78>\n  xor    %eax,%eax\n  mov    $0xaaaaaaab,%ecx\n  jmp    1232 <func0+0xf2>\n  nopl   0x0(%rax)\n  mov    %eax,%edx\n  imul   %rcx,%rdx\n  shr    $0x21,%rdx\n  mov    (%rdi,%rdx,4),%edx\n  mov    %edx,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r12\n  je     1250 <func0+0x110>\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  jbe    1218 <func0+0xd8>\n  mov    (%rbx,%rax,4),%edx\n  mov    %edx,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r12\n  jne    1232 <func0+0xf2>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1060 <free@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  movslq %esi,%r12\n  push   %rbp\n  mov    %r12d,%eax\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  imul   $0x55555556,%r12,%rdi\n  sar    $0x1f,%eax\n  shr    $0x20,%rdi\n  sub    %eax,%edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    L0\n  mov    %r12,%r13\n  xor    %edx,%edx\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    (%rbx,%rdx,4),%ecx\n  mov    %rax,%r9\n  add    $0x3,%rdx\n  mov    %eax,%r11d\n  mov    %ecx,(%rdi,%rax,4)\n  lea    0x1(%r9),%rax\n  cmp    %edx,%r13d\n  jg     L1\n  test   %r11d,%r11d\n  je     L2\n  lea    -0x1(%r11),%r13d\n  xor    %esi,%esi\n  nopl   0x0(%rax)\nL5:\n  mov    %esi,%edx\n  mov    %esi,%r14d\n  lea    0x1(%rsi),%r10\n  cmp    %r11d,%esi\n  jge    L3\n  mov    %r13d,%ecx\n  mov    %r10,%rax\n  sub    %esi,%ecx\n  lea    0x2(%rsi,%rcx,1),%r8\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movslq %edx,%rcx\n  mov    (%rdi,%rcx,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  jne    L4\n  cmp    %edx,%r14d\n  je     L3\n  movslq %edx,%rdx\n  mov    (%rdi,%rsi,4),%ecx\n  lea    (%rdi,%rdx,4),%rax\n  mov    (%rax),%edx\n  mov    %edx,(%rdi,%rsi,4)\n  mov    %ecx,(%rax)\nL3:\n  mov    %r10,%rsi\n  cmp    %r9,%r10\n  jne    L5\nL2:\n  xor    %eax,%eax\n  mov    $0xaaaaaaab,%ecx\n  jmp    L6\n  nopl   0x0(%rax)\nL7:\n  mov    %eax,%edx\n  imul   %rcx,%rdx\n  shr    $0x21,%rdx\n  mov    (%rdi,%rdx,4),%edx\n  mov    %edx,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r12\n  je     L0\nL6:\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  jbe    L7\n  mov    (%rbx,%rax,4),%edx\n  mov    %edx,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r12\n  jne    L6\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1060 <free@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4688
            },
            "L1": {
                "label": "L1",
                "addr": 4496
            },
            "L2": {
                "label": "L2",
                "addr": 4619
            },
            "L3": {
                "label": "L3",
                "addr": 4611
            },
            "L4": {
                "label": "L4",
                "addr": 4568
            },
            "L5": {
                "label": "L5",
                "addr": 4536
            },
            "L6": {
                "label": "L6",
                "addr": 4658
            },
            "L7": {
                "label": "L7",
                "addr": 4632
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 33,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *l, int size, int *out) {\n    int *third = malloc((size / 3 + 1) * sizeof(int));\n    int i, k = 0, third_size = 0;\n\n    for (i = 0; i * 3 < size; i++) {\n        third[i] = l[i * 3];\n        third_size++;\n    }\n\n    for (i = 0; i < third_size - 1; i++) {\n        int min_idx = i;\n        for (k = i + 1; k < third_size; k++) {\n            if (third[k] < third[min_idx])\n                min_idx = k;\n        }\n        if (min_idx != i) {\n            int temp = third[i];\n            third[i] = third[min_idx];\n            third[min_idx] = temp;\n        }\n    }\n\n    for (i = 0; i < size; i++) {\n        if (i % 3 == 0) {\n            out[i] = third[i / 3];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(third);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 2, 3};\n    int result1[3];\n    func0(test1, 3, result1);\n    assert(issame(result1, result1, 3));\n\n    int test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    int result2[11];\n    func0(test2, 11, result2);\n    assert(issame(result2, result2, 11));\n\n    int test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    int result3[10];\n    func0(test3, 10, result3);\n    assert(issame(result3, result3, 10));\n\n    int test4[] = {5, 6, 3, 4, 8, 9, 2};\n    int correct4[] = {2, 6, 3, 4, 8, 9, 5};\n    int result4[7];\n    func0(test4, 7, result4);\n    assert(issame(result4, correct4, 7));\n\n    int test5[] = {5, 8, 3, 4, 6, 9, 2};\n    int correct5[] = {2, 8, 3, 4, 6, 9, 5};\n    int result5[7];\n    func0(test5, 7, result5);\n    assert(issame(result5, correct5, 7));\n\n    int test6[] = {5, 6, 9, 4, 8, 3, 2};\n    int correct6[] = {2, 6, 9, 4, 8, 3, 5};\n    int result6[7];\n    func0(test6, 7, result6);\n    assert(issame(result6, correct6, 7));\n\n    int test7[] = {5, 6, 3, 4, 8, 9, 2, 1};\n    int correct7[] = {2, 6, 3, 4, 8, 9, 5, 1};\n    int result7[8];\n    func0(test7, 8, result7);\n    assert(issame(result7, correct7, 8));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  mov    %r13d,%eax\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  imul   $0x55555556,%r13,%rdi\n  sar    $0x1f,%eax\n  push   %rbx\n  shr    $0x20,%rdi\n  sub    %eax,%edi\n  sub    $0x8,%rsp\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%r10\n  test   %r13d,%r13d\n  jle    1319 <func0+0x1d9>\n  lea    -0x1(%r13),%esi\n  mov    $0xaaaaaaab,%edx\n  mov    %r13,%rbx\n  mov    %rsi,%rax\n  imul   %rdx,%rsi\n  shr    $0x21,%rsi\n  add    $0x1,%esi\n  cmp    $0x8,%eax\n  jbe    1358 <func0+0x218>\n  mov    %esi,%ecx\n  movdqa 0xe4a(%rip),%xmm2        # 2000 <_fini+0xc94>\n  mov    %rbp,%rax\n  mov    %r10,%rdx\n  shr    $0x2,%ecx\n  movdqa 0xe49(%rip),%xmm4        # 2010 <_fini+0xca4>\n  shl    $0x4,%rcx\n  add    %r10,%rcx\n  xchg   %ax,%ax\n  movd   (%rax),%xmm0\n  add    $0x10,%rdx\n  movdqa %xmm2,%xmm3\n  add    $0x30,%rax\n  movd   -0x18(%rax),%xmm1\n  movd   -0xc(%rax),%xmm5\n  paddd  %xmm4,%xmm2\n  movd   -0x24(%rax),%xmm6\n  punpckldq %xmm5,%xmm1\n  punpckldq %xmm6,%xmm0\n  punpcklqdq %xmm1,%xmm0\n  movups %xmm0,-0x10(%rdx)\n  cmp    %rcx,%rdx\n  jne    11d0 <func0+0x90>\n  mov    %esi,%eax\n  pshufd $0xff,%xmm3,%xmm3\n  and    $0xfffffffc,%eax\n  movd   %xmm3,%r8d\n  lea    (%rax,%rax,2),%edx\n  cmp    %eax,%esi\n  je     1346 <func0+0x206>\n  movslq %edx,%rdx\n  movslq %eax,%rcx\n  mov    0x0(%rbp,%rdx,4),%edx\n  lea    0x0(,%rcx,4),%rsi\n  mov    %edx,(%r10,%rcx,4)\n  lea    0x1(%rax),%ecx\n  lea    (%rcx,%rcx,2),%edx\n  cmp    %edx,%ebx\n  jle    1343 <func0+0x203>\n  movslq %edx,%rdi\n  add    $0x3,%edx\n  lea    0x2(%rax),%r8d\n  lea    0x0(,%rdi,4),%r9\n  mov    0x0(%rbp,%rdi,4),%edi\n  mov    %edi,0x4(%r10,%rsi,1)\n  cmp    %ebx,%edx\n  jge    1361 <func0+0x221>\n  mov    0xc(%rbp,%r9,1),%eax\n  mov    %eax,0x8(%r10,%rsi,1)\n  lea    0x4(%r10),%rbx\n  xor    %r11d,%r11d\n  nopw   0x0(%rax,%rax,1)\n  mov    -0x4(%rbx),%r15d\n  mov    %r11d,%r14d\n  add    $0x1,%r11d\n  mov    %rbx,%rax\n  mov    %r14d,%r9d\n  mov    %r11d,%edx\n  mov    %r15d,%esi\n  jmp    12b5 <func0+0x175>\n  nopl   0x0(%rax)\n  movslq %r9d,%rcx\n  add    $0x4,%rax\n  lea    (%r10,%rcx,4),%rdi\n  lea    0x1(%rdx),%ecx\n  cmp    %r8d,%edx\n  jge    12cf <func0+0x18f>\n  mov    %ecx,%edx\n  mov    (%rax),%ecx\n  mov    %rax,%rdi\n  cmp    %esi,%ecx\n  jge    12a0 <func0+0x160>\n  mov    %ecx,%esi\n  mov    %edx,%r9d\n  lea    0x1(%rdx),%ecx\n  add    $0x4,%rax\n  cmp    %r8d,%edx\n  jl     12b3 <func0+0x173>\n  cmp    %r14d,%r9d\n  je     12da <func0+0x19a>\n  mov    %esi,-0x4(%rbx)\n  mov    %r15d,(%rdi)\n  add    $0x4,%rbx\n  cmp    %r8d,%r11d\n  jne    1280 <func0+0x140>\n  xor    %eax,%eax\n  mov    $0xaaaaaaab,%ecx\n  nopw   0x0(%rax,%rax,1)\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  ja     1330 <func0+0x1f0>\n  mov    %eax,%edx\n  imul   %rcx,%rdx\n  shr    $0x21,%rdx\n  mov    (%r10,%rdx,4),%edx\n  mov    %edx,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %r13,%rax\n  jne    12f0 <func0+0x1b0>\n  add    $0x8,%rsp\n  mov    %r10,%rdi\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  jmp    1060 <free@plt>\n  nop\n  mov    0x0(%rbp,%rax,4),%edx\n  mov    %edx,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r13\n  jne    12f0 <func0+0x1b0>\n  jmp    1319 <func0+0x1d9>\n  mov    %eax,%r8d\n  test   %r8d,%r8d\n  jg     1273 <func0+0x133>\n  jmp    12e3 <func0+0x1a3>\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    1222 <func0+0xe2>\n  mov    %ecx,%r8d\n  jmp    1273 <func0+0x133>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  movslq %esi,%r13\n  push   %r12\n  mov    %r13d,%eax\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  imul   $0x55555556,%r13,%rdi\n  sar    $0x1f,%eax\n  push   %rbx\n  shr    $0x20,%rdi\n  sub    %eax,%edi\n  sub    $0x8,%rsp\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%esi\n  mov    $0xaaaaaaab,%edx\n  mov    %r13,%rbx\n  mov    %rsi,%rax\n  imul   %rdx,%rsi\n  shr    $0x21,%rsi\n  add    $0x1,%esi\n  cmp    $0x8,%eax\n  jbe    L1\n  mov    %esi,%ecx\n  movdqa D0(%rip),%xmm2\n  mov    %rbp,%rax\n  mov    %r10,%rdx\n  shr    $0x2,%ecx\n  movdqa D1(%rip),%xmm4\n  shl    $0x4,%rcx\n  add    %r10,%rcx\n  xchg   %ax,%ax\nL2:\n  movd   (%rax),%xmm0\n  add    $0x10,%rdx\n  movdqa %xmm2,%xmm3\n  add    $0x30,%rax\n  movd   -0x18(%rax),%xmm1\n  movd   -0xc(%rax),%xmm5\n  paddd  %xmm4,%xmm2\n  movd   -0x24(%rax),%xmm6\n  punpckldq %xmm5,%xmm1\n  punpckldq %xmm6,%xmm0\n  punpcklqdq %xmm1,%xmm0\n  movups %xmm0,-0x10(%rdx)\n  cmp    %rcx,%rdx\n  jne    L2\n  mov    %esi,%eax\n  pshufd $0xff,%xmm3,%xmm3\n  and    $0xfffffffc,%eax\n  movd   %xmm3,%r8d\n  lea    (%rax,%rax,2),%edx\n  cmp    %eax,%esi\n  je     L3\nL16:\n  movslq %edx,%rdx\n  movslq %eax,%rcx\n  mov    0x0(%rbp,%rdx,4),%edx\n  lea    0x0(,%rcx,4),%rsi\n  mov    %edx,(%r10,%rcx,4)\n  lea    0x1(%rax),%ecx\n  lea    (%rcx,%rcx,2),%edx\n  cmp    %edx,%ebx\n  jle    L4\n  movslq %edx,%rdi\n  add    $0x3,%edx\n  lea    0x2(%rax),%r8d\n  lea    0x0(,%rdi,4),%r9\n  mov    0x0(%rbp,%rdi,4),%edi\n  mov    %edi,0x4(%r10,%rsi,1)\n  cmp    %ebx,%edx\n  jge    L5\n  mov    0xc(%rbp,%r9,1),%eax\n  mov    %eax,0x8(%r10,%rsi,1)\nL14:\n  lea    0x4(%r10),%rbx\n  xor    %r11d,%r11d\n  nopw   0x0(%rax,%rax,1)\nL11:\n  mov    -0x4(%rbx),%r15d\n  mov    %r11d,%r14d\n  add    $0x1,%r11d\n  mov    %rbx,%rax\n  mov    %r14d,%r9d\n  mov    %r11d,%edx\n  mov    %r15d,%esi\n  jmp    L6\n  nopl   0x0(%rax)\nL8:\n  movslq %r9d,%rcx\n  add    $0x4,%rax\n  lea    (%r10,%rcx,4),%rdi\n  lea    0x1(%rdx),%ecx\n  cmp    %r8d,%edx\n  jge    L7\nL9:\n  mov    %ecx,%edx\nL6:\n  mov    (%rax),%ecx\n  mov    %rax,%rdi\n  cmp    %esi,%ecx\n  jge    L8\n  mov    %ecx,%esi\n  mov    %edx,%r9d\n  lea    0x1(%rdx),%ecx\n  add    $0x4,%rax\n  cmp    %r8d,%edx\n  jl     L9\nL7:\n  cmp    %r14d,%r9d\n  je     L10\n  mov    %esi,-0x4(%rbx)\n  mov    %r15d,(%rdi)\nL10:\n  add    $0x4,%rbx\n  cmp    %r8d,%r11d\n  jne    L11\nL15:\n  xor    %eax,%eax\n  mov    $0xaaaaaaab,%ecx\n  nopw   0x0(%rax,%rax,1)\nL13:\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  ja     L12\n  mov    %eax,%edx\n  imul   %rcx,%rdx\n  shr    $0x21,%rdx\n  mov    (%r10,%rdx,4),%edx\n  mov    %edx,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %r13,%rax\n  jne    L13\nL0:\n  add    $0x8,%rsp\n  mov    %r10,%rdi\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  jmp    1060 <free@plt>\n  nop\nL12:\n  mov    0x0(%rbp,%rax,4),%edx\n  mov    %edx,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r13\n  jne    L13\n  jmp    L0\nL4:\n  mov    %eax,%r8d\nL3:\n  test   %r8d,%r8d\n  jg     L14\n  jmp    L15\n  nopl   0x0(%rax)\nL1:\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    L16\nL5:\n  mov    %ecx,%r8d\n  jmp    L14",
        "num_missing": 2,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3658
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3657
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4889
            },
            "L1": {
                "label": "L1",
                "addr": 4952
            },
            "L2": {
                "label": "L2",
                "addr": 4560
            },
            "L3": {
                "label": "L3",
                "addr": 4934
            },
            "L4": {
                "label": "L4",
                "addr": 4931
            },
            "L5": {
                "label": "L5",
                "addr": 4961
            },
            "L6": {
                "label": "L6",
                "addr": 4789
            },
            "L7": {
                "label": "L7",
                "addr": 4815
            },
            "L8": {
                "label": "L8",
                "addr": 4768
            },
            "L9": {
                "label": "L9",
                "addr": 4787
            },
            "L10": {
                "label": "L10",
                "addr": 4826
            },
            "L11": {
                "label": "L11",
                "addr": 4736
            },
            "L12": {
                "label": "L12",
                "addr": 4912
            },
            "L13": {
                "label": "L13",
                "addr": 4848
            },
            "L14": {
                "label": "L14",
                "addr": 4723
            },
            "L15": {
                "label": "L15",
                "addr": 4835
            },
            "L16": {
                "label": "L16",
                "addr": 4642
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000000001000000020000000300000004000000040000000400000004000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        2,
                        0,
                        0,
                        0,
                        3,
                        0,
                        0,
                        0
                    ]
                },
                "0x2010": {
                    "type": "byte[16]",
                    "value": [
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 34,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11ea <func0+0xd1>\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11a5 <func0+0x8c>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    11a1 <func0+0x88>\n  movl   $0x1,-0x1c(%rbp)\n  jmp    11ad <func0+0x94>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     1168 <func0+0x4f>\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    11e6 <func0+0xcd>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1158 <func0+0x3f>\n  movl   $0x0,-0x14(%rbp)\n  jmp    12b3 <func0+0x19a>\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    12a3 <func0+0x18a>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    129f <func0+0x186>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     1210 <func0+0xf7>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     1202 <func0+0xe9>\n  mov    -0x38(%rbp),%rax\n  mov    -0x18(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL6:\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L1\nL4:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L2\n  movl   $0x1,-0x1c(%rbp)\n  jmp    L3\nL2:\n  addl   $0x1,-0x10(%rbp)\nL1:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     L4\nL3:\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    L5\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\nL5:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L6\n  movl   $0x0,-0x14(%rbp)\n  jmp    L7\nL11:\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    L8\nL10:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L9\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\nL9:\n  addl   $0x1,-0x10(%rbp)\nL8:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jl     L10\n  addl   $0x1,-0x14(%rbp)\nL7:\n  mov    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     L11\n  mov    -0x38(%rbp),%rax\n  mov    -0x18(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4586
            },
            "L1": {
                "label": "L1",
                "addr": 4517
            },
            "L2": {
                "label": "L2",
                "addr": 4513
            },
            "L3": {
                "label": "L3",
                "addr": 4525
            },
            "L4": {
                "label": "L4",
                "addr": 4456
            },
            "L5": {
                "label": "L5",
                "addr": 4582
            },
            "L6": {
                "label": "L6",
                "addr": 4440
            },
            "L7": {
                "label": "L7",
                "addr": 4787
            },
            "L8": {
                "label": "L8",
                "addr": 4771
            },
            "L9": {
                "label": "L9",
                "addr": 4767
            },
            "L10": {
                "label": "L10",
                "addr": 4624
            },
            "L11": {
                "label": "L11",
                "addr": 4610
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 34,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r10\n  test   %ebp,%ebp\n  jle    11b8 <func0+0x9f>\n  mov    %r12,%rsi\n  lea    -0x1(%rbp),%eax\n  lea    0x4(%r12,%rax,4),%rdi\n  mov    $0x0,%r9d\n  lea    0x4(%r10),%r8\n  jmp    11e3 <func0+0xca>\n  cmp    $0x1,%r9d\n  jle    11be <func0+0xa5>\n  lea    0x4(%r10),%rsi\n  lea    -0x2(%r9),%r11d\n  add    $0x2,%r11\n  mov    $0x1,%r8d\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbp\n  jmp    119e <func0+0x85>\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     1191 <func0+0x78>\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    1178 <func0+0x5f>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  jmp    1178 <func0+0x5f>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r11,%r8\n  je     11be <func0+0xa5>\n  cmp    %r8d,%r9d\n  jle    1191 <func0+0x78>\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%rbp,%rax,4),%rdi\n  mov    %rsi,%rax\n  jmp    1181 <func0+0x68>\n  mov    $0x0,%r9d\n  mov    %r9d,(%rbx)\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  movslq %r9d,%rax\n  mov    (%rsi),%edx\n  mov    %edx,(%r10,%rax,4)\n  lea    0x1(%r9),%r9d\n  add    $0x4,%rsi\n  cmp    %rdi,%rsi\n  je     1156 <func0+0x3d>\n  test   %r9d,%r9d\n  jle    11c9 <func0+0xb0>\n  mov    (%rsi),%edx\n  mov    %r10,%rax\n  lea    -0x1(%r9),%ecx\n  lea    (%r8,%rcx,4),%rcx\n  cmp    (%rax),%edx\n  je     11d6 <func0+0xbd>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    11f5 <func0+0xdc>\n  jmp    11c9 <func0+0xb0>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  mov    %rdx,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  test   %ebp,%ebp\n  jle    L0\n  mov    %r12,%rsi\n  lea    -0x1(%rbp),%eax\n  lea    0x4(%r12,%rax,4),%rdi\n  mov    $0x0,%r9d\n  lea    0x4(%r10),%r8\n  jmp    L1\nL7:\n  cmp    $0x1,%r9d\n  jle    L2\n  lea    0x4(%r10),%rsi\n  lea    -0x2(%r9),%r11d\n  add    $0x2,%r11\n  mov    $0x1,%r8d\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbp\n  jmp    L3\nL5:\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     L4\nL6:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L5\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  jmp    L5\nL4:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r11,%r8\n  je     L2\nL3:\n  cmp    %r8d,%r9d\n  jle    L4\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%rbp,%rax,4),%rdi\n  mov    %rsi,%rax\n  jmp    L6\nL0:\n  mov    $0x0,%r9d\nL2:\n  mov    %r9d,(%rbx)\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL8:\n  movslq %r9d,%rax\n  mov    (%rsi),%edx\n  mov    %edx,(%r10,%rax,4)\n  lea    0x1(%r9),%r9d\nL9:\n  add    $0x4,%rsi\n  cmp    %rdi,%rsi\n  je     L7\nL1:\n  test   %r9d,%r9d\n  jle    L8\n  mov    (%rsi),%edx\n  mov    %r10,%rax\n  lea    -0x1(%r9),%ecx\n  lea    (%r8,%rcx,4),%rcx\nL10:\n  cmp    (%rax),%edx\n  je     L9\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L10\n  jmp    L8",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4536
            },
            "L1": {
                "label": "L1",
                "addr": 4579
            },
            "L2": {
                "label": "L2",
                "addr": 4542
            },
            "L3": {
                "label": "L3",
                "addr": 4510
            },
            "L4": {
                "label": "L4",
                "addr": 4497
            },
            "L5": {
                "label": "L5",
                "addr": 4472
            },
            "L6": {
                "label": "L6",
                "addr": 4481
            },
            "L7": {
                "label": "L7",
                "addr": 4438
            },
            "L8": {
                "label": "L8",
                "addr": 4553
            },
            "L9": {
                "label": "L9",
                "addr": 4566
            },
            "L10": {
                "label": "L10",
                "addr": 4597
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 34,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r10\n  test   %r12d,%r12d\n  jle    122d <func0+0x10d>\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rdi\n  lea    0x4(%r10),%r8\n  xor    %r9d,%r9d\n  lea    0x4(%rbx,%rax,4),%rsi\n  nopl   (%rax)\n  mov    (%rdi),%edx\n  test   %r9d,%r9d\n  je     1210 <func0+0xf0>\n  lea    -0x1(%r9),%ecx\n  mov    %r10,%rax\n  lea    (%r8,%rcx,4),%rcx\n  jmp    118d <func0+0x6d>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     1210 <func0+0xf0>\n  cmp    %edx,(%rax)\n  jne    1180 <func0+0x60>\n  add    $0x4,%rdi\n  cmp    %rsi,%rdi\n  jne    1160 <func0+0x40>\n  cmp    $0x1,%r9d\n  je     1204 <func0+0xe4>\n  lea    -0x2(%r9),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r8d\n  add    $0x2,%r11\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbx\n  nopw   0x0(%rax,%rax,1)\n  cmp    %r8d,%r9d\n  jle    11f7 <func0+0xd7>\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rbx,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopw   0x0(%rax,%rax,1)\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11ee <func0+0xce>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    11e0 <func0+0xc0>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r11,%r8\n  jne    11c0 <func0+0xa0>\n  pop    %rbx\n  mov    %r9d,0x0(%rbp)\n  mov    %r10,%rax\n  pop    %rbp\n  pop    %r12\n  ret\n  movslq %r9d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r9d\n  mov    %edx,(%r10,%rax,4)\n  cmp    %rsi,%rdi\n  jne    1160 <func0+0x40>\n  jmp    119a <func0+0x7a>\n  xor    %r9d,%r9d\n  pop    %rbx\n  mov    %r10,%rax\n  mov    %r9d,0x0(%rbp)\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rdi\n  lea    0x4(%r10),%r8\n  xor    %r9d,%r9d\n  lea    0x4(%rbx,%rax,4),%rsi\n  nopl   (%rax)\nL4:\n  mov    (%rdi),%edx\n  test   %r9d,%r9d\n  je     L1\n  lea    -0x1(%r9),%ecx\n  mov    %r10,%rax\n  lea    (%r8,%rcx,4),%rcx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\n  add    $0x4,%rdi\n  cmp    %rsi,%rdi\n  jne    L4\nL10:\n  cmp    $0x1,%r9d\n  je     L5\n  lea    -0x2(%r9),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r8d\n  add    $0x2,%r11\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbx\n  nopw   0x0(%rax,%rax,1)\nL9:\n  cmp    %r8d,%r9d\n  jle    L6\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rbx,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L7\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\nL7:\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    L8\nL6:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r11,%r8\n  jne    L9\nL5:\n  pop    %rbx\n  mov    %r9d,0x0(%rbp)\n  mov    %r10,%rax\n  pop    %rbp\n  pop    %r12\n  ret\nL1:\n  movslq %r9d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r9d\n  mov    %edx,(%r10,%rax,4)\n  cmp    %rsi,%rdi\n  jne    L4\n  jmp    L10\nL0:\n  xor    %r9d,%r9d\n  pop    %rbx\n  mov    %r10,%rax\n  mov    %r9d,0x0(%rbp)\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4653
            },
            "L1": {
                "label": "L1",
                "addr": 4624
            },
            "L2": {
                "label": "L2",
                "addr": 4493
            },
            "L3": {
                "label": "L3",
                "addr": 4480
            },
            "L4": {
                "label": "L4",
                "addr": 4448
            },
            "L5": {
                "label": "L5",
                "addr": 4612
            },
            "L6": {
                "label": "L6",
                "addr": 4599
            },
            "L7": {
                "label": "L7",
                "addr": 4590
            },
            "L8": {
                "label": "L8",
                "addr": 4576
            },
            "L9": {
                "label": "L9",
                "addr": 4544
            },
            "L10": {
                "label": "L10",
                "addr": 4506
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 34,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l, int size, int *out_size) {\n    int *out = malloc(size * sizeof(int));\n    int found, out_count = 0, i, j;\n    for (i = 0; i < size; i++) {\n        found = 0;\n        for (j = 0; j < out_count; j++) {\n            if (l[i] == out[j]) {\n                found = 1;\n                break;\n            }\n        }\n        if (!found) {\n            out[out_count++] = l[i];\n        }\n    }\n\n    for (i = 0; i < out_count - 1; i++) {\n        for (j = i + 1; j < out_count; j++) {\n            if (out[i] > out[j]) {\n                int temp = out[i];\n                out[i] = out[j];\n                out[j] = temp;\n            }\n        }\n    }\n\n    *out_size = out_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    int test_array[] = {5, 3, 5, 2, 3, 3, 9, 0, 123};\n    int expected_array[] = {0, 2, 3, 5, 9, 123};\n    int unique_size;\n    int *unique_array = func0(test_array, sizeof(test_array) / sizeof(test_array[0]), &unique_size);\n\n    assert(unique_size == sizeof(expected_array) / sizeof(expected_array[0]));\n    for (int i = 0; i < unique_size; i++) {\n        assert(unique_array[i] == expected_array[i]);\n    }\n\n    free(unique_array);\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r10\n  test   %r12d,%r12d\n  jle    122d <func0+0x10d>\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rdi\n  lea    0x4(%r10),%r8\n  xor    %r9d,%r9d\n  lea    0x4(%rbx,%rax,4),%rsi\n  nopl   (%rax)\n  mov    (%rdi),%edx\n  test   %r9d,%r9d\n  je     1210 <func0+0xf0>\n  lea    -0x1(%r9),%ecx\n  mov    %r10,%rax\n  lea    (%r8,%rcx,4),%rcx\n  jmp    118d <func0+0x6d>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     1210 <func0+0xf0>\n  cmp    %edx,(%rax)\n  jne    1180 <func0+0x60>\n  add    $0x4,%rdi\n  cmp    %rsi,%rdi\n  jne    1160 <func0+0x40>\n  cmp    $0x1,%r9d\n  je     1204 <func0+0xe4>\n  lea    -0x2(%r9),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r8d\n  add    $0x2,%r11\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbx\n  nopw   0x0(%rax,%rax,1)\n  cmp    %r8d,%r9d\n  jle    11f7 <func0+0xd7>\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rbx,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopw   0x0(%rax,%rax,1)\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11ee <func0+0xce>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    11e0 <func0+0xc0>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r8,%r11\n  jne    11c0 <func0+0xa0>\n  pop    %rbx\n  mov    %r9d,0x0(%rbp)\n  mov    %r10,%rax\n  pop    %rbp\n  pop    %r12\n  ret\n  movslq %r9d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r9d\n  mov    %edx,(%r10,%rax,4)\n  cmp    %rsi,%rdi\n  jne    1160 <func0+0x40>\n  jmp    119a <func0+0x7a>\n  xor    %r9d,%r9d\n  pop    %rbx\n  mov    %r10,%rax\n  mov    %r9d,0x0(%rbp)\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rdi\n  lea    0x4(%r10),%r8\n  xor    %r9d,%r9d\n  lea    0x4(%rbx,%rax,4),%rsi\n  nopl   (%rax)\nL4:\n  mov    (%rdi),%edx\n  test   %r9d,%r9d\n  je     L1\n  lea    -0x1(%r9),%ecx\n  mov    %r10,%rax\n  lea    (%r8,%rcx,4),%rcx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\n  add    $0x4,%rdi\n  cmp    %rsi,%rdi\n  jne    L4\nL10:\n  cmp    $0x1,%r9d\n  je     L5\n  lea    -0x2(%r9),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r8d\n  add    $0x2,%r11\n  lea    -0x1(%r9),%r12d\n  lea    0x8(%r10),%rbx\n  nopw   0x0(%rax,%rax,1)\nL9:\n  cmp    %r8d,%r9d\n  jle    L6\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%rbx,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L7\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\nL7:\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    L8\nL6:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r8,%r11\n  jne    L9\nL5:\n  pop    %rbx\n  mov    %r9d,0x0(%rbp)\n  mov    %r10,%rax\n  pop    %rbp\n  pop    %r12\n  ret\nL1:\n  movslq %r9d,%rax\n  add    $0x4,%rdi\n  add    $0x1,%r9d\n  mov    %edx,(%r10,%rax,4)\n  cmp    %rsi,%rdi\n  jne    L4\n  jmp    L10\nL0:\n  xor    %r9d,%r9d\n  pop    %rbx\n  mov    %r10,%rax\n  mov    %r9d,0x0(%rbp)\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4653
            },
            "L1": {
                "label": "L1",
                "addr": 4624
            },
            "L2": {
                "label": "L2",
                "addr": 4493
            },
            "L3": {
                "label": "L3",
                "addr": 4480
            },
            "L4": {
                "label": "L4",
                "addr": 4448
            },
            "L5": {
                "label": "L5",
                "addr": 4612
            },
            "L6": {
                "label": "L6",
                "addr": 4599
            },
            "L7": {
                "label": "L7",
                "addr": 4590
            },
            "L8": {
                "label": "L8",
                "addr": 4576
            },
            "L9": {
                "label": "L9",
                "addr": 4544
            },
            "L10": {
                "label": "L10",
                "addr": 4506
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 35,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movss  0xef0(%rip),%xmm0        # 2000 <_fini+0xe94>\n  movss  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    115d <func0+0x64>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss -0x8(%rbp),%xmm0\n  jbe    1159 <func0+0x60>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111e <func0+0x25>\n  movss  -0x8(%rbp),%xmm0\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movss  D0(%rip),%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss -0x8(%rbp),%xmm0\n  jbe    L1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  movss  -0x8(%rbp),%xmm0\n  pop    %rbp\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3824
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4445
            },
            "L1": {
                "label": "L1",
                "addr": 4441
            },
            "L2": {
                "label": "L2",
                "addr": 4382
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00401cc6",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        64,
                        28,
                        198
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 35,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1129 <func0+0x30>\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\n  movss  0xeec(%rip),%xmm0        # 2000 <_fini+0xecc>\n  movss  (%rax),%xmm1\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    1114 <func0+0x1b>\n  ret\n  movss  0xecf(%rip),%xmm0        # 2000 <_fini+0xecc>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\n  movss  D0(%rip),%xmm0\nL1:\n  movss  (%rax),%xmm1\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    L1\n  ret\nL0:\n  movss  D0(%rip),%xmm0\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3820,
                    3791
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4393
            },
            "L1": {
                "label": "L1",
                "addr": 4372
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00401cc6",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        64,
                        28,
                        198
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 35,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1138 <func0+0x38>\n  lea    -0x1(%rsi),%eax\n  movss  0xeed(%rip),%xmm0        # 2000 <_fini+0xebc>\n  lea    0x4(%rdi,%rax,4),%rax\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  cmp    %rax,%rdi\n  jne    1120 <func0+0x20>\n  ret\n  nopl   (%rax)\n  movss  0xec0(%rip),%xmm0        # 2000 <_fini+0xebc>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movss  D0(%rip),%xmm0\n  lea    0x4(%rdi,%rax,4),%rax\n  nopl   0x0(%rax,%rax,1)\nL1:\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  cmp    %rax,%rdi\n  jne    L1\n  ret\n  nopl   (%rax)\nL0:\n  movss  D0(%rip),%xmm0\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3821,
                    3776
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00401cc6",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        64,
                        28,
                        198
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 35,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nfloat func0(float *l, int size) {\n    float max = -10000;\n    for (int i = 0; i < size; i++)\n        if (max < l[i]) max = l[i];\n    return max;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {1, 2, 3};\n    assert(fabs(func0(list1, 3) - 3) < 1e-4);\n\n    float list2[] = {5, 3, -5, 2, -3, 3, 9, 0, 124, 1, -10};\n    assert(fabs(func0(list2, 11) - 124) < 1e-4);\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1138 <func0+0x38>\n  lea    -0x1(%rsi),%eax\n  movss  0xeed(%rip),%xmm0        # 2000 <_fini+0xebc>\n  lea    0x4(%rdi,%rax,4),%rax\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  cmp    %rax,%rdi\n  jne    1120 <func0+0x20>\n  ret\n  nopl   (%rax)\n  movss  0xec0(%rip),%xmm0        # 2000 <_fini+0xebc>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movss  D0(%rip),%xmm0\n  lea    0x4(%rdi,%rax,4),%rax\n  nopl   0x0(%rax,%rax,1)\nL1:\n  movss  (%rdi),%xmm1\n  add    $0x4,%rdi\n  maxss  %xmm0,%xmm1\n  movaps %xmm1,%xmm0\n  cmp    %rax,%rdi\n  jne    L1\n  ret\n  nopl   (%rax)\nL0:\n  movss  D0(%rip),%xmm0\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3821,
                    3776
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00401cc6",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        64,
                        28,
                        198
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 36,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    11db <func0+0xe2>\n  mov    -0x8(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x2e8ba2e9,%rax,%rax\n  shr    $0x20,%rax\n  sar    %eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  test   %edx,%edx\n  je     1176 <func0+0x7d>\n  mov    -0x8(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  test   %edx,%edx\n  jne    11d7 <func0+0xde>\n  mov    -0x8(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    11d1 <func0+0xd8>\n  mov    -0x4(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  cmp    $0x7,%edx\n  jne    11b1 <func0+0xb8>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x0,-0x4(%rbp)\n  jg     117e <func0+0x85>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     1117 <func0+0x1e>\n  mov    -0xc(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL6:\n  mov    -0x8(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x2e8ba2e9,%rax,%rax\n  shr    $0x20,%rax\n  sar    %eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  test   %edx,%edx\n  je     L1\n  mov    -0x8(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  test   %edx,%edx\n  jne    L2\nL1:\n  mov    -0x8(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    L3\nL5:\n  mov    -0x4(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  cmp    $0x7,%edx\n  jne    L4\n  addl   $0x1,-0xc(%rbp)\nL4:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x4(%rbp)\nL3:\n  cmpl   $0x0,-0x4(%rbp)\n  jg     L5\nL2:\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L6\n  mov    -0xc(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4571
            },
            "L1": {
                "label": "L1",
                "addr": 4470
            },
            "L2": {
                "label": "L2",
                "addr": 4567
            },
            "L3": {
                "label": "L3",
                "addr": 4561
            },
            "L4": {
                "label": "L4",
                "addr": 4529
            },
            "L5": {
                "label": "L5",
                "addr": 4478
            },
            "L6": {
                "label": "L6",
                "addr": 4375
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 36,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    11af <func0+0xb6>\n  mov    $0x0,%ecx\n  mov    $0x0,%esi\n  jmp    1166 <func0+0x6d>\n  mov    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%r8d\n  sar    $0x1f,%r8d\n  sub    %r8d,%eax\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  mov    %edx,%r8d\n  sub    %eax,%r8d\n  cmp    $0x7,%r8d\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%esi\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%r8d\n  sar    $0x1f,%r8d\n  sub    %r8d,%eax\n  cmp    $0x9,%edx\n  jg     1111 <func0+0x18>\n  add    $0x1,%ecx\n  cmp    %ecx,%edi\n  je     11b4 <func0+0xbb>\n  movslq %ecx,%rax\n  imul   $0x2e8ba2e9,%rax,%rax\n  sar    $0x21,%rax\n  mov    %ecx,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%edx\n  lea    (%rax,%rdx,2),%eax\n  cmp    %eax,%ecx\n  je     11a4 <func0+0xab>\n  movslq %ecx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x22,%rax\n  mov    %ecx,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,2),%edx\n  lea    (%rax,%rdx,4),%eax\n  cmp    %eax,%ecx\n  jne    115f <func0+0x66>\n  test   %ecx,%ecx\n  jle    115f <func0+0x66>\n  mov    %ecx,%edx\n  jmp    1113 <func0+0x1a>\n  mov    $0x0,%esi\n  mov    %esi,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  mov    $0x0,%ecx\n  mov    $0x0,%esi\n  jmp    L1\nL2:\n  mov    %eax,%edx\nL6:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%r8d\n  sar    $0x1f,%r8d\n  sub    %r8d,%eax\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  mov    %edx,%r8d\n  sub    %eax,%r8d\n  cmp    $0x7,%r8d\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%esi\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%r8d\n  sar    $0x1f,%r8d\n  sub    %r8d,%eax\n  cmp    $0x9,%edx\n  jg     L2\nL5:\n  add    $0x1,%ecx\n  cmp    %ecx,%edi\n  je     L3\nL1:\n  movslq %ecx,%rax\n  imul   $0x2e8ba2e9,%rax,%rax\n  sar    $0x21,%rax\n  mov    %ecx,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%edx\n  lea    (%rax,%rdx,2),%eax\n  cmp    %eax,%ecx\n  je     L4\n  movslq %ecx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x22,%rax\n  mov    %ecx,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,2),%edx\n  lea    (%rax,%rdx,4),%eax\n  cmp    %eax,%ecx\n  jne    L5\nL4:\n  test   %ecx,%ecx\n  jle    L5\n  mov    %ecx,%edx\n  jmp    L6\nL0:\n  mov    $0x0,%esi\nL3:\n  mov    %esi,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4527
            },
            "L1": {
                "label": "L1",
                "addr": 4454
            },
            "L2": {
                "label": "L2",
                "addr": 4369
            },
            "L3": {
                "label": "L3",
                "addr": 4532
            },
            "L4": {
                "label": "L4",
                "addr": 4516
            },
            "L5": {
                "label": "L5",
                "addr": 4447
            },
            "L6": {
                "label": "L6",
                "addr": 4371
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 36,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    116e <func0+0x6e>\n  xor    %esi,%esi\n  xor    %r8d,%r8d\n  mov    $0xcccccccd,%r9d\n  jmp    112c <func0+0x2c>\n  nopl   (%rax)\n  imul   $0xc4ec4ec5,%esi,%eax\n  cmp    $0x13b13b13,%eax\n  jbe    1139 <func0+0x39>\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  je     116a <func0+0x6a>\n  imul   $0xba2e8ba3,%esi,%eax\n  cmp    $0x1745d174,%eax\n  ja     1118 <func0+0x18>\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     1125 <func0+0x25>\n  nop\n  mov    %edx,%eax\n  imul   %r9,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  cmp    $0x7,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%r8d\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    1140 <func0+0x40>\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  jne    112c <func0+0x2c>\n  mov    %r8d,%eax\n  ret\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %esi,%esi\n  xor    %r8d,%r8d\n  mov    $0xcccccccd,%r9d\n  jmp    L1\n  nopl   (%rax)\nL4:\n  imul   $0xc4ec4ec5,%esi,%eax\n  cmp    $0x13b13b13,%eax\n  jbe    L2\nL5:\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  je     L3\nL1:\n  imul   $0xba2e8ba3,%esi,%eax\n  cmp    $0x1745d174,%eax\n  ja     L4\nL2:\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     L5\n  nop\nL6:\n  mov    %edx,%eax\n  imul   %r9,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  cmp    $0x7,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%r8d\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    L6\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  jne    L1\nL3:\n  mov    %r8d,%eax\n  ret\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4462
            },
            "L1": {
                "label": "L1",
                "addr": 4396
            },
            "L2": {
                "label": "L2",
                "addr": 4409
            },
            "L3": {
                "label": "L3",
                "addr": 4458
            },
            "L4": {
                "label": "L4",
                "addr": 4376
            },
            "L5": {
                "label": "L5",
                "addr": 4389
            },
            "L6": {
                "label": "L6",
                "addr": 4416
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 36,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++)\n        if (i % 11 == 0 || i % 13 == 0) {\n            int q = i;\n            while (q > 0) {\n                if (q % 10 == 7) count += 1;\n                q = q / 10;\n            }\n        }\n    return count;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(50) == 0);\n    assert(func0(78) == 2);\n    assert(func0(79) == 3);\n    assert(func0(100) == 3);\n    assert(func0(200) == 6);\n    assert(func0(4000) == 192);\n    assert(func0(10000) == 639);\n    assert(func0(100000) == 8026);\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    116e <func0+0x6e>\n  xor    %esi,%esi\n  xor    %r8d,%r8d\n  mov    $0xcccccccd,%r9d\n  jmp    112c <func0+0x2c>\n  nopl   (%rax)\n  imul   $0xc4ec4ec5,%esi,%eax\n  cmp    $0x13b13b13,%eax\n  jbe    1139 <func0+0x39>\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  je     116a <func0+0x6a>\n  imul   $0xba2e8ba3,%esi,%eax\n  cmp    $0x1745d174,%eax\n  ja     1118 <func0+0x18>\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     1125 <func0+0x25>\n  nop\n  mov    %edx,%eax\n  imul   %r9,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  cmp    $0x7,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%r8d\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    1140 <func0+0x40>\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  jne    112c <func0+0x2c>\n  mov    %r8d,%eax\n  ret\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %esi,%esi\n  xor    %r8d,%r8d\n  mov    $0xcccccccd,%r9d\n  jmp    L1\n  nopl   (%rax)\nL4:\n  imul   $0xc4ec4ec5,%esi,%eax\n  cmp    $0x13b13b13,%eax\n  jbe    L2\nL5:\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  je     L3\nL1:\n  imul   $0xba2e8ba3,%esi,%eax\n  cmp    $0x1745d174,%eax\n  ja     L4\nL2:\n  mov    %esi,%edx\n  test   %esi,%esi\n  je     L5\n  nop\nL6:\n  mov    %edx,%eax\n  imul   %r9,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  cmp    $0x7,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%r8d\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    L6\n  add    $0x1,%esi\n  cmp    %esi,%edi\n  jne    L1\nL3:\n  mov    %r8d,%eax\n  ret\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4462
            },
            "L1": {
                "label": "L1",
                "addr": 4396
            },
            "L2": {
                "label": "L2",
                "addr": 4409
            },
            "L3": {
                "label": "L3",
                "addr": 4458
            },
            "L4": {
                "label": "L4",
                "addr": 4376
            },
            "L5": {
                "label": "L5",
                "addr": 4389
            },
            "L6": {
                "label": "L6",
                "addr": 4416
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 37,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    11bc <func0+0x83>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rcx),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x2,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1181 <func0+0x48>\n  movl   $0x0,-0x18(%rbp)\n  jmp    12a1 <func0+0x168>\n  movl   $0x0,-0x14(%rbp)\n  jmp    128b <func0+0x152>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1287 <func0+0x14e>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  -0xc(%rbp),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  sub    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     11dc <func0+0xa3>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x10(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     11d0 <func0+0x97>\n  movl   $0x0,-0x18(%rbp)\n  jmp    1332 <func0+0x1f9>\n  mov    -0x18(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    12fe <func0+0x1c5>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  jmp    132e <func0+0x1f5>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     12b9 <func0+0x180>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <free@plt>\n  nop\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    -0x2c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    L0\nL1:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rcx),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x2,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L1\n  movl   $0x0,-0x18(%rbp)\n  jmp    L2\nL6:\n  movl   $0x0,-0x14(%rbp)\n  jmp    L3\nL5:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L4\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0xc(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movss  -0xc(%rbp),%xmm0\n  movss  %xmm0,(%rax)\nL4:\n  addl   $0x1,-0x14(%rbp)\nL3:\n  mov    -0x10(%rbp),%eax\n  sub    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     L5\n  addl   $0x1,-0x18(%rbp)\nL2:\n  mov    -0x10(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     L6\n  movl   $0x0,-0x18(%rbp)\n  jmp    L7\nL10:\n  mov    -0x18(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L8\n  mov    -0x18(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  jmp    L9\nL8:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\nL9:\n  addl   $0x1,-0x18(%rbp)\nL7:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L10\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  nop\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4540
            },
            "L1": {
                "label": "L1",
                "addr": 4481
            },
            "L2": {
                "label": "L2",
                "addr": 4769
            },
            "L3": {
                "label": "L3",
                "addr": 4747
            },
            "L4": {
                "label": "L4",
                "addr": 4743
            },
            "L5": {
                "label": "L5",
                "addr": 4572
            },
            "L6": {
                "label": "L6",
                "addr": 4560
            },
            "L7": {
                "label": "L7",
                "addr": 4914
            },
            "L8": {
                "label": "L8",
                "addr": 4862
            },
            "L9": {
                "label": "L9",
                "addr": 4910
            },
            "L10": {
                "label": "L10",
                "addr": 4793
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 37,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  mov    %rdx,%r12\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    11fa <func0+0xc1>\n  mov    $0x0,%eax\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%rdi,%rax,2)\n  add    $0x2,%rax\n  cmp    %eax,%ebx\n  jg     1171 <func0+0x38>\n  lea    -0x1(%rbx),%ecx\n  shr    %ecx\n  je     1204 <func0+0xcb>\n  lea    0x4(%rdi),%rsi\n  jmp    11b8 <func0+0x7f>\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  je     11b3 <func0+0x7a>\n  movss  (%rax),%xmm0\n  movss  0x4(%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1191 <func0+0x58>\n  movss  %xmm1,(%rax)\n  movss  %xmm0,0x4(%rax)\n  jmp    1191 <func0+0x58>\n  sub    $0x1,%ecx\n  je     1204 <func0+0xcb>\n  test   %ecx,%ecx\n  jle    11b3 <func0+0x7a>\n  mov    %rdi,%rax\n  lea    -0x1(%rcx),%edx\n  lea    (%rsi,%rdx,4),%rdx\n  jmp    119a <func0+0x61>\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rbx,%rax\n  je     11fa <func0+0xc1>\n  test   $0x1,%al\n  jne    11c8 <func0+0x8f>\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %eax,%edx\n  sar    %edx\n  movslq %edx,%rdx\n  movss  (%rdi,%rdx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  jmp    11d4 <func0+0x9b>\n  call   1060 <free@plt>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  mov    %ebx,%ebx\n  mov    $0x0,%eax\n  jmp    11dd <func0+0xa4>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  mov    %rdx,%r12\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    L0\n  mov    $0x0,%eax\nL1:\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%rdi,%rax,2)\n  add    $0x2,%rax\n  cmp    %eax,%ebx\n  jg     L1\n  lea    -0x1(%rbx),%ecx\n  shr    %ecx\n  je     L2\n  lea    0x4(%rdi),%rsi\n  jmp    L3\nL5:\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  je     L4\nL6:\n  movss  (%rax),%xmm0\n  movss  0x4(%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L5\n  movss  %xmm1,(%rax)\n  movss  %xmm0,0x4(%rax)\n  jmp    L5\nL4:\n  sub    $0x1,%ecx\n  je     L2\nL3:\n  test   %ecx,%ecx\n  jle    L4\n  mov    %rdi,%rax\n  lea    -0x1(%rcx),%edx\n  lea    (%rsi,%rdx,4),%rdx\n  jmp    L6\nL7:\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\nL8:\n  add    $0x1,%rax\n  cmp    %rbx,%rax\n  je     L0\nL9:\n  test   $0x1,%al\n  jne    L7\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %eax,%edx\n  sar    %edx\n  movslq %edx,%rdx\n  movss  (%rdi,%rdx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  jmp    L8\nL0:\n  call   <free@plt>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL2:\n  mov    %ebx,%ebx\n  mov    $0x0,%eax\n  jmp    L9",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4602
            },
            "L1": {
                "label": "L1",
                "addr": 4465
            },
            "L2": {
                "label": "L2",
                "addr": 4612
            },
            "L3": {
                "label": "L3",
                "addr": 4536
            },
            "L4": {
                "label": "L4",
                "addr": 4531
            },
            "L5": {
                "label": "L5",
                "addr": 4497
            },
            "L6": {
                "label": "L6",
                "addr": 4506
            },
            "L7": {
                "label": "L7",
                "addr": 4552
            },
            "L8": {
                "label": "L8",
                "addr": 4564
            },
            "L9": {
                "label": "L9",
                "addr": 4573
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 37,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  movslq %esi,%rbx\n  mov    %ebx,%edi\n  shr    $0x1f,%edi\n  add    %ebx,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    1214 <func0+0xd4>\n  xor    %eax,%eax\n  cs nopw 0x0(%rax,%rax,1)\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%rdi,%rax,2)\n  add    $0x2,%rax\n  cmp    %eax,%ebx\n  jg     1180 <func0+0x40>\n  lea    -0x1(%rbx),%edx\n  shr    %edx\n  je     11d6 <func0+0x96>\n  lea    0x4(%rdi),%rsi\n  xchg   %ax,%ax\n  sub    $0x1,%edx\n  mov    %rdi,%rax\n  mov    %rdx,%rcx\n  lea    (%rsi,%rdx,4),%rdx\n  nopl   (%rax)\n  movss  (%rax),%xmm0\n  movss  0x4(%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    11c7 <func0+0x87>\n  movss  %xmm1,(%rax)\n  movss  %xmm0,0x4(%rax)\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    11b0 <func0+0x70>\n  mov    %ecx,%edx\n  test   %ecx,%ecx\n  jne    11a0 <func0+0x60>\n  xor    %eax,%eax\n  jmp    11fb <func0+0xbb>\n  nopw   0x0(%rax,%rax,1)\n  mov    %eax,%edx\n  sar    %edx\n  movslq %edx,%rdx\n  movss  (%rdi,%rdx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rbx\n  je     1214 <func0+0xd4>\n  test   $0x1,%al\n  je     11e0 <func0+0xa0>\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rbx\n  jne    11fb <func0+0xbb>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  movslq %esi,%rbx\n  mov    %ebx,%edi\n  shr    $0x1f,%edi\n  add    %ebx,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    L0\n  xor    %eax,%eax\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%rdi,%rax,2)\n  add    $0x2,%rax\n  cmp    %eax,%ebx\n  jg     L1\n  lea    -0x1(%rbx),%edx\n  shr    %edx\n  je     L2\n  lea    0x4(%rdi),%rsi\n  xchg   %ax,%ax\nL5:\n  sub    $0x1,%edx\n  mov    %rdi,%rax\n  mov    %rdx,%rcx\n  lea    (%rsi,%rdx,4),%rdx\n  nopl   (%rax)\nL4:\n  movss  (%rax),%xmm0\n  movss  0x4(%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L3\n  movss  %xmm1,(%rax)\n  movss  %xmm0,0x4(%rax)\nL3:\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    L4\n  mov    %ecx,%edx\n  test   %ecx,%ecx\n  jne    L5\nL2:\n  xor    %eax,%eax\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL7:\n  mov    %eax,%edx\n  sar    %edx\n  movslq %edx,%rdx\n  movss  (%rdi,%rdx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rbx\n  je     L0\nL6:\n  test   $0x1,%al\n  je     L7\n  movss  0x0(%rbp,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rbx\n  jne    L6\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4628
            },
            "L1": {
                "label": "L1",
                "addr": 4480
            },
            "L2": {
                "label": "L2",
                "addr": 4566
            },
            "L3": {
                "label": "L3",
                "addr": 4551
            },
            "L4": {
                "label": "L4",
                "addr": 4528
            },
            "L5": {
                "label": "L5",
                "addr": 4512
            },
            "L6": {
                "label": "L6",
                "addr": 4603
            },
            "L7": {
                "label": "L7",
                "addr": 4576
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 37,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nvoid func0(float *l, int size, float *out) {\n    float *even = malloc((size / 2 + 1) * sizeof(float));\n    int i, j, even_count = 0;\n\n    for (i = 0; i < size; i += 2) {\n        even[even_count++] = l[i];\n    }\n\n    for (i = 0; i < even_count - 1; i++) {\n        for (j = 0; j < even_count - i - 1; j++) {\n            if (even[j] > even[j + 1]) {\n                float temp = even[j];\n                even[j] = even[j + 1];\n                even[j + 1] = temp;\n            }\n        }\n    }\n\n    // Merging even-indexed sorted and odd-indexed as they are\n    for (i = 0; i < size; i++) {\n        if (i % 2 == 0) {\n            out[i] = even[i / 2];\n        } else {\n            out[i] = l[i];\n        }\n    }\n\n    free(even);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\n\nint issame(float *a, float *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    float test1[] = {1, 2, 3};\n    float result1[3];\n    func0(test1, 3, result1);\n    float expected1[] = {1, 2, 3};\n    assert(issame(result1, expected1, 3));\n\n    float test2[] = {5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10};\n    float result2[11];\n    func0(test2, 11, result2);\n    float expected2[] = {-10, 3, -5, 2, -3, 3, 5, 0, 9, 1, 123};\n    assert(issame(result2, expected2, 11));\n\n    float test3[] = {5, 8, -12, 4, 23, 2, 3, 11, 12, -10};\n    float result3[10];\n    func0(test3, 10, result3);\n    float expected3[] = {-12, 8, 3, 4, 5, 2, 12, 11, 23, -10};\n    assert(issame(result3, expected3, 10));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebp,%ebp\n  jle    128f <func0+0x14f>\n  lea    -0x1(%rbp),%eax\n  mov    %eax,%edx\n  shr    %edx\n  cmp    $0x7,%eax\n  jbe    12bd <func0+0x17d>\n  shr    $0x3,%eax\n  mov    %eax,%esi\n  xor    %eax,%eax\n  mov    %rsi,%rcx\n  shl    $0x4,%rsi\n  nopl   0x0(%rax)\n  movups (%rbx,%rax,2),%xmm0\n  movups 0x10(%rbx,%rax,2),%xmm4\n  shufps $0x88,%xmm4,%xmm0\n  movups %xmm0,(%rdi,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rsi\n  jne    1198 <func0+0x58>\n  lea    0x0(,%rcx,4),%esi\n  lea    0x0(,%rcx,8),%eax\n  movslq %eax,%r9\n  movslq %esi,%rcx\n  movss  (%rbx,%r9,4),%xmm0\n  lea    0x0(,%rcx,4),%rsi\n  lea    0x0(,%r9,4),%r8\n  movss  %xmm0,(%rdi,%rcx,4)\n  lea    0x2(%rax),%ecx\n  cmp    %ecx,%ebp\n  jle    121d <func0+0xdd>\n  movss  0x8(%rbx,%r8,1),%xmm0\n  lea    0x4(%rax),%ecx\n  movss  %xmm0,0x4(%rdi,%rsi,1)\n  cmp    %ecx,%ebp\n  jle    121d <func0+0xdd>\n  movss  0x10(%rbx,%r8,1),%xmm0\n  add    $0x6,%eax\n  movss  %xmm0,0x8(%rdi,%rsi,1)\n  cmp    %eax,%ebp\n  jle    121d <func0+0xdd>\n  movss  0x18(%rbx,%r8,1),%xmm0\n  movss  %xmm0,0xc(%rdi,%rsi,1)\n  test   %edx,%edx\n  je     1261 <func0+0x121>\n  lea    0x4(%rdi),%rsi\n  nopl   (%rax)\n  sub    $0x1,%edx\n  mov    %rdi,%rax\n  mov    %rdx,%rcx\n  lea    (%rsi,%rdx,4),%rdx\n  nopl   (%rax)\n  movq   (%rax),%xmm0\n  movaps %xmm0,%xmm3\n  movaps %xmm0,%xmm2\n  shufps $0xe5,%xmm3,%xmm3\n  comiss %xmm3,%xmm0\n  shufps $0xe1,%xmm2,%xmm2\n  jbe    1252 <func0+0x112>\n  movlps %xmm2,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdx\n  jne    1238 <func0+0xf8>\n  mov    %ecx,%edx\n  test   %ecx,%ecx\n  jne    1228 <func0+0xe8>\n  movslq %ebp,%rdx\n  xor    %eax,%eax\n  cs nopw 0x0(%rax,%rax,1)\n  test   $0x1,%al\n  jne    12a0 <func0+0x160>\n  mov    %eax,%ecx\n  sar    %ecx\n  movslq %ecx,%rcx\n  movss  (%rdi,%rcx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rdx,%rax\n  jne    1270 <func0+0x130>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rbx,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rdx\n  jne    1270 <func0+0x130>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>\n  xor    %esi,%esi\n  xor    %eax,%eax\n  jmp    11c0 <func0+0x80>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  test   %ebp,%ebp\n  jle    L0\n  lea    -0x1(%rbp),%eax\n  mov    %eax,%edx\n  shr    %edx\n  cmp    $0x7,%eax\n  jbe    L1\n  shr    $0x3,%eax\n  mov    %eax,%esi\n  xor    %eax,%eax\n  mov    %rsi,%rcx\n  shl    $0x4,%rsi\n  nopl   0x0(%rax)\nL2:\n  movups (%rbx,%rax,2),%xmm0\n  movups 0x10(%rbx,%rax,2),%xmm4\n  shufps $0x88,%xmm4,%xmm0\n  movups %xmm0,(%rdi,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rsi\n  jne    L2\n  lea    0x0(,%rcx,4),%esi\n  lea    0x0(,%rcx,8),%eax\nL10:\n  movslq %eax,%r9\n  movslq %esi,%rcx\n  movss  (%rbx,%r9,4),%xmm0\n  lea    0x0(,%rcx,4),%rsi\n  lea    0x0(,%r9,4),%r8\n  movss  %xmm0,(%rdi,%rcx,4)\n  lea    0x2(%rax),%ecx\n  cmp    %ecx,%ebp\n  jle    L3\n  movss  0x8(%rbx,%r8,1),%xmm0\n  lea    0x4(%rax),%ecx\n  movss  %xmm0,0x4(%rdi,%rsi,1)\n  cmp    %ecx,%ebp\n  jle    L3\n  movss  0x10(%rbx,%r8,1),%xmm0\n  add    $0x6,%eax\n  movss  %xmm0,0x8(%rdi,%rsi,1)\n  cmp    %eax,%ebp\n  jle    L3\n  movss  0x18(%rbx,%r8,1),%xmm0\n  movss  %xmm0,0xc(%rdi,%rsi,1)\nL3:\n  test   %edx,%edx\n  je     L4\n  lea    0x4(%rdi),%rsi\n  nopl   (%rax)\nL7:\n  sub    $0x1,%edx\n  mov    %rdi,%rax\n  mov    %rdx,%rcx\n  lea    (%rsi,%rdx,4),%rdx\n  nopl   (%rax)\nL6:\n  movq   (%rax),%xmm0\n  movaps %xmm0,%xmm3\n  movaps %xmm0,%xmm2\n  shufps $0xe5,%xmm3,%xmm3\n  comiss %xmm3,%xmm0\n  shufps $0xe1,%xmm2,%xmm2\n  jbe    L5\n  movlps %xmm2,(%rax)\nL5:\n  add    $0x4,%rax\n  cmp    %rax,%rdx\n  jne    L6\n  mov    %ecx,%edx\n  test   %ecx,%ecx\n  jne    L7\nL4:\n  movslq %ebp,%rdx\n  xor    %eax,%eax\n  cs nopw 0x0(%rax,%rax,1)\nL9:\n  test   $0x1,%al\n  jne    L8\n  mov    %eax,%ecx\n  sar    %ecx\n  movslq %ecx,%rcx\n  movss  (%rdi,%rcx,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rdx,%rax\n  jne    L9\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>\n  nopl   0x0(%rax,%rax,1)\nL8:\n  movss  (%rbx,%rax,4),%xmm0\n  movss  %xmm0,(%r12,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rdx\n  jne    L9\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  jmp    1060 <free@plt>\nL1:\n  xor    %esi,%esi\n  xor    %eax,%eax\n  jmp    L10",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4751
            },
            "L1": {
                "label": "L1",
                "addr": 4797
            },
            "L2": {
                "label": "L2",
                "addr": 4504
            },
            "L3": {
                "label": "L3",
                "addr": 4637
            },
            "L4": {
                "label": "L4",
                "addr": 4705
            },
            "L5": {
                "label": "L5",
                "addr": 4690
            },
            "L6": {
                "label": "L6",
                "addr": 4664
            },
            "L7": {
                "label": "L7",
                "addr": 4648
            },
            "L8": {
                "label": "L8",
                "addr": 4768
            },
            "L9": {
                "label": "L9",
                "addr": 4720
            },
            "L10": {
                "label": "L10",
                "addr": 4544
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 38,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <strlen@plt>\n  mov    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  add    $0x2,%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1284 <func0+0x12b>\n  mov    -0x1c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cmp    %eax,-0x18(%rbp)\n  jge    11d8 <func0+0x7f>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shl    $0x2,%eax\n  sub    %eax,%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  jmp    11dd <func0+0x84>\n  mov    $0x3,%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x1c(%rbp),%ecx\n  mov    %ecx,%eax\n  add    %eax,%eax\n  add    %ecx,%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rcx\n  lea    -0xc(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strncpy@plt>\n  mov    -0x10(%rbp),%eax\n  cltq\n  movb   $0x0,-0xc(%rbp,%rax,1)\n  cmpl   $0x3,-0x10(%rbp)\n  jne    1258 <func0+0xff>\n  cmpl   $0x0,-0x2c(%rbp)\n  je     123c <func0+0xe3>\n  movzbl -0xa(%rbp),%eax\n  mov    %al,-0x1d(%rbp)\n  movzbl -0xb(%rbp),%eax\n  mov    %al,-0xa(%rbp)\n  movzbl -0xc(%rbp),%eax\n  mov    %al,-0xb(%rbp)\n  movzbl -0x1d(%rbp),%eax\n  mov    %al,-0xc(%rbp)\n  jmp    1258 <func0+0xff>\n  movzbl -0xc(%rbp),%eax\n  mov    %al,-0x1e(%rbp)\n  movzbl -0xb(%rbp),%eax\n  mov    %al,-0xc(%rbp)\n  movzbl -0xa(%rbp),%eax\n  mov    %al,-0xb(%rbp)\n  movzbl -0x1e(%rbp),%eax\n  mov    %al,-0xa(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x1c(%rbp),%ecx\n  mov    %ecx,%eax\n  add    %eax,%eax\n  add    %ecx,%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rcx\n  lea    -0xc(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   1070 <strncpy@plt>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     11b6 <func0+0x5d>\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     12a5 <func0+0x14c>\n  call   1090 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  add    $0x2,%eax\n  movslq %eax,%rdx\n  imul   $0x55555556,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL5:\n  mov    -0x1c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  cmp    %eax,-0x18(%rbp)\n  jge    L1\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shl    $0x2,%eax\n  sub    %eax,%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  jmp    L2\nL1:\n  mov    $0x3,%eax\nL2:\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x1c(%rbp),%ecx\n  mov    %ecx,%eax\n  add    %eax,%eax\n  add    %ecx,%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rcx\n  lea    -0xc(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  mov    -0x10(%rbp),%eax\n  cltq\n  movb   $0x0,-0xc(%rbp,%rax,1)\n  cmpl   $0x3,-0x10(%rbp)\n  jne    L3\n  cmpl   $0x0,-0x2c(%rbp)\n  je     L4\n  movzbl -0xa(%rbp),%eax\n  mov    %al,-0x1d(%rbp)\n  movzbl -0xb(%rbp),%eax\n  mov    %al,-0xa(%rbp)\n  movzbl -0xc(%rbp),%eax\n  mov    %al,-0xb(%rbp)\n  movzbl -0x1d(%rbp),%eax\n  mov    %al,-0xc(%rbp)\n  jmp    L3\nL4:\n  movzbl -0xc(%rbp),%eax\n  mov    %al,-0x1e(%rbp)\n  movzbl -0xb(%rbp),%eax\n  mov    %al,-0xc(%rbp)\n  movzbl -0xa(%rbp),%eax\n  mov    %al,-0xb(%rbp)\n  movzbl -0x1e(%rbp),%eax\n  mov    %al,-0xa(%rbp)\nL3:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x1c(%rbp),%ecx\n  mov    %ecx,%eax\n  add    %eax,%eax\n  add    %ecx,%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rcx\n  lea    -0xc(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   <strncpy@plt>\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L5\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     L6\n  call   <__stack_chk_fail@plt>\nL6:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4740
            },
            "L1": {
                "label": "L1",
                "addr": 4568
            },
            "L2": {
                "label": "L2",
                "addr": 4573
            },
            "L3": {
                "label": "L3",
                "addr": 4696
            },
            "L4": {
                "label": "L4",
                "addr": 4668
            },
            "L5": {
                "label": "L5",
                "addr": 4534
            },
            "L6": {
                "label": "L6",
                "addr": 4773
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 38,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,0xc(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1090 <strlen@plt>\n  mov    %rax,%r12\n  mov    %eax,0x8(%rsp)\n  lea    0x2(%rax),%eax\n  movslq %eax,%r15\n  imul   $0x55555556,%r15,%r15\n  shr    $0x20,%r15\n  sar    $0x1f,%eax\n  sub    %eax,%r15d\n  test   %r12d,%r12d\n  jle    128b <func0+0x112>\n  mov    $0x0,%ebx\n  lea    0x14(%rsp),%r14\n  jmp    121c <func0+0xa3>\n  movslq %r12d,%r13\n  mov    %rbp,(%rsp)\n  mov    $0x4,%ecx\n  mov    %r13,%rdx\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   10b0 <__strncpy_chk@plt>\n  movb   $0x0,0x14(%rsp,%r13,1)\n  cmp    $0x3,%r12d\n  je     1247 <func0+0xce>\n  mov    %r13,%rdx\n  mov    %r14,%rsi\n  mov    (%rsp),%rdi\n  call   1080 <strncpy@plt>\n  add    $0x3,%rbp\n  sub    $0x3,%r12d\n  cmp    %r15d,%ebx\n  jge    128b <func0+0x112>\n  add    $0x1,%ebx\n  lea    (%rbx,%rbx,2),%eax\n  cmp    %eax,0x8(%rsp)\n  jl     11da <func0+0x61>\n  mov    %rbp,(%rsp)\n  mov    $0x3,%edx\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   1080 <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\n  mov    $0x3,%r13d\n  cmpl   $0x0,0xc(%rsp)\n  je     126b <func0+0xf2>\n  movzbl 0x16(%rsp),%eax\n  movzbl 0x15(%rsp),%edx\n  mov    %dl,0x16(%rsp)\n  movzbl 0x14(%rsp),%edx\n  mov    %dl,0x15(%rsp)\n  mov    %al,0x14(%rsp)\n  jmp    1200 <func0+0x87>\n  movzbl 0x14(%rsp),%eax\n  movzbl 0x15(%rsp),%edx\n  mov    %dl,0x14(%rsp)\n  movzbl 0x16(%rsp),%edx\n  mov    %dl,0x15(%rsp)\n  mov    %al,0x16(%rsp)\n  jmp    1200 <func0+0x87>\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12aa <func0+0x131>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10a0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,0xc(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%r12\n  mov    %eax,0x8(%rsp)\n  lea    0x2(%rax),%eax\n  movslq %eax,%r15\n  imul   $0x55555556,%r15,%r15\n  shr    $0x20,%r15\n  sar    $0x1f,%eax\n  sub    %eax,%r15d\n  test   %r12d,%r12d\n  jle    L0\n  mov    $0x0,%ebx\n  lea    0x14(%rsp),%r14\n  jmp    L1\nL3:\n  movslq %r12d,%r13\n  mov    %rbp,(%rsp)\n  mov    $0x4,%ecx\n  mov    %r13,%rdx\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   <__strncpy_chk@plt>\n  movb   $0x0,0x14(%rsp,%r13,1)\n  cmp    $0x3,%r12d\n  je     L2\nL5:\n  mov    %r13,%rdx\n  mov    %r14,%rsi\n  mov    (%rsp),%rdi\n  call   <strncpy@plt>\n  add    $0x3,%rbp\n  sub    $0x3,%r12d\n  cmp    %r15d,%ebx\n  jge    L0\nL1:\n  add    $0x1,%ebx\n  lea    (%rbx,%rbx,2),%eax\n  cmp    %eax,0x8(%rsp)\n  jl     L3\n  mov    %rbp,(%rsp)\n  mov    $0x3,%edx\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\n  mov    $0x3,%r13d\nL2:\n  cmpl   $0x0,0xc(%rsp)\n  je     L4\n  movzbl 0x16(%rsp),%eax\n  movzbl 0x15(%rsp),%edx\n  mov    %dl,0x16(%rsp)\n  movzbl 0x14(%rsp),%edx\n  mov    %dl,0x15(%rsp)\n  mov    %al,0x14(%rsp)\n  jmp    L5\nL4:\n  movzbl 0x14(%rsp),%eax\n  movzbl 0x15(%rsp),%edx\n  mov    %dl,0x14(%rsp)\n  movzbl 0x16(%rsp),%edx\n  mov    %dl,0x15(%rsp)\n  mov    %al,0x16(%rsp)\n  jmp    L5\nL0:\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL6:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4747
            },
            "L1": {
                "label": "L1",
                "addr": 4636
            },
            "L2": {
                "label": "L2",
                "addr": 4679
            },
            "L3": {
                "label": "L3",
                "addr": 4570
            },
            "L4": {
                "label": "L4",
                "addr": 4715
            },
            "L5": {
                "label": "L5",
                "addr": 4608
            },
            "L6": {
                "label": "L6",
                "addr": 4778
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 38,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1090 <strlen@plt>\n  mov    %rax,%rbp\n  mov    %eax,%r14d\n  add    $0x2,%eax\n  movslq %eax,%r13\n  sar    $0x1f,%eax\n  imul   $0x55555556,%r13,%r13\n  shr    $0x20,%r13\n  sub    %eax,%r13d\n  test   %ebp,%ebp\n  jle    1288 <func0+0x108>\n  xor    %ebx,%ebx\n  lea    0x14(%rsp),%r12\n  jmp    1237 <func0+0xb7>\n  nopl   0x0(%rax)\n  mov    $0x3,%edx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  call   1080 <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\n  mov    0xc(%rsp),%esi\n  movzbl 0x15(%rsp),%ecx\n  movzbl 0x16(%rsp),%edx\n  movzbl 0x14(%rsp),%eax\n  test   %esi,%esi\n  je     1270 <func0+0xf0>\n  mov    %cl,0x16(%rsp)\n  mov    %al,0x15(%rsp)\n  mov    %dl,0x14(%rsp)\n  mov    $0x3,%edx\n  nopl   (%rax)\n  mov    %r15,%rdi\n  mov    %r12,%rsi\n  add    $0x3,%r15\n  sub    $0x3,%ebp\n  call   1080 <strncpy@plt>\n  cmp    %r13d,%ebx\n  jge    1288 <func0+0x108>\n  add    $0x1,%ebx\n  lea    (%rbx,%rbx,2),%eax\n  cmp    %r14d,%eax\n  jle    11e0 <func0+0x60>\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  mov    %rdx,(%rsp)\n  call   10b0 <__strncpy_chk@plt>\n  mov    (%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    1220 <func0+0xa0>\n  jmp    11f5 <func0+0x75>\n  nopl   0x0(%rax)\n  mov    %dl,0x15(%rsp)\n  mov    $0x3,%edx\n  mov    %cl,0x14(%rsp)\n  mov    %al,0x16(%rsp)\n  jmp    1220 <func0+0xa0>\n  nopl   0x0(%rax,%rax,1)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12a7 <func0+0x127>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10a0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  mov    %eax,%r14d\n  add    $0x2,%eax\n  movslq %eax,%r13\n  sar    $0x1f,%eax\n  imul   $0x55555556,%r13,%r13\n  shr    $0x20,%r13\n  sub    %eax,%r13d\n  test   %ebp,%ebp\n  jle    L0\n  xor    %ebx,%ebx\n  lea    0x14(%rsp),%r12\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  mov    $0x3,%edx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\nL5:\n  mov    0xc(%rsp),%esi\n  movzbl 0x15(%rsp),%ecx\n  movzbl 0x16(%rsp),%edx\n  movzbl 0x14(%rsp),%eax\n  test   %esi,%esi\n  je     L2\n  mov    %cl,0x16(%rsp)\n  mov    %al,0x15(%rsp)\n  mov    %dl,0x14(%rsp)\n  mov    $0x3,%edx\n  nopl   (%rax)\nL4:\n  mov    %r15,%rdi\n  mov    %r12,%rsi\n  add    $0x3,%r15\n  sub    $0x3,%ebp\n  call   <strncpy@plt>\n  cmp    %r13d,%ebx\n  jge    L0\nL1:\n  add    $0x1,%ebx\n  lea    (%rbx,%rbx,2),%eax\n  cmp    %r14d,%eax\n  jle    L3\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  mov    %rdx,(%rsp)\n  call   <__strncpy_chk@plt>\n  mov    (%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    L4\n  jmp    L5\n  nopl   0x0(%rax)\nL2:\n  mov    %dl,0x15(%rsp)\n  mov    $0x3,%edx\n  mov    %cl,0x14(%rsp)\n  mov    %al,0x16(%rsp)\n  jmp    L4\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL6:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4744
            },
            "L1": {
                "label": "L1",
                "addr": 4663
            },
            "L2": {
                "label": "L2",
                "addr": 4720
            },
            "L3": {
                "label": "L3",
                "addr": 4576
            },
            "L4": {
                "label": "L4",
                "addr": 4640
            },
            "L5": {
                "label": "L5",
                "addr": 4597
            },
            "L6": {
                "label": "L6",
                "addr": 4775
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 38,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(char *s, int encode) {\n    int l = strlen(s);\n    int num = (l + 2) / 3;\n    char x[4];\n\n    for (int i = 0; i < num; ++i) {\n        int len = (i * 3 + 3 <= l) ? 3 : l - i * 3;\n        strncpy(x, s + i * 3, len);\n        x[len] = '\\0';\n\n        if (len == 3) {\n            if (encode) {\n                char temp = x[2];\n                x[2] = x[1];\n                x[1] = x[0];\n                x[0] = temp;\n            } else {\n                char temp = x[0];\n                x[0] = x[1];\n                x[1] = x[2];\n                x[2] = temp;\n            }\n        }\n        strncpy(s + i * 3, x, len);\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main(){\n    srand((unsigned int)time(NULL));\n    char str[22], temp[22], decoded_str[22];\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        for (int j = 0; j < l; j++) {\n            str[j] = 'a' + rand() % 26;\n        }\n        str[l] = '\\0';\n        strcpy(temp, str);\n\n        func0(temp, 1); // Encode\n        strcpy(decoded_str, temp);\n        func0(decoded_str, 0); // Decode\n\n        assert(strcmp(decoded_str, str) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %esi,%r15d\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1090 <strlen@plt>\n  mov    %rax,%rbp\n  mov    %eax,%r13d\n  add    $0x2,%eax\n  movslq %eax,%r12\n  sar    $0x1f,%eax\n  imul   $0x55555556,%r12,%r12\n  shr    $0x20,%r12\n  sub    %eax,%r12d\n  test   %ebp,%ebp\n  jle    1268 <func0+0xe8>\n  test   %r15d,%r15d\n  jne    1290 <func0+0x110>\n  lea    0x14(%rsp),%r14\n  jmp    122c <func0+0xac>\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x3,%edx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  call   1080 <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\n  movzbl 0x14(%rsp),%eax\n  movzwl 0x15(%rsp),%edx\n  mov    %al,0x16(%rsp)\n  mov    %dx,0x14(%rsp)\n  mov    $0x3,%edx\n  mov    %rbx,%rdi\n  mov    %r14,%rsi\n  add    $0x3,%rbx\n  sub    $0x3,%ebp\n  call   1080 <strncpy@plt>\n  cmp    %r15d,%r12d\n  jle    1268 <func0+0xe8>\n  add    $0x1,%r15d\n  lea    (%r15,%r15,2),%eax\n  cmp    %eax,%r13d\n  jge    11e8 <func0+0x68>\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  call   10b0 <__strncpy_chk@plt>\n  mov    0x8(%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    1215 <func0+0x95>\n  jmp    11fd <func0+0x7d>\n  nopw   0x0(%rax,%rax,1)\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1323 <func0+0x1a3>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %r15d,%r15d\n  lea    0x14(%rsp),%r14\n  jmp    12ed <func0+0x16d>\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x3,%edx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  call   1080 <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\n  xor    %eax,%eax\n  mov    0x16(%rsp),%al\n  mov    0x14(%rsp),%ah\n  movzbl 0x15(%rsp),%edx\n  mov    %ax,0x14(%rsp)\n  mov    %dl,0x16(%rsp)\n  mov    $0x3,%edx\n  mov    %rbx,%rdi\n  mov    %r14,%rsi\n  add    $0x3,%rbx\n  sub    $0x3,%ebp\n  call   1080 <strncpy@plt>\n  cmp    %r12d,%r15d\n  jge    1268 <func0+0xe8>\n  add    $0x1,%r15d\n  lea    (%r15,%r15,2),%eax\n  cmp    %eax,%r13d\n  jge    12a0 <func0+0x120>\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  call   10b0 <__strncpy_chk@plt>\n  mov    0x8(%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    12d2 <func0+0x152>\n  jmp    12b5 <func0+0x135>\n  call   10a0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %esi,%r15d\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  mov    %eax,%r13d\n  add    $0x2,%eax\n  movslq %eax,%r12\n  sar    $0x1f,%eax\n  imul   $0x55555556,%r12,%r12\n  shr    $0x20,%r12\n  sub    %eax,%r12d\n  test   %ebp,%ebp\n  jle    L0\n  test   %r15d,%r15d\n  jne    L1\n  lea    0x14(%rsp),%r14\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL3:\n  mov    $0x3,%edx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\nL5:\n  movzbl 0x14(%rsp),%eax\n  movzwl 0x15(%rsp),%edx\n  mov    %al,0x16(%rsp)\n  mov    %dx,0x14(%rsp)\n  mov    $0x3,%edx\nL4:\n  mov    %rbx,%rdi\n  mov    %r14,%rsi\n  add    $0x3,%rbx\n  sub    $0x3,%ebp\n  call   <strncpy@plt>\n  cmp    %r15d,%r12d\n  jle    L0\nL2:\n  add    $0x1,%r15d\n  lea    (%r15,%r15,2),%eax\n  cmp    %eax,%r13d\n  jge    L3\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  call   <__strncpy_chk@plt>\n  mov    0x8(%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    L4\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %r15d,%r15d\n  lea    0x14(%rsp),%r14\n  jmp    L7\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    $0x3,%edx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,0x17(%rsp)\nL10:\n  xor    %eax,%eax\n  mov    0x16(%rsp),%al\n  mov    0x14(%rsp),%ah\n  movzbl 0x15(%rsp),%edx\n  mov    %ax,0x14(%rsp)\n  mov    %dl,0x16(%rsp)\n  mov    $0x3,%edx\nL9:\n  mov    %rbx,%rdi\n  mov    %r14,%rsi\n  add    $0x3,%rbx\n  sub    $0x3,%ebp\n  call   <strncpy@plt>\n  cmp    %r12d,%r15d\n  jge    L0\nL7:\n  add    $0x1,%r15d\n  lea    (%r15,%r15,2),%eax\n  cmp    %eax,%r13d\n  jge    L8\n  movslq %ebp,%rdx\n  mov    $0x4,%ecx\n  mov    %rbx,%rsi\n  mov    %r14,%rdi\n  mov    %rdx,0x8(%rsp)\n  call   <__strncpy_chk@plt>\n  mov    0x8(%rsp),%rdx\n  movb   $0x0,0x14(%rsp,%rdx,1)\n  cmp    $0x3,%ebp\n  jne    L9\n  jmp    L10\nL6:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4712
            },
            "L1": {
                "label": "L1",
                "addr": 4752
            },
            "L2": {
                "label": "L2",
                "addr": 4652
            },
            "L3": {
                "label": "L3",
                "addr": 4584
            },
            "L4": {
                "label": "L4",
                "addr": 4629
            },
            "L5": {
                "label": "L5",
                "addr": 4605
            },
            "L6": {
                "label": "L6",
                "addr": 4899
            },
            "L7": {
                "label": "L7",
                "addr": 4845
            },
            "L8": {
                "label": "L8",
                "addr": 4768
            },
            "L9": {
                "label": "L9",
                "addr": 4818
            },
            "L10": {
                "label": "L10",
                "addr": 4789
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 39,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x24(%rbp)\n  movl   $0x1,-0x18(%rbp)\n  movl   $0x2,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    117f <func0+0x86>\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    115d <func0+0x64>\n  mov    -0x18(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1159 <func0+0x60>\n  movl   $0x0,-0xc(%rbp)\n  jmp    1168 <func0+0x6f>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x18(%rbp)\n  jge    1143 <func0+0x4a>\n  cmpl   $0x0,-0xc(%rbp)\n  je     1172 <func0+0x79>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jne    117f <func0+0x86>\n  mov    -0x18(%rbp),%eax\n  jmp    118c <func0+0x93>\n  mov    -0x10(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     111b <func0+0x22>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x24(%rbp)\n  movl   $0x1,-0x18(%rbp)\n  movl   $0x2,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL7:\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    L1\nL4:\n  mov    -0x18(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L2\n  movl   $0x0,-0xc(%rbp)\n  jmp    L3\nL2:\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x18(%rbp)\n  jge    L4\nL3:\n  cmpl   $0x0,-0xc(%rbp)\n  je     L5\n  addl   $0x1,-0x10(%rbp)\nL5:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jne    L0\n  mov    -0x18(%rbp),%eax\n  jmp    L6\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     L7\n  mov    $0x0,%eax\nL6:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4479
            },
            "L1": {
                "label": "L1",
                "addr": 4445
            },
            "L2": {
                "label": "L2",
                "addr": 4441
            },
            "L3": {
                "label": "L3",
                "addr": 4456
            },
            "L4": {
                "label": "L4",
                "addr": 4419
            },
            "L5": {
                "label": "L5",
                "addr": 4466
            },
            "L6": {
                "label": "L6",
                "addr": 4492
            },
            "L7": {
                "label": "L7",
                "addr": 4379
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 39,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    $0x0,%r8d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  jmp    1125 <func0+0x2c>\n  mov    $0x0,%esi\n  mov    %esi,%eax\n  ret\n  add    $0x1,%r8d\n  cmp    %r8d,%edi\n  je     1114 <func0+0x1b>\n  mov    %esi,%eax\n  mov    %r9d,%esi\n  cmp    %edi,%r8d\n  jge    110f <func0+0x16>\n  lea    (%rax,%rsi,1),%r9d\n  cmp    $0x3,%esi\n  jle    1117 <func0+0x1e>\n  test   $0x1,%sil\n  je     1120 <func0+0x27>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     1117 <func0+0x1e>\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    113e <func0+0x45>\n  jmp    1120 <func0+0x27>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x0,%r8d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  jmp    L0\nL2:\n  mov    $0x0,%esi\nL1:\n  mov    %esi,%eax\n  ret\nL3:\n  add    $0x1,%r8d\n  cmp    %r8d,%edi\n  je     L1\nL4:\n  mov    %esi,%eax\n  mov    %r9d,%esi\nL0:\n  cmp    %edi,%r8d\n  jge    L2\n  lea    (%rax,%rsi,1),%r9d\n  cmp    $0x3,%esi\n  jle    L3\n  test   $0x1,%sil\n  je     L4\n  mov    $0x2,%ecx\nL5:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     L3\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L5\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4389
            },
            "L1": {
                "label": "L1",
                "addr": 4372
            },
            "L2": {
                "label": "L2",
                "addr": 4367
            },
            "L3": {
                "label": "L3",
                "addr": 4375
            },
            "L4": {
                "label": "L4",
                "addr": 4384
            },
            "L5": {
                "label": "L5",
                "addr": 4414
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 39,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1158 <func0+0x58>\n  xor    %r9d,%r9d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  nopl   (%rax)\n  mov    %esi,%r8d\n  add    %eax,%esi\n  cmp    $0x3,%r8d\n  jle    1147 <func0+0x47>\n  test   $0x1,%r8b\n  je     1150 <func0+0x50>\n  mov    $0x2,%ecx\n  jmp    113a <func0+0x3a>\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1150 <func0+0x50>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    1130 <func0+0x30>\n  add    $0x1,%r9d\n  cmp    %r9d,%edi\n  je     115b <func0+0x5b>\n  mov    %r8d,%eax\n  cmp    %r9d,%edi\n  jg     1118 <func0+0x18>\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %r9d,%r9d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  nopl   (%rax)\nL6:\n  mov    %esi,%r8d\n  add    %eax,%esi\n  cmp    $0x3,%r8d\n  jle    L1\n  test   $0x1,%r8b\n  je     L2\n  mov    $0x2,%ecx\n  jmp    L3\nL4:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\nL3:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    L4\nL1:\n  add    $0x1,%r9d\n  cmp    %r9d,%edi\n  je     L5\nL2:\n  mov    %r8d,%eax\n  cmp    %r9d,%edi\n  jg     L6\nL0:\n  xor    %r8d,%r8d\nL5:\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4440
            },
            "L1": {
                "label": "L1",
                "addr": 4423
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4410
            },
            "L4": {
                "label": "L4",
                "addr": 4400
            },
            "L5": {
                "label": "L5",
                "addr": 4443
            },
            "L6": {
                "label": "L6",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 39,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f1 = 1, f2 = 2, m;\n    int count = 0;\n    while (count < n) {\n        f1 = f1 + f2;\n        m = f1; f1 = f2; f2 = m;\n        int isprime = 1;\n        for (int w = 2; w * w <= f1; w++) {\n            if (f1 % w == 0) {\n                isprime = 0; break;\n            }\n        }\n        if (isprime) count += 1;\n        if (count == n) return f1;\n    }\n    return 0;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(1) == 2);\n    assert(func0(2) == 3);\n    assert(func0(3) == 5);\n    assert(func0(4) == 13);\n    assert(func0(5) == 89);\n    assert(func0(6) == 233);\n    assert(func0(7) == 1597);\n    assert(func0(8) == 28657);\n    assert(func0(9) == 514229);\n    assert(func0(10) == 433494437);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1158 <func0+0x58>\n  xor    %r9d,%r9d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  nopl   (%rax)\n  mov    %esi,%r8d\n  add    %eax,%esi\n  cmp    $0x3,%r8d\n  jle    1147 <func0+0x47>\n  test   $0x1,%r8b\n  je     1150 <func0+0x50>\n  mov    $0x2,%ecx\n  jmp    113a <func0+0x3a>\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1150 <func0+0x50>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    1130 <func0+0x30>\n  add    $0x1,%r9d\n  cmp    %r9d,%edi\n  je     115b <func0+0x5b>\n  mov    %r8d,%eax\n  cmp    %r9d,%edi\n  jg     1118 <func0+0x18>\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %r9d,%r9d\n  mov    $0x2,%esi\n  mov    $0x1,%eax\n  nopl   (%rax)\nL6:\n  mov    %esi,%r8d\n  add    %eax,%esi\n  cmp    $0x3,%r8d\n  jle    L1\n  test   $0x1,%r8b\n  je     L2\n  mov    $0x2,%ecx\n  jmp    L3\nL4:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L2\nL3:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    L4\nL1:\n  add    $0x1,%r9d\n  cmp    %r9d,%edi\n  je     L5\nL2:\n  mov    %r8d,%eax\n  cmp    %r9d,%edi\n  jg     L6\nL0:\n  xor    %r8d,%r8d\nL5:\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4440
            },
            "L1": {
                "label": "L1",
                "addr": 4423
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4410
            },
            "L4": {
                "label": "L4",
                "addr": 4400
            },
            "L5": {
                "label": "L5",
                "addr": 4443
            },
            "L6": {
                "label": "L6",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 40,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    1197 <func0+0x9e>\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    118b <func0+0x92>\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    117f <func0+0x86>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %eax,%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  test   %eax,%eax\n  jne    117b <func0+0x82>\n  mov    $0x1,%eax\n  jmp    11a8 <func0+0xaf>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     112a <func0+0x31>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111f <func0+0x26>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1114 <func0+0x1b>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL7:\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    L1\nL6:\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    L2\nL5:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %eax,%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  test   %eax,%eax\n  jne    L3\n  mov    $0x1,%eax\n  jmp    L4\nL3:\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L6\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L7\n  mov    $0x0,%eax\nL4:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4503
            },
            "L1": {
                "label": "L1",
                "addr": 4491
            },
            "L2": {
                "label": "L2",
                "addr": 4479
            },
            "L3": {
                "label": "L3",
                "addr": 4475
            },
            "L4": {
                "label": "L4",
                "addr": 4520
            },
            "L5": {
                "label": "L5",
                "addr": 4394
            },
            "L6": {
                "label": "L6",
                "addr": 4383
            },
            "L7": {
                "label": "L7",
                "addr": 4372
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 40,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    113a <func0+0x41>\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\n  cmp    %r10,%r9\n  je     1140 <func0+0x47>\n  mov    %r9,%r8\n  cmp    %r8d,%esi\n  jle    114c <func0+0x53>\n  mov    -0x4(%rdi,%r8,4),%edx\n  add    -0x8(%rdi,%r9,4),%edx\n  mov    %r8,%rax\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  je     1146 <func0+0x4d>\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     1125 <func0+0x2c>\n  add    $0x1,%r8\n  jmp    1113 <func0+0x1a>\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  add    $0x1,%r9\n  jmp    110b <func0+0x12>",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\nL6:\n  cmp    %r10,%r9\n  je     L1\n  mov    %r9,%r8\nL5:\n  cmp    %r8d,%esi\n  jle    L2\n  mov    -0x4(%rdi,%r8,4),%edx\n  add    -0x8(%rdi,%r9,4),%edx\n  mov    %r8,%rax\nL4:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  je     L3\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L4\n  add    $0x1,%r8\n  jmp    L5\nL0:\n  mov    $0x0,%eax\n  ret\nL1:\n  mov    $0x0,%eax\n  ret\nL3:\n  mov    $0x1,%eax\n  ret\nL2:\n  add    $0x1,%r9\n  jmp    L6",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4410
            },
            "L1": {
                "label": "L1",
                "addr": 4416
            },
            "L2": {
                "label": "L2",
                "addr": 4428
            },
            "L3": {
                "label": "L3",
                "addr": 4422
            },
            "L4": {
                "label": "L4",
                "addr": 4389
            },
            "L5": {
                "label": "L5",
                "addr": 4371
            },
            "L6": {
                "label": "L6",
                "addr": 4363
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 40,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1157 <func0+0x57>\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\n  cmp    %r9,%r10\n  je     1157 <func0+0x57>\n  mov    %r9,%r8\n  cmp    %r8d,%esi\n  jle    1151 <func0+0x51>\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  add    -0x8(%rdi,%r9,4),%edx\n  jmp    1138 <func0+0x38>\n  xchg   %ax,%ax\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1148 <func0+0x48>\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    1130 <func0+0x30>\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\n  add    $0x1,%r8\n  cmp    %r8d,%esi\n  jg     111f <func0+0x1f>\n  add    $0x1,%r9\n  jmp    1112 <func0+0x12>\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\nL6:\n  cmp    %r9,%r10\n  je     L0\n  mov    %r9,%r8\n  cmp    %r8d,%esi\n  jle    L1\nL5:\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  add    -0x8(%rdi,%r9,4),%edx\n  jmp    L2\n  xchg   %ax,%ax\nL4:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L3\nL2:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    L4\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\nL3:\n  add    $0x1,%r8\n  cmp    %r8d,%esi\n  jg     L5\nL1:\n  add    $0x1,%r9\n  jmp    L6\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4439
            },
            "L1": {
                "label": "L1",
                "addr": 4433
            },
            "L2": {
                "label": "L2",
                "addr": 4408
            },
            "L3": {
                "label": "L3",
                "addr": 4424
            },
            "L4": {
                "label": "L4",
                "addr": 4400
            },
            "L5": {
                "label": "L5",
                "addr": 4383
            },
            "L6": {
                "label": "L6",
                "addr": 4370
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 40,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            for (int k = j + 1; k < size; k++)\n                if (l[i] + l[j] + l[k] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, 5, -1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 3, -2, 1};\n    assert(func0(test3, 4) == true);\n    \n    int test4[] = {1, 2, 3, 7};\n    assert(func0(test4, 4) == false);\n    \n    int test5[] = {1, 2, 5, 7};\n    assert(func0(test5, 4) == false);\n    \n    int test6[] = {2, 4, -5, 3, 9, 7};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {1};\n    assert(func0(test7, 1) == false);\n    \n    int test8[] = {1, 3, 5, -100};\n    assert(func0(test8, 4) == false);\n    \n    int test9[] = {100, 3, 5, -100};\n    assert(func0(test9, 4) == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1157 <func0+0x57>\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\n  cmp    %r9,%r10\n  je     1157 <func0+0x57>\n  mov    %r9,%r8\n  cmp    %r8d,%esi\n  jle    1151 <func0+0x51>\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  add    -0x8(%rdi,%r9,4),%edx\n  jmp    1138 <func0+0x38>\n  xchg   %ax,%ax\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1148 <func0+0x48>\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    1130 <func0+0x30>\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\n  add    $0x1,%r8\n  cmp    %r8d,%esi\n  jg     111f <func0+0x1f>\n  add    $0x1,%r9\n  jmp    1112 <func0+0x12>\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    0x1(%rsi),%r10d\n  mov    $0x2,%r9d\nL6:\n  cmp    %r9,%r10\n  je     L0\n  mov    %r9,%r8\n  cmp    %r8d,%esi\n  jle    L1\nL5:\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  add    -0x8(%rdi,%r9,4),%edx\n  jmp    L2\n  xchg   %ax,%ax\nL4:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L3\nL2:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    L4\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\nL3:\n  add    $0x1,%r8\n  cmp    %r8d,%esi\n  jg     L5\nL1:\n  add    $0x1,%r9\n  jmp    L6\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4439
            },
            "L1": {
                "label": "L1",
                "addr": 4433
            },
            "L2": {
                "label": "L2",
                "addr": 4408
            },
            "L3": {
                "label": "L3",
                "addr": 4424
            },
            "L4": {
                "label": "L4",
                "addr": 4400
            },
            "L5": {
                "label": "L5",
                "addr": 4383
            },
            "L6": {
                "label": "L6",
                "addr": 4370
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 41,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 41,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  imul   %edi,%edi\n  mov    %edi,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  imul   %edi,%edi\n  mov    %edi,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 41,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  imul   %edi,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  imul   %edi,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 41,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * n;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(2) == 4);\n    assert(func0(3) == 9);\n    assert(func0(4) == 16);\n    assert(func0(8) == 64);\n    assert(func0(10) == 100);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  imul   %edi,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  imul   %edi,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 42,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1144 <func0+0x4b>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1111 <func0+0x18>\n  nop\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L1\n  nop\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4420
            },
            "L1": {
                "label": "L1",
                "addr": 4369
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 42,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1118 <func0+0x1f>\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\n  addl   $0x1,(%rax)\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    110c <func0+0x13>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdx\nL1:\n  addl   $0x1,(%rax)\n  add    $0x4,%rax\n  cmp    %rdx,%rax\n  jne    L1\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4376
            },
            "L1": {
                "label": "L1",
                "addr": 4364
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 42,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    111c <func0+0x1c>\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\n  addl   $0x1,(%rdi)\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  jne    1110 <func0+0x10>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\nL1:\n  addl   $0x1,(%rdi)\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  jne    L1\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4380
            },
            "L1": {
                "label": "L1",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 42,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        l[i] += 1;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int list1[] = {};\n    int result1[] = {};\n    func0(list1, 0);\n    assert(issame(list1, 0, result1, 0));\n\n    int list2[] = {3, 2, 1};\n    int result2[] = {4, 3, 2};\n    func0(list2, 3);\n    assert(issame(list2, 3, result2, 3));\n\n    int list3[] = {5, 2, 5, 2, 3, 3, 9, 0, 123};\n    int result3[] = {6, 3, 6, 3, 4, 4, 10, 1, 124};\n    func0(list3, 9);\n    assert(issame(list3, 9, result3, 9));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1173 <func0+0x73>\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    1179 <func0+0x79>\n  mov    %esi,%edx\n  movdqa 0xee6(%rip),%xmm1        # 2000 <_fini+0xe80>\n  mov    %rdi,%rax\n  shr    $0x2,%edx\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%rdi,%rdx,1),%rdx\n  nopl   0x0(%rax)\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  paddd  %xmm1,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rdx,%rax\n  jne    1130 <func0+0x30>\n  mov    %esi,%edx\n  and    $0xfffffffc,%edx\n  test   $0x3,%sil\n  je     1178 <func0+0x78>\n  movslq %edx,%rax\n  lea    0x1(%rdx),%ecx\n  shl    $0x2,%rax\n  addl   $0x1,(%rdi,%rax,1)\n  cmp    %ecx,%esi\n  jle    1173 <func0+0x73>\n  add    $0x2,%edx\n  addl   $0x1,0x4(%rdi,%rax,1)\n  cmp    %edx,%esi\n  jle    1173 <func0+0x73>\n  addl   $0x1,0x8(%rdi,%rax,1)\n  ret\n  nopl   0x0(%rax)\n  ret\n  xor    %edx,%edx\n  jmp    1150 <func0+0x50>",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    L1\n  mov    %esi,%edx\n  movdqa D0(%rip),%xmm1\n  mov    %rdi,%rax\n  shr    $0x2,%edx\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%rdi,%rdx,1),%rdx\n  nopl   0x0(%rax)\nL2:\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  paddd  %xmm1,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rdx,%rax\n  jne    L2\n  mov    %esi,%edx\n  and    $0xfffffffc,%edx\n  test   $0x3,%sil\n  je     L3\nL4:\n  movslq %edx,%rax\n  lea    0x1(%rdx),%ecx\n  shl    $0x2,%rax\n  addl   $0x1,(%rdi,%rax,1)\n  cmp    %ecx,%esi\n  jle    L0\n  add    $0x2,%edx\n  addl   $0x1,0x4(%rdi,%rax,1)\n  cmp    %edx,%esi\n  jle    L0\n  addl   $0x1,0x8(%rdi,%rax,1)\nL0:\n  ret\n  nopl   0x0(%rax)\nL3:\n  ret\nL1:\n  xor    %edx,%edx\n  jmp    L4",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3814
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4467
            },
            "L1": {
                "label": "L1",
                "addr": 4473
            },
            "L2": {
                "label": "L2",
                "addr": 4400
            },
            "L3": {
                "label": "L3",
                "addr": 4472
            },
            "L4": {
                "label": "L4",
                "addr": 4432
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "01000000010000000100000001000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 43,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1165 <func0+0x6c>\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    1159 <func0+0x60>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  test   %eax,%eax\n  jne    1155 <func0+0x5c>\n  mov    $0x1,%eax\n  jmp    1172 <func0+0x79>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111c <func0+0x23>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1111 <func0+0x18>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL5:\n  mov    -0x8(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    L1\nL4:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  test   %eax,%eax\n  jne    L2\n  mov    $0x1,%eax\n  jmp    L3\nL2:\n  addl   $0x1,-0x4(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    $0x0,%eax\nL3:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4453
            },
            "L1": {
                "label": "L1",
                "addr": 4441
            },
            "L2": {
                "label": "L2",
                "addr": 4437
            },
            "L3": {
                "label": "L3",
                "addr": 4466
            },
            "L4": {
                "label": "L4",
                "addr": 4380
            },
            "L5": {
                "label": "L5",
                "addr": 4369
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 43,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    112c <func0+0x33>\n  mov    %esi,%r9d\n  mov    $0x1,%r8d\n  cmp    %r9,%r8\n  je     1132 <func0+0x39>\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  je     1138 <func0+0x3f>\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     1117 <func0+0x1e>\n  add    $0x1,%r8\n  jmp    110a <func0+0x11>\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%r9d\n  mov    $0x1,%r8d\nL4:\n  cmp    %r9,%r8\n  je     L1\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\nL3:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  je     L2\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L3\n  add    $0x1,%r8\n  jmp    L4\nL0:\n  mov    $0x0,%eax\n  ret\nL1:\n  mov    $0x0,%eax\n  ret\nL2:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4396
            },
            "L1": {
                "label": "L1",
                "addr": 4402
            },
            "L2": {
                "label": "L2",
                "addr": 4408
            },
            "L3": {
                "label": "L3",
                "addr": 4375
            },
            "L4": {
                "label": "L4",
                "addr": 4362
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 43,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1141 <func0+0x41>\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  cmp    %r9,%r8\n  je     1141 <func0+0x41>\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  jmp    1128 <func0+0x28>\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1138 <func0+0x38>\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\n  add    $0x1,%r8\n  cmp    %r9,%r8\n  jne    1116 <func0+0x16>\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  cmp    %r9,%r8\n  je     L0\nL4:\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  jmp    L1\nL3:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L2\nL1:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    L3\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\nL2:\n  add    $0x1,%r8\n  cmp    %r9,%r8\n  jne    L4\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4417
            },
            "L1": {
                "label": "L1",
                "addr": 4392
            },
            "L2": {
                "label": "L2",
                "addr": 4408
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4374
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 43,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size) {\n    for (int i = 0; i < size; i++)\n        for (int j = i + 1; j < size; j++)\n            if (l[i] + l[j] == 0) return true;\n    return false;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 3, 5, 0};\n    assert(func0(test1, 4) == false);\n    \n    int test2[] = {1, 3, -2, 1};\n    assert(func0(test2, 4) == false);\n    \n    int test3[] = {1, 2, 3, 7};\n    assert(func0(test3, 4) == false);\n    \n    int test4[] = {2, 4, -5, 3, 5, 7};\n    assert(func0(test4, 6) == true);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == false);\n    \n    int test6[] = {-3, 9, -1, 3, 2, 30};\n    assert(func0(test6, 6) == true);\n    \n    int test7[] = {-3, 9, -1, 3, 2, 31};\n    assert(func0(test7, 6) == true);\n    \n    int test8[] = {-3, 9, -1, 4, 2, 30};\n    assert(func0(test8, 6) == false);\n    \n    int test9[] = {-3, 9, -1, 4, 2, 31};\n    assert(func0(test9, 6) == false);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1141 <func0+0x41>\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  cmp    %r8,%r9\n  je     1141 <func0+0x41>\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  jmp    1128 <func0+0x28>\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    1138 <func0+0x38>\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    1120 <func0+0x20>\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\n  add    $0x1,%r8\n  cmp    %r8,%r9\n  jne    1116 <func0+0x16>\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%r9\n  mov    $0x1,%r8d\n  cmp    %r8,%r9\n  je     L0\nL4:\n  mov    -0x4(%rdi,%r8,4),%edx\n  mov    %r8,%rax\n  jmp    L1\nL3:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jle    L2\nL1:\n  mov    %edx,%ecx\n  add    (%rdi,%rax,4),%ecx\n  jne    L3\n  mov    $0x1,%eax\n  ret\n  nopl   (%rax)\nL2:\n  add    $0x1,%r8\n  cmp    %r8,%r9\n  jne    L4\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4417
            },
            "L1": {
                "label": "L1",
                "addr": 4392
            },
            "L2": {
                "label": "L2",
                "addr": 4408
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4374
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 44,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %edi,-0x44(%rbp)\n  mov    %esi,-0x48(%rbp)\n  mov    %rdx,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x38(%rbp)\n  jmp    116e <func0+0x55>\n  mov    -0x44(%rbp),%eax\n  cltd\n  idivl  -0x48(%rbp)\n  mov    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  mov    %ecx,%edx\n  cltq\n  mov    %dl,-0x30(%rbp,%rax,1)\n  mov    -0x44(%rbp),%eax\n  cltd\n  idivl  -0x48(%rbp)\n  mov    %eax,-0x44(%rbp)\n  cmpl   $0x0,-0x44(%rbp)\n  jg     1147 <func0+0x2e>\n  movl   $0x0,-0x34(%rbp)\n  jmp    11a0 <func0+0x87>\n  subl   $0x1,-0x38(%rbp)\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movslq %eax,%rdx\n  mov    -0x50(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%eax\n  cltq\n  movzbl -0x30(%rbp,%rax,1),%eax\n  mov    %al,(%rdx)\n  cmpl   $0x0,-0x38(%rbp)\n  jg     117d <func0+0x64>\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x50(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     11cb <func0+0xb2>\n  call   1050 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %edi,-0x44(%rbp)\n  mov    %esi,-0x48(%rbp)\n  mov    %rdx,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x38(%rbp)\n  jmp    L0\nL1:\n  mov    -0x44(%rbp),%eax\n  cltd\n  idivl  -0x48(%rbp)\n  mov    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x38(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x38(%rbp)\n  mov    %ecx,%edx\n  cltq\n  mov    %dl,-0x30(%rbp,%rax,1)\n  mov    -0x44(%rbp),%eax\n  cltd\n  idivl  -0x48(%rbp)\n  mov    %eax,-0x44(%rbp)\nL0:\n  cmpl   $0x0,-0x44(%rbp)\n  jg     L1\n  movl   $0x0,-0x34(%rbp)\n  jmp    L2\nL3:\n  subl   $0x1,-0x38(%rbp)\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movslq %eax,%rdx\n  mov    -0x50(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%eax\n  cltq\n  movzbl -0x30(%rbp,%rax,1),%eax\n  mov    %al,(%rdx)\nL2:\n  cmpl   $0x0,-0x38(%rbp)\n  jg     L3\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x50(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     L4\n  call   <__stack_chk_fail@plt>\nL4:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4462
            },
            "L1": {
                "label": "L1",
                "addr": 4423
            },
            "L2": {
                "label": "L2",
                "addr": 4512
            },
            "L3": {
                "label": "L3",
                "addr": 4477
            },
            "L4": {
                "label": "L4",
                "addr": 4555
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 44,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    11a6 <func0+0x8d>\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r11\n  mov    %ecx,%r8d\n  mov    %edi,%eax\n  cltd\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r11,%rcx,1)\n  mov    %eax,%edi\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     1142 <func0+0x29>\n  test   %r8d,%r8d\n  jle    11ae <func0+0x95>\n  movslq %r8d,%rcx\n  lea    (%rsp,%rcx,1),%rax\n  mov    %r9,%rdx\n  lea    -0x1(%rsp,%rcx,1),%rsi\n  lea    -0x1(%r8),%ecx\n  sub    %rcx,%rsi\n  movzbl -0x1(%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    1176 <func0+0x5d>\n  movslq %r8d,%r8\n  movb   $0x0,(%r9,%r8,1)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11b6 <func0+0x9d>\n  add    $0x38,%rsp\n  ret\n  mov    $0x0,%r8d\n  jmp    1189 <func0+0x70>\n  mov    $0x0,%r8d\n  jmp    1189 <func0+0x70>\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    L0\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r11\nL1:\n  mov    %ecx,%r8d\n  mov    %edi,%eax\n  cltd\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r11,%rcx,1)\n  mov    %eax,%edi\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     L1\n  test   %r8d,%r8d\n  jle    L2\n  movslq %r8d,%rcx\n  lea    (%rsp,%rcx,1),%rax\n  mov    %r9,%rdx\n  lea    -0x1(%rsp,%rcx,1),%rsi\n  lea    -0x1(%r8),%ecx\n  sub    %rcx,%rsi\nL3:\n  movzbl -0x1(%rax),%ecx\n  mov    %cl,(%rdx)\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  cmp    %rsi,%rax\n  jne    L3\nL5:\n  movslq %r8d,%r8\n  movb   $0x0,(%r9,%r8,1)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L4\n  add    $0x38,%rsp\n  ret\nL0:\n  mov    $0x0,%r8d\n  jmp    L5\nL2:\n  mov    $0x0,%r8d\n  jmp    L5\nL4:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4518
            },
            "L1": {
                "label": "L1",
                "addr": 4418
            },
            "L2": {
                "label": "L2",
                "addr": 4526
            },
            "L3": {
                "label": "L3",
                "addr": 4470
            },
            "L4": {
                "label": "L4",
                "addr": 4534
            },
            "L5": {
                "label": "L5",
                "addr": 4489
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 44,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rdx\n  mov    %rdx,0x28(%rsp)\n  xor    %edx,%edx\n  test   %edi,%edi\n  jle    1196 <func0+0x76>\n  mov    %edi,%eax\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r8\n  nopl   0x0(%rax,%rax,1)\n  cltd\n  mov    %ecx,%edi\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rcx,1)\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     1150 <func0+0x30>\n  movslq %edi,%r8\n  lea    -0x1(%rdi),%esi\n  mov    %r9,%rax\n  lea    (%rsp,%r8,1),%rcx\n  add    %r9,%rsi\n  jmp    1188 <func0+0x68>\n  cs nopw 0x0(%rax,%rax,1)\n  movzbl -0x1(%rcx),%edx\n  add    $0x1,%rax\n  mov    %dl,(%rax)\n  sub    $0x1,%rcx\n  cmp    %rsi,%rax\n  jne    1180 <func0+0x60>\n  add    %r8,%r9\n  movb   $0x0,(%r9)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11af <func0+0x8f>\n  add    $0x38,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rdx\n  mov    %rdx,0x28(%rsp)\n  xor    %edx,%edx\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%eax\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r8\n  nopl   0x0(%rax,%rax,1)\nL1:\n  cltd\n  mov    %ecx,%edi\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rcx,1)\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     L1\n  movslq %edi,%r8\n  lea    -0x1(%rdi),%esi\n  mov    %r9,%rax\n  lea    (%rsp,%r8,1),%rcx\n  add    %r9,%rsi\n  jmp    L2\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  movzbl -0x1(%rcx),%edx\n  add    $0x1,%rax\nL2:\n  mov    %dl,(%rax)\n  sub    $0x1,%rcx\n  cmp    %rsi,%rax\n  jne    L3\n  add    %r8,%r9\nL0:\n  movb   $0x0,(%r9)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L4\n  add    $0x38,%rsp\n  ret\nL4:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4502
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            },
            "L2": {
                "label": "L2",
                "addr": 4488
            },
            "L3": {
                "label": "L3",
                "addr": 4480
            },
            "L4": {
                "label": "L4",
                "addr": 4527
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 44,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int x, int base, char *out) {\n    int index = 0;\n    char temp[33];\n    while (x > 0) {\n        temp[index++] = (x % base) + '0';\n        x = x / base;\n    }\n    int j = 0;\n    while(index > 0) {\n        out[j++] = temp[--index];\n    }\n    out[j] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char buffer[33];\n    \n    func0(8, 3, buffer);\n    assert(strcmp(buffer, \"22\") == 0);\n    \n    func0(9, 3, buffer);\n    assert(strcmp(buffer, \"100\") == 0);\n    \n    func0(234, 2, buffer);\n    assert(strcmp(buffer, \"11101010\") == 0);\n    \n    func0(16, 2, buffer);\n    assert(strcmp(buffer, \"10000\") == 0);\n    \n    func0(8, 2, buffer);\n    assert(strcmp(buffer, \"1000\") == 0);\n    \n    func0(7, 2, buffer);\n    assert(strcmp(buffer, \"111\") == 0);\n    \n    for (int x = 2; x < 8; x++) {\n        char expected[33];\n        sprintf(expected, \"%d\", x);\n        func0(x, x + 1, buffer);\n        assert(strcmp(buffer, expected) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rdx\n  mov    %rdx,0x28(%rsp)\n  xor    %edx,%edx\n  test   %edi,%edi\n  jle    1196 <func0+0x76>\n  mov    %edi,%eax\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r8\n  nopl   0x0(%rax,%rax,1)\n  cltd\n  mov    %ecx,%edi\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rcx,1)\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     1150 <func0+0x30>\n  mov    %rsp,%rax\n  movslq %edi,%r8\n  lea    -0x1(%rdi),%ecx\n  lea    -0x1(%rax,%r8,1),%rdx\n  lea    0x1(%r9,%rcx,1),%rsi\n  mov    %r9,%rax\n  nopw   0x0(%rax,%rax,1)\n  movzbl (%rdx),%ecx\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  mov    %cl,-0x1(%rax)\n  cmp    %rax,%rsi\n  jne    1180 <func0+0x60>\n  add    %r8,%r9\n  movb   $0x0,(%r9)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11af <func0+0x8f>\n  add    $0x38,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x38,%rsp\n  mov    %rdx,%r9\n  mov    %fs:0x28,%rdx\n  mov    %rdx,0x28(%rsp)\n  xor    %edx,%edx\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%eax\n  mov    $0x1,%ecx\n  lea    -0x1(%rsp),%r8\n  nopl   0x0(%rax,%rax,1)\nL1:\n  cltd\n  mov    %ecx,%edi\n  idiv   %esi\n  add    $0x30,%edx\n  mov    %dl,(%r8,%rcx,1)\n  add    $0x1,%rcx\n  test   %eax,%eax\n  jg     L1\n  mov    %rsp,%rax\n  movslq %edi,%r8\n  lea    -0x1(%rdi),%ecx\n  lea    -0x1(%rax,%r8,1),%rdx\n  lea    0x1(%r9,%rcx,1),%rsi\n  mov    %r9,%rax\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movzbl (%rdx),%ecx\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  mov    %cl,-0x1(%rax)\n  cmp    %rax,%rsi\n  jne    L2\n  add    %r8,%r9\nL0:\n  movb   $0x0,(%r9)\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  add    $0x38,%rsp\n  ret\nL3:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4502
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            },
            "L2": {
                "label": "L2",
                "addr": 4480
            },
            "L3": {
                "label": "L3",
                "addr": 4527
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 45,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  -0x8(%rbp),%xmm1\n  movss  0xee0(%rip),%xmm0        # 2000 <_fini+0xed8>\n  mulss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  -0x8(%rbp),%xmm1\n  movss  D0(%rip),%xmm0\n  mulss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3808
                ]
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000003f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f32",
                    "value": 0.5
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 45,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  0xef7(%rip),%xmm0        # 2000 <_fini+0xef4>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  D0(%rip),%xmm0\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3831
                ]
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000003f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f32",
                    "value": 0.5
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 45,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  0xef0(%rip),%xmm0        # 2000 <_fini+0xeec>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  D0(%rip),%xmm0\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3824
                ]
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000003f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f32",
                    "value": 0.5
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 45,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float h) {\n    return (a * h) * 0.5;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    assert(fabs(func0(5, 3) - 7.5) < 1e-4);\n    assert(fabs(func0(2, 2) - 2.0) < 1e-4);\n    assert(fabs(func0(10, 8) - 40.0) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  0xef0(%rip),%xmm0        # 2000 <_fini+0xeec>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mulss  %xmm1,%xmm0\n  mulss  D0(%rip),%xmm0\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3824
                ]
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000003f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f32",
                    "value": 0.5
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 46,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x1c0,%rsp\n  mov    %edi,-0x1b4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x1a0(%rbp)\n  movl   $0x0,-0x19c(%rbp)\n  movl   $0x2,-0x198(%rbp)\n  movl   $0x0,-0x194(%rbp)\n  movl   $0x4,-0x1a4(%rbp)\n  jmp    11d5 <func0+0xbc>\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x3,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x4,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  cltq\n  mov    %edx,-0x1a0(%rbp,%rax,4)\n  addl   $0x1,-0x1a4(%rbp)\n  mov    -0x1a4(%rbp),%eax\n  cmp    -0x1b4(%rbp),%eax\n  jle    1171 <func0+0x58>\n  mov    -0x1b4(%rbp),%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     1206 <func0+0xed>\n  call   1050 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x1c0,%rsp\n  mov    %edi,-0x1b4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x1a0(%rbp)\n  movl   $0x0,-0x19c(%rbp)\n  movl   $0x2,-0x198(%rbp)\n  movl   $0x0,-0x194(%rbp)\n  movl   $0x4,-0x1a4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x3,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x4,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  cltq\n  mov    %edx,-0x1a0(%rbp,%rax,4)\n  addl   $0x1,-0x1a4(%rbp)\nL0:\n  mov    -0x1a4(%rbp),%eax\n  cmp    -0x1b4(%rbp),%eax\n  jle    L1\n  mov    -0x1b4(%rbp),%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L2\n  call   <__stack_chk_fail@plt>\nL2:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4565
            },
            "L1": {
                "label": "L1",
                "addr": 4465
            },
            "L2": {
                "label": "L2",
                "addr": 4614
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 46,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movl   $0x0,(%rsp)\n  movl   $0x0,0x4(%rsp)\n  movl   $0x2,0x8(%rsp)\n  movl   $0x0,0xc(%rsp)\n  cmp    $0x3,%edi\n  jle    117d <func0+0x64>\n  mov    %rsp,%rax\n  lea    -0x4(%rdi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\n  mov    0x8(%rax),%edx\n  add    0xc(%rax),%edx\n  add    0x4(%rax),%edx\n  add    (%rax),%edx\n  mov    %edx,0x10(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    1166 <func0+0x4d>\n  movslq %edi,%rdi\n  mov    (%rsp,%rdi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    119e <func0+0x85>\n  add    $0x1a8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movl   $0x0,(%rsp)\n  movl   $0x0,0x4(%rsp)\n  movl   $0x2,0x8(%rsp)\n  movl   $0x0,0xc(%rsp)\n  cmp    $0x3,%edi\n  jle    L0\n  mov    %rsp,%rax\n  lea    -0x4(%rdi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\nL1:\n  mov    0x8(%rax),%edx\n  add    0xc(%rax),%edx\n  add    0x4(%rax),%edx\n  add    (%rax),%edx\n  mov    %edx,0x10(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L1\nL0:\n  movslq %edi,%rdi\n  mov    (%rsp,%rdi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L2\n  add    $0x1a8,%rsp\n  ret\nL2:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4477
            },
            "L1": {
                "label": "L1",
                "addr": 4454
            },
            "L2": {
                "label": "L2",
                "addr": 4510
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 46,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,(%rsp)\n  movq   $0x2,0x8(%rsp)\n  cmp    $0x3,%edi\n  jle    118f <func0+0x6f>\n  lea    -0x4(%rdi),%eax\n  lea    0x4(%rsp),%rdx\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  lea    0x8(%rsp,%rax,4),%r9\n  mov    $0x2,%ecx\n  xor    %eax,%eax\n  jmp    117c <func0+0x5c>\n  nop\n  mov    0x8(%rdx),%eax\n  mov    0x4(%rdx),%ecx\n  mov    (%rdx),%esi\n  mov    -0x4(%rdx),%r8d\n  add    %ecx,%eax\n  add    $0x4,%rdx\n  add    %esi,%eax\n  add    %r8d,%eax\n  mov    %eax,0x8(%rdx)\n  cmp    %rdx,%r9\n  jne    1170 <func0+0x50>\n  movslq %edi,%rdi\n  mov    (%rsp,%rdi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    11b0 <func0+0x90>\n  add    $0x1a8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,(%rsp)\n  movq   $0x2,0x8(%rsp)\n  cmp    $0x3,%edi\n  jle    L0\n  lea    -0x4(%rdi),%eax\n  lea    0x4(%rsp),%rdx\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  lea    0x8(%rsp,%rax,4),%r9\n  mov    $0x2,%ecx\n  xor    %eax,%eax\n  jmp    L1\n  nop\nL2:\n  mov    0x8(%rdx),%eax\n  mov    0x4(%rdx),%ecx\n  mov    (%rdx),%esi\n  mov    -0x4(%rdx),%r8d\nL1:\n  add    %ecx,%eax\n  add    $0x4,%rdx\n  add    %esi,%eax\n  add    %r8d,%eax\n  mov    %eax,0x8(%rdx)\n  cmp    %rdx,%r9\n  jne    L2\nL0:\n  movslq %edi,%rdi\n  mov    (%rsp,%rdi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L3\n  add    $0x1a8,%rsp\n  ret\nL3:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4495
            },
            "L1": {
                "label": "L1",
                "addr": 4476
            },
            "L2": {
                "label": "L2",
                "addr": 4464
            },
            "L3": {
                "label": "L3",
                "addr": 4528
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 46,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[100];\n    f[0] = 0;\n    f[1] = 0;\n    f[2] = 2;\n    f[3] = 0;\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] + f[i - 2] + f[i - 3] + f[i - 4];\n    }\n    return f[n];\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(5) == 4);\n    assert(func0(8) == 28);\n    assert(func0(10) == 104);\n    assert(func0(12) == 386);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movdqa 0xecd(%rip),%xmm0        # 2000 <_fini+0xdf8>\n  movslq %edi,%rsi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movaps %xmm0,(%rsp)\n  cmp    $0x3,%esi\n  jle    11da <func0+0xba>\n  lea    -0x1(%rsi),%r11d\n  cmp    $0x6,%esi\n  jle    11f8 <func0+0xd8>\n  mov    %rsp,%r10\n  xor    %r8d,%r8d\n  mov    $0x2,%edi\n  xor    %edx,%edx\n  mov    %r10,%rax\n  mov    $0x4,%ecx\n  lea    (%rdi,%r8,1),%r9d\n  add    $0xc,%rax\n  add    %r9d,%edx\n  add    -0xc(%rax),%edx\n  lea    (%rdx,%r8,1),%r9d\n  mov    %edx,0x4(%rax)\n  add    %r9d,%edi\n  add    -0x8(%rax),%edi\n  lea    (%rdx,%rdi,1),%r9d\n  mov    %edi,0x8(%rax)\n  add    %r9d,%r8d\n  mov    %ecx,%r9d\n  add    -0x4(%rax),%r8d\n  add    $0x3,%ecx\n  add    $0x4,%r9d\n  mov    %r8d,0xc(%rax)\n  cmp    %r9d,%r11d\n  jg     1178 <func0+0x58>\n  movslq %ecx,%rax\n  lea    (%r10,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\n  mov    -0x4(%rdx),%eax\n  add    $0x1,%ecx\n  add    -0x8(%rdx),%eax\n  add    $0x4,%rdx\n  add    -0x10(%rdx),%eax\n  add    -0x14(%rdx),%eax\n  mov    %eax,-0x4(%rdx)\n  cmp    %ecx,%esi\n  jge    11c0 <func0+0xa0>\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    1202 <func0+0xe2>\n  add    $0x1a8,%rsp\n  ret\n  mov    $0x4,%ecx\n  mov    %rsp,%r10\n  jmp    11b4 <func0+0x94>\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movdqa D0(%rip),%xmm0\n  movslq %edi,%rsi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  movaps %xmm0,(%rsp)\n  cmp    $0x3,%esi\n  jle    L0\n  lea    -0x1(%rsi),%r11d\n  cmp    $0x6,%esi\n  jle    L1\n  mov    %rsp,%r10\n  xor    %r8d,%r8d\n  mov    $0x2,%edi\n  xor    %edx,%edx\n  mov    %r10,%rax\n  mov    $0x4,%ecx\nL2:\n  lea    (%rdi,%r8,1),%r9d\n  add    $0xc,%rax\n  add    %r9d,%edx\n  add    -0xc(%rax),%edx\n  lea    (%rdx,%r8,1),%r9d\n  mov    %edx,0x4(%rax)\n  add    %r9d,%edi\n  add    -0x8(%rax),%edi\n  lea    (%rdx,%rdi,1),%r9d\n  mov    %edi,0x8(%rax)\n  add    %r9d,%r8d\n  mov    %ecx,%r9d\n  add    -0x4(%rax),%r8d\n  add    $0x3,%ecx\n  add    $0x4,%r9d\n  mov    %r8d,0xc(%rax)\n  cmp    %r9d,%r11d\n  jg     L2\nL5:\n  movslq %ecx,%rax\n  lea    (%r10,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    -0x4(%rdx),%eax\n  add    $0x1,%ecx\n  add    -0x8(%rdx),%eax\n  add    $0x4,%rdx\n  add    -0x10(%rdx),%eax\n  add    -0x14(%rdx),%eax\n  mov    %eax,-0x4(%rdx)\n  cmp    %ecx,%esi\n  jge    L3\nL0:\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L4\n  add    $0x1a8,%rsp\n  ret\nL1:\n  mov    $0x4,%ecx\n  mov    %rsp,%r10\n  jmp    L5\nL4:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3789
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4570
            },
            "L1": {
                "label": "L1",
                "addr": 4600
            },
            "L2": {
                "label": "L2",
                "addr": 4472
            },
            "L3": {
                "label": "L3",
                "addr": 4544
            },
            "L4": {
                "label": "L4",
                "addr": 4610
            },
            "L5": {
                "label": "L5",
                "addr": 4532
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00000000000000000200000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        2,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 47,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11d5 <func0+0xdc>\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    11c5 <func0+0xcc>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    11c1 <func0+0xc8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  -0x4(%rbp),%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1122 <func0+0x29>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1114 <func0+0x1b>\n  mov    -0x1c(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1217 <func0+0x11e>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  jmp    1269 <func0+0x170>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  addss  %xmm0,%xmm1\n  movss  0xd9b(%rip),%xmm0        # 2000 <_fini+0xd94>\n  mulss  %xmm1,%xmm0\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL4:\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    L1\nL3:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L2\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  movss  %xmm0,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movss  (%rdx),%xmm0\n  movss  %xmm0,(%rax)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  -0x4(%rbp),%xmm0\n  movss  %xmm0,(%rax)\nL2:\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  mov    -0x1c(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L5\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  jmp    L6\nL5:\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  addss  %xmm0,%xmm1\n  movss  D0(%rip),%xmm0\n  mulss  %xmm1,%xmm0\nL6:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3483
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4565
            },
            "L1": {
                "label": "L1",
                "addr": 4549
            },
            "L2": {
                "label": "L2",
                "addr": 4545
            },
            "L3": {
                "label": "L3",
                "addr": 4386
            },
            "L4": {
                "label": "L4",
                "addr": 4372
            },
            "L5": {
                "label": "L5",
                "addr": 4631
            },
            "L6": {
                "label": "L6",
                "addr": 4713
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000003f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f32",
                    "value": 0.5
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 47,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r11\n  mov    %esi,%edi\n  test   %esi,%esi\n  jle    115e <func0+0x65>\n  lea    0x4(%r11),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r8d\n  mov    $0x1,%esi\n  lea    0x8(%r11),%r9\n  jmp    1146 <func0+0x4d>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     113e <func0+0x45>\n  movss  -0x4(%rdx),%xmm0\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    111c <func0+0x23>\n  movss  %xmm1,-0x4(%rdx)\n  movss  %xmm0,(%rax)\n  jmp    111c <func0+0x23>\n  add    $0x1,%rsi\n  add    $0x4,%rdx\n  cmp    %r8,%rsi\n  je     115e <func0+0x65>\n  mov    %r10d,%eax\n  sub    %esi,%eax\n  lea    -0x1(%rsi,%rax,1),%rax\n  lea    (%r9,%rax,4),%rcx\n  mov    %rdx,%rax\n  jmp    1125 <func0+0x2c>\n  mov    %edi,%edx\n  shr    $0x1f,%edx\n  lea    (%rdi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     1191 <func0+0x98>\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%r11,%rax,4),%xmm0\n  addss  (%r11,%rax,4),%xmm0\n  mulss  0xe70(%rip),%xmm0        # 2000 <_fini+0xe60>\n  ret\n  mov    %edx,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  (%r11,%rax,4),%xmm0\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r11\n  mov    %esi,%edi\n  test   %esi,%esi\n  jle    L0\n  lea    0x4(%r11),%rdx\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r8d\n  mov    $0x1,%esi\n  lea    0x8(%r11),%r9\n  jmp    L1\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L2\nL4:\n  movss  -0x4(%rdx),%xmm0\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L3\n  movss  %xmm1,-0x4(%rdx)\n  movss  %xmm0,(%rax)\n  jmp    L3\nL2:\n  add    $0x1,%rsi\n  add    $0x4,%rdx\nL1:\n  cmp    %r8,%rsi\n  je     L0\n  mov    %r10d,%eax\n  sub    %esi,%eax\n  lea    -0x1(%rsi,%rax,1),%rax\n  lea    (%r9,%rax,4),%rcx\n  mov    %rdx,%rax\n  jmp    L4\nL0:\n  mov    %edi,%edx\n  shr    $0x1f,%edx\n  lea    (%rdi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     L5\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%r11,%rax,4),%xmm0\n  addss  (%r11,%rax,4),%xmm0\n  mulss  D0(%rip),%xmm0\n  ret\nL5:\n  mov    %edx,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  (%r11,%rax,4),%xmm0\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3696
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4446
            },
            "L1": {
                "label": "L1",
                "addr": 4422
            },
            "L2": {
                "label": "L2",
                "addr": 4414
            },
            "L3": {
                "label": "L3",
                "addr": 4380
            },
            "L4": {
                "label": "L4",
                "addr": 4389
            },
            "L5": {
                "label": "L5",
                "addr": 4497
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000003f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f32",
                    "value": 0.5
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 47,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r11\n  mov    %esi,%edi\n  test   %esi,%esi\n  jle    1175 <func0+0x75>\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r8d\n  mov    $0x1,%esi\n  lea    0x4(%r11),%rdx\n  lea    0x8(%r11),%r9\n  cmp    %r8,%rsi\n  je     1175 <func0+0x75>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    %r10d,%eax\n  sub    %esi,%eax\n  lea    -0x1(%rsi,%rax,1),%rax\n  lea    (%r9,%rax,4),%rcx\n  mov    %rdx,%rax\n  nopl   0x0(%rax)\n  movss  -0x4(%rdx),%xmm0\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    115f <func0+0x5f>\n  movss  %xmm1,-0x4(%rdx)\n  movss  %xmm0,(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    1148 <func0+0x48>\n  add    $0x1,%rsi\n  add    $0x4,%rdx\n  cmp    %r8,%rsi\n  jne    1130 <func0+0x30>\n  mov    %edi,%edx\n  shr    $0x1f,%edx\n  lea    (%rdi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     11a8 <func0+0xa8>\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%r11,%rax,4),%xmm0\n  addss  (%r11,%rax,4),%xmm0\n  mulss  0xe59(%rip),%xmm0        # 2000 <_fini+0xe4c>\n  ret\n  sar    %edi\n  movslq %edi,%rax\n  movss  (%r11,%rax,4),%xmm0\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r11\n  mov    %esi,%edi\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%r10d\n  mov    %esi,%r8d\n  mov    $0x1,%esi\n  lea    0x4(%r11),%rdx\n  lea    0x8(%r11),%r9\n  cmp    %r8,%rsi\n  je     L0\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    %r10d,%eax\n  sub    %esi,%eax\n  lea    -0x1(%rsi,%rax,1),%rax\n  lea    (%r9,%rax,4),%rcx\n  mov    %rdx,%rax\n  nopl   0x0(%rax)\nL2:\n  movss  -0x4(%rdx),%xmm0\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L1\n  movss  %xmm1,-0x4(%rdx)\n  movss  %xmm0,(%rax)\nL1:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L2\n  add    $0x1,%rsi\n  add    $0x4,%rdx\n  cmp    %r8,%rsi\n  jne    L3\nL0:\n  mov    %edi,%edx\n  shr    $0x1f,%edx\n  lea    (%rdi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     L4\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %edi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%r11,%rax,4),%xmm0\n  addss  (%r11,%rax,4),%xmm0\n  mulss  D0(%rip),%xmm0\n  ret\nL4:\n  sar    %edi\n  movslq %edi,%rax\n  movss  (%r11,%rax,4),%xmm0\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3673
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4469
            },
            "L1": {
                "label": "L1",
                "addr": 4447
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            },
            "L3": {
                "label": "L3",
                "addr": 4400
            },
            "L4": {
                "label": "L4",
                "addr": 4520
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000003f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f32",
                    "value": 0.5
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 47,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nfloat func0(float *l, int size) {\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (l[i] > l[j]) {\n                float temp = l[i];\n                l[i] = l[j];\n                l[j] = temp;\n            }\n        }\n    }\n    if (size % 2 == 1) return l[size / 2];\n    return 0.5 * (l[size / 2] + l[size / 2 - 1]);\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <math.h>\n\nint main() {\n    float list1[] = {3, 1, 2, 4, 5};\n    assert(fabs(func0(list1, 5) - 3) < 1e-4);\n\n    float list2[] = {-10, 4, 6, 1000, 10, 20};\n    assert(fabs(func0(list2, 6) - 8.0) < 1e-4);\n\n    float list3[] = {5};\n    assert(fabs(func0(list3, 1) - 5) < 1e-4);\n\n    float list4[] = {6, 5};\n    assert(fabs(func0(list4, 2) - 5.5) < 1e-4);\n\n    float list5[] = {8, 1, 3, 9, 9, 2, 7};\n    assert(fabs(func0(list5, 7) - 7) < 1e-4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  cmp    $0x1,%esi\n  jle    1154 <func0+0x54>\n  mov    %rdi,%rdx\n  movslq %esi,%r8\n  mov    $0x1,%edi\n  nopw   0x0(%rax,%rax,1)\n  mov    %rdi,%rax\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rdx),%xmm0\n  movss  (%rcx,%rax,4),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    113f <func0+0x3f>\n  movss  %xmm1,(%rdx)\n  movss  %xmm0,(%rcx,%rax,4)\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     1128 <func0+0x28>\n  add    $0x1,%rdi\n  add    $0x4,%rdx\n  cmp    %r8,%rdi\n  jne    1120 <func0+0x20>\n  mov    %esi,%edx\n  shr    $0x1f,%edx\n  lea    (%rsi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     1185 <func0+0x85>\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %esi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%rcx,%rax,4),%xmm0\n  addss  (%rcx,%rax,4),%xmm0\n  mulss  0xe7c(%rip),%xmm0        # 2000 <_fini+0xe70>\n  ret\n  sar    %esi\n  movslq %esi,%rax\n  movss  (%rcx,%rax,4),%xmm0\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %rdi,%rdx\n  movslq %esi,%r8\n  mov    $0x1,%edi\n  nopw   0x0(%rax,%rax,1)\nL3:\n  mov    %rdi,%rax\n  nopl   0x0(%rax,%rax,1)\nL2:\n  movss  (%rdx),%xmm0\n  movss  (%rcx,%rax,4),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L1\n  movss  %xmm1,(%rdx)\n  movss  %xmm0,(%rcx,%rax,4)\nL1:\n  add    $0x1,%rax\n  cmp    %eax,%esi\n  jg     L2\n  add    $0x1,%rdi\n  add    $0x4,%rdx\n  cmp    %r8,%rdi\n  jne    L3\nL0:\n  mov    %esi,%edx\n  shr    $0x1f,%edx\n  lea    (%rsi,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     L4\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %esi,%eax\n  sar    %eax\n  cltq\n  movss  -0x4(%rcx,%rax,4),%xmm0\n  addss  (%rcx,%rax,4),%xmm0\n  mulss  D0(%rip),%xmm0\n  ret\nL4:\n  sar    %esi\n  movslq %esi,%rax\n  movss  (%rcx,%rax,4),%xmm0\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3708
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4436
            },
            "L1": {
                "label": "L1",
                "addr": 4415
            },
            "L2": {
                "label": "L2",
                "addr": 4392
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4485
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000003f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f32",
                    "value": 0.5
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 48,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1176 <func0+0x5d>\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x8(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     1172 <func0+0x59>\n  mov    $0x0,%eax\n  jmp    118c <func0+0x73>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x8(%rbp)\n  jl     1141 <func0+0x28>\n  mov    $0x1,%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL3:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x8(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     L1\n  mov    $0x0,%eax\n  jmp    L2\nL1:\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x8(%rbp)\n  jl     L3\n  mov    $0x1,%eax\nL2:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4470
            },
            "L1": {
                "label": "L1",
                "addr": 4466
            },
            "L2": {
                "label": "L2",
                "addr": 4492
            },
            "L3": {
                "label": "L3",
                "addr": 4417
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 48,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    115c <func0+0x43>\n  cltq\n  lea    -0x1(%rbx,%rax,1),%rdx\n  mov    $0x0,%eax\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rbx,%rax,1)\n  jne    1163 <func0+0x4a>\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     1140 <func0+0x27>\n  mov    $0x1,%eax\n  jmp    1168 <func0+0x4f>\n  mov    $0x1,%eax\n  jmp    1168 <func0+0x4f>\n  mov    $0x0,%eax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    L0\n  cltq\n  lea    -0x1(%rbx,%rax,1),%rdx\n  mov    $0x0,%eax\nL2:\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rbx,%rax,1)\n  jne    L1\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     L2\n  mov    $0x1,%eax\n  jmp    L3\nL0:\n  mov    $0x1,%eax\n  jmp    L3\nL1:\n  mov    $0x0,%eax\nL3:\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4444
            },
            "L1": {
                "label": "L1",
                "addr": 4451
            },
            "L2": {
                "label": "L2",
                "addr": 4416
            },
            "L3": {
                "label": "L3",
                "addr": 4456
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 48,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    1170 <func0+0x50>\n  sub    $0x1,%eax\n  xor    %edx,%edx\n  cltq\n  add    %rbx,%rax\n  jmp    115c <func0+0x3c>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%ecx\n  jle    1170 <func0+0x50>\n  movzbl (%rax),%esi\n  cmp    %sil,(%rbx,%rdx,1)\n  je     1150 <func0+0x30>\n  xor    %eax,%eax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\n  mov    $0x1,%eax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    L0\n  sub    $0x1,%eax\n  xor    %edx,%edx\n  cltq\n  add    %rbx,%rax\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL2:\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%ecx\n  jle    L0\nL1:\n  movzbl (%rax),%esi\n  cmp    %sil,(%rbx,%rdx,1)\n  je     L2\n  xor    %eax,%eax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x1,%eax\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4464
            },
            "L1": {
                "label": "L1",
                "addr": 4444
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 48,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *text) {\n    int len = strlen(text);\n    for (int i = 0; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == true);\n    assert(func0(\"aba\") == true);\n    assert(func0(\"aaaaa\") == true);\n    assert(func0(\"zbcd\") == false);\n    assert(func0(\"xywyx\") == true);\n    assert(func0(\"xywyz\") == false);\n    assert(func0(\"xywzx\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    1170 <func0+0x50>\n  sub    $0x1,%eax\n  xor    %edx,%edx\n  cltq\n  add    %rbx,%rax\n  jmp    115c <func0+0x3c>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%ecx\n  jle    1170 <func0+0x50>\n  movzbl (%rax),%esi\n  cmp    %sil,(%rbx,%rdx,1)\n  je     1150 <func0+0x30>\n  xor    %eax,%eax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\n  mov    $0x1,%eax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    L0\n  sub    $0x1,%eax\n  xor    %edx,%edx\n  cltq\n  add    %rbx,%rax\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL2:\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%ecx\n  jle    L0\nL1:\n  movzbl (%rax),%esi\n  cmp    %sil,(%rbx,%rdx,1)\n  je     L2\n  xor    %eax,%eax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x1,%eax\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4464
            },
            "L1": {
                "label": "L1",
                "addr": 4444
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 49,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1127 <func0+0x2e>\n  mov    -0x8(%rbp),%eax\n  add    %eax,%eax\n  cltd\n  idivl  -0x18(%rbp)\n  mov    %edx,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     1117 <func0+0x1e>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x8(%rbp),%eax\n  add    %eax,%eax\n  cltd\n  idivl  -0x18(%rbp)\n  mov    %edx,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L1\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4391
            },
            "L1": {
                "label": "L1",
                "addr": 4375
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 49,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    111b <func0+0x22>\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\n  lea    (%rdx,%rdx,1),%eax\n  cltd\n  idiv   %esi\n  add    $0x1,%ecx\n  cmp    %ecx,%edi\n  jne    110b <func0+0x12>\n  mov    %edx,%eax\n  ret\n  mov    $0x1,%edx\n  jmp    1118 <func0+0x1f>",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\nL1:\n  lea    (%rdx,%rdx,1),%eax\n  cltd\n  idiv   %esi\n  add    $0x1,%ecx\n  cmp    %ecx,%edi\n  jne    L1\nL2:\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x1,%edx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4379
            },
            "L1": {
                "label": "L1",
                "addr": 4363
            },
            "L2": {
                "label": "L2",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 49,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1120 <func0+0x20>\n  xor    %ecx,%ecx\n  mov    $0x1,%edx\n  nop\n  lea    (%rdx,%rdx,1),%eax\n  add    $0x1,%ecx\n  cltd\n  idiv   %esi\n  cmp    %ecx,%edi\n  jne    1110 <func0+0x10>\n  mov    %edx,%eax\n  ret\n  mov    $0x1,%edx\n  mov    %edx,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %ecx,%ecx\n  mov    $0x1,%edx\n  nop\nL1:\n  lea    (%rdx,%rdx,1),%eax\n  add    $0x1,%ecx\n  cltd\n  idiv   %esi\n  cmp    %ecx,%edi\n  jne    L1\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x1,%edx\n  mov    %edx,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4384
            },
            "L1": {
                "label": "L1",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 49,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int p) {\n    int out = 1;\n    for (int i = 0; i < n; i++)\n        out = (out * 2) % p;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(func0(3, 5) == 3);\n    assert(func0(1101, 101) == 2);\n    assert(func0(0, 101) == 1);\n    assert(func0(3, 11) == 8);\n    assert(func0(100, 101) == 1);\n    assert(func0(30, 5) == 4);\n    assert(func0(31, 5) == 3);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1120 <func0+0x20>\n  xor    %ecx,%ecx\n  mov    $0x1,%edx\n  nop\n  lea    (%rdx,%rdx,1),%eax\n  add    $0x1,%ecx\n  cltd\n  idiv   %esi\n  cmp    %ecx,%edi\n  jne    1110 <func0+0x10>\n  mov    %edx,%eax\n  ret\n  mov    $0x1,%edx\n  mov    %edx,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  xor    %ecx,%ecx\n  mov    $0x1,%edx\n  nop\nL1:\n  lea    (%rdx,%rdx,1),%eax\n  add    $0x1,%ecx\n  cltd\n  idiv   %esi\n  cmp    %ecx,%edi\n  jne    L1\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x1,%edx\n  mov    %edx,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4384
            },
            "L1": {
                "label": "L1",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 50,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  cmpl   $0x0,-0x2c(%rbp)\n  je     1139 <func0+0x20>\n  mov    $0x5,%eax\n  jmp    113e <func0+0x25>\n  mov    $0x15,%eax\n  mov    %eax,-0x18(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %rax,-0x8(%rbp)\n  movq   $0x0,-0x10(%rbp)\n  jmp    11ae <func0+0x95>\n  mov    -0x28(%rbp),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  lea    -0x61(%rax),%edx\n  mov    -0x18(%rbp),%eax\n  add    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x3,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x61,%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x28(%rbp),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x14(%rbp),%edx\n  mov    %dl,(%rax)\n  addq   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  cmp    -0x8(%rbp),%rax\n  jb     115b <func0+0x42>\n  nop\n  nop\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  cmpl   $0x0,-0x2c(%rbp)\n  je     L0\n  mov    $0x5,%eax\n  jmp    L1\nL0:\n  mov    $0x15,%eax\nL1:\n  mov    %eax,-0x18(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x8(%rbp)\n  movq   $0x0,-0x10(%rbp)\n  jmp    L2\nL3:\n  mov    -0x28(%rbp),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  lea    -0x61(%rax),%edx\n  mov    -0x18(%rbp),%eax\n  add    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x3,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x61,%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x28(%rbp),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x14(%rbp),%edx\n  mov    %dl,(%rax)\n  addq   $0x1,-0x10(%rbp)\nL2:\n  mov    -0x10(%rbp),%rax\n  cmp    -0x8(%rbp),%rax\n  jb     L3\n  nop\n  nop\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4409
            },
            "L1": {
                "label": "L1",
                "addr": 4414
            },
            "L2": {
                "label": "L2",
                "addr": 4526
            },
            "L3": {
                "label": "L3",
                "addr": 4443
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 50,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  cmp    $0x1,%esi\n  sbb    %ebx,%ebx\n  and    $0x10,%ebx\n  add    $0x5,%ebx\n  call   1050 <strlen@plt>\n  test   %rax,%rax\n  je     1172 <func0+0x59>\n  mov    %rbp,%rcx\n  lea    0x0(%rbp,%rax,1),%rdi\n  movsbl (%rcx),%eax\n  lea    -0x61(%rbx,%rax,1),%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x23,%rax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%edx\n  add    $0x61,%edx\n  mov    %dl,(%rcx)\n  add    $0x1,%rcx\n  cmp    %rdi,%rcx\n  jne    1143 <func0+0x2a>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  cmp    $0x1,%esi\n  sbb    %ebx,%ebx\n  and    $0x10,%ebx\n  add    $0x5,%ebx\n  call   <strlen@plt>\n  test   %rax,%rax\n  je     L0\n  mov    %rbp,%rcx\n  lea    0x0(%rbp,%rax,1),%rdi\nL1:\n  movsbl (%rcx),%eax\n  lea    -0x61(%rbx,%rax,1),%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x23,%rax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%edx\n  add    $0x61,%edx\n  mov    %dl,(%rcx)\n  add    $0x1,%rcx\n  cmp    %rdi,%rcx\n  jne    L1\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4466
            },
            "L1": {
                "label": "L1",
                "addr": 4419
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 50,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  cmp    $0x1,%esi\n  sbb    %ebp,%ebp\n  and    $0x10,%ebp\n  add    $0x5,%ebp\n  call   1050 <strlen@plt>\n  test   %rax,%rax\n  je     1180 <func0+0x60>\n  mov    %rbx,%rdi\n  add    %rbx,%rax\n  nopl   0x0(%rax,%rax,1)\n  movsbl (%rdi),%edx\n  add    $0x1,%rdi\n  lea    -0x61(%rbp,%rdx,1),%ecx\n  movslq %ecx,%rdx\n  mov    %ecx,%esi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%esi\n  sar    $0x23,%rdx\n  sub    %esi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%ecx\n  add    $0x61,%ecx\n  mov    %cl,-0x1(%rdi)\n  cmp    %rdi,%rax\n  jne    1150 <func0+0x30>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  cmp    $0x1,%esi\n  sbb    %ebp,%ebp\n  and    $0x10,%ebp\n  add    $0x5,%ebp\n  call   <strlen@plt>\n  test   %rax,%rax\n  je     L0\n  mov    %rbx,%rdi\n  add    %rbx,%rax\n  nopl   0x0(%rax,%rax,1)\nL1:\n  movsbl (%rdi),%edx\n  add    $0x1,%rdi\n  lea    -0x61(%rbp,%rdx,1),%ecx\n  movslq %ecx,%rdx\n  mov    %ecx,%esi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%esi\n  sar    $0x23,%rdx\n  sub    %esi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%ecx\n  add    $0x61,%ecx\n  mov    %cl,-0x1(%rdi)\n  cmp    %rdi,%rax\n  jne    L1\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4480
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 50,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *s, int encode) {\n    int shift = encode ? 5 : 21;\n    size_t len = strlen(s);\n    for (size_t i = 0; i < len; i++) {\n        int w = ((s[i] - 'a' + shift) % 26) + 'a';\n        s[i] = (char)w;\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <time.h>\n\nint main() {\n    srand((unsigned int)time(NULL));\n\n    for (int i = 0; i < 100; i++) {\n        int l = 10 + rand() % 11;\n        char *str = (char *)malloc(l + 1);\n        for (int j = 0; j < l; j++) {\n            char chr = 'a' + rand() % 26;\n            str[j] = chr;\n        }\n        str[l] = '\\0';\n\n        char *encoded_str = (char *)malloc(l + 1);\n        strcpy(encoded_str, str);\n        func0(encoded_str, 1);\n        func0(encoded_str, 0);\n        assert(strcmp(encoded_str, str) == 0);\n\n        free(str);\n        free(encoded_str);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  cmp    $0x1,%esi\n  sbb    %ebp,%ebp\n  and    $0x10,%ebp\n  add    $0x5,%ebp\n  call   1050 <strlen@plt>\n  test   %rax,%rax\n  je     15e8 <func0+0x4c8>\n  mov    %rax,%rdx\n  lea    -0x1(%rax),%rax\n  cmp    $0xe,%rax\n  jbe    15ef <func0+0x4cf>\n  movd   %ebp,%xmm2\n  mov    %rdx,%rcx\n  movdqa 0xe9a(%rip),%xmm5        # 2000 <_fini+0xa08>\n  movdqa 0xea2(%rip),%xmm4        # 2010 <_fini+0xa18>\n  punpcklwd %xmm2,%xmm2\n  and    $0xfffffffffffffff0,%rcx\n  pxor   %xmm6,%xmm6\n  mov    %rbx,%rax\n  movdqa 0xe9b(%rip),%xmm3        # 2020 <_fini+0xa28>\n  movdqa 0xea3(%rip),%xmm7        # 2030 <_fini+0xa38>\n  pshufd $0x0,%xmm2,%xmm2\n  add    %rbx,%rcx\n  nopl   (%rax)\n  movdqu (%rax),%xmm1\n  movdqa %xmm6,%xmm9\n  add    $0x10,%rax\n  pcmpgtb %xmm1,%xmm9\n  movdqa %xmm1,%xmm8\n  movdqa %xmm1,%xmm0\n  punpcklbw %xmm9,%xmm8\n  punpckhbw %xmm9,%xmm0\n  paddw  %xmm5,%xmm8\n  paddw  %xmm5,%xmm0\n  paddw  %xmm2,%xmm8\n  paddw  %xmm2,%xmm0\n  movdqa %xmm8,%xmm9\n  movdqa %xmm8,%xmm1\n  pmulhw %xmm4,%xmm9\n  psraw  $0xf,%xmm1\n  psraw  $0x3,%xmm9\n  psubw  %xmm1,%xmm9\n  movdqa %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x2,%xmm1\n  paddw  %xmm9,%xmm1\n  movdqa %xmm0,%xmm9\n  pmulhw %xmm4,%xmm9\n  psllw  $0x1,%xmm1\n  psubw  %xmm1,%xmm8\n  movdqa %xmm0,%xmm1\n  psraw  $0xf,%xmm1\n  psraw  $0x3,%xmm9\n  psubw  %xmm1,%xmm9\n  movdqa %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x2,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  psubw  %xmm1,%xmm0\n  movdqa %xmm0,%xmm9\n  movdqa %xmm8,%xmm0\n  movdqa %xmm9,%xmm1\n  pand   %xmm3,%xmm0\n  pand   %xmm3,%xmm1\n  packuswb %xmm1,%xmm0\n  paddb  %xmm7,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rax,%rcx\n  jne    1198 <func0+0x78>\n  mov    %rdx,%rcx\n  and    $0xfffffffffffffff0,%rcx\n  test   $0xf,%dl\n  je     15e8 <func0+0x4c8>\n  lea    (%rbx,%rcx,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x1(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x2(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x3(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x4(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x5(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x6(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x7(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x8(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x9(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xa(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xb(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xc(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xd(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    15e8 <func0+0x4c8>\n  lea    (%rbx,%rax,1),%rdi\n  add    $0xe,%rcx\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rcx,%rdx\n  jbe    15e8 <func0+0x4c8>\n  add    %rcx,%rbx\n  movsbl (%rbx),%eax\n  lea    -0x61(%rbp,%rax,1),%edx\n  movslq %edx,%rax\n  mov    %edx,%ecx\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%ecx\n  sar    $0x23,%rax\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%edx\n  add    $0x61,%edx\n  mov    %dl,(%rbx)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  xor    %ecx,%ecx\n  jmp    128d <func0+0x16d>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  cmp    $0x1,%esi\n  sbb    %ebp,%ebp\n  and    $0x10,%ebp\n  add    $0x5,%ebp\n  call   <strlen@plt>\n  test   %rax,%rax\n  je     L0\n  mov    %rax,%rdx\n  lea    -0x1(%rax),%rax\n  cmp    $0xe,%rax\n  jbe    L1\n  movd   %ebp,%xmm2\n  mov    %rdx,%rcx\n  movdqa D0(%rip),%xmm5\n  movdqa D1(%rip),%xmm4\n  punpcklwd %xmm2,%xmm2\n  and    $0xfffffffffffffff0,%rcx\n  pxor   %xmm6,%xmm6\n  mov    %rbx,%rax\n  movdqa D2(%rip),%xmm3\n  movdqa D3(%rip),%xmm7\n  pshufd $0x0,%xmm2,%xmm2\n  add    %rbx,%rcx\n  nopl   (%rax)\nL2:\n  movdqu (%rax),%xmm1\n  movdqa %xmm6,%xmm9\n  add    $0x10,%rax\n  pcmpgtb %xmm1,%xmm9\n  movdqa %xmm1,%xmm8\n  movdqa %xmm1,%xmm0\n  punpcklbw %xmm9,%xmm8\n  punpckhbw %xmm9,%xmm0\n  paddw  %xmm5,%xmm8\n  paddw  %xmm5,%xmm0\n  paddw  %xmm2,%xmm8\n  paddw  %xmm2,%xmm0\n  movdqa %xmm8,%xmm9\n  movdqa %xmm8,%xmm1\n  pmulhw %xmm4,%xmm9\n  psraw  $0xf,%xmm1\n  psraw  $0x3,%xmm9\n  psubw  %xmm1,%xmm9\n  movdqa %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x2,%xmm1\n  paddw  %xmm9,%xmm1\n  movdqa %xmm0,%xmm9\n  pmulhw %xmm4,%xmm9\n  psllw  $0x1,%xmm1\n  psubw  %xmm1,%xmm8\n  movdqa %xmm0,%xmm1\n  psraw  $0xf,%xmm1\n  psraw  $0x3,%xmm9\n  psubw  %xmm1,%xmm9\n  movdqa %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x2,%xmm1\n  paddw  %xmm9,%xmm1\n  psllw  $0x1,%xmm1\n  psubw  %xmm1,%xmm0\n  movdqa %xmm0,%xmm9\n  movdqa %xmm8,%xmm0\n  movdqa %xmm9,%xmm1\n  pand   %xmm3,%xmm0\n  pand   %xmm3,%xmm1\n  packuswb %xmm1,%xmm0\n  paddb  %xmm7,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rax,%rcx\n  jne    L2\n  mov    %rdx,%rcx\n  and    $0xfffffffffffffff0,%rcx\n  test   $0xf,%dl\n  je     L0\nL3:\n  lea    (%rbx,%rcx,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x1(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x2(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x3(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x4(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x5(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x6(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x7(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x8(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0x9(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xa(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xb(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xc(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  lea    0xd(%rcx),%rax\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rax,%rdx\n  jbe    L0\n  lea    (%rbx,%rax,1),%rdi\n  add    $0xe,%rcx\n  movsbl (%rdi),%eax\n  lea    -0x61(%rbp,%rax,1),%esi\n  movslq %esi,%rax\n  mov    %esi,%r8d\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%r8d\n  sar    $0x23,%rax\n  sub    %r8d,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%esi\n  add    $0x61,%esi\n  mov    %sil,(%rdi)\n  cmp    %rcx,%rdx\n  jbe    L0\n  add    %rcx,%rbx\n  movsbl (%rbx),%eax\n  lea    -0x61(%rbp,%rax,1),%edx\n  movslq %edx,%rax\n  mov    %edx,%ecx\n  imul   $0x4ec4ec4f,%rax,%rax\n  sar    $0x1f,%ecx\n  sar    $0x23,%rax\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%eax\n  sub    %eax,%edx\n  add    $0x61,%edx\n  mov    %dl,(%rbx)\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL1:\n  xor    %ecx,%ecx\n  jmp    L3",
        "num_missing": 4,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3738
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3746
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8224,
                "bias": [
                    3739
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8240,
                "bias": [
                    3747
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5608
            },
            "L1": {
                "label": "L1",
                "addr": 5615
            },
            "L2": {
                "label": "L2",
                "addr": 4504
            },
            "L3": {
                "label": "L3",
                "addr": 4749
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "9fff9fff9fff9fff9fff9fff9fff9fffc54ec54ec54ec54ec54ec54ec54ec54eff00ff00ff00ff00ff00ff00ff00ff0061616161616161616161616161616161",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        159,
                        255,
                        159,
                        255,
                        159,
                        255,
                        159,
                        255,
                        159,
                        255,
                        159,
                        255,
                        159,
                        255,
                        159,
                        255
                    ]
                },
                "0x2010": {
                    "type": "byte[16]",
                    "value": [
                        197,
                        78,
                        197,
                        78,
                        197,
                        78,
                        197,
                        78,
                        197,
                        78,
                        197,
                        78,
                        197,
                        78,
                        197,
                        78
                    ]
                },
                "0x2020": {
                    "type": "byte[16]",
                    "value": [
                        255,
                        0,
                        255,
                        0,
                        255,
                        0,
                        255,
                        0,
                        255,
                        0,
                        255,
                        0,
                        255,
                        0,
                        255,
                        0
                    ]
                },
                "0x2030": {
                    "type": "byte[16]",
                    "value": [
                        97,
                        97,
                        97,
                        97,
                        97,
                        97,
                        97,
                        97,
                        97,
                        97,
                        97,
                        97,
                        97,
                        97,
                        97,
                        97
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 51,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  lea    0xed0(%rip),%rax        # 2000 <_fini+0xe74>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  jmp    1175 <func0+0x5c>\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1050 <strchr@plt>\n  test   %rax,%rax\n  jne    1170 <func0+0x57>\n  mov    -0x10(%rbp),%rax\n  lea    0x1(%rax),%rdx\n  mov    %rdx,-0x10(%rbp)\n  mov    -0x18(%rbp),%rdx\n  movzbl (%rdx),%edx\n  mov    %dl,(%rax)\n  addq   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    113e <func0+0x25>\n  mov    -0x10(%rbp),%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  jmp    L0\nL2:\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L1\n  mov    -0x10(%rbp),%rax\n  lea    0x1(%rax),%rdx\n  mov    %rdx,-0x10(%rbp)\n  mov    -0x18(%rbp),%rdx\n  movzbl (%rdx),%edx\n  mov    %dl,(%rax)\nL1:\n  addq   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\n  mov    -0x10(%rbp),%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3792
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4469
            },
            "L1": {
                "label": "L1",
                "addr": 4464
            },
            "L2": {
                "label": "L2",
                "addr": 4414
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f556165696f7500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOUaeiou\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 51,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  movzbl (%rdi),%ebp\n  test   %bpl,%bpl\n  je     1166 <func0+0x4d>\n  mov    %rdi,%r12\n  lea    0xec4(%rip),%r13        # 2000 <_fini+0xe84>\n  jmp    114a <func0+0x31>\n  add    $0x1,%rbx\n  movzbl (%rbx),%ebp\n  test   %bpl,%bpl\n  je     1169 <func0+0x50>\n  movsbl %bpl,%esi\n  mov    %r13,%rdi\n  call   1050 <strchr@plt>\n  test   %rax,%rax\n  jne    113e <func0+0x25>\n  mov    %bpl,(%r12)\n  lea    0x1(%r12),%r12\n  jmp    113e <func0+0x25>\n  mov    %rdi,%r12\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  movzbl (%rdi),%ebp\n  test   %bpl,%bpl\n  je     L0\n  mov    %rdi,%r12\n  lea    D0(%rip),%r13\n  jmp    L1\nL3:\n  add    $0x1,%rbx\n  movzbl (%rbx),%ebp\n  test   %bpl,%bpl\n  je     L2\nL1:\n  movsbl %bpl,%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L3\n  mov    %bpl,(%r12)\n  lea    0x1(%r12),%r12\n  jmp    L3\nL0:\n  mov    %rdi,%r12\nL2:\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3780
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4454
            },
            "L1": {
                "label": "L1",
                "addr": 4426
            },
            "L2": {
                "label": "L2",
                "addr": 4457
            },
            "L3": {
                "label": "L3",
                "addr": 4414
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f556165696f7500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOUaeiou\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 51,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     1178 <func0+0x58>\n  mov    %rdi,%rbp\n  lea    0xebe(%rip),%r13        # 2000 <_fini+0xe78>\n  jmp    1154 <func0+0x34>\n  nopl   0x0(%rax)\n  movzbl 0x1(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  je     1178 <func0+0x58>\n  movsbl %bl,%esi\n  mov    %r13,%rdi\n  call   1050 <strchr@plt>\n  test   %rax,%rax\n  jne    1148 <func0+0x28>\n  add    $0x1,%rbp\n  mov    %bl,(%r12)\n  add    $0x1,%r12\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  jne    1154 <func0+0x34>\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  lea    D0(%rip),%r13\n  jmp    L1\n  nopl   0x0(%rax)\nL2:\n  movzbl 0x1(%rbp),%ebx\n  add    $0x1,%rbp\n  test   %bl,%bl\n  je     L0\nL1:\n  movsbl %bl,%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\n  add    $0x1,%rbp\n  mov    %bl,(%r12)\n  add    $0x1,%r12\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  jne    L1\nL0:\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3774
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4472
            },
            "L1": {
                "label": "L1",
                "addr": 4436
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f556165696f7500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOUaeiou\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 51,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nvoid func0(char *text) {\n    const char *vowels = \"AEIOUaeiou\";\n    char *out = text;\n    while (*text != '\\0') {\n        if (strchr(vowels, *text) == NULL) {\n            *out++ = *text;\n        }\n        text++;\n    }\n    *out = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    char test1[] = \"\";\n    func0(test1);\n    assert(strcmp(test1, \"\") == 0);\n    \n    char test2[] = \"abcdef\\nghijklm\";\n    func0(test2);\n    assert(strcmp(test2, \"bcdf\\nghjklm\") == 0);\n    \n    char test3[] = \"fedcba\";\n    func0(test3);\n    assert(strcmp(test3, \"fdcb\") == 0);\n    \n    char test4[] = \"eeeee\";\n    func0(test4);\n    assert(strcmp(test4, \"\") == 0);\n    \n    char test5[] = \"acBAA\";\n    func0(test5);\n    assert(strcmp(test5, \"cB\") == 0);\n    \n    char test6[] = \"EcBOO\";\n    func0(test6);\n    assert(strcmp(test6, \"cB\") == 0);\n    \n    char test7[] = \"ybcd\";\n    func0(test7);\n    assert(strcmp(test7, \"ybcd\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebp\n  test   %bpl,%bpl\n  je     1166 <func0+0x46>\n  lea    0xebd(%rip),%r13        # 2000 <_fini+0xe58>\n  nopl   0x0(%rax,%rax,1)\n  movsbl %bpl,%esi\n  mov    %r13,%rdi\n  call   1050 <strchr@plt>\n  test   %rax,%rax\n  je     1180 <func0+0x60>\n  movzbl 0x1(%rbx),%ebp\n  add    $0x1,%rbx\n  test   %bpl,%bpl\n  jne    1148 <func0+0x28>\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  add    $0x1,%rbx\n  mov    %bpl,(%r12)\n  lea    0x1(%r12),%rax\n  movzbl (%rbx),%ebp\n  mov    %rax,%r12\n  test   %bpl,%bpl\n  jne    1148 <func0+0x28>\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebp\n  test   %bpl,%bpl\n  je     L0\n  lea    D0(%rip),%r13\n  nopl   0x0(%rax,%rax,1)\nL2:\n  movsbl %bpl,%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\n  movzbl 0x1(%rbx),%ebp\n  add    $0x1,%rbx\n  test   %bpl,%bpl\n  jne    L2\nL0:\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  add    $0x1,%rbx\n  mov    %bpl,(%r12)\n  lea    0x1(%r12),%rax\n  movzbl (%rbx),%ebp\n  mov    %rax,%r12\n  test   %bpl,%bpl\n  jne    L2\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3773
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4454
            },
            "L1": {
                "label": "L1",
                "addr": 4480
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f556165696f7500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOUaeiou\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 52,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    113a <func0+0x41>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x20(%rbp)\n  jg     1136 <func0+0x3d>\n  mov    $0x0,%eax\n  jmp    1147 <func0+0x4e>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1114 <func0+0x1b>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x20(%rbp)\n  jg     L1\n  mov    $0x0,%eax\n  jmp    L2\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  mov    $0x1,%eax\nL2:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4410
            },
            "L1": {
                "label": "L1",
                "addr": 4406
            },
            "L2": {
                "label": "L2",
                "addr": 4423
            },
            "L3": {
                "label": "L3",
                "addr": 4372
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 52,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    111f <func0+0x26>\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%ecx\n  lea    0x4(%rdi,%rcx,4),%rcx\n  cmp    %edx,(%rax)\n  jge    1125 <func0+0x2c>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    110c <func0+0x13>\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x1(%rsi),%ecx\n  lea    0x4(%rdi,%rcx,4),%rcx\nL2:\n  cmp    %edx,(%rax)\n  jge    L1\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L2\n  mov    $0x1,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret\nL1:\n  mov    $0x0,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4383
            },
            "L1": {
                "label": "L1",
                "addr": 4389
            },
            "L2": {
                "label": "L2",
                "addr": 4364
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 52,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1130 <func0+0x30>\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\n  jmp    1121 <func0+0x21>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  je     1130 <func0+0x30>\n  cmp    %edx,(%rdi)\n  jl     1118 <func0+0x18>\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL2:\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  je     L0\nL1:\n  cmp    %edx,(%rdi)\n  jl     L2\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4400
            },
            "L1": {
                "label": "L1",
                "addr": 4385
            },
            "L2": {
                "label": "L2",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 52,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *l, int size, int t) {\n    for (int i = 0; i < size; i++)\n        if (l[i] >= t) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int list1[] = {1, 2, 4, 10};\n    assert(func0(list1, 4, 100));\n\n    int list2[] = {1, 20, 4, 10};\n    assert(!func0(list2, 4, 5));\n    \n    int list3[] = {1, 20, 4, 10};\n    assert(func0(list3, 4, 21));\n    \n    int list4[] = {1, 20, 4, 10};\n    assert(func0(list4, 4, 22));\n    \n    int list5[] = {1, 8, 4, 10};\n    assert(func0(list5, 4, 11));\n    \n    int list6[] = {1, 8, 4, 10};\n    assert(!func0(list6, 4, 10));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1130 <func0+0x30>\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\n  jmp    1121 <func0+0x21>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  je     1130 <func0+0x30>\n  cmp    %edx,(%rdi)\n  jl     1118 <func0+0x18>\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rax\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL2:\n  add    $0x4,%rdi\n  cmp    %rax,%rdi\n  je     L0\nL1:\n  cmp    %edx,(%rdi)\n  jl     L2\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4400
            },
            "L1": {
                "label": "L1",
                "addr": 4385
            },
            "L2": {
                "label": "L2",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 53,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x4(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x4(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 53,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 53,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 53,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    return x + y;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint main() {\n    assert(func0(0, 1) == 1);\n    assert(func0(1, 0) == 1);\n    assert(func0(2, 3) == 5);\n    assert(func0(5, 7) == 12);\n    assert(func0(7, 5) == 12);\n    for (int i = 0; i < 100; i += 1) {\n        int x = rand() % 1000;\n        int y = rand() % 1000;\n        assert(func0(x, y) == x + y);\n    }\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  lea    (%rdi,%rsi,1),%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 54,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    11ad <func0+0x94>\n  movb   $0x0,-0x1a(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    118f <func0+0x76>\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    118b <func0+0x72>\n  movb   $0x1,-0x1a(%rbp)\n  jmp    1197 <func0+0x7e>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     1161 <func0+0x48>\n  movzbl -0x1a(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     11a9 <func0+0x90>\n  mov    $0x0,%eax\n  jmp    1224 <func0+0x10b>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     1154 <func0+0x3b>\n  movl   $0x0,-0x10(%rbp)\n  jmp    1217 <func0+0xfe>\n  movb   $0x0,-0x19(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11f9 <func0+0xe0>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    11f5 <func0+0xdc>\n  movb   $0x1,-0x19(%rbp)\n  jmp    1201 <func0+0xe8>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     11cb <func0+0xb2>\n  movzbl -0x19(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     1213 <func0+0xfa>\n  mov    $0x0,%eax\n  jmp    1224 <func0+0x10b>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     11be <func0+0xa5>\n  mov    $0x1,%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    L0\nL7:\n  movb   $0x0,-0x1a(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L1\nL4:\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    L2\n  movb   $0x1,-0x1a(%rbp)\n  jmp    L3\nL2:\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L4\nL3:\n  movzbl -0x1a(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     L5\n  mov    $0x0,%eax\n  jmp    L6\nL5:\n  addl   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     L7\n  movl   $0x0,-0x10(%rbp)\n  jmp    L8\nL14:\n  movb   $0x0,-0x19(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L9\nL12:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    L10\n  movb   $0x1,-0x19(%rbp)\n  jmp    L11\nL10:\n  addl   $0x1,-0xc(%rbp)\nL9:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     L12\nL11:\n  movzbl -0x19(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     L13\n  mov    $0x0,%eax\n  jmp    L6\nL13:\n  addl   $0x1,-0x10(%rbp)\nL8:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L14\n  mov    $0x1,%eax\nL6:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4525
            },
            "L1": {
                "label": "L1",
                "addr": 4495
            },
            "L2": {
                "label": "L2",
                "addr": 4491
            },
            "L3": {
                "label": "L3",
                "addr": 4503
            },
            "L4": {
                "label": "L4",
                "addr": 4449
            },
            "L5": {
                "label": "L5",
                "addr": 4521
            },
            "L6": {
                "label": "L6",
                "addr": 4644
            },
            "L7": {
                "label": "L7",
                "addr": 4436
            },
            "L8": {
                "label": "L8",
                "addr": 4631
            },
            "L9": {
                "label": "L9",
                "addr": 4601
            },
            "L10": {
                "label": "L10",
                "addr": 4597
            },
            "L11": {
                "label": "L11",
                "addr": 4609
            },
            "L12": {
                "label": "L12",
                "addr": 4555
            },
            "L13": {
                "label": "L13",
                "addr": 4627
            },
            "L14": {
                "label": "L14",
                "addr": 4542
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 54,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  mov    %rbx,%rdi\n  call   1050 <strlen@plt>\n  test   %r13d,%r13d\n  jle    1165 <func0+0x4c>\n  mov    %eax,%r8d\n  mov    %rbp,%rdi\n  lea    -0x1(%r13),%edx\n  lea    0x1(%rbp,%rdx,1),%r9\n  lea    -0x1(%rax),%edx\n  lea    0x1(%rbx,%rdx,1),%rsi\n  jmp    11c5 <func0+0xac>\n  mov    $0x0,%eax\n  jmp    11e2 <func0+0xc9>\n  test   %eax,%eax\n  jg     1170 <func0+0x57>\n  mov    $0x1,%eax\n  jmp    11e2 <func0+0xc9>\n  mov    %rbx,%rsi\n  lea    -0x1(%rax),%eax\n  lea    0x1(%rbx,%rax,1),%rdi\n  lea    -0x1(%r13),%eax\n  lea    0x1(%rbp,%rax,1),%rcx\n  jmp    1196 <func0+0x7d>\n  mov    $0x0,%eax\n  jmp    11e2 <func0+0xc9>\n  add    $0x1,%rsi\n  cmp    %rdi,%rsi\n  je     11b5 <func0+0x9c>\n  test   %r12d,%r12d\n  jle    1186 <func0+0x6d>\n  movzbl (%rsi),%edx\n  mov    %rbp,%rax\n  cmp    (%rax),%dl\n  je     118d <func0+0x74>\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    11a1 <func0+0x88>\n  mov    $0x0,%eax\n  jmp    11e2 <func0+0xc9>\n  mov    $0x1,%eax\n  jmp    11e2 <func0+0xc9>\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  je     1170 <func0+0x57>\n  test   %r8d,%r8d\n  jle    115e <func0+0x45>\n  movzbl (%rdi),%ecx\n  mov    %rbx,%rdx\n  cmp    (%rdx),%cl\n  je     11bc <func0+0xa3>\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    11d0 <func0+0xb7>\n  mov    $0x0,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  call   <strlen@plt>\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  test   %r13d,%r13d\n  jle    L0\n  mov    %eax,%r8d\n  mov    %rbp,%rdi\n  lea    -0x1(%r13),%edx\n  lea    0x1(%rbp,%rdx,1),%r9\n  lea    -0x1(%rax),%edx\n  lea    0x1(%rbx,%rdx,1),%rsi\n  jmp    L1\nL9:\n  mov    $0x0,%eax\n  jmp    L2\nL0:\n  test   %eax,%eax\n  jg     L3\n  mov    $0x1,%eax\n  jmp    L2\nL3:\n  mov    %rbx,%rsi\n  lea    -0x1(%rax),%eax\n  lea    0x1(%rbx,%rax,1),%rdi\n  lea    -0x1(%r13),%eax\n  lea    0x1(%rbp,%rax,1),%rcx\n  jmp    L4\nL6:\n  mov    $0x0,%eax\n  jmp    L2\nL7:\n  add    $0x1,%rsi\n  cmp    %rdi,%rsi\n  je     L5\nL4:\n  test   %r12d,%r12d\n  jle    L6\n  movzbl (%rsi),%edx\n  mov    %rbp,%rax\nL8:\n  cmp    (%rax),%dl\n  je     L7\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    L8\n  mov    $0x0,%eax\n  jmp    L2\nL5:\n  mov    $0x1,%eax\n  jmp    L2\nL10:\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  je     L3\nL1:\n  test   %r8d,%r8d\n  jle    L9\n  movzbl (%rdi),%ecx\n  mov    %rbx,%rdx\nL11:\n  cmp    (%rdx),%cl\n  je     L10\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    L11\n  mov    $0x0,%eax\nL2:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4453
            },
            "L1": {
                "label": "L1",
                "addr": 4549
            },
            "L2": {
                "label": "L2",
                "addr": 4578
            },
            "L3": {
                "label": "L3",
                "addr": 4464
            },
            "L4": {
                "label": "L4",
                "addr": 4502
            },
            "L5": {
                "label": "L5",
                "addr": 4533
            },
            "L6": {
                "label": "L6",
                "addr": 4486
            },
            "L7": {
                "label": "L7",
                "addr": 4493
            },
            "L8": {
                "label": "L8",
                "addr": 4513
            },
            "L9": {
                "label": "L9",
                "addr": 4446
            },
            "L10": {
                "label": "L10",
                "addr": 4540
            },
            "L11": {
                "label": "L11",
                "addr": 4560
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 54,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   1050 <strlen@plt>\n  test   %r12d,%r12d\n  jle    11d7 <func0+0xb7>\n  lea    -0x1(%r12),%r9d\n  mov    %eax,%r8d\n  lea    0x1(%rbp),%rsi\n  sub    $0x1,%eax\n  mov    %r9,%r12\n  mov    %rbp,%rdi\n  lea    0x1(%rbx,%rax,1),%rcx\n  add    %rsi,%r9\n  nopl   0x0(%rax)\n  test   %r8d,%r8d\n  jle    11d0 <func0+0xb0>\n  movzbl (%rdi),%edx\n  mov    %rbx,%rax\n  jmp    1181 <func0+0x61>\n  nopl   (%rax)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     11d0 <func0+0xb0>\n  cmp    (%rax),%dl\n  jne    1178 <func0+0x58>\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  jne    1168 <func0+0x48>\n  xor    %edi,%edi\n  lea    (%rsi,%r12,1),%rcx\n  nopl   0x0(%rax)\n  movzbl (%rbx,%rdi,1),%edx\n  mov    %rbp,%rax\n  jmp    11b1 <func0+0x91>\n  nopl   0x0(%rax)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     11d0 <func0+0xb0>\n  cmp    (%rax),%dl\n  jne    11a8 <func0+0x88>\n  add    $0x1,%rdi\n  cmp    %edi,%r8d\n  jg     1198 <func0+0x78>\n  pop    %rbx\n  mov    $0x1,%eax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  test   %eax,%eax\n  setle  %al\n  jmp    11d2 <func0+0xb2>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strlen@plt>\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%r9d\n  mov    %eax,%r8d\n  lea    0x1(%rbp),%rsi\n  sub    $0x1,%eax\n  mov    %r9,%r12\n  mov    %rbp,%rdi\n  lea    0x1(%rbx,%rax,1),%rcx\n  add    %rsi,%r9\n  nopl   0x0(%rax)\nL4:\n  test   %r8d,%r8d\n  jle    L1\n  movzbl (%rdi),%edx\n  mov    %rbx,%rax\n  jmp    L2\n  nopl   (%rax)\nL3:\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    (%rax),%dl\n  jne    L3\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  jne    L4\n  xor    %edi,%edi\n  lea    (%rsi,%r12,1),%rcx\n  nopl   0x0(%rax)\nL7:\n  movzbl (%rbx,%rdi,1),%edx\n  mov    %rbp,%rax\n  jmp    L5\n  nopl   0x0(%rax)\nL6:\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     L1\nL5:\n  cmp    (%rax),%dl\n  jne    L6\n  add    $0x1,%rdi\n  cmp    %edi,%r8d\n  jg     L7\n  pop    %rbx\n  mov    $0x1,%eax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %eax,%eax\nL8:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL0:\n  test   %eax,%eax\n  setle  %al\n  jmp    L8",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4567
            },
            "L1": {
                "label": "L1",
                "addr": 4560
            },
            "L2": {
                "label": "L2",
                "addr": 4481
            },
            "L3": {
                "label": "L3",
                "addr": 4472
            },
            "L4": {
                "label": "L4",
                "addr": 4456
            },
            "L5": {
                "label": "L5",
                "addr": 4529
            },
            "L6": {
                "label": "L6",
                "addr": 4520
            },
            "L7": {
                "label": "L7",
                "addr": 4504
            },
            "L8": {
                "label": "L8",
                "addr": 4562
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 54,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char *s0, const char *s1) {\n    int len0 = strlen(s0), len1 = strlen(s1);\n    for (int i = 0; i < len0; i++) {\n        bool found = false;\n        for (int j = 0; j < len1; j++) {\n            if (s0[i] == s1[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    for (int i = 0; i < len1; i++) {\n        bool found = false;\n        for (int j = 0; j < len0; j++) {\n            if (s1[i] == s0[j]) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddeddabc\") == true);\n    assert(func0(\"abcd\", \"dddddddabc\") == true);\n    assert(func0(\"dddddddabc\", \"abcd\") == true);\n    assert(func0(\"eabcd\", \"dddddddabc\") == false);\n    assert(func0(\"abcd\", \"dddddddabce\") == false);\n    assert(func0(\"eabcdzzzz\", \"dddzzzzzzzddddabc\") == false);\n    assert(func0(\"aabb\", \"aaccc\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   1050 <strlen@plt>\n  test   %r12d,%r12d\n  jle    11d7 <func0+0xb7>\n  lea    -0x1(%r12),%r9d\n  mov    %eax,%r8d\n  lea    0x1(%rbp),%rsi\n  sub    $0x1,%eax\n  mov    %r9,%r12\n  mov    %rbp,%rdi\n  lea    0x1(%rbx,%rax,1),%rcx\n  add    %rsi,%r9\n  nopl   0x0(%rax)\n  test   %r8d,%r8d\n  jle    11d0 <func0+0xb0>\n  movzbl (%rdi),%edx\n  mov    %rbx,%rax\n  jmp    1181 <func0+0x61>\n  nopl   (%rax)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     11d0 <func0+0xb0>\n  cmp    (%rax),%dl\n  jne    1178 <func0+0x58>\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  jne    1168 <func0+0x48>\n  xor    %edi,%edi\n  lea    (%rsi,%r12,1),%rcx\n  nopl   0x0(%rax)\n  movzbl (%rbx,%rdi,1),%edx\n  mov    %rbp,%rax\n  jmp    11b1 <func0+0x91>\n  nopl   0x0(%rax)\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  je     11d0 <func0+0xb0>\n  cmp    (%rax),%dl\n  jne    11a8 <func0+0x88>\n  add    $0x1,%rdi\n  cmp    %edi,%r8d\n  jg     1198 <func0+0x78>\n  pop    %rbx\n  mov    $0x1,%eax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  test   %eax,%eax\n  setle  %al\n  jmp    11d2 <func0+0xb2>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strlen@plt>\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%r9d\n  mov    %eax,%r8d\n  lea    0x1(%rbp),%rsi\n  sub    $0x1,%eax\n  mov    %r9,%r12\n  mov    %rbp,%rdi\n  lea    0x1(%rbx,%rax,1),%rcx\n  add    %rsi,%r9\n  nopl   0x0(%rax)\nL4:\n  test   %r8d,%r8d\n  jle    L1\n  movzbl (%rdi),%edx\n  mov    %rbx,%rax\n  jmp    L2\n  nopl   (%rax)\nL3:\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    (%rax),%dl\n  jne    L3\n  add    $0x1,%rdi\n  cmp    %r9,%rdi\n  jne    L4\n  xor    %edi,%edi\n  lea    (%rsi,%r12,1),%rcx\n  nopl   0x0(%rax)\nL7:\n  movzbl (%rbx,%rdi,1),%edx\n  mov    %rbp,%rax\n  jmp    L5\n  nopl   0x0(%rax)\nL6:\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  je     L1\nL5:\n  cmp    (%rax),%dl\n  jne    L6\n  add    $0x1,%rdi\n  cmp    %edi,%r8d\n  jg     L7\n  pop    %rbx\n  mov    $0x1,%eax\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %eax,%eax\nL8:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL0:\n  test   %eax,%eax\n  setle  %al\n  jmp    L8",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4567
            },
            "L1": {
                "label": "L1",
                "addr": 4560
            },
            "L2": {
                "label": "L2",
                "addr": 4481
            },
            "L3": {
                "label": "L3",
                "addr": 4472
            },
            "L4": {
                "label": "L4",
                "addr": 4456
            },
            "L5": {
                "label": "L5",
                "addr": 4529
            },
            "L6": {
                "label": "L6",
                "addr": 4520
            },
            "L7": {
                "label": "L7",
                "addr": 4504
            },
            "L8": {
                "label": "L8",
                "addr": 4562
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 55,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xfd0,%rsp\n  mov    %edi,-0xfc4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0xfb0(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x1f4,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0xfb0(%rbp)\n  movl   $0x1,-0xfac(%rbp)\n  movl   $0x2,-0xfb4(%rbp)\n  jmp    11b0 <func0+0x97>\n  mov    -0xfb4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%edx\n  mov    -0xfb4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0xfb4(%rbp),%eax\n  cltq\n  mov    %edx,-0xfb0(%rbp,%rax,4)\n  addl   $0x1,-0xfb4(%rbp)\n  mov    -0xfb4(%rbp),%eax\n  cmp    -0xfc4(%rbp),%eax\n  jle    1174 <func0+0x5b>\n  mov    -0xfc4(%rbp),%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     11e1 <func0+0xc8>\n  call   1050 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xfd0,%rsp\n  mov    %edi,-0xfc4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0xfb0(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x1f4,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0xfb0(%rbp)\n  movl   $0x1,-0xfac(%rbp)\n  movl   $0x2,-0xfb4(%rbp)\n  jmp    L0\nL1:\n  mov    -0xfb4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%edx\n  mov    -0xfb4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0xfb4(%rbp),%eax\n  cltq\n  mov    %edx,-0xfb0(%rbp,%rax,4)\n  addl   $0x1,-0xfb4(%rbp)\nL0:\n  mov    -0xfb4(%rbp),%eax\n  cmp    -0xfc4(%rbp),%eax\n  jle    L1\n  mov    -0xfc4(%rbp),%eax\n  cltq\n  mov    -0xfb0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L2\n  call   <__stack_chk_fail@plt>\nL2:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4528
            },
            "L1": {
                "label": "L1",
                "addr": 4468
            },
            "L2": {
                "label": "L2",
                "addr": 4577
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 55,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  mov    %edi,%esi\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x1f4,%ecx\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%esi\n  jle    116d <func0+0x54>\n  mov    %rsp,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\n  mov    (%rax),%edx\n  add    0x4(%rax),%edx\n  mov    %edx,0x8(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    115c <func0+0x43>\n  movslq %esi,%rsi\n  mov    (%rsp,%rsi,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    118e <func0+0x75>\n  add    $0xfb8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  mov    %edi,%esi\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x1f4,%ecx\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %rsp,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\nL1:\n  mov    (%rax),%edx\n  add    0x4(%rax),%edx\n  mov    %edx,0x8(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L1\nL0:\n  movslq %esi,%rsi\n  mov    (%rsp,%rsi,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L2\n  add    $0xfb8,%rsp\n  ret\nL2:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4461
            },
            "L1": {
                "label": "L1",
                "addr": 4444
            },
            "L2": {
                "label": "L2",
                "addr": 4494
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 55,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  movslq %edi,%r8\n  mov    $0x1f4,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%r8d\n  jle    1180 <func0+0x60>\n  lea    -0x2(%r8),%edx\n  lea    0x8(%rsp),%rax\n  lea    (%rax,%rdx,4),%rsi\n  mov    $0x1,%edx\n  jmp    1177 <func0+0x57>\n  xchg   %ax,%ax\n  mov    -0x4(%rax),%ecx\n  add    $0x4,%rax\n  add    %ecx,%edx\n  mov    %edx,(%rax)\n  cmp    %rsi,%rax\n  jne    1170 <func0+0x50>\n  mov    (%rsp,%r8,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    119f <func0+0x7f>\n  add    $0xfb8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  movslq %edi,%r8\n  mov    $0x1f4,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%r8d\n  jle    L0\n  lea    -0x2(%r8),%edx\n  lea    0x8(%rsp),%rax\n  lea    (%rax,%rdx,4),%rsi\n  mov    $0x1,%edx\n  jmp    L1\n  xchg   %ax,%ax\nL2:\n  mov    -0x4(%rax),%ecx\n  add    $0x4,%rax\nL1:\n  add    %ecx,%edx\n  mov    %edx,(%rax)\n  cmp    %rsi,%rax\n  jne    L2\nL0:\n  mov    (%rsp,%r8,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L3\n  add    $0xfb8,%rsp\n  ret\nL3:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4480
            },
            "L1": {
                "label": "L1",
                "addr": 4471
            },
            "L2": {
                "label": "L2",
                "addr": 4464
            },
            "L3": {
                "label": "L3",
                "addr": 4511
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 55,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int f[1000] = {0};\n    f[0] = 0;\n    f[1] = 1;\n    for (int i = 2; i <= n; i++)\n        f[i] = f[i - 1] + f[i - 2];\n    return f[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(10) == 55);\n    assert(func0(1) == 1);\n    assert(func0(8) == 21);\n    assert(func0(11) == 89);\n    assert(func0(12) == 144);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  movslq %edi,%rsi\n  mov    $0x1f4,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%esi\n  jle    11bc <func0+0x9c>\n  cmp    $0x3,%esi\n  jle    11da <func0+0xba>\n  lea    -0x4(%rsi),%eax\n  mov    $0x1,%r8d\n  xor    %edi,%edi\n  shr    %eax\n  lea    0x3(%rax),%r9d\n  mov    $0x4,%eax\n  add    %r9,%r9\n  add    %r8d,%edi\n  mov    %eax,%ecx\n  add    %edi,%r8d\n  movd   %edi,%xmm0\n  movd   %r8d,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,-0x8(%rdx,%rax,4)\n  add    $0x2,%rax\n  cmp    %rax,%r9\n  jne    117a <func0+0x5a>\n  movslq %ecx,%rax\n  lea    (%rdx,%rax,4),%rax\n  nopl   (%rax)\n  mov    -0x4(%rax),%edx\n  add    $0x1,%ecx\n  add    -0x8(%rax),%edx\n  add    $0x4,%rax\n  mov    %edx,-0x4(%rax)\n  cmp    %ecx,%esi\n  jge    11a8 <func0+0x88>\n  mov    (%rsp,%rsi,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    11e1 <func0+0xc1>\n  add    $0xfb8,%rsp\n  ret\n  mov    $0x2,%ecx\n  jmp    119e <func0+0x7e>\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0xfb8,%rsp\n  movslq %edi,%rsi\n  mov    $0x1f4,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xfa8(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x4(%rsp)\n  cmp    $0x1,%esi\n  jle    L0\n  cmp    $0x3,%esi\n  jle    L1\n  lea    -0x4(%rsi),%eax\n  mov    $0x1,%r8d\n  xor    %edi,%edi\n  shr    %eax\n  lea    0x3(%rax),%r9d\n  mov    $0x4,%eax\n  add    %r9,%r9\nL2:\n  add    %r8d,%edi\n  mov    %eax,%ecx\n  add    %edi,%r8d\n  movd   %edi,%xmm0\n  movd   %r8d,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,-0x8(%rdx,%rax,4)\n  add    $0x2,%rax\n  cmp    %rax,%r9\n  jne    L2\nL5:\n  movslq %ecx,%rax\n  lea    (%rdx,%rax,4),%rax\n  nopl   (%rax)\nL3:\n  mov    -0x4(%rax),%edx\n  add    $0x1,%ecx\n  add    -0x8(%rax),%edx\n  add    $0x4,%rax\n  mov    %edx,-0x4(%rax)\n  cmp    %ecx,%esi\n  jge    L3\nL0:\n  mov    (%rsp,%rsi,4),%eax\n  mov    0xfa8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L4\n  add    $0xfb8,%rsp\n  ret\nL1:\n  mov    $0x2,%ecx\n  jmp    L5\nL4:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4540
            },
            "L1": {
                "label": "L1",
                "addr": 4570
            },
            "L2": {
                "label": "L2",
                "addr": 4474
            },
            "L3": {
                "label": "L3",
                "addr": 4520
            },
            "L4": {
                "label": "L4",
                "addr": 4577
            },
            "L5": {
                "label": "L5",
                "addr": 4510
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 56,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1156 <func0+0x5d>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3c,%al\n  jne    112d <func0+0x34>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3e,%al\n  jne    1145 <func0+0x4c>\n  subl   $0x1,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jns    1152 <func0+0x59>\n  mov    $0x0,%eax\n  jmp    117c <func0+0x83>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1115 <func0+0x1c>\n  cmpl   $0x0,-0x8(%rbp)\n  je     1177 <func0+0x7e>\n  mov    $0x0,%eax\n  jmp    117c <func0+0x83>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL5:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3c,%al\n  jne    L1\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3e,%al\n  jne    L2\n  subl   $0x1,-0x8(%rbp)\nL2:\n  cmpl   $0x0,-0x8(%rbp)\n  jns    L3\n  mov    $0x0,%eax\n  jmp    L4\nL3:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L5\n  cmpl   $0x0,-0x8(%rbp)\n  je     L6\n  mov    $0x0,%eax\n  jmp    L4\nL6:\n  mov    $0x1,%eax\nL4:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4438
            },
            "L1": {
                "label": "L1",
                "addr": 4397
            },
            "L2": {
                "label": "L2",
                "addr": 4421
            },
            "L3": {
                "label": "L3",
                "addr": 4434
            },
            "L4": {
                "label": "L4",
                "addr": 4476
            },
            "L5": {
                "label": "L5",
                "addr": 4373
            },
            "L6": {
                "label": "L6",
                "addr": 4471
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 56,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     1132 <func0+0x39>\n  add    $0x1,%rdi\n  mov    $0x0,%edx\n  jmp    1122 <func0+0x29>\n  add    $0x1,%edx\n  test   %edx,%edx\n  js     113d <func0+0x44>\n  add    $0x1,%rdi\n  movzbl -0x1(%rdi),%eax\n  test   %al,%al\n  je     1137 <func0+0x3e>\n  cmp    $0x3c,%al\n  je     110f <func0+0x16>\n  cmp    $0x3e,%al\n  sete   %al\n  movzbl %al,%eax\n  sub    %eax,%edx\n  jmp    1112 <func0+0x19>\n  mov    $0x0,%edx\n  test   %edx,%edx\n  sete   %al\n  ret\n  mov    $0x0,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  mov    $0x0,%edx\n  jmp    L1\nL4:\n  add    $0x1,%edx\nL5:\n  test   %edx,%edx\n  js     L2\n  add    $0x1,%rdi\n  movzbl -0x1(%rdi),%eax\n  test   %al,%al\n  je     L3\nL1:\n  cmp    $0x3c,%al\n  je     L4\n  cmp    $0x3e,%al\n  sete   %al\n  movzbl %al,%eax\n  sub    %eax,%edx\n  jmp    L5\nL0:\n  mov    $0x0,%edx\nL3:\n  test   %edx,%edx\n  sete   %al\n  ret\nL2:\n  mov    $0x0,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4402
            },
            "L1": {
                "label": "L1",
                "addr": 4386
            },
            "L2": {
                "label": "L2",
                "addr": 4413
            },
            "L3": {
                "label": "L3",
                "addr": 4407
            },
            "L4": {
                "label": "L4",
                "addr": 4367
            },
            "L5": {
                "label": "L5",
                "addr": 4370
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 56,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     114b <func0+0x4b>\n  add    $0x1,%rdi\n  xor    %edx,%edx\n  jmp    112c <func0+0x2c>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x3e,%al\n  jne    1121 <func0+0x21>\n  sub    $0x1,%edx\n  jb     1148 <func0+0x48>\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  je     113e <func0+0x3e>\n  cmp    $0x3c,%al\n  jne    1118 <func0+0x18>\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  add    $0x1,%edx\n  test   %al,%al\n  jne    112c <func0+0x2c>\n  test   %edx,%edx\n  sete   %al\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  xor    %edx,%edx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL5:\n  cmp    $0x3e,%al\n  jne    L2\n  sub    $0x1,%edx\n  jb     L3\nL2:\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  je     L4\nL1:\n  cmp    $0x3c,%al\n  jne    L5\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  add    $0x1,%edx\n  test   %al,%al\n  jne    L1\nL4:\n  test   %edx,%edx\n  sete   %al\n  ret\n  nopl   0x0(%rax)\nL3:\n  xor    %eax,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4427
            },
            "L1": {
                "label": "L1",
                "addr": 4396
            },
            "L2": {
                "label": "L2",
                "addr": 4385
            },
            "L3": {
                "label": "L3",
                "addr": 4424
            },
            "L4": {
                "label": "L4",
                "addr": 4414
            },
            "L5": {
                "label": "L5",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 56,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    int i = 0;\n    while (brackets[i]) {\n        if (brackets[i] == '<') level++;\n        if (brackets[i] == '>') level--;\n        if (level < 0) return false;\n        i++;\n    }\n    if (level != 0) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"<>\"));\n    assert(func0(\"<<><>>\"));\n    assert(func0(\"<><><<><>><>\"));\n    assert(func0(\"<><><<<><><>><>><<><><<>>>\"));\n    assert(!func0(\"<<<><>>>>\"));\n    assert(!func0(\"><<>\"));\n    assert(!func0(\"<\"));\n    assert(!func0(\"<<<<\"));\n    assert(!func0(\">\"));\n    assert(!func0(\"<<>\"));\n    assert(!func0(\"<><><<><>><>><<>\"));\n    assert(!func0(\"<><><<><>><>>><>\"));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     114b <func0+0x4b>\n  add    $0x1,%rdi\n  xor    %edx,%edx\n  jmp    112c <func0+0x2c>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x3e,%al\n  jne    1121 <func0+0x21>\n  sub    $0x1,%edx\n  jb     1148 <func0+0x48>\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  je     113e <func0+0x3e>\n  cmp    $0x3c,%al\n  jne    1118 <func0+0x18>\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  add    $0x1,%edx\n  test   %al,%al\n  jne    112c <func0+0x2c>\n  test   %edx,%edx\n  sete   %al\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  xor    %edx,%edx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL5:\n  cmp    $0x3e,%al\n  jne    L2\n  sub    $0x1,%edx\n  jb     L3\nL2:\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  je     L4\nL1:\n  cmp    $0x3c,%al\n  jne    L5\n  movzbl (%rdi),%eax\n  add    $0x1,%rdi\n  add    $0x1,%edx\n  test   %al,%al\n  jne    L1\nL4:\n  test   %edx,%edx\n  sete   %al\n  ret\n  nopl   0x0(%rax)\nL3:\n  xor    %eax,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4427
            },
            "L1": {
                "label": "L1",
                "addr": 4396
            },
            "L2": {
                "label": "L2",
                "addr": 4385
            },
            "L3": {
                "label": "L3",
                "addr": 4424
            },
            "L4": {
                "label": "L4",
                "addr": 4414
            },
            "L5": {
                "label": "L5",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 57,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    119a <func0+0xa1>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    115a <func0+0x61>\n  movl   $0x1,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    1196 <func0+0x9d>\n  movl   $0x1,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111e <func0+0x25>\n  mov    -0xc(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  jne    11ba <func0+0xc1>\n  mov    $0x0,%eax\n  jmp    11bf <func0+0xc6>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L1\n  movl   $0x1,-0xc(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  comiss %xmm1,%xmm0\n  jbe    L2\n  movl   $0x1,-0x8(%rbp)\nL2:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  mov    -0xc(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  jne    L4\n  mov    $0x0,%eax\n  jmp    L5\nL4:\n  mov    $0x1,%eax\nL5:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4506
            },
            "L1": {
                "label": "L1",
                "addr": 4442
            },
            "L2": {
                "label": "L2",
                "addr": 4502
            },
            "L3": {
                "label": "L3",
                "addr": 4382
            },
            "L4": {
                "label": "L4",
                "addr": 4538
            },
            "L5": {
                "label": "L5",
                "addr": 4543
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 57,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1143 <func0+0x4a>\n  mov    %rdi,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdi\n  mov    $0x0,%ecx\n  mov    $0x0,%edx\n  mov    $0x1,%esi\n  movss  0x4(%rax),%xmm0\n  movss  (%rax),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %esi,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %esi,%ecx\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    111c <func0+0x23>\n  add    %ecx,%edx\n  cmp    $0x2,%edx\n  setne  %al\n  ret\n  mov    $0x0,%ecx\n  mov    $0x0,%edx\n  jmp    113a <func0+0x41>",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %rdi,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%rdi\n  mov    $0x0,%ecx\n  mov    $0x0,%edx\n  mov    $0x1,%esi\nL1:\n  movss  0x4(%rax),%xmm0\n  movss  (%rax),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %esi,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %esi,%ecx\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    L1\nL2:\n  add    %ecx,%edx\n  cmp    $0x2,%edx\n  setne  %al\n  ret\nL0:\n  mov    $0x0,%ecx\n  mov    $0x0,%edx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4419
            },
            "L1": {
                "label": "L1",
                "addr": 4380
            },
            "L2": {
                "label": "L2",
                "addr": 4410
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 57,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1150 <func0+0x50>\n  lea    -0x2(%rsi),%eax\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  lea    0x4(%rdi,%rax,4),%rsi\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\n  movss  0x4(%rdi),%xmm0\n  movss  (%rdi),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %ecx,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %ecx,%edx\n  add    $0x4,%rdi\n  cmp    %rdi,%rsi\n  jne    1120 <func0+0x20>\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%eax\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  lea    0x4(%rdi,%rax,4),%rsi\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\nL1:\n  movss  0x4(%rdi),%xmm0\n  movss  (%rdi),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %ecx,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %ecx,%edx\n  add    $0x4,%rdi\n  cmp    %rdi,%rsi\n  jne    L1\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4432
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 57,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(float *l, int size) {\n    int incr, decr;\n    incr = decr = 0;\n    \n    for (int i = 1; i < size; i++) {\n        if (l[i] > l[i - 1]) incr = 1;\n        if (l[i] < l[i - 1]) decr = 1;\n    }\n    if (incr + decr == 2) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    float list1[] = {1, 2, 4, 10};\n    float list2[] = {1, 2, 4, 20};\n    float list3[] = {1, 20, 4, 10};\n    float list4[] = {4, 1, 0, -10};\n    float list5[] = {4, 1, 1, 0};\n    float list6[] = {1, 2, 3, 2, 5, 60};\n    float list7[] = {1, 2, 3, 4, 5, 60};\n    float list8[] = {9, 9, 9, 9};\n\n    assert(func0(list1, 4) == true);\n    assert(func0(list2, 4) == true);\n    assert(func0(list3, 4) == false);\n    assert(func0(list4, 4) == true);\n    assert(func0(list5, 4) == true);\n    assert(func0(list6, 6) == false);\n    assert(func0(list7, 6) == true);\n    assert(func0(list8, 4) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1370 <func0+0x270>\n  lea    -0x2(%rsi),%eax\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%eax\n  jbe    1376 <func0+0x276>\n  mov    %r8d,%edx\n  pxor   %xmm1,%xmm1\n  movdqa 0xed1(%rip),%xmm2        # 2000 <_fini+0xc74>\n  mov    %rdi,%rax\n  shr    $0x2,%edx\n  movdqa %xmm1,%xmm4\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%rdi,%rdx,1),%rdx\n  nopl   (%rax)\n  movups 0x4(%rax),%xmm5\n  movups (%rax),%xmm0\n  movdqa %xmm2,%xmm3\n  add    $0x10,%rax\n  movups -0x10(%rax),%xmm6\n  cmpltps %xmm5,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm4,%xmm0\n  movdqa %xmm0,%xmm4\n  movaps %xmm5,%xmm0\n  cmpltps %xmm6,%xmm0\n  por    %xmm3,%xmm4\n  movdqa %xmm2,%xmm3\n  pand   %xmm0,%xmm3\n  pandn  %xmm1,%xmm0\n  movdqa %xmm0,%xmm1\n  por    %xmm3,%xmm1\n  cmp    %rdx,%rax\n  jne    1148 <func0+0x48>\n  movdqa %xmm1,%xmm2\n  mov    %r8d,%r9d\n  psrldq $0x8,%xmm2\n  and    $0xfffffffc,%r9d\n  movdqa %xmm2,%xmm0\n  lea    0x1(%r9),%edi\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm2\n  pandn  %xmm1,%xmm0\n  por    %xmm2,%xmm0\n  movdqa %xmm0,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm1\n  pcmpgtd %xmm0,%xmm1\n  pand   %xmm1,%xmm2\n  pandn  %xmm0,%xmm1\n  por    %xmm2,%xmm1\n  movd   %xmm1,%edx\n  movdqa %xmm4,%xmm1\n  psrldq $0x8,%xmm1\n  movdqa %xmm1,%xmm0\n  pcmpgtd %xmm4,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm4,%xmm0\n  por    %xmm1,%xmm0\n  movdqa %xmm0,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm1\n  pcmpgtd %xmm0,%xmm1\n  pand   %xmm1,%xmm2\n  pandn  %xmm0,%xmm1\n  por    %xmm2,%xmm1\n  movd   %xmm1,%eax\n  cmp    %r9d,%r8d\n  je     1360 <func0+0x260>\n  movslq %edi,%r10\n  lea    0x1(%rdi),%r11d\n  push   %rbx\n  shl    $0x2,%r10\n  lea    (%rcx,%r10,1),%r9\n  cmp    %r11d,%r8d\n  jle    1384 <func0+0x284>\n  cmp    %edi,%esi\n  jle    1384 <func0+0x284>\n  movss  (%r9),%xmm0\n  movss  -0x4(%r9),%xmm1\n  lea    0x3(%rdi),%ebx\n  lea    0x2(%rdi),%r11d\n  mov    $0x1,%r9d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0x4(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  cmp    %ebx,%r8d\n  jg     12f0 <func0+0x1f0>\n  movslq %r11d,%rdi\n  lea    0x1(%r11),%r9d\n  lea    0x0(,%rdi,4),%r8\n  movss  (%rcx,%rdi,4),%xmm0\n  mov    $0x1,%edi\n  movss  -0x4(%rcx,%r8,1),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%edx\n  cmp    %r9d,%esi\n  jle    12e0 <func0+0x1e0>\n  movss  0x4(%rcx,%r8,1),%xmm1\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%edx\n  add    $0x2,%r11d\n  cmp    %r11d,%esi\n  jle    12e0 <func0+0x1e0>\n  movss  0x8(%rcx,%r8,1),%xmm0\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%edx\n  add    %edx,%eax\n  pop    %rbx\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopw   0x0(%rax,%rax,1)\n  movss  0x8(%rcx,%r10,1),%xmm0\n  lea    0x5(%rdi),%ebx\n  lea    0x4(%rdi),%r11d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0xc(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  cmp    %ebx,%r8d\n  jle    1280 <func0+0x180>\n  movss  0x10(%rcx,%r10,1),%xmm0\n  lea    0x6(%rdi),%r11d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0x14(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  jmp    1280 <func0+0x180>\n  nopl   (%rax)\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopl   0x0(%rax)\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%edi\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    121f <func0+0x11f>\n  mov    %edi,%r11d\n  jmp    1280 <func0+0x180>",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%eax\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%eax\n  jbe    L1\n  mov    %r8d,%edx\n  pxor   %xmm1,%xmm1\n  movdqa D0(%rip),%xmm2\n  mov    %rdi,%rax\n  shr    $0x2,%edx\n  movdqa %xmm1,%xmm4\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%rdi,%rdx,1),%rdx\n  nopl   (%rax)\nL2:\n  movups 0x4(%rax),%xmm5\n  movups (%rax),%xmm0\n  movdqa %xmm2,%xmm3\n  add    $0x10,%rax\n  movups -0x10(%rax),%xmm6\n  cmpltps %xmm5,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm4,%xmm0\n  movdqa %xmm0,%xmm4\n  movaps %xmm5,%xmm0\n  cmpltps %xmm6,%xmm0\n  por    %xmm3,%xmm4\n  movdqa %xmm2,%xmm3\n  pand   %xmm0,%xmm3\n  pandn  %xmm1,%xmm0\n  movdqa %xmm0,%xmm1\n  por    %xmm3,%xmm1\n  cmp    %rdx,%rax\n  jne    L2\n  movdqa %xmm1,%xmm2\n  mov    %r8d,%r9d\n  psrldq $0x8,%xmm2\n  and    $0xfffffffc,%r9d\n  movdqa %xmm2,%xmm0\n  lea    0x1(%r9),%edi\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm2\n  pandn  %xmm1,%xmm0\n  por    %xmm2,%xmm0\n  movdqa %xmm0,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm1\n  pcmpgtd %xmm0,%xmm1\n  pand   %xmm1,%xmm2\n  pandn  %xmm0,%xmm1\n  por    %xmm2,%xmm1\n  movd   %xmm1,%edx\n  movdqa %xmm4,%xmm1\n  psrldq $0x8,%xmm1\n  movdqa %xmm1,%xmm0\n  pcmpgtd %xmm4,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm4,%xmm0\n  por    %xmm1,%xmm0\n  movdqa %xmm0,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm1\n  pcmpgtd %xmm0,%xmm1\n  pand   %xmm1,%xmm2\n  pandn  %xmm0,%xmm1\n  por    %xmm2,%xmm1\n  movd   %xmm1,%eax\n  cmp    %r9d,%r8d\n  je     L3\nL8:\n  movslq %edi,%r10\n  lea    0x1(%rdi),%r11d\n  push   %rbx\n  shl    $0x2,%r10\n  lea    (%rcx,%r10,1),%r9\n  cmp    %r11d,%r8d\n  jle    L4\n  cmp    %edi,%esi\n  jle    L4\n  movss  (%r9),%xmm0\n  movss  -0x4(%r9),%xmm1\n  lea    0x3(%rdi),%ebx\n  lea    0x2(%rdi),%r11d\n  mov    $0x1,%r9d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0x4(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  cmp    %ebx,%r8d\n  jg     L5\nL7:\n  movslq %r11d,%rdi\n  lea    0x1(%r11),%r9d\n  lea    0x0(,%rdi,4),%r8\n  movss  (%rcx,%rdi,4),%xmm0\n  mov    $0x1,%edi\n  movss  -0x4(%rcx,%r8,1),%xmm1\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%edx\n  cmp    %r9d,%esi\n  jle    L6\n  movss  0x4(%rcx,%r8,1),%xmm1\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%edx\n  add    $0x2,%r11d\n  cmp    %r11d,%esi\n  jle    L6\n  movss  0x8(%rcx,%r8,1),%xmm0\n  ucomiss %xmm1,%xmm0\n  cmova  %edi,%eax\n  ucomiss %xmm0,%xmm1\n  cmova  %edi,%edx\nL6:\n  add    %edx,%eax\n  pop    %rbx\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopw   0x0(%rax,%rax,1)\nL5:\n  movss  0x8(%rcx,%r10,1),%xmm0\n  lea    0x5(%rdi),%ebx\n  lea    0x4(%rdi),%r11d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0xc(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  cmp    %ebx,%r8d\n  jle    L7\n  movss  0x10(%rcx,%r10,1),%xmm0\n  lea    0x6(%rdi),%r11d\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%eax\n  ucomiss %xmm0,%xmm1\n  movss  0x14(%rcx,%r10,1),%xmm1\n  cmova  %r9d,%edx\n  ucomiss %xmm0,%xmm1\n  cmova  %r9d,%eax\n  ucomiss %xmm1,%xmm0\n  cmova  %r9d,%edx\n  jmp    L7\n  nopl   (%rax)\nL3:\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  setne  %al\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x1,%eax\n  ret\nL1:\n  mov    $0x1,%edi\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    L8\nL4:\n  mov    %edi,%r11d\n  jmp    L7",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3793
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4976
            },
            "L1": {
                "label": "L1",
                "addr": 4982
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            },
            "L3": {
                "label": "L3",
                "addr": 4960
            },
            "L4": {
                "label": "L4",
                "addr": 4996
            },
            "L5": {
                "label": "L5",
                "addr": 4848
            },
            "L6": {
                "label": "L6",
                "addr": 4832
            },
            "L7": {
                "label": "L7",
                "addr": 4736
            },
            "L8": {
                "label": "L8",
                "addr": 4639
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "01000000010000000100000001000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 58,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %ecx,-0x30(%rbp)\n  mov    %r8,-0x40(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1238 <func0+0x11f>\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11ac <func0+0x93>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    11a8 <func0+0x8f>\n  movl   $0x1,-0x10(%rbp)\n  jmp    11b4 <func0+0x9b>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     116f <func0+0x56>\n  cmpl   $0x0,-0x10(%rbp)\n  jne    1234 <func0+0x11b>\n  movl   $0x0,-0x18(%rbp)\n  jmp    122c <func0+0x113>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    1228 <func0+0x10f>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  jmp    1234 <func0+0x11b>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     11c3 <func0+0xaa>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     115f <func0+0x46>\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1311 <func0+0x1f8>\n  movl   $0x0,-0x18(%rbp)\n  jmp    12fb <func0+0x1e2>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    12f7 <func0+0x1de>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     125c <func0+0x143>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x20(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     1250 <func0+0x137>\n  mov    -0x40(%rbp),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %ecx,-0x30(%rbp)\n  mov    %r8,-0x40(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL9:\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L1\nL4:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L2\n  movl   $0x1,-0x10(%rbp)\n  jmp    L3\nL2:\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     L4\nL3:\n  cmpl   $0x0,-0x10(%rbp)\n  jne    L5\n  movl   $0x0,-0x18(%rbp)\n  jmp    L6\nL8:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L7\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  jmp    L5\nL7:\n  addl   $0x1,-0x18(%rbp)\nL6:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L8\nL5:\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L9\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L10\nL14:\n  movl   $0x0,-0x18(%rbp)\n  jmp    L11\nL13:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L12\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\nL12:\n  addl   $0x1,-0x18(%rbp)\nL11:\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     L13\n  addl   $0x1,-0x1c(%rbp)\nL10:\n  mov    -0x20(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     L14\n  mov    -0x40(%rbp),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4664
            },
            "L1": {
                "label": "L1",
                "addr": 4524
            },
            "L2": {
                "label": "L2",
                "addr": 4520
            },
            "L3": {
                "label": "L3",
                "addr": 4532
            },
            "L4": {
                "label": "L4",
                "addr": 4463
            },
            "L5": {
                "label": "L5",
                "addr": 4660
            },
            "L6": {
                "label": "L6",
                "addr": 4652
            },
            "L7": {
                "label": "L7",
                "addr": 4648
            },
            "L8": {
                "label": "L8",
                "addr": 4547
            },
            "L9": {
                "label": "L9",
                "addr": 4447
            },
            "L10": {
                "label": "L10",
                "addr": 4881
            },
            "L11": {
                "label": "L11",
                "addr": 4859
            },
            "L12": {
                "label": "L12",
                "addr": 4855
            },
            "L13": {
                "label": "L13",
                "addr": 4700
            },
            "L14": {
                "label": "L14",
                "addr": 4688
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 58,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %esi,%r13d\n  mov    %rdx,%r12\n  mov    %ecx,%ebp\n  mov    %r8,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r9\n  test   %r13d,%r13d\n  jle    11f2 <func0+0xd9>\n  mov    %r14,%rsi\n  lea    -0x1(%r13),%eax\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%rbp),%eax\n  lea    0x4(%r12,%rax,4),%rdi\n  mov    $0x0,%r8d\n  lea    0x4(%r9),%r11\n  jmp    117f <func0+0x66>\n  movslq %r8d,%rax\n  mov    %edx,(%r9,%rax,4)\n  lea    0x1(%r8),%r8d\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  je     11b6 <func0+0x9d>\n  test   %r8d,%r8d\n  jle    119e <func0+0x85>\n  mov    (%rsi),%edx\n  mov    %r9,%rax\n  lea    -0x1(%r8),%ecx\n  lea    (%r11,%rcx,4),%rcx\n  cmp    %edx,(%rax)\n  je     1176 <func0+0x5d>\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    1191 <func0+0x78>\n  test   %ebp,%ebp\n  jle    1176 <func0+0x5d>\n  mov    (%rsi),%edx\n  mov    %r12,%rax\n  cmp    (%rax),%edx\n  je     116b <func0+0x52>\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    11a7 <func0+0x8e>\n  jmp    1176 <func0+0x5d>\n  lea    -0x1(%r8),%edi\n  test   %edi,%edi\n  jle    11f8 <func0+0xdf>\n  lea    0x4(%r9),%r10\n  jmp    11e2 <func0+0xc9>\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  je     11dd <func0+0xc4>\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11c4 <func0+0xab>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    11c4 <func0+0xab>\n  sub    $0x1,%edi\n  je     11f8 <func0+0xdf>\n  test   %edi,%edi\n  jle    11dd <func0+0xc4>\n  mov    %r9,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r10,%rdx,4),%rsi\n  jmp    11cd <func0+0xb4>\n  mov    $0x0,%r8d\n  mov    %r8d,(%rbx)\n  mov    %r9,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %esi,%r13d\n  mov    %rdx,%r12\n  mov    %ecx,%ebp\n  mov    %r8,%rbx\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r9\n  test   %r13d,%r13d\n  jle    L0\n  mov    %r14,%rsi\n  lea    -0x1(%r13),%eax\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%rbp),%eax\n  lea    0x4(%r12,%rax,4),%rdi\n  mov    $0x0,%r8d\n  lea    0x4(%r9),%r11\n  jmp    L1\nL6:\n  movslq %r8d,%rax\n  mov    %edx,(%r9,%rax,4)\n  lea    0x1(%r8),%r8d\nL4:\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  je     L2\nL1:\n  test   %r8d,%r8d\n  jle    L3\n  mov    (%rsi),%edx\n  mov    %r9,%rax\n  lea    -0x1(%r8),%ecx\n  lea    (%r11,%rcx,4),%rcx\nL5:\n  cmp    %edx,(%rax)\n  je     L4\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L5\nL3:\n  test   %ebp,%ebp\n  jle    L4\n  mov    (%rsi),%edx\n  mov    %r12,%rax\nL7:\n  cmp    (%rax),%edx\n  je     L6\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    L7\n  jmp    L4\nL2:\n  lea    -0x1(%r8),%edi\n  test   %edi,%edi\n  jle    L8\n  lea    0x4(%r9),%r10\n  jmp    L9\nL11:\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  je     L10\nL12:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L11\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    L11\nL10:\n  sub    $0x1,%edi\n  je     L8\nL9:\n  test   %edi,%edi\n  jle    L10\n  mov    %r9,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r10,%rdx,4),%rsi\n  jmp    L12\nL0:\n  mov    $0x0,%r8d\nL8:\n  mov    %r8d,(%rbx)\n  mov    %r9,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4594
            },
            "L1": {
                "label": "L1",
                "addr": 4479
            },
            "L2": {
                "label": "L2",
                "addr": 4534
            },
            "L3": {
                "label": "L3",
                "addr": 4510
            },
            "L4": {
                "label": "L4",
                "addr": 4470
            },
            "L5": {
                "label": "L5",
                "addr": 4497
            },
            "L6": {
                "label": "L6",
                "addr": 4459
            },
            "L7": {
                "label": "L7",
                "addr": 4519
            },
            "L8": {
                "label": "L8",
                "addr": 4600
            },
            "L9": {
                "label": "L9",
                "addr": 4578
            },
            "L10": {
                "label": "L10",
                "addr": 4573
            },
            "L11": {
                "label": "L11",
                "addr": 4548
            },
            "L12": {
                "label": "L12",
                "addr": 4557
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 58,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rdi,%r14\n  movslq %esi,%rdi\n  push   %r13\n  mov    %rdi,%r13\n  shl    $0x2,%rdi\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %r8,%rbx\n  call   1050 <malloc@plt>\n  mov    %rax,%r8\n  test   %r13d,%r13d\n  jle    122a <func0+0x10a>\n  lea    -0x1(%r13),%eax\n  mov    %r14,%rsi\n  lea    0x4(%r8),%r11\n  xor    %r9d,%r9d\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%r12),%eax\n  lea    0x4(%rbp,%rax,4),%rdi\n  test   %r9d,%r9d\n  je     11f0 <func0+0xd0>\n  lea    -0x1(%r9),%ecx\n  mov    (%rsi),%edx\n  mov    %r8,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    1191 <func0+0x71>\n  nopl   0x0(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     11f0 <func0+0xd0>\n  cmp    %edx,(%rax)\n  jne    1188 <func0+0x68>\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  jne    1170 <func0+0x50>\n  lea    -0x1(%r9),%edx\n  test   %edx,%edx\n  jle    11dd <func0+0xbd>\n  lea    0x4(%r8),%r10\n  nopw   0x0(%rax,%rax,1)\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r10,%rdx,4),%rsi\n  nopl   (%rax)\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11ce <func0+0xae>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    11c0 <func0+0xa0>\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    11b0 <func0+0x90>\n  mov    %r9d,(%rbx)\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\n  test   %r12d,%r12d\n  jle    1195 <func0+0x75>\n  mov    (%rsi),%edx\n  mov    %rbp,%rax\n  jmp    1209 <func0+0xe9>\n  nopl   0x0(%rax)\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     1195 <func0+0x75>\n  cmp    (%rax),%edx\n  jne    1200 <func0+0xe0>\n  movslq %r9d,%rax\n  add    $0x4,%rsi\n  add    $0x1,%r9d\n  mov    %edx,(%r8,%rax,4)\n  cmp    %r10,%rsi\n  jne    1170 <func0+0x50>\n  jmp    119e <func0+0x7e>\n  xor    %r9d,%r9d\n  mov    %r8,%rax\n  mov    %r9d,(%rbx)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rdi,%r14\n  movslq %esi,%rdi\n  push   %r13\n  mov    %rdi,%r13\n  shl    $0x2,%rdi\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %r8,%rbx\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%eax\n  mov    %r14,%rsi\n  lea    0x4(%r8),%r11\n  xor    %r9d,%r9d\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%r12),%eax\n  lea    0x4(%rbp,%rax,4),%rdi\nL4:\n  test   %r9d,%r9d\n  je     L1\n  lea    -0x1(%r9),%ecx\n  mov    (%rsi),%edx\n  mov    %r8,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    L2\n  nopl   0x0(%rax)\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\nL9:\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  jne    L4\nL12:\n  lea    -0x1(%r9),%edx\n  test   %edx,%edx\n  jle    L5\n  lea    0x4(%r8),%r10\n  nopw   0x0(%rax,%rax,1)\nL8:\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r10,%rdx,4),%rsi\n  nopl   (%rax)\nL7:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L6\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\nL6:\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    L7\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    L8\nL5:\n  mov    %r9d,(%rbx)\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\nL1:\n  test   %r12d,%r12d\n  jle    L9\n  mov    (%rsi),%edx\n  mov    %rbp,%rax\n  jmp    L10\n  nopl   0x0(%rax)\nL11:\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     L9\nL10:\n  cmp    (%rax),%edx\n  jne    L11\n  movslq %r9d,%rax\n  add    $0x4,%rsi\n  add    $0x1,%r9d\n  mov    %edx,(%r8,%rax,4)\n  cmp    %r10,%rsi\n  jne    L4\n  jmp    L12\nL0:\n  xor    %r9d,%r9d\n  mov    %r8,%rax\n  mov    %r9d,(%rbx)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4650
            },
            "L1": {
                "label": "L1",
                "addr": 4592
            },
            "L2": {
                "label": "L2",
                "addr": 4497
            },
            "L3": {
                "label": "L3",
                "addr": 4488
            },
            "L4": {
                "label": "L4",
                "addr": 4464
            },
            "L5": {
                "label": "L5",
                "addr": 4573
            },
            "L6": {
                "label": "L6",
                "addr": 4558
            },
            "L7": {
                "label": "L7",
                "addr": 4544
            },
            "L8": {
                "label": "L8",
                "addr": 4528
            },
            "L9": {
                "label": "L9",
                "addr": 4501
            },
            "L10": {
                "label": "L10",
                "addr": 4617
            },
            "L11": {
                "label": "L11",
                "addr": 4608
            },
            "L12": {
                "label": "L12",
                "addr": 4510
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 58,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int *l1, int size1, int *l2, int size2, int *out_size) {\n    int *out = malloc(size1 * sizeof(int));\n    int k = 0, i, j, m;\n\n    for (i = 0; i < size1; i++) {\n        int exists_in_out = 0;\n        for (m = 0; m < k; m++) {\n            if (out[m] == l1[i]) {\n                exists_in_out = 1;\n                break;\n            }\n        }\n        if (!exists_in_out) {\n            for (j = 0; j < size2; j++) {\n                if (l1[i] == l2[j]) {\n                    out[k++] = l1[i];\n                    break;\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < k - 1; i++) {\n        for (j = 0; j < k - i - 1; j++) {\n            if (out[j] > out[j + 1]) {\n                int temp = out[j];\n                out[j] = out[j + 1];\n                out[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = k;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int size;\n\n    int l1[] = {1, 4, 3, 34, 653, 2, 5};\n    int l2[] = {5, 7, 1, 5, 9, 653, 121};\n    int expected1[] = {1, 5, 653};\n    int *result1 = func0(l1, 7, l2, 7, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result1[i] == expected1[i]);\n    }\n    free(result1);\n\n    int l3[] = {5, 3, 2, 8};\n    int l4[] = {3, 2};\n    int expected2[] = {2, 3};\n    int *result2 = func0(l3, 4, l4, 2, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result2[i] == expected2[i]);\n    }\n    free(result2);\n\n    int l5[] = {4, 3, 2, 8};\n    int l6[] = {3, 2, 4};\n    int expected3[] = {2, 3, 4};\n    int *result3 = func0(l5, 4, l6, 3, &size);\n    for (int i = 0; i < size; i++) {\n        assert(result3[i] == expected3[i]);\n    }\n    free(result3);\n\n    int l7[] = {4, 3, 2, 8};\n    int l8[] = {};\n    int *result4 = func0(l7, 4, l8, 0, &size);\n    assert(size == 0); // Since l8 is empty, result4 should be empty as well\n    free(result4);\n\n    return 0;\n}\n",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rdi,%r14\n  movslq %esi,%rdi\n  push   %r13\n  mov    %rdi,%r13\n  shl    $0x2,%rdi\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %r8,%rbx\n  call   1050 <malloc@plt>\n  mov    %rax,%r8\n  test   %r13d,%r13d\n  jle    1246 <func0+0x126>\n  lea    -0x1(%r13),%eax\n  mov    %r14,%rsi\n  lea    0x4(%r8),%r11\n  xor    %r9d,%r9d\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%r12),%eax\n  lea    0x4(%rbp,%rax,4),%rdi\n  test   %r9d,%r9d\n  je     1208 <func0+0xe8>\n  lea    -0x1(%r9),%ecx\n  mov    (%rsi),%edx\n  mov    %r8,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    1199 <func0+0x79>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     1208 <func0+0xe8>\n  cmp    %edx,(%rax)\n  jne    1190 <func0+0x70>\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  jne    1170 <func0+0x50>\n  lea    -0x1(%r9),%eax\n  test   %eax,%eax\n  jle    11f5 <func0+0xd5>\n  lea    0x4(%r8),%r10\n  nopw   0x0(%rax,%rax,1)\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%r10,%rax,4),%rsi\n  nopl   (%rax)\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    11e6 <func0+0xc6>\n  movq   %xmm1,(%rdx)\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    11c8 <func0+0xa8>\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    11b8 <func0+0x98>\n  mov    %r9d,(%rbx)\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\n  test   %r12d,%r12d\n  jle    119d <func0+0x7d>\n  mov    (%rsi),%edx\n  mov    %rbp,%rax\n  jmp    1225 <func0+0x105>\n  nopl   0x0(%rax)\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     119d <func0+0x7d>\n  cmp    (%rax),%edx\n  jne    1218 <func0+0xf8>\n  movslq %r9d,%rax\n  add    $0x4,%rsi\n  add    $0x1,%r9d\n  mov    %edx,(%r8,%rax,4)\n  cmp    %r10,%rsi\n  jne    1170 <func0+0x50>\n  jmp    11a6 <func0+0x86>\n  xor    %r9d,%r9d\n  mov    %r8,%rax\n  mov    %r9d,(%rbx)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rdi,%r14\n  movslq %esi,%rdi\n  push   %r13\n  mov    %rdi,%r13\n  shl    $0x2,%rdi\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %r8,%rbx\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%eax\n  mov    %r14,%rsi\n  lea    0x4(%r8),%r11\n  xor    %r9d,%r9d\n  lea    0x4(%r14,%rax,4),%r10\n  lea    -0x1(%r12),%eax\n  lea    0x4(%rbp,%rax,4),%rdi\nL4:\n  test   %r9d,%r9d\n  je     L1\n  lea    -0x1(%r9),%ecx\n  mov    (%rsi),%edx\n  mov    %r8,%rax\n  lea    (%r11,%rcx,4),%rcx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  je     L1\nL2:\n  cmp    %edx,(%rax)\n  jne    L3\nL9:\n  add    $0x4,%rsi\n  cmp    %r10,%rsi\n  jne    L4\nL12:\n  lea    -0x1(%r9),%eax\n  test   %eax,%eax\n  jle    L5\n  lea    0x4(%r8),%r10\n  nopw   0x0(%rax,%rax,1)\nL8:\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%r10,%rax,4),%rsi\n  nopl   (%rax)\nL7:\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    L6\n  movq   %xmm1,(%rdx)\nL6:\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    L7\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    L8\nL5:\n  mov    %r9d,(%rbx)\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\nL1:\n  test   %r12d,%r12d\n  jle    L9\n  mov    (%rsi),%edx\n  mov    %rbp,%rax\n  jmp    L10\n  nopl   0x0(%rax)\nL11:\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     L9\nL10:\n  cmp    (%rax),%edx\n  jne    L11\n  movslq %r9d,%rax\n  add    $0x4,%rsi\n  add    $0x1,%r9d\n  mov    %edx,(%r8,%rax,4)\n  cmp    %r10,%rsi\n  jne    L4\n  jmp    L12\nL0:\n  xor    %r9d,%r9d\n  mov    %r8,%rax\n  mov    %r9d,(%rbx)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4678
            },
            "L1": {
                "label": "L1",
                "addr": 4616
            },
            "L2": {
                "label": "L2",
                "addr": 4505
            },
            "L3": {
                "label": "L3",
                "addr": 4496
            },
            "L4": {
                "label": "L4",
                "addr": 4464
            },
            "L5": {
                "label": "L5",
                "addr": 4597
            },
            "L6": {
                "label": "L6",
                "addr": 4582
            },
            "L7": {
                "label": "L7",
                "addr": 4552
            },
            "L8": {
                "label": "L8",
                "addr": 4536
            },
            "L9": {
                "label": "L9",
                "addr": 4509
            },
            "L10": {
                "label": "L10",
                "addr": 4645
            },
            "L11": {
                "label": "L11",
                "addr": 4632
            },
            "L12": {
                "label": "L12",
                "addr": 4518
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 59,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    1130 <func0+0x37>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %eax,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    112c <func0+0x33>\n  mov    -0x14(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jg     110d <func0+0x14>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    1117 <func0+0x1e>\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %eax,-0x14(%rbp)\nL3:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x14(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jg     L2\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L3\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4400
            },
            "L1": {
                "label": "L1",
                "addr": 4396
            },
            "L2": {
                "label": "L2",
                "addr": 4365
            },
            "L3": {
                "label": "L3",
                "addr": 4375
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 59,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jg     1116 <func0+0x1d>\n  mov    %edi,%eax\n  ret\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     1107 <func0+0xe>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    110a <func0+0x11>\n  cmp    %ecx,%edi\n  jle    110a <func0+0x11>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%esi\n  mov    %eax,%edi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    110a <func0+0x11>\n  cmp    %ecx,%esi\n  jg     1123 <func0+0x2a>\n  jmp    110a <func0+0x11>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jg     L0\nL1:\n  mov    %edi,%eax\n  ret\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     L1\nL0:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\n  cmp    %ecx,%edi\n  jle    L2\nL3:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%esi\n  mov    %eax,%edi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\n  cmp    %ecx,%esi\n  jg     L3\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4374
            },
            "L1": {
                "label": "L1",
                "addr": 4359
            },
            "L2": {
                "label": "L2",
                "addr": 4362
            },
            "L3": {
                "label": "L3",
                "addr": 4387
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 59,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%r8d\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jle    114a <func0+0x4a>\n  nopl   0x0(%rax)\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1138 <func0+0x38>\n  jmp    113d <func0+0x3d>\n  nopl   0x0(%rax)\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%r8d\n  idiv   %ecx\n  test   %edx,%edx\n  jne    113d <func0+0x3d>\n  cmp    %ecx,%r8d\n  jg     1128 <func0+0x28>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%r8d\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jle    L0\n  nopl   0x0(%rax)\nL4:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L1\n  jmp    L2\n  nopl   0x0(%rax)\nL3:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%r8d\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\nL1:\n  cmp    %ecx,%r8d\n  jg     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    L4\nL0:\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4426
            },
            "L1": {
                "label": "L1",
                "addr": 4408
            },
            "L2": {
                "label": "L2",
                "addr": 4413
            },
            "L3": {
                "label": "L3",
                "addr": 4392
            },
            "L4": {
                "label": "L4",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 59,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    for (int i = 2; i * i <= n; i++)\n        while (n % i == 0 && n > i) n = n / i;\n    return n;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(15) == 5);\n    assert(func0(27) == 3);\n    assert(func0(63) == 7);\n    assert(func0(330) == 11);\n    assert(func0(13195) == 29);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%r8d\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jle    114a <func0+0x4a>\n  nopl   0x0(%rax)\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1138 <func0+0x38>\n  jmp    113d <func0+0x3d>\n  nopl   0x0(%rax)\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%r8d\n  idiv   %ecx\n  test   %edx,%edx\n  jne    113d <func0+0x3d>\n  cmp    %ecx,%r8d\n  jg     1128 <func0+0x28>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%r8d\n  mov    $0x2,%ecx\n  cmp    $0x3,%edi\n  jle    L0\n  nopl   0x0(%rax)\nL4:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L1\n  jmp    L2\n  nopl   0x0(%rax)\nL3:\n  mov    %r8d,%eax\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%r8d\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\nL1:\n  cmp    %ecx,%r8d\n  jg     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %r8d,%eax\n  jle    L4\nL0:\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4426
            },
            "L1": {
                "label": "L1",
                "addr": 4408
            },
            "L2": {
                "label": "L2",
                "addr": 4413
            },
            "L3": {
                "label": "L3",
                "addr": 4392
            },
            "L4": {
                "label": "L4",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 60,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  add    $0x1,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  add    $0x1,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 60,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 60,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 60,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    return n * (n + 1) / 2;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(6) == 21);\n    assert(func0(11) == 66);\n    assert(func0(30) == 465);\n    assert(func0(100) == 5050);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  lea    0x1(%rdi),%edx\n  imul   %edi,%edx\n  mov    %edx,%eax\n  shr    $0x1f,%eax\n  add    %edx,%eax\n  sar    %eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 61,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    117b <func0+0x62>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    1152 <func0+0x39>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    116a <func0+0x51>\n  subl   $0x1,-0x18(%rbp)\n  cmpl   $0x0,-0x18(%rbp)\n  jns    1177 <func0+0x5e>\n  mov    $0x0,%eax\n  jmp    1199 <func0+0x80>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     113a <func0+0x21>\n  cmpl   $0x0,-0x18(%rbp)\n  sete   %al\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL5:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    L1\n  addl   $0x1,-0x18(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    L2\n  subl   $0x1,-0x18(%rbp)\nL2:\n  cmpl   $0x0,-0x18(%rbp)\n  jns    L3\n  mov    $0x0,%eax\n  jmp    L4\nL3:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L5\n  cmpl   $0x0,-0x18(%rbp)\n  sete   %al\nL4:\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4475
            },
            "L1": {
                "label": "L1",
                "addr": 4434
            },
            "L2": {
                "label": "L2",
                "addr": 4458
            },
            "L3": {
                "label": "L3",
                "addr": 4471
            },
            "L4": {
                "label": "L4",
                "addr": 4505
            },
            "L5": {
                "label": "L5",
                "addr": 4410
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 61,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rax,%rdi\n  mov    %rbx,%rax\n  add    %rbx,%rdi\n  mov    $0x0,%edx\n  jmp    1141 <func0+0x28>\n  add    $0x1,%edx\n  add    $0x1,%rax\n  test   %edx,%edx\n  js     1162 <func0+0x49>\n  cmp    %rdi,%rax\n  je     115b <func0+0x42>\n  movzbl (%rax),%ecx\n  cmp    $0x28,%cl\n  je     1136 <func0+0x1d>\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%edx\n  jmp    1139 <func0+0x20>\n  test   %edx,%edx\n  sete   %al\n  pop    %rbx\n  ret\n  mov    $0x0,%eax\n  jmp    1160 <func0+0x47>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rax,%rdi\n  mov    %rbx,%rax\n  add    %rbx,%rdi\n  mov    $0x0,%edx\n  jmp    L0\nL3:\n  add    $0x1,%edx\nL4:\n  add    $0x1,%rax\n  test   %edx,%edx\n  js     L1\nL0:\n  cmp    %rdi,%rax\n  je     L2\n  movzbl (%rax),%ecx\n  cmp    $0x28,%cl\n  je     L3\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%edx\n  jmp    L4\nL2:\n  test   %edx,%edx\n  sete   %al\nL5:\n  pop    %rbx\n  ret\nL1:\n  mov    $0x0,%eax\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4417
            },
            "L1": {
                "label": "L1",
                "addr": 4450
            },
            "L2": {
                "label": "L2",
                "addr": 4443
            },
            "L3": {
                "label": "L3",
                "addr": 4406
            },
            "L4": {
                "label": "L4",
                "addr": 4409
            },
            "L5": {
                "label": "L5",
                "addr": 4448
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 61,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  add    %rbx,%rax\n  jmp    114e <func0+0x2e>\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x29,%dl\n  jne    114a <func0+0x2a>\n  sub    $0x1,%ecx\n  jb     1170 <func0+0x50>\n  add    $0x1,%rdi\n  cmp    %rax,%rdi\n  je     1160 <func0+0x40>\n  movzbl (%rdi),%edx\n  cmp    $0x28,%dl\n  jne    1140 <func0+0x20>\n  add    $0x1,%ecx\n  jmp    114a <func0+0x2a>\n  test   %ecx,%ecx\n  pop    %rbx\n  sete   %al\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  add    %rbx,%rax\n  jmp    L0\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    $0x29,%dl\n  jne    L1\n  sub    $0x1,%ecx\n  jb     L2\nL1:\n  add    $0x1,%rdi\nL0:\n  cmp    %rax,%rdi\n  je     L3\n  movzbl (%rdi),%edx\n  cmp    $0x28,%dl\n  jne    L4\n  add    $0x1,%ecx\n  jmp    L1\nL3:\n  test   %ecx,%ecx\n  pop    %rbx\n  sete   %al\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4430
            },
            "L1": {
                "label": "L1",
                "addr": 4426
            },
            "L2": {
                "label": "L2",
                "addr": 4464
            },
            "L3": {
                "label": "L3",
                "addr": 4448
            },
            "L4": {
                "label": "L4",
                "addr": 4416
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 61,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool func0(const char *brackets) {\n    int level = 0;\n    for (int i = 0; i < strlen(brackets); i++) {\n        if (brackets[i] == '(') level += 1;\n        if (brackets[i] == ')') level -= 1;\n        if (level < 0) return false;\n    }\n    return level == 0;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"()\"));\n    assert(func0(\"(()())\"));\n    assert(func0(\"()()(()())()\"));\n    assert(func0(\"()()((()()())())(()()(()))\"));\n    assert(!func0(\"((()())))\"));\n    assert(!func0(\")(()\"));\n    assert(!func0(\"(\"));\n    assert(!func0(\"((((\"));\n    assert(!func0(\")\"));\n    assert(!func0(\"(()\"));\n    assert(!func0(\"()()(()())())(()\"));\n    assert(!func0(\"()()(()())()))()\"));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  add    %rbx,%rax\n  jmp    114e <func0+0x2e>\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x29,%dl\n  jne    114a <func0+0x2a>\n  sub    $0x1,%ecx\n  jb     1170 <func0+0x50>\n  add    $0x1,%rdi\n  cmp    %rax,%rdi\n  je     1160 <func0+0x40>\n  movzbl (%rdi),%edx\n  cmp    $0x28,%dl\n  jne    1140 <func0+0x20>\n  add    $0x1,%ecx\n  jmp    114a <func0+0x2a>\n  test   %ecx,%ecx\n  pop    %rbx\n  sete   %al\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  add    %rbx,%rax\n  jmp    L0\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    $0x29,%dl\n  jne    L1\n  sub    $0x1,%ecx\n  jb     L2\nL1:\n  add    $0x1,%rdi\nL0:\n  cmp    %rax,%rdi\n  je     L3\n  movzbl (%rdi),%edx\n  cmp    $0x28,%dl\n  jne    L4\n  add    $0x1,%ecx\n  jmp    L1\nL3:\n  test   %ecx,%ecx\n  pop    %rbx\n  sete   %al\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4430
            },
            "L1": {
                "label": "L1",
                "addr": 4426
            },
            "L2": {
                "label": "L2",
                "addr": 4464
            },
            "L3": {
                "label": "L3",
                "addr": 4448
            },
            "L4": {
                "label": "L4",
                "addr": 4416
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 62,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    1156 <func0+0x5d>\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x4(%rbp),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mulss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1115 <func0+0x1c>\n  nop\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    L0\nL1:\n  pxor   %xmm1,%xmm1\n  cvtsi2ssl -0x4(%rbp),%xmm1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mulss  %xmm1,%xmm0\n  movss  %xmm0,(%rax)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L1\n  nop\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4438
            },
            "L1": {
                "label": "L1",
                "addr": 4373
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 62,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1125 <func0+0x2c>\n  mov    %esi,%esi\n  mov    $0x1,%eax\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rdi,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    1109 <func0+0x10>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %esi,%esi\n  mov    $0x1,%eax\nL1:\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rdi,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    L1\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4389
            },
            "L1": {
                "label": "L1",
                "addr": 4361
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 62,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1134 <func0+0x34>\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rdi,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    1118 <func0+0x18>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\nL1:\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rdi,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    L1\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4404
            },
            "L1": {
                "label": "L1",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 62,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(const float *xs, int xs_size, float *out) {\n    for (int i = 1; i < xs_size; i++) {\n        out[i - 1] = i * xs[i];\n    }\n}",
        "c_test": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(const float *a, int a_size, const float *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (fabs(a[i] - b[i]) > 1e-4) return false;\n    }\n    return true;\n}\n\nint main() {\n    float result[4];\n\n    float case1[] = {3, 1, 2, 4, 5};\n    float expected1[] = {1, 4, 12, 20};\n    func0(case1, 5, result);\n    assert(issame(result, 4, expected1, 4));\n\n    float case2[] = {1, 2, 3};\n    float expected2[] = {2, 6};\n    func0(case2, 3, result);\n    assert(issame(result, 2, expected2, 2));\n\n    float case3[] = {3, 2, 1};\n    float expected3[] = {2, 2};\n    func0(case3, 3, result);\n    assert(issame(result, 2, expected3, 2));\n\n    float case4[] = {3, 2, 1, 0, 4};\n    float expected4[] = {2, 2, 0, 16};\n    func0(case4, 5, result);\n    assert(issame(result, 4, expected4, 4));\n\n    float case5[] = {1};\n    func0(case5, 1, result);\n    assert(issame(result, 0, NULL, 0));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  cmp    $0x1,%esi\n  jle    11e8 <func0+0xe8>\n  lea    0x8(%rdi),%rdi\n  mov    %rdx,%rax\n  sub    %rdi,%rax\n  cmp    $0x8,%rax\n  jbe    11f0 <func0+0xf0>\n  cmp    $0x2,%esi\n  je     11f0 <func0+0xf0>\n  lea    -0x2(%rsi),%eax\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%eax\n  jbe    121d <func0+0x11d>\n  mov    %r8d,%edi\n  movdqa 0xeb8(%rip),%xmm1        # 2000 <_fini+0xdd4>\n  movdqa 0xec0(%rip),%xmm2        # 2010 <_fini+0xde4>\n  xor    %eax,%eax\n  shr    $0x2,%edi\n  shl    $0x4,%rdi\n  nopl   0x0(%rax)\n  movups 0x4(%rcx,%rax,1),%xmm3\n  movdqa %xmm1,%xmm0\n  paddd  %xmm2,%xmm1\n  cvtdq2ps %xmm0,%xmm0\n  mulps  %xmm3,%xmm0\n  movups %xmm0,(%rdx,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rdi\n  jne    1160 <func0+0x60>\n  mov    %r8d,%r9d\n  and    $0xfffffffc,%r9d\n  lea    0x1(%r9),%edi\n  mov    %edi,%eax\n  cmp    %r9d,%r8d\n  je     11e8 <func0+0xe8>\n  sub    %r9d,%esi\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%esi\n  je     11cc <func0+0xcc>\n  mov    %edi,%esi\n  lea    0x1(%rax),%edi\n  movd   %eax,%xmm0\n  movq   (%rcx,%rsi,4),%xmm1\n  movd   %edi,%xmm4\n  punpckldq %xmm4,%xmm0\n  cvtdq2ps %xmm0,%xmm0\n  mulps  %xmm1,%xmm0\n  movlps %xmm0,-0x4(%rdx,%rsi,4)\n  mov    %r8d,%esi\n  and    $0xfffffffe,%esi\n  add    %esi,%eax\n  cmp    %esi,%r8d\n  je     11e8 <func0+0xe8>\n  movslq %eax,%rsi\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rcx,%rsi,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rsi,4)\n  ret\n  nopl   0x0(%rax,%rax,1)\n  ret\n  nopl   0x0(%rax)\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  nopl   0x0(%rax,%rax,1)\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rcx,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    1200 <func0+0x100>\n  ret\n  mov    $0x1,%eax\n  mov    $0x1,%edi\n  jmp    119e <func0+0x9e>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  cmp    $0x1,%esi\n  jle    L0\n  lea    0x8(%rdi),%rdi\n  mov    %rdx,%rax\n  sub    %rdi,%rax\n  cmp    $0x8,%rax\n  jbe    L1\n  cmp    $0x2,%esi\n  je     L1\n  lea    -0x2(%rsi),%eax\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%eax\n  jbe    L2\n  mov    %r8d,%edi\n  movdqa D0(%rip),%xmm1\n  movdqa D1(%rip),%xmm2\n  xor    %eax,%eax\n  shr    $0x2,%edi\n  shl    $0x4,%rdi\n  nopl   0x0(%rax)\nL3:\n  movups 0x4(%rcx,%rax,1),%xmm3\n  movdqa %xmm1,%xmm0\n  paddd  %xmm2,%xmm1\n  cvtdq2ps %xmm0,%xmm0\n  mulps  %xmm3,%xmm0\n  movups %xmm0,(%rdx,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rdi\n  jne    L3\n  mov    %r8d,%r9d\n  and    $0xfffffffc,%r9d\n  lea    0x1(%r9),%edi\n  mov    %edi,%eax\n  cmp    %r9d,%r8d\n  je     L0\n  sub    %r9d,%esi\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x2,%esi\n  je     L4\nL6:\n  mov    %edi,%esi\n  lea    0x1(%rax),%edi\n  movd   %eax,%xmm0\n  movq   (%rcx,%rsi,4),%xmm1\n  movd   %edi,%xmm4\n  punpckldq %xmm4,%xmm0\n  cvtdq2ps %xmm0,%xmm0\n  mulps  %xmm1,%xmm0\n  movlps %xmm0,-0x4(%rdx,%rsi,4)\n  mov    %r8d,%esi\n  and    $0xfffffffe,%esi\n  add    %esi,%eax\n  cmp    %esi,%r8d\n  je     L0\nL4:\n  movslq %eax,%rsi\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rcx,%rsi,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rsi,4)\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  ret\n  nopl   0x0(%rax)\nL1:\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  nopl   0x0(%rax,%rax,1)\nL5:\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  mulss  (%rcx,%rax,4),%xmm0\n  movss  %xmm0,-0x4(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    L5\n  ret\nL2:\n  mov    $0x1,%eax\n  mov    $0x1,%edi\n  jmp    L6",
        "num_missing": 2,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3768
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3776
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4584
            },
            "L1": {
                "label": "L1",
                "addr": 4592
            },
            "L2": {
                "label": "L2",
                "addr": 4637
            },
            "L3": {
                "label": "L3",
                "addr": 4448
            },
            "L4": {
                "label": "L4",
                "addr": 4556
            },
            "L5": {
                "label": "L5",
                "addr": 4608
            },
            "L6": {
                "label": "L6",
                "addr": 4510
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0100000002000000030000000400000004000000040000000400000004000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        1,
                        0,
                        0,
                        0,
                        2,
                        0,
                        0,
                        0,
                        3,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0
                    ]
                },
                "0x2010": {
                    "type": "byte[16]",
                    "value": [
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 63,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x1c0,%rsp\n  mov    %edi,-0x1b4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0x1a0(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x32,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x19c(%rbp)\n  movl   $0x1,-0x198(%rbp)\n  movl   $0x3,-0x1a4(%rbp)\n  jmp    11c4 <func0+0xab>\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x3,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  cltq\n  mov    %edx,-0x1a0(%rbp,%rax,4)\n  addl   $0x1,-0x1a4(%rbp)\n  mov    -0x1a4(%rbp),%eax\n  cmp    -0x1b4(%rbp),%eax\n  jle    1174 <func0+0x5b>\n  mov    -0x1b4(%rbp),%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     11f5 <func0+0xdc>\n  call   1050 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x1c0,%rsp\n  mov    %edi,-0x1b4(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0x1a0(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0x32,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x19c(%rbp)\n  movl   $0x1,-0x198(%rbp)\n  movl   $0x3,-0x1a4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x1,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x2,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  sub    $0x3,%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  add    %eax,%edx\n  mov    -0x1a4(%rbp),%eax\n  cltq\n  mov    %edx,-0x1a0(%rbp,%rax,4)\n  addl   $0x1,-0x1a4(%rbp)\nL0:\n  mov    -0x1a4(%rbp),%eax\n  cmp    -0x1b4(%rbp),%eax\n  jle    L1\n  mov    -0x1b4(%rbp),%eax\n  cltq\n  mov    -0x1a0(%rbp,%rax,4),%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L2\n  call   <__stack_chk_fail@plt>\nL2:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4548
            },
            "L1": {
                "label": "L1",
                "addr": 4468
            },
            "L2": {
                "label": "L2",
                "addr": 4597
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 63,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %edi,%esi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x32,%ecx\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%esi\n  jle    1170 <func0+0x57>\n  mov    %rsp,%rax\n  lea    -0x3(%rsi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\n  mov    0x4(%rax),%edx\n  add    0x8(%rax),%edx\n  add    (%rax),%edx\n  mov    %edx,0xc(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    115c <func0+0x43>\n  movslq %esi,%rsi\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    1191 <func0+0x78>\n  add    $0x1a8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  mov    %edi,%esi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0x32,%ecx\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%esi\n  jle    L0\n  mov    %rsp,%rax\n  lea    -0x3(%rsi),%edx\n  lea    0x4(%rsp,%rdx,4),%rcx\nL1:\n  mov    0x4(%rax),%edx\n  add    0x8(%rax),%edx\n  add    (%rax),%edx\n  mov    %edx,0xc(%rax)\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L1\nL0:\n  movslq %esi,%rsi\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L2\n  add    $0x1a8,%rsp\n  ret\nL2:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4464
            },
            "L1": {
                "label": "L1",
                "addr": 4444
            },
            "L2": {
                "label": "L2",
                "addr": 4497
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 63,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movslq %edi,%r8\n  mov    $0x32,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%r8d\n  jle    1190 <func0+0x70>\n  lea    -0x3(%r8),%edx\n  lea    0x4(%rsp),%rax\n  xor    %esi,%esi\n  lea    0x8(%rsp,%rdx,4),%rdi\n  mov    $0x1,%edx\n  jmp    1180 <func0+0x60>\n  nopl   0x0(%rax)\n  mov    0x4(%rax),%edx\n  mov    (%rax),%ecx\n  mov    -0x4(%rax),%esi\n  add    %ecx,%edx\n  add    $0x4,%rax\n  add    %esi,%edx\n  mov    %edx,0x4(%rax)\n  cmp    %rdi,%rax\n  jne    1178 <func0+0x58>\n  mov    (%rsp,%r8,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    11af <func0+0x8f>\n  add    $0x1a8,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movslq %edi,%r8\n  mov    $0x32,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%r8d\n  jle    L0\n  lea    -0x3(%r8),%edx\n  lea    0x4(%rsp),%rax\n  xor    %esi,%esi\n  lea    0x8(%rsp,%rdx,4),%rdi\n  mov    $0x1,%edx\n  jmp    L1\n  nopl   0x0(%rax)\nL2:\n  mov    0x4(%rax),%edx\n  mov    (%rax),%ecx\n  mov    -0x4(%rax),%esi\nL1:\n  add    %ecx,%edx\n  add    $0x4,%rax\n  add    %esi,%edx\n  mov    %edx,0x4(%rax)\n  cmp    %rdi,%rax\n  jne    L2\nL0:\n  mov    (%rsp,%r8,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L3\n  add    $0x1a8,%rsp\n  ret\nL3:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4496
            },
            "L1": {
                "label": "L1",
                "addr": 4480
            },
            "L2": {
                "label": "L2",
                "addr": 4472
            },
            "L3": {
                "label": "L3",
                "addr": 4527
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 63,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int ff[100] = {0};\n    ff[1] = 0;\n    ff[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        ff[i] = ff[i - 1] + ff[i - 2] + ff[i - 3];\n    }\n    return ff[n];\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2) == 1);\n    assert(func0(1) == 0);\n    assert(func0(5) == 4);\n    assert(func0(8) == 24);\n    assert(func0(10) == 81);\n    assert(func0(12) == 274);\n    assert(func0(14) == 927);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movslq %edi,%rsi\n  mov    $0x32,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r9\n  mov    %r9,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%esi\n  jle    11d7 <func0+0xb7>\n  lea    -0x1(%rsi),%r11d\n  cmp    $0x5,%esi\n  jle    11f5 <func0+0xd5>\n  lea    0xc(%rsp),%r8\n  mov    $0x1,%edi\n  xor    %edx,%edx\n  mov    $0x3,%ecx\n  lea    (%rdx,%rdi,1),%r10d\n  add    $0xc,%r8\n  add    %r10d,%eax\n  lea    (%rax,%rdi,1),%r10d\n  movd   %eax,%xmm0\n  add    %r10d,%edx\n  lea    (%rax,%rdx,1),%r10d\n  movd   %edx,%xmm1\n  add    %r10d,%edi\n  mov    %ecx,%r10d\n  punpckldq %xmm1,%xmm0\n  add    $0x3,%ecx\n  add    $0x4,%r10d\n  movq   %xmm0,-0xc(%r8)\n  mov    %edi,-0x4(%r8)\n  cmp    %r10d,%r11d\n  jg     117a <func0+0x5a>\n  movslq %ecx,%rax\n  lea    (%r9,%rax,4),%rax\n  nop\n  mov    -0x4(%rax),%edx\n  add    $0x1,%ecx\n  add    -0x8(%rax),%edx\n  add    $0x4,%rax\n  add    -0x10(%rax),%edx\n  mov    %edx,-0x4(%rax)\n  cmp    %ecx,%esi\n  jge    11c0 <func0+0xa0>\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    11fc <func0+0xdc>\n  add    $0x1a8,%rsp\n  ret\n  mov    $0x3,%ecx\n  jmp    11b8 <func0+0x98>\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x1a8,%rsp\n  movslq %edi,%rsi\n  mov    $0x32,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x198(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r9\n  mov    %r9,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x1,0x8(%rsp)\n  cmp    $0x2,%esi\n  jle    L0\n  lea    -0x1(%rsi),%r11d\n  cmp    $0x5,%esi\n  jle    L1\n  lea    0xc(%rsp),%r8\n  mov    $0x1,%edi\n  xor    %edx,%edx\n  mov    $0x3,%ecx\nL2:\n  lea    (%rdx,%rdi,1),%r10d\n  add    $0xc,%r8\n  add    %r10d,%eax\n  lea    (%rax,%rdi,1),%r10d\n  movd   %eax,%xmm0\n  add    %r10d,%edx\n  lea    (%rax,%rdx,1),%r10d\n  movd   %edx,%xmm1\n  add    %r10d,%edi\n  mov    %ecx,%r10d\n  punpckldq %xmm1,%xmm0\n  add    $0x3,%ecx\n  add    $0x4,%r10d\n  movq   %xmm0,-0xc(%r8)\n  mov    %edi,-0x4(%r8)\n  cmp    %r10d,%r11d\n  jg     L2\nL5:\n  movslq %ecx,%rax\n  lea    (%r9,%rax,4),%rax\n  nop\nL3:\n  mov    -0x4(%rax),%edx\n  add    $0x1,%ecx\n  add    -0x8(%rax),%edx\n  add    $0x4,%rax\n  add    -0x10(%rax),%edx\n  mov    %edx,-0x4(%rax)\n  cmp    %ecx,%esi\n  jge    L3\nL0:\n  mov    (%rsp,%rsi,4),%eax\n  mov    0x198(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L4\n  add    $0x1a8,%rsp\n  ret\nL1:\n  mov    $0x3,%ecx\n  jmp    L5\nL4:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4567
            },
            "L1": {
                "label": "L1",
                "addr": 4597
            },
            "L2": {
                "label": "L2",
                "addr": 4474
            },
            "L3": {
                "label": "L3",
                "addr": 4544
            },
            "L4": {
                "label": "L4",
                "addr": 4604
            },
            "L5": {
                "label": "L5",
                "addr": 4536
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 64,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    0xeb0(%rip),%rax        # 2000 <_fini+0xe18>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11a1 <func0+0x68>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     119d <func0+0x64>\n  addl   $0x1,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     1173 <func0+0x3a>\n  cmpl   $0x0,-0xc(%rbp)\n  jle    11e1 <func0+0xa8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x79,%al\n  je     11dd <func0+0xa4>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x59,%al\n  jne    11e1 <func0+0xa8>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL2:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\n  addl   $0x1,-0x14(%rbp)\nL1:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L2\n  cmpl   $0x0,-0xc(%rbp)\n  jle    L3\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x79,%al\n  je     L4\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x59,%al\n  jne    L3\nL4:\n  addl   $0x1,-0x14(%rbp)\nL3:\n  mov    -0x14(%rbp),%eax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3760
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4513
            },
            "L1": {
                "label": "L1",
                "addr": 4509
            },
            "L2": {
                "label": "L2",
                "addr": 4467
            },
            "L3": {
                "label": "L3",
                "addr": 4577
            },
            "L4": {
                "label": "L4",
                "addr": 4573
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 64,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r15\n  call   1060 <strlen@plt>\n  test   %eax,%eax\n  jle    11b3 <func0+0x7a>\n  mov    %rax,%r14\n  mov    %r15,%rbx\n  lea    -0x1(%rax),%eax\n  lea    0x1(%r15,%rax,1),%r13\n  mov    $0x0,%ebp\n  lea    0xe8f(%rip),%r12        # 2000 <_fini+0xe44>\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%ebp\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    1171 <func0+0x38>\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebp\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    $0x0,%ebp\n  jmp    11a2 <func0+0x69>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r15\n  call   <strlen@plt>\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r14\n  mov    %r15,%rbx\n  lea    -0x1(%rax),%eax\n  lea    0x1(%r15,%rax,1),%r13\n  mov    $0x0,%ebp\n  lea    D0(%rip),%r12\nL1:\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%ebp\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    L1\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebp\nL2:\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  mov    $0x0,%ebp\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3727
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4531
            },
            "L1": {
                "label": "L1",
                "addr": 4465
            },
            "L2": {
                "label": "L2",
                "addr": 4514
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 64,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  test   %eax,%eax\n  jle    11c8 <func0+0x88>\n  mov    %rax,%r14\n  lea    -0x1(%rax),%eax\n  mov    %r15,%rbx\n  xor    %r12d,%r12d\n  lea    0x1(%r15,%rax,1),%r13\n  lea    0xe8a(%rip),%rbp        # 2000 <_fini+0xe30>\n  cs nopw 0x0(%rax,%rax,1)\n  movsbl (%rbx),%esi\n  mov    %rbp,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    1180 <func0+0x40>\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\n  xor    %r12d,%r12d\n  jmp    11b3 <func0+0x73>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r14\n  lea    -0x1(%rax),%eax\n  mov    %r15,%rbx\n  xor    %r12d,%r12d\n  lea    0x1(%r15,%rax,1),%r13\n  lea    D0(%rip),%rbp\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  movsbl (%rbx),%esi\n  mov    %rbp,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    L1\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\nL2:\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\nL0:\n  xor    %r12d,%r12d\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3722
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4552
            },
            "L1": {
                "label": "L1",
                "addr": 4480
            },
            "L2": {
                "label": "L2",
                "addr": 4531
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 64,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *s) {\n    const char *vowels = \"aeiouAEIOU\";\n    int count = 0;\n    int length = strlen(s);\n    \n    for (int i = 0; i < length; i++) {\n        if (strchr(vowels, s[i])) {\n            count++;\n        }\n    }\n    \n    if (length > 0 && (s[length - 1] == 'y' || s[length - 1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"abcde\") == 2);\n    assert(func0(\"Alone\") == 3);\n    assert(func0(\"key\") == 2);\n    assert(func0(\"bye\") == 1);\n    assert(func0(\"keY\") == 2);\n    assert(func0(\"bYe\") == 1);\n    assert(func0(\"ACEDY\") == 3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  test   %eax,%eax\n  jle    11c8 <func0+0x88>\n  mov    %rax,%r14\n  lea    -0x1(%rax),%eax\n  mov    %r15,%rbx\n  xor    %r12d,%r12d\n  lea    0x1(%r15,%rax,1),%r13\n  lea    0xe8a(%rip),%rbp        # 2000 <_fini+0xe30>\n  cs nopw 0x0(%rax,%rax,1)\n  movsbl (%rbx),%esi\n  mov    %rbp,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    1180 <func0+0x40>\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\n  xor    %r12d,%r12d\n  jmp    11b3 <func0+0x73>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r14\n  lea    -0x1(%rax),%eax\n  mov    %r15,%rbx\n  xor    %r12d,%r12d\n  lea    0x1(%r15,%rax,1),%r13\n  lea    D0(%rip),%rbp\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  movsbl (%rbx),%esi\n  mov    %rbp,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  jne    L1\n  movslq %r14d,%r14\n  movzbl -0x1(%r15,%r14,1),%eax\n  and    $0xffffffdf,%eax\n  cmp    $0x59,%al\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\nL2:\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\nL0:\n  xor    %r12d,%r12d\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3722
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4552
            },
            "L1": {
                "label": "L1",
                "addr": 4480
            },
            "L2": {
                "label": "L2",
                "addr": 4531
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 65,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x60,%rsp\n  mov    %edi,-0x54(%rbp)\n  mov    %esi,-0x58(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x54(%rbp),%eax\n  mov    %eax,%edx\n  lea    0xe3a(%rip),%rax        # 2000 <_fini+0xd10>\n  mov    %rax,%rsi\n  lea    0x2eb0(%rip),%rax        # 4080 <xs.0>\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   10d0 <sprintf@plt>\n  lea    0x2e9c(%rip),%rax        # 4080 <xs.0>\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,-0x44(%rbp)\n  mov    -0x44(%rbp),%eax\n  cmp    -0x58(%rbp),%eax\n  jge    1268 <func0+0xcf>\n  movl   $0x0,-0x48(%rbp)\n  jmp    1255 <func0+0xbc>\n  mov    -0x48(%rbp),%eax\n  cltq\n  lea    0x2e74(%rip),%rdx        # 4080 <xs.0>\n  movzbl (%rax,%rdx,1),%eax\n  mov    %al,-0x49(%rbp)\n  mov    -0x44(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x48(%rbp),%eax\n  cltq\n  lea    0x2e5b(%rip),%rdx        # 4080 <xs.0>\n  movzbl (%rax,%rdx,1),%edx\n  mov    -0x48(%rbp),%eax\n  cltq\n  lea    0x2e4b(%rip),%rcx        # 4080 <xs.0>\n  mov    %dl,(%rax,%rcx,1)\n  mov    -0x44(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x48(%rbp),%eax\n  cltq\n  lea    0x2e36(%rip),%rcx        # 4080 <xs.0>\n  movzbl -0x49(%rbp),%edx\n  mov    %dl,(%rax,%rcx,1)\n  addl   $0x1,-0x48(%rbp)\n  mov    -0x44(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x48(%rbp)\n  jl     1200 <func0+0x67>\n  jmp    12d2 <func0+0x139>\n  mov    -0x44(%rbp),%eax\n  cltq\n  mov    -0x58(%rbp),%edx\n  movslq %edx,%rdx\n  sub    %rdx,%rax\n  mov    %rax,%rcx\n  lea    0x2e00(%rip),%rax        # 4080 <xs.0>\n  lea    (%rcx,%rax,1),%rdx\n  lea    -0x40(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcpy@plt>\n  mov    -0x58(%rbp),%eax\n  cltq\n  movb   $0x0,-0x40(%rbp,%rax,1)\n  mov    -0x44(%rbp),%eax\n  sub    -0x58(%rbp),%eax\n  movslq %eax,%rdx\n  lea    -0x40(%rbp),%rax\n  lea    0x2dcf(%rip),%rcx        # 4080 <xs.0>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   10c0 <strncat@plt>\n  lea    -0x40(%rbp),%rax\n  mov    %rax,%rsi\n  lea    0x2db6(%rip),%rax        # 4080 <xs.0>\n  mov    %rax,%rdi\n  call   1090 <strcpy@plt>\n  lea    0x2da7(%rip),%rax        # 4080 <xs.0>\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     12ed <func0+0x154>\n  call   10b0 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x60,%rsp\n  mov    %edi,-0x54(%rbp)\n  mov    %esi,-0x58(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x54(%rbp),%eax\n  mov    %eax,%edx\n  lea    D0(%rip),%rax\n  mov    %rax,%rsi\n  lea    D1(%rip),%rax\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  lea    D1(%rip),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x44(%rbp)\n  mov    -0x44(%rbp),%eax\n  cmp    -0x58(%rbp),%eax\n  jge    L0\n  movl   $0x0,-0x48(%rbp)\n  jmp    L1\nL2:\n  mov    -0x48(%rbp),%eax\n  cltq\n  lea    D1(%rip),%rdx\n  movzbl (%rax,%rdx,1),%eax\n  mov    %al,-0x49(%rbp)\n  mov    -0x44(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x48(%rbp),%eax\n  cltq\n  lea    D1(%rip),%rdx\n  movzbl (%rax,%rdx,1),%edx\n  mov    -0x48(%rbp),%eax\n  cltq\n  lea    D1(%rip),%rcx\n  mov    %dl,(%rax,%rcx,1)\n  mov    -0x44(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x48(%rbp),%eax\n  cltq\n  lea    D1(%rip),%rcx\n  movzbl -0x49(%rbp),%edx\n  mov    %dl,(%rax,%rcx,1)\n  addl   $0x1,-0x48(%rbp)\nL1:\n  mov    -0x44(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x48(%rbp)\n  jl     L2\n  jmp    L3\nL0:\n  mov    -0x44(%rbp),%eax\n  cltq\n  mov    -0x58(%rbp),%edx\n  movslq %edx,%rdx\n  sub    %rdx,%rax\n  mov    %rax,%rcx\n  lea    D1(%rip),%rax\n  lea    (%rcx,%rax,1),%rdx\n  lea    -0x40(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  mov    -0x58(%rbp),%eax\n  cltq\n  movb   $0x0,-0x40(%rbp,%rax,1)\n  mov    -0x44(%rbp),%eax\n  sub    -0x58(%rbp),%eax\n  movslq %eax,%rdx\n  lea    -0x40(%rbp),%rax\n  lea    D1(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncat@plt>\n  lea    -0x40(%rbp),%rax\n  mov    %rax,%rsi\n  lea    D1(%rip),%rax\n  mov    %rax,%rdi\n  call   <strcpy@plt>\nL3:\n  lea    D1(%rip),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L4\n  call   <__stack_chk_fail@plt>\nL4:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3642
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 16512,
                "bias": [
                    11952,
                    11932,
                    11892,
                    11867,
                    11851,
                    11830,
                    11776,
                    11727,
                    11702,
                    11687
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4712
            },
            "L1": {
                "label": "L1",
                "addr": 4693
            },
            "L2": {
                "label": "L2",
                "addr": 4608
            },
            "L3": {
                "label": "L3",
                "addr": 4818
            },
            "L4": {
                "label": "L4",
                "addr": 4845
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 65,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %edi,%r8d\n  mov    %esi,%ebp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  lea    0xe3d(%rip),%rcx        # 2000 <_fini+0xd68>\n  mov    $0x32,%edx\n  mov    $0x1,%esi\n  lea    0x2eac(%rip),%rbx        # 4080 <xs.0>\n  mov    %rbx,%rdi\n  call   10d0 <__sprintf_chk@plt>\n  mov    %rbx,%rdi\n  call   1090 <strlen@plt>\n  cmp    %ebp,%eax\n  jge    1246 <func0+0xad>\n  mov    %eax,%r8d\n  shr    $0x1f,%r8d\n  add    %eax,%r8d\n  sar    %r8d\n  cmp    $0x1,%eax\n  jle    1224 <func0+0x8b>\n  cltq\n  add    %rbx,%rax\n  mov    $0x0,%edx\n  mov    %rbx,%rcx\n  movzbl (%rcx,%rdx,1),%esi\n  movzbl -0x1(%rax),%edi\n  mov    %dil,(%rcx,%rdx,1)\n  mov    %sil,-0x1(%rax)\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%r8d\n  jg     1207 <func0+0x6e>\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1293 <func0+0xfa>\n  lea    0x2e45(%rip),%rax        # 4080 <xs.0>\n  add    $0x48,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  movslq %eax,%rbx\n  movslq %ebp,%rbp\n  sub    %rbp,%rbx\n  lea    0x2e2a(%rip),%r12        # 4080 <xs.0>\n  lea    (%rbx,%r12,1),%rsi\n  mov    %rsp,%r13\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  call   10b0 <__strcpy_chk@plt>\n  movb   $0x0,(%rsp,%rbp,1)\n  mov    $0x32,%ecx\n  mov    %rbx,%rdx\n  mov    %r12,%rsi\n  mov    %r13,%rdi\n  call   10c0 <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rsi\n  mov    %r12,%rdi\n  call   10b0 <__strcpy_chk@plt>\n  jmp    1224 <func0+0x8b>\n  call   10a0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %edi,%r8d\n  mov    %esi,%ebp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rcx\n  mov    $0x32,%edx\n  mov    $0x1,%esi\n  lea    D1(%rip),%rbx\n  mov    %rbx,%rdi\n  call   <__sprintf_chk@plt>\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  cmp    %ebp,%eax\n  jge    L0\n  mov    %eax,%r8d\n  shr    $0x1f,%r8d\n  add    %eax,%r8d\n  sar    %r8d\n  cmp    $0x1,%eax\n  jle    L1\n  cltq\n  add    %rbx,%rax\n  mov    $0x0,%edx\n  mov    %rbx,%rcx\nL2:\n  movzbl (%rcx,%rdx,1),%esi\n  movzbl -0x1(%rax),%edi\n  mov    %dil,(%rcx,%rdx,1)\n  mov    %sil,-0x1(%rax)\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  cmp    %edx,%r8d\n  jg     L2\nL1:\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  lea    D1(%rip),%rax\n  add    $0x48,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL0:\n  movslq %eax,%rbx\n  movslq %ebp,%rbp\n  sub    %rbp,%rbx\n  lea    D1(%rip),%r12\n  lea    (%rbx,%r12,1),%rsi\n  mov    %rsp,%r13\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  call   <__strcpy_chk@plt>\n  movb   $0x0,(%rsp,%rbp,1)\n  mov    $0x32,%ecx\n  mov    %rbx,%rdx\n  mov    %r12,%rsi\n  mov    %r13,%rdi\n  call   <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rsi\n  mov    %r12,%rdi\n  call   <__strcpy_chk@plt>\n  jmp    L1\nL3:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3645
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 16512,
                "bias": [
                    11948,
                    11845,
                    11818
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4678
            },
            "L1": {
                "label": "L1",
                "addr": 4644
            },
            "L2": {
                "label": "L2",
                "addr": 4615
            },
            "L3": {
                "label": "L3",
                "addr": 4755
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 65,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  lea    0x2ed3(%rip),%r13        # 4080 <xs.0>\n  mov    %edi,%r8d\n  lea    0xe49(%rip),%rcx        # 2000 <_fini+0xd64>\n  push   %r12\n  mov    %r13,%rdi\n  mov    $0x32,%edx\n  push   %rbx\n  movslq %esi,%rbx\n  mov    $0x1,%esi\n  sub    $0x40,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   10d0 <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   1090 <strlen@plt>\n  cmp    %ebx,%eax\n  jge    1250 <func0+0xb0>\n  mov    %eax,%ecx\n  sar    %ecx\n  je     122a <func0+0x8a>\n  lea    -0x1(%rcx),%edi\n  cltq\n  lea    0x1(%r13),%rcx\n  mov    %r13,%rdx\n  lea    -0x1(%r13,%rax,1),%rax\n  add    %rcx,%rdi\n  nopl   0x0(%rax)\n  movzbl (%rax),%esi\n  movzbl (%rdx),%ecx\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rdi,%rdx\n  jne    1210 <func0+0x70>\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1294 <func0+0xf4>\n  add    $0x40,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  sub    %rbx,%rax\n  mov    %rsp,%r8\n  mov    $0x32,%edx\n  mov    %r8,%rdi\n  lea    0x0(%r13,%rax,1),%rsi\n  mov    %rax,%r12\n  call   10b0 <__strcpy_chk@plt>\n  mov    %r12,%rdx\n  mov    %r13,%rsi\n  mov    $0x32,%ecx\n  mov    %rax,%rdi\n  movb   $0x0,(%rsp,%rbx,1)\n  call   10c0 <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  mov    %rax,%rsi\n  call   10b0 <__strcpy_chk@plt>\n  jmp    122a <func0+0x8a>\n  call   10a0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  lea    D0(%rip),%r13\n  mov    %edi,%r8d\n  lea    D1(%rip),%rcx\n  push   %r12\n  mov    %r13,%rdi\n  mov    $0x32,%edx\n  push   %rbx\n  movslq %esi,%rbx\n  mov    $0x1,%esi\n  sub    $0x40,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  cmp    %ebx,%eax\n  jge    L0\n  mov    %eax,%ecx\n  sar    %ecx\n  je     L1\n  lea    -0x1(%rcx),%edi\n  cltq\n  lea    0x1(%r13),%rcx\n  mov    %r13,%rdx\n  lea    -0x1(%r13,%rax,1),%rax\n  add    %rcx,%rdi\n  nopl   0x0(%rax)\nL2:\n  movzbl (%rax),%esi\n  movzbl (%rdx),%ecx\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rdi,%rdx\n  jne    L2\nL1:\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  add    $0x40,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  sub    %rbx,%rax\n  mov    %rsp,%r8\n  mov    $0x32,%edx\n  mov    %r8,%rdi\n  lea    0x0(%r13,%rax,1),%rsi\n  mov    %rax,%r12\n  call   <__strcpy_chk@plt>\n  mov    %r12,%rdx\n  mov    %r13,%rsi\n  mov    $0x32,%ecx\n  mov    %rax,%rdi\n  movb   $0x0,(%rsp,%rbx,1)\n  call   <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  mov    %rax,%rsi\n  call   <__strcpy_chk@plt>\n  jmp    L1\nL3:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 16512,
                "bias": [
                    11987
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3657
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4688
            },
            "L1": {
                "label": "L1",
                "addr": 4650
            },
            "L2": {
                "label": "L2",
                "addr": 4624
            },
            "L3": {
                "label": "L3",
                "addr": 4756
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 65,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int x, int shift) {\n    static char xs[50];\n    sprintf(xs, \"%d\", x);\n    int len = strlen(xs);\n\n    if (len < shift) {\n        for (int i = 0; i < len / 2; i++) {\n            char temp = xs[i];\n            xs[i] = xs[len - 1 - i];\n            xs[len - 1 - i] = temp;\n        }\n    } else {\n        char temp[50];\n        strcpy(temp, xs + len - shift);\n        temp[shift] = '\\0';\n        strncat(temp, xs, len - shift);\n        strcpy(xs, temp);\n    }\n\n    return xs;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(100, 2), \"001\") == 0);\n    assert(strcmp(func0(12, 2), \"12\") == 0);\n    assert(strcmp(func0(97, 8), \"79\") == 0);\n    assert(strcmp(func0(12, 1), \"21\") == 0);\n    assert(strcmp(func0(11, 101), \"11\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  lea    0x2ed3(%rip),%r13        # 4080 <xs.0>\n  mov    %edi,%r8d\n  lea    0xe49(%rip),%rcx        # 2000 <_fini+0xd64>\n  push   %r12\n  mov    %r13,%rdi\n  mov    $0x32,%edx\n  push   %rbx\n  movslq %esi,%rbx\n  mov    $0x1,%esi\n  sub    $0x40,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   10d0 <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   1090 <strlen@plt>\n  cmp    %ebx,%eax\n  jge    1250 <func0+0xb0>\n  mov    %eax,%ecx\n  sar    %ecx\n  je     122a <func0+0x8a>\n  lea    -0x1(%rcx),%edi\n  cltq\n  lea    0x1(%r13),%rcx\n  mov    %r13,%rdx\n  lea    -0x1(%r13,%rax,1),%rax\n  add    %rcx,%rdi\n  nopl   0x0(%rax)\n  movzbl (%rax),%esi\n  movzbl (%rdx),%ecx\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rdi,%rdx\n  jne    1210 <func0+0x70>\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1294 <func0+0xf4>\n  add    $0x40,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  sub    %rbx,%rax\n  mov    %rsp,%r8\n  mov    $0x32,%edx\n  mov    %r8,%rdi\n  lea    0x0(%r13,%rax,1),%rsi\n  mov    %rax,%r12\n  call   10b0 <__strcpy_chk@plt>\n  mov    %r12,%rdx\n  mov    %r13,%rsi\n  mov    $0x32,%ecx\n  mov    %rax,%rdi\n  movb   $0x0,(%rsp,%rbx,1)\n  call   10c0 <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  mov    %rax,%rsi\n  call   10b0 <__strcpy_chk@plt>\n  jmp    122a <func0+0x8a>\n  call   10a0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  lea    D0(%rip),%r13\n  mov    %edi,%r8d\n  lea    D1(%rip),%rcx\n  push   %r12\n  mov    %r13,%rdi\n  mov    $0x32,%edx\n  push   %rbx\n  movslq %esi,%rbx\n  mov    $0x1,%esi\n  sub    $0x40,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  cmp    %ebx,%eax\n  jge    L0\n  mov    %eax,%ecx\n  sar    %ecx\n  je     L1\n  lea    -0x1(%rcx),%edi\n  cltq\n  lea    0x1(%r13),%rcx\n  mov    %r13,%rdx\n  lea    -0x1(%r13,%rax,1),%rax\n  add    %rcx,%rdi\n  nopl   0x0(%rax)\nL2:\n  movzbl (%rax),%esi\n  movzbl (%rdx),%ecx\n  add    $0x1,%rdx\n  sub    $0x1,%rax\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rdi,%rdx\n  jne    L2\nL1:\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L3\n  add    $0x40,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  sub    %rbx,%rax\n  mov    %rsp,%r8\n  mov    $0x32,%edx\n  mov    %r8,%rdi\n  lea    0x0(%r13,%rax,1),%rsi\n  mov    %rax,%r12\n  call   <__strcpy_chk@plt>\n  mov    %r12,%rdx\n  mov    %r13,%rsi\n  mov    $0x32,%ecx\n  mov    %rax,%rdi\n  movb   $0x0,(%rsp,%rbx,1)\n  call   <__strncat_chk@plt>\n  mov    $0x32,%edx\n  mov    %r13,%rdi\n  mov    %rax,%rsi\n  call   <__strcpy_chk@plt>\n  jmp    L1\nL3:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 16512,
                "bias": [
                    11987
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3657
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4688
            },
            "L1": {
                "label": "L1",
                "addr": 4650
            },
            "L2": {
                "label": "L2",
                "addr": 4624
            },
            "L3": {
                "label": "L3",
                "addr": 4756
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 66,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1157 <func0+0x5e>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x40,%al\n  jle    1153 <func0+0x5a>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5a,%al\n  jg     1153 <func0+0x5a>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1115 <func0+0x1c>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x40,%al\n  jle    L1\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5a,%al\n  jg     L1\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  add    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4439
            },
            "L1": {
                "label": "L1",
                "addr": 4435
            },
            "L2": {
                "label": "L2",
                "addr": 4373
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 66,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     112a <func0+0x31>\n  add    $0x1,%rdi\n  mov    $0x0,%edx\n  lea    -0x41(%rax),%ecx\n  movsbl %al,%eax\n  add    %edx,%eax\n  cmp    $0x1a,%cl\n  cmovb  %eax,%edx\n  add    $0x1,%rdi\n  movzbl -0x1(%rdi),%eax\n  test   %al,%al\n  jne    110d <func0+0x14>\n  mov    %edx,%eax\n  ret\n  mov    $0x0,%edx\n  jmp    1127 <func0+0x2e>",
        "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  mov    $0x0,%edx\nL1:\n  lea    -0x41(%rax),%ecx\n  movsbl %al,%eax\n  add    %edx,%eax\n  cmp    $0x1a,%cl\n  cmovb  %eax,%edx\n  add    $0x1,%rdi\n  movzbl -0x1(%rdi),%eax\n  test   %al,%al\n  jne    L1\nL2:\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x0,%edx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4394
            },
            "L1": {
                "label": "L1",
                "addr": 4365
            },
            "L2": {
                "label": "L2",
                "addr": 4391
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 66,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  test   %al,%al\n  je     1138 <func0+0x38>\n  add    $0x1,%rdi\n  xor    %r8d,%r8d\n  nopw   0x0(%rax,%rax,1)\n  lea    -0x41(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0x1a,%dl\n  cmovb  %eax,%r8d\n  movsbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  jne    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  xor    %r8d,%r8d\n  nopw   0x0(%rax,%rax,1)\nL1:\n  lea    -0x41(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0x1a,%dl\n  cmovb  %eax,%r8d\n  movsbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 66,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    int sum = 0;\n    for (int i = 0; s[i] != '\\0'; i++)\n        if (s[i] >= 'A' && s[i] <= 'Z')\n            sum += s[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"\") == 0);\n    assert(func0(\"abAB\") == 131);\n    assert(func0(\"abcCd\") == 67);\n    assert(func0(\"helloE\") == 69);\n    assert(func0(\"woArBld\") == 131);\n    assert(func0(\"aAaaaXa\") == 153);\n    assert(func0(\" How are yOu?\") == 151);\n    assert(func0(\"You arE Very Smart\") == 327);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  test   %al,%al\n  je     1138 <func0+0x38>\n  add    $0x1,%rdi\n  xor    %r8d,%r8d\n  nopw   0x0(%rax,%rax,1)\n  lea    -0x41(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0x1a,%dl\n  cmovb  %eax,%r8d\n  movsbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  jne    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rdi\n  xor    %r8d,%r8d\n  nopw   0x0(%rax,%rax,1)\nL1:\n  lea    -0x41(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0x1a,%dl\n  cmovb  %eax,%r8d\n  movsbl (%rdi),%eax\n  add    $0x1,%rdi\n  test   %al,%al\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 67,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x18(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x2c(%rbp)\n  movw   $0x0,-0x24(%rbp)\n  movq   $0x0,-0x22(%rbp)\n  movw   $0x0,-0x1a(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    124b <func0+0xf2>\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x800,%eax\n  test   %eax,%eax\n  je     122d <func0+0xd4>\n  cmpl   $0x0,-0x38(%rbp)\n  jne    120b <func0+0xb2>\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x2c(%rbp,%rax,1)\n  jmp    1247 <func0+0xee>\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x22(%rbp,%rax,1)\n  jmp    1247 <func0+0xee>\n  cmpl   $0x0,-0x38(%rbp)\n  jne    1247 <func0+0xee>\n  cmpl   $0x0,-0x34(%rbp)\n  jle    1247 <func0+0xee>\n  movl   $0x1,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11b2 <func0+0x59>\n  lea    -0x2c(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <atoi@plt>\n  mov    %eax,%edx\n  mov    -0x4c(%rbp),%eax\n  sub    %edx,%eax\n  mov    %eax,%ebx\n  lea    -0x22(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <atoi@plt>\n  mov    %eax,%edx\n  mov    %ebx,%eax\n  sub    %edx,%eax\n  mov    -0x18(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     129e <func0+0x145>\n  call   1070 <__stack_chk_fail@plt>\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x18(%rbp)\n  xor    %eax,%eax\n  movq   $0x0,-0x2c(%rbp)\n  movw   $0x0,-0x24(%rbp)\n  movq   $0x0,-0x22(%rbp)\n  movw   $0x0,-0x1a(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    L0\nL4:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x800,%eax\n  test   %eax,%eax\n  je     L1\n  cmpl   $0x0,-0x38(%rbp)\n  jne    L2\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x2c(%rbp,%rax,1)\n  jmp    L3\nL2:\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x34(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x22(%rbp,%rax,1)\n  jmp    L3\nL1:\n  cmpl   $0x0,-0x38(%rbp)\n  jne    L3\n  cmpl   $0x0,-0x34(%rbp)\n  jle    L3\n  movl   $0x1,-0x38(%rbp)\n  movl   $0x0,-0x34(%rbp)\nL3:\n  addl   $0x1,-0x30(%rbp)\nL0:\n  mov    -0x30(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L4\n  lea    -0x2c(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,%edx\n  mov    -0x4c(%rbp),%eax\n  sub    %edx,%eax\n  mov    %eax,%ebx\n  lea    -0x22(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,%edx\n  mov    %ebx,%eax\n  sub    %edx,%eax\n  mov    -0x18(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L5\n  call   <__stack_chk_fail@plt>\nL5:\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4683
            },
            "L1": {
                "label": "L1",
                "addr": 4653
            },
            "L2": {
                "label": "L2",
                "addr": 4619
            },
            "L3": {
                "label": "L3",
                "addr": 4679
            },
            "L4": {
                "label": "L4",
                "addr": 4530
            },
            "L5": {
                "label": "L5",
                "addr": 4766
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 67,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  mov    %esi,%r12d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,0x4(%rsp)\n  movw   $0x0,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  movw   $0x0,0x16(%rsp)\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     120e <func0+0xb5>\n  mov    %rdi,%rbp\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdi\n  lea    0x1(%rbp),%rdx\n  mov    $0x0,%ecx\n  mov    $0x0,%eax\n  mov    $0x0,%r9d\n  mov    $0x1,%r8d\n  jmp    11f3 <func0+0x9a>\n  movslq %ecx,%rsi\n  mov    %bl,0xe(%rsp,%rsi,1)\n  lea    0x1(%rcx),%ecx\n  jmp    11e7 <func0+0x8e>\n  test   %eax,%eax\n  jne    11e7 <func0+0x8e>\n  test   %ecx,%ecx\n  setg   %sil\n  test   %sil,%sil\n  cmovne %r9d,%ecx\n  cmovne %r8d,%eax\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%ebx\n  test   %bl,%bl\n  je     120e <func0+0xb5>\n  movsbq %bl,%rsi\n  testb  $0x8,0x1(%rdi,%rsi,2)\n  je     11d2 <func0+0x79>\n  test   %eax,%eax\n  jne    11c6 <func0+0x6d>\n  movslq %ecx,%rsi\n  mov    %bl,0x4(%rsp,%rsi,1)\n  lea    0x1(%rcx),%ecx\n  jmp    11e7 <func0+0x8e>\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1080 <strtol@plt>\n  sub    %eax,%r12d\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1080 <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1258 <func0+0xff>\n  mov    %r12d,%eax\n  add    $0x20,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  mov    %esi,%r12d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  movq   $0x0,0x4(%rsp)\n  movw   $0x0,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  movw   $0x0,0x16(%rsp)\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdi\n  lea    0x1(%rbp),%rdx\n  mov    $0x0,%ecx\n  mov    $0x0,%eax\n  mov    $0x0,%r9d\n  mov    $0x1,%r8d\n  jmp    L1\nL4:\n  movslq %ecx,%rsi\n  mov    %bl,0xe(%rsp,%rsi,1)\n  lea    0x1(%rcx),%ecx\n  jmp    L2\nL3:\n  test   %eax,%eax\n  jne    L2\n  test   %ecx,%ecx\n  setg   %sil\n  test   %sil,%sil\n  cmovne %r9d,%ecx\n  cmovne %r8d,%eax\nL2:\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%ebx\n  test   %bl,%bl\n  je     L0\nL1:\n  movsbq %bl,%rsi\n  testb  $0x8,0x1(%rdi,%rsi,2)\n  je     L3\n  test   %eax,%eax\n  jne    L4\n  movslq %ecx,%rsi\n  mov    %bl,0x4(%rsp,%rsi,1)\n  lea    0x1(%rcx),%ecx\n  jmp    L2\nL0:\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  sub    %eax,%r12d\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  mov    %r12d,%eax\n  add    $0x20,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL5:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4622
            },
            "L1": {
                "label": "L1",
                "addr": 4595
            },
            "L2": {
                "label": "L2",
                "addr": 4583
            },
            "L3": {
                "label": "L3",
                "addr": 4562
            },
            "L4": {
                "label": "L4",
                "addr": 4550
            },
            "L5": {
                "label": "L5",
                "addr": 4696
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 67,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  xor    %edx,%edx\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  movzbl (%rdi),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  mov    %dx,0x16(%rsp)\n  movq   $0x0,0x4(%rsp)\n  mov    %ax,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  test   %bl,%bl\n  je     120e <func0+0xae>\n  mov    %rdi,%rbp\n  call   1090 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %edx,%edx\n  xor    %r9d,%r9d\n  mov    (%rax),%rsi\n  mov    $0x1,%r8d\n  xor    %eax,%eax\n  jmp    11e5 <func0+0x85>\n  nopl   0x0(%rax)\n  movslq %edx,%rcx\n  test   %eax,%eax\n  jne    1258 <func0+0xf8>\n  mov    %bl,0x4(%rsp,%rcx,1)\n  add    $0x1,%edx\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     120e <func0+0xae>\n  movsbq %bl,%rcx\n  testb  $0x8,0x1(%rsi,%rcx,2)\n  jne    11c8 <func0+0x68>\n  test   %eax,%eax\n  jne    11da <func0+0x7a>\n  test   %edx,%edx\n  setg   %cl\n  test   %cl,%cl\n  cmovne %r9d,%edx\n  cmovne %r8d,%eax\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    11e5 <func0+0x85>\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  call   1080 <strtol@plt>\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  sub    %eax,%r12d\n  call   1080 <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1264 <func0+0x104>\n  add    $0x20,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %bl,0xe(%rsp,%rcx,1)\n  add    $0x1,%edx\n  jmp    11da <func0+0x7a>\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  xor    %edx,%edx\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  movzbl (%rdi),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  mov    %dx,0x16(%rsp)\n  movq   $0x0,0x4(%rsp)\n  mov    %ax,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %edx,%edx\n  xor    %r9d,%r9d\n  mov    (%rax),%rsi\n  mov    $0x1,%r8d\n  xor    %eax,%eax\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  movslq %edx,%rcx\n  test   %eax,%eax\n  jne    L2\n  mov    %bl,0x4(%rsp,%rcx,1)\n  add    $0x1,%edx\nL4:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     L0\nL1:\n  movsbq %bl,%rcx\n  testb  $0x8,0x1(%rsi,%rcx,2)\n  jne    L3\n  test   %eax,%eax\n  jne    L4\n  test   %edx,%edx\n  setg   %cl\n  test   %cl,%cl\n  cmovne %r9d,%edx\n  cmovne %r8d,%eax\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    L1\nL0:\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  call   <strtol@plt>\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  sub    %eax,%r12d\n  call   <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  add    $0x20,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    %bl,0xe(%rsp,%rcx,1)\n  add    $0x1,%edx\n  jmp    L4\nL5:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4622
            },
            "L1": {
                "label": "L1",
                "addr": 4581
            },
            "L2": {
                "label": "L2",
                "addr": 4696
            },
            "L3": {
                "label": "L3",
                "addr": 4552
            },
            "L4": {
                "label": "L4",
                "addr": 4570
            },
            "L5": {
                "label": "L5",
                "addr": 4708
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 67,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nint func0(const char *s, int n) {\n    char num1[10] = \"\";\n    char num2[10] = \"\";\n    int is12 = 0, j = 0;\n\n    for (int i = 0; s[i] != '\\0'; i++) {\n        if (isdigit(s[i])) {\n            if (is12 == 0) {\n                num1[j++] = s[i];\n            } else {\n                num2[j++] = s[i];\n            }\n        } else {\n            if (is12 == 0 && j > 0) {\n                is12 = 1;\n                j = 0;\n            }\n        }\n    }\n    return n - atoi(num1) - atoi(num2);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"5 apples and 6 oranges\", 19) == 8);\n    assert(func0(\"5 apples and 6 oranges\", 21) == 10);\n    assert(func0(\"0 apples and 1 oranges\", 3) == 2);\n    assert(func0(\"1 apples and 0 oranges\", 3) == 2);\n    assert(func0(\"2 apples and 3 oranges\", 100) == 95);\n    assert(func0(\"2 apples and 3 oranges\", 5) == 0);\n    assert(func0(\"1 apples and 100 oranges\", 120) == 19);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  xor    %edx,%edx\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  movzbl (%rdi),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  mov    %dx,0x16(%rsp)\n  movq   $0x0,0x4(%rsp)\n  mov    %ax,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  test   %bl,%bl\n  je     120e <func0+0xae>\n  mov    %rdi,%rbp\n  call   1090 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %edx,%edx\n  xor    %r9d,%r9d\n  mov    (%rax),%rsi\n  mov    $0x1,%r8d\n  xor    %eax,%eax\n  jmp    11e5 <func0+0x85>\n  nopl   0x0(%rax)\n  movslq %edx,%rcx\n  test   %eax,%eax\n  jne    1258 <func0+0xf8>\n  mov    %bl,0x4(%rsp,%rcx,1)\n  add    $0x1,%edx\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     120e <func0+0xae>\n  movsbq %bl,%rcx\n  testb  $0x8,0x1(%rsi,%rcx,2)\n  jne    11c8 <func0+0x68>\n  test   %eax,%eax\n  jne    11da <func0+0x7a>\n  test   %edx,%edx\n  setg   %cl\n  test   %cl,%cl\n  cmovne %r9d,%edx\n  cmovne %r8d,%eax\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    11e5 <func0+0x85>\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  call   1080 <strtol@plt>\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  sub    %eax,%r12d\n  call   1080 <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1264 <func0+0x104>\n  add    $0x20,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %bl,0xe(%rsp,%rcx,1)\n  add    $0x1,%edx\n  jmp    11da <func0+0x7a>\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  xor    %edx,%edx\n  mov    %esi,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  movzbl (%rdi),%ebx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  xor    %eax,%eax\n  mov    %dx,0x16(%rsp)\n  movq   $0x0,0x4(%rsp)\n  mov    %ax,0xc(%rsp)\n  movq   $0x0,0xe(%rsp)\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %edx,%edx\n  xor    %r9d,%r9d\n  mov    (%rax),%rsi\n  mov    $0x1,%r8d\n  xor    %eax,%eax\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  movslq %edx,%rcx\n  test   %eax,%eax\n  jne    L2\n  mov    %bl,0x4(%rsp,%rcx,1)\n  add    $0x1,%edx\nL4:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     L0\nL1:\n  movsbq %bl,%rcx\n  testb  $0x8,0x1(%rsi,%rcx,2)\n  jne    L3\n  test   %eax,%eax\n  jne    L4\n  test   %edx,%edx\n  setg   %cl\n  test   %cl,%cl\n  cmovne %r9d,%edx\n  cmovne %r8d,%eax\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    L1\nL0:\n  lea    0x4(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  call   <strtol@plt>\n  lea    0xe(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  sub    %eax,%r12d\n  call   <strtol@plt>\n  sub    %eax,%r12d\n  mov    0x18(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  add    $0x20,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    %bl,0xe(%rsp,%rcx,1)\n  add    $0x1,%edx\n  jmp    L4\nL5:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4622
            },
            "L1": {
                "label": "L1",
                "addr": 4581
            },
            "L2": {
                "label": "L2",
                "addr": 4696
            },
            "L3": {
                "label": "L3",
                "addr": 4552
            },
            "L4": {
                "label": "L4",
                "addr": 4570
            },
            "L5": {
                "label": "L5",
                "addr": 4708
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 68,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x7fffffff,-0xc(%rbp)\n  movl   $0xffffffff,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1184 <func0+0x8b>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    1180 <func0+0x87>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jg     1161 <func0+0x68>\n  cmpl   $0xffffffff,-0x8(%rbp)\n  jne    1180 <func0+0x87>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1123 <func0+0x2a>\n  cmpl   $0xffffffff,-0x8(%rbp)\n  jne    1199 <func0+0xa0>\n  mov    $0x0,%eax\n  jmp    11b3 <func0+0xba>\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x28(%rbp),%rax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x7fffffff,-0xc(%rbp)\n  movl   $0xffffffff,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jg     L2\n  cmpl   $0xffffffff,-0x8(%rbp)\n  jne    L1\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L3\n  cmpl   $0xffffffff,-0x8(%rbp)\n  jne    L4\n  mov    $0x0,%eax\n  jmp    L5\nL4:\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x28(%rbp),%rax\nL5:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4484
            },
            "L1": {
                "label": "L1",
                "addr": 4480
            },
            "L2": {
                "label": "L2",
                "addr": 4449
            },
            "L3": {
                "label": "L3",
                "addr": 4387
            },
            "L4": {
                "label": "L4",
                "addr": 4505
            },
            "L5": {
                "label": "L5",
                "addr": 4531
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 68,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    114e <func0+0x55>\n  mov    %esi,%esi\n  mov    $0x0,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  jmp    1124 <func0+0x2b>\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  je     113e <func0+0x45>\n  mov    %ecx,%r9d\n  mov    (%rdi,%rcx,4),%r8d\n  test   $0x1,%r8b\n  jne    111b <func0+0x22>\n  cmp    $0xffffffff,%r10d\n  je     1115 <func0+0x1c>\n  cmp    %eax,%r8d\n  jl     1115 <func0+0x1c>\n  jmp    111b <func0+0x22>\n  cmp    $0xffffffff,%r10d\n  je     1154 <func0+0x5b>\n  mov    %eax,(%rdx)\n  mov    %r10d,0x4(%rdx)\n  mov    %rdx,%rax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%esi\n  mov    $0x0,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  jmp    L1\nL4:\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\nL3:\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  je     L2\nL1:\n  mov    %ecx,%r9d\n  mov    (%rdi,%rcx,4),%r8d\n  test   $0x1,%r8b\n  jne    L3\n  cmp    $0xffffffff,%r10d\n  je     L4\n  cmp    %eax,%r8d\n  jl     L4\n  jmp    L3\nL2:\n  cmp    $0xffffffff,%r10d\n  je     L5\n  mov    %eax,(%rdx)\n  mov    %r10d,0x4(%rdx)\n  mov    %rdx,%rax\n  ret\nL0:\n  mov    $0x0,%eax\n  ret\nL5:\n  mov    $0x0,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4430
            },
            "L1": {
                "label": "L1",
                "addr": 4388
            },
            "L2": {
                "label": "L2",
                "addr": 4414
            },
            "L3": {
                "label": "L3",
                "addr": 4379
            },
            "L4": {
                "label": "L4",
                "addr": 4373
            },
            "L5": {
                "label": "L5",
                "addr": 4436
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 68,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1160 <func0+0x60>\n  movslq %esi,%rsi\n  xor    %ecx,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdi,%rcx,4),%r8d\n  mov    %ecx,%r9d\n  test   $0x1,%r8b\n  jne    113e <func0+0x3e>\n  cmp    $0xffffffff,%r10d\n  je     1138 <func0+0x38>\n  cmp    %eax,%r8d\n  jge    113e <func0+0x3e>\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  jne    1120 <func0+0x20>\n  cmp    $0xffffffff,%r10d\n  je     1160 <func0+0x60>\n  mov    %eax,(%rdx)\n  mov    %rdx,%rax\n  mov    %r10d,0x4(%rdx)\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rsi\n  xor    %ecx,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    (%rdi,%rcx,4),%r8d\n  mov    %ecx,%r9d\n  test   $0x1,%r8b\n  jne    L1\n  cmp    $0xffffffff,%r10d\n  je     L2\n  cmp    %eax,%r8d\n  jge    L1\nL2:\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\nL1:\n  add    $0x1,%rcx\n  cmp    %rsi,%rcx\n  jne    L3\n  cmp    $0xffffffff,%r10d\n  je     L0\n  mov    %eax,(%rdx)\n  mov    %rdx,%rax\n  mov    %r10d,0x4(%rdx)\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4448
            },
            "L1": {
                "label": "L1",
                "addr": 4414
            },
            "L2": {
                "label": "L2",
                "addr": 4408
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 68,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint *func0(int arr[], int length, int output[2]) {\n    int smallestEven = INT_MAX;\n    int index = -1;\n    \n    for (int i = 0; i < length; ++i) {\n        if (arr[i] % 2 == 0 && (arr[i] < smallestEven || index == -1)) {\n            smallestEven = arr[i];\n            index = i;\n        }\n    }\n    \n    if (index == -1) {\n        return NULL;\n    }\n\n    output[0] = smallestEven;\n    output[1] = index;\n    return output;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nint issame(const int *a, const int *b, int a_length, int b_length) {\n    if (a_length != b_length) return 0;\n    for (int i = 0; i < a_length; ++i) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int output[2];\n    int *result;\n    \n    int test1[] = {4, 2, 3};\n    int expect1[] = {2, 1};\n    result = func0(test1, 3, output);\n    assert(issame(result, expect1, 2, 2));\n\n    int test2[] = {1, 2, 3};\n    int expect2[] = {2, 1};\n    result = func0(test2, 3, output);\n    assert(issame(result, expect2, 2, 2));\n\n    int test3[] = {};\n    result = func0(test3, 0, output);\n    assert(result == NULL);\n\n    int test4[] = {5, 0, 3, 0, 4, 2};\n    int expect4[] = {0, 1};\n    result = func0(test4, 6, output);\n    assert(issame(result, expect4, 2, 2));\n\n    int test5[] = {1, 2, 3, 0, 5, 3};\n    int expect5[] = {0, 3};\n    result = func0(test5, 6, output);\n    assert(issame(result, expect5, 2, 2));\n\n    int test6[] = {5, 4, 8, 4, 8};\n    int expect6[] = {4, 1};\n    result = func0(test6, 5, output);\n    assert(issame(result, expect6, 2, 2));\n\n    int test7[] = {7, 6, 7, 1};\n    int expect7[] = {6, 1};\n    result = func0(test7, 4, output);\n    assert(issame(result, expect7, 2, 2));\n\n    int test8[] = {7, 9, 7, 1};\n    result = func0(test8, 4, output);\n    assert(result == NULL);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1160 <func0+0x60>\n  movslq %esi,%rsi\n  xor    %ecx,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdi,%rcx,4),%r8d\n  mov    %ecx,%r9d\n  test   $0x1,%r8b\n  jne    113e <func0+0x3e>\n  cmp    $0xffffffff,%r10d\n  je     1138 <func0+0x38>\n  cmp    %r8d,%eax\n  jle    113e <func0+0x3e>\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  jne    1120 <func0+0x20>\n  cmp    $0xffffffff,%r10d\n  je     1160 <func0+0x60>\n  mov    %eax,(%rdx)\n  mov    %rdx,%rax\n  mov    %r10d,0x4(%rdx)\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rsi\n  xor    %ecx,%ecx\n  mov    $0xffffffff,%r10d\n  mov    $0x7fffffff,%eax\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    (%rdi,%rcx,4),%r8d\n  mov    %ecx,%r9d\n  test   $0x1,%r8b\n  jne    L1\n  cmp    $0xffffffff,%r10d\n  je     L2\n  cmp    %r8d,%eax\n  jle    L1\nL2:\n  mov    %r9d,%r10d\n  mov    %r8d,%eax\nL1:\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  jne    L3\n  cmp    $0xffffffff,%r10d\n  je     L0\n  mov    %eax,(%rdx)\n  mov    %rdx,%rax\n  mov    %r10d,0x4(%rdx)\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4448
            },
            "L1": {
                "label": "L1",
                "addr": 4414
            },
            "L2": {
                "label": "L2",
                "addr": 4408
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 69,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   1070 <calloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0xffffffff,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    1221 <func0+0xe8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jl     121d <func0+0xe4>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    121d <func0+0xe4>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1178 <func0+0x3f>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <free@plt>\n  mov    -0x10(%rbp),%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    $0x4,%esi\n  mov    %rax,%rdi\n  call   <calloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0xffffffff,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL2:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jl     L1\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    L1\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\nL1:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x10(%rbp),%eax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4641
            },
            "L1": {
                "label": "L1",
                "addr": 4637
            },
            "L2": {
                "label": "L2",
                "addr": 4472
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 69,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  lea    0x1(%rsi),%edi\n  movslq %edi,%rdi\n  mov    $0x4,%esi\n  call   1070 <calloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    11a7 <func0+0x6e>\n  mov    %rbp,%rsi\n  lea    -0x1(%rbx),%eax\n  lea    0x4(%rbp,%rax,4),%rax\n  mov    $0xffffffff,%ebx\n  mov    (%rsi),%ecx\n  movslq %ecx,%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    (%r8),%edx\n  add    $0x1,%edx\n  mov    %edx,(%r8)\n  cmp    %ecx,%ebx\n  mov    %ecx,%r8d\n  cmovge %ebx,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%ebx\n  add    $0x4,%rsi\n  cmp    %rax,%rsi\n  jne    116f <func0+0x36>\n  call   1060 <free@plt>\n  mov    %ebx,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  mov    $0xffffffff,%ebx\n  jmp    1199 <func0+0x60>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  lea    0x1(%rsi),%edi\n  movslq %edi,%rdi\n  mov    $0x4,%esi\n  call   <calloc@plt>\n  mov    %rax,%rdi\n  test   %ebx,%ebx\n  jle    L0\n  mov    %rbp,%rsi\n  lea    -0x1(%rbx),%eax\n  lea    0x4(%rbp,%rax,4),%rax\n  mov    $0xffffffff,%ebx\nL1:\n  mov    (%rsi),%ecx\n  movslq %ecx,%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    (%r8),%edx\n  add    $0x1,%edx\n  mov    %edx,(%r8)\n  cmp    %ecx,%ebx\n  mov    %ecx,%r8d\n  cmovge %ebx,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%ebx\n  add    $0x4,%rsi\n  cmp    %rax,%rsi\n  jne    L1\nL2:\n  call   <free@plt>\n  mov    %ebx,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL0:\n  mov    $0xffffffff,%ebx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4519
            },
            "L1": {
                "label": "L1",
                "addr": 4463
            },
            "L2": {
                "label": "L2",
                "addr": 4505
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 69,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x1(%rsi),%edi\n  mov    $0x4,%esi\n  movslq %edi,%rdi\n  sub    $0x8,%rsp\n  call   1070 <calloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    11c0 <func0+0x80>\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rsi\n  mov    $0xffffffff,%r12d\n  lea    0x4(%rbx,%rax,4),%rax\n  nopl   0x0(%rax)\n  movslq (%rsi),%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    %rdx,%rcx\n  mov    (%r8),%ebx\n  cmp    %ecx,%r12d\n  lea    0x1(%rbx),%edx\n  mov    %edx,(%r8)\n  mov    %ecx,%r8d\n  cmovge %r12d,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%r12d\n  add    $0x4,%rsi\n  cmp    %rsi,%rax\n  jne    1180 <func0+0x40>\n  call   1060 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret\n  nopl   0x0(%rax)\n  call   1060 <free@plt>\n  mov    $0xffffffff,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x1(%rsi),%edi\n  mov    $0x4,%esi\n  movslq %edi,%rdi\n  sub    $0x8,%rsp\n  call   <calloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rsi\n  mov    $0xffffffff,%r12d\n  lea    0x4(%rbx,%rax,4),%rax\n  nopl   0x0(%rax)\nL1:\n  movslq (%rsi),%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    %rdx,%rcx\n  mov    (%r8),%ebx\n  cmp    %ecx,%r12d\n  lea    0x1(%rbx),%edx\n  mov    %edx,(%r8)\n  mov    %ecx,%r8d\n  cmovge %r12d,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%r12d\n  add    $0x4,%rsi\n  cmp    %rsi,%rax\n  jne    L1\n  call   <free@plt>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret\n  nopl   0x0(%rax)\nL0:\n  call   <free@plt>\n  mov    $0xffffffff,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4544
            },
            "L1": {
                "label": "L1",
                "addr": 4480
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 69,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *lst, int size) {\n    int *freq = (int *)calloc(size + 1, sizeof(int));\n    int max = -1;\n\n    for (int i = 0; i < size; i++) {\n        freq[lst[i]]++;\n        if ((freq[lst[i]] >= lst[i]) && (lst[i] > max)) {\n            max = lst[i];\n        }\n    }\n\n    free(freq);\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {5, 5, 5, 5, 1};\n    int arr2[] = {4, 1, 4, 1, 4, 4};\n    int arr3[] = {3, 3};\n    int arr4[] = {8, 8, 8, 8, 8, 8, 8, 8};\n    int arr5[] = {2, 3, 3, 2, 2};\n    int arr6[] = {2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1};\n    int arr7[] = {3, 2, 8, 2};\n    int arr8[] = {6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10};\n    int arr9[] = {8, 8, 3, 6, 5, 6, 4};\n    int arr10[] = {6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9};\n    int arr11[] = {1, 9, 10, 1, 3};\n    int arr12[] = {6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10};\n    int arr13[] = {1};\n    int arr14[] = {8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5};\n    int arr15[] = {2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10};\n    int arr16[] = {1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3};\n    int arr17[] = {9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4};\n    int arr18[] = {2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7};\n    int arr19[] = {9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1};\n    int arr20[] = {5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8};\n    int arr21[] = {10};\n    int arr22[] = {9, 7, 7, 2, 4,7, 2, 10, 9, 7, 5, 7, 2};\n    int arr23[] = {5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8};\n    int arr24[] = {7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6};\n    int arr25[] = {3, 10, 10, 9, 2};\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x1(%rsi),%edi\n  mov    $0x4,%esi\n  movslq %edi,%rdi\n  sub    $0x8,%rsp\n  call   1070 <calloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    11c0 <func0+0x80>\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rsi\n  mov    $0xffffffff,%r12d\n  lea    0x4(%rbx,%rax,4),%rax\n  nopl   0x0(%rax)\n  movslq (%rsi),%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    %rdx,%rcx\n  mov    (%r8),%ebx\n  cmp    %ecx,%r12d\n  lea    0x1(%rbx),%edx\n  mov    %edx,(%r8)\n  mov    %ecx,%r8d\n  cmovge %r12d,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%r12d\n  add    $0x4,%rsi\n  cmp    %rsi,%rax\n  jne    1180 <func0+0x40>\n  call   1060 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret\n  nopl   0x0(%rax)\n  call   1060 <free@plt>\n  mov    $0xffffffff,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %esi,%r12d\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x1(%rsi),%edi\n  mov    $0x4,%esi\n  movslq %edi,%rdi\n  sub    $0x8,%rsp\n  call   <calloc@plt>\n  mov    %rax,%rdi\n  test   %r12d,%r12d\n  jle    L0\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%rsi\n  mov    $0xffffffff,%r12d\n  lea    0x4(%rbx,%rax,4),%rax\n  nopl   0x0(%rax)\nL1:\n  movslq (%rsi),%rdx\n  lea    (%rdi,%rdx,4),%r8\n  mov    %rdx,%rcx\n  mov    (%r8),%ebx\n  cmp    %ecx,%r12d\n  lea    0x1(%rbx),%edx\n  mov    %edx,(%r8)\n  mov    %ecx,%r8d\n  cmovge %r12d,%r8d\n  cmp    %edx,%ecx\n  cmovle %r8d,%r12d\n  add    $0x4,%rsi\n  cmp    %rsi,%rax\n  jne    L1\n  call   <free@plt>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret\n  nopl   0x0(%rax)\nL0:\n  call   <free@plt>\n  mov    $0xffffffff,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4544
            },
            "L1": {
                "label": "L1",
                "addr": 4480
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 70,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    11c9 <func0+0xd0>\n  mov    -0x18(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    11b9 <func0+0xc0>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    11b5 <func0+0xbc>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1126 <func0+0x2d>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     1118 <func0+0x1f>\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    12a9 <func0+0x1b0>\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jne    1237 <func0+0x13e>\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  jmp    12a9 <func0+0x1b0>\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jle    11f4 <func0+0xfb>\n  nop\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    L0\nL4:\n  mov    -0x18(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    L1\nL3:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L2\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L3\n  addl   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     L4\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L5\nL7:\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jne    L6\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  jmp    L5\nL6:\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x8(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x8(%rbp)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\nL5:\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jle    L7\n  nop\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4553
            },
            "L1": {
                "label": "L1",
                "addr": 4537
            },
            "L2": {
                "label": "L2",
                "addr": 4533
            },
            "L3": {
                "label": "L3",
                "addr": 4390
            },
            "L4": {
                "label": "L4",
                "addr": 4376
            },
            "L5": {
                "label": "L5",
                "addr": 4777
            },
            "L6": {
                "label": "L6",
                "addr": 4663
            },
            "L7": {
                "label": "L7",
                "addr": 4596
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 70,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  lea    -0x1(%rsi),%r9d\n  test   %r9d,%r9d\n  jle    116d <func0+0x74>\n  mov    %esi,%ebx\n  lea    0x4(%rdi),%rsi\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  mov    $0x1,%r8d\n  mov    %r9d,%r13d\n  lea    0x8(%rdi),%r12\n  jmp    1154 <func0+0x5b>\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     1147 <func0+0x4e>\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    112e <func0+0x35>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  jmp    112e <func0+0x35>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %rbp,%r8\n  je     116f <func0+0x76>\n  cmp    %r8d,%ebx\n  jle    1147 <func0+0x4e>\n  mov    %r13d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%r12,%rax,4),%rdi\n  mov    %rsi,%rax\n  jmp    1137 <func0+0x3e>\n  jne    11ab <func0+0xb2>\n  movslq %r9d,%rdx\n  mov    $0x0,%eax\n  jmp    1196 <func0+0x9d>\n  mov    (%r10,%rax,4),%ecx\n  mov    %ecx,(%r11,%rax,8)\n  mov    (%r10,%rdx,4),%ecx\n  mov    %ecx,0x4(%r11,%rax,8)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %edx,%eax\n  jg     11ab <func0+0xb2>\n  lea    (%rax,%rax,1),%ecx\n  cmp    %eax,%edx\n  jne    1179 <func0+0x80>\n  movslq %eax,%rsi\n  mov    (%r10,%rsi,4),%eax\n  movslq %ecx,%rcx\n  mov    %eax,(%r11,%rcx,4)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  lea    -0x1(%rsi),%r9d\n  test   %r9d,%r9d\n  jle    L0\n  mov    %esi,%ebx\n  lea    0x4(%rdi),%rsi\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  mov    $0x1,%r8d\n  mov    %r9d,%r13d\n  lea    0x8(%rdi),%r12\n  jmp    L1\nL3:\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  je     L2\nL5:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L3\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  jmp    L3\nL2:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %rbp,%r8\n  je     L4\nL1:\n  cmp    %r8d,%ebx\n  jle    L2\n  mov    %r13d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    (%r12,%rax,4),%rdi\n  mov    %rsi,%rax\n  jmp    L5\nL0:\n  jne    L6\nL4:\n  movslq %r9d,%rdx\n  mov    $0x0,%eax\n  jmp    L7\nL8:\n  mov    (%r10,%rax,4),%ecx\n  mov    %ecx,(%r11,%rax,8)\n  mov    (%r10,%rdx,4),%ecx\n  mov    %ecx,0x4(%r11,%rax,8)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %edx,%eax\n  jg     L6\nL7:\n  lea    (%rax,%rax,1),%ecx\n  cmp    %eax,%edx\n  jne    L8\n  movslq %eax,%rsi\n  mov    (%r10,%rsi,4),%eax\n  movslq %ecx,%rcx\n  mov    %eax,(%r11,%rcx,4)\nL6:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4461
            },
            "L1": {
                "label": "L1",
                "addr": 4436
            },
            "L2": {
                "label": "L2",
                "addr": 4423
            },
            "L3": {
                "label": "L3",
                "addr": 4398
            },
            "L4": {
                "label": "L4",
                "addr": 4463
            },
            "L5": {
                "label": "L5",
                "addr": 4407
            },
            "L6": {
                "label": "L6",
                "addr": 4523
            },
            "L7": {
                "label": "L7",
                "addr": 4502
            },
            "L8": {
                "label": "L8",
                "addr": 4473
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 70,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  push   %r12\n  lea    -0x1(%rsi),%r12d\n  push   %rbp\n  mov    %r12d,%r9d\n  push   %rbx\n  test   %r12d,%r12d\n  jle    11d9 <func0+0xd9>\n  mov    %esi,%ebx\n  lea    0x8(%rdi),%r13\n  lea    0x4(%rdi),%rsi\n  mov    $0x1,%r8d\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  nopw   0x0(%rax,%rax,1)\n  cmp    %r8d,%ebx\n  jle    1177 <func0+0x77>\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopl   0x0(%rax,%rax,1)\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    116e <func0+0x6e>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    1160 <func0+0x60>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %rbp,%r8\n  jne    1140 <func0+0x40>\n  xor    %eax,%eax\n  xor    %ecx,%ecx\n  jmp    11ac <func0+0xac>\n  nopw   0x0(%rax,%rax,1)\n  movslq %r9d,%rsi\n  add    $0x1,%rax\n  sub    $0x1,%r9d\n  add    $0x2,%ecx\n  mov    (%r10,%rsi,4),%esi\n  mov    %esi,0x4(%r11,%rdx,1)\n  cmp    %eax,%r9d\n  jl     11d2 <func0+0xd2>\n  movslq %ecx,%rdx\n  mov    (%r10,%rax,4),%edi\n  lea    0x1(%rcx),%r8d\n  shl    $0x2,%rdx\n  lea    (%r11,%rdx,1),%rsi\n  mov    %edi,(%rsi)\n  cmp    %eax,%r9d\n  jne    1190 <func0+0x90>\n  add    $0x1,%rax\n  mov    %r8d,%ecx\n  cmp    %eax,%r9d\n  jge    11ac <func0+0xac>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  test   %r12d,%r12d\n  je     1184 <func0+0x84>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  push   %r12\n  lea    -0x1(%rsi),%r12d\n  push   %rbp\n  mov    %r12d,%r9d\n  push   %rbx\n  test   %r12d,%r12d\n  jle    L0\n  mov    %esi,%ebx\n  lea    0x8(%rdi),%r13\n  lea    0x4(%rdi),%rsi\n  mov    $0x1,%r8d\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    %r8d,%ebx\n  jle    L1\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L2\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\nL2:\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    L3\nL1:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %rbp,%r8\n  jne    L4\nL8:\n  xor    %eax,%eax\n  xor    %ecx,%ecx\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL7:\n  movslq %r9d,%rsi\n  add    $0x1,%rax\n  sub    $0x1,%r9d\n  add    $0x2,%ecx\n  mov    (%r10,%rsi,4),%esi\n  mov    %esi,0x4(%r11,%rdx,1)\n  cmp    %eax,%r9d\n  jl     L6\nL5:\n  movslq %ecx,%rdx\n  mov    (%r10,%rax,4),%edi\n  lea    0x1(%rcx),%r8d\n  shl    $0x2,%rdx\n  lea    (%r11,%rdx,1),%rsi\n  mov    %edi,(%rsi)\n  cmp    %eax,%r9d\n  jne    L7\n  add    $0x1,%rax\n  mov    %r8d,%ecx\n  cmp    %eax,%r9d\n  jge    L5\nL6:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL0:\n  test   %r12d,%r12d\n  je     L8\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4569
            },
            "L1": {
                "label": "L1",
                "addr": 4471
            },
            "L2": {
                "label": "L2",
                "addr": 4462
            },
            "L3": {
                "label": "L3",
                "addr": 4448
            },
            "L4": {
                "label": "L4",
                "addr": 4416
            },
            "L5": {
                "label": "L5",
                "addr": 4524
            },
            "L6": {
                "label": "L6",
                "addr": 4562
            },
            "L7": {
                "label": "L7",
                "addr": 4496
            },
            "L8": {
                "label": "L8",
                "addr": 4484
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 70,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *lst, int size, int *out) {\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (lst[i] > lst[j]) {\n                int temp = lst[i];\n                lst[i] = lst[j];\n                lst[j] = temp;\n            }\n        }\n    }\n\n    int l = 0, r = size - 1;\n    int index = 0;\n\n    while (l <= r) {\n        if (l == r) {\n            out[index++] = lst[l++];\n        } else {\n            out[index++] = lst[l++];\n            out[index++] = lst[r--];\n        }\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int a1[] = {1, 2, 3, 4};\n    int e1[] = {1, 4, 2, 3};\n    int out1[4];\n    func0(a1, 4, out1);\n    assert(issame(e1, out1, 4));\n\n    int a2[] = {5, 6, 7, 8, 9};\n    int e2[] = {5, 9, 6, 8, 7};\n    int out2[5];\n    func0(a2, 5, out2);\n    assert(issame(e2, out2, 5));\n\n    int a3[] = {1, 2, 3, 4, 5};\n    int e3[] = {1, 5, 2, 4, 3};\n    int out3[5];\n    func0(a3, 5, out3);\n    assert(issame(e3, out3, 5));\n\n    int a4[] = {5, 6, 7, 8, 9, 1};\n    int e4[] = {1, 9, 5, 8, 6, 7};\n    int out4[6];\n    func0(a4, 6, out4);\n    assert(issame(e4, out4, 6));\n\n    int a5[] = {5, 5, 5, 5};\n    int e5[] = {5, 5, 5, 5};\n    int out5[4];\n    func0(a5, 4, out5);\n    assert(issame(e5, out5, 4));\n\n    int a6[] = {};\n    int e6[] = {};\n    int out6[0];\n    func0(a6, 0, out6);\n    assert(issame(e6, out6, 0));\n\n    int a7[] = {1, 2, 3, 4, 5, 6, 7, 8};\n    int e7[] = {1, 8, 2, 7, 3, 6, 4, 5};\n    int out7[8];\n    func0(a7, 8, out7);\n    assert(issame(e7, out7, 8));\n\n    int a8[] = {0, 2, 2, 2, 5, 5, -5, -5};\n    int e8[] = {-5, 5, -5, 5, 0, 2, 2, 2};\n    int out8[8];\n    func0(a8, 8, out8);\n    assert(issame(e8, out8, 8));\n\n    int a9[] = {111111};\n    int e9[] = {111111};\n    int out9[1];\n    func0(a9, 1, out9);\n    assert(issame(e9, out9, 1));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  push   %r12\n  lea    -0x1(%rsi),%r12d\n  push   %rbp\n  movslq %r12d,%r9\n  push   %rbx\n  test   %r12d,%r12d\n  jle    11de <func0+0xde>\n  mov    %esi,%ebx\n  lea    0x8(%rdi),%r13\n  lea    0x4(%rdi),%rsi\n  mov    $0x1,%r8d\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  nopw   0x0(%rax,%rax,1)\n  cmp    %r8d,%ebx\n  jle    1177 <func0+0x77>\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopl   0x0(%rax,%rax,1)\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    116e <func0+0x6e>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    1160 <func0+0x60>\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r8,%rbp\n  jne    1140 <func0+0x40>\n  xor    %eax,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\n  movslq %ecx,%rdx\n  mov    (%r10,%rax,4),%edi\n  lea    0x1(%rcx),%r8d\n  shl    $0x2,%rdx\n  lea    (%r11,%rdx,1),%rsi\n  mov    %edi,(%rsi)\n  cmp    %eax,%r9d\n  je     11d0 <func0+0xd0>\n  mov    (%r10,%r9,4),%edi\n  lea    -0x1(%r9),%esi\n  add    $0x1,%rax\n  add    $0x2,%ecx\n  mov    %edi,0x4(%r11,%rdx,1)\n  cmp    %eax,%esi\n  jl     11e3 <func0+0xe3>\n  movslq %esi,%r9\n  jmp    1190 <func0+0x90>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  cmp    %eax,%r9d\n  jl     11e3 <func0+0xe3>\n  mov    %r8d,%ecx\n  jmp    1190 <func0+0x90>\n  test   %r9d,%r9d\n  je     1184 <func0+0x84>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdi,%r10\n  mov    %rdx,%r11\n  push   %r12\n  lea    -0x1(%rsi),%r12d\n  push   %rbp\n  movslq %r12d,%r9\n  push   %rbx\n  test   %r12d,%r12d\n  jle    L0\n  mov    %esi,%ebx\n  lea    0x8(%rdi),%r13\n  lea    0x4(%rdi),%rsi\n  mov    $0x1,%r8d\n  lea    -0x2(%rbx),%ebp\n  add    $0x2,%rbp\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    %r8d,%ebx\n  jle    L1\n  mov    %r12d,%eax\n  sub    %r8d,%eax\n  lea    -0x1(%r8,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rsi,%rax\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L2\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\nL2:\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    L3\nL1:\n  add    $0x1,%r8\n  add    $0x4,%rsi\n  cmp    %r8,%rbp\n  jne    L4\nL8:\n  xor    %eax,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\nL7:\n  movslq %ecx,%rdx\n  mov    (%r10,%rax,4),%edi\n  lea    0x1(%rcx),%r8d\n  shl    $0x2,%rdx\n  lea    (%r11,%rdx,1),%rsi\n  mov    %edi,(%rsi)\n  cmp    %eax,%r9d\n  je     L5\n  mov    (%r10,%r9,4),%edi\n  lea    -0x1(%r9),%esi\n  add    $0x1,%rax\n  add    $0x2,%ecx\n  mov    %edi,0x4(%r11,%rdx,1)\n  cmp    %eax,%esi\n  jl     L6\n  movslq %esi,%r9\n  jmp    L7\n  nopw   0x0(%rax,%rax,1)\nL5:\n  add    $0x1,%rax\n  cmp    %eax,%r9d\n  jl     L6\n  mov    %r8d,%ecx\n  jmp    L7\nL0:\n  test   %r9d,%r9d\n  je     L8\nL6:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4574
            },
            "L1": {
                "label": "L1",
                "addr": 4471
            },
            "L2": {
                "label": "L2",
                "addr": 4462
            },
            "L3": {
                "label": "L3",
                "addr": 4448
            },
            "L4": {
                "label": "L4",
                "addr": 4416
            },
            "L5": {
                "label": "L5",
                "addr": 4560
            },
            "L6": {
                "label": "L6",
                "addr": 4579
            },
            "L7": {
                "label": "L7",
                "addr": 4496
            },
            "L8": {
                "label": "L8",
                "addr": 4484
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 71,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  movss  %xmm0,-0x14(%rbp)\n  movss  %xmm1,-0x18(%rbp)\n  movss  %xmm2,-0x1c(%rbp)\n  movss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x18(%rbp),%xmm1\n  movss  -0x1c(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jae    1199 <func0+0x60>\n  movss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x1c(%rbp),%xmm1\n  movss  -0x18(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jae    1199 <func0+0x60>\n  movss  -0x18(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x1c(%rbp),%xmm1\n  movss  -0x14(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jb     11a6 <func0+0x6d>\n  movss  0xe5f(%rip),%xmm0        # 2000 <_fini+0xdc4>\n  jmp    123a <func0+0x101>\n  movss  -0x14(%rbp),%xmm0\n  addss  -0x18(%rbp),%xmm0\n  addss  -0x1c(%rbp),%xmm0\n  movss  0xe47(%rip),%xmm1        # 2004 <_fini+0xdc8>\n  divss  %xmm1,%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  -0x8(%rbp),%xmm1\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x18(%rbp),%xmm0\n  mulss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x1c(%rbp),%xmm0\n  mulss  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  movd   %eax,%xmm0\n  call   1060 <sqrtf@plt>\n  movd   %xmm0,%eax\n  mov    %eax,-0x4(%rbp)\n  movss  -0x4(%rbp),%xmm1\n  movss  0xdf3(%rip),%xmm0        # 2008 <_fini+0xdcc>\n  mulss  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  movd   %eax,%xmm0\n  call   1070 <roundf@plt>\n  movd   %xmm0,%eax\n  movss  0xdd6(%rip),%xmm1        # 2008 <_fini+0xdcc>\n  movd   %eax,%xmm0\n  divss  %xmm1,%xmm0\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  movss  %xmm0,-0x14(%rbp)\n  movss  %xmm1,-0x18(%rbp)\n  movss  %xmm2,-0x1c(%rbp)\n  movss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x18(%rbp),%xmm1\n  movss  -0x1c(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jae    L0\n  movss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x1c(%rbp),%xmm1\n  movss  -0x18(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jae    L0\n  movss  -0x18(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  addss  -0x1c(%rbp),%xmm1\n  movss  -0x14(%rbp),%xmm0\n  comiss %xmm1,%xmm0\n  jb     L1\nL0:\n  movss  D0(%rip),%xmm0\n  jmp    L2\nL1:\n  movss  -0x14(%rbp),%xmm0\n  addss  -0x18(%rbp),%xmm0\n  addss  -0x1c(%rbp),%xmm0\n  movss  D1(%rip),%xmm1\n  divss  %xmm1,%xmm0\n  movss  %xmm0,-0x8(%rbp)\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x14(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  -0x8(%rbp),%xmm1\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x18(%rbp),%xmm0\n  mulss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  subss  -0x1c(%rbp),%xmm0\n  mulss  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  movd   %eax,%xmm0\n  call   <sqrtf@plt>\n  movd   %xmm0,%eax\n  mov    %eax,-0x4(%rbp)\n  movss  -0x4(%rbp),%xmm1\n  movss  D2(%rip),%xmm0\n  mulss  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  movd   %eax,%xmm0\n  call   <roundf@plt>\n  movd   %xmm0,%eax\n  movss  D2(%rip),%xmm1\n  movd   %eax,%xmm0\n  divss  %xmm1,%xmm0\nL2:\n  leave\n  ret",
        "num_missing": 2,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3679
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3655
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3571,
                    3542
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4505
            },
            "L1": {
                "label": "L1",
                "addr": 4518
            },
            "L2": {
                "label": "L2",
                "addr": 4666
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000080bf000000400000c842",
        "rodata_parsed": {
            "func0": {
                "0x2004": {
                    "type": "f32",
                    "value": 2.0
                },
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        128,
                        191
                    ]
                },
                "0x2008": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        200,
                        66
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 71,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    11cd <func0+0x94>\n  movaps %xmm0,%xmm3\n  movss  0xea8(%rip),%xmm0        # 2000 <_fini+0xe28>\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    1170 <func0+0x37>\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jb     1171 <func0+0x38>\n  ret\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  0xe83(%rip),%xmm4        # 2004 <_fini+0xe2c>\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  mulss  %xmm3,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm4,%xmm0\n  pxor   %xmm1,%xmm1\n  ucomiss %xmm0,%xmm1\n  ja     11c6 <func0+0x8d>\n  sqrtss %xmm0,%xmm0\n  mulss  0xe54(%rip),%xmm0        # 2008 <_fini+0xe30>\n  call   1070 <roundf@plt>\n  divss  0xe47(%rip),%xmm0        # 2008 <_fini+0xe30>\n  add    $0x8,%rsp\n  ret\n  call   1060 <sqrtf@plt>\n  jmp    11ac <func0+0x73>\n  movss  0xe2b(%rip),%xmm0        # 2000 <_fini+0xe28>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    L0\n  movaps %xmm0,%xmm3\n  movss  D0(%rip),%xmm0\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    L1\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jb     L2\nL1:\n  ret\nL2:\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  D1(%rip),%xmm4\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  mulss  %xmm3,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm4,%xmm0\n  pxor   %xmm1,%xmm1\n  ucomiss %xmm0,%xmm1\n  ja     L3\n  sqrtss %xmm0,%xmm0\nL4:\n  mulss  D2(%rip),%xmm0\n  call   <roundf@plt>\n  divss  D2(%rip),%xmm0\n  add    $0x8,%rsp\n  ret\nL3:\n  call   <sqrtf@plt>\n  jmp    L4\nL0:\n  movss  D0(%rip),%xmm0\n  ret",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3752,
                    3627
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3715
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3668,
                    3655
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4557
            },
            "L1": {
                "label": "L1",
                "addr": 4464
            },
            "L2": {
                "label": "L2",
                "addr": 4465
            },
            "L3": {
                "label": "L3",
                "addr": 4550
            },
            "L4": {
                "label": "L4",
                "addr": 4524
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000080bf0000003f0000c842",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        128,
                        191
                    ]
                },
                "0x2004": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        0,
                        63
                    ]
                },
                "0x2008": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        200,
                        66
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 71,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    11d8 <func0+0x98>\n  movaps %xmm0,%xmm3\n  movss  0xea1(%rip),%xmm0        # 2000 <_fini+0xe18>\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    11d0 <func0+0x90>\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jae    11d0 <func0+0x90>\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  0xe7d(%rip),%xmm4        # 2004 <_fini+0xe1c>\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  pxor   %xmm1,%xmm1\n  mulss  %xmm4,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  ucomiss %xmm0,%xmm1\n  ja     11e1 <func0+0xa1>\n  sqrtss %xmm0,%xmm0\n  mulss  0xe4e(%rip),%xmm0        # 2008 <_fini+0xe20>\n  call   1070 <roundf@plt>\n  divss  0xe41(%rip),%xmm0        # 2008 <_fini+0xe20>\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax)\n  ret\n  nopl   0x0(%rax)\n  movss  0xe20(%rip),%xmm0        # 2000 <_fini+0xe18>\n  ret\n  call   1060 <sqrtf@plt>\n  jmp    11b2 <func0+0x72>",
        "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    L0\n  movaps %xmm0,%xmm3\n  movss  D0(%rip),%xmm0\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    L1\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jae    L1\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  D1(%rip),%xmm4\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  pxor   %xmm1,%xmm1\n  mulss  %xmm4,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  ucomiss %xmm0,%xmm1\n  ja     L2\n  sqrtss %xmm0,%xmm0\nL3:\n  mulss  D2(%rip),%xmm0\n  call   <roundf@plt>\n  divss  D2(%rip),%xmm0\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax)\nL1:\n  ret\n  nopl   0x0(%rax)\nL0:\n  movss  D0(%rip),%xmm0\n  ret\nL2:\n  call   <sqrtf@plt>\n  jmp    L3",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3745,
                    3616
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3709
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3662,
                    3649
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4568
            },
            "L1": {
                "label": "L1",
                "addr": 4560
            },
            "L2": {
                "label": "L2",
                "addr": 4577
            },
            "L3": {
                "label": "L3",
                "addr": 4530
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000080bf0000003f0000c842",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        128,
                        191
                    ]
                },
                "0x2004": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        0,
                        63
                    ]
                },
                "0x2008": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        200,
                        66
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 71,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nfloat func0(float a, float b, float c) {\nif (a + b <= c || a + c <= b || b + c <= a) return -1;\nfloat s = (a + b + c) / 2;\nfloat area = sqrtf(s * (s - a) * (s - b) * (s - c));\nreturn roundf(area * 100) / 100;\n}",
        "c_test": "#include <stdio.h>\n#include <math.h>\n#include <assert.h>\n\nint main() {\n    assert(fabs(func0(3, 4, 5) - 6.00) < 0.01);\n    assert(fabs(func0(1, 2, 10) + 1) < 0.01);\n    assert(fabs(func0(4, 8, 5) - 8.18) < 0.01);\n    assert(fabs(func0(2, 2, 2) - 1.73) < 0.01);\n    assert(fabs(func0(1, 2, 3) + 1) < 0.01);\n    assert(fabs(func0(10, 5, 7) - 16.25) < 0.01);\n    assert(fabs(func0(2, 6, 3) + 1) < 0.01);\n    assert(fabs(func0(1, 1, 1) - 0.43) < 0.01);\n    assert(fabs(func0(2, 2, 10) + 1) < 0.01);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    11d8 <func0+0x98>\n  movaps %xmm0,%xmm3\n  movss  0xea1(%rip),%xmm0        # 2000 <_fini+0xe18>\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    11d0 <func0+0x90>\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jae    11d0 <func0+0x90>\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  0xe7d(%rip),%xmm4        # 2004 <_fini+0xe1c>\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  pxor   %xmm1,%xmm1\n  mulss  %xmm4,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  ucomiss %xmm0,%xmm1\n  ja     11e1 <func0+0xa1>\n  sqrtss %xmm0,%xmm0\n  mulss  0xe4e(%rip),%xmm0        # 2008 <_fini+0xe20>\n  call   1070 <roundf@plt>\n  divss  0xe41(%rip),%xmm0        # 2008 <_fini+0xe20>\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax)\n  ret\n  nopl   0x0(%rax)\n  movss  0xe20(%rip),%xmm0        # 2000 <_fini+0xe18>\n  ret\n  call   1060 <sqrtf@plt>\n  jmp    11b2 <func0+0x72>",
        "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm4\n  addss  %xmm1,%xmm4\n  comiss %xmm4,%xmm2\n  jae    L0\n  movaps %xmm0,%xmm3\n  movss  D0(%rip),%xmm0\n  movaps %xmm3,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm1\n  jae    L1\n  movaps %xmm1,%xmm5\n  addss  %xmm2,%xmm5\n  comiss %xmm5,%xmm3\n  jae    L1\n  sub    $0x8,%rsp\n  addss  %xmm2,%xmm4\n  mulss  D1(%rip),%xmm4\n  movaps %xmm4,%xmm0\n  subss  %xmm3,%xmm0\n  movaps %xmm4,%xmm3\n  subss  %xmm1,%xmm3\n  pxor   %xmm1,%xmm1\n  mulss  %xmm4,%xmm0\n  subss  %xmm2,%xmm4\n  mulss  %xmm3,%xmm0\n  mulss  %xmm4,%xmm0\n  ucomiss %xmm0,%xmm1\n  ja     L2\n  sqrtss %xmm0,%xmm0\nL3:\n  mulss  D2(%rip),%xmm0\n  call   <roundf@plt>\n  divss  D2(%rip),%xmm0\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax)\nL1:\n  ret\n  nopl   0x0(%rax)\nL0:\n  movss  D0(%rip),%xmm0\n  ret\nL2:\n  call   <sqrtf@plt>\n  jmp    L3",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3745,
                    3616
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3709
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3662,
                    3649
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4568
            },
            "L1": {
                "label": "L1",
                "addr": 4560
            },
            "L2": {
                "label": "L2",
                "addr": 4577
            },
            "L3": {
                "label": "L3",
                "addr": 4530
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000080bf0000003f0000c842",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        128,
                        191
                    ]
                },
                "0x2004": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        0,
                        63
                    ]
                },
                "0x2008": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        200,
                        66
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 72,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1196 <func0+0x9d>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  je     115b <func0+0x62>\n  mov    $0x0,%eax\n  jmp    11e9 <func0+0xf0>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x4(%rbp)\n  jl     111b <func0+0x22>\n  mov    -0x1c(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    11e0 <func0+0xe7>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  setle  %al\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  je     L1\n  mov    $0x0,%eax\n  jmp    L2\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x4(%rbp)\n  jl     L3\n  mov    -0x1c(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L4\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\nL4:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  setle  %al\nL2:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4502
            },
            "L1": {
                "label": "L1",
                "addr": 4443
            },
            "L2": {
                "label": "L2",
                "addr": 4585
            },
            "L3": {
                "label": "L3",
                "addr": 4379
            },
            "L4": {
                "label": "L4",
                "addr": 4576
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 72,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  mov    %esi,%r10d\n  mov    %edx,%r11d\n  mov    %esi,%r8d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    1162 <func0+0x69>\n  movslq %esi,%rax\n  lea    (%rdi,%rax,4),%rcx\n  mov    $0x0,%edx\n  mov    $0x0,%edi\n  mov    (%r9,%rdx,4),%eax\n  mov    -0x4(%rcx),%esi\n  cmp    %esi,%eax\n  jne    1172 <func0+0x79>\n  add    %esi,%eax\n  add    %eax,%edi\n  add    $0x1,%rdx\n  sub    $0x4,%rcx\n  cmp    %edx,%r8d\n  jg     1129 <func0+0x30>\n  mov    %r10d,%eax\n  shr    $0x1f,%eax\n  add    %eax,%r10d\n  and    $0x1,%r10d\n  sub    %eax,%r10d\n  cmp    $0x1,%r10d\n  je     1169 <func0+0x70>\n  cmp    %r11d,%edi\n  setle  %al\n  ret\n  mov    $0x0,%edi\n  jmp    1145 <func0+0x4c>\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  jmp    115b <func0+0x62>\n  mov    $0x0,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  mov    %esi,%r10d\n  mov    %edx,%r11d\n  mov    %esi,%r8d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rax\n  lea    (%rdi,%rax,4),%rcx\n  mov    $0x0,%edx\n  mov    $0x0,%edi\nL2:\n  mov    (%r9,%rdx,4),%eax\n  mov    -0x4(%rcx),%esi\n  cmp    %esi,%eax\n  jne    L1\n  add    %esi,%eax\n  add    %eax,%edi\n  add    $0x1,%rdx\n  sub    $0x4,%rcx\n  cmp    %edx,%r8d\n  jg     L2\nL4:\n  mov    %r10d,%eax\n  shr    $0x1f,%eax\n  add    %eax,%r10d\n  and    $0x1,%r10d\n  sub    %eax,%r10d\n  cmp    $0x1,%r10d\n  je     L3\nL5:\n  cmp    %r11d,%edi\n  setle  %al\n  ret\nL0:\n  mov    $0x0,%edi\n  jmp    L4\nL3:\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  jmp    L5\nL1:\n  mov    $0x0,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4450
            },
            "L1": {
                "label": "L1",
                "addr": 4466
            },
            "L2": {
                "label": "L2",
                "addr": 4393
            },
            "L3": {
                "label": "L3",
                "addr": 4457
            },
            "L4": {
                "label": "L4",
                "addr": 4421
            },
            "L5": {
                "label": "L5",
                "addr": 4443
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 72,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  mov    %rdi,%r9\n  mov    %edx,%r10d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    114b <func0+0x4b>\n  lea    -0x1(%rsi),%eax\n  cltq\n  lea    (%rdi,%rax,4),%rdx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    1140 <func0+0x40>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  lea    (%rdi,%rcx,2),%edi\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jle    1150 <func0+0x50>\n  mov    (%r9,%rax,4),%ecx\n  cmp    (%rdx),%ecx\n  je     1130 <func0+0x30>\n  xor    %eax,%eax\n  ret\n  xor    %edi,%edi\n  nopl   (%rax)\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%esi\n  and    $0x1,%esi\n  sub    %eax,%esi\n  cmp    $0x1,%esi\n  je     1170 <func0+0x70>\n  cmp    %r10d,%edi\n  setle  %al\n  ret\n  nopl   0x0(%rax,%rax,1)\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  cmp    %r10d,%edi\n  setle  %al\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  mov    %rdi,%r9\n  mov    %edx,%r10d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cltq\n  lea    (%rdi,%rax,4),%rdx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  lea    (%rdi,%rcx,2),%edi\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jle    L2\nL1:\n  mov    (%r9,%rax,4),%ecx\n  cmp    (%rdx),%ecx\n  je     L3\n  xor    %eax,%eax\n  ret\nL0:\n  xor    %edi,%edi\n  nopl   (%rax)\nL2:\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%esi\n  and    $0x1,%esi\n  sub    %eax,%esi\n  cmp    $0x1,%esi\n  je     L4\n  cmp    %r10d,%edi\n  setle  %al\n  ret\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  cmp    %r10d,%edi\n  setle  %al\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4427
            },
            "L1": {
                "label": "L1",
                "addr": 4416
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4400
            },
            "L4": {
                "label": "L4",
                "addr": 4464
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 72,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int q[], int size, int w) {\n    int sum = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (q[i] != q[size - 1 - i]) return false;\n        sum += q[i] + q[size - 1 - i];\n    }\n    if (size % 2 == 1) sum += q[size / 2];\n    return sum <= w;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {3, 2, 3};\n    assert(func0(test1, 3, 9) == true);\n\n    int test2[] = {1, 2};\n    assert(func0(test2, 2, 5) == false);\n\n    int test3[] = {3};\n    assert(func0(test3, 1, 5) == true);\n\n    int test4[] = {3, 2, 3};\n    assert(func0(test4, 3, 1) == false);\n\n    int test5[] = {1, 2, 3};\n    assert(func0(test5, 3, 6) == false);\n\n    int test6[] = {5};\n    assert(func0(test6, 1, 5) == true);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  mov    %rdi,%r9\n  mov    %edx,%r10d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    114b <func0+0x4b>\n  lea    -0x1(%rsi),%eax\n  cltq\n  lea    (%rdi,%rax,4),%rdx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    1140 <func0+0x40>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  lea    (%rdi,%rcx,2),%edi\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jle    1150 <func0+0x50>\n  mov    (%r9,%rax,4),%ecx\n  cmp    (%rdx),%ecx\n  je     1130 <func0+0x30>\n  xor    %eax,%eax\n  ret\n  xor    %edi,%edi\n  nopl   (%rax)\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%esi\n  and    $0x1,%esi\n  sub    %eax,%esi\n  cmp    $0x1,%esi\n  je     1170 <func0+0x70>\n  cmp    %r10d,%edi\n  setle  %al\n  ret\n  nopl   0x0(%rax,%rax,1)\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  cmp    %r10d,%edi\n  setle  %al\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  mov    %rdi,%r9\n  mov    %edx,%r10d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cltq\n  lea    (%rdi,%rax,4),%rdx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  lea    (%rdi,%rcx,2),%edi\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jle    L2\nL1:\n  mov    (%r9,%rax,4),%ecx\n  cmp    (%rdx),%ecx\n  je     L3\n  xor    %eax,%eax\n  ret\nL0:\n  xor    %edi,%edi\n  nopl   (%rax)\nL2:\n  mov    %esi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%esi\n  and    $0x1,%esi\n  sub    %eax,%esi\n  cmp    $0x1,%esi\n  je     L4\n  cmp    %r10d,%edi\n  setle  %al\n  ret\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movslq %r8d,%r8\n  add    (%r9,%r8,4),%edi\n  cmp    %r10d,%edi\n  setle  %al\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4427
            },
            "L1": {
                "label": "L1",
                "addr": 4416
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4400
            },
            "L4": {
                "label": "L4",
                "addr": 4464
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 73,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1156 <func0+0x5d>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  je     1152 <func0+0x59>\n  addl   $0x1,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x4(%rbp)\n  jl     1118 <func0+0x1f>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  je     L1\n  addl   $0x1,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x4(%rbp)\n  jl     L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4438
            },
            "L1": {
                "label": "L1",
                "addr": 4434
            },
            "L2": {
                "label": "L2",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 73,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    1140 <func0+0x47>\n  movslq %esi,%rsi\n  lea    (%rdi,%rsi,4),%rdx\n  mov    $0x0,%eax\n  mov    $0x0,%ecx\n  mov    -0x4(%rdx),%esi\n  cmp    %esi,(%rdi,%rax,4)\n  setne  %sil\n  movzbl %sil,%esi\n  add    %esi,%ecx\n  add    $0x1,%rax\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jg     1120 <func0+0x27>\n  mov    %ecx,%eax\n  ret\n  mov    $0x0,%ecx\n  jmp    113d <func0+0x44>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%r8d\n  shr    $0x1f,%r8d\n  add    %esi,%r8d\n  sar    %r8d\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rsi\n  lea    (%rdi,%rsi,4),%rdx\n  mov    $0x0,%eax\n  mov    $0x0,%ecx\nL1:\n  mov    -0x4(%rdx),%esi\n  cmp    %esi,(%rdi,%rax,4)\n  setne  %sil\n  movzbl %sil,%esi\n  add    %esi,%ecx\n  add    $0x1,%rax\n  sub    $0x4,%rdx\n  cmp    %eax,%r8d\n  jg     L1\nL2:\n  mov    %ecx,%eax\n  ret\nL0:\n  mov    $0x0,%ecx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            },
            "L2": {
                "label": "L2",
                "addr": 4413
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 73,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %esi,%r9d\n  shr    $0x1f,%r9d\n  add    %esi,%r9d\n  sar    %r9d\n  cmp    $0x1,%esi\n  jle    1150 <func0+0x50>\n  sub    $0x1,%esi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  movslq %esi,%rsi\n  lea    (%rdi,%rsi,4),%rdx\n  nopl   (%rax)\n  mov    (%rdx),%esi\n  xor    %ecx,%ecx\n  cmp    %esi,(%rdi,%rax,4)\n  setne  %cl\n  add    $0x1,%rax\n  sub    $0x4,%rdx\n  add    %ecx,%r8d\n  cmp    %eax,%r9d\n  jg     1128 <func0+0x28>\n  mov    %r8d,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%r9d\n  shr    $0x1f,%r9d\n  add    %esi,%r9d\n  sar    %r9d\n  cmp    $0x1,%esi\n  jle    L0\n  sub    $0x1,%esi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  movslq %esi,%rsi\n  lea    (%rdi,%rsi,4),%rdx\n  nopl   (%rax)\nL1:\n  mov    (%rdx),%esi\n  xor    %ecx,%ecx\n  cmp    %esi,(%rdi,%rax,4)\n  setne  %cl\n  add    $0x1,%rax\n  sub    $0x4,%rdx\n  add    %ecx,%r8d\n  cmp    %eax,%r9d\n  jg     L1\n  mov    %r8d,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4432
            },
            "L1": {
                "label": "L1",
                "addr": 4392
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 73,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int size) {\n    int out = 0;\n    for (int i = 0; i < size / 2; i++) {\n        if (arr[i] != arr[size - 1 - i]) {\n            out++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 5, 4, 7, 9, 6};\n    assert(func0(test1, 8) == 4);\n\n    int test2[] = {1, 2, 3, 4, 3, 2, 2};\n    assert(func0(test2, 7) == 1);\n\n    int test3[] = {1, 4, 2};\n    assert(func0(test3, 3) == 1);\n\n    int test4[] = {1, 4, 4, 2};\n    assert(func0(test4, 4) == 1);\n\n    int test5[] = {1, 2, 3, 2, 1};\n    assert(func0(test5, 5) == 0);\n\n    int test6[] = {3, 1, 1, 3};\n    assert(func0(test6, 4) == 0);\n\n    int test7[] = {1};\n    assert(func0(test7, 1) == 0);\n\n    int test8[] = {0, 1};\n    assert(func0(test8, 2) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  cmp    $0x1,%esi\n  jle    1200 <func0+0x100>\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x7,%esi\n  jle    1209 <func0+0x109>\n  movslq %esi,%rsi\n  pxor   %xmm1,%xmm1\n  mov    %rcx,%rax\n  lea    -0x10(%rcx,%rsi,4),%rdx\n  mov    %edi,%esi\n  movdqa %xmm1,%xmm2\n  shr    $0x2,%esi\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  lea    0x10(%rcx,%rsi,1),%rsi\n  nopw   0x0(%rax,%rax,1)\n  movdqu (%rdx),%xmm3\n  movdqu (%rax),%xmm4\n  add    $0x10,%rax\n  sub    $0x10,%rdx\n  pshufd $0x1b,%xmm3,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pcmpeqd %xmm2,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%rsi\n  jne    1150 <func0+0x50>\n  movdqa %xmm1,%xmm0\n  mov    %edi,%edx\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%edx\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%dil\n  je     1208 <func0+0x108>\n  mov    %r8d,%esi\n  movslq %edx,%r9\n  sub    %edx,%esi\n  lea    0x0(,%r9,4),%r10\n  movslq %esi,%rsi\n  mov    (%rcx,%rsi,4),%esi\n  cmp    %esi,(%rcx,%r9,4)\n  je     11be <func0+0xbe>\n  add    $0x1,%eax\n  lea    0x1(%rdx),%r9d\n  cmp    %edi,%r9d\n  jge    1202 <func0+0x102>\n  mov    %r8d,%esi\n  mov    0x4(%rcx,%r10,1),%r11d\n  sub    %r9d,%esi\n  movslq %esi,%rsi\n  cmp    %r11d,(%rcx,%rsi,4)\n  je     11de <func0+0xde>\n  add    $0x1,%eax\n  add    $0x2,%edx\n  cmp    %edi,%edx\n  jge    1202 <func0+0x102>\n  sub    %edx,%r8d\n  movslq %r8d,%r8\n  mov    (%rcx,%r8,4),%edi\n  cmp    %edi,0x8(%rcx,%r10,1)\n  je     1202 <func0+0x102>\n  add    $0x1,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  ret\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    119f <func0+0x9f>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  mov    %esi,%edi\n  shr    $0x1f,%edi\n  add    %esi,%edi\n  sar    %edi\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x1(%rsi),%r8d\n  cmp    $0x7,%esi\n  jle    L1\n  movslq %esi,%rsi\n  pxor   %xmm1,%xmm1\n  mov    %rcx,%rax\n  lea    -0x10(%rcx,%rsi,4),%rdx\n  mov    %edi,%esi\n  movdqa %xmm1,%xmm2\n  shr    $0x2,%esi\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  lea    0x10(%rcx,%rsi,1),%rsi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movdqu (%rdx),%xmm3\n  movdqu (%rax),%xmm4\n  add    $0x10,%rax\n  sub    $0x10,%rdx\n  pshufd $0x1b,%xmm3,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pcmpeqd %xmm2,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%rsi\n  jne    L2\n  movdqa %xmm1,%xmm0\n  mov    %edi,%edx\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%edx\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%dil\n  je     L3\nL7:\n  mov    %r8d,%esi\n  movslq %edx,%r9\n  sub    %edx,%esi\n  lea    0x0(,%r9,4),%r10\n  movslq %esi,%rsi\n  mov    (%rcx,%rsi,4),%esi\n  cmp    %esi,(%rcx,%r9,4)\n  je     L4\n  add    $0x1,%eax\nL4:\n  lea    0x1(%rdx),%r9d\n  cmp    %edi,%r9d\n  jge    L5\n  mov    %r8d,%esi\n  mov    0x4(%rcx,%r10,1),%r11d\n  sub    %r9d,%esi\n  movslq %esi,%rsi\n  cmp    %r11d,(%rcx,%rsi,4)\n  je     L6\n  add    $0x1,%eax\nL6:\n  add    $0x2,%edx\n  cmp    %edi,%edx\n  jge    L5\n  sub    %edx,%r8d\n  movslq %r8d,%r8\n  mov    (%rcx,%r8,4),%edi\n  cmp    %edi,0x8(%rcx,%r10,1)\n  je     L5\n  add    $0x1,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\nL5:\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  ret\nL1:\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    L7",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4608
            },
            "L1": {
                "label": "L1",
                "addr": 4617
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4616
            },
            "L4": {
                "label": "L4",
                "addr": 4542
            },
            "L5": {
                "label": "L5",
                "addr": 4610
            },
            "L6": {
                "label": "L6",
                "addr": 4574
            },
            "L7": {
                "label": "L7",
                "addr": 4511
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 74,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    1177 <func0+0x5e>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     114a <func0+0x31>\n  movl   $0x0,-0xc(%rbp)\n  jmp    11b5 <func0+0x9c>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x4(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x4(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     1188 <func0+0x6f>\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jge    11cb <func0+0xb2>\n  mov    -0x18(%rbp),%rax\n  jmp    11dd <func0+0xc4>\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jle    11d9 <func0+0xc0>\n  mov    -0x28(%rbp),%rax\n  jmp    11dd <func0+0xc4>\n  mov    -0x18(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL1:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L1\n  movl   $0x0,-0xc(%rbp)\n  jmp    L2\nL3:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,%edx\n  mov    -0x4(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,-0x4(%rbp)\n  addl   $0x1,-0xc(%rbp)\nL2:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     L3\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jge    L4\n  mov    -0x18(%rbp),%rax\n  jmp    L5\nL4:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jle    L6\n  mov    -0x28(%rbp),%rax\n  jmp    L5\nL6:\n  mov    -0x18(%rbp),%rax\nL5:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4471
            },
            "L1": {
                "label": "L1",
                "addr": 4426
            },
            "L2": {
                "label": "L2",
                "addr": 4533
            },
            "L3": {
                "label": "L3",
                "addr": 4488
            },
            "L4": {
                "label": "L4",
                "addr": 4555
            },
            "L5": {
                "label": "L5",
                "addr": 4573
            },
            "L6": {
                "label": "L6",
                "addr": 4569
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 74,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %rdx,%r12\n  mov    %ecx,%r13d\n  test   %esi,%esi\n  jle    11a1 <func0+0x88>\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r15\n  mov    $0x0,%ebp\n  mov    (%rbx),%rdi\n  call   1050 <strlen@plt>\n  add    %eax,%ebp\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    1148 <func0+0x2f>\n  test   %r13d,%r13d\n  jle    1199 <func0+0x80>\n  mov    $0x0,%ebx\n  mov    $0x0,%r15d\n  mov    (%r12,%rbx,8),%rdi\n  call   1050 <strlen@plt>\n  add    %eax,%r15d\n  add    $0x1,%rbx\n  cmp    %ebx,%r13d\n  jg     116b <func0+0x52>\n  cmp    %r15d,%ebp\n  cmovle %r14,%r12\n  mov    %r12,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    $0x0,%r15d\n  jmp    1180 <func0+0x67>\n  mov    $0x0,%ebp\n  test   %ecx,%ecx\n  jg     1160 <func0+0x47>\n  mov    %rdi,%r12\n  jmp    1187 <func0+0x6e>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %rdx,%r12\n  mov    %ecx,%r13d\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r15\n  mov    $0x0,%ebp\nL1:\n  mov    (%rbx),%rdi\n  call   <strlen@plt>\n  add    %eax,%ebp\n  add    $0x8,%rbx\n  cmp    %r15,%rbx\n  jne    L1\n  test   %r13d,%r13d\n  jle    L2\nL5:\n  mov    $0x0,%ebx\n  mov    $0x0,%r15d\nL3:\n  mov    (%r12,%rbx,8),%rdi\n  call   <strlen@plt>\n  add    %eax,%r15d\n  add    $0x1,%rbx\n  cmp    %ebx,%r13d\n  jg     L3\nL4:\n  cmp    %r15d,%ebp\n  cmovle %r14,%r12\nL6:\n  mov    %r12,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL2:\n  mov    $0x0,%r15d\n  jmp    L4\nL0:\n  mov    $0x0,%ebp\n  test   %ecx,%ecx\n  jg     L5\n  mov    %rdi,%r12\n  jmp    L6",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4513
            },
            "L1": {
                "label": "L1",
                "addr": 4424
            },
            "L2": {
                "label": "L2",
                "addr": 4505
            },
            "L3": {
                "label": "L3",
                "addr": 4459
            },
            "L4": {
                "label": "L4",
                "addr": 4480
            },
            "L5": {
                "label": "L5",
                "addr": 4448
            },
            "L6": {
                "label": "L6",
                "addr": 4487
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 74,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    11a0 <func0+0x80>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r15\n  nopl   0x0(%rax)\n  mov    (%rbx),%rdi\n  add    $0x8,%rbx\n  call   1050 <strlen@plt>\n  add    %eax,%ebp\n  cmp    %rbx,%r15\n  jne    1150 <func0+0x30>\n  test   %r12d,%r12d\n  jle    11b0 <func0+0x90>\n  xor    %ebx,%ebx\n  xor    %r15d,%r15d\n  nopl   (%rax)\n  mov    0x0(%r13,%rbx,8),%rdi\n  add    $0x1,%rbx\n  call   1050 <strlen@plt>\n  add    %eax,%r15d\n  cmp    %ebx,%r12d\n  jg     1170 <func0+0x50>\n  cmp    %r15d,%ebp\n  mov    %r13,%rax\n  cmovle %r14,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nop\n  xor    %ebp,%ebp\n  test   %ecx,%ecx\n  jg     1168 <func0+0x48>\n  mov    %rdi,%rax\n  jmp    1190 <func0+0x70>\n  nopl   0x0(%rax,%rax,1)\n  xor    %r15d,%r15d\n  jmp    1186 <func0+0x66>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r15\n  nopl   0x0(%rax)\nL1:\n  mov    (%rbx),%rdi\n  add    $0x8,%rbx\n  call   <strlen@plt>\n  add    %eax,%ebp\n  cmp    %rbx,%r15\n  jne    L1\n  test   %r12d,%r12d\n  jle    L2\nL4:\n  xor    %ebx,%ebx\n  xor    %r15d,%r15d\n  nopl   (%rax)\nL3:\n  mov    0x0(%r13,%rbx,8),%rdi\n  add    $0x1,%rbx\n  call   <strlen@plt>\n  add    %eax,%r15d\n  cmp    %ebx,%r12d\n  jg     L3\nL6:\n  cmp    %r15d,%ebp\n  mov    %r13,%rax\n  cmovle %r14,%rax\nL5:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nop\nL0:\n  xor    %ebp,%ebp\n  test   %ecx,%ecx\n  jg     L4\n  mov    %rdi,%rax\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL2:\n  xor    %r15d,%r15d\n  jmp    L6",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4512
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            },
            "L2": {
                "label": "L2",
                "addr": 4528
            },
            "L3": {
                "label": "L3",
                "addr": 4464
            },
            "L4": {
                "label": "L4",
                "addr": 4456
            },
            "L5": {
                "label": "L5",
                "addr": 4496
            },
            "L6": {
                "label": "L6",
                "addr": 4486
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 74,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char** arr1, int n1, char** arr2, int n2){\n\n  int i, sum1 = 0, sum2 = 0;\n\n  for(i=0; i<n1; i++){\n    sum1 += strlen(arr1[i]);\n  }\n  \n  for(i=0; i<n2; i++){\n    sum2 += strlen(arr2[i]); \n  }\n\n  if(sum1 < sum2){\n    return arr1;\n  }\n  else if(sum1 > sum2){\n    return arr2;\n  }\n  else{\n    return arr1;\n  }\n\n}",
        "c_test": "int issame(char** arr1, int n1, char** arr2, int n2){\n\n  int i;\n  if(n1 != n2) return 0;\n\n  for(i=0; i<n1; i++){\n    if(strcmp(arr1[i], arr2[i]) != 0) return 0;\n  }\n\n  return 1;\n\n}\n\n// Main function\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(){\n\n  char* arr1[] = {};\n  char* arr2[] = {};\n  int n1 = 0, n2 = 0;\n  issame(func0(arr1, n1, arr2, n2), n1, arr2, n2);\n\n  char* arr3[] = {\"hi\", \"admin\"};\n  char* arr4[] = {\"hi\", \"hi\"};\n  n1 = 2; n2 = 2;\n  issame(func0(arr3, n1, arr4, n2), n1, arr4, n2);\n\n  char* arr5[] = {\"hi\", \"admin\"};\n  char* arr6[] = {\"hi\", \"hi\", \"admin\", \"project\"};\n  n1 = 2; n2 = 4;\n  issame(func0(arr5, n1, arr6, n2), n1, arr5, n1);\n\n  // Other test cases\n\n  return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    11a0 <func0+0x80>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r15\n  nopl   0x0(%rax)\n  mov    (%rbx),%rdi\n  add    $0x8,%rbx\n  call   1050 <strlen@plt>\n  add    %eax,%ebp\n  cmp    %rbx,%r15\n  jne    1150 <func0+0x30>\n  test   %r12d,%r12d\n  jle    11b0 <func0+0x90>\n  xor    %ebx,%ebx\n  xor    %r15d,%r15d\n  nopl   (%rax)\n  mov    0x0(%r13,%rbx,8),%rdi\n  add    $0x1,%rbx\n  call   1050 <strlen@plt>\n  add    %eax,%r15d\n  cmp    %ebx,%r12d\n  jg     1170 <func0+0x50>\n  cmp    %r15d,%ebp\n  mov    %r13,%rax\n  cmovle %r14,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nop\n  xor    %ebp,%ebp\n  test   %ecx,%ecx\n  jg     1168 <func0+0x48>\n  mov    %rdi,%rax\n  jmp    1190 <func0+0x70>\n  nopl   0x0(%rax,%rax,1)\n  xor    %r15d,%r15d\n  jmp    1186 <func0+0x66>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  mov    %ecx,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  lea    0x8(%rdi,%rax,8),%r15\n  nopl   0x0(%rax)\nL1:\n  mov    (%rbx),%rdi\n  add    $0x8,%rbx\n  call   <strlen@plt>\n  add    %eax,%ebp\n  cmp    %rbx,%r15\n  jne    L1\n  test   %r12d,%r12d\n  jle    L2\nL4:\n  xor    %ebx,%ebx\n  xor    %r15d,%r15d\n  nopl   (%rax)\nL3:\n  mov    0x0(%r13,%rbx,8),%rdi\n  add    $0x1,%rbx\n  call   <strlen@plt>\n  add    %eax,%r15d\n  cmp    %ebx,%r12d\n  jg     L3\nL6:\n  cmp    %r15d,%ebp\n  mov    %r13,%rax\n  cmovle %r14,%rax\nL5:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nop\nL0:\n  xor    %ebp,%ebp\n  test   %ecx,%ecx\n  jg     L4\n  mov    %rdi,%rax\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL2:\n  xor    %r15d,%r15d\n  jmp    L6",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4512
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            },
            "L2": {
                "label": "L2",
                "addr": 4528
            },
            "L3": {
                "label": "L3",
                "addr": 4464
            },
            "L4": {
                "label": "L4",
                "addr": 4456
            },
            "L5": {
                "label": "L5",
                "addr": 4496
            },
            "L6": {
                "label": "L6",
                "addr": 4486
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 75,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  cmpl   $0x1,-0x14(%rbp)\n  jg     1111 <func0+0x18>\n  mov    $0x0,%eax\n  jmp    115f <func0+0x66>\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    1140 <func0+0x47>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %eax,-0x14(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  je     1121 <func0+0x28>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    112f <func0+0x36>\n  cmpl   $0x1,-0x14(%rbp)\n  jle    1155 <func0+0x5c>\n  addl   $0x1,-0x8(%rbp)\n  cmpl   $0x3,-0x8(%rbp)\n  sete   %al\n  movzbl %al,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  cmpl   $0x1,-0x14(%rbp)\n  jg     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    L2\nL3:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %eax,-0x14(%rbp)\n  addl   $0x1,-0x8(%rbp)\nL4:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  je     L3\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L4\n  cmpl   $0x1,-0x14(%rbp)\n  jle    L5\n  addl   $0x1,-0x8(%rbp)\nL5:\n  cmpl   $0x3,-0x8(%rbp)\n  sete   %al\n  movzbl %al,%eax\nL1:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4369
            },
            "L1": {
                "label": "L1",
                "addr": 4447
            },
            "L2": {
                "label": "L2",
                "addr": 4416
            },
            "L3": {
                "label": "L3",
                "addr": 4385
            },
            "L4": {
                "label": "L4",
                "addr": 4399
            },
            "L5": {
                "label": "L5",
                "addr": 4437
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 75,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  cmp    $0x1,%edi\n  jle    1151 <func0+0x58>\n  mov    $0x2,%ecx\n  mov    $0x0,%esi\n  cmp    $0x3,%edi\n  jg     1135 <func0+0x3c>\n  jmp    1145 <func0+0x4c>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%edi\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1118 <func0+0x1f>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     1140 <func0+0x47>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1118 <func0+0x1f>\n  jmp    1129 <func0+0x30>\n  cmp    $0x1,%edi\n  jle    1148 <func0+0x4f>\n  add    $0x1,%esi\n  cmp    $0x3,%esi\n  sete   %al\n  movzbl %al,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  cmp    $0x1,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  mov    $0x0,%esi\n  cmp    $0x3,%edi\n  jg     L1\n  jmp    L2\nL3:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  mov    %eax,%edi\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL5:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     L4\nL1:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\n  jmp    L5\nL4:\n  cmp    $0x1,%edi\n  jle    L6\nL2:\n  add    $0x1,%esi\nL6:\n  cmp    $0x3,%esi\n  sete   %al\n  movzbl %al,%eax\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4433
            },
            "L1": {
                "label": "L1",
                "addr": 4405
            },
            "L2": {
                "label": "L2",
                "addr": 4421
            },
            "L3": {
                "label": "L3",
                "addr": 4376
            },
            "L4": {
                "label": "L4",
                "addr": 4416
            },
            "L5": {
                "label": "L5",
                "addr": 4393
            },
            "L6": {
                "label": "L6",
                "addr": 4424
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 75,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%edi\n  jle    115a <func0+0x5a>\n  mov    $0x2,%ecx\n  xor    %esi,%esi\n  cmp    $0x3,%edi\n  jle    1164 <func0+0x64>\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    1141 <func0+0x41>\n  nopl   0x0(%rax)\n  mov    %edi,%eax\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%edi\n  idiv   %ecx\n  test   %edx,%edx\n  je     1130 <func0+0x30>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1120 <func0+0x20>\n  cmp    $0x1,%edi\n  jle    115b <func0+0x5b>\n  xor    %eax,%eax\n  cmp    $0x2,%esi\n  sete   %al\n  ret\n  xor    %eax,%eax\n  cmp    $0x3,%esi\n  sete   %al\n  ret\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  xor    %esi,%esi\n  cmp    $0x3,%edi\n  jle    L1\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\n  nopl   0x0(%rax)\nL3:\n  mov    %edi,%eax\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%edi\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L4\n  cmp    $0x1,%edi\n  jle    L5\n  xor    %eax,%eax\n  cmp    $0x2,%esi\n  sete   %al\nL0:\n  ret\nL5:\n  xor    %eax,%eax\n  cmp    $0x3,%esi\n  sete   %al\n  ret\nL1:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4442
            },
            "L1": {
                "label": "L1",
                "addr": 4452
            },
            "L2": {
                "label": "L2",
                "addr": 4417
            },
            "L3": {
                "label": "L3",
                "addr": 4400
            },
            "L4": {
                "label": "L4",
                "addr": 4384
            },
            "L5": {
                "label": "L5",
                "addr": 4443
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 75,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    if (a < 2) return 0;\n    int num = 0;\n    for (int i = 2; i * i <= a; i++) {\n        while (a % i == 0) {\n            a = a / i;\n            num++;\n        }\n    }\n    if (a > 1) num++;\n    return num == 3;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 0);\n    assert(func0(30) == 1);\n    assert(func0(8) == 1); // 8 = 2 * 2 * 2\n    assert(func0(10) == 0);\n    assert(func0(125) == 1); // 125 = 5 * 5 * 5 (three times the same prime)\n    assert(func0(3 * 5 * 7) == 1);\n    assert(func0(3 * 6 * 7) == 0);\n    assert(func0(9 * 9 * 9) == 0);\n    assert(func0(11 * 9 * 9) == 0);\n    assert(func0(11 * 13 * 7) == 1);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%edi\n  jle    115a <func0+0x5a>\n  mov    $0x2,%ecx\n  xor    %esi,%esi\n  cmp    $0x3,%edi\n  jle    1164 <func0+0x64>\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    1141 <func0+0x41>\n  nopl   0x0(%rax)\n  mov    %edi,%eax\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%edi\n  idiv   %ecx\n  test   %edx,%edx\n  je     1130 <func0+0x30>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1120 <func0+0x20>\n  cmp    $0x1,%edi\n  jle    115b <func0+0x5b>\n  xor    %eax,%eax\n  cmp    $0x2,%esi\n  sete   %al\n  ret\n  xor    %eax,%eax\n  cmp    $0x3,%esi\n  sete   %al\n  ret\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  cmp    $0x1,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  xor    %esi,%esi\n  cmp    $0x3,%edi\n  jle    L1\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L2\n  nopl   0x0(%rax)\nL3:\n  mov    %edi,%eax\n  add    $0x1,%esi\n  cltd\n  idiv   %ecx\n  cltd\n  mov    %eax,%edi\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L4\n  cmp    $0x1,%edi\n  jle    L5\n  xor    %eax,%eax\n  cmp    $0x2,%esi\n  sete   %al\nL0:\n  ret\nL5:\n  xor    %eax,%eax\n  cmp    $0x3,%esi\n  sete   %al\n  ret\nL1:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4442
            },
            "L1": {
                "label": "L1",
                "addr": 4452
            },
            "L2": {
                "label": "L2",
                "addr": 4417
            },
            "L3": {
                "label": "L3",
                "addr": 4400
            },
            "L4": {
                "label": "L4",
                "addr": 4384
            },
            "L5": {
                "label": "L5",
                "addr": 4443
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 76,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1134 <func0+0x3b>\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    1126 <func0+0x2d>\n  mov    $0x1,%eax\n  jmp    1147 <func0+0x4e>\n  mov    -0x8(%rbp),%eax\n  imul   -0x18(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jg     1142 <func0+0x49>\n  cmpl   $0x63,-0x4(%rbp)\n  jle    1117 <func0+0x1e>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL4:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    L1\n  mov    $0x1,%eax\n  jmp    L2\nL1:\n  mov    -0x8(%rbp),%eax\n  imul   -0x18(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jg     L3\n  cmpl   $0x63,-0x4(%rbp)\n  jle    L4\nL3:\n  mov    $0x0,%eax\nL2:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4404
            },
            "L1": {
                "label": "L1",
                "addr": 4390
            },
            "L2": {
                "label": "L2",
                "addr": 4423
            },
            "L3": {
                "label": "L3",
                "addr": 4418
            },
            "L4": {
                "label": "L4",
                "addr": 4375
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 76,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    112f <func0+0x36>\n  cmp    $0x1,%edi\n  je     1135 <func0+0x3c>\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\n  imul   %esi,%edx\n  add    $0x1,%ecx\n  cmp    %edx,%edi\n  jl     1129 <func0+0x30>\n  cmp    $0x63,%ecx\n  jg     1129 <func0+0x30>\n  cmp    %edx,%edi\n  jne    1110 <func0+0x17>\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    $0x0,%eax\n  ret\n  mov    %edi,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  cmp    $0x1,%edi\n  je     L1\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\nL3:\n  imul   %esi,%edx\n  add    $0x1,%ecx\n  cmp    %edx,%edi\n  jl     L2\n  cmp    $0x63,%ecx\n  jg     L2\n  cmp    %edx,%edi\n  jne    L3\n  mov    $0x1,%eax\n  ret\nL2:\n  mov    $0x0,%eax\n  ret\nL0:\n  mov    $0x0,%eax\n  ret\nL1:\n  mov    %edi,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4399
            },
            "L1": {
                "label": "L1",
                "addr": 4405
            },
            "L2": {
                "label": "L2",
                "addr": 4393
            },
            "L3": {
                "label": "L3",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 76,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1138 <func0+0x38>\n  cmp    $0x1,%edi\n  je     112b <func0+0x2b>\n  xor    %edx,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\n  imul   %esi,%eax\n  add    $0x1,%edx\n  cmp    %eax,%edi\n  jl     1138 <func0+0x38>\n  cmp    $0x63,%edx\n  jg     1138 <func0+0x38>\n  cmp    %eax,%edi\n  jne    1118 <func0+0x18>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  cmp    $0x1,%edi\n  je     L1\n  xor    %edx,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\nL2:\n  imul   %esi,%eax\n  add    $0x1,%edx\n  cmp    %eax,%edi\n  jl     L0\n  cmp    $0x63,%edx\n  jg     L0\n  cmp    %eax,%edi\n  jne    L2\nL1:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4395
            },
            "L2": {
                "label": "L2",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 76,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int n) {\n    int p = 1, count = 0;\n    while (p <= x && count < 100) {\n        if (p == x) return 1;\n        p = p * n; count += 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1, 4) == 1);\n    assert(func0(2, 2) == 1);\n    assert(func0(8, 2) == 1);\n    assert(func0(3, 2) == 0);\n    assert(func0(3, 1) == 0);\n    assert(func0(5, 3) == 0);\n    assert(func0(16, 2) == 1);\n    assert(func0(143214, 16) == 0);\n    assert(func0(4, 2) == 1);\n    assert(func0(9, 3) == 1);\n    assert(func0(16, 4) == 1);\n    assert(func0(24, 2) == 0);\n    assert(func0(128, 4) == 0);\n    assert(func0(12, 6) == 0);\n    assert(func0(1, 1) == 1);\n    assert(func0(1, 12) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1138 <func0+0x38>\n  cmp    $0x1,%edi\n  je     112b <func0+0x2b>\n  xor    %edx,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\n  imul   %esi,%eax\n  add    $0x1,%edx\n  cmp    %eax,%edi\n  jl     1138 <func0+0x38>\n  cmp    $0x63,%edx\n  jg     1138 <func0+0x38>\n  cmp    %eax,%edi\n  jne    1118 <func0+0x18>\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  cmp    $0x1,%edi\n  je     L1\n  xor    %edx,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\nL2:\n  imul   %esi,%eax\n  add    $0x1,%edx\n  cmp    %eax,%edi\n  jl     L0\n  cmp    $0x63,%edx\n  jg     L0\n  cmp    %eax,%edi\n  jne    L2\nL1:\n  mov    $0x1,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4395
            },
            "L2": {
                "label": "L2",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 77,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1132 <func0+0x39>\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  cmp    %eax,%edx\n  jne    112e <func0+0x35>\n  mov    $0x1,%eax\n  jmp    1151 <func0+0x58>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  cmp    %eax,%edx\n  jle    110d <func0+0x14>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL3:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  cmp    %eax,%edx\n  jne    L1\n  mov    $0x1,%eax\n  jmp    L2\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  cmp    %eax,%edx\n  jle    L3\n  mov    $0x0,%eax\nL2:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4402
            },
            "L1": {
                "label": "L1",
                "addr": 4398
            },
            "L2": {
                "label": "L2",
                "addr": 4433
            },
            "L3": {
                "label": "L3",
                "addr": 4365
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 77,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     112b <func0+0x32>\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  cmp    %eax,%ecx\n  je     1131 <func0+0x38>\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    1112 <func0+0x19>\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     L0\n  mov    $0x1,%edx\n  mov    $0x1,%eax\nL2:\n  cmp    %eax,%ecx\n  je     L1\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    L2\n  mov    $0x0,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret\nL1:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4395
            },
            "L1": {
                "label": "L1",
                "addr": 4401
            },
            "L2": {
                "label": "L2",
                "addr": 4370
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 77,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     1140 <func0+0x40>\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\n  cmp    %eax,%ecx\n  je     1140 <func0+0x40>\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    1120 <func0+0x20>\n  xor    %eax,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     L0\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\nL1:\n  cmp    %eax,%ecx\n  je     L0\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    L1\n  xor    %eax,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 77,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint func0(int a) {\n    for (int i = 0; i * i * i <= abs(a); i++)\n        if (i * i * i == abs(a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 0);\n    assert(func0(-1) == 1);\n    assert(func0(64) == 1);\n    assert(func0(180) == 0);\n    assert(func0(1000) == 1);\n    assert(func0(0) == 1);\n    assert(func0(1729) == 0);\n\n    printf(\"All tests passed.\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     1140 <func0+0x40>\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\n  cmp    %eax,%ecx\n  je     1140 <func0+0x40>\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    1120 <func0+0x20>\n  xor    %eax,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%ecx\n  neg    %ecx\n  cmovs  %edi,%ecx\n  test   %edi,%edi\n  je     L0\n  mov    $0x1,%edx\n  mov    $0x1,%eax\n  nopl   0x0(%rax)\nL1:\n  cmp    %eax,%ecx\n  je     L0\n  add    $0x1,%edx\n  mov    %edx,%eax\n  imul   %edx,%eax\n  imul   %edx,%eax\n  cmp    %ecx,%eax\n  jle    L1\n  xor    %eax,%eax\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 78,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    0xeaf(%rip),%rax        # 2000 <_fini+0xe4c>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1193 <func0+0x5a>\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     118f <func0+0x56>\n  addl   $0x1,-0x20(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     1165 <func0+0x2c>\n  mov    -0x20(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL2:\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\n  addl   $0x1,-0x20(%rbp)\nL1:\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L2\n  mov    -0x20(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3759
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4499
            },
            "L1": {
                "label": "L1",
                "addr": 4495
            },
            "L2": {
                "label": "L2",
                "addr": 4453
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "32333537424400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"2357BD\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 78,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r12\n  call   1060 <strlen@plt>\n  mov    %r12,%rbx\n  add    %rax,%r12\n  mov    $0x0,%ebp\n  lea    0xe9f(%rip),%r13        # 2000 <_fini+0xe74>\n  jmp    1179 <func0+0x40>\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%ebp\n  add    $0x1,%rbx\n  cmp    %r12,%rbx\n  jne    1163 <func0+0x2a>\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r12\n  call   <strlen@plt>\n  mov    %r12,%rbx\n  add    %rax,%r12\n  mov    $0x0,%ebp\n  lea    D0(%rip),%r13\n  jmp    L0\nL1:\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%ebp\n  add    $0x1,%rbx\nL0:\n  cmp    %r12,%rbx\n  jne    L1\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3743
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4473
            },
            "L1": {
                "label": "L1",
                "addr": 4451
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "32333537424400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"2357BD\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 78,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  lea    0xeb3(%rip),%r13        # 2000 <_fini+0xe64>\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  lea    (%rbx,%rax,1),%rbp\n  jmp    1187 <func0+0x47>\n  cs nopw 0x0(%rax,%rax,1)\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %rbp,%rbx\n  jne    1170 <func0+0x30>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  lea    D0(%rip),%r13\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  lea    (%rbx,%rax,1),%rbp\n  jmp    L0\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\nL0:\n  cmp    %rbp,%rbx\n  jne    L1\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3763
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4487
            },
            "L1": {
                "label": "L1",
                "addr": 4464
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "32333537424400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"2357BD\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 78,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char* num) {\n    const char* key = \"2357BD\";\n    int out = 0;\n    for (int i = 0; i < strlen(num); i++) {\n        if (strchr(key, num[i])) out += 1;\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"AB\") == 1);\n    assert(func0(\"1077E\") == 2);\n    assert(func0(\"ABED1A33\") == 4);\n    assert(func0(\"2020\") == 2);\n    assert(func0(\"123456789ABCDEF0\") == 6);\n    assert(func0(\"112233445566778899AABBCCDDEEFF00\") == 12);\n    assert(func0(\"\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  test   %rax,%rax\n  je     11a0 <func0+0x60>\n  lea    (%rbx,%rax,1),%rbp\n  xor    %r12d,%r12d\n  lea    0xe97(%rip),%r13        # 2000 <_fini+0xe4c>\n  nopl   0x0(%rax)\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %rbp,%rbx\n  jne    1170 <func0+0x30>\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  test   %rax,%rax\n  je     L0\n  lea    (%rbx,%rax,1),%rbp\n  xor    %r12d,%r12d\n  lea    D0(%rip),%r13\n  nopl   0x0(%rax)\nL1:\n  movsbl (%rbx),%esi\n  mov    %r13,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmp    %rbp,%rbx\n  jne    L1\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3735
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4512
            },
            "L1": {
                "label": "L1",
                "addr": 4464
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "32333537424400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"2357BD\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 79,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    $0x40,%edi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x10(%rbp)\n  cmpq   $0x0,-0x10(%rbp)\n  jne    11a7 <func0+0x2e>\n  mov    $0x0,%eax\n  jmp    12cd <func0+0x154>\n  movl   $0x3e,-0x1c(%rbp)\n  mov    -0x10(%rbp),%rax\n  add    $0x3f,%rax\n  movb   $0x0,(%rax)\n  cmpl   $0x0,-0x24(%rbp)\n  jne    120e <func0+0x95>\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x30,(%rax)\n  jmp    1214 <func0+0x9b>\n  mov    -0x24(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x24(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x24(%rbp)\n  cmpl   $0x0,-0x24(%rbp)\n  jg     11d7 <func0+0x5e>\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x62,(%rax)\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x64,(%rax)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x18(%rbp)\n  mov    $0x3e,%eax\n  sub    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  add    $0x3,%eax\n  cltq\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    1282 <func0+0x109>\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    $0x0,%eax\n  jmp    12cd <func0+0x154>\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcpy@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movw   $0x6264,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    $0x40,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x10(%rbp)\n  cmpq   $0x0,-0x10(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x3e,-0x1c(%rbp)\n  mov    -0x10(%rbp),%rax\n  add    $0x3f,%rax\n  movb   $0x0,(%rax)\n  cmpl   $0x0,-0x24(%rbp)\n  jne    L2\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x30,(%rax)\n  jmp    L3\nL4:\n  mov    -0x24(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x24(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x24(%rbp)\nL2:\n  cmpl   $0x0,-0x24(%rbp)\n  jg     L4\nL3:\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x62,(%rax)\n  mov    -0x1c(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0x1c(%rbp)\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x64,(%rax)\n  mov    -0x1c(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x18(%rbp)\n  mov    $0x3e,%eax\n  sub    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  add    $0x3,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  jne    L5\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    $0x0,%eax\n  jmp    L1\nL5:\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movw   $0x6264,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4519
            },
            "L1": {
                "label": "L1",
                "addr": 4813
            },
            "L2": {
                "label": "L2",
                "addr": 4622
            },
            "L3": {
                "label": "L3",
                "addr": 4628
            },
            "L4": {
                "label": "L4",
                "addr": 4567
            },
            "L5": {
                "label": "L5",
                "addr": 4738
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 79,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  call   10b0 <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     124a <func0+0xd1>\n  movb   $0x0,0x3f(%rax)\n  test   %ebx,%ebx\n  je     11db <func0+0x62>\n  mov    $0x3d,%edx\n  mov    $0x3e,%esi\n  jle    11e4 <func0+0x6b>\n  mov    %edx,%esi\n  mov    %ebx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  add    $0x30,%eax\n  mov    %al,0x1(%rbp,%rdx,1)\n  mov    %ebx,%ecx\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  sub    $0x1,%rdx\n  cmp    $0x1,%ecx\n  jg     11ad <func0+0x34>\n  jmp    11e4 <func0+0x6b>\n  movb   $0x30,0x3e(%rax)\n  mov    $0x3d,%esi\n  lea    -0x1(%rsi),%eax\n  movslq %esi,%rsi\n  movb   $0x62,0x0(%rbp,%rsi,1)\n  movslq %eax,%r12\n  add    %rbp,%r12\n  movb   $0x64,(%r12)\n  mov    $0x41,%edi\n  sub    %eax,%edi\n  movslq %edi,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%rbx\n  test   %rax,%rax\n  je     1240 <func0+0xc7>\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcpy@plt>\n  mov    %rbx,%rdi\n  call   10a0 <strlen@plt>\n  add    %rbx,%rax\n  movw   $0x6264,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  mov    %rbx,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  jmp    1238 <func0+0xbf>\n  mov    %rax,%rbx\n  jmp    1238 <func0+0xbf>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     L0\n  movb   $0x0,0x3f(%rax)\n  test   %ebx,%ebx\n  je     L1\n  mov    $0x3d,%edx\n  mov    $0x3e,%esi\n  jle    L2\nL3:\n  mov    %edx,%esi\n  mov    %ebx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  add    $0x30,%eax\n  mov    %al,0x1(%rbp,%rdx,1)\n  mov    %ebx,%ecx\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  sub    $0x1,%rdx\n  cmp    $0x1,%ecx\n  jg     L3\n  jmp    L2\nL1:\n  movb   $0x30,0x3e(%rax)\n  mov    $0x3d,%esi\nL2:\n  lea    -0x1(%rsi),%eax\n  movslq %esi,%rsi\n  movb   $0x62,0x0(%rbp,%rsi,1)\n  movslq %eax,%r12\n  add    %rbp,%r12\n  movb   $0x64,(%r12)\n  mov    $0x41,%edi\n  sub    %eax,%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbx\n  test   %rax,%rax\n  je     L4\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  add    %rbx,%rax\n  movw   $0x6264,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    %rbp,%rdi\n  call   <free@plt>\nL5:\n  mov    %rbx,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\nL4:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  jmp    L5\nL0:\n  mov    %rax,%rbx\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4682
            },
            "L1": {
                "label": "L1",
                "addr": 4571
            },
            "L2": {
                "label": "L2",
                "addr": 4580
            },
            "L3": {
                "label": "L3",
                "addr": 4525
            },
            "L4": {
                "label": "L4",
                "addr": 4672
            },
            "L5": {
                "label": "L5",
                "addr": 4664
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 79,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  sub    $0x8,%rsp\n  call   1090 <malloc@plt>\n  test   %rax,%rax\n  je     1245 <func0+0xe5>\n  movb   $0x0,0x3f(%rax)\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jne    11f0 <func0+0x90>\n  movb   $0x30,0x3e(%rax)\n  mov    $0x5,%edi\n  mov    $0x3c,%r13d\n  mov    $0x3d,%eax\n  add    %rbp,%r13\n  movb   $0x62,0x0(%rbp,%rax,1)\n  movb   $0x64,0x0(%r13)\n  call   1090 <malloc@plt>\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     11d3 <func0+0x73>\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   1080 <stpcpy@plt>\n  mov    $0x6264,%edx\n  mov    %dx,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\n  mov    $0x3d,%eax\n  jle    1230 <func0+0xd0>\n  nopw   0x0(%rax,%rax,1)\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rbp,%rax,1)\n  sub    $0x1,%rax\n  sar    %ebx\n  jne    1200 <func0+0xa0>\n  movslq %ecx,%rax\n  mov    $0x41,%edi\n  sub    $0x1,%ecx\n  sub    %ecx,%edi\n  movslq %ecx,%r13\n  movslq %edi,%rdi\n  jmp    11a2 <func0+0x42>\n  xchg   %ax,%ax\n  mov    $0x4,%edi\n  mov    $0x3d,%r13d\n  mov    $0x3e,%eax\n  jmp    11a2 <func0+0x42>\n  xor    %r12d,%r12d\n  jmp    11db <func0+0x7b>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L0\n  movb   $0x0,0x3f(%rax)\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jne    L1\n  movb   $0x30,0x3e(%rax)\n  mov    $0x5,%edi\n  mov    $0x3c,%r13d\n  mov    $0x3d,%eax\nL5:\n  add    %rbp,%r13\n  movb   $0x62,0x0(%rbp,%rax,1)\n  movb   $0x64,0x0(%r13)\n  call   <malloc@plt>\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     L2\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   <stpcpy@plt>\n  mov    $0x6264,%edx\n  mov    %dx,(%rax)\n  movb   $0x0,0x2(%rax)\nL2:\n  mov    %rbp,%rdi\n  call   <free@plt>\nL6:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    $0x3d,%eax\n  jle    L3\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rbp,%rax,1)\n  sub    $0x1,%rax\n  sar    %ebx\n  jne    L4\n  movslq %ecx,%rax\n  mov    $0x41,%edi\n  sub    $0x1,%ecx\n  sub    %ecx,%edi\n  movslq %ecx,%r13\n  movslq %edi,%rdi\n  jmp    L5\n  xchg   %ax,%ax\nL3:\n  mov    $0x4,%edi\n  mov    $0x3d,%r13d\n  mov    $0x3e,%eax\n  jmp    L5\nL0:\n  xor    %r12d,%r12d\n  jmp    L6",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4677
            },
            "L1": {
                "label": "L1",
                "addr": 4592
            },
            "L2": {
                "label": "L2",
                "addr": 4563
            },
            "L3": {
                "label": "L3",
                "addr": 4656
            },
            "L4": {
                "label": "L4",
                "addr": 4608
            },
            "L5": {
                "label": "L5",
                "addr": 4514
            },
            "L6": {
                "label": "L6",
                "addr": 4571
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 79,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(int decimal) {\n    char* out = malloc(64);\n    if (!out) {\n        return NULL;\n    }\n    int index = 62;\n    out[63] = '\\0';\n\n    if (decimal == 0) {\n        out[index--] = '0';\n    } else {\n        while (decimal > 0) {\n            out[index--] = '0' + (decimal % 2);\n            decimal /= 2;\n        }\n    }\n\n    out[index--] = 'b';\n    out[index--] = 'd';\n\n    int start = index + 1;\n    int len = 62 - start;\n    char* formatted_out = malloc(len + 3);\n    if (!formatted_out) {\n        free(out);\n        return NULL;\n    }\n\n    strcpy(formatted_out, &out[start]);\n\n    strcat(formatted_out, \"db\");\n\n    free(out);\n\n    return formatted_out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* binary;\n\n    binary = func0(0);\n    assert(strcmp(binary, \"db0db\") == 0);\n    free(binary);\n\n    binary = func0(32);\n    assert(strcmp(binary, \"db100000db\") == 0);\n    free(binary);\n\n    binary = func0(103);\n    assert(strcmp(binary, \"db1100111db\") == 0);\n    free(binary);\n\n    binary = func0(15);\n    assert(strcmp(binary, \"db1111db\") == 0);\n    free(binary);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  sub    $0x8,%rsp\n  call   1090 <malloc@plt>\n  test   %rax,%rax\n  je     1245 <func0+0xe5>\n  movb   $0x0,0x3f(%rax)\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jne    11f0 <func0+0x90>\n  movb   $0x30,0x3e(%rax)\n  mov    $0x5,%edi\n  mov    $0x3c,%r13d\n  mov    $0x3d,%eax\n  add    %rbp,%r13\n  movb   $0x62,0x0(%rbp,%rax,1)\n  movb   $0x64,0x0(%r13)\n  call   1090 <malloc@plt>\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     11d3 <func0+0x73>\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   1080 <stpcpy@plt>\n  mov    $0x6264,%edx\n  mov    %dx,(%rax)\n  movb   $0x0,0x2(%rax)\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\n  mov    $0x3d,%eax\n  jle    1230 <func0+0xd0>\n  nopw   0x0(%rax,%rax,1)\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rbp,%rax,1)\n  sub    $0x1,%rax\n  sar    %ebx\n  jne    1200 <func0+0xa0>\n  movslq %ecx,%rax\n  mov    $0x41,%edi\n  sub    $0x1,%ecx\n  sub    %ecx,%edi\n  movslq %ecx,%r13\n  movslq %edi,%rdi\n  jmp    11a2 <func0+0x42>\n  xchg   %ax,%ax\n  mov    $0x4,%edi\n  mov    $0x3d,%r13d\n  mov    $0x3e,%eax\n  jmp    11a2 <func0+0x42>\n  xor    %r12d,%r12d\n  jmp    11db <func0+0x7b>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x40,%edi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  test   %rax,%rax\n  je     L0\n  movb   $0x0,0x3f(%rax)\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jne    L1\n  movb   $0x30,0x3e(%rax)\n  mov    $0x5,%edi\n  mov    $0x3c,%r13d\n  mov    $0x3d,%eax\nL5:\n  add    %rbp,%r13\n  movb   $0x62,0x0(%rbp,%rax,1)\n  movb   $0x64,0x0(%r13)\n  call   <malloc@plt>\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     L2\n  mov    %r13,%rsi\n  mov    %rax,%rdi\n  call   <stpcpy@plt>\n  mov    $0x6264,%edx\n  mov    %dx,(%rax)\n  movb   $0x0,0x2(%rax)\nL2:\n  mov    %rbp,%rdi\n  call   <free@plt>\nL6:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    $0x3d,%eax\n  jle    L3\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rbp,%rax,1)\n  sub    $0x1,%rax\n  sar    %ebx\n  jne    L4\n  movslq %ecx,%rax\n  mov    $0x41,%edi\n  sub    $0x1,%ecx\n  sub    %ecx,%edi\n  movslq %ecx,%r13\n  movslq %edi,%rdi\n  jmp    L5\n  xchg   %ax,%ax\nL3:\n  mov    $0x4,%edi\n  mov    $0x3d,%r13d\n  mov    $0x3e,%eax\n  jmp    L5\nL0:\n  xor    %r12d,%r12d\n  jmp    L6",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4677
            },
            "L1": {
                "label": "L1",
                "addr": 4592
            },
            "L2": {
                "label": "L2",
                "addr": 4563
            },
            "L3": {
                "label": "L3",
                "addr": 4656
            },
            "L4": {
                "label": "L4",
                "addr": 4608
            },
            "L5": {
                "label": "L5",
                "addr": 4514
            },
            "L6": {
                "label": "L6",
                "addr": 4571
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 80,
        "type": "O0",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  cmp    $0x2,%rax\n  ja     1143 <func0+0x2a>\n  mov    $0x0,%eax\n  jmp    11c1 <func0+0xa8>\n  movl   $0x2,-0x14(%rbp)\n  jmp    11a5 <func0+0x8c>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     119a <func0+0x81>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x2(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    11a1 <func0+0x88>\n  mov    $0x0,%eax\n  jmp    11c1 <func0+0xa8>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     114c <func0+0x33>\n  mov    $0x1,%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    $0x2,%rax\n  ja     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x2,-0x14(%rbp)\n  jmp    L2\nL5:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     L3\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x2(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    L4\nL3:\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  addl   $0x1,-0x14(%rbp)\nL2:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L5\n  mov    $0x1,%eax\nL1:\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4419
            },
            "L1": {
                "label": "L1",
                "addr": 4545
            },
            "L2": {
                "label": "L2",
                "addr": 4517
            },
            "L3": {
                "label": "L3",
                "addr": 4506
            },
            "L4": {
                "label": "L4",
                "addr": 4513
            },
            "L5": {
                "label": "L5",
                "addr": 4428
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 80,
        "type": "O1",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    $0x0,%edx\n  cmp    $0x2,%rax\n  jbe    115b <func0+0x42>\n  mov    %rbx,%rdx\n  lea    -0x2(%rbx,%rax,1),%rcx\n  movzbl 0x2(%rdx),%eax\n  cmp    0x1(%rdx),%al\n  je     1156 <func0+0x3d>\n  cmp    (%rdx),%al\n  je     115f <func0+0x46>\n  add    $0x1,%rdx\n  cmp    %rcx,%rdx\n  jne    1139 <func0+0x20>\n  mov    $0x1,%edx\n  jmp    115b <func0+0x42>\n  mov    $0x0,%edx\n  mov    %edx,%eax\n  pop    %rbx\n  ret\n  mov    $0x0,%edx\n  jmp    115b <func0+0x42>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    $0x0,%edx\n  cmp    $0x2,%rax\n  jbe    L0\n  mov    %rbx,%rdx\n  lea    -0x2(%rbx,%rax,1),%rcx\nL3:\n  movzbl 0x2(%rdx),%eax\n  cmp    0x1(%rdx),%al\n  je     L1\n  cmp    (%rdx),%al\n  je     L2\n  add    $0x1,%rdx\n  cmp    %rcx,%rdx\n  jne    L3\n  mov    $0x1,%edx\n  jmp    L0\nL1:\n  mov    $0x0,%edx\nL0:\n  mov    %edx,%eax\n  pop    %rbx\n  ret\nL2:\n  mov    $0x0,%edx\n  jmp    L0",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4443
            },
            "L1": {
                "label": "L1",
                "addr": 4438
            },
            "L2": {
                "label": "L2",
                "addr": 4447
            },
            "L3": {
                "label": "L3",
                "addr": 4409
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 80,
        "type": "O2",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x2,%rax\n  jbe    1159 <func0+0x39>\n  mov    %rbx,%rdi\n  lea    -0x2(%rbx,%rax,1),%rdx\n  jmp    114d <func0+0x2d>\n  cmp    (%rdi),%al\n  je     1156 <func0+0x36>\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  je     1160 <func0+0x40>\n  movzbl 0x2(%rdi),%eax\n  cmp    0x1(%rdi),%al\n  jne    1140 <func0+0x20>\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  ret\n  xchg   %ax,%ax\n  mov    $0x1,%r8d\n  pop    %rbx\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x2,%rax\n  jbe    L0\n  mov    %rbx,%rdi\n  lea    -0x2(%rbx,%rax,1),%rdx\n  jmp    L1\nL4:\n  cmp    (%rdi),%al\n  je     L2\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  je     L3\nL1:\n  movzbl 0x2(%rdi),%eax\n  cmp    0x1(%rdi),%al\n  jne    L4\nL2:\n  xor    %r8d,%r8d\nL0:\n  mov    %r8d,%eax\n  pop    %rbx\n  ret\n  xchg   %ax,%ax\nL3:\n  mov    $0x1,%r8d\n  pop    %rbx\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4441
            },
            "L1": {
                "label": "L1",
                "addr": 4429
            },
            "L2": {
                "label": "L2",
                "addr": 4438
            },
            "L3": {
                "label": "L3",
                "addr": 4448
            },
            "L4": {
                "label": "L4",
                "addr": 4416
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 80,
        "type": "O3",
        "c_func": "#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* s) {\n    if (strlen(s) < 3) return false;\n    for (int i = 2; i < strlen(s); i++)\n        if (s[i] == s[i-1] || s[i] == s[i-2]) return false;\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"a\") == false);\n    assert(func0(\"aa\") == false);\n    assert(func0(\"abcd\") == true);\n    assert(func0(\"aabb\") == false);\n    assert(func0(\"adb\") == true);\n    assert(func0(\"xyy\") == false);\n    assert(func0(\"iopaxpoi\") == true);\n    assert(func0(\"iopaxioi\") == false);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x2,%rax\n  jbe    1159 <func0+0x39>\n  mov    %rbx,%rdi\n  lea    -0x2(%rbx,%rax,1),%rdx\n  jmp    114d <func0+0x2d>\n  cmp    (%rdi),%al\n  je     1156 <func0+0x36>\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  je     1160 <func0+0x40>\n  movzbl 0x2(%rdi),%eax\n  cmp    0x1(%rdi),%al\n  jne    1140 <func0+0x20>\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  ret\n  xchg   %ax,%ax\n  mov    $0x1,%r8d\n  pop    %rbx\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x2,%rax\n  jbe    L0\n  mov    %rbx,%rdi\n  lea    -0x2(%rbx,%rax,1),%rdx\n  jmp    L1\nL4:\n  cmp    (%rdi),%al\n  je     L2\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  je     L3\nL1:\n  movzbl 0x2(%rdi),%eax\n  cmp    0x1(%rdi),%al\n  jne    L4\nL2:\n  xor    %r8d,%r8d\nL0:\n  mov    %r8d,%eax\n  pop    %rbx\n  ret\n  xchg   %ax,%ax\nL3:\n  mov    $0x1,%r8d\n  pop    %rbx\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4441
            },
            "L1": {
                "label": "L1",
                "addr": 4429
            },
            "L2": {
                "label": "L2",
                "addr": 4438
            },
            "L3": {
                "label": "L3",
                "addr": 4448
            },
            "L4": {
                "label": "L4",
                "addr": 4416
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 81,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    14d5 <func0+0x3bc>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xeb7(%rip),%xmm0        # 2028 <_fini+0xb40>\n  jb     1196 <func0+0x7d>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xe72(%rip),%rdx        # 2000 <_fini+0xb18>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xe76(%rip),%xmm0        # 2030 <_fini+0xb48>\n  jbe    11df <func0+0xc6>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xe2c(%rip),%rdx        # 2003 <_fini+0xb1b>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xe35(%rip),%xmm0        # 2038 <_fini+0xb50>\n  jbe    1228 <func0+0x10f>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xde5(%rip),%rdx        # 2005 <_fini+0xb1d>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xdf4(%rip),%xmm0        # 2040 <_fini+0xb58>\n  jbe    1271 <func0+0x158>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xd9f(%rip),%rdx        # 2008 <_fini+0xb20>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xdb3(%rip),%xmm0        # 2048 <_fini+0xb60>\n  jbe    12ba <func0+0x1a1>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xd59(%rip),%rdx        # 200b <_fini+0xb23>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xd72(%rip),%xmm0        # 2050 <_fini+0xb68>\n  jbe    1303 <func0+0x1ea>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xd12(%rip),%rdx        # 200d <_fini+0xb25>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xd31(%rip),%xmm0        # 2058 <_fini+0xb70>\n  jbe    134c <func0+0x233>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xccc(%rip),%rdx        # 2010 <_fini+0xb28>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xcf0(%rip),%xmm0        # 2060 <_fini+0xb78>\n  jbe    1395 <func0+0x27c>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xc86(%rip),%rdx        # 2013 <_fini+0xb2b>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xcaf(%rip),%xmm0        # 2068 <_fini+0xb80>\n  jbe    13de <func0+0x2c5>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xc3f(%rip),%rdx        # 2015 <_fini+0xb2d>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xc6e(%rip),%xmm0        # 2070 <_fini+0xb88>\n  jbe    1427 <func0+0x30e>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xbf9(%rip),%rdx        # 2018 <_fini+0xb30>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xc2d(%rip),%xmm0        # 2078 <_fini+0xb90>\n  jbe    146d <func0+0x354>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xbb3(%rip),%rdx        # 201b <_fini+0xb33>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd 0xbef(%rip),%xmm0        # 2080 <_fini+0xb98>\n  jbe    14b3 <func0+0x39a>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xb6f(%rip),%rdx        # 201d <_fini+0xb35>\n  mov    %rdx,(%rax)\n  jmp    14d1 <func0+0x3b8>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    0xb52(%rip),%rdx        # 2020 <_fini+0xb38>\n  mov    %rdx,(%rax)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     114d <func0+0x34>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL14:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D0(%rip),%xmm0\n  jb     L1\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL1:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D2(%rip),%xmm0\n  jbe    L3\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D3(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL3:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D4(%rip),%xmm0\n  jbe    L4\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D5(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL4:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D6(%rip),%xmm0\n  jbe    L5\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D7(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL5:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D8(%rip),%xmm0\n  jbe    L6\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D9(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL6:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D10(%rip),%xmm0\n  jbe    L7\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D11(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL7:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D12(%rip),%xmm0\n  jbe    L8\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D13(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL8:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D14(%rip),%xmm0\n  jbe    L9\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D15(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL9:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D16(%rip),%xmm0\n  jbe    L10\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D17(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL10:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D18(%rip),%xmm0\n  jbe    L11\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D19(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL11:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D20(%rip),%xmm0\n  jbe    L12\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D21(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL12:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd D22(%rip),%xmm0\n  jbe    L13\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D23(%rip),%rdx\n  mov    %rdx,(%rax)\n  jmp    L2\nL13:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  lea    D24(%rip),%rdx\n  mov    %rdx,(%rax)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L14\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8232,
                "bias": [
                    3767
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3698
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8240,
                "bias": [
                    3702
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8195,
                "bias": [
                    3628
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8248,
                "bias": [
                    3637
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8197,
                "bias": [
                    3557
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8256,
                "bias": [
                    3572
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8200,
                "bias": [
                    3487
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8264,
                "bias": [
                    3507
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8203,
                "bias": [
                    3417
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 8272,
                "bias": [
                    3442
                ]
            },
            "D11": {
                "label": "D11",
                "addr": 8205,
                "bias": [
                    3346
                ]
            },
            "D12": {
                "label": "D12",
                "addr": 8280,
                "bias": [
                    3377
                ]
            },
            "D13": {
                "label": "D13",
                "addr": 8208,
                "bias": [
                    3276
                ]
            },
            "D14": {
                "label": "D14",
                "addr": 8288,
                "bias": [
                    3312
                ]
            },
            "D15": {
                "label": "D15",
                "addr": 8211,
                "bias": [
                    3206
                ]
            },
            "D16": {
                "label": "D16",
                "addr": 8296,
                "bias": [
                    3247
                ]
            },
            "D17": {
                "label": "D17",
                "addr": 8213,
                "bias": [
                    3135
                ]
            },
            "D18": {
                "label": "D18",
                "addr": 8304,
                "bias": [
                    3182
                ]
            },
            "D19": {
                "label": "D19",
                "addr": 8216,
                "bias": [
                    3065
                ]
            },
            "D20": {
                "label": "D20",
                "addr": 8312,
                "bias": [
                    3117
                ]
            },
            "D21": {
                "label": "D21",
                "addr": 8219,
                "bias": [
                    2995
                ]
            },
            "D22": {
                "label": "D22",
                "addr": 8320,
                "bias": [
                    3055
                ]
            },
            "D23": {
                "label": "D23",
                "addr": 8221,
                "bias": [
                    2927
                ]
            },
            "D24": {
                "label": "D24",
                "addr": 8224,
                "bias": [
                    2898
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5333
            },
            "L1": {
                "label": "L1",
                "addr": 4502
            },
            "L2": {
                "label": "L2",
                "addr": 5329
            },
            "L3": {
                "label": "L3",
                "addr": 4575
            },
            "L4": {
                "label": "L4",
                "addr": 4648
            },
            "L5": {
                "label": "L5",
                "addr": 4721
            },
            "L6": {
                "label": "L6",
                "addr": 4794
            },
            "L7": {
                "label": "L7",
                "addr": 4867
            },
            "L8": {
                "label": "L8",
                "addr": 4940
            },
            "L9": {
                "label": "L9",
                "addr": 5013
            },
            "L10": {
                "label": "L10",
                "addr": 5086
            },
            "L11": {
                "label": "L11",
                "addr": 5159
            },
            "L12": {
                "label": "L12",
                "addr": 5229
            },
            "L13": {
                "label": "L13",
                "addr": 5299
            },
            "L14": {
                "label": "L14",
                "addr": 4429
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "412b004100412d00422b004200422d00432b004300432d00442b004400442d004500000000000000c7293a92cbff0f40d26f5f07ce990d409f3c2cd49a660a4039d6c56d34000840d26f5f07ce9905409f3c2cd49a66024039d6c56d34000040a4dfbe0e9c33fb3f3e7958a835cdf43f71ac8bdb6800f03f48bf7d1d3867e63f2d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2028": {
                    "type": "f64[2]",
                    "value": [
                        3.9999,
                        3.7001
                    ]
                },
                "0x2030": {
                    "type": "f64[2]",
                    "value": [
                        3.7001,
                        3.3001
                    ]
                },
                "0x2038": {
                    "type": "f64[2]",
                    "value": [
                        3.3001,
                        3.0001
                    ]
                },
                "0x2040": {
                    "type": "f64[2]",
                    "value": [
                        3.0001,
                        2.7001
                    ]
                },
                "0x2048": {
                    "type": "f64[2]",
                    "value": [
                        2.7001,
                        2.3001
                    ]
                },
                "0x2050": {
                    "type": "f64[2]",
                    "value": [
                        2.3001,
                        2.0001
                    ]
                },
                "0x2058": {
                    "type": "f64[2]",
                    "value": [
                        2.0001,
                        1.7001
                    ]
                },
                "0x2060": {
                    "type": "f64[2]",
                    "value": [
                        1.7001,
                        1.3001
                    ]
                },
                "0x2068": {
                    "type": "f64[2]",
                    "value": [
                        1.3001,
                        1.0001
                    ]
                },
                "0x2070": {
                    "type": "f64[2]",
                    "value": [
                        1.0001,
                        0.7001
                    ]
                },
                "0x2078": {
                    "type": "f64[2]",
                    "value": [
                        0.7001,
                        0.0001
                    ]
                },
                "0x2080": {
                    "type": "f64",
                    "value": 0.0001
                },
                "0x2000": {
                    "type": "string",
                    "value": "\"A+\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"A\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"A-\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"B+\""
                },
                "0x200b": {
                    "type": "string",
                    "value": "\"B\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"B-\""
                },
                "0x2010": {
                    "type": "string",
                    "value": "\"C+\""
                },
                "0x2013": {
                    "type": "string",
                    "value": "\"C\""
                },
                "0x2015": {
                    "type": "string",
                    "value": "\"C-\""
                },
                "0x2018": {
                    "type": "string",
                    "value": "\"D+\""
                },
                "0x201b": {
                    "type": "string",
                    "value": "\"D\""
                },
                "0x201d": {
                    "type": "string",
                    "value": "\"D-\""
                },
                "0x2020": {
                    "type": "string",
                    "value": "\"E\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 81,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %esi,%ebp\n  movslq %esi,%rdi\n  shl    $0x3,%rdi\n  call   1050 <malloc@plt>\n  test   %ebp,%ebp\n  jle    1296 <func0+0x17d>\n  mov    %rbx,%rcx\n  mov    %rax,%rdx\n  mov    %ebp,%ebp\n  lea    (%rax,%rbp,8),%rsi\n  movsd  0xed8(%rip),%xmm1        # 2028 <_fini+0xd88>\n  movsd  0xed8(%rip),%xmm2        # 2030 <_fini+0xd90>\n  movsd  0xed8(%rip),%xmm3        # 2038 <_fini+0xd98>\n  jmp    1183 <func0+0x6a>\n  comisd %xmm2,%xmm0\n  jbe    119d <func0+0x84>\n  lea    0xe94(%rip),%rdi        # 2003 <_fini+0xd63>\n  mov    %rdi,(%rdx)\n  add    $0x4,%rcx\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  je     1296 <func0+0x17d>\n  pxor   %xmm0,%xmm0\n  cvtss2sd (%rcx),%xmm0\n  comisd %xmm1,%xmm0\n  jb     1162 <func0+0x49>\n  lea    0xe68(%rip),%rbx        # 2000 <_fini+0xd60>\n  mov    %rbx,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd %xmm3,%xmm0\n  jbe    11af <func0+0x96>\n  lea    0xe5b(%rip),%rbx        # 2005 <_fini+0xd65>\n  mov    %rbx,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe89(%rip),%xmm0        # 2040 <_fini+0xda0>\n  jbe    11c5 <func0+0xac>\n  lea    0xe48(%rip),%rbx        # 2008 <_fini+0xd68>\n  mov    %rbx,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe7b(%rip),%xmm0        # 2048 <_fini+0xda8>\n  jbe    11db <func0+0xc2>\n  lea    0xe35(%rip),%rdi        # 200b <_fini+0xd6b>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe6d(%rip),%xmm0        # 2050 <_fini+0xdb0>\n  jbe    11f1 <func0+0xd8>\n  lea    0xe21(%rip),%rdi        # 200d <_fini+0xd6d>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe5f(%rip),%xmm0        # 2058 <_fini+0xdb8>\n  jbe    120a <func0+0xf1>\n  lea    0xe0e(%rip),%rdi        # 2010 <_fini+0xd70>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe4e(%rip),%xmm0        # 2060 <_fini+0xdc0>\n  jbe    1223 <func0+0x10a>\n  lea    0xdf8(%rip),%rdi        # 2013 <_fini+0xd73>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe3d(%rip),%xmm0        # 2068 <_fini+0xdc8>\n  jbe    123c <func0+0x123>\n  lea    0xde1(%rip),%rdi        # 2015 <_fini+0xd75>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe2c(%rip),%xmm0        # 2070 <_fini+0xdd0>\n  jbe    1255 <func0+0x13c>\n  lea    0xdcb(%rip),%rdi        # 2018 <_fini+0xd78>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe1b(%rip),%xmm0        # 2078 <_fini+0xdd8>\n  jbe    126e <func0+0x155>\n  lea    0xdb5(%rip),%rdi        # 201b <_fini+0xd7b>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  comisd 0xe0a(%rip),%xmm0        # 2080 <_fini+0xde0>\n  jbe    1287 <func0+0x16e>\n  lea    0xd9e(%rip),%rbx        # 201d <_fini+0xd7d>\n  mov    %rbx,(%rdx)\n  jmp    1172 <func0+0x59>\n  lea    0xd92(%rip),%rdi        # 2020 <_fini+0xd80>\n  mov    %rdi,(%rdx)\n  jmp    1172 <func0+0x59>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %esi,%ebp\n  movslq %esi,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  test   %ebp,%ebp\n  jle    L0\n  mov    %rbx,%rcx\n  mov    %rax,%rdx\n  mov    %ebp,%ebp\n  lea    (%rax,%rbp,8),%rsi\n  movsd  D0(%rip),%xmm1\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  jmp    L1\nL3:\n  comisd %xmm2,%xmm0\n  jbe    L2\n  lea    D3(%rip),%rdi\n  mov    %rdi,(%rdx)\nL4:\n  add    $0x4,%rcx\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  je     L0\nL1:\n  pxor   %xmm0,%xmm0\n  cvtss2sd (%rcx),%xmm0\n  comisd %xmm1,%xmm0\n  jb     L3\n  lea    D4(%rip),%rbx\n  mov    %rbx,(%rdx)\n  jmp    L4\nL2:\n  comisd %xmm3,%xmm0\n  jbe    L5\n  lea    D5(%rip),%rbx\n  mov    %rbx,(%rdx)\n  jmp    L4\nL5:\n  comisd D6(%rip),%xmm0\n  jbe    L6\n  lea    D7(%rip),%rbx\n  mov    %rbx,(%rdx)\n  jmp    L4\nL6:\n  comisd D8(%rip),%xmm0\n  jbe    L7\n  lea    D9(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL7:\n  comisd D10(%rip),%xmm0\n  jbe    L8\n  lea    D11(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL8:\n  comisd D12(%rip),%xmm0\n  jbe    L9\n  lea    D13(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL9:\n  comisd D14(%rip),%xmm0\n  jbe    L10\n  lea    D15(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL10:\n  comisd D16(%rip),%xmm0\n  jbe    L11\n  lea    D17(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL11:\n  comisd D18(%rip),%xmm0\n  jbe    L12\n  lea    D19(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL12:\n  comisd D20(%rip),%xmm0\n  jbe    L13\n  lea    D21(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL13:\n  comisd D22(%rip),%xmm0\n  jbe    L14\n  lea    D23(%rip),%rbx\n  mov    %rbx,(%rdx)\n  jmp    L4\nL14:\n  lea    D24(%rip),%rdi\n  mov    %rdi,(%rdx)\n  jmp    L4\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8232,
                "bias": [
                    3800
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8240,
                "bias": [
                    3800
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8248,
                "bias": [
                    3800
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8195,
                "bias": [
                    3732
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8192,
                "bias": [
                    3688
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8197,
                "bias": [
                    3675
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8256,
                "bias": [
                    3721
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8200,
                "bias": [
                    3656
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8264,
                "bias": [
                    3707
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8203,
                "bias": [
                    3637
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 8272,
                "bias": [
                    3693
                ]
            },
            "D11": {
                "label": "D11",
                "addr": 8205,
                "bias": [
                    3617
                ]
            },
            "D12": {
                "label": "D12",
                "addr": 8280,
                "bias": [
                    3679
                ]
            },
            "D13": {
                "label": "D13",
                "addr": 8208,
                "bias": [
                    3598
                ]
            },
            "D14": {
                "label": "D14",
                "addr": 8288,
                "bias": [
                    3662
                ]
            },
            "D15": {
                "label": "D15",
                "addr": 8211,
                "bias": [
                    3576
                ]
            },
            "D16": {
                "label": "D16",
                "addr": 8296,
                "bias": [
                    3645
                ]
            },
            "D17": {
                "label": "D17",
                "addr": 8213,
                "bias": [
                    3553
                ]
            },
            "D18": {
                "label": "D18",
                "addr": 8304,
                "bias": [
                    3628
                ]
            },
            "D19": {
                "label": "D19",
                "addr": 8216,
                "bias": [
                    3531
                ]
            },
            "D20": {
                "label": "D20",
                "addr": 8312,
                "bias": [
                    3611
                ]
            },
            "D21": {
                "label": "D21",
                "addr": 8219,
                "bias": [
                    3509
                ]
            },
            "D22": {
                "label": "D22",
                "addr": 8320,
                "bias": [
                    3594
                ]
            },
            "D23": {
                "label": "D23",
                "addr": 8221,
                "bias": [
                    3486
                ]
            },
            "D24": {
                "label": "D24",
                "addr": 8224,
                "bias": [
                    3474
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4758
            },
            "L1": {
                "label": "L1",
                "addr": 4483
            },
            "L2": {
                "label": "L2",
                "addr": 4509
            },
            "L3": {
                "label": "L3",
                "addr": 4450
            },
            "L4": {
                "label": "L4",
                "addr": 4466
            },
            "L5": {
                "label": "L5",
                "addr": 4527
            },
            "L6": {
                "label": "L6",
                "addr": 4549
            },
            "L7": {
                "label": "L7",
                "addr": 4571
            },
            "L8": {
                "label": "L8",
                "addr": 4593
            },
            "L9": {
                "label": "L9",
                "addr": 4618
            },
            "L10": {
                "label": "L10",
                "addr": 4643
            },
            "L11": {
                "label": "L11",
                "addr": 4668
            },
            "L12": {
                "label": "L12",
                "addr": 4693
            },
            "L13": {
                "label": "L13",
                "addr": 4718
            },
            "L14": {
                "label": "L14",
                "addr": 4743
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "412b004100412d00422b004200422d00432b004300432d00442b004400442d004500000000000000c7293a92cbff0f40d26f5f07ce990d409f3c2cd49a660a4039d6c56d34000840d26f5f07ce9905409f3c2cd49a66024039d6c56d34000040a4dfbe0e9c33fb3f3e7958a835cdf43f71ac8bdb6800f03f48bf7d1d3867e63f2d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2028": {
                    "type": "f64",
                    "value": 3.9999
                },
                "0x2030": {
                    "type": "f64",
                    "value": 3.7001
                },
                "0x2038": {
                    "type": "f64",
                    "value": 3.3001
                },
                "0x2040": {
                    "type": "f64[2]",
                    "value": [
                        3.0001,
                        2.7001
                    ]
                },
                "0x2048": {
                    "type": "f64[2]",
                    "value": [
                        2.7001,
                        2.3001
                    ]
                },
                "0x2050": {
                    "type": "f64[2]",
                    "value": [
                        2.3001,
                        2.0001
                    ]
                },
                "0x2058": {
                    "type": "f64[2]",
                    "value": [
                        2.0001,
                        1.7001
                    ]
                },
                "0x2060": {
                    "type": "f64[2]",
                    "value": [
                        1.7001,
                        1.3001
                    ]
                },
                "0x2068": {
                    "type": "f64[2]",
                    "value": [
                        1.3001,
                        1.0001
                    ]
                },
                "0x2070": {
                    "type": "f64[2]",
                    "value": [
                        1.0001,
                        0.7001
                    ]
                },
                "0x2078": {
                    "type": "f64[2]",
                    "value": [
                        0.7001,
                        0.0001
                    ]
                },
                "0x2080": {
                    "type": "f64",
                    "value": 0.0001
                },
                "0x2000": {
                    "type": "string",
                    "value": "\"A+\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"A\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"A-\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"B+\""
                },
                "0x200b": {
                    "type": "string",
                    "value": "\"B\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"B-\""
                },
                "0x2010": {
                    "type": "string",
                    "value": "\"C+\""
                },
                "0x2013": {
                    "type": "string",
                    "value": "\"C\""
                },
                "0x2015": {
                    "type": "string",
                    "value": "\"C-\""
                },
                "0x2018": {
                    "type": "string",
                    "value": "\"D+\""
                },
                "0x201b": {
                    "type": "string",
                    "value": "\"D\""
                },
                "0x201d": {
                    "type": "string",
                    "value": "\"D-\""
                },
                "0x2020": {
                    "type": "string",
                    "value": "\"E\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 81,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  call   1050 <malloc@plt>\n  movsd  0xee5(%rip),%xmm1        # 2028 <_fini+0xdc8>\n  test   %ebp,%ebp\n  jle    11cd <func0+0xad>\n  xor    %edx,%edx\n  movsd  0xedb(%rip),%xmm2        # 2030 <_fini+0xdd0>\n  movsd  0xedb(%rip),%xmm3        # 2038 <_fini+0xdd8>\n  lea    0xe9c(%rip),%rsi        # 2000 <_fini+0xda0>\n  lea    0xe98(%rip),%rdi        # 2003 <_fini+0xda3>\n  lea    0xe93(%rip),%r8        # 2005 <_fini+0xda5>\n  lea    0xe8f(%rip),%r9        # 2008 <_fini+0xda8>\n  lea    0xe8b(%rip),%r10        # 200b <_fini+0xdab>\n  pxor   %xmm0,%xmm0\n  mov    %rsi,%rcx\n  cvtss2sd (%rbx,%rdx,4),%xmm0\n  comisd %xmm1,%xmm0\n  jae    11c0 <func0+0xa0>\n  comisd %xmm2,%xmm0\n  mov    %rdi,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd %xmm3,%xmm0\n  mov    %r8,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd 0xe94(%rip),%xmm0        # 2040 <_fini+0xde0>\n  mov    %r9,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd 0xe8f(%rip),%xmm0        # 2048 <_fini+0xde8>\n  mov    %r10,%rcx\n  jbe    11d8 <func0+0xb8>\n  xchg   %ax,%ax\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rbp,%rdx\n  jne    1180 <func0+0x60>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  comisd 0xe70(%rip),%xmm0        # 2050 <_fini+0xdf0>\n  lea    0xe26(%rip),%rcx        # 200d <_fini+0xdad>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe67(%rip),%xmm0        # 2058 <_fini+0xdf8>\n  lea    0xe18(%rip),%rcx        # 2010 <_fini+0xdb0>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe5e(%rip),%xmm0        # 2060 <_fini+0xe00>\n  lea    0xe0a(%rip),%rcx        # 2013 <_fini+0xdb3>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe55(%rip),%xmm0        # 2068 <_fini+0xe08>\n  lea    0xdfb(%rip),%rcx        # 2015 <_fini+0xdb5>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe4c(%rip),%xmm0        # 2070 <_fini+0xe10>\n  lea    0xded(%rip),%rcx        # 2018 <_fini+0xdb8>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe43(%rip),%xmm0        # 2078 <_fini+0xe18>\n  lea    0xddf(%rip),%rcx        # 201b <_fini+0xdbb>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe3a(%rip),%xmm0        # 2080 <_fini+0xe20>\n  lea    0xdd0(%rip),%rcx        # 201d <_fini+0xdbd>\n  lea    0xdcc(%rip),%r11        # 2020 <_fini+0xdc0>\n  cmovbe %r11,%rcx\n  jmp    11c0 <func0+0xa0>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  call   <malloc@plt>\n  movsd  D0(%rip),%xmm1\n  test   %ebp,%ebp\n  jle    L0\n  xor    %edx,%edx\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  lea    D3(%rip),%rsi\n  lea    D4(%rip),%rdi\n  lea    D5(%rip),%r8\n  lea    D6(%rip),%r9\n  lea    D7(%rip),%r10\nL3:\n  pxor   %xmm0,%xmm0\n  mov    %rsi,%rcx\n  cvtss2sd (%rbx,%rdx,4),%xmm0\n  comisd %xmm1,%xmm0\n  jae    L1\n  comisd %xmm2,%xmm0\n  mov    %rdi,%rcx\n  ja     L1\n  comisd %xmm3,%xmm0\n  mov    %r8,%rcx\n  ja     L1\n  comisd D8(%rip),%xmm0\n  mov    %r9,%rcx\n  ja     L1\n  comisd D9(%rip),%xmm0\n  mov    %r10,%rcx\n  jbe    L2\n  xchg   %ax,%ax\nL1:\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rbp,%rdx\n  jne    L3\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  comisd D10(%rip),%xmm0\n  lea    D11(%rip),%rcx\n  ja     L1\n  comisd D12(%rip),%xmm0\n  lea    D13(%rip),%rcx\n  ja     L1\n  comisd D14(%rip),%xmm0\n  lea    D15(%rip),%rcx\n  ja     L1\n  comisd D16(%rip),%xmm0\n  lea    D17(%rip),%rcx\n  ja     L1\n  comisd D18(%rip),%xmm0\n  lea    D19(%rip),%rcx\n  ja     L1\n  comisd D20(%rip),%xmm0\n  lea    D21(%rip),%rcx\n  ja     L1\n  comisd D22(%rip),%xmm0\n  lea    D23(%rip),%rcx\n  lea    D24(%rip),%r11\n  cmovbe %r11,%rcx\n  jmp    L1",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8232,
                "bias": [
                    3813
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8240,
                "bias": [
                    3803
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8248,
                "bias": [
                    3803
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8192,
                "bias": [
                    3740
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8195,
                "bias": [
                    3736
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8197,
                "bias": [
                    3731
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8200,
                "bias": [
                    3727
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8203,
                "bias": [
                    3723
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8256,
                "bias": [
                    3732
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8264,
                "bias": [
                    3727
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 8272,
                "bias": [
                    3696
                ]
            },
            "D11": {
                "label": "D11",
                "addr": 8205,
                "bias": [
                    3622
                ]
            },
            "D12": {
                "label": "D12",
                "addr": 8280,
                "bias": [
                    3687
                ]
            },
            "D13": {
                "label": "D13",
                "addr": 8208,
                "bias": [
                    3608
                ]
            },
            "D14": {
                "label": "D14",
                "addr": 8288,
                "bias": [
                    3678
                ]
            },
            "D15": {
                "label": "D15",
                "addr": 8211,
                "bias": [
                    3594
                ]
            },
            "D16": {
                "label": "D16",
                "addr": 8296,
                "bias": [
                    3669
                ]
            },
            "D17": {
                "label": "D17",
                "addr": 8213,
                "bias": [
                    3579
                ]
            },
            "D18": {
                "label": "D18",
                "addr": 8304,
                "bias": [
                    3660
                ]
            },
            "D19": {
                "label": "D19",
                "addr": 8216,
                "bias": [
                    3565
                ]
            },
            "D20": {
                "label": "D20",
                "addr": 8312,
                "bias": [
                    3651
                ]
            },
            "D21": {
                "label": "D21",
                "addr": 8219,
                "bias": [
                    3551
                ]
            },
            "D22": {
                "label": "D22",
                "addr": 8320,
                "bias": [
                    3642
                ]
            },
            "D23": {
                "label": "D23",
                "addr": 8221,
                "bias": [
                    3536
                ]
            },
            "D24": {
                "label": "D24",
                "addr": 8224,
                "bias": [
                    3532
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4557
            },
            "L1": {
                "label": "L1",
                "addr": 4544
            },
            "L2": {
                "label": "L2",
                "addr": 4568
            },
            "L3": {
                "label": "L3",
                "addr": 4480
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "412b004100412d00422b004200422d00432b004300432d00442b004400442d004500000000000000c7293a92cbff0f40d26f5f07ce990d409f3c2cd49a660a4039d6c56d34000840d26f5f07ce9905409f3c2cd49a66024039d6c56d34000040a4dfbe0e9c33fb3f3e7958a835cdf43f71ac8bdb6800f03f48bf7d1d3867e63f2d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2028": {
                    "type": "f64",
                    "value": 3.9999
                },
                "0x2030": {
                    "type": "f64",
                    "value": 3.7001
                },
                "0x2038": {
                    "type": "f64",
                    "value": 3.3001
                },
                "0x2040": {
                    "type": "f64[2]",
                    "value": [
                        3.0001,
                        2.7001
                    ]
                },
                "0x2048": {
                    "type": "f64[2]",
                    "value": [
                        2.7001,
                        2.3001
                    ]
                },
                "0x2050": {
                    "type": "f64[2]",
                    "value": [
                        2.3001,
                        2.0001
                    ]
                },
                "0x2058": {
                    "type": "f64[2]",
                    "value": [
                        2.0001,
                        1.7001
                    ]
                },
                "0x2060": {
                    "type": "f64[2]",
                    "value": [
                        1.7001,
                        1.3001
                    ]
                },
                "0x2068": {
                    "type": "f64[2]",
                    "value": [
                        1.3001,
                        1.0001
                    ]
                },
                "0x2070": {
                    "type": "f64[2]",
                    "value": [
                        1.0001,
                        0.7001
                    ]
                },
                "0x2078": {
                    "type": "f64[2]",
                    "value": [
                        0.7001,
                        0.0001
                    ]
                },
                "0x2080": {
                    "type": "f64",
                    "value": 0.0001
                },
                "0x2000": {
                    "type": "string",
                    "value": "\"A+\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"A\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"A-\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"B+\""
                },
                "0x200b": {
                    "type": "string",
                    "value": "\"B\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"B-\""
                },
                "0x2010": {
                    "type": "string",
                    "value": "\"C+\""
                },
                "0x2013": {
                    "type": "string",
                    "value": "\"C\""
                },
                "0x2015": {
                    "type": "string",
                    "value": "\"C-\""
                },
                "0x2018": {
                    "type": "string",
                    "value": "\"D+\""
                },
                "0x201b": {
                    "type": "string",
                    "value": "\"D\""
                },
                "0x201d": {
                    "type": "string",
                    "value": "\"D-\""
                },
                "0x2020": {
                    "type": "string",
                    "value": "\"E\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 81,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar** func0(float* grades, int size) {\n    char** out = malloc(size * sizeof(char*));\n    for (int i = 0; i < size; ++i) {\n        if (grades[i] >= 3.9999) out[i] = \"A+\";\n        else if (grades[i] > 3.7001) out[i] = \"A\";\n        else if (grades[i] > 3.3001) out[i] = \"A-\";\n        else if (grades[i] > 3.0001) out[i] = \"B+\";\n        else if (grades[i] > 2.7001) out[i] = \"B\";\n        else if (grades[i] > 2.3001) out[i] = \"B-\";\n        else if (grades[i] > 2.0001) out[i] = \"C+\";\n        else if (grades[i] > 1.7001) out[i] = \"C\";\n        else if (grades[i] > 1.3001) out[i] = \"C-\";\n        else if (grades[i] > 1.0001) out[i] = \"D+\";\n        else if (grades[i] > 0.7001) out[i] = \"D\";\n        else if (grades[i] > 0.0001) out[i] = \"D-\";\n        else out[i] = \"E\";\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <string.h>\n\nbool issame(char** a, char** b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    float grades1[] = {4.0, 3, 1.7, 2, 3.5};\n    char* expected1[] = {\"A+\", \"B\", \"C-\", \"C\", \"A-\"};\n    char** result1 = func0(grades1, 5);\n    assert(issame(result1, expected1, 5));\n    free(result1);\n\n    float grades2[] = {1.2};\n    char* expected2[] = {\"D+\"};\n    char** result2 = func0(grades2, 1);\n    assert(issame(result2, expected2, 1));\n    free(result2);\n\n    float grades3[] = {0.5};\n    char* expected3[] = {\"D-\"};\n    char** result3 = func0(grades3, 1);\n    assert(issame(result3, expected3, 1));\n    free(result3);\n\n    float grades4[] = {0.0};\n    char* expected4[] = {\"E\"};\n    char** result4 = func0(grades4, 1);\n    assert(issame(result4, expected4, 1));\n    free(result4);\n\n    float grades5[] = {1, 0.3, 1.5, 2.8, 3.3};\n    char* expected5[] = {\"D\", \"D-\", \"C-\", \"B\", \"B+\"};\n    char** result5 = func0(grades5, 5);\n    assert(issame(result5, expected5, 5));\n    free(result5);\n\n    float grades6[] = {0, 0.7};\n    char* expected6[] = {\"E\", \"D-\"};\n    char** result6 = func0(grades6, 2);\n    assert(issame(result6, expected6, 2));\n    free(result6);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  call   1050 <malloc@plt>\n  movsd  0xee5(%rip),%xmm1        # 2028 <_fini+0xdc8>\n  test   %ebp,%ebp\n  jle    11cd <func0+0xad>\n  xor    %edx,%edx\n  movsd  0xedb(%rip),%xmm2        # 2030 <_fini+0xdd0>\n  movsd  0xedb(%rip),%xmm3        # 2038 <_fini+0xdd8>\n  lea    0xe9c(%rip),%rsi        # 2000 <_fini+0xda0>\n  lea    0xe98(%rip),%rdi        # 2003 <_fini+0xda3>\n  lea    0xe93(%rip),%r8        # 2005 <_fini+0xda5>\n  lea    0xe8f(%rip),%r9        # 2008 <_fini+0xda8>\n  lea    0xe8b(%rip),%r10        # 200b <_fini+0xdab>\n  pxor   %xmm0,%xmm0\n  mov    %rsi,%rcx\n  cvtss2sd (%rbx,%rdx,4),%xmm0\n  comisd %xmm1,%xmm0\n  jae    11c0 <func0+0xa0>\n  comisd %xmm2,%xmm0\n  mov    %rdi,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd %xmm3,%xmm0\n  mov    %r8,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd 0xe94(%rip),%xmm0        # 2040 <_fini+0xde0>\n  mov    %r9,%rcx\n  ja     11c0 <func0+0xa0>\n  comisd 0xe8f(%rip),%xmm0        # 2048 <_fini+0xde8>\n  mov    %r10,%rcx\n  jbe    11d8 <func0+0xb8>\n  xchg   %ax,%ax\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rbp,%rdx\n  jne    1180 <func0+0x60>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  comisd 0xe70(%rip),%xmm0        # 2050 <_fini+0xdf0>\n  lea    0xe26(%rip),%rcx        # 200d <_fini+0xdad>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe67(%rip),%xmm0        # 2058 <_fini+0xdf8>\n  lea    0xe18(%rip),%rcx        # 2010 <_fini+0xdb0>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe5e(%rip),%xmm0        # 2060 <_fini+0xe00>\n  lea    0xe0a(%rip),%rcx        # 2013 <_fini+0xdb3>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe55(%rip),%xmm0        # 2068 <_fini+0xe08>\n  lea    0xdfb(%rip),%rcx        # 2015 <_fini+0xdb5>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe4c(%rip),%xmm0        # 2070 <_fini+0xe10>\n  lea    0xded(%rip),%rcx        # 2018 <_fini+0xdb8>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe43(%rip),%xmm0        # 2078 <_fini+0xe18>\n  lea    0xddf(%rip),%rcx        # 201b <_fini+0xdbb>\n  ja     11c0 <func0+0xa0>\n  comisd 0xe3a(%rip),%xmm0        # 2080 <_fini+0xe20>\n  lea    0xdd0(%rip),%rcx        # 201d <_fini+0xdbd>\n  lea    0xdcc(%rip),%r11        # 2020 <_fini+0xdc0>\n  cmovbe %r11,%rcx\n  jmp    11c0 <func0+0xa0>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  call   <malloc@plt>\n  movsd  D0(%rip),%xmm1\n  test   %ebp,%ebp\n  jle    L0\n  xor    %edx,%edx\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  lea    D3(%rip),%rsi\n  lea    D4(%rip),%rdi\n  lea    D5(%rip),%r8\n  lea    D6(%rip),%r9\n  lea    D7(%rip),%r10\nL3:\n  pxor   %xmm0,%xmm0\n  mov    %rsi,%rcx\n  cvtss2sd (%rbx,%rdx,4),%xmm0\n  comisd %xmm1,%xmm0\n  jae    L1\n  comisd %xmm2,%xmm0\n  mov    %rdi,%rcx\n  ja     L1\n  comisd %xmm3,%xmm0\n  mov    %r8,%rcx\n  ja     L1\n  comisd D8(%rip),%xmm0\n  mov    %r9,%rcx\n  ja     L1\n  comisd D9(%rip),%xmm0\n  mov    %r10,%rcx\n  jbe    L2\n  xchg   %ax,%ax\nL1:\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rbp,%rdx\n  jne    L3\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL2:\n  comisd D10(%rip),%xmm0\n  lea    D11(%rip),%rcx\n  ja     L1\n  comisd D12(%rip),%xmm0\n  lea    D13(%rip),%rcx\n  ja     L1\n  comisd D14(%rip),%xmm0\n  lea    D15(%rip),%rcx\n  ja     L1\n  comisd D16(%rip),%xmm0\n  lea    D17(%rip),%rcx\n  ja     L1\n  comisd D18(%rip),%xmm0\n  lea    D19(%rip),%rcx\n  ja     L1\n  comisd D20(%rip),%xmm0\n  lea    D21(%rip),%rcx\n  ja     L1\n  comisd D22(%rip),%xmm0\n  lea    D23(%rip),%rcx\n  lea    D24(%rip),%r11\n  cmovbe %r11,%rcx\n  jmp    L1",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8232,
                "bias": [
                    3813
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8240,
                "bias": [
                    3803
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8248,
                "bias": [
                    3803
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8192,
                "bias": [
                    3740
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8195,
                "bias": [
                    3736
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8197,
                "bias": [
                    3731
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8200,
                "bias": [
                    3727
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8203,
                "bias": [
                    3723
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8256,
                "bias": [
                    3732
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8264,
                "bias": [
                    3727
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 8272,
                "bias": [
                    3696
                ]
            },
            "D11": {
                "label": "D11",
                "addr": 8205,
                "bias": [
                    3622
                ]
            },
            "D12": {
                "label": "D12",
                "addr": 8280,
                "bias": [
                    3687
                ]
            },
            "D13": {
                "label": "D13",
                "addr": 8208,
                "bias": [
                    3608
                ]
            },
            "D14": {
                "label": "D14",
                "addr": 8288,
                "bias": [
                    3678
                ]
            },
            "D15": {
                "label": "D15",
                "addr": 8211,
                "bias": [
                    3594
                ]
            },
            "D16": {
                "label": "D16",
                "addr": 8296,
                "bias": [
                    3669
                ]
            },
            "D17": {
                "label": "D17",
                "addr": 8213,
                "bias": [
                    3579
                ]
            },
            "D18": {
                "label": "D18",
                "addr": 8304,
                "bias": [
                    3660
                ]
            },
            "D19": {
                "label": "D19",
                "addr": 8216,
                "bias": [
                    3565
                ]
            },
            "D20": {
                "label": "D20",
                "addr": 8312,
                "bias": [
                    3651
                ]
            },
            "D21": {
                "label": "D21",
                "addr": 8219,
                "bias": [
                    3551
                ]
            },
            "D22": {
                "label": "D22",
                "addr": 8320,
                "bias": [
                    3642
                ]
            },
            "D23": {
                "label": "D23",
                "addr": 8221,
                "bias": [
                    3536
                ]
            },
            "D24": {
                "label": "D24",
                "addr": 8224,
                "bias": [
                    3532
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4557
            },
            "L1": {
                "label": "L1",
                "addr": 4544
            },
            "L2": {
                "label": "L2",
                "addr": 4568
            },
            "L3": {
                "label": "L3",
                "addr": 4480
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "412b004100412d00422b004200422d00432b004300432d00442b004400442d004500000000000000c7293a92cbff0f40d26f5f07ce990d409f3c2cd49a660a4039d6c56d34000840d26f5f07ce9905409f3c2cd49a66024039d6c56d34000040a4dfbe0e9c33fb3f3e7958a835cdf43f71ac8bdb6800f03f48bf7d1d3867e63f2d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2028": {
                    "type": "f64",
                    "value": 3.9999
                },
                "0x2030": {
                    "type": "f64",
                    "value": 3.7001
                },
                "0x2038": {
                    "type": "f64",
                    "value": 3.3001
                },
                "0x2040": {
                    "type": "f64[2]",
                    "value": [
                        3.0001,
                        2.7001
                    ]
                },
                "0x2048": {
                    "type": "f64[2]",
                    "value": [
                        2.7001,
                        2.3001
                    ]
                },
                "0x2050": {
                    "type": "f64[2]",
                    "value": [
                        2.3001,
                        2.0001
                    ]
                },
                "0x2058": {
                    "type": "f64[2]",
                    "value": [
                        2.0001,
                        1.7001
                    ]
                },
                "0x2060": {
                    "type": "f64[2]",
                    "value": [
                        1.7001,
                        1.3001
                    ]
                },
                "0x2068": {
                    "type": "f64[2]",
                    "value": [
                        1.3001,
                        1.0001
                    ]
                },
                "0x2070": {
                    "type": "f64[2]",
                    "value": [
                        1.0001,
                        0.7001
                    ]
                },
                "0x2078": {
                    "type": "f64[2]",
                    "value": [
                        0.7001,
                        0.0001
                    ]
                },
                "0x2080": {
                    "type": "f64",
                    "value": 0.0001
                },
                "0x2000": {
                    "type": "string",
                    "value": "\"A+\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"A\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"A-\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"B+\""
                },
                "0x200b": {
                    "type": "string",
                    "value": "\"B\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"B-\""
                },
                "0x2010": {
                    "type": "string",
                    "value": "\"C+\""
                },
                "0x2013": {
                    "type": "string",
                    "value": "\"C\""
                },
                "0x2015": {
                    "type": "string",
                    "value": "\"C-\""
                },
                "0x2018": {
                    "type": "string",
                    "value": "\"D+\""
                },
                "0x201b": {
                    "type": "string",
                    "value": "\"D\""
                },
                "0x201d": {
                    "type": "string",
                    "value": "\"D-\""
                },
                "0x2020": {
                    "type": "string",
                    "value": "\"E\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 82,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jg     1145 <func0+0x2c>\n  mov    $0x0,%eax\n  jmp    1176 <func0+0x5d>\n  movl   $0x2,-0x8(%rbp)\n  jmp    1166 <func0+0x4d>\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1162 <func0+0x49>\n  mov    $0x0,%eax\n  jmp    1176 <func0+0x5d>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    114e <func0+0x35>\n  mov    $0x1,%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jg     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x2,-0x8(%rbp)\n  jmp    L2\nL4:\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L3\n  mov    $0x0,%eax\n  jmp    L1\nL3:\n  addl   $0x1,-0x8(%rbp)\nL2:\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    L4\n  mov    $0x1,%eax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4421
            },
            "L1": {
                "label": "L1",
                "addr": 4470
            },
            "L2": {
                "label": "L2",
                "addr": 4454
            },
            "L3": {
                "label": "L3",
                "addr": 4450
            },
            "L4": {
                "label": "L4",
                "addr": 4430
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 82,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  mov    $0x0,%edx\n  cmp    $0x1,%eax\n  jle    1161 <func0+0x48>\n  mov    %eax,%esi\n  cmp    $0x3,%eax\n  jle    1168 <func0+0x4f>\n  test   $0x1,%al\n  je     116f <func0+0x56>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     115c <func0+0x43>\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    1140 <func0+0x27>\n  mov    $0x0,%edx\n  jmp    1161 <func0+0x48>\n  mov    $0x1,%edx\n  mov    %edx,%eax\n  add    $0x8,%rsp\n  ret\n  mov    $0x1,%edx\n  jmp    1161 <func0+0x48>\n  mov    $0x0,%edx\n  jmp    1161 <func0+0x48>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    $0x0,%edx\n  cmp    $0x1,%eax\n  jle    L0\n  mov    %eax,%esi\n  cmp    $0x3,%eax\n  jle    L1\n  test   $0x1,%al\n  je     L2\n  mov    $0x2,%ecx\nL4:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     L3\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L4\n  mov    $0x0,%edx\n  jmp    L0\nL3:\n  mov    $0x1,%edx\nL0:\n  mov    %edx,%eax\n  add    $0x8,%rsp\n  ret\nL1:\n  mov    $0x1,%edx\n  jmp    L0\nL2:\n  mov    $0x0,%edx\n  jmp    L0",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4449
            },
            "L1": {
                "label": "L1",
                "addr": 4456
            },
            "L2": {
                "label": "L2",
                "addr": 4463
            },
            "L3": {
                "label": "L3",
                "addr": 4444
            },
            "L4": {
                "label": "L4",
                "addr": 4416
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 82,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x1,%eax\n  jle    116b <func0+0x4b>\n  cmp    $0x3,%eax\n  jle    1165 <func0+0x45>\n  test   $0x1,%al\n  je     116b <func0+0x4b>\n  mov    %eax,%esi\n  mov    $0x2,%ecx\n  jmp    1159 <func0+0x39>\n  nopw   0x0(%rax,%rax,1)\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1178 <func0+0x58>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    1150 <func0+0x30>\n  mov    $0x1,%r8d\n  mov    %r8d,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x1,%eax\n  jle    L0\n  cmp    $0x3,%eax\n  jle    L1\n  test   $0x1,%al\n  je     L0\n  mov    %eax,%esi\n  mov    $0x2,%ecx\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    L4\nL1:\n  mov    $0x1,%r8d\nL0:\n  mov    %r8d,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  xor    %r8d,%r8d\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4459
            },
            "L1": {
                "label": "L1",
                "addr": 4453
            },
            "L2": {
                "label": "L2",
                "addr": 4441
            },
            "L3": {
                "label": "L3",
                "addr": 4472
            },
            "L4": {
                "label": "L4",
                "addr": 4432
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 82,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nbool func0(const char* str) {\n    int l = strlen(str);\n    if (l < 2) return false;\n    for (int i = 2; i * i <= l; i++) {\n        if (l % i == 0) return false;\n    }\n    return true;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello\") == true);\n    assert(func0(\"abcdcba\") == true);\n    assert(func0(\"kittens\") == true);\n    assert(func0(\"orange\") == false);\n    assert(func0(\"wow\") == true);\n    assert(func0(\"world\") == true);\n    assert(func0(\"MadaM\") == true);\n    assert(func0(\"Wow\") == true);\n    assert(func0(\"\") == false);\n    assert(func0(\"HI\") == true);\n    assert(func0(\"go\") == true);\n    assert(func0(\"gogo\") == false);\n    assert(func0(\"aaaaaaaaaaaaaaa\") == false);\n    assert(func0(\"Madam\") == true);\n    assert(func0(\"M\") == false);\n    assert(func0(\"0\") == false);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x1,%eax\n  jle    116b <func0+0x4b>\n  cmp    $0x3,%eax\n  jle    1165 <func0+0x45>\n  test   $0x1,%al\n  je     116b <func0+0x4b>\n  mov    %eax,%esi\n  mov    $0x2,%ecx\n  jmp    1159 <func0+0x39>\n  nopw   0x0(%rax,%rax,1)\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1178 <func0+0x58>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    1150 <func0+0x30>\n  mov    $0x1,%r8d\n  mov    %r8d,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  xor    %r8d,%r8d\n  cmp    $0x1,%eax\n  jle    L0\n  cmp    $0x3,%eax\n  jle    L1\n  test   $0x1,%al\n  je     L0\n  mov    %eax,%esi\n  mov    $0x2,%ecx\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL2:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    L4\nL1:\n  mov    $0x1,%r8d\nL0:\n  mov    %r8d,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  xor    %r8d,%r8d\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4459
            },
            "L1": {
                "label": "L1",
                "addr": 4453
            },
            "L2": {
                "label": "L2",
                "addr": 4441
            },
            "L3": {
                "label": "L3",
                "addr": 4472
            },
            "L4": {
                "label": "L4",
                "addr": 4432
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 83,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     1111 <func0+0x18>\n  mov    $0x0,%eax\n  jmp    114c <func0+0x53>\n  cmpl   $0x1,-0x14(%rbp)\n  jne    111e <func0+0x25>\n  mov    $0x1,%eax\n  jmp    114c <func0+0x53>\n  movl   $0x12,-0x8(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    1141 <func0+0x48>\n  mov    -0x8(%rbp),%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     112e <func0+0x35>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  cmpl   $0x1,-0x14(%rbp)\n  jne    L2\n  mov    $0x1,%eax\n  jmp    L1\nL2:\n  movl   $0x12,-0x8(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    L3\nL4:\n  mov    -0x8(%rbp),%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL3:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L4\n  mov    -0x8(%rbp),%eax\nL1:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4369
            },
            "L1": {
                "label": "L1",
                "addr": 4428
            },
            "L2": {
                "label": "L2",
                "addr": 4382
            },
            "L3": {
                "label": "L3",
                "addr": 4417
            },
            "L4": {
                "label": "L4",
                "addr": 4398
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 83,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  test   %edi,%edi\n  jle    112e <func0+0x35>\n  mov    %edi,%eax\n  cmp    $0x1,%edi\n  je     112e <func0+0x35>\n  cmp    $0x2,%edi\n  jle    1129 <func0+0x30>\n  mov    $0x2,%edx\n  mov    $0x12,%eax\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  add    $0x1,%edx\n  cmp    %edx,%edi\n  jne    111c <func0+0x23>\n  ret\n  mov    $0x12,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x0,%eax\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%eax\n  cmp    $0x1,%edi\n  je     L0\n  cmp    $0x2,%edi\n  jle    L1\n  mov    $0x2,%edx\n  mov    $0x12,%eax\nL2:\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  add    $0x1,%edx\n  cmp    %edx,%edi\n  jne    L2\n  ret\nL1:\n  mov    $0x12,%eax\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4398
            },
            "L1": {
                "label": "L1",
                "addr": 4393
            },
            "L2": {
                "label": "L2",
                "addr": 4380
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 83,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    113d <func0+0x3d>\n  mov    $0x1,%eax\n  cmp    $0x1,%edi\n  je     113d <func0+0x3d>\n  cmp    $0x2,%edi\n  je     1138 <func0+0x38>\n  mov    $0x2,%edx\n  mov    $0x12,%eax\n  nopl   0x0(%rax,%rax,1)\n  lea    (%rax,%rax,4),%eax\n  add    $0x1,%edx\n  add    %eax,%eax\n  cmp    %edx,%edi\n  jne    1128 <func0+0x28>\n  ret\n  nopl   (%rax)\n  mov    $0x12,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    L0\n  mov    $0x1,%eax\n  cmp    $0x1,%edi\n  je     L0\n  cmp    $0x2,%edi\n  je     L1\n  mov    $0x2,%edx\n  mov    $0x12,%eax\n  nopl   0x0(%rax,%rax,1)\nL2:\n  lea    (%rax,%rax,4),%eax\n  add    $0x1,%edx\n  add    %eax,%eax\n  cmp    %edx,%edi\n  jne    L2\n  ret\n  nopl   (%rax)\nL1:\n  mov    $0x12,%eax\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4413
            },
            "L1": {
                "label": "L1",
                "addr": 4408
            },
            "L2": {
                "label": "L2",
                "addr": 4392
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 83,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n < 1) return 0;\n    if (n == 1) return 1;\n    int out = 18;\n    for (int i = 2; i < n; i++)\n        out = out * 10;\n    return out;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(1) == 1);\n    assert(func0(2) == 18);\n    assert(func0(3) == 180);\n    assert(func0(4) == 1800);\n    assert(func0(5) == 18000);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    1175 <func0+0x75>\n  mov    $0x1,%eax\n  cmp    $0x1,%edi\n  je     1175 <func0+0x75>\n  cmp    $0x2,%edi\n  je     1170 <func0+0x70>\n  lea    -0x2(%rdi),%ecx\n  cmp    $0x3,%edi\n  je     1176 <func0+0x76>\n  movq   0xed7(%rip),%xmm0        # 2000 <_fini+0xe7c>\n  mov    %ecx,%edx\n  xor    %eax,%eax\n  shr    %edx\n  nop\n  movdqa %xmm0,%xmm1\n  add    $0x1,%eax\n  pslld  $0x2,%xmm1\n  paddd  %xmm1,%xmm0\n  pslld  $0x1,%xmm0\n  cmp    %eax,%edx\n  jne    1130 <func0+0x30>\n  movd   %xmm0,%edx\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm2,%eax\n  imul   %edx,%eax\n  lea    (%rax,%rax,8),%eax\n  add    %eax,%eax\n  and    $0x1,%ecx\n  je     1180 <func0+0x80>\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  ret\n  nopl   0x0(%rax)\n  mov    $0x12,%eax\n  ret\n  mov    $0x12,%eax\n  jmp    1163 <func0+0x63>\n  nopl   (%rax)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %edi,%edi\n  jle    L0\n  mov    $0x1,%eax\n  cmp    $0x1,%edi\n  je     L0\n  cmp    $0x2,%edi\n  je     L1\n  lea    -0x2(%rdi),%ecx\n  cmp    $0x3,%edi\n  je     L2\n  movq   D0(%rip),%xmm0\n  mov    %ecx,%edx\n  xor    %eax,%eax\n  shr    %edx\n  nop\nL3:\n  movdqa %xmm0,%xmm1\n  add    $0x1,%eax\n  pslld  $0x2,%xmm1\n  paddd  %xmm1,%xmm0\n  pslld  $0x1,%xmm0\n  cmp    %eax,%edx\n  jne    L3\n  movd   %xmm0,%edx\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm2,%eax\n  imul   %edx,%eax\n  lea    (%rax,%rax,8),%eax\n  add    %eax,%eax\n  and    $0x1,%ecx\n  je     L4\nL5:\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    $0x12,%eax\nL0:\n  ret\nL2:\n  mov    $0x12,%eax\n  jmp    L5\n  nopl   (%rax)\nL4:\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3799
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4469
            },
            "L1": {
                "label": "L1",
                "addr": 4464
            },
            "L2": {
                "label": "L2",
                "addr": 4470
            },
            "L3": {
                "label": "L3",
                "addr": 4400
            },
            "L4": {
                "label": "L4",
                "addr": 4480
            },
            "L5": {
                "label": "L5",
                "addr": 4451
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0100000001000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[8]",
                    "value": [
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 84,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %edi,-0x34(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x34(%rbp),%edx\n  lea    -0xe(%rbp),%rax\n  lea    0xe7b(%rip),%rcx        # 2000 <_fini+0xd2c>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1090 <sprintf@plt>\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    11bc <func0+0x63>\n  mov    -0x24(%rbp),%eax\n  cltq\n  movzbl -0xe(%rbp,%rax,1),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x28(%rbp)\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  movzbl -0xe(%rbp,%rax,1),%eax\n  test   %al,%al\n  jne    11a5 <func0+0x4c>\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  cmpl   $0x0,-0x28(%rbp)\n  jne    1234 <func0+0xdb>\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x30,(%rax)\n  jmp    123a <func0+0xe1>\n  mov    -0x28(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x28(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x28(%rbp)\n  cmpl   $0x0,-0x28(%rbp)\n  jg     11fd <func0+0xa4>\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    12a8 <func0+0x14f>\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x29(%rbp)\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x29(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x20(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     1253 <func0+0xfa>\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     12d1 <func0+0x178>\n  call   1070 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %edi,-0x34(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x34(%rbp),%edx\n  lea    -0xe(%rbp),%rax\n  lea    D0(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L0\nL1:\n  mov    -0x24(%rbp),%eax\n  cltq\n  movzbl -0xe(%rbp,%rax,1),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x28(%rbp)\n  addl   $0x1,-0x24(%rbp)\nL0:\n  mov    -0x24(%rbp),%eax\n  cltq\n  movzbl -0xe(%rbp,%rax,1),%eax\n  test   %al,%al\n  jne    L1\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  cmpl   $0x0,-0x28(%rbp)\n  jne    L2\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x30,(%rax)\n  jmp    L3\nL4:\n  mov    -0x28(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0x20(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x20(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x28(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x28(%rbp)\nL2:\n  cmpl   $0x0,-0x28(%rbp)\n  jg     L4\nL3:\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L5\nL6:\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x29(%rbp)\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x20(%rbp),%eax\n  sub    -0x1c(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x29(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\nL5:\n  mov    -0x20(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     L6\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L7\n  call   <__stack_chk_fail@plt>\nL7:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3707
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4540
            },
            "L1": {
                "label": "L1",
                "addr": 4517
            },
            "L2": {
                "label": "L2",
                "addr": 4660
            },
            "L3": {
                "label": "L3",
                "addr": 4666
            },
            "L4": {
                "label": "L4",
                "addr": 4605
            },
            "L5": {
                "label": "L5",
                "addr": 4776
            },
            "L6": {
                "label": "L6",
                "addr": 4691
            },
            "L7": {
                "label": "L7",
                "addr": 4817
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 84,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  sub    $0x10,%rsp\n  mov    %edi,%r8d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rdi\n  lea    0xe7f(%rip),%rcx        # 2000 <_fini+0xd7c>\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  call   1090 <__sprintf_chk@plt>\n  movzbl 0x2(%rsp),%eax\n  test   %al,%al\n  je     1261 <func0+0x108>\n  lea    0x2(%rsp),%rdx\n  mov    $0x0,%ebx\n  movsbl %al,%eax\n  lea    -0x30(%rbx,%rax,1),%ebx\n  add    $0x1,%rdx\n  movzbl (%rdx),%eax\n  test   %al,%al\n  jne    11a7 <func0+0x4e>\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%rcx\n  test   %ebx,%ebx\n  je     126e <func0+0x115>\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  jle    1276 <func0+0x11d>\n  mov    %edx,%edi\n  mov    %ebx,%esi\n  shr    $0x1f,%esi\n  lea    (%rbx,%rsi,1),%eax\n  and    $0x1,%eax\n  sub    %esi,%eax\n  add    $0x30,%eax\n  mov    %al,-0x1(%rcx,%rdx,1)\n  mov    %ebx,%esi\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  add    $0x1,%rdx\n  cmp    $0x1,%esi\n  jg     11de <func0+0x85>\n  movslq %edi,%rax\n  movb   $0x0,(%rcx,%rax,1)\n  mov    %edi,%r8d\n  shr    $0x1f,%r8d\n  add    %edi,%r8d\n  sar    %r8d\n  cmp    $0x1,%edi\n  jle    1248 <func0+0xef>\n  lea    -0x1(%rcx,%rax,1),%rdx\n  mov    $0x0,%eax\n  movzbl (%rcx,%rax,1),%esi\n  movzbl (%rdx),%edi\n  mov    %dil,(%rcx,%rax,1)\n  mov    %sil,(%rdx)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%r8d\n  jg     122d <func0+0xd4>\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    127e <func0+0x125>\n  mov    %rcx,%rax\n  add    $0x10,%rsp\n  pop    %rbx\n  ret\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%rcx\n  movb   $0x30,(%rcx)\n  mov    $0x1,%eax\n  cltq\n  movb   $0x0,(%rcx,%rax,1)\n  jmp    1248 <func0+0xef>\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  sub    $0x10,%rsp\n  mov    %edi,%r8d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rdi\n  lea    D0(%rip),%rcx\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  call   <__sprintf_chk@plt>\n  movzbl 0x2(%rsp),%eax\n  test   %al,%al\n  je     L0\n  lea    0x2(%rsp),%rdx\n  mov    $0x0,%ebx\nL1:\n  movsbl %al,%eax\n  lea    -0x30(%rbx,%rax,1),%ebx\n  add    $0x1,%rdx\n  movzbl (%rdx),%eax\n  test   %al,%al\n  jne    L1\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%rcx\n  test   %ebx,%ebx\n  je     L2\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  jle    L3\nL4:\n  mov    %edx,%edi\n  mov    %ebx,%esi\n  shr    $0x1f,%esi\n  lea    (%rbx,%rsi,1),%eax\n  and    $0x1,%eax\n  sub    %esi,%eax\n  add    $0x30,%eax\n  mov    %al,-0x1(%rcx,%rdx,1)\n  mov    %ebx,%esi\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  add    $0x1,%rdx\n  cmp    $0x1,%esi\n  jg     L4\n  movslq %edi,%rax\n  movb   $0x0,(%rcx,%rax,1)\n  mov    %edi,%r8d\n  shr    $0x1f,%r8d\n  add    %edi,%r8d\n  sar    %r8d\n  cmp    $0x1,%edi\n  jle    L5\n  lea    -0x1(%rcx,%rax,1),%rdx\n  mov    $0x0,%eax\nL6:\n  movzbl (%rcx,%rax,1),%esi\n  movzbl (%rdx),%edi\n  mov    %dil,(%rcx,%rax,1)\n  mov    %sil,(%rdx)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%r8d\n  jg     L6\nL5:\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  mov    %rcx,%rax\n  add    $0x10,%rsp\n  pop    %rbx\n  ret\nL0:\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%rcx\nL2:\n  movb   $0x30,(%rcx)\n  mov    $0x1,%eax\nL3:\n  cltq\n  movb   $0x0,(%rcx,%rax,1)\n  jmp    L5\nL7:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3711
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4705
            },
            "L1": {
                "label": "L1",
                "addr": 4519
            },
            "L2": {
                "label": "L2",
                "addr": 4718
            },
            "L3": {
                "label": "L3",
                "addr": 4726
            },
            "L4": {
                "label": "L4",
                "addr": 4574
            },
            "L5": {
                "label": "L5",
                "addr": 4680
            },
            "L6": {
                "label": "L6",
                "addr": 4653
            },
            "L7": {
                "label": "L7",
                "addr": 4734
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 84,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%r8d\n  lea    0xe91(%rip),%rcx        # 2000 <_fini+0xd84>\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  sub    $0x10,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rbx\n  mov    %rbx,%rdi\n  call   1090 <__sprintf_chk@plt>\n  movsbl 0x2(%rsp),%eax\n  test   %al,%al\n  je     1258 <func0+0xf8>\n  mov    %rbx,%rdx\n  xor    %ebx,%ebx\n  nopl   0x0(%rax)\n  add    $0x1,%rdx\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl (%rdx),%eax\n  test   %al,%al\n  jne    11b0 <func0+0x50>\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %ebx,%ebx\n  je     1265 <func0+0x105>\n  mov    $0x1,%eax\n  jle    1272 <func0+0x112>\n  nop\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,-0x1(%r8,%rax,1)\n  add    $0x1,%rax\n  sar    %ebx\n  jne    11e0 <func0+0x80>\n  movslq %ecx,%rsi\n  sar    %ecx\n  movb   $0x0,(%r8,%rsi,1)\n  je     123a <func0+0xda>\n  lea    -0x2(%r8,%rsi,1),%rdi\n  sub    $0x1,%ecx\n  lea    -0x1(%r8,%rsi,1),%rax\n  mov    %r8,%rdx\n  sub    %rcx,%rdi\n  cs nopw 0x0(%rax,%rax,1)\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    1220 <func0+0xc0>\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1277 <func0+0x117>\n  add    $0x10,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  movb   $0x30,(%r8)\n  lea    0x1(%r8),%rax\n  movb   $0x0,(%rax)\n  jmp    123a <func0+0xda>\n  mov    %r8,%rax\n  jmp    126d <func0+0x10d>\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%r8d\n  lea    D0(%rip),%rcx\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  sub    $0x10,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rbx\n  mov    %rbx,%rdi\n  call   <__sprintf_chk@plt>\n  movsbl 0x2(%rsp),%eax\n  test   %al,%al\n  je     L0\n  mov    %rbx,%rdx\n  xor    %ebx,%ebx\n  nopl   0x0(%rax)\nL1:\n  add    $0x1,%rdx\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl (%rdx),%eax\n  test   %al,%al\n  jne    L1\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %ebx,%ebx\n  je     L2\n  mov    $0x1,%eax\n  jle    L3\n  nop\nL4:\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,-0x1(%r8,%rax,1)\n  add    $0x1,%rax\n  sar    %ebx\n  jne    L4\n  movslq %ecx,%rsi\n  sar    %ecx\n  movb   $0x0,(%r8,%rsi,1)\n  je     L5\n  lea    -0x2(%r8,%rsi,1),%rdi\n  sub    $0x1,%ecx\n  lea    -0x1(%r8,%rsi,1),%rax\n  mov    %r8,%rdx\n  sub    %rcx,%rdi\n  cs nopw 0x0(%rax,%rax,1)\nL6:\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    L6\nL5:\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  add    $0x10,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\nL2:\n  movb   $0x30,(%r8)\n  lea    0x1(%r8),%rax\nL8:\n  movb   $0x0,(%rax)\n  jmp    L5\nL3:\n  mov    %r8,%rax\n  jmp    L8\nL7:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3729
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4696
            },
            "L1": {
                "label": "L1",
                "addr": 4528
            },
            "L2": {
                "label": "L2",
                "addr": 4709
            },
            "L3": {
                "label": "L3",
                "addr": 4722
            },
            "L4": {
                "label": "L4",
                "addr": 4576
            },
            "L5": {
                "label": "L5",
                "addr": 4666
            },
            "L6": {
                "label": "L6",
                "addr": 4640
            },
            "L7": {
                "label": "L7",
                "addr": 4727
            },
            "L8": {
                "label": "L8",
                "addr": 4717
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 84,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int N) {\n    char str[6];\n    sprintf(str, \"%d\", N);\n    int sum = 0;\n    for (int i = 0; str[i] != '\\0'; i++)\n        sum += str[i] - '0';\n\n    char* bi = malloc(33);\n    int index = 0;\n    if (sum == 0) {\n        bi[index++] = '0';\n    } else {\n        while (sum > 0) {\n            bi[index++] = (sum % 2) + '0';\n            sum /= 2;\n        }\n    }\n    bi[index] = '\\0';\n\n    for (int i = 0; i < index / 2; i++) {\n        char temp = bi[i];\n        bi[i] = bi[index - i - 1];\n        bi[index - i - 1] = temp;\n    }\n\n    return bi;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(1000);\n    assert(strcmp(result, \"1\") == 0);\n    free(result);\n\n    result = func0(150);\n    assert(strcmp(result, \"110\") == 0);\n    free(result);\n\n    result = func0(147);\n    assert(strcmp(result, \"1100\") == 0);\n    free(result);\n\n    result = func0(333);\n    assert(strcmp(result, \"1001\") == 0);\n    free(result);\n\n    result = func0(963);\n    assert(strcmp(result, \"10010\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%r8d\n  lea    0xe91(%rip),%rcx        # 2000 <_fini+0xd64>\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  sub    $0x10,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rdi\n  call   1090 <__sprintf_chk@plt>\n  movsbl 0x2(%rsp),%ebx\n  test   %bl,%bl\n  je     1278 <func0+0x118>\n  movsbl 0x3(%rsp),%eax\n  sub    $0x30,%ebx\n  test   %al,%al\n  je     11db <func0+0x7b>\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x4(%rsp),%eax\n  test   %al,%al\n  je     11db <func0+0x7b>\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x5(%rsp),%eax\n  test   %al,%al\n  je     11db <func0+0x7b>\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x6(%rsp),%eax\n  test   %al,%al\n  je     11db <func0+0x7b>\n  lea    -0x30(%rbx,%rax,1),%ebx\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  test   %ebx,%ebx\n  je     1285 <func0+0x125>\n  mov    $0x1,%eax\n  jle    1292 <func0+0x132>\n  nopl   0x0(%rax,%rax,1)\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,-0x1(%r8,%rax,1)\n  add    $0x1,%rax\n  sar    %ebx\n  jne    1200 <func0+0xa0>\n  movslq %ecx,%rsi\n  sar    %ecx\n  movb   $0x0,(%r8,%rsi,1)\n  je     125a <func0+0xfa>\n  lea    -0x2(%r8,%rsi,1),%rdi\n  sub    $0x1,%ecx\n  lea    -0x1(%r8,%rsi,1),%rax\n  mov    %r8,%rdx\n  sub    %rcx,%rdi\n  cs nopw 0x0(%rax,%rax,1)\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    1240 <func0+0xe0>\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1297 <func0+0x137>\n  add    $0x10,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x21,%edi\n  call   1080 <malloc@plt>\n  mov    %rax,%r8\n  movb   $0x30,(%r8)\n  lea    0x1(%r8),%rax\n  movb   $0x0,(%rax)\n  jmp    125a <func0+0xfa>\n  mov    %r8,%rax\n  jmp    128d <func0+0x12d>\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%r8d\n  lea    D0(%rip),%rcx\n  mov    $0x6,%edx\n  mov    $0x1,%esi\n  sub    $0x10,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x8(%rsp)\n  xor    %eax,%eax\n  lea    0x2(%rsp),%rdi\n  call   <__sprintf_chk@plt>\n  movsbl 0x2(%rsp),%ebx\n  test   %bl,%bl\n  je     L0\n  movsbl 0x3(%rsp),%eax\n  sub    $0x30,%ebx\n  test   %al,%al\n  je     L1\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x4(%rsp),%eax\n  test   %al,%al\n  je     L1\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x5(%rsp),%eax\n  test   %al,%al\n  je     L1\n  lea    -0x30(%rbx,%rax,1),%ebx\n  movsbl 0x6(%rsp),%eax\n  test   %al,%al\n  je     L1\n  lea    -0x30(%rbx,%rax,1),%ebx\nL1:\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %ebx,%ebx\n  je     L2\n  mov    $0x1,%eax\n  jle    L3\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    %ebx,%edx\n  mov    %eax,%ecx\n  and    $0x1,%edx\n  add    $0x30,%edx\n  mov    %dl,-0x1(%r8,%rax,1)\n  add    $0x1,%rax\n  sar    %ebx\n  jne    L4\n  movslq %ecx,%rsi\n  sar    %ecx\n  movb   $0x0,(%r8,%rsi,1)\n  je     L5\n  lea    -0x2(%r8,%rsi,1),%rdi\n  sub    $0x1,%ecx\n  lea    -0x1(%r8,%rsi,1),%rax\n  mov    %r8,%rdx\n  sub    %rcx,%rdi\n  cs nopw 0x0(%rax,%rax,1)\nL6:\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    L6\nL5:\n  mov    0x8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  add    $0x10,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,%r8\nL2:\n  movb   $0x30,(%r8)\n  lea    0x1(%r8),%rax\nL8:\n  movb   $0x0,(%rax)\n  jmp    L5\nL3:\n  mov    %r8,%rax\n  jmp    L8\nL7:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3729
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4728
            },
            "L1": {
                "label": "L1",
                "addr": 4571
            },
            "L2": {
                "label": "L2",
                "addr": 4741
            },
            "L3": {
                "label": "L3",
                "addr": 4754
            },
            "L4": {
                "label": "L4",
                "addr": 4608
            },
            "L5": {
                "label": "L5",
                "addr": 4698
            },
            "L6": {
                "label": "L6",
                "addr": 4672
            },
            "L7": {
                "label": "L7",
                "addr": 4759
            },
            "L8": {
                "label": "L8",
                "addr": 4749
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 85,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    115e <func0+0x65>\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    115a <func0+0x61>\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jg     1118 <func0+0x1f>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jg     L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4446
            },
            "L1": {
                "label": "L1",
                "addr": 4442
            },
            "L2": {
                "label": "L2",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 85,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    112e <func0+0x35>\n  lea    0x4(%rdi),%rax\n  sub    $0x2,%esi\n  shr    %esi\n  mov    %esi,%esi\n  lea    0xc(%rdi,%rsi,8),%rdi\n  mov    $0x0,%edx\n  mov    (%rax),%ecx\n  lea    (%rdx,%rcx,1),%esi\n  test   $0x1,%cl\n  cmove  %esi,%edx\n  add    $0x8,%rax\n  cmp    %rdi,%rax\n  jne    1117 <func0+0x1e>\n  mov    %edx,%eax\n  ret\n  mov    $0x0,%edx\n  jmp    112b <func0+0x32>",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    0x4(%rdi),%rax\n  sub    $0x2,%esi\n  shr    %esi\n  mov    %esi,%esi\n  lea    0xc(%rdi,%rsi,8),%rdi\n  mov    $0x0,%edx\nL1:\n  mov    (%rax),%ecx\n  lea    (%rdx,%rcx,1),%esi\n  test   $0x1,%cl\n  cmove  %esi,%edx\n  add    $0x8,%rax\n  cmp    %rdi,%rax\n  jne    L1\nL2:\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0x0,%edx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4398
            },
            "L1": {
                "label": "L1",
                "addr": 4375
            },
            "L2": {
                "label": "L2",
                "addr": 4395
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 85,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1140 <func0+0x40>\n  sub    $0x2,%esi\n  lea    0x4(%rdi),%rax\n  xor    %r8d,%r8d\n  shr    %esi\n  lea    0xc(%rdi,%rsi,8),%rsi\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rax),%edx\n  lea    (%r8,%rdx,1),%ecx\n  and    $0x1,%edx\n  cmove  %ecx,%r8d\n  add    $0x8,%rax\n  cmp    %rsi,%rax\n  jne    1120 <func0+0x20>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  sub    $0x2,%esi\n  lea    0x4(%rdi),%rax\n  xor    %r8d,%r8d\n  shr    %esi\n  lea    0xc(%rdi,%rsi,8),%rsi\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    (%rax),%edx\n  lea    (%r8,%rdx,1),%ecx\n  and    $0x1,%edx\n  cmove  %ecx,%r8d\n  add    $0x8,%rax\n  cmp    %rsi,%rax\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 85,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 + 1 < size; i++)\n        if (lst[i * 2 + 1] % 2 == 0) sum += lst[i * 2 + 1];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int array1[] = {4, 88};\n    assert(func0(array1, sizeof(array1) / sizeof(array1[0])) == 88);\n\n    int array2[] = {4, 5, 6, 7, 2, 122};\n    assert(func0(array2, sizeof(array2) / sizeof(array2[0])) == 122);\n\n    int array3[] = {4, 0, 6, 7};\n    assert(func0(array3, sizeof(array3) / sizeof(array3[0])) == 0);\n\n    int array4[] = {4, 4, 6, 8};\n    assert(func0(array4, sizeof(array4) / sizeof(array4[0])) == 12);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rdx\n  mov    %esi,%ecx\n  cmp    $0x1,%esi\n  jle    1200 <func0+0x100>\n  lea    -0x2(%rsi),%esi\n  cmp    $0x7,%esi\n  jbe    1203 <func0+0x103>\n  shr    $0x3,%esi\n  lea    0x4(%rdi),%rax\n  pxor   %xmm2,%xmm2\n  movdqa 0xecf(%rip),%xmm4        # 2000 <_fini+0xdf0>\n  lea    -0x1(%rsi),%edi\n  movdqa %xmm2,%xmm3\n  shl    $0x5,%rdi\n  lea    0x24(%rdx,%rdi,1),%rdi\n  nopl   0x0(%rax)\n  movdqu (%rax),%xmm1\n  movdqu 0x10(%rax),%xmm5\n  add    $0x20,%rax\n  shufps $0x88,%xmm5,%xmm1\n  movdqa %xmm1,%xmm0\n  pand   %xmm4,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  pand   %xmm1,%xmm0\n  paddd  %xmm0,%xmm2\n  cmp    %rax,%rdi\n  jne    1148 <func0+0x48>\n  movdqa %xmm2,%xmm0\n  lea    0x0(,%rsi,4),%edi\n  lea    0x1(,%rsi,8),%esi\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%eax\n  movslq %esi,%rsi\n  mov    (%rdx,%rsi,4),%esi\n  lea    (%rax,%rsi,1),%r8d\n  and    $0x1,%esi\n  lea    0x2(%rdi,%rdi,1),%esi\n  lea    0x1(%rsi),%edi\n  cmove  %r8d,%eax\n  cmp    %edi,%ecx\n  jle    1202 <func0+0x102>\n  movslq %edi,%rdi\n  mov    (%rdx,%rdi,4),%edi\n  lea    (%rax,%rdi,1),%r8d\n  and    $0x1,%edi\n  lea    0x3(%rsi),%edi\n  cmove  %r8d,%eax\n  cmp    %edi,%ecx\n  jle    1202 <func0+0x102>\n  movslq %edi,%rdi\n  mov    (%rdx,%rdi,4),%edi\n  lea    (%rax,%rdi,1),%r8d\n  and    $0x1,%edi\n  cmove  %r8d,%eax\n  add    $0x5,%esi\n  cmp    %esi,%ecx\n  jle    1202 <func0+0x102>\n  movslq %esi,%rsi\n  mov    (%rdx,%rsi,4),%edx\n  lea    (%rax,%rdx,1),%ecx\n  and    $0x1,%edx\n  cmove  %ecx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret\n  xor    %edi,%edi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  jmp    119e <func0+0x9e>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rdx\n  mov    %esi,%ecx\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%esi\n  cmp    $0x7,%esi\n  jbe    L1\n  shr    $0x3,%esi\n  lea    0x4(%rdi),%rax\n  pxor   %xmm2,%xmm2\n  movdqa D0(%rip),%xmm4\n  lea    -0x1(%rsi),%edi\n  movdqa %xmm2,%xmm3\n  shl    $0x5,%rdi\n  lea    0x24(%rdx,%rdi,1),%rdi\n  nopl   0x0(%rax)\nL2:\n  movdqu (%rax),%xmm1\n  movdqu 0x10(%rax),%xmm5\n  add    $0x20,%rax\n  shufps $0x88,%xmm5,%xmm1\n  movdqa %xmm1,%xmm0\n  pand   %xmm4,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  pand   %xmm1,%xmm0\n  paddd  %xmm0,%xmm2\n  cmp    %rax,%rdi\n  jne    L2\n  movdqa %xmm2,%xmm0\n  lea    0x0(,%rsi,4),%edi\n  lea    0x1(,%rsi,8),%esi\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%eax\nL4:\n  movslq %esi,%rsi\n  mov    (%rdx,%rsi,4),%esi\n  lea    (%rax,%rsi,1),%r8d\n  and    $0x1,%esi\n  lea    0x2(%rdi,%rdi,1),%esi\n  lea    0x1(%rsi),%edi\n  cmove  %r8d,%eax\n  cmp    %edi,%ecx\n  jle    L3\n  movslq %edi,%rdi\n  mov    (%rdx,%rdi,4),%edi\n  lea    (%rax,%rdi,1),%r8d\n  and    $0x1,%edi\n  lea    0x3(%rsi),%edi\n  cmove  %r8d,%eax\n  cmp    %edi,%ecx\n  jle    L3\n  movslq %edi,%rdi\n  mov    (%rdx,%rdi,4),%edi\n  lea    (%rax,%rdi,1),%r8d\n  and    $0x1,%edi\n  cmove  %r8d,%eax\n  add    $0x5,%esi\n  cmp    %esi,%ecx\n  jle    L3\n  movslq %esi,%rsi\n  mov    (%rdx,%rsi,4),%edx\n  lea    (%rax,%rdx,1),%ecx\n  and    $0x1,%edx\n  cmove  %ecx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\nL3:\n  ret\nL1:\n  xor    %edi,%edi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  jmp    L4",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3791
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4608
            },
            "L1": {
                "label": "L1",
                "addr": 4611
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            },
            "L3": {
                "label": "L3",
                "addr": 4610
            },
            "L4": {
                "label": "L4",
                "addr": 4510
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "01000000010000000100000001000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 86,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  add    $0xffffffffffffff80,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x78(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %eax,-0x4c(%rbp)\n  mov    -0x4c(%rbp),%eax\n  add    $0x2,%eax\n  cltq\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x48(%rbp)\n  movl   $0x0,-0x64(%rbp)\n  movl   $0x0,-0x60(%rbp)\n  movl   $0x0,-0x5c(%rbp)\n  jmp    12d2 <func0+0x179>\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     11e1 <func0+0x88>\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    12ae <func0+0x155>\n  movl   $0x0,-0x58(%rbp)\n  jmp    124a <func0+0xf1>\n  mov    -0x58(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x54(%rbp)\n  jmp    123e <func0+0xe5>\n  mov    -0x58(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%edx\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  cmp    %al,%dl\n  jle    123a <func0+0xe1>\n  mov    -0x58(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  mov    %al,-0x65(%rbp)\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%edx\n  mov    -0x58(%rbp),%eax\n  cltq\n  mov    %dl,-0x40(%rbp,%rax,1)\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x65(%rbp),%edx\n  mov    %dl,-0x40(%rbp,%rax,1)\n  addl   $0x1,-0x54(%rbp)\n  mov    -0x54(%rbp),%eax\n  cmp    -0x60(%rbp),%eax\n  jl     11f5 <func0+0x9c>\n  addl   $0x1,-0x58(%rbp)\n  mov    -0x60(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x58(%rbp)\n  jl     11ea <func0+0x91>\n  cmpl   $0x0,-0x64(%rbp)\n  jle    1271 <func0+0x118>\n  mov    -0x64(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x64(%rbp)\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\n  movl   $0x0,-0x50(%rbp)\n  jmp    129d <func0+0x144>\n  mov    -0x64(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x64(%rbp)\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x50(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x50(%rbp)\n  mov    -0x50(%rbp),%eax\n  cmp    -0x60(%rbp),%eax\n  jl     127a <func0+0x121>\n  movl   $0x0,-0x60(%rbp)\n  jmp    12ce <func0+0x175>\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x60(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x60(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x40(%rbp,%rax,1)\n  addl   $0x1,-0x5c(%rbp)\n  mov    -0x5c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jle    11b5 <func0+0x5c>\n  mov    -0x64(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x48(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     1306 <func0+0x1ad>\n  call   1080 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  add    $0xffffffffffffff80,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x78(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4c(%rbp)\n  mov    -0x4c(%rbp),%eax\n  add    $0x2,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x48(%rbp)\n  movl   $0x0,-0x64(%rbp)\n  movl   $0x0,-0x60(%rbp)\n  movl   $0x0,-0x5c(%rbp)\n  jmp    L0\nL12:\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L1\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\nL1:\n  movl   $0x0,-0x58(%rbp)\n  jmp    L3\nL7:\n  mov    -0x58(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x54(%rbp)\n  jmp    L4\nL6:\n  mov    -0x58(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%edx\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  cmp    %al,%dl\n  jle    L5\n  mov    -0x58(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  mov    %al,-0x65(%rbp)\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%edx\n  mov    -0x58(%rbp),%eax\n  cltq\n  mov    %dl,-0x40(%rbp,%rax,1)\n  mov    -0x54(%rbp),%eax\n  cltq\n  movzbl -0x65(%rbp),%edx\n  mov    %dl,-0x40(%rbp,%rax,1)\nL5:\n  addl   $0x1,-0x54(%rbp)\nL4:\n  mov    -0x54(%rbp),%eax\n  cmp    -0x60(%rbp),%eax\n  jl     L6\n  addl   $0x1,-0x58(%rbp)\nL3:\n  mov    -0x60(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x58(%rbp)\n  jl     L7\n  cmpl   $0x0,-0x64(%rbp)\n  jle    L8\n  mov    -0x64(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x64(%rbp)\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\nL8:\n  movl   $0x0,-0x50(%rbp)\n  jmp    L9\nL10:\n  mov    -0x64(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x64(%rbp)\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x50(%rbp),%eax\n  cltq\n  movzbl -0x40(%rbp,%rax,1),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x50(%rbp)\nL9:\n  mov    -0x50(%rbp),%eax\n  cmp    -0x60(%rbp),%eax\n  jl     L10\n  movl   $0x0,-0x60(%rbp)\n  jmp    L11\nL2:\n  mov    -0x5c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x78(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x60(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x60(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x40(%rbp,%rax,1)\nL11:\n  addl   $0x1,-0x5c(%rbp)\nL0:\n  mov    -0x5c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jle    L12\n  mov    -0x64(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x48(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L13\n  call   <__stack_chk_fail@plt>\nL13:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4818
            },
            "L1": {
                "label": "L1",
                "addr": 4577
            },
            "L2": {
                "label": "L2",
                "addr": 4782
            },
            "L3": {
                "label": "L3",
                "addr": 4682
            },
            "L4": {
                "label": "L4",
                "addr": 4670
            },
            "L5": {
                "label": "L5",
                "addr": 4666
            },
            "L6": {
                "label": "L6",
                "addr": 4597
            },
            "L7": {
                "label": "L7",
                "addr": 4586
            },
            "L8": {
                "label": "L8",
                "addr": 4721
            },
            "L9": {
                "label": "L9",
                "addr": 4765
            },
            "L10": {
                "label": "L10",
                "addr": 4730
            },
            "L11": {
                "label": "L11",
                "addr": 4814
            },
            "L12": {
                "label": "L12",
                "addr": 4533
            },
            "L13": {
                "label": "L13",
                "addr": 4870
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 86,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x40,%rsp\n  mov    %rdi,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   1070 <strlen@plt>\n  mov    %rax,%rbx\n  lea    0x2(%rax),%edi\n  movslq %edi,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r11\n  test   %ebx,%ebx\n  js     1274 <func0+0x11b>\n  mov    %rbp,%r10\n  mov    %ebx,%ebx\n  lea    0x1(%rbp,%rbx,1),%rbp\n  mov    $0x0,%r9d\n  mov    $0x0,%ebx\n  mov    $0x0,%r12d\n  mov    %rsp,%r13\n  jmp    1257 <func0+0xfe>\n  cmp    $0x1,%r9d\n  jle    120f <func0+0xb6>\n  mov    %rsp,%rsi\n  lea    -0x1(%r9),%r14d\n  mov    $0x0,%r8d\n  jmp    11f6 <func0+0x9d>\n  add    $0x1,%rax\n  cmp    %rdi,%rax\n  je     11ed <func0+0x94>\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    11d2 <func0+0x79>\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\n  jmp    11d2 <func0+0x79>\n  add    $0x1,%rsi\n  cmp    %r14d,%r8d\n  je     120f <func0+0xb6>\n  add    $0x1,%r8d\n  cmp    %r9d,%r8d\n  jge    11ed <func0+0x94>\n  mov    %r14d,%eax\n  sub    %r8d,%eax\n  lea    0x1(%rsi,%rax,1),%rdi\n  mov    %rsi,%rax\n  jmp    11db <func0+0x82>\n  test   %ebx,%ebx\n  jle    121e <func0+0xc5>\n  movslq %ebx,%rax\n  movb   $0x20,(%r11,%rax,1)\n  lea    0x1(%rbx),%ebx\n  test   %r9d,%r9d\n  jle    126f <func0+0x116>\n  movslq %ebx,%rdx\n  mov    %r9d,%edi\n  mov    %r9d,%ecx\n  add    %rdx,%rcx\n  mov    %rdx,%rax\n  mov    %r13,%rsi\n  sub    %rdx,%rsi\n  movzbl (%rsi,%rax,1),%edx\n  mov    %dl,(%r11,%rax,1)\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  jne    1238 <func0+0xdf>\n  add    %edi,%ebx\n  mov    %r12d,%r9d\n  add    $0x1,%r10\n  cmp    %rbp,%r10\n  je     1279 <func0+0x120>\n  movzbl (%r10),%eax\n  test   $0xdf,%al\n  je     11bd <func0+0x64>\n  movslq %r9d,%rdx\n  mov    %al,(%rsp,%rdx,1)\n  lea    0x1(%r9),%r9d\n  jmp    124e <func0+0xf5>\n  mov    %r12d,%r9d\n  jmp    124e <func0+0xf5>\n  mov    $0x0,%ebx\n  movslq %ebx,%rbx\n  movb   $0x0,(%r11,%rbx,1)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12a1 <func0+0x148>\n  mov    %r11,%rax\n  add    $0x40,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  call   1080 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x40,%rsp\n  mov    %rdi,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%rbx\n  lea    0x2(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r11\n  test   %ebx,%ebx\n  js     L0\n  mov    %rbp,%r10\n  mov    %ebx,%ebx\n  lea    0x1(%rbp,%rbx,1),%rbp\n  mov    $0x0,%r9d\n  mov    $0x0,%ebx\n  mov    $0x0,%r12d\n  mov    %rsp,%r13\n  jmp    L1\nL11:\n  cmp    $0x1,%r9d\n  jle    L2\n  mov    %rsp,%rsi\n  lea    -0x1(%r9),%r14d\n  mov    $0x0,%r8d\n  jmp    L3\nL5:\n  add    $0x1,%rax\n  cmp    %rdi,%rax\n  je     L4\nL6:\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    L5\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\n  jmp    L5\nL4:\n  add    $0x1,%rsi\n  cmp    %r14d,%r8d\n  je     L2\nL3:\n  add    $0x1,%r8d\n  cmp    %r9d,%r8d\n  jge    L4\n  mov    %r14d,%eax\n  sub    %r8d,%eax\n  lea    0x1(%rsi,%rax,1),%rdi\n  mov    %rsi,%rax\n  jmp    L6\nL2:\n  test   %ebx,%ebx\n  jle    L7\n  movslq %ebx,%rax\n  movb   $0x20,(%r11,%rax,1)\n  lea    0x1(%rbx),%ebx\nL7:\n  test   %r9d,%r9d\n  jle    L8\n  movslq %ebx,%rdx\n  mov    %r9d,%edi\n  mov    %r9d,%ecx\n  add    %rdx,%rcx\n  mov    %rdx,%rax\n  mov    %r13,%rsi\n  sub    %rdx,%rsi\nL9:\n  movzbl (%rsi,%rax,1),%edx\n  mov    %dl,(%r11,%rax,1)\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  jne    L9\n  add    %edi,%ebx\n  mov    %r12d,%r9d\nL12:\n  add    $0x1,%r10\n  cmp    %rbp,%r10\n  je     L10\nL1:\n  movzbl (%r10),%eax\n  test   $0xdf,%al\n  je     L11\n  movslq %r9d,%rdx\n  mov    %al,(%rsp,%rdx,1)\n  lea    0x1(%r9),%r9d\n  jmp    L12\nL8:\n  mov    %r12d,%r9d\n  jmp    L12\nL0:\n  mov    $0x0,%ebx\nL10:\n  movslq %ebx,%rbx\n  movb   $0x0,(%r11,%rbx,1)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L13\n  mov    %r11,%rax\n  add    $0x40,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL13:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4724
            },
            "L1": {
                "label": "L1",
                "addr": 4695
            },
            "L2": {
                "label": "L2",
                "addr": 4623
            },
            "L3": {
                "label": "L3",
                "addr": 4598
            },
            "L4": {
                "label": "L4",
                "addr": 4589
            },
            "L5": {
                "label": "L5",
                "addr": 4562
            },
            "L6": {
                "label": "L6",
                "addr": 4571
            },
            "L7": {
                "label": "L7",
                "addr": 4638
            },
            "L8": {
                "label": "L8",
                "addr": 4719
            },
            "L9": {
                "label": "L9",
                "addr": 4664
            },
            "L10": {
                "label": "L10",
                "addr": 4729
            },
            "L11": {
                "label": "L11",
                "addr": 4541
            },
            "L12": {
                "label": "L12",
                "addr": 4686
            },
            "L13": {
                "label": "L13",
                "addr": 4769
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 86,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   1080 <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r14\n  test   %ebx,%ebx\n  js     1287 <func0+0x107>\n  mov    %ebx,%ebx\n  xor    %r12d,%r12d\n  mov    %rsp,%r15\n  lea    0x1(%rbp,%rbx,1),%r13\n  xor    %ebx,%ebx\n  jmp    11ee <func0+0x6e>\n  nopl   0x0(%rax)\n  movslq %ebx,%rdx\n  add    $0x1,%ebx\n  mov    %al,(%rsp,%rdx,1)\n  add    $0x1,%rbp\n  cmp    %r13,%rbp\n  je     1281 <func0+0x101>\n  movzbl 0x0(%rbp),%eax\n  test   $0xdf,%al\n  jne    11d8 <func0+0x58>\n  lea    -0x1(%rbx),%r10d\n  mov    %r15,%rsi\n  xor    %r8d,%r8d\n  test   %r10d,%r10d\n  jle    1249 <func0+0xc9>\n  nopl   (%rax)\n  add    $0x1,%r8d\n  cmp    %ebx,%r8d\n  jge    12b0 <func0+0x130>\n  mov    %r10d,%edi\n  lea    0x1(%rsi),%r9\n  mov    %rsi,%rax\n  sub    %r8d,%edi\n  add    %r9,%rdi\n  nopl   (%rax)\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    1238 <func0+0xb8>\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\n  add    $0x1,%rax\n  cmp    %rax,%rdi\n  jne    1228 <func0+0xa8>\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    1208 <func0+0x88>\n  test   %r12d,%r12d\n  je     125a <func0+0xda>\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  movb   $0x20,(%r14,%rax,1)\n  test   %ebx,%ebx\n  je     11e1 <func0+0x61>\n  movslq %r12d,%rdi\n  movslq %ebx,%rdx\n  mov    %r15,%rsi\n  add    $0x1,%rbp\n  add    %r14,%rdi\n  add    %ebx,%r12d\n  xor    %ebx,%ebx\n  call   10a0 <memcpy@plt>\n  cmp    %r13,%rbp\n  jne    11ee <func0+0x6e>\n  movslq %r12d,%rax\n  add    %r14,%rax\n  movb   $0x0,(%rax)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12c2 <func0+0x142>\n  add    $0x48,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  lea    0x1(%rsi),%r9\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    1208 <func0+0x88>\n  jmp    1249 <func0+0xc9>\n  call   1090 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %ebx,%ebx\n  js     L0\n  mov    %ebx,%ebx\n  xor    %r12d,%r12d\n  mov    %rsp,%r15\n  lea    0x1(%rbp,%rbx,1),%r13\n  xor    %ebx,%ebx\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  movslq %ebx,%rdx\n  add    $0x1,%ebx\n  mov    %al,(%rsp,%rdx,1)\nL10:\n  add    $0x1,%rbp\n  cmp    %r13,%rbp\n  je     L2\nL1:\n  movzbl 0x0(%rbp),%eax\n  test   $0xdf,%al\n  jne    L3\n  lea    -0x1(%rbx),%r10d\n  mov    %r15,%rsi\n  xor    %r8d,%r8d\n  test   %r10d,%r10d\n  jle    L4\n  nopl   (%rax)\nL8:\n  add    $0x1,%r8d\n  cmp    %ebx,%r8d\n  jge    L5\n  mov    %r10d,%edi\n  lea    0x1(%rsi),%r9\n  mov    %rsi,%rax\n  sub    %r8d,%edi\n  add    %r9,%rdi\n  nopl   (%rax)\nL7:\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    L6\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\nL6:\n  add    $0x1,%rax\n  cmp    %rax,%rdi\n  jne    L7\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    L8\nL4:\n  test   %r12d,%r12d\n  je     L9\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  movb   $0x20,(%r14,%rax,1)\nL9:\n  test   %ebx,%ebx\n  je     L10\n  movslq %r12d,%rdi\n  movslq %ebx,%rdx\n  mov    %r15,%rsi\n  add    $0x1,%rbp\n  add    %r14,%rdi\n  add    %ebx,%r12d\n  xor    %ebx,%ebx\n  call   <memcpy@plt>\n  cmp    %r13,%rbp\n  jne    L1\nL2:\n  movslq %r12d,%rax\n  add    %r14,%rax\nL0:\n  movb   $0x0,(%rax)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L11\n  add    $0x48,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL5:\n  lea    0x1(%rsi),%r9\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    L8\n  jmp    L4\nL11:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4743
            },
            "L1": {
                "label": "L1",
                "addr": 4590
            },
            "L2": {
                "label": "L2",
                "addr": 4737
            },
            "L3": {
                "label": "L3",
                "addr": 4568
            },
            "L4": {
                "label": "L4",
                "addr": 4681
            },
            "L5": {
                "label": "L5",
                "addr": 4784
            },
            "L6": {
                "label": "L6",
                "addr": 4664
            },
            "L7": {
                "label": "L7",
                "addr": 4648
            },
            "L8": {
                "label": "L8",
                "addr": 4616
            },
            "L9": {
                "label": "L9",
                "addr": 4698
            },
            "L10": {
                "label": "L10",
                "addr": 4577
            },
            "L11": {
                "label": "L11",
                "addr": 4802
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 86,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar* func0(const char* s) {\n    int len = strlen(s);\n    char* out = malloc(len + 2); \n    char current[51];\n    int out_index = 0, current_index = 0;\n\n    for (int i = 0; i <= len; i++) {\n        if (s[i] == ' ' || s[i] == '\\0') {\n            for (int j = 0; j < current_index - 1; j++) {\n                for (int k = j + 1; k < current_index; k++) {\n                    if (current[j] > current[k]) {\n                        char temp = current[j];\n                        current[j] = current[k];\n                        current[k] = temp;\n                    }\n                }\n            }\n            if (out_index > 0) out[out_index++] = ' ';\n            for (int j = 0; j < current_index; j++) {\n                out[out_index++] = current[j];\n            }\n            current_index = 0;\n        } else {\n            current[current_index++] = s[i];\n        }\n    }\n\n    out[out_index] = '\\0';\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char* result;\n\n    result = func0(\"Hi\");\n    assert(strcmp(result, \"Hi\") == 0);\n    free(result);\n\n    result = func0(\"hello\");\n    assert(strcmp(result, \"ehllo\") == 0);\n    free(result);\n\n    result = func0(\"number\");\n    assert(strcmp(result, \"bemnru\") == 0);\n    free(result);\n\n    result = func0(\"abcd\");\n    assert(strcmp(result, \"abcd\") == 0);\n    free(result);\n\n    result = func0(\"Hello World!!!\");\n    assert(strcmp(result, \"Hello !!!Wdlor\") == 0);\n    free(result);\n\n    result = func0(\"\");\n    assert(strcmp(result, \"\") == 0);\n    free(result);\n\n    result = func0(\"Hi. My name is Mister Robot. How are you?\");\n    assert(strcmp(result, \".Hi My aemn is Meirst .Rboot How aer ?ouy\") == 0);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   1080 <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r14\n  test   %ebx,%ebx\n  js     1287 <func0+0x107>\n  mov    %ebx,%ebx\n  xor    %r12d,%r12d\n  mov    %rsp,%r15\n  lea    0x1(%rbp,%rbx,1),%r13\n  xor    %ebx,%ebx\n  jmp    11ee <func0+0x6e>\n  nopl   0x0(%rax)\n  movslq %ebx,%rdx\n  add    $0x1,%ebx\n  mov    %al,(%rsp,%rdx,1)\n  add    $0x1,%rbp\n  cmp    %r13,%rbp\n  je     1281 <func0+0x101>\n  movzbl 0x0(%rbp),%eax\n  test   $0xdf,%al\n  jne    11d8 <func0+0x58>\n  lea    -0x1(%rbx),%r10d\n  mov    %r15,%rsi\n  xor    %r8d,%r8d\n  test   %r10d,%r10d\n  jle    1249 <func0+0xc9>\n  nopl   (%rax)\n  add    $0x1,%r8d\n  cmp    %ebx,%r8d\n  jge    12b0 <func0+0x130>\n  mov    %r10d,%edi\n  lea    0x1(%rsi),%r9\n  mov    %rsi,%rax\n  sub    %r8d,%edi\n  add    %r9,%rdi\n  nopl   (%rax)\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    1238 <func0+0xb8>\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\n  add    $0x1,%rax\n  cmp    %rax,%rdi\n  jne    1228 <func0+0xa8>\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    1208 <func0+0x88>\n  test   %r12d,%r12d\n  je     125a <func0+0xda>\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  movb   $0x20,(%r14,%rax,1)\n  test   %ebx,%ebx\n  je     11e1 <func0+0x61>\n  movslq %r12d,%rdi\n  movslq %ebx,%rdx\n  mov    %r15,%rsi\n  add    $0x1,%rbp\n  add    %r14,%rdi\n  add    %ebx,%r12d\n  xor    %ebx,%ebx\n  call   10a0 <memcpy@plt>\n  cmp    %r13,%rbp\n  jne    11ee <func0+0x6e>\n  movslq %r12d,%rax\n  add    %r14,%rax\n  movb   $0x0,(%rax)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12c2 <func0+0x142>\n  add    $0x48,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  lea    0x1(%rsi),%r9\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    1208 <func0+0x88>\n  jmp    1249 <func0+0xc9>\n  call   1090 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  lea    0x2(%rax),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %ebx,%ebx\n  js     L0\n  mov    %ebx,%ebx\n  xor    %r12d,%r12d\n  mov    %rsp,%r15\n  lea    0x1(%rbp,%rbx,1),%r13\n  xor    %ebx,%ebx\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  movslq %ebx,%rdx\n  add    $0x1,%ebx\n  mov    %al,(%rsp,%rdx,1)\nL10:\n  add    $0x1,%rbp\n  cmp    %r13,%rbp\n  je     L2\nL1:\n  movzbl 0x0(%rbp),%eax\n  test   $0xdf,%al\n  jne    L3\n  lea    -0x1(%rbx),%r10d\n  mov    %r15,%rsi\n  xor    %r8d,%r8d\n  test   %r10d,%r10d\n  jle    L4\n  nopl   (%rax)\nL8:\n  add    $0x1,%r8d\n  cmp    %ebx,%r8d\n  jge    L5\n  mov    %r10d,%edi\n  lea    0x1(%rsi),%r9\n  mov    %rsi,%rax\n  sub    %r8d,%edi\n  add    %r9,%rdi\n  nopl   (%rax)\nL7:\n  movzbl (%rsi),%edx\n  movzbl 0x1(%rax),%ecx\n  cmp    %cl,%dl\n  jle    L6\n  mov    %cl,(%rsi)\n  mov    %dl,0x1(%rax)\nL6:\n  add    $0x1,%rax\n  cmp    %rax,%rdi\n  jne    L7\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    L8\nL4:\n  test   %r12d,%r12d\n  je     L9\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  movb   $0x20,(%r14,%rax,1)\nL9:\n  test   %ebx,%ebx\n  je     L10\n  movslq %r12d,%rdi\n  movslq %ebx,%rdx\n  mov    %r15,%rsi\n  add    $0x1,%rbp\n  add    %r14,%rdi\n  add    %ebx,%r12d\n  xor    %ebx,%ebx\n  call   <memcpy@plt>\n  cmp    %r13,%rbp\n  jne    L1\nL2:\n  movslq %r12d,%rax\n  add    %r14,%rax\nL0:\n  movb   $0x0,(%rax)\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L11\n  add    $0x48,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL5:\n  lea    0x1(%rsi),%r9\n  mov    %r9,%rsi\n  cmp    %r10d,%r8d\n  jne    L8\n  jmp    L4\nL11:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4743
            },
            "L1": {
                "label": "L1",
                "addr": 4590
            },
            "L2": {
                "label": "L2",
                "addr": 4737
            },
            "L3": {
                "label": "L3",
                "addr": 4568
            },
            "L4": {
                "label": "L4",
                "addr": 4681
            },
            "L5": {
                "label": "L5",
                "addr": 4784
            },
            "L6": {
                "label": "L6",
                "addr": 4664
            },
            "L7": {
                "label": "L7",
                "addr": 4648
            },
            "L8": {
                "label": "L8",
                "addr": 4616
            },
            "L9": {
                "label": "L9",
                "addr": 4698
            },
            "L10": {
                "label": "L10",
                "addr": 4577
            },
            "L11": {
                "label": "L11",
                "addr": 4802
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 87,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    %ecx,-0x40(%rbp)\n  mov    %r8,-0x50(%rbp)\n  mov    $0x320,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  jmp    1218 <func0+0xff>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x1c(%rbp)\n  jmp    120a <func0+0xf1>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x40(%rbp)\n  jne    1206 <func0+0xed>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x24(%rbp)\n  subl   $0x1,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jns    117a <func0+0x61>\n  addl   $0x1,-0x20(%rbp)\n  mov    -0x20(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     1159 <func0+0x40>\n  mov    -0x50(%rbp),%rax\n  mov    -0x24(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    %ecx,-0x40(%rbp)\n  mov    %r8,-0x50(%rbp)\n  mov    $0x320,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  jmp    L0\nL4:\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x1c(%rbp)\n  jmp    L1\nL3:\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x40(%rbp)\n  jne    L2\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x20(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x24(%rbp)\nL2:\n  subl   $0x1,-0x1c(%rbp)\nL1:\n  cmpl   $0x0,-0x1c(%rbp)\n  jns    L3\n  addl   $0x1,-0x20(%rbp)\nL0:\n  mov    -0x20(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L4\n  mov    -0x50(%rbp),%rax\n  mov    -0x24(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4632
            },
            "L1": {
                "label": "L1",
                "addr": 4618
            },
            "L2": {
                "label": "L2",
                "addr": 4614
            },
            "L3": {
                "label": "L3",
                "addr": 4474
            },
            "L4": {
                "label": "L4",
                "addr": 4441
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 87,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%r12\n  mov    %esi,%ebx\n  mov    %rdx,0x18(%rsp)\n  mov    %ecx,%r13d\n  mov    %r8,0x28(%rsp)\n  mov    $0x320,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  test   %ebx,%ebx\n  jle    11d5 <func0+0xbc>\n  mov    %ebx,%eax\n  mov    %rax,0x20(%rsp)\n  mov    $0x0,%r15d\n  mov    $0x0,%r14d\n  jmp    11b3 <func0+0x9a>\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  movslq %r14d,%rdx\n  mov    0x10(%rsp),%rcx\n  mov    %rax,(%rcx,%rdx,8)\n  mov    0x8(%rsp),%esi\n  mov    %esi,(%rax)\n  mov    %ebx,0x4(%rax)\n  add    $0x1,%r14d\n  sub    $0x1,%ebx\n  sub    $0x4,%rbp\n  cmp    $0xffffffff,%ebx\n  je     11a4 <func0+0x8b>\n  mov    (%r12),%rax\n  cmp    %r13d,(%rax,%rbp,1)\n  jne    118c <func0+0x73>\n  jmp    1169 <func0+0x50>\n  add    $0x1,%r15\n  add    $0x8,%r12\n  cmp    0x20(%rsp),%r15\n  je     11db <func0+0xc2>\n  mov    %r15d,0x8(%rsp)\n  mov    0x18(%rsp),%rax\n  mov    (%rax,%r15,4),%eax\n  mov    %eax,0xc(%rsp)\n  mov    %eax,%ebx\n  sub    $0x1,%ebx\n  js     11a4 <func0+0x8b>\n  movslq %ebx,%rbp\n  shl    $0x2,%rbp\n  jmp    1198 <func0+0x7f>\n  mov    $0x0,%r14d\n  mov    0x28(%rsp),%rax\n  mov    %r14d,(%rax)\n  mov    0x10(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%r12\n  mov    %esi,%ebx\n  mov    %rdx,0x18(%rsp)\n  mov    %ecx,%r13d\n  mov    %r8,0x28(%rsp)\n  mov    $0x320,%edi\n  call   <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  test   %ebx,%ebx\n  jle    L0\n  mov    %ebx,%eax\n  mov    %rax,0x20(%rsp)\n  mov    $0x0,%r15d\n  mov    $0x0,%r14d\n  jmp    L1\nL4:\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  movslq %r14d,%rdx\n  mov    0x10(%rsp),%rcx\n  mov    %rax,(%rcx,%rdx,8)\n  mov    0x8(%rsp),%esi\n  mov    %esi,(%rax)\n  mov    %ebx,0x4(%rax)\n  add    $0x1,%r14d\nL3:\n  sub    $0x1,%ebx\n  sub    $0x4,%rbp\n  cmp    $0xffffffff,%ebx\n  je     L2\nL6:\n  mov    (%r12),%rax\n  cmp    %r13d,(%rax,%rbp,1)\n  jne    L3\n  jmp    L4\nL2:\n  add    $0x1,%r15\n  add    $0x8,%r12\n  cmp    0x20(%rsp),%r15\n  je     L5\nL1:\n  mov    %r15d,0x8(%rsp)\n  mov    0x18(%rsp),%rax\n  mov    (%rax,%r15,4),%eax\n  mov    %eax,0xc(%rsp)\n  mov    %eax,%ebx\n  sub    $0x1,%ebx\n  js     L2\n  movslq %ebx,%rbp\n  shl    $0x2,%rbp\n  jmp    L6\nL0:\n  mov    $0x0,%r14d\nL5:\n  mov    0x28(%rsp),%rax\n  mov    %r14d,(%rax)\n  mov    0x10(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4565
            },
            "L1": {
                "label": "L1",
                "addr": 4531
            },
            "L2": {
                "label": "L2",
                "addr": 4516
            },
            "L3": {
                "label": "L3",
                "addr": 4492
            },
            "L4": {
                "label": "L4",
                "addr": 4457
            },
            "L5": {
                "label": "L5",
                "addr": 4571
            },
            "L6": {
                "label": "L6",
                "addr": 4504
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 87,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %ecx,%r14d\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x20(%rsp)\n  mov    $0x320,%edi\n  mov    %rdx,0x10(%rsp)\n  mov    %r8,0x28(%rsp)\n  call   1050 <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  test   %ebp,%ebp\n  jle    11ff <func0+0xdf>\n  movslq %ebp,%rax\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  mov    %rax,0x18(%rsp)\n  nopw   0x0(%rax,%rax,1)\n  mov    0x10(%rsp),%rax\n  mov    %ebp,%ebx\n  mov    (%rax,%rbp,4),%eax\n  mov    %eax,%edx\n  mov    %eax,0x4(%rsp)\n  sub    $0x1,%edx\n  js     11d8 <func0+0xb8>\n  mov    0x20(%rsp),%rax\n  movslq %edx,%r12\n  mov    (%rax,%rbp,8),%r13\n  jmp    11a1 <func0+0x81>\n  nopl   0x0(%rax,%rax,1)\n  sub    $0x1,%r12\n  test   %r12d,%r12d\n  js     11d8 <func0+0xb8>\n  cmp    %r14d,0x0(%r13,%r12,4)\n  jne    1198 <func0+0x78>\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  mov    0x8(%rsp),%rcx\n  movslq %r15d,%rdi\n  add    $0x1,%r15d\n  mov    %r12d,0x4(%rax)\n  sub    $0x1,%r12\n  mov    %rax,(%rcx,%rdi,8)\n  mov    %ebx,(%rax)\n  test   %r12d,%r12d\n  jns    11a1 <func0+0x81>\n  nopl   0x0(%rax)\n  add    $0x1,%rbp\n  cmp    0x18(%rsp),%rbp\n  jne    1170 <func0+0x50>\n  mov    0x28(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x8(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xor    %r15d,%r15d\n  jmp    11e3 <func0+0xc3>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %ecx,%r14d\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x20(%rsp)\n  mov    $0x320,%edi\n  mov    %rdx,0x10(%rsp)\n  mov    %r8,0x28(%rsp)\n  call   <malloc@plt>\n  mov    %rax,0x8(%rsp)\n  test   %ebp,%ebp\n  jle    L0\n  movslq %ebp,%rax\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  mov    %rax,0x18(%rsp)\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    0x10(%rsp),%rax\n  mov    %ebp,%ebx\n  mov    (%rax,%rbp,4),%eax\n  mov    %eax,%edx\n  mov    %eax,0x4(%rsp)\n  sub    $0x1,%edx\n  js     L1\n  mov    0x20(%rsp),%rax\n  movslq %edx,%r12\n  mov    (%rax,%rbp,8),%r13\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL3:\n  sub    $0x1,%r12\n  test   %r12d,%r12d\n  js     L1\nL2:\n  cmp    %r14d,0x0(%r13,%r12,4)\n  jne    L3\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    0x8(%rsp),%rcx\n  movslq %r15d,%rdi\n  add    $0x1,%r15d\n  mov    %r12d,0x4(%rax)\n  sub    $0x1,%r12\n  mov    %rax,(%rcx,%rdi,8)\n  mov    %ebx,(%rax)\n  test   %r12d,%r12d\n  jns    L2\n  nopl   0x0(%rax)\nL1:\n  add    $0x1,%rbp\n  cmp    0x18(%rsp),%rbp\n  jne    L4\nL5:\n  mov    0x28(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x8(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  xor    %r15d,%r15d\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4607
            },
            "L1": {
                "label": "L1",
                "addr": 4568
            },
            "L2": {
                "label": "L2",
                "addr": 4513
            },
            "L3": {
                "label": "L3",
                "addr": 4504
            },
            "L4": {
                "label": "L4",
                "addr": 4464
            },
            "L5": {
                "label": "L5",
                "addr": 4579
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 87,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint **func0(int **lst, int lst_size, int *row_sizes, int x, int *return_size) {\n    int **out = (int **)malloc(100 * sizeof(int *));\n    int count = 0;\n    for (int i = 0; i < lst_size; i++) {\n        for (int j = row_sizes[i] - 1; j >= 0; j--) {\n            if (lst[i][j] == x) {\n                out[count] = (int *)malloc(2 * sizeof(int));\n                out[count][0] = i;\n                out[count][1] = j;\n                count++;\n            }\n        }\n    }\n    *return_size = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int **a, int aSize, int **b, int bSize) {\n    if (aSize != bSize) return 0;\n\n    for (int i = 0; i < aSize; i++) {\n        if (a[i][0] != b[i][0] || a[i][1] != b[i][1]) return 0;\n    }\n    return 1;\n}\n\nvoid free_result(int **result, int size) {\n    for (int i = 0; i < size; ++i) {\n        free(result[i]);\n    }\n    free(result);\n}\n\nint main() {\n    int rows, returnSize;\n    int **result;\n\n    // Test case 1\n    rows = 3;\n    int cols1[] = {6, 6, 6};\n    int *lst1[] = {(const int[]){1,2,3,4,5,6}, (const int[]){1,2,3,4,1,6}, (const int[]){1,2,3,4,5,1}};\n    int *expected1[] = {(const int[]){0, 0}, (const int[]){1, 4}, (const int[]){1, 0}, (const int[]){2, 5}, (const int[]){2, 0}};\n    result = func0(lst1, rows, cols1, 1, &returnSize);\n    assert(issame(result, returnSize, expected1, 5));\n    free_result(result, returnSize);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %ecx,%r14d\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x20(%rsp)\n  mov    $0x320,%edi\n  mov    %r8,0x28(%rsp)\n  call   1050 <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  test   %ebp,%ebp\n  jle    121b <func0+0xfb>\n  movslq %ebp,%rax\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  mov    %rax,0x18(%rsp)\n  nopl   0x0(%rax,%rax,1)\n  mov    0x0(%r13,%rbp,4),%ebx\n  movd   %ebp,%xmm1\n  sub    $0x1,%ebx\n  js     11f0 <func0+0xd0>\n  mov    0x20(%rsp),%rax\n  movslq %ebx,%rbx\n  mov    (%rax,%rbp,8),%r12\n  jmp    1198 <func0+0x78>\n  nopl   0x0(%rax)\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     11f0 <func0+0xd0>\n  movdqa %xmm1,%xmm0\n  movd   %ebx,%xmm2\n  punpckldq %xmm2,%xmm0\n  cmp    %r14d,(%r12,%rbx,4)\n  jne    1190 <func0+0x70>\n  mov    $0x8,%edi\n  movq   %xmm0,0x8(%rsp)\n  sub    $0x1,%rbx\n  movd   %xmm1,0x4(%rsp)\n  call   1050 <malloc@plt>\n  mov    0x10(%rsp),%rdx\n  movslq %r15d,%rdi\n  movq   0x8(%rsp),%xmm0\n  movd   0x4(%rsp),%xmm1\n  add    $0x1,%r15d\n  mov    %rax,(%rdx,%rdi,8)\n  movq   %xmm0,(%rax)\n  test   %ebx,%ebx\n  jns    1198 <func0+0x78>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rbp\n  cmp    %rbp,0x18(%rsp)\n  jne    1170 <func0+0x50>\n  mov    0x28(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x10(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xor    %r15d,%r15d\n  jmp    11ff <func0+0xdf>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %ecx,%r14d\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x20(%rsp)\n  mov    $0x320,%edi\n  mov    %r8,0x28(%rsp)\n  call   <malloc@plt>\n  mov    %rax,0x10(%rsp)\n  test   %ebp,%ebp\n  jle    L0\n  movslq %ebp,%rax\n  xor    %r15d,%r15d\n  xor    %ebp,%ebp\n  mov    %rax,0x18(%rsp)\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    0x0(%r13,%rbp,4),%ebx\n  movd   %ebp,%xmm1\n  sub    $0x1,%ebx\n  js     L1\n  mov    0x20(%rsp),%rax\n  movslq %ebx,%rbx\n  mov    (%rax,%rbp,8),%r12\n  jmp    L2\n  nopl   0x0(%rax)\nL3:\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     L1\nL2:\n  movdqa %xmm1,%xmm0\n  movd   %ebx,%xmm2\n  punpckldq %xmm2,%xmm0\n  cmp    %r14d,(%r12,%rbx,4)\n  jne    L3\n  mov    $0x8,%edi\n  movq   %xmm0,0x8(%rsp)\n  sub    $0x1,%rbx\n  movd   %xmm1,0x4(%rsp)\n  call   <malloc@plt>\n  mov    0x10(%rsp),%rdx\n  movslq %r15d,%rdi\n  movq   0x8(%rsp),%xmm0\n  movd   0x4(%rsp),%xmm1\n  add    $0x1,%r15d\n  mov    %rax,(%rdx,%rdi,8)\n  movq   %xmm0,(%rax)\n  test   %ebx,%ebx\n  jns    L2\n  nopl   0x0(%rax,%rax,1)\nL1:\n  add    $0x1,%rbp\n  cmp    %rbp,0x18(%rsp)\n  jne    L4\nL5:\n  mov    0x28(%rsp),%rax\n  mov    %r15d,(%rax)\n  mov    0x10(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  xor    %r15d,%r15d\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4635
            },
            "L1": {
                "label": "L1",
                "addr": 4592
            },
            "L2": {
                "label": "L2",
                "addr": 4504
            },
            "L3": {
                "label": "L3",
                "addr": 4496
            },
            "L4": {
                "label": "L4",
                "addr": 4464
            },
            "L5": {
                "label": "L5",
                "addr": 4607
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 88,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %rcx,-0x40(%rbp)\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  cmpl   $0x0,-0x2c(%rbp)\n  jne    1173 <func0+0x3a>\n  mov    -0x38(%rbp),%rax\n  movq   $0x0,(%rax)\n  jmp    137c <func0+0x243>\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1060 <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rax\n  test   %rax,%rax\n  jne    11a4 <func0+0x6b>\n  mov    $0x1,%edi\n  call   1070 <exit@plt>\n  movl   $0x0,-0x18(%rbp)\n  jmp    11dd <func0+0xa4>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     11ad <func0+0x74>\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%edx\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    136d <func0+0x234>\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    135d <func0+0x224>\n  cmpl   $0x0,-0xc(%rbp)\n  je     12d0 <func0+0x197>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    1359 <func0+0x220>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    1359 <func0+0x220>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    1359 <func0+0x220>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1234 <func0+0xfb>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     1226 <func0+0xed>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %rcx,-0x40(%rbp)\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  cmpl   $0x0,-0x2c(%rbp)\n  jne    L0\n  mov    -0x38(%rbp),%rax\n  movq   $0x0,(%rax)\n  jmp    L1\nL0:\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rax\n  test   %rax,%rax\n  jne    L2\n  mov    $0x1,%edi\n  call   <exit@plt>\nL2:\n  movl   $0x0,-0x18(%rbp)\n  jmp    L3\nL4:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x18(%rbp)\nL3:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L4\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%edx\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  mov    %eax,-0xc(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L5\nL10:\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    L6\nL9:\n  cmpl   $0x0,-0xc(%rbp)\n  je     L7\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L8\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    L8\nL7:\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L8\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\nL8:\n  addl   $0x1,-0x10(%rbp)\nL6:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L9\n  addl   $0x1,-0x14(%rbp)\nL5:\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     L10\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4467
            },
            "L1": {
                "label": "L1",
                "addr": 4988
            },
            "L2": {
                "label": "L2",
                "addr": 4516
            },
            "L3": {
                "label": "L3",
                "addr": 4573
            },
            "L4": {
                "label": "L4",
                "addr": 4525
            },
            "L5": {
                "label": "L5",
                "addr": 4973
            },
            "L6": {
                "label": "L6",
                "addr": 4957
            },
            "L7": {
                "label": "L7",
                "addr": 4816
            },
            "L8": {
                "label": "L8",
                "addr": 4953
            },
            "L9": {
                "label": "L9",
                "addr": 4660
            },
            "L10": {
                "label": "L10",
                "addr": 4646
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 88,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdx,%rbx\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    1162 <func0+0x29>\n  movq   $0x0,(%rdx)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  movslq %esi,%r13\n  shl    $0x2,%r13\n  mov    %r13,%rdi\n  call   1060 <malloc@plt>\n  mov    %rax,(%rbx)\n  test   %rax,%rax\n  je     11d5 <func0+0x9c>\n  mov    %ebp,%esi\n  shl    $0x2,%rsi\n  mov    $0x0,%eax\n  test   %ebp,%ebp\n  jle    11a0 <func0+0x67>\n  mov    (%r12,%rax,1),%ecx\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  jne    118d <func0+0x54>\n  mov    (%r12),%eax\n  add    -0x4(%r12,%r13,1),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%r9d\n  and    $0x1,%r9d\n  sub    %edx,%r9d\n  cmp    $0x1,%ebp\n  jle    1157 <func0+0x1e>\n  lea    -0x1(%rbp),%r12d\n  mov    $0x0,%edi\n  mov    $0x0,%r11d\n  mov    $0x0,%r10d\n  jmp    1231 <func0+0xf8>\n  mov    $0x1,%edi\n  call   1070 <exit@plt>\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rdi,1),%rsi\n  mov    (%rsi),%ecx\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%ecx\n  jle    11f7 <func0+0xbe>\n  mov    %edx,(%rsi)\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  je     1220 <func0+0xe7>\n  cmp    $0x1,%r9d\n  je     11df <func0+0xa6>\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rdi,1),%rsi\n  mov    (%rsi),%ecx\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%ecx\n  jge    11f7 <func0+0xbe>\n  mov    %edx,(%rsi)\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\n  jmp    11f7 <func0+0xbe>\n  add    $0x1,%r11\n  add    $0x4,%rdi\n  cmp    %r12d,%r10d\n  je     1157 <func0+0x1e>\n  add    $0x1,%r10d\n  cmp    %r10d,%ebp\n  jle    1220 <func0+0xe7>\n  lea    0x4(%rdi),%rax\n  mov    %r12d,%edx\n  sub    %r10d,%edx\n  lea    0x2(%r11,%rdx,1),%r8\n  shl    $0x2,%r8\n  jmp    1200 <func0+0xc7>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdx,%rbx\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    L0\n  movq   $0x0,(%rdx)\nL4:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL0:\n  mov    %rdi,%r12\n  mov    %esi,%ebp\n  movslq %esi,%r13\n  shl    $0x2,%r13\n  mov    %r13,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  test   %rax,%rax\n  je     L1\n  mov    %ebp,%esi\n  shl    $0x2,%rsi\n  mov    $0x0,%eax\n  test   %ebp,%ebp\n  jle    L2\nL3:\n  mov    (%r12,%rax,1),%ecx\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  jne    L3\nL2:\n  mov    (%r12),%eax\n  add    -0x4(%r12,%r13,1),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%r9d\n  and    $0x1,%r9d\n  sub    %edx,%r9d\n  cmp    $0x1,%ebp\n  jle    L4\n  lea    -0x1(%rbp),%r12d\n  mov    $0x0,%edi\n  mov    $0x0,%r11d\n  mov    $0x0,%r10d\n  jmp    L5\nL1:\n  mov    $0x1,%edi\n  call   <exit@plt>\nL8:\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rdi,1),%rsi\n  mov    (%rsi),%ecx\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%ecx\n  jle    L6\n  mov    %edx,(%rsi)\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\nL6:\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  je     L7\nL9:\n  cmp    $0x1,%r9d\n  je     L8\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rdi,1),%rsi\n  mov    (%rsi),%ecx\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%ecx\n  jge    L6\n  mov    %edx,(%rsi)\n  mov    (%rbx),%rdx\n  mov    %ecx,(%rdx,%rax,1)\n  jmp    L6\nL7:\n  add    $0x1,%r11\n  add    $0x4,%rdi\n  cmp    %r12d,%r10d\n  je     L4\nL5:\n  add    $0x1,%r10d\n  cmp    %r10d,%ebp\n  jle    L7\n  lea    0x4(%rdi),%rax\n  mov    %r12d,%edx\n  sub    %r10d,%edx\n  lea    0x2(%r11,%rdx,1),%r8\n  shl    $0x2,%r8\n  jmp    L9",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4450
            },
            "L1": {
                "label": "L1",
                "addr": 4565
            },
            "L2": {
                "label": "L2",
                "addr": 4512
            },
            "L3": {
                "label": "L3",
                "addr": 4493
            },
            "L4": {
                "label": "L4",
                "addr": 4439
            },
            "L5": {
                "label": "L5",
                "addr": 4657
            },
            "L6": {
                "label": "L6",
                "addr": 4599
            },
            "L7": {
                "label": "L7",
                "addr": 4640
            },
            "L8": {
                "label": "L8",
                "addr": 4575
            },
            "L9": {
                "label": "L9",
                "addr": 4608
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 88,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    1190 <func0+0x30>\n  movq   $0x0,(%rdx)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\n  movslq %esi,%r13\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  shl    $0x2,%r13\n  mov    %r13,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,(%r12)\n  mov    %rax,%r10\n  test   %rax,%rax\n  je     1268 <func0+0x108>\n  test   %ebx,%ebx\n  jle    11c9 <func0+0x69>\n  mov    %r13,%rdx\n  mov    %rbp,%rsi\n  mov    %rax,%rdi\n  call   1070 <memcpy@plt>\n  mov    %rax,%r10\n  mov    0x0(%rbp),%eax\n  add    -0x4(%rbp,%r13,1),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%edi\n  and    $0x1,%edi\n  sub    %edx,%edi\n  cmp    $0x1,%ebx\n  jle    117e <func0+0x1e>\n  lea    -0x2(%rbx),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r9d\n  add    $0x8,%r10\n  add    $0x2,%r11\n  lea    -0x1(%rbx),%ebp\n  nopl   0x0(%rax)\n  cmp    %r9d,%ebx\n  jle    1250 <func0+0xf0>\n  mov    %ebp,%eax\n  sub    %r9d,%eax\n  lea    -0x1(%r9,%rax,1),%rax\n  lea    (%r10,%rax,4),%r8\n  mov    %rsi,%rax\n  jmp    1232 <func0+0xd2>\n  nopl   0x0(%rax,%rax,1)\n  cmp    %ecx,%edx\n  jge    1229 <func0+0xc9>\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%r8\n  je     1250 <func0+0xf0>\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    $0x1,%edi\n  jne    1220 <func0+0xc0>\n  cmp    %ecx,%edx\n  jg     1224 <func0+0xc4>\n  add    $0x4,%rax\n  cmp    %rax,%r8\n  jne    1232 <func0+0xd2>\n  nopl   0x0(%rax)\n  add    $0x1,%r9\n  add    $0x4,%rsi\n  cmp    %r11,%r9\n  jne    1200 <func0+0xa0>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  mov    $0x1,%edi\n  call   1090 <exit@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    L0\n  movq   $0x0,(%rdx)\nL3:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\nL0:\n  movslq %esi,%r13\n  mov    %rdi,%rbp\n  mov    %esi,%ebx\n  shl    $0x2,%r13\n  mov    %r13,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%r12)\n  mov    %rax,%r10\n  test   %rax,%rax\n  je     L1\n  test   %ebx,%ebx\n  jle    L2\n  mov    %r13,%rdx\n  mov    %rbp,%rsi\n  mov    %rax,%rdi\n  call   <memcpy@plt>\n  mov    %rax,%r10\nL2:\n  mov    0x0(%rbp),%eax\n  add    -0x4(%rbp,%r13,1),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%edi\n  and    $0x1,%edi\n  sub    %edx,%edi\n  cmp    $0x1,%ebx\n  jle    L3\n  lea    -0x2(%rbx),%r11d\n  lea    0x4(%r10),%rsi\n  mov    $0x1,%r9d\n  add    $0x8,%r10\n  add    $0x2,%r11\n  lea    -0x1(%rbx),%ebp\n  nopl   0x0(%rax)\nL9:\n  cmp    %r9d,%ebx\n  jle    L4\n  mov    %ebp,%eax\n  sub    %r9d,%eax\n  lea    -0x1(%r9,%rax,1),%rax\n  lea    (%r10,%rax,4),%r8\n  mov    %rsi,%rax\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL7:\n  cmp    %ecx,%edx\n  jge    L6\nL8:\n  mov    %ecx,-0x4(%rsi)\n  mov    %edx,(%rax)\nL6:\n  add    $0x4,%rax\n  cmp    %rax,%r8\n  je     L4\nL5:\n  mov    -0x4(%rsi),%edx\n  mov    (%rax),%ecx\n  cmp    $0x1,%edi\n  jne    L7\n  cmp    %ecx,%edx\n  jg     L8\n  add    $0x4,%rax\n  cmp    %rax,%r8\n  jne    L5\n  nopl   0x0(%rax)\nL4:\n  add    $0x1,%r9\n  add    $0x4,%rsi\n  cmp    %r11,%r9\n  jne    L9\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL1:\n  mov    $0x1,%edi\n  call   <exit@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4496
            },
            "L1": {
                "label": "L1",
                "addr": 4712
            },
            "L2": {
                "label": "L2",
                "addr": 4553
            },
            "L3": {
                "label": "L3",
                "addr": 4478
            },
            "L4": {
                "label": "L4",
                "addr": 4688
            },
            "L5": {
                "label": "L5",
                "addr": 4658
            },
            "L6": {
                "label": "L6",
                "addr": 4649
            },
            "L7": {
                "label": "L7",
                "addr": 4640
            },
            "L8": {
                "label": "L8",
                "addr": 4644
            },
            "L9": {
                "label": "L9",
                "addr": 4608
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 88,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *array, int size, int **out_array, int *out_size) {\n    *out_size = size;\n    if (size == 0) {\n        *out_array = NULL;\n        return;\n    }\n\n    *out_array = (int *)malloc(sizeof(int) * size);\n    if (*out_array == NULL) {\n        exit(1);\n    }\n\n    for (int i = 0; i < size; i++) {\n        (*out_array)[i] = array[i];\n    }\n\n    int shouldSortAscending = (array[0] + array[size - 1]) % 2 == 1;\n\n    for (int i = 0; i < size - 1; i++) {\n        for (int j = i + 1; j < size; j++) {\n            if (shouldSortAscending) {\n                if ((*out_array)[i] > (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            } else {\n                if ((*out_array)[i] < (*out_array)[j]) {\n                    int temp = (*out_array)[i];\n                    (*out_array)[i] = (*out_array)[j];\n                    (*out_array)[j] = temp;\n                }\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int *a, int aSize, int *b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result, result_size;\n\n    func0((const int[]){}, 0, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){}, 0));\n    free(result);\n\n    func0((const int[]){5}, 1, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){5}, 1));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 1, 2, 3, 4, 5}, 6));\n    free(result);\n\n    func0((const int[]){2, 4, 3, 0, 1, 5, 6}, 7, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){6, 5, 4, 3, 2, 1, 0}, 7));\n    free(result);\n\n    func0((const int[]){2, 1}, 2, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){1, 2}, 2));\n    free(result);\n\n    func0((const int[]){15, 42, 87, 32, 11, 0}, 6, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){0, 11, 15, 32, 42, 87}, 6));\n    free(result);\n\n    func0((const int[]){21, 14, 23, 11}, 4, &result, &result_size);\n    assert(issame(result, result_size, (const int[]){23, 21, 14, 11}, 4));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    1188 <func0+0x28>\n  movq   $0x0,(%rdx)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   (%rax)\n  movslq %esi,%r14\n  mov    %rdi,%r12\n  mov    %esi,%ebx\n  shl    $0x2,%r14\n  mov    %r14,%rdi\n  call   1080 <malloc@plt>\n  mov    %rax,0x0(%r13)\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     1269 <func0+0x109>\n  test   %ebx,%ebx\n  jle    11be <func0+0x5e>\n  mov    %r14,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  call   1070 <memcpy@plt>\n  mov    (%r12),%eax\n  add    -0x4(%r12,%r14,1),%eax\n  lea    -0x1(%rbx),%r12d\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%r11d\n  and    $0x1,%r11d\n  sub    %edx,%r11d\n  test   %r12d,%r12d\n  jle    117c <func0+0x1c>\n  lea    0x4(%rbp),%rdx\n  lea    -0x2(%rbx),%r10d\n  xor    %r9d,%r9d\n  xor    %r8d,%r8d\n  add    $0x8,%rbp\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jle    122f <func0+0xcf>\n  mov    %r10d,%eax\n  add    %r9,%rax\n  lea    0x0(%rbp,%rax,4),%rdi\n  mov    %rdx,%rax\n  cmp    $0x1,%r11d\n  je     1250 <func0+0xf0>\n  nopl   (%rax)\n  mov    -0x4(%rdx),%ecx\n  mov    (%rax),%esi\n  cmp    %ecx,%esi\n  jle    1226 <func0+0xc6>\n  mov    %esi,-0x4(%rdx)\n  mov    %ecx,(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    1218 <func0+0xb8>\n  add    $0x1,%r9\n  add    $0x4,%rdx\n  sub    $0x1,%r10d\n  cmp    %r12d,%r8d\n  jne    11f8 <func0+0x98>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\n  mov    -0x4(%rdx),%ecx\n  mov    (%rax),%esi\n  cmp    %esi,%ecx\n  jle    125e <func0+0xfe>\n  mov    %esi,-0x4(%rdx)\n  mov    %ecx,(%rax)\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    1250 <func0+0xf0>\n  jmp    122f <func0+0xcf>\n  mov    $0x1,%edi\n  call   1090 <exit@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %esi,(%rcx)\n  test   %esi,%esi\n  jne    L0\n  movq   $0x0,(%rdx)\nL3:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   (%rax)\nL0:\n  movslq %esi,%r14\n  mov    %rdi,%r12\n  mov    %esi,%ebx\n  shl    $0x2,%r14\n  mov    %r14,%rdi\n  call   <malloc@plt>\n  mov    %rax,0x0(%r13)\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     L1\n  test   %ebx,%ebx\n  jle    L2\n  mov    %r14,%rdx\n  mov    %r12,%rsi\n  mov    %rax,%rdi\n  call   <memcpy@plt>\nL2:\n  mov    (%r12),%eax\n  add    -0x4(%r12,%r14,1),%eax\n  lea    -0x1(%rbx),%r12d\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  lea    (%rax,%rdx,1),%r11d\n  and    $0x1,%r11d\n  sub    %edx,%r11d\n  test   %r12d,%r12d\n  jle    L3\n  lea    0x4(%rbp),%rdx\n  lea    -0x2(%rbx),%r10d\n  xor    %r9d,%r9d\n  xor    %r8d,%r8d\n  add    $0x8,%rbp\n  nopw   0x0(%rax,%rax,1)\nL8:\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jle    L4\n  mov    %r10d,%eax\n  add    %r9,%rax\n  lea    0x0(%rbp,%rax,4),%rdi\n  mov    %rdx,%rax\n  cmp    $0x1,%r11d\n  je     L5\n  nopl   (%rax)\nL7:\n  mov    -0x4(%rdx),%ecx\n  mov    (%rax),%esi\n  cmp    %ecx,%esi\n  jle    L6\n  mov    %esi,-0x4(%rdx)\n  mov    %ecx,(%rax)\nL6:\n  add    $0x4,%rax\n  cmp    %rax,%rdi\n  jne    L7\nL4:\n  add    $0x1,%r9\n  add    $0x4,%rdx\n  sub    $0x1,%r10d\n  cmp    %r12d,%r8d\n  jne    L8\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax)\nL5:\n  mov    -0x4(%rdx),%ecx\n  mov    (%rax),%esi\n  cmp    %esi,%ecx\n  jle    L9\n  mov    %esi,-0x4(%rdx)\n  mov    %ecx,(%rax)\nL9:\n  add    $0x4,%rax\n  cmp    %rdi,%rax\n  jne    L5\n  jmp    L4\nL1:\n  mov    $0x1,%edi\n  call   <exit@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4488
            },
            "L1": {
                "label": "L1",
                "addr": 4713
            },
            "L2": {
                "label": "L2",
                "addr": 4542
            },
            "L3": {
                "label": "L3",
                "addr": 4476
            },
            "L4": {
                "label": "L4",
                "addr": 4655
            },
            "L5": {
                "label": "L5",
                "addr": 4688
            },
            "L6": {
                "label": "L6",
                "addr": 4646
            },
            "L7": {
                "label": "L7",
                "addr": 4632
            },
            "L8": {
                "label": "L8",
                "addr": 4600
            },
            "L9": {
                "label": "L9",
                "addr": 4702
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 89,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1163 <func0+0x6a>\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  lea    -0x5d(%rax),%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x3,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x61,%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x4(%rbp),%edx\n  mov    %dl,(%rax)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1112 <func0+0x19>\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL1:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  lea    -0x5d(%rax),%edx\n  movslq %edx,%rax\n  imul   $0x4ec4ec4f,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x3,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  imul   $0x1a,%eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  add    $0x61,%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x4(%rbp),%edx\n  mov    %dl,(%rax)\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L1\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4451
            },
            "L1": {
                "label": "L1",
                "addr": 4370
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 89,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     1144 <func0+0x4b>\n  mov    $0x0,%ecx\n  movsbl %al,%eax\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x23,%rdx\n  mov    %eax,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movzbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    110c <func0+0x13>\n  movb   $0x0,(%rsi,%rcx,1)\n  ret\n  mov    $0x0,%ecx\n  jmp    113f <func0+0x46>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  mov    $0x0,%ecx\nL1:\n  movsbl %al,%eax\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x23,%rdx\n  mov    %eax,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movzbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    L1\nL2:\n  movb   $0x0,(%rsi,%rcx,1)\n  ret\nL0:\n  mov    $0x0,%ecx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4420
            },
            "L1": {
                "label": "L1",
                "addr": 4364
            },
            "L2": {
                "label": "L2",
                "addr": 4415
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 89,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  mov    %rdi,%r8\n  test   %al,%al\n  je     1143 <func0+0x43>\n  xor    %ecx,%ecx\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  mov    %eax,%edi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%edi\n  sar    $0x23,%rdx\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movsbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    1110 <func0+0x10>\n  add    %rcx,%rsi\n  movb   $0x0,(%rsi)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  mov    %rdi,%r8\n  test   %al,%al\n  je     L0\n  xor    %ecx,%ecx\nL1:\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  mov    %eax,%edi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%edi\n  sar    $0x23,%rdx\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movsbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    L1\n  add    %rcx,%rsi\nL0:\n  movb   $0x0,(%rsi)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4419
            },
            "L1": {
                "label": "L1",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 89,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *s, char *out) {\n    int i;\n    for (i = 0; s[i] != '\\0'; i++) {\n        int w = ((int)s[i] - 'a' + 4) % 26 + 'a';\n        out[i] = (char)w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    char encrypted[100]; // Buffer should be large enough to hold the encrypted string\n\n    func0(\"hi\", encrypted);\n    assert(strcmp(encrypted, \"lm\") == 0);\n\n    func0(\"asdfghjkl\", encrypted);\n    assert(strcmp(encrypted, \"ewhjklnop\") == 0);\n\n    func0(\"gf\", encrypted);\n    assert(strcmp(encrypted, \"kj\") == 0);\n\n    func0(\"et\", encrypted);\n    assert(strcmp(encrypted, \"ix\") == 0);\n\n    func0(\"faewfawefaewg\", encrypted);\n    assert(strcmp(encrypted, \"jeiajeaijeiak\") == 0);\n\n    func0(\"hellomyfriend\", encrypted);\n    assert(strcmp(encrypted, \"lippsqcjvmirh\") == 0);\n\n    func0(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\", encrypted);\n    assert(strcmp(encrypted, \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\") == 0);\n\n    func0(\"a\", encrypted);\n    assert(strcmp(encrypted, \"e\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  mov    %rdi,%r8\n  test   %al,%al\n  je     1143 <func0+0x43>\n  xor    %ecx,%ecx\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  mov    %eax,%edi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%edi\n  sar    $0x23,%rdx\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movsbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    1110 <func0+0x10>\n  add    %rcx,%rsi\n  movb   $0x0,(%rsi)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movsbl (%rdi),%eax\n  mov    %rdi,%r8\n  test   %al,%al\n  je     L0\n  xor    %ecx,%ecx\nL1:\n  sub    $0x5d,%eax\n  movslq %eax,%rdx\n  mov    %eax,%edi\n  imul   $0x4ec4ec4f,%rdx,%rdx\n  sar    $0x1f,%edi\n  sar    $0x23,%rdx\n  sub    %edi,%edx\n  imul   $0x1a,%edx,%edx\n  sub    %edx,%eax\n  add    $0x61,%eax\n  mov    %al,(%rsi,%rcx,1)\n  add    $0x1,%rcx\n  movsbl (%r8,%rcx,1),%eax\n  test   %al,%al\n  jne    L1\n  add    %rcx,%rsi\nL0:\n  movb   $0x0,(%rsi)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4419
            },
            "L1": {
                "label": "L1",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 90,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x1,-0x1c(%rbp)\n  jg     1118 <func0+0x1f>\n  mov    $0xffffffff,%eax\n  jmp    11e0 <func0+0xe7>\n  movl   $0x7fffffff,-0xc(%rbp)\n  movl   $0x7fffffff,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    11c1 <func0+0xc8>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    116e <func0+0x75>\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    11bd <func0+0xc4>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x8(%rbp)\n  jle    11bd <func0+0xc4>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  je     11bd <func0+0xc4>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1132 <func0+0x39>\n  cmpl   $0x7fffffff,-0x8(%rbp)\n  jne    11dd <func0+0xe4>\n  mov    $0xffffffff,%eax\n  jmp    11e0 <func0+0xe7>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x1,-0x1c(%rbp)\n  jg     L0\n  mov    $0xffffffff,%eax\n  jmp    L1\nL0:\n  movl   $0x7fffffff,-0xc(%rbp)\n  movl   $0x7fffffff,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L2\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L3\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    L4\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x8(%rbp)\n  jle    L4\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  je     L4\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\nL4:\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  cmpl   $0x7fffffff,-0x8(%rbp)\n  jne    L6\n  mov    $0xffffffff,%eax\n  jmp    L1\nL6:\n  mov    -0x8(%rbp),%eax\nL1:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4376
            },
            "L1": {
                "label": "L1",
                "addr": 4576
            },
            "L2": {
                "label": "L2",
                "addr": 4545
            },
            "L3": {
                "label": "L3",
                "addr": 4462
            },
            "L4": {
                "label": "L4",
                "addr": 4541
            },
            "L5": {
                "label": "L5",
                "addr": 4402
            },
            "L6": {
                "label": "L6",
                "addr": 4573
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 90,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    114a <func0+0x51>\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rdi\n  mov    $0x7fffffff,%eax\n  mov    $0x7fffffff,%esi\n  jmp    1126 <func0+0x2d>\n  mov    %esi,%eax\n  mov    %edx,%esi\n  add    $0x4,%rcx\n  cmp    %rdi,%rcx\n  je     113c <func0+0x43>\n  mov    (%rcx),%edx\n  cmp    %esi,%edx\n  jl     1119 <func0+0x20>\n  mov    %eax,%r8d\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  cmp    %esi,%edx\n  cmove  %r8d,%eax\n  jmp    111d <func0+0x24>\n  cmp    $0x7fffffff,%eax\n  je     1144 <func0+0x4b>\n  ret\n  mov    $0xffffffff,%eax\n  ret\n  mov    $0xffffffff,%eax\n  jmp    1143 <func0+0x4a>",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rdi\n  mov    $0x7fffffff,%eax\n  mov    $0x7fffffff,%esi\n  jmp    L1\nL3:\n  mov    %esi,%eax\n  mov    %edx,%esi\nL4:\n  add    $0x4,%rcx\n  cmp    %rdi,%rcx\n  je     L2\nL1:\n  mov    (%rcx),%edx\n  cmp    %esi,%edx\n  jl     L3\n  mov    %eax,%r8d\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  cmp    %esi,%edx\n  cmove  %r8d,%eax\n  jmp    L4\nL2:\n  cmp    $0x7fffffff,%eax\n  je     L5\nL6:\n  ret\nL5:\n  mov    $0xffffffff,%eax\n  ret\nL0:\n  mov    $0xffffffff,%eax\n  jmp    L6",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4426
            },
            "L1": {
                "label": "L1",
                "addr": 4390
            },
            "L2": {
                "label": "L2",
                "addr": 4412
            },
            "L3": {
                "label": "L3",
                "addr": 4377
            },
            "L4": {
                "label": "L4",
                "addr": 4381
            },
            "L5": {
                "label": "L5",
                "addr": 4420
            },
            "L6": {
                "label": "L6",
                "addr": 4419
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 90,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1153 <func0+0x53>\n  lea    -0x1(%rsi),%eax\n  mov    $0x7fffffff,%r8d\n  mov    $0x7fffffff,%edx\n  lea    0x4(%rdi,%rax,4),%rcx\n  jmp    1132 <func0+0x32>\n  xchg   %ax,%ax\n  je     1129 <func0+0x29>\n  cmp    %r8d,%eax\n  cmovle %eax,%r8d\n  add    $0x4,%rdi\n  cmp    %rcx,%rdi\n  je     1146 <func0+0x46>\n  mov    (%rdi),%eax\n  cmp    %edx,%eax\n  jge    1120 <func0+0x20>\n  add    $0x4,%rdi\n  mov    %edx,%r8d\n  mov    %eax,%edx\n  cmp    %rcx,%rdi\n  jne    1132 <func0+0x32>\n  cmp    $0x7fffffff,%r8d\n  je     1153 <func0+0x53>\n  mov    %r8d,%eax\n  ret\n  mov    $0xffffffff,%r8d\n  jmp    114f <func0+0x4f>",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    $0x7fffffff,%r8d\n  mov    $0x7fffffff,%edx\n  lea    0x4(%rdi,%rax,4),%rcx\n  jmp    L1\n  xchg   %ax,%ax\nL4:\n  je     L2\n  cmp    %r8d,%eax\n  cmovle %eax,%r8d\nL2:\n  add    $0x4,%rdi\n  cmp    %rcx,%rdi\n  je     L3\nL1:\n  mov    (%rdi),%eax\n  cmp    %edx,%eax\n  jge    L4\n  add    $0x4,%rdi\n  mov    %edx,%r8d\n  mov    %eax,%edx\n  cmp    %rcx,%rdi\n  jne    L1\nL3:\n  cmp    $0x7fffffff,%r8d\n  je     L0\nL5:\n  mov    %r8d,%eax\n  ret\nL0:\n  mov    $0xffffffff,%r8d\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4435
            },
            "L1": {
                "label": "L1",
                "addr": 4402
            },
            "L2": {
                "label": "L2",
                "addr": 4393
            },
            "L3": {
                "label": "L3",
                "addr": 4422
            },
            "L4": {
                "label": "L4",
                "addr": 4384
            },
            "L5": {
                "label": "L5",
                "addr": 4431
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 90,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <limits.h>\n\nint func0(int *lst, int size) {\n    if (size < 2) return -1;\n\n    int first = INT_MAX, second = INT_MAX;\n    for (int i = 0; i < size; ++i) {\n        if (lst[i] < first) {\n            second = first;\n            first = lst[i];\n        } else if (lst[i] < second && lst[i] != first) {\n            second = lst[i];\n        }\n    }\n\n    if (second == INT_MAX) return -1;\n    return second;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, 2, 3, 4, 5};\n    assert(func0(test1, 5) == 2);\n\n    int test2[] = {5, 1, 4, 3, 2};\n    assert(func0(test2, 5) == 2);\n\n    assert(func0((const int[]){}, 0) == -1);\n\n    int test4[] = {1, 1};\n    assert(func0(test4, 2) == -1);\n\n    int test5[] = {1, 1, 1, 1, 0};\n    assert(func0(test5, 5) == 1);\n\n    int test6[] = {-35, 34, 12, -45};\n    assert(func0(test6, 4) == -35);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1153 <func0+0x53>\n  lea    -0x1(%rsi),%eax\n  mov    $0x7fffffff,%r8d\n  mov    $0x7fffffff,%edx\n  lea    0x4(%rdi,%rax,4),%rcx\n  jmp    1132 <func0+0x32>\n  xchg   %ax,%ax\n  je     1129 <func0+0x29>\n  cmp    %r8d,%eax\n  cmovle %eax,%r8d\n  add    $0x4,%rdi\n  cmp    %rdi,%rcx\n  je     1146 <func0+0x46>\n  mov    (%rdi),%eax\n  cmp    %eax,%edx\n  jle    1120 <func0+0x20>\n  add    $0x4,%rdi\n  mov    %edx,%r8d\n  mov    %eax,%edx\n  cmp    %rdi,%rcx\n  jne    1132 <func0+0x32>\n  cmp    $0x7fffffff,%r8d\n  je     1153 <func0+0x53>\n  mov    %r8d,%eax\n  ret\n  mov    $0xffffffff,%r8d\n  jmp    114f <func0+0x4f>",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    $0x7fffffff,%r8d\n  mov    $0x7fffffff,%edx\n  lea    0x4(%rdi,%rax,4),%rcx\n  jmp    L1\n  xchg   %ax,%ax\nL4:\n  je     L2\n  cmp    %r8d,%eax\n  cmovle %eax,%r8d\nL2:\n  add    $0x4,%rdi\n  cmp    %rdi,%rcx\n  je     L3\nL1:\n  mov    (%rdi),%eax\n  cmp    %eax,%edx\n  jle    L4\n  add    $0x4,%rdi\n  mov    %edx,%r8d\n  mov    %eax,%edx\n  cmp    %rdi,%rcx\n  jne    L1\nL3:\n  cmp    $0x7fffffff,%r8d\n  je     L0\nL5:\n  mov    %r8d,%eax\n  ret\nL0:\n  mov    $0xffffffff,%r8d\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4435
            },
            "L1": {
                "label": "L1",
                "addr": 4402
            },
            "L2": {
                "label": "L2",
                "addr": 4393
            },
            "L3": {
                "label": "L3",
                "addr": 4422
            },
            "L4": {
                "label": "L4",
                "addr": 4384
            },
            "L5": {
                "label": "L5",
                "addr": 4431
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 91,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1266 <func0+0x14d>\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  je     118c <func0+0x73>\n  cmpl   $0x0,-0xc(%rbp)\n  je     118c <func0+0x73>\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x49,%al\n  jne    11af <func0+0x96>\n  cmpl   $0x0,-0x10(%rbp)\n  je     11af <func0+0x96>\n  movl   $0x1,-0xc(%rbp)\n  jmp    11e7 <func0+0xce>\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    11e7 <func0+0xce>\n  movl   $0x0,-0xc(%rbp)\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    121f <func0+0x106>\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2e,%al\n  je     125b <func0+0x142>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3f,%al\n  je     125b <func0+0x142>\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x21,%al\n  jne    1262 <func0+0x149>\n  movl   $0x1,-0x10(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    114a <func0+0x31>\n  mov    -0x8(%rbp),%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL7:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  je     L1\n  cmpl   $0x0,-0xc(%rbp)\n  je     L1\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x49,%al\n  jne    L2\n  cmpl   $0x0,-0x10(%rbp)\n  je     L2\n  movl   $0x1,-0xc(%rbp)\n  jmp    L3\nL2:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    L3\n  movl   $0x0,-0xc(%rbp)\nL3:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    L4\n  movl   $0x0,-0x10(%rbp)\nL4:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2e,%al\n  je     L5\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x3f,%al\n  je     L5\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x21,%al\n  jne    L6\nL5:\n  movl   $0x1,-0x10(%rbp)\nL6:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L7\n  mov    -0x8(%rbp),%eax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4710
            },
            "L1": {
                "label": "L1",
                "addr": 4492
            },
            "L2": {
                "label": "L2",
                "addr": 4527
            },
            "L3": {
                "label": "L3",
                "addr": 4583
            },
            "L4": {
                "label": "L4",
                "addr": 4639
            },
            "L5": {
                "label": "L5",
                "addr": 4699
            },
            "L6": {
                "label": "L6",
                "addr": 4706
            },
            "L7": {
                "label": "L7",
                "addr": 4426
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 91,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  mov    $0x0,%ebp\n  test   %bl,%bl\n  je     11d6 <func0+0xbd>\n  mov    %rdi,%rbp\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%r9\n  movsbq %bl,%rax\n  movzwl (%r9,%rax,2),%eax\n  and    $0x2000,%ax\n  lea    0x1(%rbp),%rsi\n  mov    $0x1,%edx\n  mov    $0x0,%ebp\n  mov    $0x0,%edi\n  mov    $0x0,%r8d\n  movabs $0x8000400200000000,%r11\n  mov    $0x1,%r10d\n  jmp    117a <func0+0x61>\n  add    $0x1,%rsi\n  test   %edx,%edx\n  je     1183 <func0+0x6a>\n  cmp    $0x49,%bl\n  je     11c8 <func0+0xaf>\n  test   %ax,%ax\n  cmove  %r8d,%edi\n  cmove  %r8d,%edx\n  cmp    $0x3f,%bl\n  ja     11a1 <func0+0x88>\n  mov    %r11,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r10d,%edx\n  movzbl (%rsi),%ebx\n  test   %bl,%bl\n  je     11d6 <func0+0xbd>\n  movsbq %bl,%rax\n  movzwl (%r9,%rax,2),%eax\n  and    $0x2000,%ax\n  test   %edi,%edi\n  je     1176 <func0+0x5d>\n  test   %ax,%ax\n  je     1176 <func0+0x5d>\n  add    $0x1,%ebp\n  mov    $0x0,%edi\n  jmp    1176 <func0+0x5d>\n  mov    $0x1,%edi\n  test   %ax,%ax\n  cmove  %r8d,%edx\n  jmp    11a1 <func0+0x88>\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  mov    $0x0,%ebp\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%r9\n  movsbq %bl,%rax\n  movzwl (%r9,%rax,2),%eax\n  and    $0x2000,%ax\n  lea    0x1(%rbp),%rsi\n  mov    $0x1,%edx\n  mov    $0x0,%ebp\n  mov    $0x0,%edi\n  mov    $0x0,%r8d\n  movabs $0x8000400200000000,%r11\n  mov    $0x1,%r10d\n  jmp    L1\nL5:\n  add    $0x1,%rsi\nL1:\n  test   %edx,%edx\n  je     L2\n  cmp    $0x49,%bl\n  je     L3\nL2:\n  test   %ax,%ax\n  cmove  %r8d,%edi\n  cmove  %r8d,%edx\n  cmp    $0x3f,%bl\n  ja     L4\n  mov    %r11,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r10d,%edx\nL4:\n  movzbl (%rsi),%ebx\n  test   %bl,%bl\n  je     L0\n  movsbq %bl,%rax\n  movzwl (%r9,%rax,2),%eax\n  and    $0x2000,%ax\n  test   %edi,%edi\n  je     L5\n  test   %ax,%ax\n  je     L5\n  add    $0x1,%ebp\n  mov    $0x0,%edi\n  jmp    L5\nL3:\n  mov    $0x1,%edi\n  test   %ax,%ax\n  cmove  %r8d,%edx\n  jmp    L4\nL0:\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4566
            },
            "L1": {
                "label": "L1",
                "addr": 4474
            },
            "L2": {
                "label": "L2",
                "addr": 4483
            },
            "L3": {
                "label": "L3",
                "addr": 4552
            },
            "L4": {
                "label": "L4",
                "addr": 4513
            },
            "L5": {
                "label": "L5",
                "addr": 4470
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 91,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     11d0 <func0+0xb0>\n  mov    %rdi,%rbp\n  call   1050 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  mov    (%rax),%r9\n  mov    $0x1,%edx\n  mov    $0x1,%r11d\n  movabs $0x8000400200000000,%r10\n  jmp    118b <func0+0x6b>\n  cmp    $0x1,%esi\n  sbb    $0xffffffff,%r8d\n  test   %al,%al\n  jne    11c0 <func0+0xa0>\n  xor    %esi,%esi\n  cmp    $0x3f,%bl\n  ja     1180 <func0+0x60>\n  mov    %r10,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r11d,%edx\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     11b5 <func0+0x95>\n  cmp    $0x49,%bl\n  movsbq %bl,%rcx\n  sete   %al\n  and    %edx,%eax\n  testb  $0x20,0x1(%r9,%rcx,2)\n  jne    1160 <func0+0x40>\n  xor    %edx,%edx\n  test   %al,%al\n  je     116b <func0+0x4b>\n  mov    $0x1,%esi\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    118b <func0+0x6b>\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nop\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  jmp    11aa <func0+0x8a>\n  nopl   0x0(%rax)\n  add    $0x8,%rsp\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  mov    (%rax),%r9\n  mov    $0x1,%edx\n  mov    $0x1,%r11d\n  movabs $0x8000400200000000,%r10\n  jmp    L1\nL5:\n  cmp    $0x1,%esi\n  sbb    $0xffffffff,%r8d\n  test   %al,%al\n  jne    L2\nL6:\n  xor    %esi,%esi\n  cmp    $0x3f,%bl\n  ja     L3\n  mov    %r10,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r11d,%edx\nL3:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     L4\nL1:\n  cmp    $0x49,%bl\n  movsbq %bl,%rcx\n  sete   %al\n  and    %edx,%eax\n  testb  $0x20,0x1(%r9,%rcx,2)\n  jne    L5\n  xor    %edx,%edx\n  test   %al,%al\n  je     L6\n  mov    $0x1,%esi\nL7:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    L1\nL4:\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nop\nL2:\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  jmp    L7\n  nopl   0x0(%rax)\nL0:\n  add    $0x8,%rsp\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4560
            },
            "L1": {
                "label": "L1",
                "addr": 4491
            },
            "L2": {
                "label": "L2",
                "addr": 4544
            },
            "L3": {
                "label": "L3",
                "addr": 4480
            },
            "L4": {
                "label": "L4",
                "addr": 4533
            },
            "L5": {
                "label": "L5",
                "addr": 4448
            },
            "L6": {
                "label": "L6",
                "addr": 4459
            },
            "L7": {
                "label": "L7",
                "addr": 4522
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 91,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *S) {\n    int isstart = 1;\n    int isi = 0;\n    int sum = 0;\n    for (int i = 0; S[i] != '\\0'; i++) {\n        if (isspace(S[i]) && isi) {\n            isi = 0;\n            sum += 1;\n        }\n        if (S[i] == 'I' && isstart) {\n            isi = 1;\n        } else if (!isspace(S[i])) {\n            isi = 0;\n        }\n        if (!isspace(S[i])) {\n            isstart = 0;\n        }\n        if (S[i] == '.' || S[i] == '?' || S[i] == '!') {\n            isstart = 1;\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"Hello world\") == 0);\n    assert(func0(\"Is the sky blue?\") == 0);\n    assert(func0(\"I love It !\") == 1);\n    assert(func0(\"bIt\") == 0);\n    assert(func0(\"I feel good today. I will be productive. will kill It\") == 2);\n    assert(func0(\"You and I are going for a walk\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     11d0 <func0+0xb0>\n  mov    %rdi,%rbp\n  call   1050 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  mov    (%rax),%r9\n  mov    $0x1,%edx\n  movabs $0x8000400200000000,%r11\n  mov    $0x1,%r10d\n  jmp    118b <func0+0x6b>\n  cmp    $0x1,%esi\n  sbb    $0xffffffff,%r8d\n  test   %al,%al\n  jne    11c0 <func0+0xa0>\n  xor    %esi,%esi\n  cmp    $0x3f,%bl\n  ja     1180 <func0+0x60>\n  mov    %r11,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r10d,%edx\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     11b5 <func0+0x95>\n  cmp    $0x49,%bl\n  movsbq %bl,%rcx\n  sete   %al\n  and    %edx,%eax\n  testb  $0x20,0x1(%r9,%rcx,2)\n  jne    1160 <func0+0x40>\n  xor    %edx,%edx\n  test   %al,%al\n  je     116b <func0+0x4b>\n  mov    $0x1,%esi\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    118b <func0+0x6b>\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nop\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  jmp    11aa <func0+0x8a>\n  nopl   0x0(%rax)\n  add    $0x8,%rsp\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%rbp\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdi\n  xor    %r8d,%r8d\n  xor    %esi,%esi\n  mov    (%rax),%r9\n  mov    $0x1,%edx\n  movabs $0x8000400200000000,%r11\n  mov    $0x1,%r10d\n  jmp    L1\nL5:\n  cmp    $0x1,%esi\n  sbb    $0xffffffff,%r8d\n  test   %al,%al\n  jne    L2\nL6:\n  xor    %esi,%esi\n  cmp    $0x3f,%bl\n  ja     L3\n  mov    %r11,%rax\n  mov    %ebx,%ecx\n  shr    %cl,%rax\n  test   $0x1,%al\n  cmovne %r10d,%edx\nL3:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  je     L4\nL1:\n  cmp    $0x49,%bl\n  movsbq %bl,%rcx\n  sete   %al\n  and    %edx,%eax\n  testb  $0x20,0x1(%r9,%rcx,2)\n  jne    L5\n  xor    %edx,%edx\n  test   %al,%al\n  je     L6\n  mov    $0x1,%esi\nL7:\n  movzbl (%rdi),%ebx\n  add    $0x1,%rdi\n  test   %bl,%bl\n  jne    L1\nL4:\n  add    $0x8,%rsp\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret\n  nop\nL2:\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  jmp    L7\n  nopl   0x0(%rax)\nL0:\n  add    $0x8,%rsp\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4560
            },
            "L1": {
                "label": "L1",
                "addr": 4491
            },
            "L2": {
                "label": "L2",
                "addr": 4544
            },
            "L3": {
                "label": "L3",
                "addr": 4480
            },
            "L4": {
                "label": "L4",
                "addr": 4533
            },
            "L5": {
                "label": "L5",
                "addr": 4448
            },
            "L6": {
                "label": "L6",
                "addr": 4459
            },
            "L7": {
                "label": "L7",
                "addr": 4522
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 92,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x10,%rsp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  %xmm2,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  movd   %eax,%xmm0\n  call   1050 <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm3\n  ucomiss -0x4(%rbp),%xmm3\n  jp     1158 <func0+0x3f>\n  movd   %eax,%xmm4\n  ucomiss -0x4(%rbp),%xmm4\n  je     1162 <func0+0x49>\n  mov    $0x0,%eax\n  jmp    1206 <func0+0xed>\n  mov    -0x8(%rbp),%eax\n  movd   %eax,%xmm0\n  call   1050 <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm5\n  ucomiss -0x8(%rbp),%xmm5\n  jp     1186 <func0+0x6d>\n  movd   %eax,%xmm6\n  ucomiss -0x8(%rbp),%xmm6\n  je     118d <func0+0x74>\n  mov    $0x0,%eax\n  jmp    1206 <func0+0xed>\n  mov    -0xc(%rbp),%eax\n  movd   %eax,%xmm0\n  call   1050 <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm7\n  ucomiss -0xc(%rbp),%xmm7\n  jp     11b1 <func0+0x98>\n  movd   %eax,%xmm1\n  ucomiss -0xc(%rbp),%xmm1\n  je     11b8 <func0+0x9f>\n  mov    $0x0,%eax\n  jmp    1206 <func0+0xed>\n  movss  -0x4(%rbp),%xmm0\n  addss  -0x8(%rbp),%xmm0\n  ucomiss -0xc(%rbp),%xmm0\n  jp     11ce <func0+0xb5>\n  ucomiss -0xc(%rbp),%xmm0\n  je     11fa <func0+0xe1>\n  movss  -0x4(%rbp),%xmm0\n  addss  -0xc(%rbp),%xmm0\n  ucomiss -0x8(%rbp),%xmm0\n  jp     11e4 <func0+0xcb>\n  ucomiss -0x8(%rbp),%xmm0\n  je     11fa <func0+0xe1>\n  movss  -0x8(%rbp),%xmm0\n  addss  -0xc(%rbp),%xmm0\n  ucomiss -0x4(%rbp),%xmm0\n  jp     1201 <func0+0xe8>\n  ucomiss -0x4(%rbp),%xmm0\n  jne    1201 <func0+0xe8>\n  mov    $0x1,%eax\n  jmp    1206 <func0+0xed>\n  mov    $0x0,%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x10,%rsp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  %xmm2,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  movd   %eax,%xmm0\n  call   <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm3\n  ucomiss -0x4(%rbp),%xmm3\n  jp     L0\n  movd   %eax,%xmm4\n  ucomiss -0x4(%rbp),%xmm4\n  je     L1\nL0:\n  mov    $0x0,%eax\n  jmp    L2\nL1:\n  mov    -0x8(%rbp),%eax\n  movd   %eax,%xmm0\n  call   <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm5\n  ucomiss -0x8(%rbp),%xmm5\n  jp     L3\n  movd   %eax,%xmm6\n  ucomiss -0x8(%rbp),%xmm6\n  je     L4\nL3:\n  mov    $0x0,%eax\n  jmp    L2\nL4:\n  mov    -0xc(%rbp),%eax\n  movd   %eax,%xmm0\n  call   <roundf@plt>\n  movd   %xmm0,%eax\n  movd   %eax,%xmm7\n  ucomiss -0xc(%rbp),%xmm7\n  jp     L5\n  movd   %eax,%xmm1\n  ucomiss -0xc(%rbp),%xmm1\n  je     L6\nL5:\n  mov    $0x0,%eax\n  jmp    L2\nL6:\n  movss  -0x4(%rbp),%xmm0\n  addss  -0x8(%rbp),%xmm0\n  ucomiss -0xc(%rbp),%xmm0\n  jp     L7\n  ucomiss -0xc(%rbp),%xmm0\n  je     L8\nL7:\n  movss  -0x4(%rbp),%xmm0\n  addss  -0xc(%rbp),%xmm0\n  ucomiss -0x8(%rbp),%xmm0\n  jp     L9\n  ucomiss -0x8(%rbp),%xmm0\n  je     L8\nL9:\n  movss  -0x8(%rbp),%xmm0\n  addss  -0xc(%rbp),%xmm0\n  ucomiss -0x4(%rbp),%xmm0\n  jp     L10\n  ucomiss -0x4(%rbp),%xmm0\n  jne    L10\nL8:\n  mov    $0x1,%eax\n  jmp    L2\nL10:\n  mov    $0x0,%eax\nL2:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4440
            },
            "L1": {
                "label": "L1",
                "addr": 4450
            },
            "L2": {
                "label": "L2",
                "addr": 4614
            },
            "L3": {
                "label": "L3",
                "addr": 4486
            },
            "L4": {
                "label": "L4",
                "addr": 4493
            },
            "L5": {
                "label": "L5",
                "addr": 4529
            },
            "L6": {
                "label": "L6",
                "addr": 4536
            },
            "L7": {
                "label": "L7",
                "addr": 4558
            },
            "L8": {
                "label": "L8",
                "addr": 4602
            },
            "L9": {
                "label": "L9",
                "addr": 4580
            },
            "L10": {
                "label": "L10",
                "addr": 4609
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 92,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x8(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x4(%rsp)\n  call   1050 <roundf@plt>\n  movss  0x4(%rsp),%xmm3\n  ucomiss %xmm3,%xmm0\n  jp     11d4 <func0+0xbb>\n  jne    11d4 <func0+0xbb>\n  movss  0x8(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  movss  0x8(%rsp),%xmm4\n  ucomiss %xmm4,%xmm0\n  jp     11de <func0+0xc5>\n  jne    11de <func0+0xc5>\n  movss  0xc(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     11e5 <func0+0xcc>\n  jne    11e5 <func0+0xcc>\n  movss  0x4(%rsp),%xmm0\n  addss  0x8(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     1195 <func0+0x7c>\n  mov    $0x1,%eax\n  je     11d9 <func0+0xc0>\n  movss  0x4(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  movss  0x8(%rsp),%xmm6\n  ucomiss %xmm6,%xmm0\n  jp     11b3 <func0+0x9a>\n  mov    $0x1,%eax\n  je     11d9 <func0+0xc0>\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  setnp  %al\n  movzbl %al,%eax\n  mov    $0x0,%edx\n  cmovne %edx,%eax\n  jmp    11d9 <func0+0xc0>\n  mov    $0x0,%eax\n  add    $0x18,%rsp\n  ret\n  mov    $0x0,%eax\n  jmp    11d9 <func0+0xc0>\n  mov    $0x0,%eax\n  jmp    11d9 <func0+0xc0>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x8(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x4(%rsp)\n  call   <roundf@plt>\n  movss  0x4(%rsp),%xmm3\n  ucomiss %xmm3,%xmm0\n  jp     L0\n  jne    L0\n  movss  0x8(%rsp),%xmm0\n  call   <roundf@plt>\n  movss  0x8(%rsp),%xmm4\n  ucomiss %xmm4,%xmm0\n  jp     L1\n  jne    L1\n  movss  0xc(%rsp),%xmm0\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     L2\n  jne    L2\n  movss  0x4(%rsp),%xmm0\n  addss  0x8(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     L3\n  mov    $0x1,%eax\n  je     L4\nL3:\n  movss  0x4(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  movss  0x8(%rsp),%xmm6\n  ucomiss %xmm6,%xmm0\n  jp     L5\n  mov    $0x1,%eax\n  je     L4\nL5:\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  setnp  %al\n  movzbl %al,%eax\n  mov    $0x0,%edx\n  cmovne %edx,%eax\n  jmp    L4\nL0:\n  mov    $0x0,%eax\nL4:\n  add    $0x18,%rsp\n  ret\nL1:\n  mov    $0x0,%eax\n  jmp    L4\nL2:\n  mov    $0x0,%eax\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4564
            },
            "L1": {
                "label": "L1",
                "addr": 4574
            },
            "L2": {
                "label": "L2",
                "addr": 4581
            },
            "L3": {
                "label": "L3",
                "addr": 4501
            },
            "L4": {
                "label": "L4",
                "addr": 4569
            },
            "L5": {
                "label": "L5",
                "addr": 4531
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 92,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x4(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x8(%rsp)\n  call   1050 <roundf@plt>\n  ucomiss 0x8(%rsp),%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0x4(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  ucomiss 0x4(%rsp),%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0xc(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0x8(%rsp),%xmm0\n  addss  0x4(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     1194 <func0+0x74>\n  mov    $0x1,%eax\n  je     11da <func0+0xba>\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  jp     11ae <func0+0x8e>\n  mov    $0x1,%eax\n  je     11da <func0+0xba>\n  movss  0x4(%rsp),%xmm0\n  xor    %eax,%eax\n  mov    $0x0,%edx\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x8(%rsp),%xmm0\n  setnp  %al\n  cmovne %edx,%eax\n  add    $0x18,%rsp\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  add    $0x18,%rsp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x4(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x8(%rsp)\n  call   <roundf@plt>\n  ucomiss 0x8(%rsp),%xmm0\n  jp     L0\n  jne    L0\n  movss  0x4(%rsp),%xmm0\n  call   <roundf@plt>\n  ucomiss 0x4(%rsp),%xmm0\n  jp     L0\n  jne    L0\n  movss  0xc(%rsp),%xmm0\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     L0\n  jne    L0\n  movss  0x8(%rsp),%xmm0\n  addss  0x4(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     L1\n  mov    $0x1,%eax\n  je     L2\nL1:\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  jp     L3\n  mov    $0x1,%eax\n  je     L2\nL3:\n  movss  0x4(%rsp),%xmm0\n  xor    %eax,%eax\n  mov    $0x0,%edx\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x8(%rsp),%xmm0\n  setnp  %al\n  cmovne %edx,%eax\n  add    $0x18,%rsp\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\nL2:\n  add    $0x18,%rsp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4568
            },
            "L1": {
                "label": "L1",
                "addr": 4500
            },
            "L2": {
                "label": "L2",
                "addr": 4570
            },
            "L3": {
                "label": "L3",
                "addr": 4526
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 92,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (roundf(a) != a) return 0;\n    if (roundf(b) != b) return 0;\n    if (roundf(c) != c) return 0;\n    if ((a + b == c) || (a + c == b) || (b + c == a)) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(2, 3, 1) == 1);\n    assert(func0(2.5, 2, 3) == 0);\n    assert(func0(1.5, 5, 3.5) == 0);\n    assert(func0(2, 6, 2) == 0);\n    assert(func0(4, 2, 2) == 1);\n    assert(func0(2.2, 2.2, 2.2) == 0);\n    assert(func0(-4, 6, 2) == 1);\n    assert(func0(2, 1, 1) == 1);\n    assert(func0(3, 4, 7) == 1);\n    assert(func0(3.01, 4, 7) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x4(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x8(%rsp)\n  call   1050 <roundf@plt>\n  ucomiss 0x8(%rsp),%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0x4(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  ucomiss 0x4(%rsp),%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0xc(%rsp),%xmm0\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     11d8 <func0+0xb8>\n  jne    11d8 <func0+0xb8>\n  movss  0x8(%rsp),%xmm0\n  addss  0x4(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     1194 <func0+0x74>\n  mov    $0x1,%eax\n  je     11da <func0+0xba>\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  jp     11ae <func0+0x8e>\n  mov    $0x1,%eax\n  je     11da <func0+0xba>\n  movss  0x4(%rsp),%xmm0\n  xor    %eax,%eax\n  mov    $0x0,%edx\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x8(%rsp),%xmm0\n  setnp  %al\n  cmovne %edx,%eax\n  add    $0x18,%rsp\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  add    $0x18,%rsp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x18,%rsp\n  movss  %xmm1,0x4(%rsp)\n  movss  %xmm2,0xc(%rsp)\n  movss  %xmm0,0x8(%rsp)\n  call   <roundf@plt>\n  ucomiss 0x8(%rsp),%xmm0\n  jp     L0\n  jne    L0\n  movss  0x4(%rsp),%xmm0\n  call   <roundf@plt>\n  ucomiss 0x4(%rsp),%xmm0\n  jp     L0\n  jne    L0\n  movss  0xc(%rsp),%xmm0\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm5\n  ucomiss %xmm5,%xmm0\n  jp     L0\n  jne    L0\n  movss  0x8(%rsp),%xmm0\n  addss  0x4(%rsp),%xmm0\n  ucomiss %xmm5,%xmm0\n  jp     L1\n  mov    $0x1,%eax\n  je     L2\nL1:\n  movss  0x8(%rsp),%xmm0\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x4(%rsp),%xmm0\n  jp     L3\n  mov    $0x1,%eax\n  je     L2\nL3:\n  movss  0x4(%rsp),%xmm0\n  xor    %eax,%eax\n  mov    $0x0,%edx\n  addss  0xc(%rsp),%xmm0\n  ucomiss 0x8(%rsp),%xmm0\n  setnp  %al\n  cmovne %edx,%eax\n  add    $0x18,%rsp\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\nL2:\n  add    $0x18,%rsp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4568
            },
            "L1": {
                "label": "L1",
                "addr": 4500
            },
            "L2": {
                "label": "L2",
                "addr": 4570
            },
            "L3": {
                "label": "L3",
                "addr": 4526
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 93,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  lea    0xe8c(%rip),%rax        # 2000 <_fini+0xd78>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    125b <func0+0x102>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x11(%rbp)\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movsbq -0x11(%rbp),%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     11c9 <func0+0x70>\n  movsbl -0x11(%rbp),%eax\n  mov    %eax,%edi\n  call   1070 <toupper@plt>\n  mov    %al,-0x11(%rbp)\n  jmp    11f9 <func0+0xa0>\n  call   1090 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movsbq -0x11(%rbp),%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     11f9 <func0+0xa0>\n  movsbl -0x11(%rbp),%eax\n  mov    %eax,%edi\n  call   1080 <tolower@plt>\n  mov    %al,-0x11(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    122d <func0+0xd4>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,-0x11(%rbp)\n  jne    1229 <func0+0xd0>\n  cmpl   $0x9,-0xc(%rbp)\n  jg     1243 <func0+0xea>\n  movzbl -0x11(%rbp),%eax\n  add    $0x2,%eax\n  mov    %al,-0x11(%rbp)\n  jmp    1243 <func0+0xea>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1202 <func0+0xa9>\n  jmp    1244 <func0+0xeb>\n  nop\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x11(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1184 <func0+0x2b>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL8:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x11(%rbp)\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movsbq -0x11(%rbp),%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     L1\n  movsbl -0x11(%rbp),%eax\n  mov    %eax,%edi\n  call   <toupper@plt>\n  mov    %al,-0x11(%rbp)\n  jmp    L2\nL1:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movsbq -0x11(%rbp),%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     L2\n  movsbl -0x11(%rbp),%eax\n  mov    %eax,%edi\n  call   <tolower@plt>\n  mov    %al,-0x11(%rbp)\nL2:\n  movl   $0x0,-0xc(%rbp)\n  jmp    L3\nL6:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,-0x11(%rbp)\n  jne    L4\n  cmpl   $0x9,-0xc(%rbp)\n  jg     L5\n  movzbl -0x11(%rbp),%eax\n  add    $0x2,%eax\n  mov    %al,-0x11(%rbp)\n  jmp    L5\nL4:\n  addl   $0x1,-0xc(%rbp)\nL3:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L6\n  jmp    L7\nL5:\n  nop\nL7:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x11(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L8\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3724
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4699
            },
            "L1": {
                "label": "L1",
                "addr": 4553
            },
            "L2": {
                "label": "L2",
                "addr": 4601
            },
            "L3": {
                "label": "L3",
                "addr": 4653
            },
            "L4": {
                "label": "L4",
                "addr": 4649
            },
            "L5": {
                "label": "L5",
                "addr": 4675
            },
            "L6": {
                "label": "L6",
                "addr": 4610
            },
            "L7": {
                "label": "L7",
                "addr": 4676
            },
            "L8": {
                "label": "L8",
                "addr": 4484
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 93,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     1205 <func0+0xac>\n  mov    %rdi,%r14\n  call   1090 <__ctype_b_loc@plt>\n  mov    %rax,%r15\n  mov    $0x0,%r12d\n  lea    0xe6d(%rip),%rbp        # 2000 <_fini+0xddc>\n  jmp    11c8 <func0+0x6f>\n  test   $0x1,%ah\n  je     11e6 <func0+0x8d>\n  call   1080 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r13,4),%ebx\n  jmp    11e6 <func0+0x8d>\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\n  mov    0x8(%rsp),%rax\n  mov    %bl,(%rax,%r12,1)\n  add    $0x1,%r12\n  movzbl (%r14,%r12,1),%ebx\n  test   %bl,%bl\n  je     120b <func0+0xb2>\n  movsbq %bl,%r13\n  mov    (%r15),%rax\n  movzwl (%rax,%r13,2),%eax\n  test   $0x2,%ah\n  je     1195 <func0+0x3c>\n  call   1070 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r13,4),%ebx\n  mov    $0x0,%eax\n  mov    $0x61,%edx\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  je     11a9 <func0+0x50>\n  add    $0x1,%rax\n  movzbl 0x0(%rbp,%rax,1),%edx\n  test   %dl,%dl\n  jne    11f0 <func0+0x97>\n  jmp    11b2 <func0+0x59>\n  mov    $0x0,%r12d\n  mov    0x8(%rsp),%rax\n  movb   $0x0,(%rax,%r12,1)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  movzbl (%rdi),%ebx\n  test   %bl,%bl\n  je     L0\n  mov    %rdi,%r14\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r15\n  mov    $0x0,%r12d\n  lea    D0(%rip),%rbp\n  jmp    L1\nL4:\n  test   $0x1,%ah\n  je     L2\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r13,4),%ebx\n  jmp    L2\nL5:\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\nL7:\n  mov    0x8(%rsp),%rax\n  mov    %bl,(%rax,%r12,1)\n  add    $0x1,%r12\n  movzbl (%r14,%r12,1),%ebx\n  test   %bl,%bl\n  je     L3\nL1:\n  movsbq %bl,%r13\n  mov    (%r15),%rax\n  movzwl (%rax,%r13,2),%eax\n  test   $0x2,%ah\n  je     L4\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r13,4),%ebx\nL2:\n  mov    $0x0,%eax\n  mov    $0x61,%edx\nL6:\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  je     L5\n  add    $0x1,%rax\n  movzbl 0x0(%rbp,%rax,1),%edx\n  test   %dl,%dl\n  jne    L6\n  jmp    L7\nL0:\n  mov    $0x0,%r12d\nL3:\n  mov    0x8(%rsp),%rax\n  movb   $0x0,(%rax,%r12,1)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3693
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4613
            },
            "L1": {
                "label": "L1",
                "addr": 4552
            },
            "L2": {
                "label": "L2",
                "addr": 4582
            },
            "L3": {
                "label": "L3",
                "addr": 4619
            },
            "L4": {
                "label": "L4",
                "addr": 4501
            },
            "L5": {
                "label": "L5",
                "addr": 4521
            },
            "L6": {
                "label": "L6",
                "addr": 4592
            },
            "L7": {
                "label": "L7",
                "addr": 4530
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 93,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rdi,0x8(%rsp)\n  test   %bl,%bl\n  je     11f7 <func0+0x97>\n  call   1090 <__ctype_b_loc@plt>\n  xor    %r14d,%r14d\n  lea    0xe70(%rip),%r13        # 2000 <_fini+0xddc>\n  mov    %rax,%r12\n  nopl   0x0(%rax,%rax,1)\n  mov    (%r12),%rax\n  movsbq %bl,%r15\n  movzwl (%rax,%r15,2),%eax\n  test   $0x2,%ah\n  je     1210 <func0+0xb0>\n  call   1070 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  xor    %eax,%eax\n  mov    $0x61,%edx\n  jmp    11ce <func0+0x6e>\n  add    $0x1,%rax\n  movzbl 0x0(%r13,%rax,1),%edx\n  test   %dl,%dl\n  je     11dd <func0+0x7d>\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  jne    11c0 <func0+0x60>\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\n  mov    0x8(%rsp),%rax\n  mov    %bl,0x0(%rbp,%r14,1)\n  add    $0x1,%r14\n  movzbl (%rax,%r14,1),%ebx\n  test   %bl,%bl\n  jne    1198 <func0+0x38>\n  add    %r14,%rbp\n  movb   $0x0,0x0(%rbp)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  test   $0x1,%ah\n  je     11b7 <func0+0x57>\n  call   1080 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  jmp    11b7 <func0+0x57>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rdi,0x8(%rsp)\n  test   %bl,%bl\n  je     L0\n  call   <__ctype_b_loc@plt>\n  xor    %r14d,%r14d\n  lea    D0(%rip),%r13\n  mov    %rax,%r12\n  nopl   0x0(%rax,%rax,1)\nL5:\n  mov    (%r12),%rax\n  movsbq %bl,%r15\n  movzwl (%rax,%r15,2),%eax\n  test   $0x2,%ah\n  je     L1\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\nL6:\n  xor    %eax,%eax\n  mov    $0x61,%edx\n  jmp    L2\nL4:\n  add    $0x1,%rax\n  movzbl 0x0(%r13,%rax,1),%edx\n  test   %dl,%dl\n  je     L3\nL2:\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  jne    L4\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\nL3:\n  mov    0x8(%rsp),%rax\n  mov    %bl,0x0(%rbp,%r14,1)\n  add    $0x1,%r14\n  movzbl (%rax,%r14,1),%ebx\n  test   %bl,%bl\n  jne    L5\n  add    %r14,%rbp\nL0:\n  movb   $0x0,0x0(%rbp)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  test   $0x1,%ah\n  je     L6\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  jmp    L6",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3696
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4599
            },
            "L1": {
                "label": "L1",
                "addr": 4624
            },
            "L2": {
                "label": "L2",
                "addr": 4558
            },
            "L3": {
                "label": "L3",
                "addr": 4573
            },
            "L4": {
                "label": "L4",
                "addr": 4544
            },
            "L5": {
                "label": "L5",
                "addr": 4504
            },
            "L6": {
                "label": "L6",
                "addr": 4535
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 93,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid func0(const char* message, char* out) {\n    const char* vowels = \"aeiouAEIOU\";\n    int i, j;\n    \n    for (i = 0; message[i] != '\\0'; ++i) {\n        char w = message[i];\n        if (islower(w)) {\n            w = toupper(w);\n        } else if (isupper(w)) {\n            w = tolower(w);\n        }\n        \n        for (j = 0; vowels[j] != '\\0'; ++j) {\n            if (w == vowels[j]) {\n                if (j < 10) {\n                    w = w + 2;\n                }\n                break;\n            }\n        }\n        out[i] = w;\n    }\n    out[i] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"TEST\", output);\n    assert(strcmp(output, \"tgst\") == 0);\n\n    func0(\"Mudasir\", output);\n    assert(strcmp(output, \"mWDCSKR\") == 0);\n\n    func0(\"YES\", output);\n    assert(strcmp(output, \"ygs\") == 0);\n\n    func0(\"This is a message\", output);\n    assert(strcmp(output, \"tHKS KS C MGSSCGG\") == 0);\n\n    func0(\"I DoNt KnOw WhAt tO WrItE\", output);\n    assert(strcmp(output, \"k dQnT kNqW wHcT Tq wRkTg\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rdi,0x8(%rsp)\n  test   %bl,%bl\n  je     11f7 <func0+0x97>\n  call   1090 <__ctype_b_loc@plt>\n  xor    %r14d,%r14d\n  lea    0xe70(%rip),%r13        # 2000 <_fini+0xddc>\n  mov    %rax,%r12\n  nopl   0x0(%rax,%rax,1)\n  mov    (%r12),%rax\n  movsbq %bl,%r15\n  movzwl (%rax,%r15,2),%eax\n  test   $0x2,%ah\n  je     1210 <func0+0xb0>\n  call   1070 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  xor    %eax,%eax\n  mov    $0x61,%edx\n  jmp    11ce <func0+0x6e>\n  add    $0x1,%rax\n  movzbl 0x0(%r13,%rax,1),%edx\n  test   %dl,%dl\n  je     11dd <func0+0x7d>\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  jne    11c0 <func0+0x60>\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\n  mov    0x8(%rsp),%rax\n  mov    %bl,0x0(%rbp,%r14,1)\n  add    $0x1,%r14\n  movzbl (%rax,%r14,1),%ebx\n  test   %bl,%bl\n  jne    1198 <func0+0x38>\n  add    %r14,%rbp\n  movb   $0x0,0x0(%rbp)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  test   $0x1,%ah\n  je     11b7 <func0+0x57>\n  call   1080 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  jmp    11b7 <func0+0x57>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  movzbl (%rdi),%ebx\n  mov    %rdi,0x8(%rsp)\n  test   %bl,%bl\n  je     L0\n  call   <__ctype_b_loc@plt>\n  xor    %r14d,%r14d\n  lea    D0(%rip),%r13\n  mov    %rax,%r12\n  nopl   0x0(%rax,%rax,1)\nL5:\n  mov    (%r12),%rax\n  movsbq %bl,%r15\n  movzwl (%rax,%r15,2),%eax\n  test   $0x2,%ah\n  je     L1\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\nL6:\n  xor    %eax,%eax\n  mov    $0x61,%edx\n  jmp    L2\nL4:\n  add    $0x1,%rax\n  movzbl 0x0(%r13,%rax,1),%edx\n  test   %dl,%dl\n  je     L3\nL2:\n  mov    %eax,%ecx\n  cmp    %dl,%bl\n  jne    L4\n  lea    0x2(%rbx),%eax\n  cmp    $0xa,%ecx\n  cmovl  %eax,%ebx\nL3:\n  mov    0x8(%rsp),%rax\n  mov    %bl,0x0(%rbp,%r14,1)\n  add    $0x1,%r14\n  movzbl (%rax,%r14,1),%ebx\n  test   %bl,%bl\n  jne    L5\n  add    %r14,%rbp\nL0:\n  movb   $0x0,0x0(%rbp)\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  test   $0x1,%ah\n  je     L6\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  movzbl (%rax,%r15,4),%ebx\n  jmp    L6",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3696
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4599
            },
            "L1": {
                "label": "L1",
                "addr": 4624
            },
            "L2": {
                "label": "L2",
                "addr": 4558
            },
            "L3": {
                "label": "L3",
                "addr": 4573
            },
            "L4": {
                "label": "L4",
                "addr": 4544
            },
            "L5": {
                "label": "L5",
                "addr": 4504
            },
            "L6": {
                "label": "L6",
                "addr": 4535
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 94,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    118b <func0+0x92>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jle    1187 <func0+0x8e>\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    1168 <func0+0x6f>\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1164 <func0+0x6b>\n  movl   $0x0,-0xc(%rbp)\n  jmp    1173 <func0+0x7a>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    114e <func0+0x55>\n  cmpl   $0x0,-0xc(%rbp)\n  je     1187 <func0+0x8e>\n  mov    -0x18(%rbp),%edx\n  mov    -0x4(%rbp),%eax\n  cmp    %eax,%edx\n  cmovge %edx,%eax\n  mov    %eax,-0x18(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     111f <func0+0x26>\n  jmp    11e2 <func0+0xe9>\n  mov    -0x18(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  add    %edx,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x18(%rbp)\n  cmpl   $0x0,-0x18(%rbp)\n  jg     1195 <func0+0x9c>\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL6:\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jle    L1\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    L2\nL5:\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L3\n  movl   $0x0,-0xc(%rbp)\n  jmp    L4\nL3:\n  addl   $0x1,-0x8(%rbp)\nL2:\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    L5\nL4:\n  cmpl   $0x0,-0xc(%rbp)\n  je     L1\n  mov    -0x18(%rbp),%edx\n  mov    -0x4(%rbp),%eax\n  cmp    %eax,%edx\n  cmovge %edx,%eax\n  mov    %eax,-0x18(%rbp)\nL1:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L6\n  jmp    L7\nL8:\n  mov    -0x18(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  add    %edx,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x18(%rbp)\nL7:\n  cmpl   $0x0,-0x18(%rbp)\n  jg     L8\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4491
            },
            "L1": {
                "label": "L1",
                "addr": 4487
            },
            "L2": {
                "label": "L2",
                "addr": 4456
            },
            "L3": {
                "label": "L3",
                "addr": 4452
            },
            "L4": {
                "label": "L4",
                "addr": 4467
            },
            "L5": {
                "label": "L5",
                "addr": 4430
            },
            "L6": {
                "label": "L6",
                "addr": 4383
            },
            "L7": {
                "label": "L7",
                "addr": 4578
            },
            "L8": {
                "label": "L8",
                "addr": 4501
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 94,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1148 <func0+0x4f>\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%edi\n  jmp    1164 <func0+0x6b>\n  test   %edi,%edi\n  jle    114f <func0+0x56>\n  mov    $0x0,%ecx\n  movslq %edi,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edi,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  mov    %edi,%esi\n  sub    %edx,%esi\n  add    %esi,%ecx\n  mov    %edi,%edx\n  mov    %eax,%edi\n  cmp    $0x9,%edx\n  jg     111c <func0+0x23>\n  mov    %ecx,%eax\n  ret\n  mov    $0x0,%ecx\n  jmp    1145 <func0+0x4c>\n  mov    $0x0,%ecx\n  jmp    1145 <func0+0x4c>\n  cmp    %esi,%edi\n  cmovl  %esi,%edi\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  je     1113 <func0+0x1a>\n  mov    (%r8),%esi\n  cmp    $0x1,%esi\n  jle    115b <func0+0x62>\n  cmp    $0x3,%esi\n  jle    1156 <func0+0x5d>\n  test   $0x1,%sil\n  je     115b <func0+0x62>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     1156 <func0+0x5d>\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    117c <func0+0x83>\n  jmp    115b <func0+0x62>",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%edi\n  jmp    L1\nL5:\n  test   %edi,%edi\n  jle    L2\n  mov    $0x0,%ecx\nL3:\n  movslq %edi,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edi,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  mov    %edi,%esi\n  sub    %edx,%esi\n  add    %esi,%ecx\n  mov    %edi,%edx\n  mov    %eax,%edi\n  cmp    $0x9,%edx\n  jg     L3\nL4:\n  mov    %ecx,%eax\n  ret\nL0:\n  mov    $0x0,%ecx\n  jmp    L4\nL2:\n  mov    $0x0,%ecx\n  jmp    L4\nL7:\n  cmp    %esi,%edi\n  cmovl  %esi,%edi\nL6:\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  je     L5\nL1:\n  mov    (%r8),%esi\n  cmp    $0x1,%esi\n  jle    L6\n  cmp    $0x3,%esi\n  jle    L7\n  test   $0x1,%sil\n  je     L6\n  mov    $0x2,%ecx\nL8:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jg     L7\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L8\n  jmp    L6",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4424
            },
            "L1": {
                "label": "L1",
                "addr": 4452
            },
            "L2": {
                "label": "L2",
                "addr": 4431
            },
            "L3": {
                "label": "L3",
                "addr": 4380
            },
            "L4": {
                "label": "L4",
                "addr": 4421
            },
            "L5": {
                "label": "L5",
                "addr": 4371
            },
            "L6": {
                "label": "L6",
                "addr": 4443
            },
            "L7": {
                "label": "L7",
                "addr": 4438
            },
            "L8": {
                "label": "L8",
                "addr": 4476
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 94,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    11a1 <func0+0xa1>\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%r9\n  jmp    1129 <func0+0x29>\n  nopl   0x0(%rax)\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  je     1170 <func0+0x70>\n  mov    (%rdi),%esi\n  cmp    $0x1,%esi\n  jle    1120 <func0+0x20>\n  cmp    $0x3,%esi\n  jle    115d <func0+0x5d>\n  test   $0x1,%sil\n  je     1120 <func0+0x20>\n  mov    $0x2,%ecx\n  jmp    1151 <func0+0x51>\n  nopw   0x0(%rax,%rax,1)\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1120 <func0+0x20>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    1148 <func0+0x48>\n  cmp    %esi,%r8d\n  cmovl  %esi,%r8d\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    1129 <func0+0x29>\n  nopl   (%rax)\n  xor    %r9d,%r9d\n  test   %r8d,%r8d\n  je     119d <func0+0x9d>\n  mov    $0xcccccccd,%ecx\n  nopl   (%rax)\n  mov    %r8d,%eax\n  imul   %rcx,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  sub    %edx,%r8d\n  add    %r8d,%r9d\n  mov    %eax,%r8d\n  test   %eax,%eax\n  jne    1180 <func0+0x80>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%r9\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  je     L2\nL1:\n  mov    (%rdi),%esi\n  cmp    $0x1,%esi\n  jle    L3\n  cmp    $0x3,%esi\n  jle    L4\n  test   $0x1,%sil\n  je     L3\n  mov    $0x2,%ecx\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL6:\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL5:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    L6\nL4:\n  cmp    %esi,%r8d\n  cmovl  %esi,%r8d\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    L1\n  nopl   (%rax)\nL2:\n  xor    %r9d,%r9d\n  test   %r8d,%r8d\n  je     L7\n  mov    $0xcccccccd,%ecx\n  nopl   (%rax)\nL8:\n  mov    %r8d,%eax\n  imul   %rcx,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  sub    %edx,%r8d\n  add    %r8d,%r9d\n  mov    %eax,%r8d\n  test   %eax,%eax\n  jne    L8\nL7:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4513
            },
            "L1": {
                "label": "L1",
                "addr": 4393
            },
            "L2": {
                "label": "L2",
                "addr": 4464
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4445
            },
            "L5": {
                "label": "L5",
                "addr": 4433
            },
            "L6": {
                "label": "L6",
                "addr": 4424
            },
            "L7": {
                "label": "L7",
                "addr": 4509
            },
            "L8": {
                "label": "L8",
                "addr": 4480
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 94,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int lst[], int size) {\n    int largest = 0, sum = 0, num, temp;\n\n    for (int i = 0; i < size; ++i) {\n        num = lst[i];\n        if (num > 1) {\n            int prime = 1;\n            for (int j = 2; j * j <= num; ++j) {\n                if (num % j == 0) {\n                    prime = 0;\n                    break;\n                }\n            }\n            if (prime) {\n                largest = num > largest ? num : largest;\n            }\n        }\n    }\n\n    while (largest > 0) {\n        sum += largest % 10;\n        largest /= 10;\n    }\n\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int lst1[] = {0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3};\n    assert(func0(lst1, sizeof(lst1)/sizeof(lst1[0])) == 10);\n\n    int lst2[] = {1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1};\n    assert(func0(lst2, sizeof(lst2)/sizeof(lst2[0])) == 25);\n\n    int lst3[] = {1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3};\n    assert(func0(lst3, sizeof(lst3)/sizeof(lst3[0])) == 13);\n\n    int lst4[] = {0,724,32,71,99,32,6,0,5,91,83,0,5,6};\n    assert(func0(lst4, sizeof(lst4)/sizeof(lst4[0])) == 11);\n\n    int lst5[] = {0,81,12,3,1,21};\n    assert(func0(lst5, sizeof(lst5)/sizeof(lst5[0])) == 3);\n\n    int lst6[] = {0,8,1,2,1,7};\n    assert(func0(lst6, sizeof(lst6)/sizeof(lst6[0])) == 7);\n\n    int lst7[] = {8191};\n    assert(func0(lst7, sizeof(lst7)/sizeof(lst7[0])) == 19);\n\n    int lst8[] = {8191, 123456, 127, 7};\n    assert(func0(lst8, sizeof(lst8)/sizeof(lst8[0])) == 19);\n\n    int lst9[] = {127, 97, 8192};\n    assert(func0(lst9, sizeof(lst9)/sizeof(lst9[0])) == 10);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    11a1 <func0+0xa1>\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%r9\n  jmp    1129 <func0+0x29>\n  nopl   0x0(%rax)\n  add    $0x4,%rdi\n  cmp    %rdi,%r9\n  je     1170 <func0+0x70>\n  mov    (%rdi),%esi\n  cmp    $0x1,%esi\n  jle    1120 <func0+0x20>\n  cmp    $0x3,%esi\n  jle    115d <func0+0x5d>\n  test   $0x1,%sil\n  je     1120 <func0+0x20>\n  mov    $0x2,%ecx\n  jmp    1151 <func0+0x51>\n  nopw   0x0(%rax,%rax,1)\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     1120 <func0+0x20>\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    1148 <func0+0x48>\n  cmp    %esi,%r8d\n  cmovl  %esi,%r8d\n  add    $0x4,%rdi\n  cmp    %rdi,%r9\n  jne    1129 <func0+0x29>\n  nopl   (%rax)\n  xor    %r9d,%r9d\n  test   %r8d,%r8d\n  je     119d <func0+0x9d>\n  mov    $0xcccccccd,%ecx\n  nopl   (%rax)\n  mov    %r8d,%eax\n  imul   %rcx,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  sub    %edx,%r8d\n  add    %r8d,%r9d\n  mov    %eax,%r8d\n  test   %eax,%eax\n  jne    1180 <func0+0x80>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%r9\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  add    $0x4,%rdi\n  cmp    %rdi,%r9\n  je     L2\nL1:\n  mov    (%rdi),%esi\n  cmp    $0x1,%esi\n  jle    L3\n  cmp    $0x3,%esi\n  jle    L4\n  test   $0x1,%sil\n  je     L3\n  mov    $0x2,%ecx\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL6:\n  mov    %esi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\nL5:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %esi,%eax\n  jle    L6\nL4:\n  cmp    %esi,%r8d\n  cmovl  %esi,%r8d\n  add    $0x4,%rdi\n  cmp    %rdi,%r9\n  jne    L1\n  nopl   (%rax)\nL2:\n  xor    %r9d,%r9d\n  test   %r8d,%r8d\n  je     L7\n  mov    $0xcccccccd,%ecx\n  nopl   (%rax)\nL8:\n  mov    %r8d,%eax\n  imul   %rcx,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%edx\n  add    %edx,%edx\n  sub    %edx,%r8d\n  add    %r8d,%r9d\n  mov    %eax,%r8d\n  test   %eax,%eax\n  jne    L8\nL7:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4513
            },
            "L1": {
                "label": "L1",
                "addr": 4393
            },
            "L2": {
                "label": "L2",
                "addr": 4464
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4445
            },
            "L5": {
                "label": "L5",
                "addr": 4433
            },
            "L6": {
                "label": "L6",
                "addr": 4424
            },
            "L7": {
                "label": "L7",
                "addr": 4509
            },
            "L8": {
                "label": "L8",
                "addr": 4480
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 95,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  cmpl   $0x0,-0x2c(%rbp)\n  jne    113c <func0+0x23>\n  mov    $0x0,%eax\n  jmp    1269 <func0+0x150>\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    1258 <func0+0x13f>\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x4,%rax\n  mov    %rax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    123c <func0+0x123>\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  jne    11b6 <func0+0x9d>\n  mov    $0x0,%eax\n  jmp    1269 <func0+0x150>\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     11ed <func0+0xd4>\n  movl   $0x1,-0x14(%rbp)\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     1224 <func0+0x10b>\n  movl   $0x1,-0x18(%rbp)\n  mov    -0x14(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  jne    1238 <func0+0x11f>\n  mov    $0x0,%eax\n  jmp    1269 <func0+0x150>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    117c <func0+0x63>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1156 <func0+0x3d>\n  mov    $0x1,%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  cmpl   $0x0,-0x2c(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L2\nL9:\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x4,%rax\n  mov    %rax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L3\nL8:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  jne    L4\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     L5\n  movl   $0x1,-0x14(%rbp)\nL5:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     L6\n  movl   $0x1,-0x18(%rbp)\nL6:\n  mov    -0x14(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  add    %edx,%eax\n  cmp    $0x2,%eax\n  jne    L7\n  mov    $0x0,%eax\n  jmp    L1\nL7:\n  addl   $0x1,-0xc(%rbp)\nL3:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L8\n  addl   $0x1,-0x10(%rbp)\nL2:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L9\n  mov    $0x1,%eax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4412
            },
            "L1": {
                "label": "L1",
                "addr": 4713
            },
            "L2": {
                "label": "L2",
                "addr": 4696
            },
            "L3": {
                "label": "L3",
                "addr": 4668
            },
            "L4": {
                "label": "L4",
                "addr": 4534
            },
            "L5": {
                "label": "L5",
                "addr": 4589
            },
            "L6": {
                "label": "L6",
                "addr": 4644
            },
            "L7": {
                "label": "L7",
                "addr": 4664
            },
            "L8": {
                "label": "L8",
                "addr": 4476
            },
            "L9": {
                "label": "L9",
                "addr": 4438
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 95,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  test   %esi,%esi\n  je     11e7 <func0+0xce>\n  jle    1188 <func0+0x6f>\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r15\n  lea    -0x1(%rsi),%eax\n  shl    $0x4,%rax\n  lea    0x10(%rdi,%rax,1),%rax\n  mov    %rax,0x8(%rsp)\n  mov    $0x0,%r13d\n  mov    $0x0,%r12d\n  mov    $0x1,%r14d\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     1176 <func0+0x5d>\n  call   1050 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  add    $0x1,%rbp\n  jmp    11cd <func0+0xb4>\n  add    $0x10,%r15\n  cmp    0x8(%rsp),%r15\n  jne    115d <func0+0x44>\n  mov    $0x1,%eax\n  jmp    1193 <func0+0x7a>\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    $0x0,%eax\n  jmp    1193 <func0+0x7a>\n  mov    $0x0,%eax\n  jmp    1193 <func0+0x7a>\n  test   $0x2,%ah\n  jne    11a9 <func0+0x90>\n  mov    %r14d,%r13d\n  lea    (%r12,%r13,1),%eax\n  cmp    $0x2,%eax\n  je     11a2 <func0+0x89>\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     1176 <func0+0x5d>\n  movzbl %bl,%ebx\n  movzwl (%rdx,%rbx,2),%eax\n  test   $0x4,%ah\n  je     118e <func0+0x75>\n  test   $0x1,%ah\n  jne    11b0 <func0+0x97>\n  test   $0x2,%ah\n  cmovne %r14d,%r12d\n  jmp    11b8 <func0+0x9f>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r15\n  lea    -0x1(%rsi),%eax\n  shl    $0x4,%rax\n  lea    0x10(%rdi,%rax,1),%rax\n  mov    %rax,0x8(%rsp)\n  mov    $0x0,%r13d\n  mov    $0x0,%r12d\n  mov    $0x1,%r14d\nL4:\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  add    $0x1,%rbp\n  jmp    L3\nL2:\n  add    $0x10,%r15\n  cmp    0x8(%rsp),%r15\n  jne    L4\n  mov    $0x1,%eax\n  jmp    L5\nL1:\n  mov    $0x1,%eax\n  ret\nL8:\n  mov    $0x0,%eax\nL5:\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL7:\n  mov    $0x0,%eax\n  jmp    L5\nL6:\n  mov    $0x0,%eax\n  jmp    L5\nL9:\n  test   $0x2,%ah\n  jne    L6\n  mov    %r14d,%r13d\nL10:\n  lea    (%r12,%r13,1),%eax\n  cmp    $0x2,%eax\n  je     L7\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\nL3:\n  movzbl %bl,%ebx\n  movzwl (%rdx,%rbx,2),%eax\n  test   $0x4,%ah\n  je     L8\n  test   $0x1,%ah\n  jne    L9\n  test   $0x2,%ah\n  cmovne %r14d,%r12d\n  jmp    L10\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4583
            },
            "L1": {
                "label": "L1",
                "addr": 4488
            },
            "L2": {
                "label": "L2",
                "addr": 4470
            },
            "L3": {
                "label": "L3",
                "addr": 4557
            },
            "L4": {
                "label": "L4",
                "addr": 4445
            },
            "L5": {
                "label": "L5",
                "addr": 4499
            },
            "L6": {
                "label": "L6",
                "addr": 4521
            },
            "L7": {
                "label": "L7",
                "addr": 4514
            },
            "L8": {
                "label": "L8",
                "addr": 4494
            },
            "L9": {
                "label": "L9",
                "addr": 4528
            },
            "L10": {
                "label": "L10",
                "addr": 4536
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 95,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %esi,%esi\n  je     11f0 <func0+0xd0>\n  jle    11f1 <func0+0xd1>\n  push   %r15\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%r15\n  push   %r14\n  shl    $0x4,%rax\n  xor    %r14d,%r14d\n  push   %r13\n  lea    0x10(%rdi,%rax,1),%rax\n  xor    %r13d,%r13d\n  push   %r12\n  mov    $0x1,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rax,0x8(%rsp)\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     11d8 <func0+0xb8>\n  call   1050 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdx\n  mov    (%rax),%rsi\n  jmp    119c <func0+0x7c>\n  nopl   0x0(%rax,%rax,1)\n  test   %cx,%cx\n  cmovne %r12d,%r13d\n  lea    0x0(%r13,%r14,1),%eax\n  cmp    $0x2,%eax\n  je     11c0 <func0+0xa0>\n  movzbl (%rdx),%ebx\n  add    $0x1,%rdx\n  test   %bl,%bl\n  je     11d8 <func0+0xb8>\n  movzwl (%rsi,%rbx,2),%eax\n  test   $0x4,%ah\n  je     11c0 <func0+0xa0>\n  mov    %eax,%ecx\n  and    $0x200,%cx\n  test   $0x1,%ah\n  je     1180 <func0+0x60>\n  test   %cx,%cx\n  jne    11c0 <func0+0xa0>\n  mov    $0x1,%r14d\n  jmp    1187 <func0+0x67>\n  xchg   %ax,%ax\n  xor    %eax,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  add    $0x10,%r15\n  cmp    %r15,0x8(%rsp)\n  jne    1162 <func0+0x42>\n  mov    $0x1,%eax\n  jmp    11c2 <func0+0xa2>\n  xchg   %ax,%ax\n  ret\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  push   %r15\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%r15\n  push   %r14\n  shl    $0x4,%rax\n  xor    %r14d,%r14d\n  push   %r13\n  lea    0x10(%rdi,%rax,1),%rax\n  xor    %r13d,%r13d\n  push   %r12\n  mov    $0x1,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rax,0x8(%rsp)\nL7:\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdx\n  mov    (%rax),%rsi\n  jmp    L3\n  nopl   0x0(%rax,%rax,1)\nL5:\n  test   %cx,%cx\n  cmovne %r12d,%r13d\nL6:\n  lea    0x0(%r13,%r14,1),%eax\n  cmp    $0x2,%eax\n  je     L4\n  movzbl (%rdx),%ebx\n  add    $0x1,%rdx\n  test   %bl,%bl\n  je     L2\nL3:\n  movzwl (%rsi,%rbx,2),%eax\n  test   $0x4,%ah\n  je     L4\n  mov    %eax,%ecx\n  and    $0x200,%cx\n  test   $0x1,%ah\n  je     L5\n  test   %cx,%cx\n  jne    L4\n  mov    $0x1,%r14d\n  jmp    L6\n  xchg   %ax,%ax\nL4:\n  xor    %eax,%eax\nL8:\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL2:\n  add    $0x10,%r15\n  cmp    %r15,0x8(%rsp)\n  jne    L7\n  mov    $0x1,%eax\n  jmp    L8\n  xchg   %ax,%ax\nL0:\n  ret\nL1:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4592
            },
            "L1": {
                "label": "L1",
                "addr": 4593
            },
            "L2": {
                "label": "L2",
                "addr": 4568
            },
            "L3": {
                "label": "L3",
                "addr": 4508
            },
            "L4": {
                "label": "L4",
                "addr": 4544
            },
            "L5": {
                "label": "L5",
                "addr": 4480
            },
            "L6": {
                "label": "L6",
                "addr": 4487
            },
            "L7": {
                "label": "L7",
                "addr": 4450
            },
            "L8": {
                "label": "L8",
                "addr": 4546
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 95,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(char* dict[][2], int size) {\n    if (size == 0) return 0;\n    int has_lower = 0, has_upper = 0;\n    for (int i = 0; i < size; ++i) {\n        char* key = dict[i][0];\n        for (int j = 0; key[j]; ++j) {\n            if (!isalpha((unsigned char)key[j])) return 0;\n            if (isupper((unsigned char)key[j])) has_upper = 1;\n            if (islower((unsigned char)key[j])) has_lower = 1;\n            if (has_upper + has_lower == 2) return 0;\n        }\n    }\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    char* test1[][2] = {{\"p\",\"pineapple\"}, {\"b\",\"banana\"}};\n    assert(func0(test1, 2) == 1);\n\n    char* test2[][2] = {{\"p\",\"pineapple\"}, {\"A\",\"banana\"}, {\"B\",\"banana\"}};\n    assert(func0(test2, 3) == 0);\n\n    char* test3[][2] = {{\"p\",\"pineapple\"}, {\"5\",\"banana\"}, {\"a\",\"apple\"}};\n    assert(func0(test3, 3) == 0);\n\n    char* test4[][2] = {{\"Name\",\"John\"}, {\"Age\",\"36\"}, {\"City\",\"Houston\"}};\n    assert(func0(test4, 3) == 0);\n\n    char* test5[][2] = {{\"STATE\",\"NC\"}, {\"ZIP\",\"12345\"}};\n    assert(func0(test5, 2) == 1);\n\n    char* test6[][2] = {{\"fruit\",\"Orange\"}, {\"taste\",\"Sweet\"}};\n    assert(func0(test6, 2) == 1);\n\n    assert(func0(NULL, 0) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %esi,%esi\n  je     11f0 <func0+0xd0>\n  jle    11f1 <func0+0xd1>\n  push   %r15\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%r15\n  push   %r14\n  shl    $0x4,%rax\n  xor    %r14d,%r14d\n  push   %r13\n  lea    0x10(%rdi,%rax,1),%rax\n  xor    %r13d,%r13d\n  push   %r12\n  mov    $0x1,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rax,0x8(%rsp)\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     11d8 <func0+0xb8>\n  call   1050 <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdx\n  mov    (%rax),%rsi\n  jmp    119c <func0+0x7c>\n  nopl   0x0(%rax,%rax,1)\n  test   %cx,%cx\n  cmovne %r12d,%r13d\n  lea    0x0(%r13,%r14,1),%eax\n  cmp    $0x2,%eax\n  je     11c0 <func0+0xa0>\n  movzbl (%rdx),%ebx\n  add    $0x1,%rdx\n  test   %bl,%bl\n  je     11d8 <func0+0xb8>\n  movzwl (%rsi,%rbx,2),%eax\n  test   $0x4,%ah\n  je     11c0 <func0+0xa0>\n  mov    %eax,%ecx\n  and    $0x200,%cx\n  test   $0x1,%ah\n  je     1180 <func0+0x60>\n  test   %cx,%cx\n  jne    11c0 <func0+0xa0>\n  mov    $0x1,%r14d\n  jmp    1187 <func0+0x67>\n  xchg   %ax,%ax\n  xor    %eax,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  add    $0x10,%r15\n  cmp    %r15,0x8(%rsp)\n  jne    1162 <func0+0x42>\n  mov    $0x1,%eax\n  jmp    11c2 <func0+0xa2>\n  xchg   %ax,%ax\n  ret\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %eax,%eax\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  push   %r15\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%r15\n  push   %r14\n  shl    $0x4,%rax\n  xor    %r14d,%r14d\n  push   %r13\n  lea    0x10(%rdi,%rax,1),%rax\n  xor    %r13d,%r13d\n  push   %r12\n  mov    $0x1,%r12d\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rax,0x8(%rsp)\nL7:\n  mov    (%r15),%rbp\n  movzbl 0x0(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\n  call   <__ctype_b_loc@plt>\n  lea    0x1(%rbp),%rdx\n  mov    (%rax),%rsi\n  jmp    L3\n  nopl   0x0(%rax,%rax,1)\nL5:\n  test   %cx,%cx\n  cmovne %r12d,%r13d\nL6:\n  lea    0x0(%r13,%r14,1),%eax\n  cmp    $0x2,%eax\n  je     L4\n  movzbl (%rdx),%ebx\n  add    $0x1,%rdx\n  test   %bl,%bl\n  je     L2\nL3:\n  movzwl (%rsi,%rbx,2),%eax\n  test   $0x4,%ah\n  je     L4\n  mov    %eax,%ecx\n  and    $0x200,%cx\n  test   $0x1,%ah\n  je     L5\n  test   %cx,%cx\n  jne    L4\n  mov    $0x1,%r14d\n  jmp    L6\n  xchg   %ax,%ax\nL4:\n  xor    %eax,%eax\nL8:\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL2:\n  add    $0x10,%r15\n  cmp    %r15,0x8(%rsp)\n  jne    L7\n  mov    $0x1,%eax\n  jmp    L8\n  xchg   %ax,%ax\nL0:\n  ret\nL1:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4592
            },
            "L1": {
                "label": "L1",
                "addr": 4593
            },
            "L2": {
                "label": "L2",
                "addr": 4568
            },
            "L3": {
                "label": "L3",
                "addr": 4508
            },
            "L4": {
                "label": "L4",
                "addr": 4544
            },
            "L5": {
                "label": "L5",
                "addr": 4480
            },
            "L6": {
                "label": "L6",
                "addr": 4487
            },
            "L7": {
                "label": "L7",
                "addr": 4450
            },
            "L8": {
                "label": "L8",
                "addr": 4546
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 96,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x2,-0x18(%rbp)\n  jmp    11e8 <func0+0xcf>\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11a5 <func0+0x8c>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     11b2 <func0+0x99>\n  mov    -0x18(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    11a1 <func0+0x88>\n  movl   $0x0,-0x10(%rbp)\n  jmp    11b3 <func0+0x9a>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     1167 <func0+0x4e>\n  jmp    11b3 <func0+0x9a>\n  nop\n  cmpl   $0x0,-0x10(%rbp)\n  je     11e4 <func0+0xcb>\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x30(%rbp),%rax\n  mov    %edx,(%rax)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     1157 <func0+0x3e>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x2,-0x18(%rbp)\n  jmp    L0\nL7:\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L1\nL5:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x18(%rbp)\n  jl     L2\n  mov    -0x18(%rbp),%eax\n  cltd\n  idivl  -0xc(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L3\n  movl   $0x0,-0x10(%rbp)\n  jmp    L4\nL3:\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x14(%rbp)\n  jl     L5\n  jmp    L4\nL2:\n  nop\nL4:\n  cmpl   $0x0,-0x10(%rbp)\n  je     L6\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x18(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x30(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x30(%rbp),%rax\n  mov    %edx,(%rax)\nL6:\n  addl   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     L7\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4584
            },
            "L1": {
                "label": "L1",
                "addr": 4517
            },
            "L2": {
                "label": "L2",
                "addr": 4530
            },
            "L3": {
                "label": "L3",
                "addr": 4513
            },
            "L4": {
                "label": "L4",
                "addr": 4531
            },
            "L5": {
                "label": "L5",
                "addr": 4455
            },
            "L6": {
                "label": "L6",
                "addr": 4580
            },
            "L7": {
                "label": "L7",
                "addr": 4439
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 96,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %edi,%ebp\n  mov    %rsi,%rbx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r10\n  movl   $0x0,(%rbx)\n  mov    $0x2,%edi\n  cmp    $0x2,%ebp\n  jg     1166 <func0+0x4d>\n  mov    %r10,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  movslq %r9d,%rax\n  mov    %edi,(%r10,%rax,4)\n  add    $0x1,%r9d\n  mov    %r9d,(%rbx)\n  add    $0x1,%edi\n  cmp    %edi,%ebp\n  je     1147 <func0+0x2e>\n  mov    (%rbx),%r9d\n  mov    %r10,%rsi\n  mov    %r9d,%eax\n  lea    (%r10,%rax,4),%r8\n  test   %r9d,%r9d\n  jle    1151 <func0+0x38>\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     1151 <func0+0x38>\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     115f <func0+0x46>\n  add    $0x4,%rsi\n  cmp    %r8,%rsi\n  jne    1178 <func0+0x5f>\n  jmp    1151 <func0+0x38>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %edi,%ebp\n  mov    %rsi,%rbx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r10\n  movl   $0x0,(%rbx)\n  mov    $0x2,%edi\n  cmp    $0x2,%ebp\n  jg     L0\nL1:\n  mov    %r10,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL2:\n  movslq %r9d,%rax\n  mov    %edi,(%r10,%rax,4)\n  add    $0x1,%r9d\n  mov    %r9d,(%rbx)\nL3:\n  add    $0x1,%edi\n  cmp    %edi,%ebp\n  je     L1\nL0:\n  mov    (%rbx),%r9d\n  mov    %r10,%rsi\n  mov    %r9d,%eax\n  lea    (%r10,%rax,4),%r8\n  test   %r9d,%r9d\n  jle    L2\nL4:\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jg     L2\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\n  add    $0x4,%rsi\n  cmp    %r8,%rsi\n  jne    L4\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4454
            },
            "L1": {
                "label": "L1",
                "addr": 4423
            },
            "L2": {
                "label": "L2",
                "addr": 4433
            },
            "L3": {
                "label": "L3",
                "addr": 4447
            },
            "L4": {
                "label": "L4",
                "addr": 4472
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 96,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  movslq %edi,%rdi\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  xor    %r9d,%r9d\n  mov    $0x2,%edi\n  mov    %rax,%r10\n  lea    0x4(%rax),%r11\n  cmp    $0x2,%ebx\n  jle    11b8 <func0+0x98>\n  nopw   0x0(%rax,%rax,1)\n  test   %r9d,%r9d\n  jle    1195 <func0+0x75>\n  lea    -0x1(%r9),%eax\n  mov    %r10,%rsi\n  lea    (%r11,%rax,4),%r8\n  jmp    118a <func0+0x6a>\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     11a4 <func0+0x84>\n  add    $0x4,%rsi\n  cmp    %r8,%rsi\n  je     1195 <func0+0x75>\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1178 <func0+0x58>\n  movslq %r9d,%rax\n  add    $0x1,%r9d\n  mov    %edi,(%r10,%rax,4)\n  mov    %r9d,0x0(%rbp)\n  add    $0x1,%edi\n  cmp    %edi,%ebx\n  je     11b8 <func0+0x98>\n  mov    0x0(%rbp),%r9d\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax)\n  add    $0x8,%rsp\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  movslq %edi,%rdi\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  xor    %r9d,%r9d\n  mov    $0x2,%edi\n  mov    %rax,%r10\n  lea    0x4(%rax),%r11\n  cmp    $0x2,%ebx\n  jle    L0\n  nopw   0x0(%rax,%rax,1)\nL5:\n  test   %r9d,%r9d\n  jle    L1\n  lea    -0x1(%r9),%eax\n  mov    %r10,%rsi\n  lea    (%r11,%rax,4),%r8\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\n  add    $0x4,%rsi\n  cmp    %r8,%rsi\n  je     L1\nL2:\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L4\nL1:\n  movslq %r9d,%rax\n  add    $0x1,%r9d\n  mov    %edi,(%r10,%rax,4)\n  mov    %r9d,0x0(%rbp)\nL3:\n  add    $0x1,%edi\n  cmp    %edi,%ebx\n  je     L0\n  mov    0x0(%rbp),%r9d\n  jmp    L5\n  nopl   0x0(%rax)\nL0:\n  add    $0x8,%rsp\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4536
            },
            "L1": {
                "label": "L1",
                "addr": 4501
            },
            "L2": {
                "label": "L2",
                "addr": 4490
            },
            "L3": {
                "label": "L3",
                "addr": 4516
            },
            "L4": {
                "label": "L4",
                "addr": 4472
            },
            "L5": {
                "label": "L5",
                "addr": 4448
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 96,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int n, int *count) {\n    int *out = malloc(n * sizeof(int));\n    *count = 0;\n    int i, j, isp, k;\n\n    for (i = 2; i < n; i++) {\n        isp = 1;\n        for (j = 0; j < *count; j++) {\n            k = out[j];\n            if (k * k > i) break;\n            if (i % k == 0) {\n                isp = 0;\n                break;\n            }\n        }\n        if (isp) {\n            out[*count] = i;\n            (*count)++;\n        }\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int *a, int a_count, int *b, int b_count) {\n    if (a_count != b_count) return 0;\n    for (int i = 0; i < a_count; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int count;\n    int expected[] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\n    int *result = func0(5, &count);\n    assert(issame(result, count, (const int[]){2, 3}, 2));\n    free(result);\n\n    result = func0(6, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(7, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5}, 3));\n    free(result);\n\n    result = func0(10, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7}, 4));\n    free(result);\n\n    result = func0(0, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(22, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19}, 8));\n    free(result);\n\n    result = func0(1, &count);\n    assert(count == 0);\n    free(result);\n\n    result = func0(18, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17}, 7));\n    free(result);\n\n    result = func0(47, &count);\n    assert(issame(result, count, (const int[]){2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43}, 14));\n    free(result);\n\n    result = func0(101, &count);\n    assert(issame(result, count, expected, 25));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  movslq %edi,%rdi\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  xor    %r9d,%r9d\n  mov    $0x2,%edi\n  mov    %rax,%r10\n  lea    0x4(%rax),%r11\n  cmp    $0x2,%ebx\n  jle    11ab <func0+0x8b>\n  nopw   0x0(%rax,%rax,1)\n  test   %r9d,%r9d\n  je     1195 <func0+0x75>\n  lea    -0x1(%r9),%eax\n  mov    %r10,%rsi\n  lea    (%r11,%rax,4),%r8\n  jmp    118a <func0+0x6a>\n  nopw   0x0(%rax,%rax,1)\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     11a4 <func0+0x84>\n  add    $0x4,%rsi\n  cmp    %rsi,%r8\n  je     1195 <func0+0x75>\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1178 <func0+0x58>\n  movslq %r9d,%rax\n  add    $0x1,%r9d\n  mov    %edi,(%r10,%rax,4)\n  mov    %r9d,0x0(%rbp)\n  add    $0x1,%edi\n  cmp    %edi,%ebx\n  jne    1160 <func0+0x40>\n  add    $0x8,%rsp\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  movslq %edi,%rdi\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  movl   $0x0,0x0(%rbp)\n  xor    %r9d,%r9d\n  mov    $0x2,%edi\n  mov    %rax,%r10\n  lea    0x4(%rax),%r11\n  cmp    $0x2,%ebx\n  jle    L0\n  nopw   0x0(%rax,%rax,1)\nL5:\n  test   %r9d,%r9d\n  je     L1\n  lea    -0x1(%r9),%eax\n  mov    %r10,%rsi\n  lea    (%r11,%rax,4),%r8\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  je     L3\n  add    $0x4,%rsi\n  cmp    %rsi,%r8\n  je     L1\nL2:\n  mov    (%rsi),%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L4\nL1:\n  movslq %r9d,%rax\n  add    $0x1,%r9d\n  mov    %edi,(%r10,%rax,4)\n  mov    %r9d,0x0(%rbp)\nL3:\n  add    $0x1,%edi\n  cmp    %edi,%ebx\n  jne    L5\nL0:\n  add    $0x8,%rsp\n  mov    %r10,%rax\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4523
            },
            "L1": {
                "label": "L1",
                "addr": 4501
            },
            "L2": {
                "label": "L2",
                "addr": 4490
            },
            "L3": {
                "label": "L3",
                "addr": 4516
            },
            "L4": {
                "label": "L4",
                "addr": 4472
            },
            "L5": {
                "label": "L5",
                "addr": 4448
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 97,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  mov    %edx,%ecx\n  sub    %eax,%ecx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,%esi\n  movslq %esi,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %esi,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%esi\n  mov    %esi,%edx\n  mov    %ecx,%eax\n  imul   %edx,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  mov    %edx,%ecx\n  sub    %eax,%ecx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,%esi\n  movslq %esi,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %esi,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%esi\n  mov    %esi,%edx\n  mov    %ecx,%eax\n  imul   %edx,%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 97,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  sar    $0x22,%rdx\n  mov    %eax,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%edx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%ecx\n  neg    %ecx\n  cmovs  %esi,%ecx\n  movslq %ecx,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  sar    $0x22,%rdx\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%edx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%ecx\n  imul   %ecx,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  sar    $0x22,%rdx\n  mov    %eax,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%edx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%ecx\n  neg    %ecx\n  cmovs  %esi,%ecx\n  movslq %ecx,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  sar    $0x22,%rdx\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%edx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%ecx\n  imul   %ecx,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 97,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  mov    $0xcccccccd,%edi\n  mov    %eax,%edx\n  imul   %rdi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%edx\n  neg    %edx\n  cmovs  %esi,%edx\n  mov    %edx,%ecx\n  imul   %rdi,%rcx\n  shr    $0x23,%rcx\n  lea    (%rcx,%rcx,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  imul   %edx,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  mov    $0xcccccccd,%edi\n  mov    %eax,%edx\n  imul   %rdi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%edx\n  neg    %edx\n  cmovs  %esi,%edx\n  mov    %edx,%ecx\n  imul   %rdi,%rcx\n  shr    $0x23,%rcx\n  lea    (%rcx,%rcx,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  imul   %edx,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 97,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int a, int b) {\n    return (abs(a) % 10) * (abs(b) % 10);\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(148, 412) == 16);\n    assert(func0(19, 28) == 72);\n    assert(func0(2020, 1851) == 0);\n    assert(func0(14, -15) == 20);\n    assert(func0(76, 67) == 42);\n    assert(func0(17, 27) == 49);\n    assert(func0(0, 1) == 0);\n    assert(func0(0, 0) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  mov    $0xcccccccd,%edi\n  mov    %eax,%edx\n  imul   %rdi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%edx\n  neg    %edx\n  cmovs  %esi,%edx\n  mov    %edx,%ecx\n  imul   %rdi,%rcx\n  shr    $0x23,%rcx\n  lea    (%rcx,%rcx,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  imul   %edx,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%eax\n  neg    %eax\n  cmovs  %edi,%eax\n  mov    $0xcccccccd,%edi\n  mov    %eax,%edx\n  imul   %rdi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%edx\n  add    %edx,%edx\n  sub    %edx,%eax\n  mov    %esi,%edx\n  neg    %edx\n  cmovs  %esi,%edx\n  mov    %edx,%ecx\n  imul   %rdi,%rcx\n  shr    $0x23,%rcx\n  lea    (%rcx,%rcx,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  imul   %edx,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 98,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    0xeaf(%rip),%rax        # 2000 <_fini+0xe34>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1195 <func0+0x5c>\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     1191 <func0+0x58>\n  addl   $0x1,-0x20(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     11c2 <func0+0x89>\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     1165 <func0+0x2c>\n  mov    -0x20(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL3:\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\n  addl   $0x1,-0x20(%rbp)\nL1:\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L2\n  mov    -0x1c(%rbp),%eax\n  add    %eax,%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L3\nL2:\n  mov    -0x20(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3759
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4501
            },
            "L1": {
                "label": "L1",
                "addr": 4497
            },
            "L2": {
                "label": "L2",
                "addr": 4546
            },
            "L3": {
                "label": "L3",
                "addr": 4453
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 98,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     119c <func0+0x63>\n  mov    %rdi,%rbp\n  call   1060 <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  mov    $0x0,%ebx\n  mov    $0x0,%r12d\n  lea    0xe95(%rip),%r14        # 2000 <_fini+0xe5c>\n  cmp    %r13,%rbx\n  je     1190 <func0+0x57>\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  jne    116b <func0+0x32>\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x0,%r12d\n  jmp    1190 <func0+0x57>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    %rdi,%rbp\n  call   <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  mov    $0x0,%ebx\n  mov    $0x0,%r12d\n  lea    D0(%rip),%r14\nL2:\n  cmp    %r13,%rbx\n  je     L1\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  jne    L2\nL1:\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  mov    $0x0,%r12d\n  jmp    L1",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3733
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4508
            },
            "L1": {
                "label": "L1",
                "addr": 4496
            },
            "L2": {
                "label": "L2",
                "addr": 4459
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 98,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     11a1 <func0+0x61>\n  mov    %rdi,%rbp\n  xor    %ebx,%ebx\n  lea    0xea3(%rip),%r14        # 2000 <_fini+0xe58>\n  xor    %r12d,%r12d\n  call   1060 <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  jmp    1190 <func0+0x50>\n  xchg   %ax,%ax\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  je     1195 <func0+0x55>\n  cmp    %r13,%rbx\n  jne    1170 <func0+0x30>\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r12d,%r12d\n  jmp    1195 <func0+0x55>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    %rdi,%rbp\n  xor    %ebx,%ebx\n  lea    D0(%rip),%r14\n  xor    %r12d,%r12d\n  call   <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  jmp    L1\n  xchg   %ax,%ax\nL3:\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  je     L2\nL1:\n  cmp    %r13,%rbx\n  jne    L3\nL2:\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  xor    %r12d,%r12d\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3747
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4513
            },
            "L1": {
                "label": "L1",
                "addr": 4496
            },
            "L2": {
                "label": "L2",
                "addr": 4501
            },
            "L3": {
                "label": "L3",
                "addr": 4464
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 98,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *s) {\n    const char *uvowel = \"AEIOU\";\n    int count = 0;\n    for (int i = 0; s[i] != '\\0' && i * 2 < strlen(s); i++) {\n        if (strchr(uvowel, s[i * 2]) != NULL) {\n            count += 1;\n        }\n    }\n    return count;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"aBCdEf\") == 1);\n    assert(func0(\"abcdefg\") == 0);\n    assert(func0(\"dBBE\") == 0);\n    assert(func0(\"B\") == 0);\n    assert(func0(\"U\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"EEEE\") == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     11a1 <func0+0x61>\n  mov    %rdi,%rbp\n  xor    %ebx,%ebx\n  lea    0xea3(%rip),%r14        # 2000 <_fini+0xe58>\n  xor    %r12d,%r12d\n  call   1060 <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  jmp    1190 <func0+0x50>\n  xchg   %ax,%ax\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   1070 <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  je     1195 <func0+0x55>\n  cmp    %rbx,%r13\n  jne    1170 <func0+0x30>\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  xor    %r12d,%r12d\n  jmp    1195 <func0+0x55>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  cmpb   $0x0,(%rdi)\n  je     L0\n  mov    %rdi,%rbp\n  xor    %ebx,%ebx\n  lea    D0(%rip),%r14\n  xor    %r12d,%r12d\n  call   <strlen@plt>\n  lea    0x1(%rax),%r13\n  shr    %r13\n  jmp    L1\n  xchg   %ax,%ax\nL3:\n  movsbl 0x0(%rbp,%rbx,2),%esi\n  mov    %r14,%rdi\n  call   <strchr@plt>\n  cmp    $0x1,%rax\n  sbb    $0xffffffff,%r12d\n  add    $0x1,%rbx\n  cmpb   $0x0,0x0(%rbp,%rbx,1)\n  je     L2\nL1:\n  cmp    %rbx,%r13\n  jne    L3\nL2:\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  xor    %r12d,%r12d\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3747
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4513
            },
            "L1": {
                "label": "L1",
                "addr": 4496
            },
            "L2": {
                "label": "L2",
                "addr": 4501
            },
            "L3": {
                "label": "L3",
                "addr": 4464
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 99,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <atof@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x8(%rbp)\n  pxor   %xmm0,%xmm0\n  comisd -0x8(%rbp),%xmm0\n  jbe    11af <func0+0x56>\n  movsd  -0x8(%rbp),%xmm0\n  movsd  0xe6a(%rip),%xmm1        # 2000 <_fini+0xe28>\n  subsd  %xmm1,%xmm0\n  movq   %xmm0,%rax\n  movq   %rax,%xmm0\n  call   1080 <ceil@plt>\n  cvttsd2si %xmm0,%eax\n  jmp    11d3 <func0+0x7a>\n  movsd  -0x8(%rbp),%xmm1\n  movsd  0xe44(%rip),%xmm0        # 2000 <_fini+0xe28>\n  addsd  %xmm0,%xmm1\n  movq   %xmm1,%rax\n  movq   %rax,%xmm0\n  call   1090 <floor@plt>\n  cvttsd2si %xmm0,%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atof@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x8(%rbp)\n  pxor   %xmm0,%xmm0\n  comisd -0x8(%rbp),%xmm0\n  jbe    L0\n  movsd  -0x8(%rbp),%xmm0\n  movsd  D0(%rip),%xmm1\n  subsd  %xmm1,%xmm0\n  movq   %xmm0,%rax\n  movq   %rax,%xmm0\n  call   <ceil@plt>\n  cvttsd2si %xmm0,%eax\n  jmp    L1\nL0:\n  movsd  -0x8(%rbp),%xmm1\n  movsd  D0(%rip),%xmm0\n  addsd  %xmm0,%xmm1\n  movq   %xmm1,%rax\n  movq   %rax,%xmm0\n  call   <floor@plt>\n  cvttsd2si %xmm0,%eax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3690,
                    3652
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4527
            },
            "L1": {
                "label": "L1",
                "addr": 4563
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000000000000e03f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f64",
                    "value": 0.5
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 99,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  mov    $0x0,%esi\n  call   1050 <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     119b <func0+0x82>\n  addsd  0xec3(%rip),%xmm0        # 2000 <_fini+0xe08>\n  movapd %xmm0,%xmm3\n  movsd  0xed7(%rip),%xmm2        # 2020 <_fini+0xe28>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  movsd  0xeaf(%rip),%xmm4        # 2008 <_fini+0xe10>\n  ucomisd %xmm1,%xmm4\n  jbe    1192 <func0+0x79>\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  movsd  0xe92(%rip),%xmm4        # 2010 <_fini+0xe18>\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  andnpd %xmm0,%xmm2\n  movapd %xmm1,%xmm3\n  orpd   %xmm2,%xmm3\n  cvttsd2si %xmm3,%eax\n  add    $0x8,%rsp\n  ret\n  subsd  0xe5d(%rip),%xmm0        # 2000 <_fini+0xe08>\n  movapd %xmm0,%xmm3\n  movsd  0xe71(%rip),%xmm2        # 2020 <_fini+0xe28>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  movsd  0xe49(%rip),%xmm4        # 2008 <_fini+0xe10>\n  ucomisd %xmm1,%xmm4\n  jbe    11f0 <func0+0xd7>\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  movsd  0xe30(%rip),%xmm4        # 2010 <_fini+0xe18>\n  andpd  %xmm4,%xmm3\n  addsd  %xmm1,%xmm3\n  andnpd %xmm0,%xmm2\n  orpd   %xmm2,%xmm3\n  cvttsd2si %xmm3,%eax\n  jmp    1196 <func0+0x7d>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  mov    $0x0,%esi\n  call   <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     L0\n  addsd  D0(%rip),%xmm0\n  movapd %xmm0,%xmm3\n  movsd  D1(%rip),%xmm2\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  movsd  D2(%rip),%xmm4\n  ucomisd %xmm1,%xmm4\n  jbe    L1\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  movsd  D3(%rip),%xmm4\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  andnpd %xmm0,%xmm2\n  movapd %xmm1,%xmm3\n  orpd   %xmm2,%xmm3\nL1:\n  cvttsd2si %xmm3,%eax\nL3:\n  add    $0x8,%rsp\n  ret\nL0:\n  subsd  D0(%rip),%xmm0\n  movapd %xmm0,%xmm3\n  movsd  D1(%rip),%xmm2\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  movsd  D2(%rip),%xmm4\n  ucomisd %xmm1,%xmm4\n  jbe    L2\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  movsd  D3(%rip),%xmm4\n  andpd  %xmm4,%xmm3\n  addsd  %xmm1,%xmm3\n  andnpd %xmm0,%xmm2\n  orpd   %xmm2,%xmm3\nL2:\n  cvttsd2si %xmm3,%eax\n  jmp    L3",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3779,
                    3677
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8224,
                "bias": [
                    3799,
                    3697
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3759,
                    3657
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8208,
                "bias": [
                    3730,
                    3632
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4507
            },
            "L1": {
                "label": "L1",
                "addr": 4498
            },
            "L2": {
                "label": "L2",
                "addr": 4592
            },
            "L3": {
                "label": "L3",
                "addr": 4502
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000000000000e03f0000000000003043000000000000f03f0000000000000000ffffffffffffff7f0000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f64",
                    "value": 0.5
                },
                "0x2020": {
                    "type": "byte[8]",
                    "value": [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        127
                    ]
                },
                "0x2008": {
                    "type": "byte[8]",
                    "value": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        48,
                        67
                    ]
                },
                "0x2010": {
                    "type": "byte[8]",
                    "value": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        240,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 99,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  xor    %esi,%esi\n  call   1050 <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     11b0 <func0+0x90>\n  addsd  0xebf(%rip),%xmm0        # 2000 <_fini+0xdec>\n  movsd  0xed7(%rip),%xmm2        # 2020 <_fini+0xe0c>\n  movsd  0xeb7(%rip),%xmm3        # 2008 <_fini+0xdf4>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  ja     1170 <func0+0x50>\n  cvttsd2si %xmm0,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movsd  0xe8f(%rip),%xmm4        # 2010 <_fini+0xdfc>\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret\n  nopl   0x0(%rax)\n  subsd  0xe48(%rip),%xmm0        # 2000 <_fini+0xdec>\n  movsd  0xe60(%rip),%xmm2        # 2020 <_fini+0xe0c>\n  movsd  0xe40(%rip),%xmm3        # 2008 <_fini+0xdf4>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  jbe    115f <func0+0x3f>\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movapd %xmm0,%xmm3\n  movsd  0xe25(%rip),%xmm4        # 2010 <_fini+0xdfc>\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  andpd  %xmm4,%xmm3\n  addsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  xor    %esi,%esi\n  call   <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     L0\n  addsd  D0(%rip),%xmm0\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  ja     L1\nL2:\n  cvttsd2si %xmm0,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movsd  D3(%rip),%xmm4\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  subsd  D0(%rip),%xmm0\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  jbe    L2\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movapd %xmm0,%xmm3\n  movsd  D3(%rip),%xmm4\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  andpd  %xmm4,%xmm3\n  addsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3775,
                    3656
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8224,
                "bias": [
                    3799,
                    3680
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3767,
                    3648
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8208,
                "bias": [
                    3727,
                    3621
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4528
            },
            "L1": {
                "label": "L1",
                "addr": 4464
            },
            "L2": {
                "label": "L2",
                "addr": 4447
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000000000000e03f0000000000003043000000000000f03f0000000000000000ffffffffffffff7f0000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f64",
                    "value": 0.5
                },
                "0x2020": {
                    "type": "byte[8]",
                    "value": [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        127
                    ]
                },
                "0x2008": {
                    "type": "byte[8]",
                    "value": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        48,
                        67
                    ]
                },
                "0x2010": {
                    "type": "byte[8]",
                    "value": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        240,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 99,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint func0(const char *value) {\n    double w;\n    w = atof(value);\n    return (int)(w < 0 ? ceil(w - 0.5) : floor(w + 0.5));\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"10\") == 10);\n    assert(func0(\"14.5\") == 15);\n    assert(func0(\"-15.5\") == -16);\n    assert(func0(\"15.3\") == 15);\n    assert(func0(\"0\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  xor    %esi,%esi\n  call   1050 <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     11b0 <func0+0x90>\n  addsd  0xebf(%rip),%xmm0        # 2000 <_fini+0xdec>\n  movsd  0xed7(%rip),%xmm2        # 2020 <_fini+0xe0c>\n  movsd  0xeb7(%rip),%xmm3        # 2008 <_fini+0xdf4>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  ja     1170 <func0+0x50>\n  cvttsd2si %xmm0,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movsd  0xe8f(%rip),%xmm4        # 2010 <_fini+0xdfc>\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret\n  nopl   0x0(%rax)\n  subsd  0xe48(%rip),%xmm0        # 2000 <_fini+0xdec>\n  movsd  0xe60(%rip),%xmm2        # 2020 <_fini+0xe0c>\n  movsd  0xe40(%rip),%xmm3        # 2008 <_fini+0xdf4>\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  jbe    115f <func0+0x3f>\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movapd %xmm0,%xmm3\n  movsd  0xe25(%rip),%xmm4        # 2010 <_fini+0xdfc>\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  andpd  %xmm4,%xmm3\n  addsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x8,%rsp\n  xor    %esi,%esi\n  call   <strtod@plt>\n  pxor   %xmm1,%xmm1\n  comisd %xmm0,%xmm1\n  ja     L0\n  addsd  D0(%rip),%xmm0\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  ja     L1\nL2:\n  cvttsd2si %xmm0,%eax\n  add    $0x8,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movsd  D3(%rip),%xmm4\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  movapd %xmm1,%xmm3\n  cmpnlesd %xmm0,%xmm3\n  andpd  %xmm4,%xmm3\n  subsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  subsd  D0(%rip),%xmm0\n  movsd  D1(%rip),%xmm2\n  movsd  D2(%rip),%xmm3\n  movapd %xmm0,%xmm1\n  andpd  %xmm2,%xmm1\n  ucomisd %xmm1,%xmm3\n  jbe    L2\n  cvttsd2si %xmm0,%rax\n  pxor   %xmm1,%xmm1\n  movapd %xmm0,%xmm3\n  movsd  D3(%rip),%xmm4\n  andnpd %xmm0,%xmm2\n  add    $0x8,%rsp\n  cvtsi2sd %rax,%xmm1\n  cmpnlesd %xmm1,%xmm3\n  andpd  %xmm4,%xmm3\n  addsd  %xmm3,%xmm1\n  orpd   %xmm2,%xmm1\n  movapd %xmm1,%xmm0\n  cvttsd2si %xmm0,%eax\n  ret",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3775,
                    3656
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8224,
                "bias": [
                    3799,
                    3680
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3767,
                    3648
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8208,
                "bias": [
                    3727,
                    3621
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4528
            },
            "L1": {
                "label": "L1",
                "addr": 4464
            },
            "L2": {
                "label": "L2",
                "addr": 4447
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "000000000000e03f0000000000003043000000000000f03f0000000000000000ffffffffffffff7f0000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "f64",
                    "value": 0.5
                },
                "0x2020": {
                    "type": "byte[8]",
                    "value": [
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        255,
                        127
                    ]
                },
                "0x2008": {
                    "type": "byte[8]",
                    "value": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        48,
                        67
                    ]
                },
                "0x2010": {
                    "type": "byte[8]",
                    "value": [
                        0,
                        0,
                        0,
                        0,
                        0,
                        0,
                        240,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 100,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  mov    -0x14(%rbp),%edx\n  mov    %edx,(%rax)\n  movl   $0x1,-0xc(%rbp)\n  jmp    1182 <func0+0x69>\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x2,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     114f <func0+0x36>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  mov    -0x14(%rbp),%edx\n  mov    %edx,(%rax)\n  movl   $0x1,-0xc(%rbp)\n  jmp    L0\nL1:\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x2,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L1\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4482
            },
            "L1": {
                "label": "L1",
                "addr": 4431
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 100,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    114e <func0+0x35>\n  mov    %rax,%rdx\n  lea    -0x1(%rbx),%ecx\n  lea    (%rax,%rcx,4),%rsi\n  mov    (%rdx),%ebx\n  lea    0x2(%rbx),%ecx\n  mov    %ecx,0x4(%rdx)\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    113d <func0+0x24>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  mov    %rax,%rdx\n  lea    -0x1(%rbx),%ecx\n  lea    (%rax,%rcx,4),%rsi\nL1:\n  mov    (%rdx),%ebx\n  lea    0x2(%rbx),%ecx\n  mov    %ecx,0x4(%rdx)\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4430
            },
            "L1": {
                "label": "L1",
                "addr": 4413
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 100,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    115e <func0+0x3e>\n  lea    -0x1(%rbx),%ecx\n  lea    0x4(%rax),%rdx\n  lea    (%rax,%rcx,4),%rcx\n  jmp    1154 <func0+0x34>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x4,%rdx\n  add    $0x2,%ebx\n  mov    %ebx,(%rdx)\n  cmp    %rcx,%rdx\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  lea    -0x1(%rbx),%ecx\n  lea    0x4(%rax),%rdx\n  lea    (%rax,%rcx,4),%rcx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL2:\n  add    $0x4,%rdx\nL1:\n  add    $0x2,%ebx\n  mov    %ebx,(%rdx)\n  cmp    %rcx,%rdx\n  jne    L2\nL0:\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4446
            },
            "L1": {
                "label": "L1",
                "addr": 4436
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 100,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    *out = n;\n    for (int i = 1; i < n; i++)\n        *(out + i) = *(out + i - 1) + 2;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int* result;\n    int test1[] = {3, 5, 7};\n    int test2[] = {4, 6, 8, 10};\n    int test3[] = {5, 7, 9, 11, 13};\n    int test4[] = {6, 8, 10, 12, 14, 16};\n    int test5[] = {8, 10, 12, 14, 16, 18, 20, 22};\n\n    result = func0(3);\n    for (int i = 0; i < 3; i++) assert(result[i] == test1[i]);\n    free(result);\n\n    result = func0(4);\n    for (int i = 0; i < 4; i++) assert(result[i] == test2[i]);\n    free(result);\n\n    result = func0(5);\n    for (int i = 0; i < 5; i++) assert(result[i] == test3[i]);\n    free(result);\n\n    result = func0(6);\n    for (int i = 0; i < 6; i++) assert(result[i] == test4[i]);\n    free(result);\n\n    result = func0(8);\n    for (int i = 0; i < 8; i++) assert(result[i] == test5[i]);\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    115f <func0+0x3f>\n  lea    -0x2(%rbx),%ecx\n  lea    0x4(%rax),%rdx\n  lea    0x8(%rax,%rcx,4),%rcx\n  nopw   0x0(%rax,%rax,1)\n  add    $0x2,%ebx\n  add    $0x4,%rdx\n  mov    %ebx,-0x4(%rdx)\n  cmp    %rdx,%rcx\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %ebx,(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  lea    -0x2(%rbx),%ecx\n  lea    0x4(%rax),%rdx\n  lea    0x8(%rax,%rcx,4),%rcx\n  nopw   0x0(%rax,%rax,1)\nL1:\n  add    $0x2,%ebx\n  add    $0x4,%rdx\n  mov    %ebx,-0x4(%rdx)\n  cmp    %rdx,%rcx\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4447
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 101,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  movl   $0xa,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  add    $0x1,%rax\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    12cd <func0+0x134>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     1228 <func0+0x8f>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    12a0 <func0+0x107>\n  cmpl   $0x0,-0x28(%rbp)\n  jle    12c8 <func0+0x12f>\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strdup@plt>\n  mov    %rax,(%rbx)\n  movl   $0x0,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     12c8 <func0+0x12f>\n  shll   -0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10c0 <realloc@plt>\n  mov    %rax,-0x20(%rbp)\n  jmp    12c8 <func0+0x12f>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x28(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x28(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  jmp    12c9 <func0+0x130>\n  nop\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1200 <func0+0x67>\n  cmpl   $0x0,-0x28(%rbp)\n  jle    1325 <func0+0x18c>\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strdup@plt>\n  mov    %rax,(%rbx)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  movl   $0xa,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  add    $0x1,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x2c(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L0\nL5:\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L1\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    L2\nL1:\n  cmpl   $0x0,-0x28(%rbp)\n  jle    L3\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,(%rbx)\n  movl   $0x0,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L3\n  shll   -0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x20(%rbp)\n  jmp    L3\nL2:\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x28(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x28(%rbp)\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  jmp    L4\nL3:\n  nop\nL4:\n  addl   $0x1,-0x24(%rbp)\nL0:\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L5\n  cmpl   $0x0,-0x28(%rbp)\n  jle    L6\n  mov    -0x28(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x2c(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x2c(%rbp)\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,(%rbx)\nL6:\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x40(%rbp),%rax\n  mov    -0x2c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4813
            },
            "L1": {
                "label": "L1",
                "addr": 4648
            },
            "L2": {
                "label": "L2",
                "addr": 4768
            },
            "L3": {
                "label": "L3",
                "addr": 4808
            },
            "L4": {
                "label": "L4",
                "addr": 4809
            },
            "L5": {
                "label": "L5",
                "addr": 4608
            },
            "L6": {
                "label": "L6",
                "addr": 4901
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 101,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,0x8(%rsp)\n  mov    $0x50,%edi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r13\n  mov    %rbx,%rdi\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r12\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     12a0 <func0+0x107>\n  add    $0x1,%rbx\n  mov    $0x0,%edx\n  mov    $0x0,%ebp\n  mov    $0xa,%r15d\n  jmp    120b <func0+0x72>\n  movslq %edx,%rcx\n  mov    %al,(%r12,%rcx,1)\n  lea    0x1(%rdx),%edx\n  add    $0x1,%rbx\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  je     125c <func0+0xc3>\n  cmp    $0x20,%al\n  je     1213 <func0+0x7a>\n  cmp    $0x2c,%al\n  jne    11f5 <func0+0x5c>\n  test   %edx,%edx\n  jle    11ff <func0+0x66>\n  movslq %edx,%rdx\n  movb   $0x0,(%r12,%rdx,1)\n  lea    0x1(%rbp),%r14d\n  mov    %r12,%rdi\n  call   10d0 <strdup@plt>\n  movslq %ebp,%rbp\n  mov    %rax,0x0(%r13,%rbp,8)\n  mov    %r14d,%ebp\n  mov    $0x0,%edx\n  cmp    %r15d,%r14d\n  jl     11ff <func0+0x66>\n  add    %r15d,%r15d\n  movslq %r15d,%rsi\n  shl    $0x3,%rsi\n  mov    %r13,%rdi\n  call   10c0 <realloc@plt>\n  mov    %rax,%r13\n  mov    $0x0,%edx\n  jmp    11ff <func0+0x66>\n  test   %edx,%edx\n  jg     1281 <func0+0xe8>\n  mov    %r12,%rdi\n  call   1090 <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %ebp,(%rax)\n  mov    %r13,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  movslq %edx,%rdx\n  movb   $0x0,(%r12,%rdx,1)\n  lea    0x1(%rbp),%ebx\n  mov    %r12,%rdi\n  call   10d0 <strdup@plt>\n  movslq %ebp,%rbp\n  mov    %rax,0x0(%r13,%rbp,8)\n  mov    %ebx,%ebp\n  jmp    1260 <func0+0xc7>\n  mov    $0x0,%ebp\n  jmp    1260 <func0+0xc7>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,0x8(%rsp)\n  mov    $0x50,%edi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r12\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rbx\n  mov    $0x0,%edx\n  mov    $0x0,%ebp\n  mov    $0xa,%r15d\n  jmp    L1\nL4:\n  movslq %edx,%rcx\n  mov    %al,(%r12,%rcx,1)\n  lea    0x1(%rdx),%edx\nL5:\n  add    $0x1,%rbx\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  je     L2\nL1:\n  cmp    $0x20,%al\n  je     L3\n  cmp    $0x2c,%al\n  jne    L4\nL3:\n  test   %edx,%edx\n  jle    L5\n  movslq %edx,%rdx\n  movb   $0x0,(%r12,%rdx,1)\n  lea    0x1(%rbp),%r14d\n  mov    %r12,%rdi\n  call   <strdup@plt>\n  movslq %ebp,%rbp\n  mov    %rax,0x0(%r13,%rbp,8)\n  mov    %r14d,%ebp\n  mov    $0x0,%edx\n  cmp    %r15d,%r14d\n  jl     L5\n  add    %r15d,%r15d\n  movslq %r15d,%rsi\n  shl    $0x3,%rsi\n  mov    %r13,%rdi\n  call   <realloc@plt>\n  mov    %rax,%r13\n  mov    $0x0,%edx\n  jmp    L5\nL2:\n  test   %edx,%edx\n  jg     L6\nL7:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %ebp,(%rax)\n  mov    %r13,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL6:\n  movslq %edx,%rdx\n  movb   $0x0,(%r12,%rdx,1)\n  lea    0x1(%rbp),%ebx\n  mov    %r12,%rdi\n  call   <strdup@plt>\n  movslq %ebp,%rbp\n  mov    %rax,0x0(%r13,%rbp,8)\n  mov    %ebx,%ebp\n  jmp    L7\nL0:\n  mov    $0x0,%ebp\n  jmp    L7",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4768
            },
            "L1": {
                "label": "L1",
                "addr": 4619
            },
            "L2": {
                "label": "L2",
                "addr": 4700
            },
            "L3": {
                "label": "L3",
                "addr": 4627
            },
            "L4": {
                "label": "L4",
                "addr": 4597
            },
            "L5": {
                "label": "L5",
                "addr": 4607
            },
            "L6": {
                "label": "L6",
                "addr": 4737
            },
            "L7": {
                "label": "L7",
                "addr": 4704
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 101,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    $0x50,%edi\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  call   10b0 <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r14\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     12b0 <func0+0x110>\n  add    $0x1,%rbx\n  xor    %ebp,%ebp\n  xor    %r15d,%r15d\n  mov    $0xa,%r13d\n  jmp    1215 <func0+0x75>\n  nopw   0x0(%rax,%rax,1)\n  movslq %ebp,%rdx\n  add    $0x1,%ebp\n  mov    %al,(%r14,%rdx,1)\n  movzbl (%rbx),%eax\n  add    $0x1,%rbx\n  test   %al,%al\n  je     1268 <func0+0xc8>\n  cmp    $0x20,%al\n  je     121d <func0+0x7d>\n  cmp    $0x2c,%al\n  jne    1200 <func0+0x60>\n  test   %ebp,%ebp\n  je     120a <func0+0x6a>\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  movb   $0x0,(%r14,%rbp,1)\n  lea    0x1(%r15),%ebp\n  call   10d0 <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  movslq %ebp,%r15\n  xor    %ebp,%ebp\n  cmp    %r13d,%r15d\n  jl     120a <func0+0x6a>\n  add    %r13d,%r13d\n  mov    %r12,%rdi\n  add    $0x1,%rbx\n  movslq %r13d,%rsi\n  shl    $0x3,%rsi\n  call   10c0 <realloc@plt>\n  mov    %rax,%r12\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  jne    1215 <func0+0x75>\n  nopl   0x0(%rax)\n  test   %ebp,%ebp\n  jne    1290 <func0+0xf0>\n  mov    %r14,%rdi\n  call   1090 <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  lea    0x1(%r15),%ebx\n  movb   $0x0,(%r14,%rbp,1)\n  call   10d0 <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  mov    %ebx,%r15d\n  jmp    126c <func0+0xcc>\n  nopl   (%rax)\n  xor    %r15d,%r15d\n  jmp    126c <func0+0xcc>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    $0x50,%edi\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  call   <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rbx\n  xor    %ebp,%ebp\n  xor    %r15d,%r15d\n  mov    $0xa,%r13d\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL4:\n  movslq %ebp,%rdx\n  add    $0x1,%ebp\n  mov    %al,(%r14,%rdx,1)\nL5:\n  movzbl (%rbx),%eax\n  add    $0x1,%rbx\n  test   %al,%al\n  je     L2\nL1:\n  cmp    $0x20,%al\n  je     L3\n  cmp    $0x2c,%al\n  jne    L4\nL3:\n  test   %ebp,%ebp\n  je     L5\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  movb   $0x0,(%r14,%rbp,1)\n  lea    0x1(%r15),%ebp\n  call   <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  movslq %ebp,%r15\n  xor    %ebp,%ebp\n  cmp    %r13d,%r15d\n  jl     L5\n  add    %r13d,%r13d\n  mov    %r12,%rdi\n  add    $0x1,%rbx\n  movslq %r13d,%rsi\n  shl    $0x3,%rsi\n  call   <realloc@plt>\n  mov    %rax,%r12\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  jne    L1\n  nopl   0x0(%rax)\nL2:\n  test   %ebp,%ebp\n  jne    L6\nL7:\n  mov    %r14,%rdi\n  call   <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\nL6:\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  lea    0x1(%r15),%ebx\n  movb   $0x0,(%r14,%rbp,1)\n  call   <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  mov    %ebx,%r15d\n  jmp    L7\n  nopl   (%rax)\nL0:\n  xor    %r15d,%r15d\n  jmp    L7",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4784
            },
            "L1": {
                "label": "L1",
                "addr": 4629
            },
            "L2": {
                "label": "L2",
                "addr": 4712
            },
            "L3": {
                "label": "L3",
                "addr": 4637
            },
            "L4": {
                "label": "L4",
                "addr": 4608
            },
            "L5": {
                "label": "L5",
                "addr": 4618
            },
            "L6": {
                "label": "L6",
                "addr": 4752
            },
            "L7": {
                "label": "L7",
                "addr": 4716
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 101,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(const char* s, int* count) {\n    int capacity = 10;\n    char** out = malloc(capacity * sizeof(char*));\n    char* current = malloc(strlen(s) + 1);\n    int word_count = 0;\n    int current_length = 0;\n\n    for (int i = 0; s[i]; i++) {\n        if (s[i] == ' ' || s[i] == ',') {\n            if (current_length > 0) {\n                current[current_length] = '\\0';\n                out[word_count++] = strdup(current);\n                current_length = 0;\n\n                if (word_count >= capacity) {\n                    capacity *= 2;\n                    out = realloc(out, capacity * sizeof(char*));\n                }\n            }\n        } else {\n            current[current_length++] = s[i];\n        }\n    }\n\n    if (current_length > 0) {\n        current[current_length] = '\\0';\n        out[word_count++] = strdup(current);\n    }\n\n    free(current);\n    *count = word_count;\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n\nbool issame(char** a, int a_count, char** b, int b_count) {\n    if (a_count != b_count) return false;\n    for (int i = 0; i < a_count; i++) {\n        if (strcmp(a[i], b[i]) != 0) return false;\n    }\n    return true;\n}\n\nvoid free_words(char** words, int count) {\n    for (int i = 0; i < count; i++)\n        free(words[i]);\n    free(words);\n}\n\nint main() {\n    int count;\n    char** result;\n\n    char* expected1[] = {\"Hi\", \"my\", \"name\", \"is\", \"John\"};\n    result = func0(\"Hi, my name is John\", &count);\n    assert(issame(result, count, expected1, 5));\n    free_words(result, count);\n\n    char* expected2[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One, two, three, four, five, six\", &count);\n    assert(issame(result, count, expected2, 6));\n    free_words(result, count);\n\n    char* expected3[] = {\"Hi\", \"my\", \"name\"};\n    result = func0(\"Hi, my name\", &count);\n    assert(issame(result, count, expected3, 3));\n    free_words(result, count);\n\n    char* expected4[] = {\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"};\n    result = func0(\"One,, two, three, four, five, six,\", &count);\n    assert(issame(result, count, expected4, 6));\n    free_words(result, count);\n\n    char* expected5[] = {};\n    result = func0(\"\", &count);\n    assert(issame(result, count, expected5, 0));\n    free_words(result, count);\n\n    char* expected6[] = {\"ahmed\", \"gamal\"};\n    result = func0(\"ahmed     , gamal\", &count);\n    assert(issame(result, count, expected6, 2));\n    free_words(result, count);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    $0x50,%edi\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  call   10b0 <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r14\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     12b0 <func0+0x110>\n  add    $0x1,%rbx\n  xor    %ebp,%ebp\n  xor    %r15d,%r15d\n  mov    $0xa,%r13d\n  jmp    1215 <func0+0x75>\n  nopw   0x0(%rax,%rax,1)\n  movslq %ebp,%rdx\n  add    $0x1,%ebp\n  mov    %al,(%r14,%rdx,1)\n  movzbl (%rbx),%eax\n  add    $0x1,%rbx\n  test   %al,%al\n  je     1268 <func0+0xc8>\n  cmp    $0x20,%al\n  je     121d <func0+0x7d>\n  cmp    $0x2c,%al\n  jne    1200 <func0+0x60>\n  test   %ebp,%ebp\n  je     120a <func0+0x6a>\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  movb   $0x0,(%r14,%rbp,1)\n  lea    0x1(%r15),%ebp\n  call   10d0 <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  movslq %ebp,%r15\n  xor    %ebp,%ebp\n  cmp    %r13d,%r15d\n  jl     120a <func0+0x6a>\n  add    %r13d,%r13d\n  mov    %r12,%rdi\n  add    $0x1,%rbx\n  movslq %r13d,%rsi\n  shl    $0x3,%rsi\n  call   10c0 <realloc@plt>\n  mov    %rax,%r12\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  jne    1215 <func0+0x75>\n  nopl   0x0(%rax)\n  test   %ebp,%ebp\n  jne    1290 <func0+0xf0>\n  mov    %r14,%rdi\n  call   1090 <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  lea    0x1(%r15),%ebx\n  movb   $0x0,(%r14,%rbp,1)\n  call   10d0 <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  mov    %ebx,%r15d\n  jmp    126c <func0+0xcc>\n  nopl   (%rax)\n  xor    %r15d,%r15d\n  jmp    126c <func0+0xcc>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  mov    $0x50,%edi\n  sub    $0x18,%rsp\n  mov    %rsi,0x8(%rsp)\n  call   <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  movzbl (%rbx),%eax\n  test   %al,%al\n  je     L0\n  add    $0x1,%rbx\n  xor    %ebp,%ebp\n  xor    %r15d,%r15d\n  mov    $0xa,%r13d\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL4:\n  movslq %ebp,%rdx\n  add    $0x1,%ebp\n  mov    %al,(%r14,%rdx,1)\nL5:\n  movzbl (%rbx),%eax\n  add    $0x1,%rbx\n  test   %al,%al\n  je     L2\nL1:\n  cmp    $0x20,%al\n  je     L3\n  cmp    $0x2c,%al\n  jne    L4\nL3:\n  test   %ebp,%ebp\n  je     L5\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  movb   $0x0,(%r14,%rbp,1)\n  lea    0x1(%r15),%ebp\n  call   <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  movslq %ebp,%r15\n  xor    %ebp,%ebp\n  cmp    %r13d,%r15d\n  jl     L5\n  add    %r13d,%r13d\n  mov    %r12,%rdi\n  add    $0x1,%rbx\n  movslq %r13d,%rsi\n  shl    $0x3,%rsi\n  call   <realloc@plt>\n  mov    %rax,%r12\n  movzbl -0x1(%rbx),%eax\n  test   %al,%al\n  jne    L1\n  nopl   0x0(%rax)\nL2:\n  test   %ebp,%ebp\n  jne    L6\nL7:\n  mov    %r14,%rdi\n  call   <free@plt>\n  mov    0x8(%rsp),%rax\n  mov    %r15d,(%rax)\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\nL6:\n  movslq %ebp,%rbp\n  mov    %r14,%rdi\n  lea    0x1(%r15),%ebx\n  movb   $0x0,(%r14,%rbp,1)\n  call   <strdup@plt>\n  mov    %rax,(%r12,%r15,8)\n  mov    %ebx,%r15d\n  jmp    L7\n  nopl   (%rax)\nL0:\n  xor    %r15d,%r15d\n  jmp    L7",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4784
            },
            "L1": {
                "label": "L1",
                "addr": 4629
            },
            "L2": {
                "label": "L2",
                "addr": 4712
            },
            "L3": {
                "label": "L3",
                "addr": 4637
            },
            "L4": {
                "label": "L4",
                "addr": 4608
            },
            "L5": {
                "label": "L5",
                "addr": 4618
            },
            "L6": {
                "label": "L6",
                "addr": 4752
            },
            "L7": {
                "label": "L7",
                "addr": 4716
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 102,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jge    1116 <func0+0x1d>\n  mov    $0xffffffff,%eax\n  jmp    1156 <func0+0x5d>\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jne    1138 <func0+0x3f>\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1138 <func0+0x3f>\n  mov    $0xffffffff,%eax\n  jmp    1156 <func0+0x5d>\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1153 <func0+0x5a>\n  mov    -0x8(%rbp),%eax\n  sub    $0x1,%eax\n  jmp    1156 <func0+0x5d>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jge    L0\n  mov    $0xffffffff,%eax\n  jmp    L1\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jne    L2\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L2\n  mov    $0xffffffff,%eax\n  jmp    L1\nL2:\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L3\n  mov    -0x8(%rbp),%eax\n  sub    $0x1,%eax\n  jmp    L1\nL3:\n  mov    -0x8(%rbp),%eax\nL1:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4374
            },
            "L1": {
                "label": "L1",
                "addr": 4438
            },
            "L2": {
                "label": "L2",
                "addr": 4408
            },
            "L3": {
                "label": "L3",
                "addr": 4435
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 102,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     1137 <func0+0x3e>\n  je     111e <func0+0x25>\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\n  mov    $0xffffffff,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     L0\n  je     L1\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\nL1:\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\nL0:\n  mov    $0xffffffff,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4407
            },
            "L1": {
                "label": "L1",
                "addr": 4382
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 102,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     1140 <func0+0x40>\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    %edi,%esi\n  je     1130 <func0+0x30>\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\n  nopl   0x0(%rax)\n  mov    $0xffffffff,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     L0\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    %edi,%esi\n  je     L1\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0xffffffff,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4400
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 102,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int x, int y) {\n    if (y < x) return -1;\n    if (y == x && y % 2 == 1) return -1;\n    if (y % 2 == 1) return y - 1;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(12, 15) == 14);\n    assert(func0(13, 12) == -1);\n    assert(func0(33, 12354) == 12354);\n    assert(func0(5234, 5233) == -1);\n    assert(func0(6, 29) == 28);\n    assert(func0(27, 10) == -1);\n    assert(func0(7, 7) == -1);\n    assert(func0(546, 546) == 546);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     1140 <func0+0x40>\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    %edi,%esi\n  je     1130 <func0+0x30>\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\n  nopl   0x0(%rax)\n  mov    $0xffffffff,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %esi,%eax\n  cmp    %edi,%esi\n  jl     L0\n  mov    %esi,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rsi,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    %edi,%esi\n  je     L1\n  cmp    $0x1,%edx\n  sete   %dl\n  movzbl %dl,%edx\n  sub    %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL1:\n  cmp    $0x1,%edx\n  mov    $0xffffffff,%edx\n  cmove  %edx,%eax\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0xffffffff,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4400
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 103,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    113f <func0+0x26>\n  lea    0xec6(%rip),%rax        # 2000 <_fini+0xe2c>\n  jmp    11d2 <func0+0xb9>\n  mov    -0x18(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x10(%rbp)\n  mov    $0x21,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x20,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x10(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x10(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x10(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jg     1185 <func0+0x6c>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x1(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    L0\n  lea    D0(%rip),%rax\n  jmp    L1\nL0:\n  mov    -0x18(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  add    %edx,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x10(%rbp)\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movb   $0x0,(%rax)\n  movl   $0x20,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\nL2:\n  mov    -0x10(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  lea    0x30(%rax),%ecx\n  mov    -0xc(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    %edx,-0xc(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  mov    -0x10(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x10(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jg     L2\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x1(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3782
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4415
            },
            "L1": {
                "label": "L1",
                "addr": 4562
            },
            "L2": {
                "label": "L2",
                "addr": 4485
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "2d3100",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"-1\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 103,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  lea    0xedc(%rip),%r8        # 2000 <_fini+0xe80>\n  cmp    %esi,%edi\n  jle    112c <func0+0x13>\n  mov    %r8,%rax\n  ret\n  push   %rbx\n  add    %esi,%edi\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  sar    %ebx\n  mov    $0x21,%edi\n  call   1050 <malloc@plt>\n  movb   $0x0,(%rax)\n  movb   $0x0,0x20(%rax)\n  add    $0x1f,%rax\n  mov    %rax,%r8\n  mov    %ebx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,(%rax)\n  mov    %ebx,%ecx\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  add    %ebx,%edx\n  mov    %edx,%ebx\n  sar    %ebx\n  sub    $0x1,%rax\n  cmp    $0x1,%ecx\n  jg     114d <func0+0x34>\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  lea    D0(%rip),%r8\n  cmp    %esi,%edi\n  jle    L0\n  mov    %r8,%rax\n  ret\nL0:\n  push   %rbx\n  add    %esi,%edi\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  sar    %ebx\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  movb   $0x0,(%rax)\n  movb   $0x0,0x20(%rax)\n  add    $0x1f,%rax\nL1:\n  mov    %rax,%r8\n  mov    %ebx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,(%rax)\n  mov    %ebx,%ecx\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  add    %ebx,%edx\n  mov    %edx,%ebx\n  sar    %ebx\n  sub    $0x1,%rax\n  cmp    $0x1,%ecx\n  jg     L1\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3804
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4396
            },
            "L1": {
                "label": "L1",
                "addr": 4429
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "2d3100",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"-1\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 103,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    %esi,%edi\n  jle    1138 <func0+0x18>\n  lea    0xed1(%rip),%r8        # 2000 <_fini+0xe74>\n  mov    %r8,%rax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  add    %esi,%edi\n  push   %rbx\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  mov    $0x21,%edi\n  call   1050 <malloc@plt>\n  sar    %ebx\n  movb   $0x0,(%rax)\n  add    $0x1f,%rax\n  movb   $0x0,0x1(%rax)\n  nopl   0x0(%rax)\n  mov    %ebx,%ecx\n  mov    %rax,%r8\n  sub    $0x1,%rax\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rax)\n  mov    %ebx,%edx\n  mov    %ecx,%ebx\n  add    %edx,%ebx\n  sar    %ebx\n  cmp    $0x1,%edx\n  jg     1160 <func0+0x40>\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    %esi,%edi\n  jle    L0\n  lea    D0(%rip),%r8\n  mov    %r8,%rax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  add    %esi,%edi\n  push   %rbx\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  sar    %ebx\n  movb   $0x0,(%rax)\n  add    $0x1f,%rax\n  movb   $0x0,0x1(%rax)\n  nopl   0x0(%rax)\nL1:\n  mov    %ebx,%ecx\n  mov    %rax,%r8\n  sub    $0x1,%rax\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rax)\n  mov    %ebx,%edx\n  mov    %ecx,%ebx\n  add    %edx,%ebx\n  sar    %ebx\n  cmp    $0x1,%edx\n  jg     L1\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3793
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4448
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "2d3100",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"-1\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 103,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* func0(int n, int m) {\n    if (n > m) return \"-1\";\n    int num = (m + n) / 2;\n    char* out = (char*)malloc(33);\n    out[0] = '\\0';\n\n    int index = 32;\n    out[index--] = '\\0';\n\n    do {\n        out[index--] = '0' + num % 2;\n        num /= 2;\n    } while (num > 0);\n\n    return &out[index + 1]; \n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 5), \"11\") == 0);\n    assert(strcmp(func0(7, 13), \"1010\") == 0);\n    assert(strcmp(func0(964, 977), \"1111001010\") == 0);\n    assert(strcmp(func0(996, 997), \"1111100100\") == 0);\n    assert(strcmp(func0(560, 851), \"1011000001\") == 0);\n    assert(strcmp(func0(185, 546), \"101101101\") == 0);\n    assert(strcmp(func0(362, 496), \"110101101\") == 0);\n    assert(strcmp(func0(350, 902), \"1001110010\") == 0);\n    assert(strcmp(func0(197, 233), \"11010111\") == 0);\n    assert(strcmp(func0(7, 5), \"-1\") == 0);\n    assert(strcmp(func0(5, 1), \"-1\") == 0);\n    assert(strcmp(func0(5, 5), \"101\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    %esi,%edi\n  jle    1138 <func0+0x18>\n  lea    0xed1(%rip),%r8        # 2000 <_fini+0xe74>\n  mov    %r8,%rax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  add    %esi,%edi\n  push   %rbx\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  mov    $0x21,%edi\n  call   1050 <malloc@plt>\n  sar    %ebx\n  movb   $0x0,(%rax)\n  add    $0x1f,%rax\n  movb   $0x0,0x1(%rax)\n  nopl   0x0(%rax)\n  mov    %ebx,%ecx\n  mov    %rax,%r8\n  sub    $0x1,%rax\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rax)\n  mov    %ebx,%edx\n  mov    %ecx,%ebx\n  add    %edx,%ebx\n  sar    %ebx\n  cmp    $0x1,%edx\n  jg     1160 <func0+0x40>\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    %esi,%edi\n  jle    L0\n  lea    D0(%rip),%r8\n  mov    %r8,%rax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  add    %esi,%edi\n  push   %rbx\n  mov    %edi,%ebx\n  shr    $0x1f,%ebx\n  add    %edi,%ebx\n  mov    $0x21,%edi\n  call   <malloc@plt>\n  sar    %ebx\n  movb   $0x0,(%rax)\n  add    $0x1f,%rax\n  movb   $0x0,0x1(%rax)\n  nopl   0x0(%rax)\nL1:\n  mov    %ebx,%ecx\n  mov    %rax,%r8\n  sub    $0x1,%rax\n  shr    $0x1f,%ecx\n  lea    (%rbx,%rcx,1),%edx\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  add    $0x30,%edx\n  mov    %dl,0x1(%rax)\n  mov    %ebx,%edx\n  mov    %ecx,%ebx\n  add    %edx,%ebx\n  sar    %ebx\n  cmp    $0x1,%edx\n  jg     L1\n  mov    %r8,%rax\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3793
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4448
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "2d3100",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"-1\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 104,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %rcx,-0x40(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x40(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x14(%rbp)\n  jmp    121a <func0+0x101>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  movb   $0x0,-0x15(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jne    11bc <func0+0xa3>\n  movb   $0x1,-0x15(%rbp)\n  jmp    11bc <func0+0xa3>\n  mov    -0x10(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    119c <func0+0x83>\n  movb   $0x1,-0x15(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x10(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jle    11cd <func0+0xb4>\n  movzbl -0x15(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  jne    118e <func0+0x75>\n  movzbl -0x15(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     1216 <func0+0xfd>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x40(%rbp),%rax\n  mov    %edx,(%rax)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1165 <func0+0x4c>\n  movl   $0x0,-0xc(%rbp)\n  jmp    12f0 <func0+0x1d7>\n  movl   $0x0,-0x8(%rbp)\n  jmp    12d7 <func0+0x1be>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    12d3 <func0+0x1ba>\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  sub    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x8(%rbp)\n  jl     123e <func0+0x125>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     1232 <func0+0x119>\n  nop\n  nop\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %rdx,-0x38(%rbp)\n  mov    %rcx,-0x40(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x38(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x40(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL6:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  movb   $0x0,-0x15(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jne    L1\n  movb   $0x1,-0x15(%rbp)\n  jmp    L1\nL4:\n  mov    -0x10(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L2\n  movb   $0x1,-0x15(%rbp)\nL2:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x10(%rbp)\nL1:\n  cmpl   $0x0,-0x10(%rbp)\n  jle    L3\n  movzbl -0x15(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  jne    L4\nL3:\n  movzbl -0x15(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     L5\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x40(%rbp),%rax\n  mov    %edx,(%rax)\nL5:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L6\n  movl   $0x0,-0xc(%rbp)\n  jmp    L7\nL11:\n  movl   $0x0,-0x8(%rbp)\n  jmp    L8\nL10:\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rcx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L9\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    (%rcx),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%rax\n  mov    (%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\nL9:\n  addl   $0x1,-0x8(%rbp)\nL8:\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  sub    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x8(%rbp)\n  jl     L10\n  addl   $0x1,-0xc(%rbp)\nL7:\n  mov    -0x40(%rbp),%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     L11\n  nop\n  nop\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4634
            },
            "L1": {
                "label": "L1",
                "addr": 4540
            },
            "L2": {
                "label": "L2",
                "addr": 4508
            },
            "L3": {
                "label": "L3",
                "addr": 4557
            },
            "L4": {
                "label": "L4",
                "addr": 4494
            },
            "L5": {
                "label": "L5",
                "addr": 4630
            },
            "L6": {
                "label": "L6",
                "addr": 4453
            },
            "L7": {
                "label": "L7",
                "addr": 4848
            },
            "L8": {
                "label": "L8",
                "addr": 4823
            },
            "L9": {
                "label": "L9",
                "addr": 4819
            },
            "L10": {
                "label": "L10",
                "addr": 4670
            },
            "L11": {
                "label": "L11",
                "addr": 4658
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 104,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r13\n  mov    %esi,%r12d\n  mov    %rdx,%rbx\n  mov    %rcx,%rbp\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,(%rbx)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    1208 <func0+0xef>\n  mov    %r13,%rsi\n  lea    -0x1(%r12),%eax\n  lea    0x4(%r13,%rax,4),%r8\n  jmp    118b <func0+0x72>\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    1197 <func0+0x7e>\n  mov    %eax,%edx\n  test   $0x1,%dl\n  jne    1161 <func0+0x48>\n  add    $0x4,%rsi\n  cmp    %rsi,%r8\n  je     11a7 <func0+0x8e>\n  mov    (%rsi),%edi\n  test   %edi,%edi\n  jle    1195 <func0+0x7c>\n  mov    %edi,%edx\n  jmp    117d <func0+0x64>\n  je     1182 <func0+0x69>\n  movslq 0x0(%rbp),%rdx\n  mov    (%rbx),%rax\n  mov    %edi,(%rax,%rdx,4)\n  addl   $0x1,0x0(%rbp)\n  jmp    1182 <func0+0x69>\n  cmpl   $0x1,0x0(%rbp)\n  jle    1208 <func0+0xef>\n  mov    $0x0,%r8d\n  jmp    11f1 <func0+0xd8>\n  add    $0x1,%ecx\n  mov    %r8d,%edx\n  not    %edx\n  add    0x0(%rbp),%edx\n  cmp    %ecx,%edx\n  jle    11e2 <func0+0xc9>\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rax,1),%rdi\n  mov    (%rdi),%esi\n  add    $0x4,%rax\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%esi\n  jle    11b5 <func0+0x9c>\n  mov    %edx,(%rdi)\n  mov    (%rbx),%rdx\n  mov    %esi,(%rdx,%rax,1)\n  jmp    11b5 <func0+0x9c>\n  add    $0x1,%r8d\n  mov    0x0(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %r8d,%eax\n  jle    1208 <func0+0xef>\n  mov    0x0(%rbp),%edx\n  sub    %r8d,%edx\n  mov    $0x0,%eax\n  mov    $0x0,%ecx\n  cmp    $0x1,%edx\n  jg     11c4 <func0+0xab>\n  jmp    11e2 <func0+0xc9>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r13\n  mov    %esi,%r12d\n  mov    %rdx,%rbx\n  mov    %rcx,%rbp\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    L0\n  mov    %r13,%rsi\n  lea    -0x1(%r12),%eax\n  lea    0x4(%r13,%rax,4),%r8\n  jmp    L1\nL3:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    L2\n  mov    %eax,%edx\nL6:\n  test   $0x1,%dl\n  jne    L3\nL7:\n  add    $0x4,%rsi\n  cmp    %rsi,%r8\n  je     L4\nL1:\n  mov    (%rsi),%edi\n  test   %edi,%edi\n  jle    L5\n  mov    %edi,%edx\n  jmp    L6\nL5:\n  je     L7\nL2:\n  movslq 0x0(%rbp),%rdx\n  mov    (%rbx),%rax\n  mov    %edi,(%rax,%rdx,4)\n  addl   $0x1,0x0(%rbp)\n  jmp    L7\nL4:\n  cmpl   $0x1,0x0(%rbp)\n  jle    L0\n  mov    $0x0,%r8d\n  jmp    L8\nL10:\n  add    $0x1,%ecx\n  mov    %r8d,%edx\n  not    %edx\n  add    0x0(%rbp),%edx\n  cmp    %ecx,%edx\n  jle    L9\nL11:\n  mov    (%rbx),%rdx\n  lea    (%rdx,%rax,1),%rdi\n  mov    (%rdi),%esi\n  add    $0x4,%rax\n  mov    (%rdx,%rax,1),%edx\n  cmp    %edx,%esi\n  jle    L10\n  mov    %edx,(%rdi)\n  mov    (%rbx),%rdx\n  mov    %esi,(%rdx,%rax,1)\n  jmp    L10\nL9:\n  add    $0x1,%r8d\n  mov    0x0(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %r8d,%eax\n  jle    L0\nL8:\n  mov    0x0(%rbp),%edx\n  sub    %r8d,%edx\n  mov    $0x0,%eax\n  mov    $0x0,%ecx\n  cmp    $0x1,%edx\n  jg     L11\n  jmp    L9\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4616
            },
            "L1": {
                "label": "L1",
                "addr": 4491
            },
            "L2": {
                "label": "L2",
                "addr": 4503
            },
            "L3": {
                "label": "L3",
                "addr": 4449
            },
            "L4": {
                "label": "L4",
                "addr": 4519
            },
            "L5": {
                "label": "L5",
                "addr": 4501
            },
            "L6": {
                "label": "L6",
                "addr": 4477
            },
            "L7": {
                "label": "L7",
                "addr": 4482
            },
            "L8": {
                "label": "L8",
                "addr": 4593
            },
            "L9": {
                "label": "L9",
                "addr": 4578
            },
            "L10": {
                "label": "L10",
                "addr": 4533
            },
            "L11": {
                "label": "L11",
                "addr": 4548
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 104,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  mov    %rax,0x0(%r13)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    11f5 <func0+0xd5>\n  mov    %rax,%r8\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%r9\n  xor    %esi,%esi\n  lea    0x4(%rbx,%rax,4),%r11\n  mov    $0xcccccccd,%edi\n  nopl   0x0(%rax)\n  mov    (%r9),%r10d\n  test   %r10d,%r10d\n  je     11ad <func0+0x8d>\n  jle    1204 <func0+0xe4>\n  mov    %r10d,%eax\n  nopl   0x0(%rax)\n  mov    %eax,%edx\n  mov    %eax,%eax\n  mov    %rax,%rcx\n  imul   %rdi,%rax\n  not    %edx\n  and    $0x1,%edx\n  shr    $0x23,%rax\n  cmp    $0x9,%ecx\n  jle    1200 <func0+0xe0>\n  test   %dl,%dl\n  je     1190 <func0+0x70>\n  add    $0x4,%r9\n  cmp    %r11,%r9\n  jne    1178 <func0+0x58>\n  lea    -0x1(%rsi),%edx\n  test   %edx,%edx\n  jle    11f5 <func0+0xd5>\n  lea    0x4(%r8),%r9\n  nopl   0x0(%rax)\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r9,%rdx,4),%rsi\n  nopl   (%rax)\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11e6 <func0+0xc6>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    11d8 <func0+0xb8>\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    11c8 <func0+0xa8>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  test   %dl,%dl\n  jne    11ad <func0+0x8d>\n  movslq %esi,%rax\n  add    $0x4,%r9\n  add    $0x1,%esi\n  mov    %r10d,(%r8,%rax,4)\n  mov    %esi,0x0(%rbp)\n  cmp    %r11,%r9\n  jne    1178 <func0+0x58>\n  jmp    11b6 <func0+0x96>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %rax,0x0(%r13)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    L0\n  mov    %rax,%r8\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%r9\n  xor    %esi,%esi\n  lea    0x4(%rbx,%rax,4),%r11\n  mov    $0xcccccccd,%edi\n  nopl   0x0(%rax)\nL5:\n  mov    (%r9),%r10d\n  test   %r10d,%r10d\n  je     L1\n  jle    L2\n  mov    %r10d,%eax\n  nopl   0x0(%rax)\nL4:\n  mov    %eax,%edx\n  mov    %eax,%eax\n  mov    %rax,%rcx\n  imul   %rdi,%rax\n  not    %edx\n  and    $0x1,%edx\n  shr    $0x23,%rax\n  cmp    $0x9,%ecx\n  jle    L3\n  test   %dl,%dl\n  je     L4\nL1:\n  add    $0x4,%r9\n  cmp    %r11,%r9\n  jne    L5\nL9:\n  lea    -0x1(%rsi),%edx\n  test   %edx,%edx\n  jle    L0\n  lea    0x4(%r8),%r9\n  nopl   0x0(%rax)\nL8:\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r9,%rdx,4),%rsi\n  nopl   (%rax)\nL7:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L6\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\nL6:\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    L7\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    L8\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL3:\n  test   %dl,%dl\n  jne    L1\nL2:\n  movslq %esi,%rax\n  add    $0x4,%r9\n  add    $0x1,%esi\n  mov    %r10d,(%r8,%rax,4)\n  mov    %esi,0x0(%rbp)\n  cmp    %r11,%r9\n  jne    L5\n  jmp    L9",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4597
            },
            "L1": {
                "label": "L1",
                "addr": 4525
            },
            "L2": {
                "label": "L2",
                "addr": 4612
            },
            "L3": {
                "label": "L3",
                "addr": 4608
            },
            "L4": {
                "label": "L4",
                "addr": 4496
            },
            "L5": {
                "label": "L5",
                "addr": 4472
            },
            "L6": {
                "label": "L6",
                "addr": 4582
            },
            "L7": {
                "label": "L7",
                "addr": 4568
            },
            "L8": {
                "label": "L8",
                "addr": 4552
            },
            "L9": {
                "label": "L9",
                "addr": 4534
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 104,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nvoid func0(int *x, int size, int **out, int *out_size) {\n    *out = malloc(size * sizeof(int));\n    *out_size = 0;\n\n    for (int i = 0; i < size; i++) {\n        int num = x[i];\n        bool has_even_digit = false;\n        if (num == 0) has_even_digit = true;\n\n        while (num > 0 && !has_even_digit) {\n            if (num % 2 == 0) has_even_digit = true;\n            num = num / 10;\n        }\n\n        if (!has_even_digit) {\n            (*out)[*out_size] = x[i];\n            (*out_size)++;\n        }\n    }\n\n    for (int i = 0; i < *out_size - 1; i++) {\n        for (int j = 0; j < *out_size - i - 1; j++) {\n            if ((*out)[j] > (*out)[j + 1]) {\n                int temp = (*out)[j];\n                (*out)[j] = (*out)[j + 1];\n                (*out)[j + 1] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <assert.h>\n\nbool issame(int *a, int a_size, int *b, int b_size) {\n    if (a_size != b_size) return false;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test cases\n    int test1[] = {15, 33, 1422, 1};\n    int expected1[] = {1, 15, 33};\n    int *out1;\n    int out1_size;\n    func0(test1, 4, &out1, &out1_size);\n    assert(issame(out1, out1_size, expected1, 3));\n    free(out1);\n\n    int test2[] = {152, 323, 1422, 10};\n    int *out2;\n    int out2_size;\n    func0(test2, 4, &out2, &out2_size);\n    assert(issame(out2, out2_size, NULL, 0));\n    free(out2);\n\n    int test3[] = {12345, 2033, 111, 151};\n    int expected3[] = {111, 151};\n    int *out3;\n    int out3_size;\n    func0(test3, 4, &out3, &out3_size);\n    assert(issame(out3, out3_size, expected3, 2));\n    free(out3);\n\n    int test4[] = {135, 103, 31};\n    int expected4[] = {31, 135};\n    int *out4;\n    int out4_size;\n    func0(test4, 3, &out4, &out4_size);\n    assert(issame(out4, out4_size, expected4, 2));\n    free(out4);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   1050 <malloc@plt>\n  mov    %rax,0x0(%r13)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    1205 <func0+0xe5>\n  mov    %rax,%r8\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%r9\n  xor    %esi,%esi\n  lea    0x4(%rbx,%rax,4),%r11\n  mov    $0xcccccccd,%edi\n  nopl   0x0(%rax)\n  mov    (%r9),%r10d\n  test   %r10d,%r10d\n  je     11ad <func0+0x8d>\n  jle    1214 <func0+0xf4>\n  mov    %r10d,%eax\n  nopl   0x0(%rax)\n  mov    %eax,%edx\n  mov    %eax,%eax\n  mov    %rax,%rcx\n  imul   %rdi,%rax\n  not    %edx\n  and    $0x1,%edx\n  shr    $0x23,%rax\n  cmp    $0x9,%ecx\n  jle    1210 <func0+0xf0>\n  test   %dl,%dl\n  je     1190 <func0+0x70>\n  add    $0x4,%r9\n  cmp    %r9,%r11\n  jne    1178 <func0+0x58>\n  lea    -0x1(%rsi),%eax\n  test   %eax,%eax\n  jle    1205 <func0+0xe5>\n  lea    0x4(%r8),%r9\n  nopl   0x0(%rax)\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%r9,%rax,4),%rsi\n  nopl   (%rax)\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    11f6 <func0+0xd6>\n  movq   %xmm1,(%rdx)\n  add    $0x4,%rdx\n  cmp    %rdx,%rsi\n  jne    11d8 <func0+0xb8>\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    11c8 <func0+0xa8>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  test   %dl,%dl\n  jne    11ad <func0+0x8d>\n  movslq %esi,%rax\n  add    $0x4,%r9\n  add    $0x1,%esi\n  mov    %r10d,(%r8,%rax,4)\n  mov    %esi,0x0(%rbp)\n  cmp    %r9,%r11\n  jne    1178 <func0+0x58>\n  jmp    11b6 <func0+0x96>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rdx,%r13\n  push   %r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  movslq %esi,%rdi\n  mov    %rdi,%r12\n  shl    $0x2,%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %rax,0x0(%r13)\n  movl   $0x0,0x0(%rbp)\n  test   %r12d,%r12d\n  jle    L0\n  mov    %rax,%r8\n  lea    -0x1(%r12),%eax\n  mov    %rbx,%r9\n  xor    %esi,%esi\n  lea    0x4(%rbx,%rax,4),%r11\n  mov    $0xcccccccd,%edi\n  nopl   0x0(%rax)\nL5:\n  mov    (%r9),%r10d\n  test   %r10d,%r10d\n  je     L1\n  jle    L2\n  mov    %r10d,%eax\n  nopl   0x0(%rax)\nL4:\n  mov    %eax,%edx\n  mov    %eax,%eax\n  mov    %rax,%rcx\n  imul   %rdi,%rax\n  not    %edx\n  and    $0x1,%edx\n  shr    $0x23,%rax\n  cmp    $0x9,%ecx\n  jle    L3\n  test   %dl,%dl\n  je     L4\nL1:\n  add    $0x4,%r9\n  cmp    %r9,%r11\n  jne    L5\nL9:\n  lea    -0x1(%rsi),%eax\n  test   %eax,%eax\n  jle    L0\n  lea    0x4(%r8),%r9\n  nopl   0x0(%rax)\nL8:\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%r9,%rax,4),%rsi\n  nopl   (%rax)\nL7:\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    L6\n  movq   %xmm1,(%rdx)\nL6:\n  add    $0x4,%rdx\n  cmp    %rdx,%rsi\n  jne    L7\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    L8\nL0:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL3:\n  test   %dl,%dl\n  jne    L1\nL2:\n  movslq %esi,%rax\n  add    $0x4,%r9\n  add    $0x1,%esi\n  mov    %r10d,(%r8,%rax,4)\n  mov    %esi,0x0(%rbp)\n  cmp    %r9,%r11\n  jne    L5\n  jmp    L9",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4613
            },
            "L1": {
                "label": "L1",
                "addr": 4525
            },
            "L2": {
                "label": "L2",
                "addr": 4628
            },
            "L3": {
                "label": "L3",
                "addr": 4624
            },
            "L4": {
                "label": "L4",
                "addr": 4496
            },
            "L5": {
                "label": "L5",
                "addr": 4472
            },
            "L6": {
                "label": "L6",
                "addr": 4598
            },
            "L7": {
                "label": "L7",
                "addr": 4568
            },
            "L8": {
                "label": "L8",
                "addr": 4552
            },
            "L9": {
                "label": "L9",
                "addr": 4534
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 105,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x90,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %esi,-0x7c(%rbp)\n  mov    %rdx,-0x88(%rbp)\n  mov    %rcx,-0x90(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    0xe8d(%rip),%rax        # 2000 <_fini+0xc00>\n  mov    %rax,-0x60(%rbp)\n  lea    0xe83(%rip),%rax        # 2001 <_fini+0xc01>\n  mov    %rax,-0x58(%rbp)\n  lea    0xe7c(%rip),%rax        # 2005 <_fini+0xc05>\n  mov    %rax,-0x50(%rbp)\n  lea    0xe75(%rip),%rax        # 2009 <_fini+0xc09>\n  mov    %rax,-0x48(%rbp)\n  lea    0xe70(%rip),%rax        # 200f <_fini+0xc0f>\n  mov    %rax,-0x40(%rbp)\n  lea    0xe6a(%rip),%rax        # 2014 <_fini+0xc14>\n  mov    %rax,-0x38(%rbp)\n  lea    0xe64(%rip),%rax        # 2019 <_fini+0xc19>\n  mov    %rax,-0x30(%rbp)\n  lea    0xe5d(%rip),%rax        # 201d <_fini+0xc1d>\n  mov    %rax,-0x28(%rbp)\n  lea    0xe58(%rip),%rax        # 2023 <_fini+0xc23>\n  mov    %rax,-0x20(%rbp)\n  lea    0xe53(%rip),%rax        # 2029 <_fini+0xc29>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x6c(%rbp)\n  jmp    12a7 <func0+0x16e>\n  movl   $0x0,-0x68(%rbp)\n  jmp    1291 <func0+0x158>\n  mov    -0x68(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x78(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    128d <func0+0x154>\n  mov    -0x68(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x64(%rbp)\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x68(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x78(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x64(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x68(%rbp)\n  mov    -0x7c(%rbp),%eax\n  sub    -0x6c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x68(%rbp)\n  jl     11f2 <func0+0xb9>\n  addl   $0x1,-0x6c(%rbp)\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x6c(%rbp)\n  jl     11e6 <func0+0xad>\n  mov    -0x90(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x6c(%rbp)\n  jmp    131c <func0+0x1e3>\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    1318 <func0+0x1df>\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x9,%eax\n  jg     1318 <func0+0x1df>\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x90(%rbp),%rax\n  mov    %edx,(%rax)\n  subl   $0x1,-0x6c(%rbp)\n  cmpl   $0x0,-0x6c(%rbp)\n  jns    12ce <func0+0x195>\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x88(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x6c(%rbp)\n  movl   $0x0,-0x68(%rbp)\n  jmp    13cf <func0+0x296>\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    13cb <func0+0x292>\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x9,%eax\n  jg     13cb <func0+0x292>\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%rsi\n  mov    -0x68(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x68(%rbp)\n  cltq\n  shl    $0x3,%rax\n  lea    (%rsi,%rax,1),%rdx\n  movslq %ecx,%rax\n  mov    -0x60(%rbp,%rax,8),%rax\n  mov    %rax,(%rdx)\n  subl   $0x1,-0x6c(%rbp)\n  cmpl   $0x0,-0x6c(%rbp)\n  js     13e7 <func0+0x2ae>\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x68(%rbp)\n  jl     1358 <func0+0x21f>\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     13fc <func0+0x2c3>\n  call   1060 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x90,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %esi,-0x7c(%rbp)\n  mov    %rdx,-0x88(%rbp)\n  mov    %rcx,-0x90(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,-0x60(%rbp)\n  lea    D1(%rip),%rax\n  mov    %rax,-0x58(%rbp)\n  lea    D2(%rip),%rax\n  mov    %rax,-0x50(%rbp)\n  lea    D3(%rip),%rax\n  mov    %rax,-0x48(%rbp)\n  lea    D4(%rip),%rax\n  mov    %rax,-0x40(%rbp)\n  lea    D5(%rip),%rax\n  mov    %rax,-0x38(%rbp)\n  lea    D6(%rip),%rax\n  mov    %rax,-0x30(%rbp)\n  lea    D7(%rip),%rax\n  mov    %rax,-0x28(%rbp)\n  lea    D8(%rip),%rax\n  mov    %rax,-0x20(%rbp)\n  lea    D9(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x6c(%rbp)\n  jmp    L0\nL4:\n  movl   $0x0,-0x68(%rbp)\n  jmp    L1\nL3:\n  mov    -0x68(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x78(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L2\n  mov    -0x68(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x64(%rbp)\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x68(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x78(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x68(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x64(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  addl   $0x1,-0x68(%rbp)\nL1:\n  mov    -0x7c(%rbp),%eax\n  sub    -0x6c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x68(%rbp)\n  jl     L3\n  addl   $0x1,-0x6c(%rbp)\nL0:\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x6c(%rbp)\n  jl     L4\n  mov    -0x90(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x6c(%rbp)\n  jmp    L5\nL7:\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    L6\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x9,%eax\n  jg     L6\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x90(%rbp),%rax\n  mov    %edx,(%rax)\nL6:\n  subl   $0x1,-0x6c(%rbp)\nL5:\n  cmpl   $0x0,-0x6c(%rbp)\n  jns    L7\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x88(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x7c(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x6c(%rbp)\n  movl   $0x0,-0x68(%rbp)\n  jmp    L8\nL11:\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    L9\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x9,%eax\n  jg     L9\n  mov    -0x6c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x78(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%rsi\n  mov    -0x68(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x68(%rbp)\n  cltq\n  shl    $0x3,%rax\n  lea    (%rsi,%rax,1),%rdx\n  movslq %ecx,%rax\n  mov    -0x60(%rbp,%rax,8),%rax\n  mov    %rax,(%rdx)\nL9:\n  subl   $0x1,-0x6c(%rbp)\nL8:\n  cmpl   $0x0,-0x6c(%rbp)\n  js     L10\n  mov    -0x90(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x68(%rbp)\n  jl     L11\nL10:\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     L12\n  call   <__stack_chk_fail@plt>\nL12:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3725
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8193,
                "bias": [
                    3715
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8197,
                "bias": [
                    3708
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8201,
                "bias": [
                    3701
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8207,
                "bias": [
                    3696
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8212,
                "bias": [
                    3690
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8217,
                "bias": [
                    3684
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8221,
                "bias": [
                    3677
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8227,
                "bias": [
                    3672
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8233,
                "bias": [
                    3667
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4775
            },
            "L1": {
                "label": "L1",
                "addr": 4753
            },
            "L2": {
                "label": "L2",
                "addr": 4749
            },
            "L3": {
                "label": "L3",
                "addr": 4594
            },
            "L4": {
                "label": "L4",
                "addr": 4582
            },
            "L5": {
                "label": "L5",
                "addr": 4892
            },
            "L6": {
                "label": "L6",
                "addr": 4888
            },
            "L7": {
                "label": "L7",
                "addr": 4814
            },
            "L8": {
                "label": "L8",
                "addr": 5071
            },
            "L9": {
                "label": "L9",
                "addr": 5067
            },
            "L10": {
                "label": "L10",
                "addr": 5095
            },
            "L11": {
                "label": "L11",
                "addr": 4952
            },
            "L12": {
                "label": "L12",
                "addr": 5116
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "004f6e650054776f00546872656500466f757200466976650053697800536576656e004569676874004e696e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"\""
                },
                "0x2001": {
                    "type": "string",
                    "value": "\"One\""
                },
                "0x2023": {
                    "type": "string",
                    "value": "\"Eight\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"Two\""
                },
                "0x2009": {
                    "type": "string",
                    "value": "\"Three\""
                },
                "0x2029": {
                    "type": "string",
                    "value": "\"Nine\""
                },
                "0x200f": {
                    "type": "string",
                    "value": "\"Four\""
                },
                "0x2014": {
                    "type": "string",
                    "value": "\"Five\""
                },
                "0x2019": {
                    "type": "string",
                    "value": "\"Six\""
                },
                "0x201d": {
                    "type": "string",
                    "value": "\"Seven\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 105,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %rdi,%rbx\n  mov    %rdx,%r12\n  mov    %rcx,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    0xea6(%rip),%rax        # 200d <_fini+0xd45>\n  mov    %rax,(%rsp)\n  lea    0xe8e(%rip),%rax        # 2000 <_fini+0xd38>\n  mov    %rax,0x8(%rsp)\n  lea    0xe86(%rip),%rax        # 2004 <_fini+0xd3c>\n  mov    %rax,0x10(%rsp)\n  lea    0xe7e(%rip),%rax        # 2008 <_fini+0xd40>\n  mov    %rax,0x18(%rsp)\n  lea    0xe78(%rip),%rax        # 200e <_fini+0xd46>\n  mov    %rax,0x20(%rsp)\n  lea    0xe71(%rip),%rax        # 2013 <_fini+0xd4b>\n  mov    %rax,0x28(%rsp)\n  lea    0xe6a(%rip),%rax        # 2018 <_fini+0xd50>\n  mov    %rax,0x30(%rsp)\n  lea    0xe62(%rip),%rax        # 201c <_fini+0xd54>\n  mov    %rax,0x38(%rsp)\n  lea    0xe5c(%rip),%rax        # 2022 <_fini+0xd5a>\n  mov    %rax,0x40(%rsp)\n  lea    0xe56(%rip),%rax        # 2028 <_fini+0xd60>\n  mov    %rax,0x48(%rsp)\n  lea    -0x1(%rsi),%r13d\n  test   %r13d,%r13d\n  jle    121b <func0+0xe2>\n  mov    %r13d,%edi\n  lea    0x4(%rbx),%r8\n  jmp    120b <func0+0xd2>\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     1202 <func0+0xc9>\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    11e9 <func0+0xb0>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    11e9 <func0+0xb0>\n  sub    $0x1,%edi\n  je     12b1 <func0+0x178>\n  test   %edi,%edi\n  jle    1202 <func0+0xc9>\n  mov    %rbx,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r8,%rdx,4),%rsi\n  jmp    11f2 <func0+0xb9>\n  movl   $0x0,(%rcx)\n  je     12b8 <func0+0x17f>\n  mov    $0x0,%edi\n  call   1070 <malloc@plt>\n  mov    %rax,(%r12)\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12c0 <func0+0x187>\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  sub    $0x1,%rax\n  test   %eax,%eax\n  js     1299 <func0+0x160>\n  mov    (%rbx,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     1250 <func0+0x117>\n  addl   $0x1,0x0(%rbp)\n  jmp    1250 <func0+0x117>\n  sub    $0x1,%r13\n  test   %r13d,%r13d\n  js     1235 <func0+0xfc>\n  cmp    %edx,0x0(%rbp)\n  jle    1235 <func0+0xfc>\n  mov    (%rbx,%r13,4),%eax\n  lea    -0x1(%rax),%ecx\n  cmp    $0x8,%ecx\n  ja     1269 <func0+0x130>\n  movslq %edx,%rsi\n  mov    (%r12),%rcx\n  cltq\n  mov    (%rsp,%rax,8),%rax\n  mov    %rax,(%rcx,%rsi,8)\n  lea    0x1(%rdx),%edx\n  jmp    1269 <func0+0x130>\n  movslq 0x0(%rbp),%rdi\n  shl    $0x3,%rdi\n  call   1070 <malloc@plt>\n  mov    %rax,(%r12)\n  mov    $0x0,%edx\n  jmp    1272 <func0+0x139>\n  movl   $0x0,0x0(%rbp)\n  movslq %r13d,%r13\n  mov    %r13,%rax\n  jmp    1258 <func0+0x11f>\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %rdi,%rbx\n  mov    %rdx,%r12\n  mov    %rcx,%rbp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x8(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x10(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x18(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x20(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x28(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x30(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  lea    -0x1(%rsi),%r13d\n  test   %r13d,%r13d\n  jle    L0\n  mov    %r13d,%edi\n  lea    0x4(%rbx),%r8\n  jmp    L1\nL3:\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     L2\nL5:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L3\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    L3\nL2:\n  sub    $0x1,%edi\n  je     L4\nL1:\n  test   %edi,%edi\n  jle    L2\n  mov    %rbx,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r8,%rdx,4),%rsi\n  jmp    L5\nL0:\n  movl   $0x0,(%rcx)\n  je     L6\n  mov    $0x0,%edi\n  call   <malloc@plt>\n  mov    %rax,(%r12)\nL10:\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL9:\n  sub    $0x1,%rax\n  test   %eax,%eax\n  js     L8\nL13:\n  mov    (%rbx,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     L9\n  addl   $0x1,0x0(%rbp)\n  jmp    L9\nL11:\n  sub    $0x1,%r13\n  test   %r13d,%r13d\n  js     L10\nL12:\n  cmp    %edx,0x0(%rbp)\n  jle    L10\n  mov    (%rbx,%r13,4),%eax\n  lea    -0x1(%rax),%ecx\n  cmp    $0x8,%ecx\n  ja     L11\n  movslq %edx,%rsi\n  mov    (%r12),%rcx\n  cltq\n  mov    (%rsp,%rax,8),%rax\n  mov    %rax,(%rcx,%rsi,8)\n  lea    0x1(%rdx),%edx\n  jmp    L11\nL8:\n  movslq 0x0(%rbp),%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%r12)\n  mov    $0x0,%edx\n  jmp    L12\nL4:\n  movl   $0x0,0x0(%rbp)\nL6:\n  movslq %r13d,%r13\n  mov    %r13,%rax\n  jmp    L13\nL7:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8205,
                "bias": [
                    3750
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3726
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8196,
                "bias": [
                    3718
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8200,
                "bias": [
                    3710
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8206,
                "bias": [
                    3704
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8211,
                "bias": [
                    3697
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8216,
                "bias": [
                    3690
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8220,
                "bias": [
                    3682
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8226,
                "bias": [
                    3676
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8232,
                "bias": [
                    3670
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4635
            },
            "L1": {
                "label": "L1",
                "addr": 4619
            },
            "L2": {
                "label": "L2",
                "addr": 4610
            },
            "L3": {
                "label": "L3",
                "addr": 4585
            },
            "L4": {
                "label": "L4",
                "addr": 4785
            },
            "L5": {
                "label": "L5",
                "addr": 4594
            },
            "L6": {
                "label": "L6",
                "addr": 4792
            },
            "L7": {
                "label": "L7",
                "addr": 4800
            },
            "L8": {
                "label": "L8",
                "addr": 4761
            },
            "L9": {
                "label": "L9",
                "addr": 4688
            },
            "L10": {
                "label": "L10",
                "addr": 4661
            },
            "L11": {
                "label": "L11",
                "addr": 4713
            },
            "L12": {
                "label": "L12",
                "addr": 4722
            },
            "L13": {
                "label": "L13",
                "addr": 4696
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4f6e650054776f00546872656500466f757200466976650053697800536576656e004569676874004e696e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"One\""
                },
                "0x2022": {
                    "type": "string",
                    "value": "\"Eight\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"Two\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"Three\""
                },
                "0x2028": {
                    "type": "string",
                    "value": "\"Nine\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"\""
                },
                "0x200e": {
                    "type": "string",
                    "value": "\"Four\""
                },
                "0x2013": {
                    "type": "string",
                    "value": "\"Five\""
                },
                "0x2018": {
                    "type": "string",
                    "value": "\"Six\""
                },
                "0x201c": {
                    "type": "string",
                    "value": "\"Seven\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 105,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rcx,%r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  lea    -0x1(%rsi),%ebx\n  sub    $0x68,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  lea    0xe9e(%rip),%rax        # 200d <_fini+0xd3d>\n  mov    %rax,(%rsp)\n  lea    0xe86(%rip),%rax        # 2000 <_fini+0xd30>\n  mov    %rax,0x8(%rsp)\n  lea    0xe7e(%rip),%rax        # 2004 <_fini+0xd34>\n  mov    %rax,0x10(%rsp)\n  lea    0xe76(%rip),%rax        # 2008 <_fini+0xd38>\n  mov    %rax,0x18(%rsp)\n  lea    0xe70(%rip),%rax        # 200e <_fini+0xd3e>\n  mov    %rax,0x20(%rsp)\n  lea    0xe69(%rip),%rax        # 2013 <_fini+0xd43>\n  mov    %rax,0x28(%rsp)\n  lea    0xe62(%rip),%rax        # 2018 <_fini+0xd48>\n  mov    %rax,0x30(%rsp)\n  lea    0xe5a(%rip),%rax        # 201c <_fini+0xd4c>\n  mov    %rax,0x38(%rsp)\n  lea    0xe54(%rip),%rax        # 2022 <_fini+0xd52>\n  mov    %rax,0x40(%rsp)\n  lea    0xe4e(%rip),%rax        # 2028 <_fini+0xd58>\n  mov    %rax,0x48(%rsp)\n  test   %ebx,%ebx\n  jle    12b2 <func0+0x172>\n  mov    %ebx,%edx\n  lea    0x4(%rdi),%r8\n  nopl   (%rax)\n  sub    $0x1,%edx\n  mov    %rbp,%rax\n  mov    %rdx,%rdi\n  lea    (%r8,%rdx,4),%rsi\n  nopl   (%rax)\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    120e <func0+0xce>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    1200 <func0+0xc0>\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    11f0 <func0+0xb0>\n  movl   $0x0,0x0(%r13)\n  movslq %ebx,%rbx\n  xor    %ecx,%ecx\n  mov    %rbx,%rax\n  nopl   (%rax)\n  mov    0x0(%rbp,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     1243 <func0+0x103>\n  add    $0x1,%ecx\n  mov    %ecx,0x0(%r13)\n  sub    $0x1,%rax\n  test   %eax,%eax\n  jns    1230 <func0+0xf0>\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,8),%rdi\n  call   1070 <malloc@plt>\n  mov    0x0(%r13),%edi\n  xor    %ecx,%ecx\n  mov    %rax,(%r12)\n  jmp    1293 <func0+0x153>\n  nopw   0x0(%rax,%rax,1)\n  movslq 0x0(%rbp,%rbx,4),%rdx\n  lea    -0x1(%rdx),%esi\n  cmp    $0x8,%esi\n  ja     128b <func0+0x14b>\n  mov    (%rsp,%rdx,8),%rdx\n  movslq %ecx,%rsi\n  add    $0x1,%ecx\n  mov    %rdx,(%rax,%rsi,8)\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     1297 <func0+0x157>\n  cmp    %ecx,%edi\n  jg     1270 <func0+0x130>\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12cb <func0+0x18b>\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  movl   $0x0,(%rcx)\n  je     1225 <func0+0xe5>\n  xor    %edi,%edi\n  call   1070 <malloc@plt>\n  mov    %rax,(%r12)\n  jmp    1297 <func0+0x157>\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rcx,%r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  lea    -0x1(%rsi),%ebx\n  sub    $0x68,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  lea    D0(%rip),%rax\n  mov    %rax,(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x8(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x10(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x18(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x20(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x28(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x30(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  test   %ebx,%ebx\n  jle    L0\n  mov    %ebx,%edx\n  lea    0x4(%rdi),%r8\n  nopl   (%rax)\nL3:\n  sub    $0x1,%edx\n  mov    %rbp,%rax\n  mov    %rdx,%rdi\n  lea    (%r8,%rdx,4),%rsi\n  nopl   (%rax)\nL2:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L1\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\nL1:\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    L2\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    L3\n  movl   $0x0,0x0(%r13)\nL11:\n  movslq %ebx,%rbx\n  xor    %ecx,%ecx\n  mov    %rbx,%rax\n  nopl   (%rax)\nL5:\n  mov    0x0(%rbp,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     L4\n  add    $0x1,%ecx\n  mov    %ecx,0x0(%r13)\nL4:\n  sub    $0x1,%rax\n  test   %eax,%eax\n  jns    L5\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,8),%rdi\n  call   <malloc@plt>\n  mov    0x0(%r13),%edi\n  xor    %ecx,%ecx\n  mov    %rax,(%r12)\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL9:\n  movslq 0x0(%rbp,%rbx,4),%rdx\n  lea    -0x1(%rdx),%esi\n  cmp    $0x8,%esi\n  ja     L7\n  mov    (%rsp,%rdx,8),%rdx\n  movslq %ecx,%rsi\n  add    $0x1,%ecx\n  mov    %rdx,(%rax,%rsi,8)\nL7:\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     L8\nL6:\n  cmp    %ecx,%edi\n  jg     L9\nL8:\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L10\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL0:\n  movl   $0x0,(%rcx)\n  je     L11\n  xor    %edi,%edi\n  call   <malloc@plt>\n  mov    %rax,(%r12)\n  jmp    L8\nL10:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8205,
                "bias": [
                    3742
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3718
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8196,
                "bias": [
                    3710
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8200,
                "bias": [
                    3702
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8206,
                "bias": [
                    3696
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8211,
                "bias": [
                    3689
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8216,
                "bias": [
                    3682
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8220,
                "bias": [
                    3674
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8226,
                "bias": [
                    3668
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8232,
                "bias": [
                    3662
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4786
            },
            "L1": {
                "label": "L1",
                "addr": 4622
            },
            "L2": {
                "label": "L2",
                "addr": 4608
            },
            "L3": {
                "label": "L3",
                "addr": 4592
            },
            "L4": {
                "label": "L4",
                "addr": 4675
            },
            "L5": {
                "label": "L5",
                "addr": 4656
            },
            "L6": {
                "label": "L6",
                "addr": 4755
            },
            "L7": {
                "label": "L7",
                "addr": 4747
            },
            "L8": {
                "label": "L8",
                "addr": 4759
            },
            "L9": {
                "label": "L9",
                "addr": 4720
            },
            "L10": {
                "label": "L10",
                "addr": 4811
            },
            "L11": {
                "label": "L11",
                "addr": 4645
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4f6e650054776f00546872656500466f757200466976650053697800536576656e004569676874004e696e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"One\""
                },
                "0x2022": {
                    "type": "string",
                    "value": "\"Eight\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"Two\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"Three\""
                },
                "0x2028": {
                    "type": "string",
                    "value": "\"Nine\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"\""
                },
                "0x200e": {
                    "type": "string",
                    "value": "\"Four\""
                },
                "0x2013": {
                    "type": "string",
                    "value": "\"Five\""
                },
                "0x2018": {
                    "type": "string",
                    "value": "\"Six\""
                },
                "0x201c": {
                    "type": "string",
                    "value": "\"Seven\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 105,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func0(int *arr, int size, char ***out, int *out_size) {\n    char *names[] = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n    int i, j;\n\n    for (i = 0; i < size - 1; i++) {\n        for (j = 0; j < size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    *out_size = 0;\n    for (i = size - 1; i >= 0; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out_size)++;\n        }\n    }\n\n    *out = malloc(*out_size * sizeof(char *));\n\n    for (i = size - 1, j = 0; i >= 0 && j < *out_size; i--) {\n        if (arr[i] >= 1 && arr[i] <= 9) {\n            (*out)[j++] = names[arr[i]];\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint issame(char **a, int a_size, char **b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    char **out;\n    int out_size;\n\n    int test1[] = {2, 1, 1, 4, 5, 8, 2, 3};\n    char *expected1[] = {\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"};\n    func0(test1, 8, &out, &out_size);\n    assert(issame(out, out_size, expected1, 8));\n    free(out);\n\n    int test2[] = {};\n    func0(test2, 0, &out, &out_size);\n    assert(issame(out, out_size, NULL, 0));\n    free(out);\n\n    int test3[] = {1, -1, 55};\n    char *expected3[] = {\"One\"};\n    func0(test3, 3, &out, &out_size);\n    assert(issame(out, out_size, expected3, 1));\n    free(out);\n\n    int test4[] = {1, -1, 3, 2};\n    char *expected4[] = {\"Three\", \"Two\", \"One\"};\n    func0(test4, 4, &out, &out_size);\n    assert(issame(out, out_size, expected4, 3));\n    free(out);\n\n    int test5[] = {9, 4, 8};\n    char *expected5[] = {\"Nine\", \"Eight\", \"Four\"};\n    func0(test5, 3, &out, &out_size);\n    assert(issame(out, out_size, expected5, 3));\n    free(out);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rcx,%r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  lea    0xeb3(%rip),%rbx        # 200d <_fini+0xcfd>\n  movq   %rbx,%xmm0\n  lea    0xe9e(%rip),%rbx        # 2004 <_fini+0xcf4>\n  sub    $0x68,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  lea    0xe81(%rip),%rax        # 2000 <_fini+0xcf0>\n  movq   %rax,%xmm3\n  lea    0xe7d(%rip),%rax        # 2008 <_fini+0xcf8>\n  punpcklqdq %xmm3,%xmm0\n  movq   %rax,%xmm4\n  lea    0xe78(%rip),%rax        # 2013 <_fini+0xd03>\n  movaps %xmm0,(%rsp)\n  movq   %rbx,%xmm0\n  lea    0xe63(%rip),%rbx        # 200e <_fini+0xcfe>\n  movq   %rax,%xmm5\n  punpcklqdq %xmm4,%xmm0\n  lea    0xe61(%rip),%rax        # 201c <_fini+0xd0c>\n  movaps %xmm0,0x10(%rsp)\n  movq   %rbx,%xmm0\n  movq   %rax,%xmm6\n  lea    0xe47(%rip),%rbx        # 2018 <_fini+0xd08>\n  punpcklqdq %xmm5,%xmm0\n  lea    0xe4c(%rip),%rax        # 2028 <_fini+0xd18>\n  movaps %xmm0,0x20(%rsp)\n  movq   %rbx,%xmm0\n  movq   %rax,%xmm7\n  lea    0xe30(%rip),%rbx        # 2022 <_fini+0xd12>\n  punpcklqdq %xmm6,%xmm0\n  movaps %xmm0,0x30(%rsp)\n  movq   %rbx,%xmm0\n  lea    -0x1(%rsi),%ebx\n  punpcklqdq %xmm7,%xmm0\n  movaps %xmm0,0x40(%rsp)\n  test   %ebx,%ebx\n  jle    12f2 <func0+0x1b2>\n  mov    %ebx,%eax\n  lea    0x4(%rdi),%r8\n  nopw   0x0(%rax,%rax,1)\n  sub    $0x1,%eax\n  mov    %rbp,%rdx\n  mov    %rax,%rdi\n  lea    (%r8,%rax,4),%rsi\n  nopl   (%rax)\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    124e <func0+0x10e>\n  movq   %xmm1,(%rdx)\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    1230 <func0+0xf0>\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    1220 <func0+0xe0>\n  movl   $0x0,0x0(%r13)\n  movslq %ebx,%rbx\n  xor    %ecx,%ecx\n  mov    %rbx,%rax\n  nopl   (%rax)\n  mov    0x0(%rbp,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     1283 <func0+0x143>\n  add    $0x1,%ecx\n  mov    %ecx,0x0(%r13)\n  sub    $0x1,%rax\n  test   %eax,%eax\n  jns    1270 <func0+0x130>\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,8),%rdi\n  call   1070 <malloc@plt>\n  mov    0x0(%r13),%edi\n  xor    %ecx,%ecx\n  mov    %rax,(%r12)\n  jmp    12d3 <func0+0x193>\n  nopw   0x0(%rax,%rax,1)\n  movslq 0x0(%rbp,%rbx,4),%rdx\n  lea    -0x1(%rdx),%esi\n  cmp    $0x8,%esi\n  ja     12cb <func0+0x18b>\n  mov    (%rsp,%rdx,8),%rdx\n  movslq %ecx,%rsi\n  add    $0x1,%ecx\n  mov    %rdx,(%rax,%rsi,8)\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     12d7 <func0+0x197>\n  cmp    %ecx,%edi\n  jg     12b0 <func0+0x170>\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    130b <func0+0x1cb>\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  movl   $0x0,(%rcx)\n  je     1265 <func0+0x125>\n  xor    %edi,%edi\n  call   1070 <malloc@plt>\n  mov    %rax,(%r12)\n  jmp    12d7 <func0+0x197>\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  mov    %rcx,%r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  lea    D0(%rip),%rbx\n  movq   %rbx,%xmm0\n  lea    D1(%rip),%rbx\n  sub    $0x68,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  lea    D2(%rip),%rax\n  movq   %rax,%xmm3\n  lea    D3(%rip),%rax\n  punpcklqdq %xmm3,%xmm0\n  movq   %rax,%xmm4\n  lea    D4(%rip),%rax\n  movaps %xmm0,(%rsp)\n  movq   %rbx,%xmm0\n  lea    D5(%rip),%rbx\n  movq   %rax,%xmm5\n  punpcklqdq %xmm4,%xmm0\n  lea    D6(%rip),%rax\n  movaps %xmm0,0x10(%rsp)\n  movq   %rbx,%xmm0\n  movq   %rax,%xmm6\n  lea    D7(%rip),%rbx\n  punpcklqdq %xmm5,%xmm0\n  lea    D8(%rip),%rax\n  movaps %xmm0,0x20(%rsp)\n  movq   %rbx,%xmm0\n  movq   %rax,%xmm7\n  lea    D9(%rip),%rbx\n  punpcklqdq %xmm6,%xmm0\n  movaps %xmm0,0x30(%rsp)\n  movq   %rbx,%xmm0\n  lea    -0x1(%rsi),%ebx\n  punpcklqdq %xmm7,%xmm0\n  movaps %xmm0,0x40(%rsp)\n  test   %ebx,%ebx\n  jle    L0\n  mov    %ebx,%eax\n  lea    0x4(%rdi),%r8\n  nopw   0x0(%rax,%rax,1)\nL3:\n  sub    $0x1,%eax\n  mov    %rbp,%rdx\n  mov    %rax,%rdi\n  lea    (%r8,%rax,4),%rsi\n  nopl   (%rax)\nL2:\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%ecx\n  movd   %xmm2,%eax\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jle    L1\n  movq   %xmm1,(%rdx)\nL1:\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    L2\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    L3\n  movl   $0x0,0x0(%r13)\nL11:\n  movslq %ebx,%rbx\n  xor    %ecx,%ecx\n  mov    %rbx,%rax\n  nopl   (%rax)\nL5:\n  mov    0x0(%rbp,%rax,4),%edi\n  lea    -0x1(%rdi),%edx\n  cmp    $0x8,%edx\n  ja     L4\n  add    $0x1,%ecx\n  mov    %ecx,0x0(%r13)\nL4:\n  sub    $0x1,%rax\n  test   %eax,%eax\n  jns    L5\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,8),%rdi\n  call   <malloc@plt>\n  mov    0x0(%r13),%edi\n  xor    %ecx,%ecx\n  mov    %rax,(%r12)\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL9:\n  movslq 0x0(%rbp,%rbx,4),%rdx\n  lea    -0x1(%rdx),%esi\n  cmp    $0x8,%esi\n  ja     L7\n  mov    (%rsp,%rdx,8),%rdx\n  movslq %ecx,%rsi\n  add    $0x1,%ecx\n  mov    %rdx,(%rax,%rsi,8)\nL7:\n  sub    $0x1,%rbx\n  test   %ebx,%ebx\n  js     L8\nL6:\n  cmp    %ecx,%edi\n  jg     L9\nL8:\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L10\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL0:\n  movl   $0x0,(%rcx)\n  je     L11\n  xor    %edi,%edi\n  call   <malloc@plt>\n  mov    %rax,(%r12)\n  jmp    L8\nL10:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8205,
                "bias": [
                    3763
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3742
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8192,
                "bias": [
                    3713
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8200,
                "bias": [
                    3709
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8211,
                "bias": [
                    3704
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8206,
                "bias": [
                    3683
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8220,
                "bias": [
                    3681
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8216,
                "bias": [
                    3655
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8232,
                "bias": [
                    3660
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8226,
                "bias": [
                    3632
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4850
            },
            "L1": {
                "label": "L1",
                "addr": 4686
            },
            "L2": {
                "label": "L2",
                "addr": 4656
            },
            "L3": {
                "label": "L3",
                "addr": 4640
            },
            "L4": {
                "label": "L4",
                "addr": 4739
            },
            "L5": {
                "label": "L5",
                "addr": 4720
            },
            "L6": {
                "label": "L6",
                "addr": 4819
            },
            "L7": {
                "label": "L7",
                "addr": 4811
            },
            "L8": {
                "label": "L8",
                "addr": 4823
            },
            "L9": {
                "label": "L9",
                "addr": 4784
            },
            "L10": {
                "label": "L10",
                "addr": 4875
            },
            "L11": {
                "label": "L11",
                "addr": 4709
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4f6e650054776f00546872656500466f757200466976650053697800536576656e004569676874004e696e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"One\""
                },
                "0x2022": {
                    "type": "string",
                    "value": "\"Eight\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"Two\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"Three\""
                },
                "0x2028": {
                    "type": "string",
                    "value": "\"Nine\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"\""
                },
                "0x200e": {
                    "type": "string",
                    "value": "\"Four\""
                },
                "0x2013": {
                    "type": "string",
                    "value": "\"Five\""
                },
                "0x2018": {
                    "type": "string",
                    "value": "\"Six\""
                },
                "0x201c": {
                    "type": "string",
                    "value": "\"Seven\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 106,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  jmp    11a6 <func0+0x8d>\n  mov    -0xc(%rbp),%eax\n  add    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  imul   -0xc(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    1189 <func0+0x70>\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x10(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    11a2 <func0+0x89>\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    1154 <func0+0x3b>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x1,-0x10(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  jmp    L0\nL3:\n  mov    -0xc(%rbp),%eax\n  add    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  imul   -0xc(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x10(%rbp),%eax\n  mov    %eax,(%rdx)\n  jmp    L2\nL1:\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    L3\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4518
            },
            "L1": {
                "label": "L1",
                "addr": 4489
            },
            "L2": {
                "label": "L2",
                "addr": 4514
            },
            "L3": {
                "label": "L3",
                "addr": 4436
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 106,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  test   %ebx,%ebx\n  jle    115d <func0+0x44>\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%ecx\n  add    %edx,%ecx\n  imul   %edx,%esi\n  test   $0x1,%dl\n  mov    %esi,%edi\n  cmovne %ecx,%edi\n  mov    %edi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %r8,%rdx\n  jne    1143 <func0+0x2a>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%ecx\nL1:\n  add    %edx,%ecx\n  imul   %edx,%esi\n  test   $0x1,%dl\n  mov    %esi,%edi\n  cmovne %ecx,%edi\n  mov    %edi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %r8,%rdx\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4445
            },
            "L1": {
                "label": "L1",
                "addr": 4419
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 106,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  test   %ebx,%ebx\n  jle    116a <func0+0x4a>\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\n  imul   %edx,%esi\n  add    %edx,%ecx\n  test   $0x1,%dl\n  mov    %esi,%edi\n  cmovne %ecx,%edi\n  mov    %edi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%r8\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\nL1:\n  imul   %edx,%esi\n  add    %edx,%ecx\n  test   $0x1,%dl\n  mov    %esi,%edi\n  cmovne %ecx,%edi\n  mov    %edi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%r8\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4458
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 106,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc(n * sizeof(int));\n    int sum = 0, prod = 1;\n    for (int i = 1; i <= n; i++) {\n        sum += i;\n        prod *= i;\n        if (i % 2 == 0) out[i - 1] = prod;\n        else out[i - 1] = sum;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int a_size, int* b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int *result;\n    int expected1[] = {1, 2, 6, 24, 15};\n    result = func0(5);\n    assert(issame(result, 5, expected1, 5));\n    free(result);\n\n    int expected2[] = {1, 2, 6, 24, 15, 720, 28};\n    result = func0(7);\n    assert(issame(result, 7, expected2, 7));\n    free(result);\n\n    int expected3[] = {1};\n    result = func0(1);\n    assert(issame(result, 1, expected3, 1));\n    free(result);\n\n    int expected4[] = {1, 2, 6};\n    result = func0(3);\n    assert(issame(result, 3, expected4, 3));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  test   %ebx,%ebx\n  jle    1167 <func0+0x47>\n  lea    0x1(%rbx),%edi\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  xor    %ecx,%ecx\n  nopw   0x0(%rax,%rax,1)\n  imul   %edx,%esi\n  add    %edx,%ecx\n  test   $0x1,%dl\n  je     1170 <func0+0x50>\n  mov    %ecx,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rdi\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\n  mov    %esi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rdi\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  movslq %edi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%edi\n  mov    $0x1,%edx\n  mov    $0x1,%esi\n  xor    %ecx,%ecx\n  nopw   0x0(%rax,%rax,1)\nL2:\n  imul   %edx,%esi\n  add    %edx,%ecx\n  test   $0x1,%dl\n  je     L1\n  mov    %ecx,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rdi\n  jne    L2\nL0:\n  pop    %rbx\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    %esi,-0x4(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%rdi\n  jne    L2\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4455
            },
            "L1": {
                "label": "L1",
                "addr": 4464
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 107,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x0,(%rax)\n  movl   $0x1,-0x18(%rbp)\n  jmp    1209 <func0+0xf0>\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    11cd <func0+0xb4>\n  mov    -0x14(%rbp),%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  mov    %eax,%edi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  mov    %edx,%ecx\n  sub    %eax,%ecx\n  lea    (%rdi,%rcx,1),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x10(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jne    116f <func0+0x56>\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    1205 <func0+0xec>\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    11f6 <func0+0xdd>\n  mov    -0x8(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,(%rax)\n  jmp    1205 <func0+0xec>\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  mov    (%rax),%edx\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    115a <func0+0x41>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x24(%rbp)\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x0,(%rax)\n  movl   $0x1,-0x18(%rbp)\n  jmp    L0\nL5:\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    L1\nL2:\n  mov    -0x14(%rbp),%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  mov    %eax,%edi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  mov    %edx,%ecx\n  sub    %eax,%ecx\n  lea    (%rdi,%rcx,1),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x10(%rbp)\nL1:\n  cmpl   $0x0,-0x10(%rbp)\n  jne    L2\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    L3\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L4\n  mov    -0x8(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x8(%rbp),%rax\n  mov    %edx,(%rax)\n  jmp    L3\nL4:\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  mov    (%rax),%edx\n  add    $0x1,%edx\n  mov    %edx,(%rax)\nL3:\n  addl   $0x1,-0x18(%rbp)\nL0:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    L5\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4617
            },
            "L1": {
                "label": "L1",
                "addr": 4557
            },
            "L2": {
                "label": "L2",
                "addr": 4463
            },
            "L3": {
                "label": "L3",
                "addr": 4613
            },
            "L4": {
                "label": "L4",
                "addr": 4598
            },
            "L5": {
                "label": "L5",
                "addr": 4442
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 107,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  mov    %rax,%r9\n  movl   $0x0,(%rax)\n  movl   $0x0,0x4(%rax)\n  test   %ebx,%ebx\n  jle    119d <func0+0x84>\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edi\n  mov    $0x0,%r10d\n  jmp    115b <func0+0x42>\n  addl   $0x1,(%r9)\n  add    $0x1,%edi\n  cmp    %edi,%r8d\n  je     119d <func0+0x84>\n  mov    %edi,%edx\n  mov    %r10d,%ecx\n  test   %edi,%edi\n  je     114f <func0+0x36>\n  lea    (%rcx,%rcx,4),%esi\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  lea    (%rdx,%rsi,2),%ecx\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    1164 <func0+0x4b>\n  cmp    %edi,%ecx\n  jne    1153 <func0+0x3a>\n  test   $0x1,%dil\n  je     114f <func0+0x36>\n  addl   $0x1,0x4(%r9)\n  jmp    1153 <func0+0x3a>\n  mov    %r9,%rax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    %rax,%r9\n  movl   $0x0,(%rax)\n  movl   $0x0,0x4(%rax)\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r8d\n  mov    $0x1,%edi\n  mov    $0x0,%r10d\n  jmp    L1\nL2:\n  addl   $0x1,(%r9)\nL4:\n  add    $0x1,%edi\n  cmp    %edi,%r8d\n  je     L0\nL1:\n  mov    %edi,%edx\n  mov    %r10d,%ecx\n  test   %edi,%edi\n  je     L2\nL3:\n  lea    (%rcx,%rcx,4),%esi\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  lea    (%rdx,%rsi,2),%ecx\n  mov    %eax,%edx\n  test   %eax,%eax\n  jne    L3\n  cmp    %edi,%ecx\n  jne    L4\n  test   $0x1,%dil\n  je     L2\n  addl   $0x1,0x4(%r9)\n  jmp    L4\nL0:\n  mov    %r9,%rax\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4509
            },
            "L1": {
                "label": "L1",
                "addr": 4443
            },
            "L2": {
                "label": "L2",
                "addr": 4431
            },
            "L3": {
                "label": "L3",
                "addr": 4452
            },
            "L4": {
                "label": "L4",
                "addr": 4435
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 107,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  movq   $0x0,(%rax)\n  test   %ebx,%ebx\n  jle    1183 <func0+0x63>\n  lea    0x1(%rbx),%r10d\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%r8d\n  nopl   0x0(%rax)\n  mov    %r9d,%ecx\n  xor    %esi,%esi\n  nopl   (%rax)\n  mov    %ecx,%edx\n  lea    (%rsi,%rsi,4),%edi\n  imul   %r8,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%esi\n  add    %esi,%esi\n  sub    %esi,%ecx\n  lea    (%rcx,%rdi,2),%esi\n  mov    %edx,%ecx\n  test   %edx,%edx\n  jne    1158 <func0+0x38>\n  cmp    %esi,%r9d\n  je     1188 <func0+0x68>\n  add    $0x1,%r9d\n  cmp    %r9d,%r10d\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret\n  nopl   (%rax)\n  test   $0x1,%r9b\n  jne    1198 <func0+0x78>\n  addl   $0x1,(%rax)\n  jmp    117a <func0+0x5a>\n  nopl   0x0(%rax,%rax,1)\n  addl   $0x1,0x4(%rax)\n  jmp    117a <func0+0x5a>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  movq   $0x0,(%rax)\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r10d\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%r8d\n  nopl   0x0(%rax)\nL3:\n  mov    %r9d,%ecx\n  xor    %esi,%esi\n  nopl   (%rax)\nL1:\n  mov    %ecx,%edx\n  lea    (%rsi,%rsi,4),%edi\n  imul   %r8,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%esi\n  add    %esi,%esi\n  sub    %esi,%ecx\n  lea    (%rcx,%rdi,2),%esi\n  mov    %edx,%ecx\n  test   %edx,%edx\n  jne    L1\n  cmp    %esi,%r9d\n  je     L2\nL5:\n  add    $0x1,%r9d\n  cmp    %r9d,%r10d\n  jne    L3\nL0:\n  pop    %rbx\n  ret\n  nopl   (%rax)\nL2:\n  test   $0x1,%r9b\n  jne    L4\n  addl   $0x1,(%rax)\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL4:\n  addl   $0x1,0x4(%rax)\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4483
            },
            "L1": {
                "label": "L1",
                "addr": 4440
            },
            "L2": {
                "label": "L2",
                "addr": 4488
            },
            "L3": {
                "label": "L3",
                "addr": 4432
            },
            "L4": {
                "label": "L4",
                "addr": 4504
            },
            "L5": {
                "label": "L5",
                "addr": 4474
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 107,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* counts = (int*)malloc(2 * sizeof(int));\n    counts[0] = 0;\n    counts[1] = 0;\n\n    for (int i = 1; i <= n; i++) {\n        int reversed = 0, original = i;\n\n        int number = i;\n        while (number != 0) {\n            reversed = reversed * 10 + number % 10;\n            number /= 10;\n        }\n\n        if (original == reversed) {\n            if (original % 2 == 0) counts[0]++;\n            else counts[1]++;\n        }\n    }\n\n    return counts;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int* result;\n\n    result = func0(123);\n    int expected1[] = {8, 13};\n    assert(issame(result, expected1, 2));\n    free(result);\n\n    result = func0(12);\n    int expected2[] = {4, 6};\n    assert(issame(result, expected2, 2));\n    free(result);\n\n    result = func0(3);\n    int expected3[] = {1, 2};\n    assert(issame(result, expected3, 2));\n    free(result);\n\n    result = func0(63);\n    int expected4[] = {6, 8};\n    assert(issame(result, expected4, 2));\n    free(result);\n\n    result = func0(25);\n    int expected5[] = {5, 6};\n    assert(issame(result, expected5, 2));\n    free(result);\n\n    result = func0(19);\n    int expected6[] = {4, 6};\n    assert(issame(result, expected6, 2));\n    free(result);\n\n    result = func0(9);\n    int expected7[] = {4, 5};\n    assert(issame(result, expected7, 2));\n    free(result);\n\n    result = func0(1);\n    int expected8[] = {0, 1};\n    assert(issame(result, expected8, 2));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   1050 <malloc@plt>\n  movq   $0x0,(%rax)\n  test   %ebx,%ebx\n  jle    1183 <func0+0x63>\n  lea    0x1(%rbx),%r10d\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%r8d\n  nopl   0x0(%rax)\n  mov    %r9d,%ecx\n  xor    %esi,%esi\n  nopl   (%rax)\n  mov    %ecx,%edx\n  lea    (%rsi,%rsi,4),%edi\n  imul   %r8,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%esi\n  add    %esi,%esi\n  sub    %esi,%ecx\n  lea    (%rcx,%rdi,2),%esi\n  mov    %edx,%ecx\n  test   %edx,%edx\n  jne    1158 <func0+0x38>\n  cmp    %esi,%r9d\n  je     1188 <func0+0x68>\n  add    $0x1,%r9d\n  cmp    %r10d,%r9d\n  jne    1150 <func0+0x30>\n  pop    %rbx\n  ret\n  nopl   (%rax)\n  test   $0x1,%r9b\n  jne    1198 <func0+0x78>\n  addl   $0x1,(%rax)\n  jmp    117a <func0+0x5a>\n  nopl   0x0(%rax,%rax,1)\n  addl   $0x1,0x4(%rax)\n  jmp    117a <func0+0x5a>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  movq   $0x0,(%rax)\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r10d\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%r8d\n  nopl   0x0(%rax)\nL3:\n  mov    %r9d,%ecx\n  xor    %esi,%esi\n  nopl   (%rax)\nL1:\n  mov    %ecx,%edx\n  lea    (%rsi,%rsi,4),%edi\n  imul   %r8,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%esi\n  add    %esi,%esi\n  sub    %esi,%ecx\n  lea    (%rcx,%rdi,2),%esi\n  mov    %edx,%ecx\n  test   %edx,%edx\n  jne    L1\n  cmp    %esi,%r9d\n  je     L2\nL5:\n  add    $0x1,%r9d\n  cmp    %r10d,%r9d\n  jne    L3\nL0:\n  pop    %rbx\n  ret\n  nopl   (%rax)\nL2:\n  test   $0x1,%r9b\n  jne    L4\n  addl   $0x1,(%rax)\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL4:\n  addl   $0x1,0x4(%rax)\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4483
            },
            "L1": {
                "label": "L1",
                "addr": 4440
            },
            "L2": {
                "label": "L2",
                "addr": 4488
            },
            "L3": {
                "label": "L3",
                "addr": 4432
            },
            "L4": {
                "label": "L4",
                "addr": 4504
            },
            "L5": {
                "label": "L5",
                "addr": 4474
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 108,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11ce <func0+0xd5>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    113e <func0+0x45>\n  addl   $0x1,-0x10(%rbp)\n  jmp    11ca <func0+0xd1>\n  movl   $0x0,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    11b4 <func0+0xbb>\n  mov    -0x4(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  add    %edx,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x9,-0x4(%rbp)\n  jg     1167 <func0+0x6e>\n  mov    -0x4(%rbp),%eax\n  sub    %eax,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jle    11ca <func0+0xd1>\n  addl   $0x1,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111b <func0+0x22>\n  mov    -0x10(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL5:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    L1\n  addl   $0x1,-0x10(%rbp)\n  jmp    L2\nL1:\n  movl   $0x0,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,-0x4(%rbp)\n  jmp    L3\nL4:\n  mov    -0x4(%rbp),%ecx\n  movslq %ecx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %ecx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  mov    %edx,%eax\n  shl    $0x2,%eax\n  add    %edx,%eax\n  add    %eax,%eax\n  sub    %eax,%ecx\n  mov    %ecx,%edx\n  add    %edx,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x4(%rbp)\nL3:\n  cmpl   $0x9,-0x4(%rbp)\n  jg     L4\n  mov    -0x4(%rbp),%eax\n  sub    %eax,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  jle    L2\n  addl   $0x1,-0x10(%rbp)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    -0x10(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4558
            },
            "L1": {
                "label": "L1",
                "addr": 4414
            },
            "L2": {
                "label": "L2",
                "addr": 4554
            },
            "L3": {
                "label": "L3",
                "addr": 4532
            },
            "L4": {
                "label": "L4",
                "addr": 4455
            },
            "L5": {
                "label": "L5",
                "addr": 4379
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 108,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    116f <func0+0x76>\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r10\n  mov    $0x0,%r9d\n  jmp    1162 <func0+0x69>\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  cmp    $0x9,%edx\n  jle    1159 <func0+0x60>\n  mov    $0x0,%esi\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  mov    %edx,%edi\n  sub    %ecx,%edi\n  add    %edi,%esi\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  cmp    $0x63,%ecx\n  jg     1125 <func0+0x2c>\n  cmp    %eax,%esi\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%r9d\n  add    $0x4,%r8\n  cmp    %r10,%r8\n  je     1175 <func0+0x7c>\n  mov    (%r8),%eax\n  test   %eax,%eax\n  jle    1114 <func0+0x1b>\n  add    $0x1,%r9d\n  jmp    1159 <func0+0x60>\n  mov    $0x0,%r9d\n  mov    %r9d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r10\n  mov    $0x0,%r9d\n  jmp    L1\nL5:\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  cmp    $0x9,%edx\n  jle    L2\n  mov    $0x0,%esi\nL3:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  mov    %edx,%edi\n  sub    %ecx,%edi\n  add    %edi,%esi\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  cmp    $0x63,%ecx\n  jg     L3\n  cmp    %eax,%esi\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%r9d\nL2:\n  add    $0x4,%r8\n  cmp    %r10,%r8\n  je     L4\nL1:\n  mov    (%r8),%eax\n  test   %eax,%eax\n  jle    L5\n  add    $0x1,%r9d\n  jmp    L2\nL0:\n  mov    $0x0,%r9d\nL4:\n  mov    %r9d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4463
            },
            "L1": {
                "label": "L1",
                "addr": 4450
            },
            "L2": {
                "label": "L2",
                "addr": 4441
            },
            "L3": {
                "label": "L3",
                "addr": 4389
            },
            "L4": {
                "label": "L4",
                "addr": 4469
            },
            "L5": {
                "label": "L5",
                "addr": 4372
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 108,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1178 <func0+0x78>\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%r10d\n  lea    0x4(%rdi,%rax,4),%r11\n  jmp    112d <func0+0x2d>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%r9d\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  je     1174 <func0+0x74>\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  jg     1120 <func0+0x20>\n  mov    %eax,%edx\n  neg    %edx\n  cmp    $0xfffffff7,%eax\n  jge    1124 <func0+0x24>\n  xor    %esi,%esi\n  xchg   %ax,%ax\n  mov    %edx,%eax\n  mov    %edx,%r8d\n  imul   %r10,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%r8d\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  add    %r8d,%esi\n  cmp    $0x63,%ecx\n  jg     1140 <func0+0x40>\n  xor    %eax,%eax\n  cmp    %edx,%esi\n  setg   %al\n  add    $0x4,%rdi\n  add    %eax,%r9d\n  cmp    %r11,%rdi\n  jne    112d <func0+0x2d>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%r10d\n  lea    0x4(%rdi,%rax,4),%r11\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%r9d\nL4:\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  je     L2\nL1:\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  jg     L3\n  mov    %eax,%edx\n  neg    %edx\n  cmp    $0xfffffff7,%eax\n  jge    L4\n  xor    %esi,%esi\n  xchg   %ax,%ax\nL5:\n  mov    %edx,%eax\n  mov    %edx,%r8d\n  imul   %r10,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%r8d\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  add    %r8d,%esi\n  cmp    $0x63,%ecx\n  jg     L5\n  xor    %eax,%eax\n  cmp    %edx,%esi\n  setg   %al\n  add    $0x4,%rdi\n  add    %eax,%r9d\n  cmp    %r11,%rdi\n  jne    L1\nL2:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4472
            },
            "L1": {
                "label": "L1",
                "addr": 4397
            },
            "L2": {
                "label": "L2",
                "addr": 4468
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4388
            },
            "L5": {
                "label": "L5",
                "addr": 4416
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 108,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *n, int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (n[i] > 0) {\n            num += 1;\n        } else {\n            int sum = 0;\n            int w = abs(n[i]);\n            while (w >= 10) {\n                sum += w % 10;\n                w = w / 10;\n            }\n            sum -= w;\n            if (sum > 0) num += 1;\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const int[]){}, 0) == 0);\n    assert(func0((const int[]){-1, -2, 0}, 3) == 0);\n    assert(func0((const int[]){1, 1, 2, -2, 3, 4, 5}, 7) == 6);\n    assert(func0((const int[]){1, 6, 9, -6, 0, 1, 5}, 7) == 5);\n    assert(func0((const int[]){1, 100, 98, -7, 1, -1}, 6) == 4);\n    assert(func0((const int[]){12, 23, 34, -45, -56, 0}, 6) == 5);\n    assert(func0((const int[]){-0, 1}, 2) == 1);\n    assert(func0((const int[]){1}, 1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1178 <func0+0x78>\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%r10d\n  lea    0x4(%rdi,%rax,4),%r11\n  jmp    112d <func0+0x2d>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%r9d\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  je     1174 <func0+0x74>\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  jg     1120 <func0+0x20>\n  mov    %eax,%edx\n  neg    %edx\n  cmp    $0xfffffff7,%eax\n  jge    1124 <func0+0x24>\n  xor    %esi,%esi\n  xchg   %ax,%ax\n  mov    %edx,%eax\n  mov    %edx,%r8d\n  imul   %r10,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%r8d\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  add    %r8d,%esi\n  cmp    $0x63,%ecx\n  jg     1140 <func0+0x40>\n  xor    %eax,%eax\n  cmp    %edx,%esi\n  setg   %al\n  add    $0x4,%rdi\n  add    %eax,%r9d\n  cmp    %r11,%rdi\n  jne    112d <func0+0x2d>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%r10d\n  lea    0x4(%rdi,%rax,4),%r11\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%r9d\nL4:\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  je     L2\nL1:\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  jg     L3\n  mov    %eax,%edx\n  neg    %edx\n  cmp    $0xfffffff7,%eax\n  jge    L4\n  xor    %esi,%esi\n  xchg   %ax,%ax\nL5:\n  mov    %edx,%eax\n  mov    %edx,%r8d\n  imul   %r10,%rax\n  shr    $0x23,%rax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  sub    %ecx,%r8d\n  mov    %edx,%ecx\n  mov    %eax,%edx\n  add    %r8d,%esi\n  cmp    $0x63,%ecx\n  jg     L5\n  xor    %eax,%eax\n  cmp    %edx,%esi\n  setg   %al\n  add    $0x4,%rdi\n  add    %eax,%r9d\n  cmp    %r11,%rdi\n  jne    L1\nL2:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4472
            },
            "L1": {
                "label": "L1",
                "addr": 4397
            },
            "L2": {
                "label": "L2",
                "addr": 4468
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4388
            },
            "L5": {
                "label": "L5",
                "addr": 4416
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 109,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    111c <func0+0x23>\n  mov    $0x1,%eax\n  jmp    119b <func0+0xa2>\n  movl   $0x1,-0x4(%rbp)\n  jmp    115d <func0+0x64>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    1159 <func0+0x60>\n  addl   $0x1,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1125 <func0+0x2c>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    1189 <func0+0x90>\n  addl   $0x1,-0x8(%rbp)\n  cmpl   $0x1,-0x8(%rbp)\n  jg     1196 <func0+0x9d>\n  mov    $0x1,%eax\n  jmp    119b <func0+0xa2>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    L0\n  mov    $0x1,%eax\n  jmp    L1\nL0:\n  movl   $0x1,-0x4(%rbp)\n  jmp    L2\nL4:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L3\n  addl   $0x1,-0x8(%rbp)\nL3:\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  mov    -0x1c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L5\n  addl   $0x1,-0x8(%rbp)\nL5:\n  cmpl   $0x1,-0x8(%rbp)\n  jg     L6\n  mov    $0x1,%eax\n  jmp    L1\nL6:\n  mov    $0x0,%eax\nL1:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4380
            },
            "L1": {
                "label": "L1",
                "addr": 4507
            },
            "L2": {
                "label": "L2",
                "addr": 4445
            },
            "L3": {
                "label": "L3",
                "addr": 4441
            },
            "L4": {
                "label": "L4",
                "addr": 4389
            },
            "L5": {
                "label": "L5",
                "addr": 4489
            },
            "L6": {
                "label": "L6",
                "addr": 4502
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 109,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    $0x1,%eax\n  test   %esi,%esi\n  je     1148 <func0+0x4f>\n  cmp    $0x1,%esi\n  jle    1149 <func0+0x50>\n  mov    %rdi,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%r8\n  mov    $0x0,%edx\n  mov    (%rax),%ecx\n  cmp    %ecx,0x4(%rax)\n  setl   %cl\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  jne    111b <func0+0x22>\n  movslq %esi,%rsi\n  mov    (%rdi),%eax\n  cmp    %eax,-0x4(%rdi,%rsi,4)\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%edx\n  cmp    $0x1,%edx\n  setle  %al\n  ret\n  mov    $0x0,%edx\n  jmp    1131 <func0+0x38>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x1,%eax\n  test   %esi,%esi\n  je     L0\n  cmp    $0x1,%esi\n  jle    L1\n  mov    %rdi,%rax\n  lea    -0x2(%rsi),%edx\n  lea    0x4(%rdi,%rdx,4),%r8\n  mov    $0x0,%edx\nL2:\n  mov    (%rax),%ecx\n  cmp    %ecx,0x4(%rax)\n  setl   %cl\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  add    $0x4,%rax\n  cmp    %r8,%rax\n  jne    L2\nL3:\n  movslq %esi,%rsi\n  mov    (%rdi),%eax\n  cmp    %eax,-0x4(%rdi,%rsi,4)\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%edx\n  cmp    $0x1,%edx\n  setle  %al\nL0:\n  ret\nL1:\n  mov    $0x0,%edx\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4424
            },
            "L1": {
                "label": "L1",
                "addr": 4425
            },
            "L2": {
                "label": "L2",
                "addr": 4379
            },
            "L3": {
                "label": "L3",
                "addr": 4401
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 109,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    $0x1,%eax\n  test   %esi,%esi\n  je     114d <func0+0x4d>\n  cmp    $0x1,%esi\n  jle    1150 <func0+0x50>\n  lea    -0x2(%rsi),%edx\n  mov    %rdi,%rax\n  lea    0x4(%rdi,%rdx,4),%r8\n  xor    %edx,%edx\n  nop\n  mov    (%rax),%ecx\n  cmp    %ecx,0x4(%rax)\n  setl   %cl\n  add    $0x4,%rax\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  cmp    %r8,%rax\n  jne    1120 <func0+0x20>\n  movslq %esi,%rsi\n  mov    (%rdi),%eax\n  cmp    %eax,-0x4(%rdi,%rsi,4)\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%edx\n  cmp    $0x1,%edx\n  setle  %al\n  ret\n  xchg   %ax,%ax\n  xor    %edx,%edx\n  jmp    1136 <func0+0x36>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    $0x1,%eax\n  test   %esi,%esi\n  je     L0\n  cmp    $0x1,%esi\n  jle    L1\n  lea    -0x2(%rsi),%edx\n  mov    %rdi,%rax\n  lea    0x4(%rdi,%rdx,4),%r8\n  xor    %edx,%edx\n  nop\nL2:\n  mov    (%rax),%ecx\n  cmp    %ecx,0x4(%rax)\n  setl   %cl\n  add    $0x4,%rax\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  cmp    %r8,%rax\n  jne    L2\nL3:\n  movslq %esi,%rsi\n  mov    (%rdi),%eax\n  cmp    %eax,-0x4(%rdi,%rsi,4)\n  setg   %al\n  movzbl %al,%eax\n  add    %eax,%edx\n  cmp    $0x1,%edx\n  setle  %al\nL0:\n  ret\n  xchg   %ax,%ax\nL1:\n  xor    %edx,%edx\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4429
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            },
            "L2": {
                "label": "L2",
                "addr": 4384
            },
            "L3": {
                "label": "L3",
                "addr": 4406
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 109,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(int *arr, int size) {\n    int num = 0;\n    if (size == 0) return true;\n    for (int i = 1; i < size; i++)\n        if (arr[i] < arr[i - 1]) num += 1;\n    if (arr[size - 1] > arr[0]) num += 1;\n    if (num < 2) return true;\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0((const int[]){3, 4, 5, 1, 2}, 5) == true);\n    assert(func0((const int[]){3, 5, 10, 1, 2}, 5) == true);\n    assert(func0((const int[]){4, 3, 1, 2}, 4) == false);\n    assert(func0((const int[]){3, 5, 4, 1, 2}, 5) == false);\n    assert(func0((const int[]){}, 0) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movslq %esi,%rdx\n  mov    %rdi,%r8\n  mov    $0x1,%eax\n  test   %edx,%edx\n  je     1291 <func0+0x191>\n  cmp    $0x1,%edx\n  jle    12a0 <func0+0x1a0>\n  lea    -0x2(%rdx),%eax\n  lea    -0x1(%rdx),%esi\n  cmp    $0x2,%eax\n  jbe    12a4 <func0+0x1a4>\n  mov    %esi,%ecx\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  shr    $0x2,%ecx\n  sub    $0x1,%ecx\n  shl    $0x4,%rcx\n  lea    0x10(%rdi,%rcx,1),%rcx\n  nopw   0x0(%rax,%rax,1)\n  movdqu (%rax),%xmm0\n  movdqu 0x4(%rax),%xmm2\n  add    $0x10,%rax\n  pcmpgtd %xmm2,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rcx,%rax\n  jne    1150 <func0+0x50>\n  movdqa %xmm1,%xmm0\n  mov    %esi,%edi\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%edi\n  paddd  %xmm0,%xmm1\n  lea    0x1(%rdi),%ecx\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  cmp    %edi,%esi\n  je     127b <func0+0x17b>\n  movslq %ecx,%rdi\n  lea    0x1(%rcx),%r10d\n  shl    $0x2,%rdi\n  lea    (%r8,%rdi,1),%r9\n  cmp    %esi,%r10d\n  jge    12b0 <func0+0x1b0>\n  cmp    %ecx,%edx\n  jle    12b0 <func0+0x1b0>\n  mov    (%r9),%r10d\n  cmp    %r10d,-0x4(%r9)\n  setg   %r9b\n  mov    0x4(%r8,%rdi,1),%r11d\n  movzbl %r9b,%r9d\n  add    %r9d,%eax\n  xor    %r9d,%r9d\n  cmp    %r11d,%r10d\n  setg   %r9b\n  lea    0x3(%rcx),%r10d\n  add    %r9d,%eax\n  lea    0x2(%rcx),%r9d\n  cmp    %r10d,%esi\n  jle    123b <func0+0x13b>\n  mov    0x8(%r8,%rdi,1),%r9d\n  xor    %r10d,%r10d\n  cmp    %r9d,%r11d\n  lea    0x5(%rcx),%r11d\n  setg   %r10b\n  add    %r10d,%eax\n  mov    0xc(%r8,%rdi,1),%r10d\n  cmp    %r10d,%r9d\n  setg   %r9b\n  movzbl %r9b,%r9d\n  add    %r9d,%eax\n  lea    0x4(%rcx),%r9d\n  cmp    %r11d,%esi\n  jle    123b <func0+0x13b>\n  mov    0x10(%r8,%rdi,1),%esi\n  xor    %r9d,%r9d\n  cmp    %r10d,%esi\n  setl   %r9b\n  add    %r9d,%eax\n  cmp    0x14(%r8,%rdi,1),%esi\n  jle    1237 <func0+0x137>\n  add    $0x1,%eax\n  lea    0x6(%rcx),%r9d\n  movslq %r9d,%rcx\n  mov    (%r8,%rcx,4),%edi\n  lea    0x0(,%rcx,4),%rsi\n  cmp    -0x4(%r8,%rcx,4),%edi\n  jl     1298 <func0+0x198>\n  lea    0x1(%r9),%ecx\n  cmp    %ecx,%edx\n  jle    127b <func0+0x17b>\n  cmp    0x4(%r8,%rsi,1),%edi\n  jle    1263 <func0+0x163>\n  add    $0x1,%eax\n  add    $0x2,%r9d\n  cmp    %r9d,%edx\n  jle    127b <func0+0x17b>\n  mov    0x8(%r8,%rsi,1),%edi\n  cmp    %edi,0x4(%r8,%rsi,1)\n  jle    127b <func0+0x17b>\n  add    $0x1,%eax\n  mov    (%r8),%esi\n  cmp    %esi,-0x4(%r8,%rdx,4)\n  setg   %dl\n  movzbl %dl,%edx\n  add    %edx,%eax\n  cmp    $0x1,%eax\n  setle  %al\n  ret\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    1251 <func0+0x151>\n  nopl   (%rax)\n  xor    %eax,%eax\n  jmp    127b <func0+0x17b>\n  mov    $0x1,%ecx\n  xor    %eax,%eax\n  jmp    1198 <func0+0x98>\n  mov    %ecx,%r9d\n  jmp    123b <func0+0x13b>",
        "asm_labeled": "<func0>:\n  endbr64\n  movslq %esi,%rdx\n  mov    %rdi,%r8\n  mov    $0x1,%eax\n  test   %edx,%edx\n  je     L0\n  cmp    $0x1,%edx\n  jle    L1\n  lea    -0x2(%rdx),%eax\n  lea    -0x1(%rdx),%esi\n  cmp    $0x2,%eax\n  jbe    L2\n  mov    %esi,%ecx\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  shr    $0x2,%ecx\n  sub    $0x1,%ecx\n  shl    $0x4,%rcx\n  lea    0x10(%rdi,%rcx,1),%rcx\n  nopw   0x0(%rax,%rax,1)\nL3:\n  movdqu (%rax),%xmm0\n  movdqu 0x4(%rax),%xmm2\n  add    $0x10,%rax\n  pcmpgtd %xmm2,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rcx,%rax\n  jne    L3\n  movdqa %xmm1,%xmm0\n  mov    %esi,%edi\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%edi\n  paddd  %xmm0,%xmm1\n  lea    0x1(%rdi),%ecx\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  cmp    %edi,%esi\n  je     L4\nL11:\n  movslq %ecx,%rdi\n  lea    0x1(%rcx),%r10d\n  shl    $0x2,%rdi\n  lea    (%r8,%rdi,1),%r9\n  cmp    %esi,%r10d\n  jge    L5\n  cmp    %ecx,%edx\n  jle    L5\n  mov    (%r9),%r10d\n  cmp    %r10d,-0x4(%r9)\n  setg   %r9b\n  mov    0x4(%r8,%rdi,1),%r11d\n  movzbl %r9b,%r9d\n  add    %r9d,%eax\n  xor    %r9d,%r9d\n  cmp    %r11d,%r10d\n  setg   %r9b\n  lea    0x3(%rcx),%r10d\n  add    %r9d,%eax\n  lea    0x2(%rcx),%r9d\n  cmp    %r10d,%esi\n  jle    L6\n  mov    0x8(%r8,%rdi,1),%r9d\n  xor    %r10d,%r10d\n  cmp    %r9d,%r11d\n  lea    0x5(%rcx),%r11d\n  setg   %r10b\n  add    %r10d,%eax\n  mov    0xc(%r8,%rdi,1),%r10d\n  cmp    %r10d,%r9d\n  setg   %r9b\n  movzbl %r9b,%r9d\n  add    %r9d,%eax\n  lea    0x4(%rcx),%r9d\n  cmp    %r11d,%esi\n  jle    L6\n  mov    0x10(%r8,%rdi,1),%esi\n  xor    %r9d,%r9d\n  cmp    %r10d,%esi\n  setl   %r9b\n  add    %r9d,%eax\n  cmp    0x14(%r8,%rdi,1),%esi\n  jle    L7\n  add    $0x1,%eax\nL7:\n  lea    0x6(%rcx),%r9d\nL6:\n  movslq %r9d,%rcx\n  mov    (%r8,%rcx,4),%edi\n  lea    0x0(,%rcx,4),%rsi\n  cmp    -0x4(%r8,%rcx,4),%edi\n  jl     L8\nL10:\n  lea    0x1(%r9),%ecx\n  cmp    %ecx,%edx\n  jle    L4\n  cmp    0x4(%r8,%rsi,1),%edi\n  jle    L9\n  add    $0x1,%eax\nL9:\n  add    $0x2,%r9d\n  cmp    %r9d,%edx\n  jle    L4\n  mov    0x8(%r8,%rsi,1),%edi\n  cmp    %edi,0x4(%r8,%rsi,1)\n  jle    L4\n  add    $0x1,%eax\nL4:\n  mov    (%r8),%esi\n  cmp    %esi,-0x4(%r8,%rdx,4)\n  setg   %dl\n  movzbl %dl,%edx\n  add    %edx,%eax\n  cmp    $0x1,%eax\n  setle  %al\nL0:\n  ret\n  nopw   0x0(%rax,%rax,1)\nL8:\n  add    $0x1,%eax\n  jmp    L10\n  nopl   (%rax)\nL1:\n  xor    %eax,%eax\n  jmp    L4\nL2:\n  mov    $0x1,%ecx\n  xor    %eax,%eax\n  jmp    L11\nL5:\n  mov    %ecx,%r9d\n  jmp    L6",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4753
            },
            "L1": {
                "label": "L1",
                "addr": 4768
            },
            "L2": {
                "label": "L2",
                "addr": 4772
            },
            "L3": {
                "label": "L3",
                "addr": 4432
            },
            "L4": {
                "label": "L4",
                "addr": 4731
            },
            "L5": {
                "label": "L5",
                "addr": 4784
            },
            "L6": {
                "label": "L6",
                "addr": 4667
            },
            "L7": {
                "label": "L7",
                "addr": 4663
            },
            "L8": {
                "label": "L8",
                "addr": 4760
            },
            "L9": {
                "label": "L9",
                "addr": 4707
            },
            "L10": {
                "label": "L10",
                "addr": 4689
            },
            "L11": {
                "label": "L11",
                "addr": 4504
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 110,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1144 <func0+0x4b>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    1140 <func0+0x47>\n  addl   $0x1,-0xc(%rbp)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111f <func0+0x26>\n  movl   $0x0,-0x4(%rbp)\n  jmp    117a <func0+0x81>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    1176 <func0+0x7d>\n  addl   $0x1,-0xc(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     1155 <func0+0x5c>\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1193 <func0+0x9a>\n  lea    0xe6f(%rip),%rax        # 2000 <_fini+0xe64>\n  jmp    119a <func0+0xa1>\n  lea    0xe6a(%rip),%rax        # 2004 <_fini+0xe68>\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL2:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L1\n  addl   $0x1,-0xc(%rbp)\nL1:\n  addl   $0x1,-0x8(%rbp)\nL0:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  movl   $0x0,-0x4(%rbp)\n  jmp    L3\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L4\n  addl   $0x1,-0xc(%rbp)\nL4:\n  addl   $0x1,-0x4(%rbp)\nL3:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     L5\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L6\n  lea    D0(%rip),%rax\n  jmp    L7\nL6:\n  lea    D1(%rip),%rax\nL7:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3695
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3690
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4420
            },
            "L1": {
                "label": "L1",
                "addr": 4416
            },
            "L2": {
                "label": "L2",
                "addr": 4383
            },
            "L3": {
                "label": "L3",
                "addr": 4474
            },
            "L4": {
                "label": "L4",
                "addr": 4470
            },
            "L5": {
                "label": "L5",
                "addr": 4437
            },
            "L6": {
                "label": "L6",
                "addr": 4499
            },
            "L7": {
                "label": "L7",
                "addr": 4506
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "594553004e4f00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"YES\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"NO\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 110,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    115b <func0+0x62>\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%eax\n  mov    (%r8),%edi\n  and    $0x1,%edi\n  cmp    $0x1,%edi\n  adc    $0x0,%eax\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  jne    1111 <func0+0x18>\n  test   %ecx,%ecx\n  jle    1146 <func0+0x4d>\n  mov    $0x0,%edi\n  mov    (%rdx,%rdi,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x1,%rdi\n  cmp    %edi,%ecx\n  jg     112f <func0+0x36>\n  cmp    %eax,%esi\n  lea    0xeb5(%rip),%rax        # 2004 <_fini+0xe98>\n  lea    0xeaa(%rip),%rdx        # 2000 <_fini+0xe94>\n  cmovle %rdx,%rax\n  ret\n  mov    $0x0,%eax\n  test   %ecx,%ecx\n  jg     112a <func0+0x31>\n  lea    0xe95(%rip),%rax        # 2000 <_fini+0xe94>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%eax\nL1:\n  mov    (%r8),%edi\n  and    $0x1,%edi\n  cmp    $0x1,%edi\n  adc    $0x0,%eax\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  jne    L1\n  test   %ecx,%ecx\n  jle    L2\nL4:\n  mov    $0x0,%edi\nL3:\n  mov    (%rdx,%rdi,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x1,%rdi\n  cmp    %edi,%ecx\n  jg     L3\nL2:\n  cmp    %eax,%esi\n  lea    D0(%rip),%rax\n  lea    D1(%rip),%rdx\n  cmovle %rdx,%rax\n  ret\nL0:\n  mov    $0x0,%eax\n  test   %ecx,%ecx\n  jg     L4\n  lea    D1(%rip),%rax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8196,
                "bias": [
                    3765
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3754,
                    3733
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4443
            },
            "L1": {
                "label": "L1",
                "addr": 4369
            },
            "L2": {
                "label": "L2",
                "addr": 4422
            },
            "L3": {
                "label": "L3",
                "addr": 4399
            },
            "L4": {
                "label": "L4",
                "addr": 4394
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "594553004e4f00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"YES\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"NO\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 110,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1168 <func0+0x68>\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rdi),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    1118 <func0+0x18>\n  test   %ecx,%ecx\n  jle    114f <func0+0x4f>\n  xor    %edi,%edi\n  nopl   (%rax)\n  mov    (%rdx,%rdi,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x1,%rdi\n  cmp    %edi,%ecx\n  jg     1138 <func0+0x38>\n  cmp    %eax,%esi\n  lea    0xeac(%rip),%rdx        # 2004 <_fini+0xe8c>\n  lea    0xea1(%rip),%rax        # 2000 <_fini+0xe88>\n  cmovg  %rdx,%rax\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  test   %ecx,%ecx\n  jg     1133 <func0+0x33>\n  lea    0xe8b(%rip),%rax        # 2000 <_fini+0xe88>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  xor    %eax,%eax\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    (%rdi),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x4,%rdi\n  cmp    %r9,%rdi\n  jne    L1\n  test   %ecx,%ecx\n  jle    L2\nL4:\n  xor    %edi,%edi\n  nopl   (%rax)\nL3:\n  mov    (%rdx,%rdi,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%eax\n  add    $0x1,%rdi\n  cmp    %edi,%ecx\n  jg     L3\nL2:\n  cmp    %eax,%esi\n  lea    D0(%rip),%rdx\n  lea    D1(%rip),%rax\n  cmovg  %rdx,%rax\n  ret\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\n  test   %ecx,%ecx\n  jg     L4\n  lea    D1(%rip),%rax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8196,
                "bias": [
                    3756
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3745,
                    3723
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4456
            },
            "L1": {
                "label": "L1",
                "addr": 4376
            },
            "L2": {
                "label": "L2",
                "addr": 4431
            },
            "L3": {
                "label": "L3",
                "addr": 4408
            },
            "L4": {
                "label": "L4",
                "addr": 4403
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "594553004e4f00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"YES\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"NO\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 110,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int *lst1, int size1, int *lst2, int size2) {\n    int num = 0;\n    for (int i = 0; i < size1; i++)\n        if (lst1[i] % 2 == 0) num += 1;\n    for (int i = 0; i < size2; i++)\n        if (lst2[i] % 2 == 0) num += 1;\n    if (num >= size1) return \"YES\";\n    return \"NO\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 2, 3, 4}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){1, 5, 3, 4}, 4), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){1, 2, 3, 4}, 4, (const int[]){2, 1, 4, 3}, 4), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 4}, 3), \"YES\") == 0);\n    assert(strcmp(func0((const int[]){5, 7, 3}, 3, (const int[]){2, 6, 3}, 3), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){3, 2, 6, 1, 8, 9}, 6, (const int[]){3, 5, 5, 1, 1, 1}, 6), \"NO\") == 0);\n    assert(strcmp(func0((const int[]){100, 200}, 2, (const int[]){200, 200}, 2), \"YES\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  mov    %rdx,%rdi\n  test   %esi,%esi\n  jle    12c8 <func0+0x1c8>\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    12da <func0+0x1da>\n  mov    %esi,%edx\n  pxor   %xmm1,%xmm1\n  movdqa 0xee4(%rip),%xmm2        # 2010 <_fini+0xd24>\n  mov    %r8,%rax\n  shr    $0x2,%edx\n  movdqa %xmm1,%xmm3\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%r8,%rdx,1),%rdx\n  nopw   0x0(%rax,%rax,1)\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%rdx\n  jne    1148 <func0+0x48>\n  movdqa %xmm1,%xmm0\n  mov    %esi,%eax\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%eax\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%edx\n  test   $0x3,%sil\n  je     11d2 <func0+0xd2>\n  movslq %eax,%r9\n  lea    0x0(,%r9,4),%r10\n  mov    (%r8,%r9,4),%r9d\n  and    $0x1,%r9d\n  cmp    $0x1,%r9d\n  lea    0x1(%rax),%r9d\n  adc    $0x0,%edx\n  cmp    %r9d,%esi\n  jle    11d2 <func0+0xd2>\n  mov    0x4(%r8,%r10,1),%r9d\n  and    $0x1,%r9d\n  cmp    $0x1,%r9d\n  adc    $0x0,%edx\n  add    $0x2,%eax\n  cmp    %esi,%eax\n  jge    11d2 <func0+0xd2>\n  mov    0x8(%r8,%r10,1),%eax\n  and    $0x1,%eax\n  cmp    $0x1,%eax\n  adc    $0x0,%edx\n  test   %ecx,%ecx\n  jle    12ad <func0+0x1ad>\n  test   %ecx,%ecx\n  mov    $0x1,%r9d\n  cmovg  %ecx,%r9d\n  cmp    $0x3,%ecx\n  jle    12e3 <func0+0x1e3>\n  mov    %r9d,%r8d\n  pxor   %xmm1,%xmm1\n  movdqa 0xe12(%rip),%xmm2        # 2010 <_fini+0xd24>\n  mov    %rdi,%rax\n  shr    $0x2,%r8d\n  movdqa %xmm1,%xmm3\n  sub    $0x1,%r8d\n  shl    $0x4,%r8\n  lea    0x10(%rdi,%r8,1),%r8\n  cs nopw 0x0(%rax,%rax,1)\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%r8\n  jne    1220 <func0+0x120>\n  movdqa %xmm1,%xmm0\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  add    %eax,%edx\n  mov    %r9d,%eax\n  and    $0xfffffffc,%eax\n  and    $0x3,%r9d\n  je     12ad <func0+0x1ad>\n  movslq %eax,%r8\n  lea    0x0(,%r8,4),%r9\n  mov    (%rdi,%r8,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  lea    0x1(%rax),%r8d\n  adc    $0x0,%edx\n  cmp    %r8d,%ecx\n  jle    12ad <func0+0x1ad>\n  mov    0x4(%rdi,%r9,1),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%edx\n  add    $0x2,%eax\n  cmp    %eax,%ecx\n  jle    12ad <func0+0x1ad>\n  mov    0x8(%rdi,%r9,1),%eax\n  and    $0x1,%eax\n  cmp    $0x1,%eax\n  adc    $0x0,%edx\n  cmp    %edx,%esi\n  lea    0xd4a(%rip),%rax        # 2000 <_fini+0xd14>\n  lea    0xd47(%rip),%rdx        # 2004 <_fini+0xd18>\n  cmovg  %rdx,%rax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %edx,%edx\n  test   %ecx,%ecx\n  jg     11da <func0+0xda>\n  lea    0xd27(%rip),%rax        # 2000 <_fini+0xd14>\n  ret\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    118a <func0+0x8a>\n  xor    %eax,%eax\n  jmp    1265 <func0+0x165>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  mov    %rdx,%rdi\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    L1\n  mov    %esi,%edx\n  pxor   %xmm1,%xmm1\n  movdqa D0(%rip),%xmm2\n  mov    %r8,%rax\n  shr    $0x2,%edx\n  movdqa %xmm1,%xmm3\n  sub    $0x1,%edx\n  shl    $0x4,%rdx\n  lea    0x10(%r8,%rdx,1),%rdx\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%rdx\n  jne    L2\n  movdqa %xmm1,%xmm0\n  mov    %esi,%eax\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%eax\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%edx\n  test   $0x3,%sil\n  je     L3\nL8:\n  movslq %eax,%r9\n  lea    0x0(,%r9,4),%r10\n  mov    (%r8,%r9,4),%r9d\n  and    $0x1,%r9d\n  cmp    $0x1,%r9d\n  lea    0x1(%rax),%r9d\n  adc    $0x0,%edx\n  cmp    %r9d,%esi\n  jle    L3\n  mov    0x4(%r8,%r10,1),%r9d\n  and    $0x1,%r9d\n  cmp    $0x1,%r9d\n  adc    $0x0,%edx\n  add    $0x2,%eax\n  cmp    %esi,%eax\n  jge    L3\n  mov    0x8(%r8,%r10,1),%eax\n  and    $0x1,%eax\n  cmp    $0x1,%eax\n  adc    $0x0,%edx\nL3:\n  test   %ecx,%ecx\n  jle    L4\nL7:\n  test   %ecx,%ecx\n  mov    $0x1,%r9d\n  cmovg  %ecx,%r9d\n  cmp    $0x3,%ecx\n  jle    L5\n  mov    %r9d,%r8d\n  pxor   %xmm1,%xmm1\n  movdqa D0(%rip),%xmm2\n  mov    %rdi,%rax\n  shr    $0x2,%r8d\n  movdqa %xmm1,%xmm3\n  sub    $0x1,%r8d\n  shl    $0x4,%r8\n  lea    0x10(%rdi,%r8,1),%r8\n  cs nopw 0x0(%rax,%rax,1)\nL6:\n  movdqu (%rax),%xmm0\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm3,%xmm0\n  psubd  %xmm0,%xmm1\n  cmp    %rax,%r8\n  jne    L6\n  movdqa %xmm1,%xmm0\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  add    %eax,%edx\n  mov    %r9d,%eax\n  and    $0xfffffffc,%eax\n  and    $0x3,%r9d\n  je     L4\nL9:\n  movslq %eax,%r8\n  lea    0x0(,%r8,4),%r9\n  mov    (%rdi,%r8,4),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  lea    0x1(%rax),%r8d\n  adc    $0x0,%edx\n  cmp    %r8d,%ecx\n  jle    L4\n  mov    0x4(%rdi,%r9,1),%r8d\n  and    $0x1,%r8d\n  cmp    $0x1,%r8d\n  adc    $0x0,%edx\n  add    $0x2,%eax\n  cmp    %eax,%ecx\n  jle    L4\n  mov    0x8(%rdi,%r9,1),%eax\n  and    $0x1,%eax\n  cmp    $0x1,%eax\n  adc    $0x0,%edx\nL4:\n  cmp    %edx,%esi\n  lea    D1(%rip),%rax\n  lea    D2(%rip),%rdx\n  cmovg  %rdx,%rax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %edx,%edx\n  test   %ecx,%ecx\n  jg     L7\n  lea    D1(%rip),%rax\n  ret\nL1:\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    L8\nL5:\n  xor    %eax,%eax\n  jmp    L9",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8208,
                "bias": [
                    3812,
                    3602
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3402,
                    3367
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8196,
                "bias": [
                    3399
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4808
            },
            "L1": {
                "label": "L1",
                "addr": 4826
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            },
            "L3": {
                "label": "L3",
                "addr": 4562
            },
            "L4": {
                "label": "L4",
                "addr": 4781
            },
            "L5": {
                "label": "L5",
                "addr": 4835
            },
            "L6": {
                "label": "L6",
                "addr": 4640
            },
            "L7": {
                "label": "L7",
                "addr": 4570
            },
            "L8": {
                "label": "L8",
                "addr": 4490
            },
            "L9": {
                "label": "L9",
                "addr": 4709
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "594553004e4f0000000000000000000001000000010000000100000001000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"YES\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"NO\""
                },
                "0x2010": {
                    "type": "byte[16]",
                    "value": [
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 111,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xb0,%rsp\n  mov    %rdi,-0x98(%rbp)\n  mov    %rsi,-0xa0(%rbp)\n  mov    %rdx,-0xa8(%rbp)\n  mov    %rcx,-0xb0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0x70(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0xd,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x88(%rbp)\n  mov    -0x98(%rbp),%rax\n  mov    %rax,-0x78(%rbp)\n  movl   $0x0,-0x84(%rbp)\n  jmp    11dd <func0+0xc4>\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     11d8 <func0+0xbf>\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  mov    %eax,-0x7c(%rbp)\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    %edx,-0x70(%rbp,%rax,4)\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  cmp    %eax,-0x88(%rbp)\n  jge    11d8 <func0+0xbf>\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  mov    %eax,-0x88(%rbp)\n  addq   $0x1,-0x78(%rbp)\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1188 <func0+0x6f>\n  movl   $0x0,-0x80(%rbp)\n  jmp    124e <func0+0x135>\n  mov    -0x80(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0xa0(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x80(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  mov    %eax,(%rdx)\n  mov    -0x80(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  cmp    %eax,-0x88(%rbp)\n  jne    124a <func0+0x131>\n  mov    -0x80(%rbp),%eax\n  lea    0x61(%rax),%ecx\n  mov    -0x84(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x84(%rbp)\n  movslq %eax,%rdx\n  mov    -0xb0(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\n  addl   $0x1,-0x80(%rbp)\n  cmpl   $0x19,-0x80(%rbp)\n  jle    11f1 <func0+0xd8>\n  mov    -0xa8(%rbp),%rax\n  mov    -0x88(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x84(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xb0(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     128e <func0+0x175>\n  call   1050 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xb0,%rsp\n  mov    %rdi,-0x98(%rbp)\n  mov    %rsi,-0xa0(%rbp)\n  mov    %rdx,-0xa8(%rbp)\n  mov    %rcx,-0xb0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    -0x70(%rbp),%rdx\n  mov    $0x0,%eax\n  mov    $0xd,%ecx\n  mov    %rdx,%rdi\n  rep stos %rax,%es:(%rdi)\n  movl   $0x0,-0x88(%rbp)\n  mov    -0x98(%rbp),%rax\n  mov    %rax,-0x78(%rbp)\n  movl   $0x0,-0x84(%rbp)\n  jmp    L0\nL2:\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L1\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  mov    %eax,-0x7c(%rbp)\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    %edx,-0x70(%rbp,%rax,4)\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  cmp    %eax,-0x88(%rbp)\n  jge    L1\n  mov    -0x7c(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  mov    %eax,-0x88(%rbp)\nL1:\n  addq   $0x1,-0x78(%rbp)\nL0:\n  mov    -0x78(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\n  movl   $0x0,-0x80(%rbp)\n  jmp    L3\nL5:\n  mov    -0x80(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0xa0(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x80(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  mov    %eax,(%rdx)\n  mov    -0x80(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,4),%eax\n  cmp    %eax,-0x88(%rbp)\n  jne    L4\n  mov    -0x80(%rbp),%eax\n  lea    0x61(%rax),%ecx\n  mov    -0x84(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x84(%rbp)\n  movslq %eax,%rdx\n  mov    -0xb0(%rbp),%rax\n  add    %rdx,%rax\n  mov    %ecx,%edx\n  mov    %dl,(%rax)\nL4:\n  addl   $0x1,-0x80(%rbp)\nL3:\n  cmpl   $0x19,-0x80(%rbp)\n  jle    L5\n  mov    -0xa8(%rbp),%rax\n  mov    -0x88(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x84(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xb0(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     L6\n  call   <__stack_chk_fail@plt>\nL6:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4573
            },
            "L1": {
                "label": "L1",
                "addr": 4568
            },
            "L2": {
                "label": "L2",
                "addr": 4488
            },
            "L3": {
                "label": "L3",
                "addr": 4686
            },
            "L4": {
                "label": "L4",
                "addr": 4682
            },
            "L5": {
                "label": "L5",
                "addr": 4593
            },
            "L6": {
                "label": "L6",
                "addr": 4750
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 111,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r11\n  mov    %rsi,%r8\n  mov    %rdx,%r10\n  mov    %rcx,%r9\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0xd,%ecx\n  rep stos %rax,%es:(%rdi)\n  movzbl (%r11),%eax\n  test   %al,%al\n  jne    1183 <func0+0x6a>\n  mov    $0x0,%ecx\n  mov    $0x0,%eax\n  mov    $0x0,%esi\n  jmp    1193 <func0+0x7a>\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  mov    %edx,(%rsp,%rax,4)\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%r11\n  movzbl (%r11),%eax\n  test   %al,%al\n  je     1155 <func0+0x3c>\n  cmp    $0x20,%al\n  jne    1161 <func0+0x48>\n  jmp    1177 <func0+0x5e>\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  je     11ad <func0+0x94>\n  mov    (%rsp,%rax,4),%edx\n  mov    %edx,(%r8,%rax,4)\n  cmp    %ecx,%edx\n  jne    1189 <func0+0x70>\n  movslq %esi,%rdx\n  lea    0x61(%rax),%edi\n  mov    %dil,(%r9,%rdx,1)\n  lea    0x1(%rsi),%esi\n  jmp    1189 <func0+0x70>\n  mov    %ecx,(%r10)\n  movslq %esi,%rsi\n  movb   $0x0,(%r9,%rsi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11cd <func0+0xb4>\n  add    $0x78,%rsp\n  ret\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r11\n  mov    %rsi,%r8\n  mov    %rdx,%r10\n  mov    %rcx,%r9\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%rdi\n  mov    $0xd,%ecx\n  rep stos %rax,%es:(%rdi)\n  movzbl (%r11),%eax\n  test   %al,%al\n  jne    L0\n  mov    $0x0,%ecx\nL2:\n  mov    $0x0,%eax\n  mov    $0x0,%esi\n  jmp    L1\nL3:\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  mov    %edx,(%rsp,%rax,4)\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\nL4:\n  add    $0x1,%r11\n  movzbl (%r11),%eax\n  test   %al,%al\n  je     L2\nL0:\n  cmp    $0x20,%al\n  jne    L3\n  jmp    L4\nL6:\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  je     L5\nL1:\n  mov    (%rsp,%rax,4),%edx\n  mov    %edx,(%r8,%rax,4)\n  cmp    %ecx,%edx\n  jne    L6\n  movslq %esi,%rdx\n  lea    0x61(%rax),%edi\n  mov    %dil,(%r9,%rdx,1)\n  lea    0x1(%rsi),%esi\n  jmp    L6\nL5:\n  mov    %ecx,(%r10)\n  movslq %esi,%rsi\n  movb   $0x0,(%r9,%rsi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  add    $0x78,%rsp\n  ret\nL7:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4483
            },
            "L1": {
                "label": "L1",
                "addr": 4499
            },
            "L2": {
                "label": "L2",
                "addr": 4437
            },
            "L3": {
                "label": "L3",
                "addr": 4449
            },
            "L4": {
                "label": "L4",
                "addr": 4471
            },
            "L5": {
                "label": "L5",
                "addr": 4525
            },
            "L6": {
                "label": "L6",
                "addr": 4489
            },
            "L7": {
                "label": "L7",
                "addr": 4557
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 111,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r8\n  mov    %rcx,%r10\n  mov    $0xd,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r9\n  mov    %rdx,%r11\n  mov    %r9,%rdi\n  rep stos %rax,%es:(%rdi)\n  movsbl (%r8),%eax\n  test   %al,%al\n  je     11d3 <func0+0xb3>\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x20,%al\n  je     1177 <func0+0x57>\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  cmp    %edx,%ecx\n  mov    %edx,(%rsp,%rax,4)\n  cmovl  %edx,%ecx\n  movsbl 0x1(%r8),%eax\n  add    $0x1,%r8\n  test   %al,%al\n  jne    1160 <func0+0x40>\n  mov    (%rsp),%edx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    1194 <func0+0x74>\n  nopl   (%rax)\n  mov    (%r9,%rax,4),%edx\n  mov    %edx,(%rsi,%rax,4)\n  cmp    %edx,%ecx\n  jne    11a9 <func0+0x89>\n  movslq %edi,%rdx\n  lea    0x61(%rax),%r8d\n  add    $0x1,%edi\n  mov    %r8b,(%r10,%rdx,1)\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  jne    1190 <func0+0x70>\n  movslq %edi,%rdi\n  mov    %ecx,(%r11)\n  movb   $0x0,(%r10,%rdi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11d9 <func0+0xb9>\n  add    $0x78,%rsp\n  ret\n  xor    %edx,%edx\n  xor    %ecx,%ecx\n  jmp    1187 <func0+0x67>\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r8\n  mov    %rcx,%r10\n  mov    $0xd,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r9\n  mov    %rdx,%r11\n  mov    %r9,%rdi\n  rep stos %rax,%es:(%rdi)\n  movsbl (%r8),%eax\n  test   %al,%al\n  je     L0\n  nopw   0x0(%rax,%rax,1)\nL2:\n  cmp    $0x20,%al\n  je     L1\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  cmp    %edx,%ecx\n  mov    %edx,(%rsp,%rax,4)\n  cmovl  %edx,%ecx\nL1:\n  movsbl 0x1(%r8),%eax\n  add    $0x1,%r8\n  test   %al,%al\n  jne    L2\n  mov    (%rsp),%edx\nL7:\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    L3\n  nopl   (%rax)\nL5:\n  mov    (%r9,%rax,4),%edx\nL3:\n  mov    %edx,(%rsi,%rax,4)\n  cmp    %edx,%ecx\n  jne    L4\n  movslq %edi,%rdx\n  lea    0x61(%rax),%r8d\n  add    $0x1,%edi\n  mov    %r8b,(%r10,%rdx,1)\nL4:\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  jne    L5\n  movslq %edi,%rdi\n  mov    %ecx,(%r11)\n  movb   $0x0,(%r10,%rdi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x78,%rsp\n  ret\nL0:\n  xor    %edx,%edx\n  xor    %ecx,%ecx\n  jmp    L7\nL6:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4563
            },
            "L1": {
                "label": "L1",
                "addr": 4471
            },
            "L2": {
                "label": "L2",
                "addr": 4448
            },
            "L3": {
                "label": "L3",
                "addr": 4500
            },
            "L4": {
                "label": "L4",
                "addr": 4521
            },
            "L5": {
                "label": "L5",
                "addr": 4496
            },
            "L6": {
                "label": "L6",
                "addr": 4569
            },
            "L7": {
                "label": "L7",
                "addr": 4487
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 111,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* test, int* freq, int* max_count, char* letters) {\n    int local_freq[26] = {0}; // for 'a' to 'z'\n    int local_max = 0;\n    const char* ptr = test;\n    int idx = 0;\n\n    while (*ptr) {\n        if (*ptr != ' ') {\n            int letter_index = *ptr - 'a';\n            local_freq[letter_index]++;\n            if (local_freq[letter_index] > local_max) {\n                local_max = local_freq[letter_index];\n            }\n        }\n        ptr++;\n    }\n\n    for (int i = 0; i < 26; i++) {\n        freq[i] = local_freq[i];\n        if (local_freq[i] == local_max) {\n            letters[idx++] = 'a' + i;\n        }\n    }\n\n    *max_count = local_max;\n    letters[idx] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdio.h>\n\nbool issame(int* freq1, const char* letters1, int max_count1, int* freq2, const char* letters2, int max_count2) {\n    if (max_count1 != max_count2) return false;\n    for (int i = 0; letters1[i] != '\\0'; i++) {\n        if (freq1[letters1[i] - 'a'] != freq2[letters1[i] - 'a']) return false;\n    }\n    for (int i = 0; letters2[i] != '\\0'; i++) {\n        if (freq2[letters2[i] - 'a'] != freq1[letters2[i] - 'a']) return false;\n    }\n    return true;\n}\n\nint main() {\n    int counts1[26], counts2[26];\n    int max_count1, max_count2;\n    char letters1[27], letters2[27];\n\n    func0(\"a b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c a b\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 2;\n    counts2['b' - 'a'] = 2;\n    assert(issame(counts1, letters1, max_count1, counts2, \"ab\", 2));\n\n    func0(\"a b c d g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = counts2['b' - 'a'] = counts2['c' - 'a'] = counts2['d' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"abcdg\", 1));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"b b b b a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['b' - 'a'] = 4;\n    assert(issame(counts1, letters1, max_count1, counts2, \"b\", 4));\n\n    func0(\"r t g\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['r' - 'a'] = counts2['t' - 'a'] = counts2['g' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"rtg\", 1));\n\n    func0(\"a\", counts1, &max_count1, letters1);\n    memset(counts2, 0, sizeof(counts2));\n    counts2['a' - 'a'] = 1;\n    assert(issame(counts1, letters1, max_count1, counts2, \"a\", 1));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r9\n  mov    %rcx,%r10\n  mov    $0xd,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r8\n  mov    %rdx,%r11\n  mov    %r8,%rdi\n  rep stos %rax,%es:(%rdi)\n  movsbl (%r9),%eax\n  test   %al,%al\n  je     11eb <func0+0xcb>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x20,%al\n  je     11d8 <func0+0xb8>\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  cmp    %edx,%ecx\n  mov    %edx,(%rsp,%rax,4)\n  cmovl  %edx,%ecx\n  movsbl 0x1(%r9),%eax\n  add    $0x1,%r9\n  test   %al,%al\n  jne    1160 <func0+0x40>\n  xor    %eax,%eax\n  xor    %edi,%edi\n  nopl   0x0(%rax,%rax,1)\n  mov    (%r8,%rax,4),%edx\n  mov    %edx,(%rsi,%rax,4)\n  cmp    %ecx,%edx\n  jne    11a9 <func0+0x89>\n  movslq %edi,%rdx\n  lea    0x61(%rax),%r9d\n  add    $0x1,%edi\n  mov    %r9b,(%r10,%rdx,1)\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  jne    1190 <func0+0x70>\n  movslq %edi,%rdi\n  mov    %ecx,(%r11)\n  movb   $0x0,(%r10,%rdi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    11ef <func0+0xcf>\n  add    $0x78,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\n  movsbl 0x1(%r9),%eax\n  add    $0x1,%r9\n  test   %al,%al\n  jne    1160 <func0+0x40>\n  jmp    1184 <func0+0x64>\n  xor    %ecx,%ecx\n  jmp    1184 <func0+0x64>\n  call   1050 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  sub    $0x78,%rsp\n  mov    %rdi,%r9\n  mov    %rcx,%r10\n  mov    $0xd,%ecx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  mov    %rsp,%r8\n  mov    %rdx,%r11\n  mov    %r8,%rdi\n  rep stos %rax,%es:(%rdi)\n  movsbl (%r9),%eax\n  test   %al,%al\n  je     L0\n  nopl   0x0(%rax,%rax,1)\nL2:\n  cmp    $0x20,%al\n  je     L1\n  sub    $0x61,%eax\n  cltq\n  mov    (%rsp,%rax,4),%edi\n  lea    0x1(%rdi),%edx\n  cmp    %edx,%ecx\n  mov    %edx,(%rsp,%rax,4)\n  cmovl  %edx,%ecx\n  movsbl 0x1(%r9),%eax\n  add    $0x1,%r9\n  test   %al,%al\n  jne    L2\nL6:\n  xor    %eax,%eax\n  xor    %edi,%edi\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    (%r8,%rax,4),%edx\n  mov    %edx,(%rsi,%rax,4)\n  cmp    %ecx,%edx\n  jne    L3\n  movslq %edi,%rdx\n  lea    0x61(%rax),%r9d\n  add    $0x1,%edi\n  mov    %r9b,(%r10,%rdx,1)\nL3:\n  add    $0x1,%rax\n  cmp    $0x1a,%rax\n  jne    L4\n  movslq %edi,%rdi\n  mov    %ecx,(%r11)\n  movb   $0x0,(%r10,%rdi,1)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  add    $0x78,%rsp\n  ret\n  nopl   0x0(%rax,%rax,1)\nL1:\n  movsbl 0x1(%r9),%eax\n  add    $0x1,%r9\n  test   %al,%al\n  jne    L2\n  jmp    L6\nL0:\n  xor    %ecx,%ecx\n  jmp    L6\nL5:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4587
            },
            "L1": {
                "label": "L1",
                "addr": 4568
            },
            "L2": {
                "label": "L2",
                "addr": 4448
            },
            "L3": {
                "label": "L3",
                "addr": 4521
            },
            "L4": {
                "label": "L4",
                "addr": 4496
            },
            "L5": {
                "label": "L5",
                "addr": 4591
            },
            "L6": {
                "label": "L6",
                "addr": 4484
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 112,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    %rcx,-0x50(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  jmp    123c <func0+0xc3>\n  mov    -0x40(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  movb   $0x0,-0x26(%rbp)\n  jmp    11fc <func0+0x83>\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    11f7 <func0+0x7e>\n  movb   $0x1,-0x26(%rbp)\n  jmp    1207 <func0+0x8e>\n  addq   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11d6 <func0+0x5d>\n  movzbl -0x26(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     1238 <func0+0xbf>\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x24(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x24(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x20(%rbp)\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11c8 <func0+0x4f>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,-0x14(%rbp)\n  movb   $0x1,-0x25(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    12b4 <func0+0x13b>\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x1c(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     12b0 <func0+0x137>\n  movb   $0x0,-0x25(%rbp)\n  jmp    12c5 <func0+0x14c>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     1280 <func0+0x107>\n  mov    -0x8(%rbp),%rdx\n  mov    -0x48(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcpy@plt>\n  cmpb   $0x0,-0x25(%rbp)\n  je     12e7 <func0+0x16e>\n  lea    0xd1b(%rip),%rax        # 2000 <_fini+0xcf4>\n  jmp    12ee <func0+0x175>\n  lea    0xd17(%rip),%rax        # 2005 <_fini+0xcf9>\n  mov    -0x50(%rbp),%rdx\n  mov    %rax,%rsi\n  mov    %rdx,%rdi\n  call   1090 <strcpy@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  nop\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    %rcx,-0x50(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  jmp    L0\nL6:\n  mov    -0x40(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  movb   $0x0,-0x26(%rbp)\n  jmp    L1\nL4:\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  jne    L2\n  movb   $0x1,-0x26(%rbp)\n  jmp    L3\nL2:\n  addq   $0x1,-0x10(%rbp)\nL1:\n  mov    -0x10(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L4\nL3:\n  movzbl -0x26(%rbp),%eax\n  xor    $0x1,%eax\n  test   %al,%al\n  je     L5\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x24(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x24(%rbp)\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\nL5:\n  addl   $0x1,-0x20(%rbp)\nL0:\n  mov    -0x20(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L6\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x14(%rbp)\n  movb   $0x1,-0x25(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L7\nL10:\n  mov    -0x1c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x14(%rbp),%eax\n  sub    $0x1,%eax\n  sub    -0x1c(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  cmp    %al,%dl\n  je     L8\n  movb   $0x0,-0x25(%rbp)\n  jmp    L9\nL8:\n  addl   $0x1,-0x1c(%rbp)\nL7:\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x1c(%rbp)\n  jl     L10\nL9:\n  mov    -0x8(%rbp),%rdx\n  mov    -0x48(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  cmpb   $0x0,-0x25(%rbp)\n  je     L11\n  lea    D0(%rip),%rax\n  jmp    L12\nL11:\n  lea    D1(%rip),%rax\nL12:\n  mov    -0x50(%rbp),%rdx\n  mov    %rax,%rsi\n  mov    %rdx,%rdi\n  call   <strcpy@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  nop\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3355
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8197,
                "bias": [
                    3351
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4668
            },
            "L1": {
                "label": "L1",
                "addr": 4604
            },
            "L2": {
                "label": "L2",
                "addr": 4599
            },
            "L3": {
                "label": "L3",
                "addr": 4615
            },
            "L4": {
                "label": "L4",
                "addr": 4566
            },
            "L5": {
                "label": "L5",
                "addr": 4664
            },
            "L6": {
                "label": "L6",
                "addr": 4552
            },
            "L7": {
                "label": "L7",
                "addr": 4788
            },
            "L8": {
                "label": "L8",
                "addr": 4784
            },
            "L9": {
                "label": "L9",
                "addr": 4805
            },
            "L10": {
                "label": "L10",
                "addr": 4736
            },
            "L11": {
                "label": "L11",
                "addr": 4839
            },
            "L12": {
                "label": "L12",
                "addr": 4846
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "547275650046616c736500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"True\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"False\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 112,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %rsi,%rbp\n  mov    %rdx,%r13\n  mov    %rcx,%r12\n  call   10a0 <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%rbx\n  movzbl (%r14),%ecx\n  test   %cl,%cl\n  je     11bf <func0+0x46>\n  movzbl 0x0(%rbp),%edi\n  lea    0x1(%r14),%rsi\n  mov    $0x0,%r8d\n  jmp    125d <func0+0xe4>\n  mov    $0x0,%r8d\n  movslq %r8d,%r8\n  movb   $0x0,(%rbx,%r8,1)\n  mov    %rbx,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    1204 <func0+0x8b>\n  cltq\n  lea    -0x1(%rbx,%rax,1),%rdx\n  mov    $0x0,%eax\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rbx,%rax,1)\n  jne    122f <func0+0xb6>\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     11ef <func0+0x76>\n  mov    %rbx,%rsi\n  mov    %r13,%rdi\n  call   1090 <strcpy@plt>\n  lea    0xdf0(%rip),%rsi        # 2006 <_fini+0xd8e>\n  mov    %r12,%rdi\n  call   1090 <strcpy@plt>\n  mov    %rbx,%rdi\n  call   1080 <free@plt>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    %rbx,%rsi\n  mov    %r13,%rdi\n  call   1090 <strcpy@plt>\n  lea    0xdbf(%rip),%rsi        # 2000 <_fini+0xd88>\n  jmp    1216 <func0+0x9d>\n  movslq %r8d,%rax\n  mov    %cl,(%rbx,%rax,1)\n  lea    0x1(%r8),%r8d\n  add    $0x1,%rsi\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  je     11c5 <func0+0x4c>\n  mov    %rbp,%rdx\n  mov    %edi,%eax\n  test   %dil,%dil\n  je     1243 <func0+0xca>\n  cmp    %cl,%al\n  je     124d <func0+0xd4>\n  add    $0x1,%rdx\n  movzbl (%rdx),%eax\n  test   %al,%al\n  jne    1267 <func0+0xee>\n  jmp    1243 <func0+0xca>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r14\n  mov    %rsi,%rbp\n  mov    %rdx,%r13\n  mov    %rcx,%r12\n  call   <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbx\n  movzbl (%r14),%ecx\n  test   %cl,%cl\n  je     L0\n  movzbl 0x0(%rbp),%edi\n  lea    0x1(%r14),%rsi\n  mov    $0x0,%r8d\n  jmp    L1\nL0:\n  mov    $0x0,%r8d\nL6:\n  movslq %r8d,%r8\n  movb   $0x0,(%rbx,%r8,1)\n  mov    %rbx,%rdi\n  call   <strlen@plt>\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %eax,%ecx\n  sar    %ecx\n  cmp    $0x1,%eax\n  jle    L2\n  cltq\n  lea    -0x1(%rbx,%rax,1),%rdx\n  mov    $0x0,%eax\nL4:\n  movzbl (%rdx),%esi\n  cmp    %sil,(%rbx,%rax,1)\n  jne    L3\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%ecx\n  jg     L4\nL2:\n  mov    %rbx,%rsi\n  mov    %r13,%rdi\n  call   <strcpy@plt>\n  lea    D0(%rip),%rsi\nL5:\n  mov    %r12,%rdi\n  call   <strcpy@plt>\n  mov    %rbx,%rdi\n  call   <free@plt>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL3:\n  mov    %rbx,%rsi\n  mov    %r13,%rdi\n  call   <strcpy@plt>\n  lea    D1(%rip),%rsi\n  jmp    L5\nL7:\n  movslq %r8d,%rax\n  mov    %cl,(%rbx,%rax,1)\n  lea    0x1(%r8),%r8d\nL8:\n  add    $0x1,%rsi\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  je     L6\nL1:\n  mov    %rbp,%rdx\n  mov    %edi,%eax\n  test   %dil,%dil\n  je     L7\nL9:\n  cmp    %cl,%al\n  je     L8\n  add    $0x1,%rdx\n  movzbl (%rdx),%eax\n  test   %al,%al\n  jne    L9\n  jmp    L7",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8198,
                "bias": [
                    3568
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3519
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4543
            },
            "L1": {
                "label": "L1",
                "addr": 4701
            },
            "L2": {
                "label": "L2",
                "addr": 4612
            },
            "L3": {
                "label": "L3",
                "addr": 4655
            },
            "L4": {
                "label": "L4",
                "addr": 4591
            },
            "L5": {
                "label": "L5",
                "addr": 4630
            },
            "L6": {
                "label": "L6",
                "addr": 4549
            },
            "L7": {
                "label": "L7",
                "addr": 4675
            },
            "L8": {
                "label": "L8",
                "addr": 4685
            },
            "L9": {
                "label": "L9",
                "addr": 4711
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "46616c7365005472756500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"False\""
                },
                "0x2006": {
                    "type": "string",
                    "value": "\"True\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 112,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   10b0 <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   10d0 <malloc@plt>\n  movzbl (%rbx),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     1211 <func0+0x71>\n  movzbl (%r14),%r8d\n  lea    0x1(%rbx),%rsi\n  xor    %edi,%edi\n  nopl   0x0(%rax)\n  mov    %r14,%rdx\n  mov    %r8d,%eax\n  test   %r8b,%r8b\n  jne    11fc <func0+0x5c>\n  jmp    1270 <func0+0xd0>\n  movzbl 0x1(%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     1270 <func0+0xd0>\n  cmp    %al,%cl\n  jne    11f0 <func0+0x50>\n  movzbl (%rsi),%ecx\n  add    $0x1,%rsi\n  test   %cl,%cl\n  jne    11e0 <func0+0x40>\n  movslq %edi,%rax\n  add    %r13,%rax\n  movb   $0x0,(%rax)\n  mov    %r13,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,%esi\n  shr    $0x1f,%esi\n  add    %eax,%esi\n  sar    %esi\n  cmp    $0x1,%eax\n  jle    1290 <func0+0xf0>\n  lea    -0x1(%rax),%ecx\n  xor    %edx,%edx\n  movslq %ecx,%rcx\n  add    %r13,%rcx\n  jmp    124c <func0+0xac>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%rdx\n  sub    $0x1,%rcx\n  cmp    %edx,%esi\n  jle    1290 <func0+0xf0>\n  movzbl (%rcx),%ebx\n  cmp    %bl,0x0(%r13,%rdx,1)\n  je     1240 <func0+0xa0>\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   10c0 <memcpy@plt>\n  lea    0xd94(%rip),%rsi        # 2000 <_fini+0xd40>\n  jmp    12a6 <func0+0x106>\n  xchg   %ax,%ax\n  movslq %edi,%rax\n  add    $0x1,%rsi\n  add    $0x1,%edi\n  mov    %cl,0x0(%r13,%rax,1)\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  jne    11e0 <func0+0x40>\n  jmp    120b <func0+0x6b>\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   10c0 <memcpy@plt>\n  lea    0xd60(%rip),%rsi        # 2006 <_fini+0xd46>\n  mov    %rbp,%rdi\n  call   10a0 <strcpy@plt>\n  pop    %rbx\n  mov    %r13,%rdi\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1090 <free@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  movzbl (%rbx),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     L0\n  movzbl (%r14),%r8d\n  lea    0x1(%rbx),%rsi\n  xor    %edi,%edi\n  nopl   0x0(%rax)\nL4:\n  mov    %r14,%rdx\n  mov    %r8d,%eax\n  test   %r8b,%r8b\n  jne    L1\n  jmp    L2\nL3:\n  movzbl 0x1(%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     L2\nL1:\n  cmp    %al,%cl\n  jne    L3\n  movzbl (%rsi),%ecx\n  add    $0x1,%rsi\n  test   %cl,%cl\n  jne    L4\nL9:\n  movslq %edi,%rax\n  add    %r13,%rax\nL0:\n  movb   $0x0,(%rax)\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  mov    %eax,%esi\n  shr    $0x1f,%esi\n  add    %eax,%esi\n  sar    %esi\n  cmp    $0x1,%eax\n  jle    L5\n  lea    -0x1(%rax),%ecx\n  xor    %edx,%edx\n  movslq %ecx,%rcx\n  add    %r13,%rcx\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL7:\n  add    $0x1,%rdx\n  sub    $0x1,%rcx\n  cmp    %edx,%esi\n  jle    L5\nL6:\n  movzbl (%rcx),%ebx\n  cmp    %bl,0x0(%r13,%rdx,1)\n  je     L7\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   <memcpy@plt>\n  lea    D0(%rip),%rsi\n  jmp    L8\n  xchg   %ax,%ax\nL2:\n  movslq %edi,%rax\n  add    $0x1,%rsi\n  add    $0x1,%edi\n  mov    %cl,0x0(%r13,%rax,1)\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  jne    L4\n  jmp    L9\nL5:\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   <memcpy@plt>\n  lea    D1(%rip),%rsi\nL8:\n  mov    %rbp,%rdi\n  call   <strcpy@plt>\n  pop    %rbx\n  mov    %r13,%rdi\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1090 <free@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3476
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8198,
                "bias": [
                    3424
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4625
            },
            "L1": {
                "label": "L1",
                "addr": 4604
            },
            "L2": {
                "label": "L2",
                "addr": 4720
            },
            "L3": {
                "label": "L3",
                "addr": 4592
            },
            "L4": {
                "label": "L4",
                "addr": 4576
            },
            "L5": {
                "label": "L5",
                "addr": 4752
            },
            "L6": {
                "label": "L6",
                "addr": 4684
            },
            "L7": {
                "label": "L7",
                "addr": 4672
            },
            "L8": {
                "label": "L8",
                "addr": 4774
            },
            "L9": {
                "label": "L9",
                "addr": 4619
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "46616c7365005472756500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"False\""
                },
                "0x2006": {
                    "type": "string",
                    "value": "\"True\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 112,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char *s, const char *c, char *result, char *palindrome) {\n    int len = strlen(s);\n    char *n = malloc((len + 1) * sizeof(char));\n    int ni = 0;\n    for (int i = 0; s[i] != '\\0'; i++) {\n        const char *temp = c;\n        bool found = false;\n        while (*temp != '\\0') {\n            if (s[i] == *temp) {\n                found = true;\n                break;\n            }\n            temp++;\n        }\n        if (!found) {\n            n[ni++] = s[i];\n        }\n    }\n    n[ni] = '\\0';\n\n    int n_len = strlen(n);\n    bool is_palindrome = true;\n    for (int i = 0; i < n_len / 2; i++) {\n        if (n[i] != n[n_len - 1 - i]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    strcpy(result, n);\n    strcpy(palindrome, is_palindrome ? \"True\" : \"False\");\n\n    free(n);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[100];\n    char palindrome[6];\n\n    func0(\"abcde\", \"ae\", result, palindrome);\n    assert(strcmp(result, \"bcd\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdef\", \"b\", result, palindrome);\n    assert(strcmp(result, \"acdef\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"abcdedcba\", \"ab\", result, palindrome);\n    assert(strcmp(result, \"cdedc\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"dwik\", \"w\", result, palindrome);\n    assert(strcmp(result, \"dik\") == 0 && strcmp(palindrome, \"False\") == 0);\n\n    func0(\"a\", \"a\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"abcdedcba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abcdedcba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"vabba\", \"v\", result, palindrome);\n    assert(strcmp(result, \"abba\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    func0(\"mamma\", \"mia\", result, palindrome);\n    assert(strcmp(result, \"\") == 0 && strcmp(palindrome, \"True\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   10b0 <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   10d0 <malloc@plt>\n  movzbl (%rbx),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     1211 <func0+0x71>\n  movzbl (%r14),%r8d\n  lea    0x1(%rbx),%rsi\n  xor    %edi,%edi\n  nopl   0x0(%rax)\n  mov    %r14,%rdx\n  mov    %r8d,%eax\n  test   %r8b,%r8b\n  jne    11fc <func0+0x5c>\n  jmp    1270 <func0+0xd0>\n  movzbl 0x1(%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     1270 <func0+0xd0>\n  cmp    %al,%cl\n  jne    11f0 <func0+0x50>\n  movzbl (%rsi),%ecx\n  add    $0x1,%rsi\n  test   %cl,%cl\n  jne    11e0 <func0+0x40>\n  movslq %edi,%rax\n  add    %r13,%rax\n  movb   $0x0,(%rax)\n  mov    %r13,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,%esi\n  shr    $0x1f,%esi\n  add    %eax,%esi\n  sar    %esi\n  cmp    $0x1,%eax\n  jle    1290 <func0+0xf0>\n  lea    -0x1(%rax),%ecx\n  xor    %edx,%edx\n  movslq %ecx,%rcx\n  add    %r13,%rcx\n  jmp    124c <func0+0xac>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%rdx\n  sub    $0x1,%rcx\n  cmp    %edx,%esi\n  jle    1290 <func0+0xf0>\n  movzbl (%rcx),%ebx\n  cmp    %bl,0x0(%r13,%rdx,1)\n  je     1240 <func0+0xa0>\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   10c0 <memcpy@plt>\n  lea    0xd94(%rip),%rsi        # 2000 <_fini+0xd40>\n  jmp    12a6 <func0+0x106>\n  xchg   %ax,%ax\n  movslq %edi,%rax\n  add    $0x1,%rsi\n  add    $0x1,%edi\n  mov    %cl,0x0(%r13,%rax,1)\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  jne    11e0 <func0+0x40>\n  jmp    120b <func0+0x6b>\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   10c0 <memcpy@plt>\n  lea    0xd60(%rip),%rsi        # 2006 <_fini+0xd46>\n  mov    %rbp,%rdi\n  call   10a0 <strcpy@plt>\n  pop    %rbx\n  mov    %r13,%rdi\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1090 <free@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  push   %r12\n  mov    %rdx,%r12\n  push   %rbp\n  mov    %rcx,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  lea    0x1(%rax),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  movzbl (%rbx),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     L0\n  movzbl (%r14),%r8d\n  lea    0x1(%rbx),%rsi\n  xor    %edi,%edi\n  nopl   0x0(%rax)\nL4:\n  mov    %r14,%rdx\n  mov    %r8d,%eax\n  test   %r8b,%r8b\n  jne    L1\n  jmp    L2\nL3:\n  movzbl 0x1(%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     L2\nL1:\n  cmp    %al,%cl\n  jne    L3\n  movzbl (%rsi),%ecx\n  add    $0x1,%rsi\n  test   %cl,%cl\n  jne    L4\nL9:\n  movslq %edi,%rax\n  add    %r13,%rax\nL0:\n  movb   $0x0,(%rax)\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  mov    %eax,%esi\n  shr    $0x1f,%esi\n  add    %eax,%esi\n  sar    %esi\n  cmp    $0x1,%eax\n  jle    L5\n  lea    -0x1(%rax),%ecx\n  xor    %edx,%edx\n  movslq %ecx,%rcx\n  add    %r13,%rcx\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL7:\n  add    $0x1,%rdx\n  sub    $0x1,%rcx\n  cmp    %edx,%esi\n  jle    L5\nL6:\n  movzbl (%rcx),%ebx\n  cmp    %bl,0x0(%r13,%rdx,1)\n  je     L7\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   <memcpy@plt>\n  lea    D0(%rip),%rsi\n  jmp    L8\n  xchg   %ax,%ax\nL2:\n  movslq %edi,%rax\n  add    $0x1,%rsi\n  add    $0x1,%edi\n  mov    %cl,0x0(%r13,%rax,1)\n  movzbl -0x1(%rsi),%ecx\n  test   %cl,%cl\n  jne    L4\n  jmp    L9\nL5:\n  mov    %r13,%rsi\n  lea    0x1(%rax),%rdx\n  mov    %r12,%rdi\n  call   <memcpy@plt>\n  lea    D1(%rip),%rsi\nL8:\n  mov    %rbp,%rdi\n  call   <strcpy@plt>\n  pop    %rbx\n  mov    %r13,%rdi\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  jmp    1090 <free@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3476
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8198,
                "bias": [
                    3424
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4625
            },
            "L1": {
                "label": "L1",
                "addr": 4604
            },
            "L2": {
                "label": "L2",
                "addr": 4720
            },
            "L3": {
                "label": "L3",
                "addr": 4592
            },
            "L4": {
                "label": "L4",
                "addr": 4576
            },
            "L5": {
                "label": "L5",
                "addr": 4752
            },
            "L6": {
                "label": "L6",
                "addr": 4684
            },
            "L7": {
                "label": "L7",
                "addr": 4672
            },
            "L8": {
                "label": "L8",
                "addr": 4774
            },
            "L9": {
                "label": "L9",
                "addr": 4619
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "46616c7365005472756500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"False\""
                },
                "0x2006": {
                    "type": "string",
                    "value": "\"True\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 113,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    -0x3c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1060 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    1294 <func0+0x15b>\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    120d <func0+0xd4>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    1209 <func0+0xd0>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jg     1209 <func0+0xd0>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1209 <func0+0xd0>\n  addl   $0x1,-0x20(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1181 <func0+0x48>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x64,%edi\n  call   1060 <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x20(%rbp),%esi\n  mov    -0x20(%rbp),%ecx\n  mov    -0x20(%rbp),%edx\n  mov    %esi,%r8d\n  lea    0xd7d(%rip),%rsi        # 2000 <_fini+0xd54>\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1070 <sprintf@plt>\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     116e <func0+0x35>\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    -0x3c(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L0\nL4:\n  movl   $0x0,-0x20(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L1\nL3:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    L2\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jg     L2\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L2\n  addl   $0x1,-0x20(%rbp)\nL2:\n  addl   $0x1,-0x1c(%rbp)\nL1:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L3\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x64,%edi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x20(%rbp),%esi\n  mov    -0x20(%rbp),%ecx\n  mov    -0x20(%rbp),%edx\n  mov    %esi,%r8d\n  lea    D0(%rip),%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  addl   $0x1,-0x24(%rbp)\nL0:\n  mov    -0x24(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L4\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3453
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4756
            },
            "L1": {
                "label": "L1",
                "addr": 4621
            },
            "L2": {
                "label": "L2",
                "addr": 4617
            },
            "L3": {
                "label": "L3",
                "addr": 4481
            },
            "L4": {
                "label": "L4",
                "addr": 4462
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "746865206e756d626572206f66206f646420656c656d656e747320256420696e2074686520737472696e67202564206f662074686520256420696e7075742e00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"the number of odd elements %d in the string %d of the %d input.\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 113,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %esi,%r12d\n  movslq %esi,%rdi\n  shl    $0x3,%rdi\n  call   1060 <malloc@plt>\n  mov    %rax,%r13\n  test   %r12d,%r12d\n  jle    1204 <func0+0xcb>\n  mov    %r12d,%r12d\n  mov    $0x0,%ebp\n  lea    0xe88(%rip),%r15        # 2000 <_fini+0xde8>\n  jmp    11ee <func0+0xb5>\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%eax\n  test   %al,%al\n  je     11ad <func0+0x74>\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     117a <func0+0x41>\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebx\n  jmp    117a <func0+0x41>\n  mov    $0x64,%edi\n  call   1060 <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13,%rbp,8)\n  sub    $0x8,%rsp\n  push   %rbx\n  mov    %ebx,%r9d\n  mov    %ebx,%r8d\n  mov    %r15,%rcx\n  mov    $0x64,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%eax\n  call   1070 <__sprintf_chk@plt>\n  add    $0x1,%rbp\n  add    $0x10,%rsp\n  cmp    %r12,%rbp\n  je     1204 <func0+0xcb>\n  mov    (%r14,%rbp,8),%rdx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  mov    $0x0,%ebx\n  test   %al,%al\n  jne    1186 <func0+0x4d>\n  jmp    11ad <func0+0x74>\n  mov    %r13,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %esi,%r12d\n  movslq %esi,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %r12d,%r12d\n  jle    L0\n  mov    %r12d,%r12d\n  mov    $0x0,%ebp\n  lea    D0(%rip),%r15\n  jmp    L1\nL3:\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%eax\n  test   %al,%al\n  je     L2\nL4:\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     L3\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebx\n  jmp    L3\nL2:\n  mov    $0x64,%edi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13,%rbp,8)\n  sub    $0x8,%rsp\n  push   %rbx\n  mov    %ebx,%r9d\n  mov    %ebx,%r8d\n  mov    %r15,%rcx\n  mov    $0x64,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\n  add    $0x1,%rbp\n  add    $0x10,%rsp\n  cmp    %r12,%rbp\n  je     L0\nL1:\n  mov    (%r14,%rbp,8),%rdx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  mov    $0x0,%ebx\n  test   %al,%al\n  jne    L4\n  jmp    L2\nL0:\n  mov    %r13,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3720
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4612
            },
            "L1": {
                "label": "L1",
                "addr": 4590
            },
            "L2": {
                "label": "L2",
                "addr": 4525
            },
            "L3": {
                "label": "L3",
                "addr": 4474
            },
            "L4": {
                "label": "L4",
                "addr": 4486
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "746865206e756d626572206f66206f646420656c656d656e747320256420696e2074686520737472696e67202564206f662074686520256420696e7075742e00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"the number of odd elements %d in the string %d of the %d input.\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 113,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  sub    $0x8,%rsp\n  call   1060 <malloc@plt>\n  mov    %rax,%r12\n  test   %ebp,%ebp\n  jle    11f0 <func0+0xb0>\n  xor    %r14d,%r14d\n  lea    0xe86(%rip),%r13        # 2000 <_fini+0xdfc>\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx,%r14,8),%rdx\n  xor    %r15d,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     11b4 <func0+0x74>\n  nopw   0x0(%rax,%rax,1)\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     11a9 <func0+0x69>\n  and    $0x1,%eax\n  cmp    $0x1,%al\n  sbb    $0xffffffff,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    1198 <func0+0x58>\n  mov    $0x64,%edi\n  call   1060 <malloc@plt>\n  sub    $0x8,%rsp\n  mov    %r15d,%r9d\n  mov    %r15d,%r8d\n  push   %r15\n  mov    %rax,%rdi\n  mov    $0x64,%edx\n  mov    %r13,%rcx\n  mov    %rax,(%r12,%r14,8)\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%r14\n  call   1070 <__sprintf_chk@plt>\n  pop    %rax\n  pop    %rdx\n  cmp    %r14,%rbp\n  jne    1180 <func0+0x40>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %rax,%r12\n  test   %ebp,%ebp\n  jle    L0\n  xor    %r14d,%r14d\n  lea    D0(%rip),%r13\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    (%rbx,%r14,8),%rdx\n  xor    %r15d,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     L2\n  and    $0x1,%eax\n  cmp    $0x1,%al\n  sbb    $0xffffffff,%r15d\nL2:\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    L3\nL1:\n  mov    $0x64,%edi\n  call   <malloc@plt>\n  sub    $0x8,%rsp\n  mov    %r15d,%r9d\n  mov    %r15d,%r8d\n  push   %r15\n  mov    %rax,%rdi\n  mov    $0x64,%edx\n  mov    %r13,%rcx\n  mov    %rax,(%r12,%r14,8)\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%r14\n  call   <__sprintf_chk@plt>\n  pop    %rax\n  pop    %rdx\n  cmp    %r14,%rbp\n  jne    L4\nL0:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3718
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4592
            },
            "L1": {
                "label": "L1",
                "addr": 4532
            },
            "L2": {
                "label": "L2",
                "addr": 4521
            },
            "L3": {
                "label": "L3",
                "addr": 4504
            },
            "L4": {
                "label": "L4",
                "addr": 4480
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "746865206e756d626572206f66206f646420656c656d656e747320256420696e2074686520737472696e67202564206f662074686520256420696e7075742e00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"the number of odd elements %d in the string %d of the %d input.\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 113,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar **func0(char *lst[], int size) {\n    char **out = malloc(size * sizeof(char *));\n    for (int i = 0; i < size; i++) {\n        int sum = 0;\n        for (int j = 0; lst[i][j] != '\\0'; j++) {\n            if (lst[i][j] >= '0' && lst[i][j] <= '9' && (lst[i][j] - '0') % 2 == 1)\n                sum += 1;\n        }\n        out[i] = malloc(100); // Assuming the string will not be longer than 99 characters.\n        sprintf(out[i], \"the number of odd elements %d in the string %d of the %d input.\", sum, sum, sum);\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\nint issame(char **a, char **b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (strcmp(a[i], b[i]) != 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char *input1[] = {\"1234567\"};\n    char *expected1[] = {\"the number of odd elements 4 in the string 4 of the 4 input.\"};\n    char **result1 = func0(input1, 1);\n    assert(issame(result1, expected1, 1));\n\n    char *input2[] = {\"3\", \"11111111\"};\n    char *expected2[] = {\n        \"the number of odd elements 1 in the string 1 of the 1 input.\",\n        \"the number of odd elements 8 in the string 8 of the 8 input.\"\n    };\n    char **result2 = func0(input2, 2);\n    assert(issame(result2, expected2, 2));\n\n    char *input3[] = {\"271\", \"137\", \"314\"};\n    char *expected3[] = {\n        \"the number of odd elements 2 in the string 2 of the 2 input.\",\n        \"the number of odd elements 3 in the string 3 of the 3 input.\",\n        \"the number of odd elements 2 in the string 2 of the 2 input.\"\n    };\n    char **result3 = func0(input3, 3);\n    assert(issame(result3, expected3, 3));\n\n    // Free the allocated memory\n    for (int i = 0; i < 1; i++) free(result1[i]);\n    free(result1);\n    for (int i = 0; i < 2; i++) free(result2[i]);\n    free(result2);\n    for (int i = 0; i < 3; i++) free(result3[i]);\n    free(result3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  sub    $0x8,%rsp\n  call   1060 <malloc@plt>\n  mov    %rax,%r12\n  test   %ebp,%ebp\n  jle    11f0 <func0+0xb0>\n  xor    %r14d,%r14d\n  lea    0xe86(%rip),%r13        # 2000 <_fini+0xdfc>\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rbx,%r14,8),%rdx\n  xor    %r15d,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     11b4 <func0+0x74>\n  nopw   0x0(%rax,%rax,1)\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     11a9 <func0+0x69>\n  and    $0x1,%eax\n  cmp    $0x1,%al\n  sbb    $0xffffffff,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    1198 <func0+0x58>\n  mov    $0x64,%edi\n  call   1060 <malloc@plt>\n  sub    $0x8,%rsp\n  mov    %r15d,%r9d\n  mov    %r15d,%r8d\n  push   %r15\n  mov    %rax,%rdi\n  mov    $0x64,%edx\n  mov    %r13,%rcx\n  mov    %rax,(%r12,%r14,8)\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%r14\n  call   1070 <__sprintf_chk@plt>\n  pop    %rax\n  pop    %rdx\n  cmp    %rbp,%r14\n  jne    1180 <func0+0x40>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %esi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  lea    0x0(,%rbp,8),%rdi\n  sub    $0x8,%rsp\n  call   <malloc@plt>\n  mov    %rax,%r12\n  test   %ebp,%ebp\n  jle    L0\n  xor    %r14d,%r14d\n  lea    D0(%rip),%r13\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    (%rbx,%r14,8),%rdx\n  xor    %r15d,%r15d\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  je     L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  lea    -0x30(%rax),%ecx\n  cmp    $0x9,%cl\n  ja     L2\n  and    $0x1,%eax\n  cmp    $0x1,%al\n  sbb    $0xffffffff,%r15d\nL2:\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    L3\nL1:\n  mov    $0x64,%edi\n  call   <malloc@plt>\n  sub    $0x8,%rsp\n  mov    %r15d,%r9d\n  mov    %r15d,%r8d\n  push   %r15\n  mov    %rax,%rdi\n  mov    $0x64,%edx\n  mov    %r13,%rcx\n  mov    %rax,(%r12,%r14,8)\n  mov    $0x1,%esi\n  xor    %eax,%eax\n  add    $0x1,%r14\n  call   <__sprintf_chk@plt>\n  pop    %rax\n  pop    %rdx\n  cmp    %rbp,%r14\n  jne    L4\nL0:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3718
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4592
            },
            "L1": {
                "label": "L1",
                "addr": 4532
            },
            "L2": {
                "label": "L2",
                "addr": 4521
            },
            "L3": {
                "label": "L3",
                "addr": 4504
            },
            "L4": {
                "label": "L4",
                "addr": 4480
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "746865206e756d626572206f66206f646420656c656d656e747320256420696e2074686520737472696e67202564206f662074686520256420696e7075742e00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"the number of odd elements %d in the string %d of the %d input.\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 114,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    117f <func0+0x86>\n  cmpq   $0x0,-0x10(%rbp)\n  jns    114e <func0+0x55>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  jmp    1165 <func0+0x6c>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  cmp    -0x8(%rbp),%rax\n  jge    117b <func0+0x82>\n  mov    -0x10(%rbp),%rax\n  mov    %rax,-0x8(%rbp)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1127 <func0+0x2e>\n  mov    -0x8(%rbp),%rax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    L0\nL4:\n  cmpq   $0x0,-0x10(%rbp)\n  jns    L1\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  jmp    L2\nL1:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\nL2:\n  mov    %rax,-0x10(%rbp)\n  mov    -0x10(%rbp),%rax\n  cmp    -0x8(%rbp),%rax\n  jge    L3\n  mov    -0x10(%rbp),%rax\n  mov    %rax,-0x8(%rbp)\nL3:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L4\n  mov    -0x8(%rbp),%rax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4479
            },
            "L1": {
                "label": "L1",
                "addr": 4430
            },
            "L2": {
                "label": "L2",
                "addr": 4453
            },
            "L3": {
                "label": "L3",
                "addr": 4475
            },
            "L4": {
                "label": "L4",
                "addr": 4391
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 114,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    (%rdi),%rax\n  cmp    $0x1,%esi\n  jle    1133 <func0+0x3a>\n  lea    0x8(%rdi),%rdx\n  lea    -0x2(%rsi),%ecx\n  lea    0x10(%rdi,%rcx,8),%rsi\n  mov    %rax,%rcx\n  jmp    1129 <func0+0x30>\n  mov    (%rdx),%rax\n  cmp    %rax,%rcx\n  cmovg  %rax,%rcx\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  je     1136 <func0+0x3d>\n  test   %rax,%rax\n  jns    1116 <func0+0x1d>\n  add    (%rdx),%rax\n  jmp    1119 <func0+0x20>\n  mov    %rax,%rcx\n  mov    %rcx,%rax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    (%rdi),%rax\n  cmp    $0x1,%esi\n  jle    L0\n  lea    0x8(%rdi),%rdx\n  lea    -0x2(%rsi),%ecx\n  lea    0x10(%rdi,%rcx,8),%rsi\n  mov    %rax,%rcx\n  jmp    L1\nL3:\n  mov    (%rdx),%rax\nL4:\n  cmp    %rax,%rcx\n  cmovg  %rax,%rcx\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  je     L2\nL1:\n  test   %rax,%rax\n  jns    L3\n  add    (%rdx),%rax\n  jmp    L4\nL0:\n  mov    %rax,%rcx\nL2:\n  mov    %rcx,%rax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4403
            },
            "L1": {
                "label": "L1",
                "addr": 4393
            },
            "L2": {
                "label": "L2",
                "addr": 4406
            },
            "L3": {
                "label": "L3",
                "addr": 4374
            },
            "L4": {
                "label": "L4",
                "addr": 4377
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 114,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    (%rdi),%rax\n  cmp    $0x1,%esi\n  jle    1148 <func0+0x48>\n  lea    -0x2(%rsi),%ecx\n  lea    0x8(%rdi),%rdx\n  mov    %rax,%r8\n  lea    0x10(%rdi,%rcx,8),%rdi\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdx),%rcx\n  test   %rax,%rax\n  lea    (%rax,%rcx,1),%rsi\n  mov    %rcx,%rax\n  cmovs  %rsi,%rax\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rdi,%rdx\n  jne    1120 <func0+0x20>\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\n  mov    %rax,%r8\n  mov    %r8,%rax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    (%rdi),%rax\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%ecx\n  lea    0x8(%rdi),%rdx\n  mov    %rax,%r8\n  lea    0x10(%rdi,%rcx,8),%rdi\n  nopl   0x0(%rax,%rax,1)\nL1:\n  mov    (%rdx),%rcx\n  test   %rax,%rax\n  lea    (%rax,%rcx,1),%rsi\n  mov    %rcx,%rax\n  cmovs  %rsi,%rax\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rdi,%rdx\n  jne    L1\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\nL0:\n  mov    %rax,%r8\n  mov    %r8,%rax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4424
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 114,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nlong long func0(long long *nums, int size) {\n    long long current = nums[0];\n    long long min = nums[0];\n    for (int i = 1; i < size; i++) {\n        current = current < 0 ? current + nums[i] : nums[i];\n        if (current < min) min = current;\n    }\n    return min;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    long long nums1[] = {2, 3, 4, 1, 2, 4};\n    assert(func0(nums1, 6) == 1);\n\n    long long nums2[] = {-1, -2, -3};\n    assert(func0(nums2, 3) == -6);\n\n    long long nums3[] = {-1, -2, -3, 2, -10};\n    assert(func0(nums3, 5) == -14);\n\n    long long nums4[] = {-9999999999999999};\n    assert(func0(nums4, 1) == -9999999999999999);\n\n    long long nums5[] = {0, 10, 20, 1000000};\n    assert(func0(nums5, 4) == 0);\n\n    long long nums6[] = {-1, -2, -3, 10, -5};\n    assert(func0(nums6, 5) == -6);\n\n    long long nums7[] = {100, -1, -2, -3, 10, -5};\n    assert(func0(nums7, 6) == -6);\n\n    long long nums8[] = {10, 11, 13, 8, 3, 4};\n    assert(func0(nums8, 6) == 3);\n\n    long long nums9[] = {100, -33, 32, -1, 0, -2};\n    assert(func0(nums9, 6) == -33);\n\n    long long nums10[] = {-10};\n    assert(func0(nums10, 1) == -10);\n\n    long long nums11[] = {7};\n    assert(func0(nums11, 1) == 7);\n\n    long long nums12[] = {1, -1};\n    assert(func0(nums12, 2) == -1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    (%rdi),%rcx\n  cmp    $0x1,%esi\n  jle    1158 <func0+0x58>\n  lea    -0x2(%rsi),%eax\n  lea    0x8(%rdi),%rdx\n  mov    %rcx,%r8\n  lea    0x10(%rdi,%rax,8),%rsi\n  jmp    1133 <func0+0x33>\n  nopl   (%rax)\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rdx,%rsi\n  je     114e <func0+0x4e>\n  mov    %rax,%rcx\n  mov    (%rdx),%rax\n  test   %rcx,%rcx\n  jns    1120 <func0+0x20>\n  add    %rcx,%rax\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  jne    1130 <func0+0x30>\n  mov    %r8,%rax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %rcx,%r8\n  mov    %r8,%rax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    (%rdi),%rcx\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%eax\n  lea    0x8(%rdi),%rdx\n  mov    %rcx,%r8\n  lea    0x10(%rdi,%rax,8),%rsi\n  jmp    L1\n  nopl   (%rax)\nL3:\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rdx,%rsi\n  je     L2\nL4:\n  mov    %rax,%rcx\nL1:\n  mov    (%rdx),%rax\n  test   %rcx,%rcx\n  jns    L3\n  add    %rcx,%rax\n  cmp    %rax,%r8\n  cmovg  %rax,%r8\n  add    $0x8,%rdx\n  cmp    %rsi,%rdx\n  jne    L4\nL2:\n  mov    %r8,%rax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    %rcx,%r8\n  mov    %r8,%rax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4440
            },
            "L1": {
                "label": "L1",
                "addr": 4403
            },
            "L2": {
                "label": "L2",
                "addr": 4430
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4400
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 115,
        "type": "O0",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %ecx,-0x24(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    117e <func0+0x85>\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    115a <func0+0x61>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     112e <func0+0x35>\n  cmpl   $0x0,-0x8(%rbp)\n  jle    117a <func0+0x81>\n  mov    -0x8(%rbp),%edx\n  mov    -0x24(%rbp),%eax\n  add    %edx,%eax\n  sub    $0x1,%eax\n  cltd\n  idivl  -0x24(%rbp)\n  add    %eax,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111e <func0+0x25>\n  mov    -0x10(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %ecx,-0x24(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL4:\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L1\nL2:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     L2\n  cmpl   $0x0,-0x8(%rbp)\n  jle    L3\n  mov    -0x8(%rbp),%edx\n  mov    -0x24(%rbp),%eax\n  add    %edx,%eax\n  sub    $0x1,%eax\n  cltd\n  idivl  -0x24(%rbp)\n  add    %eax,-0x10(%rbp)\nL3:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  mov    -0x10(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4478
            },
            "L1": {
                "label": "L1",
                "addr": 4442
            },
            "L2": {
                "label": "L2",
                "addr": 4398
            },
            "L3": {
                "label": "L3",
                "addr": 4474
            },
            "L4": {
                "label": "L4",
                "addr": 4382
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 115,
        "type": "O1",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    115f <func0+0x66>\n  push   %rbx\n  mov    %edx,%r10d\n  mov    %ecx,%r9d\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%rdi\n  lea    -0x1(%rdx),%eax\n  mov    $0x0,%esi\n  lea    0x4(,%rax,4),%rbx\n  mov    $0x0,%r11d\n  jmp    1134 <func0+0x3b>\n  add    $0x8,%r8\n  cmp    %rdi,%r8\n  je     1167 <func0+0x6e>\n  test   %r10d,%r10d\n  jle    112b <func0+0x32>\n  mov    (%r8),%rax\n  lea    (%rbx,%rax,1),%rcx\n  mov    %r11d,%edx\n  add    (%rax),%edx\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    1143 <func0+0x4a>\n  test   %edx,%edx\n  jle    112b <func0+0x32>\n  lea    -0x1(%rdx,%r9,1),%eax\n  cltd\n  idiv   %r9d\n  add    %eax,%esi\n  jmp    112b <func0+0x32>\n  mov    $0x0,%esi\n  mov    %esi,%eax\n  ret\n  mov    %esi,%eax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %rbx\n  mov    %edx,%r10d\n  mov    %ecx,%r9d\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%rdi\n  lea    -0x1(%rdx),%eax\n  mov    $0x0,%esi\n  lea    0x4(,%rax,4),%rbx\n  mov    $0x0,%r11d\n  jmp    L1\nL3:\n  add    $0x8,%r8\n  cmp    %rdi,%r8\n  je     L2\nL1:\n  test   %r10d,%r10d\n  jle    L3\n  mov    (%r8),%rax\n  lea    (%rbx,%rax,1),%rcx\n  mov    %r11d,%edx\nL4:\n  add    (%rax),%edx\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L4\n  test   %edx,%edx\n  jle    L3\n  lea    -0x1(%rdx,%r9,1),%eax\n  cltd\n  idiv   %r9d\n  add    %eax,%esi\n  jmp    L3\nL0:\n  mov    $0x0,%esi\n  mov    %esi,%eax\n  ret\nL2:\n  mov    %esi,%eax\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4447
            },
            "L1": {
                "label": "L1",
                "addr": 4404
            },
            "L2": {
                "label": "L2",
                "addr": 4455
            },
            "L3": {
                "label": "L3",
                "addr": 4395
            },
            "L4": {
                "label": "L4",
                "addr": 4419
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 115,
        "type": "O2",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edx,%r10d\n  mov    %ecx,%r11d\n  test   %esi,%esi\n  jle    1168 <func0+0x68>\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x8(%rdi,%rax,8),%rsi\n  lea    -0x1(%rdx),%eax\n  lea    0x4(,%rax,4),%r9\n  nopl   0x0(%rax)\n  test   %r10d,%r10d\n  jle    115b <func0+0x5b>\n  mov    (%rdi),%rax\n  xor    %edx,%edx\n  lea    (%r9,%rax,1),%rcx\n  cs nopw 0x0(%rax,%rax,1)\n  add    (%rax),%edx\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    1140 <func0+0x40>\n  test   %edx,%edx\n  jle    115b <func0+0x5b>\n  lea    -0x1(%rdx,%r11,1),%eax\n  cltd\n  idiv   %r11d\n  add    %eax,%r8d\n  add    $0x8,%rdi\n  cmp    %rsi,%rdi\n  jne    1128 <func0+0x28>\n  mov    %r8d,%eax\n  ret\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edx,%r10d\n  mov    %ecx,%r11d\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x8(%rdi,%rax,8),%rsi\n  lea    -0x1(%rdx),%eax\n  lea    0x4(,%rax,4),%r9\n  nopl   0x0(%rax)\nL3:\n  test   %r10d,%r10d\n  jle    L1\n  mov    (%rdi),%rax\n  xor    %edx,%edx\n  lea    (%r9,%rax,1),%rcx\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  add    (%rax),%edx\n  add    $0x4,%rax\n  cmp    %rcx,%rax\n  jne    L2\n  test   %edx,%edx\n  jle    L1\n  lea    -0x1(%rdx,%r11,1),%eax\n  cltd\n  idiv   %r11d\n  add    %eax,%r8d\nL1:\n  add    $0x8,%rdi\n  cmp    %rsi,%rdi\n  jne    L3\n  mov    %r8d,%eax\n  ret\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4456
            },
            "L1": {
                "label": "L1",
                "addr": 4443
            },
            "L2": {
                "label": "L2",
                "addr": 4416
            },
            "L3": {
                "label": "L3",
                "addr": 4392
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 115,
        "type": "O3",
        "c_func": "#include <stdio.h>\nint func0(int **grid, int rows, int cols, int capacity) {\n    int out = 0;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j++)\n            sum += grid[i][j];\n        if (sum > 0) out += (sum + capacity - 1) / capacity;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint main() {\n    int rows, cols, capacity;\n    int **grid;\n    \n    // Test case 1\n    rows = 3; cols = 4; capacity = 1;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid1_data[3][4] = {{0,0,1,0}, {0,1,0,0}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid1_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 6);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 2\n    rows = 4; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid2_data[4][4] = {{0,0,1,1}, {0,0,0,0}, {1,1,1,1}, {0,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid2_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 5);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 3\n    rows = 2; cols = 3; capacity = 5;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid3_data[2][3] = {{0,0,0}, {0,0,0}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid3_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 0);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 4\n    rows = 2; cols = 4; capacity = 2;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid4_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid4_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 4);\n    for (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    // Test case 5\n    rows = 2; cols = 4; capacity = 9;\n    grid = (int **)malloc(rows * sizeof(int *));\n    int grid5_data[2][4] = {{1,1,1,1}, {1,1,1,1}};\n    for (int i = 0; i < rows; i++) {\n        grid[i] = (int *)malloc(cols * sizeof(int));\n        for (int j = 0; j < cols; j++) {\n            grid[i][j] = grid5_data[i][j];\n        }\n    }\n    assert(func0(grid, rows, cols, capacity) == 2);\nfor (int i = 0; i < rows; i++) free(grid[i]);\n    free(grid);\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    11ed <func0+0xed>\n  lea    -0x1(%rsi),%eax\n  push   %r13\n  mov    %ecx,%r9d\n  mov    %rdi,%rcx\n  push   %r12\n  mov    %edx,%r8d\n  xor    %r10d,%r10d\n  push   %rbp\n  lea    -0x1(%rdx),%ebp\n  push   %rbx\n  lea    0x8(%rdi,%rax,8),%rbx\n  mov    %edx,%eax\n  mov    %edx,%edi\n  shr    $0x2,%eax\n  and    $0xfffffffc,%edi\n  lea    -0x1(%rax),%r11d\n  add    $0x1,%r11\n  shl    $0x4,%r11\n  nop\n  test   %r8d,%r8d\n  jle    11d0 <func0+0xd0>\n  mov    (%rcx),%rsi\n  cmp    $0x2,%ebp\n  jbe    11e7 <func0+0xe7>\n  mov    %rsi,%rax\n  lea    (%r11,%rsi,1),%rdx\n  pxor   %xmm0,%xmm0\n  movdqu (%rax),%xmm2\n  add    $0x10,%rax\n  paddd  %xmm2,%xmm0\n  cmp    %rdx,%rax\n  jne    1160 <func0+0x60>\n  movdqa %xmm0,%xmm1\n  mov    %edi,%edx\n  psrldq $0x8,%xmm1\n  paddd  %xmm1,%xmm0\n  movdqa %xmm0,%xmm1\n  psrldq $0x4,%xmm1\n  paddd  %xmm1,%xmm0\n  movd   %xmm0,%eax\n  cmp    %edi,%r8d\n  je     11c0 <func0+0xc0>\n  movslq %edx,%r12\n  lea    0x0(,%r12,4),%r13\n  add    (%rsi,%r12,4),%eax\n  lea    0x1(%rdx),%r12d\n  cmp    %r12d,%r8d\n  jle    11c0 <func0+0xc0>\n  add    $0x2,%edx\n  add    0x4(%rsi,%r13,1),%eax\n  cmp    %edx,%r8d\n  jle    11c0 <func0+0xc0>\n  add    0x8(%rsi,%r13,1),%eax\n  test   %eax,%eax\n  jle    11d0 <func0+0xd0>\n  lea    -0x1(%rax,%r9,1),%eax\n  cltd\n  idiv   %r9d\n  add    %eax,%r10d\n  add    $0x8,%rcx\n  cmp    %rbx,%rcx\n  jne    1140 <func0+0x40>\n  pop    %rbx\n  mov    %r10d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    1196 <func0+0x96>\n  xor    %eax,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  push   %r13\n  mov    %ecx,%r9d\n  mov    %rdi,%rcx\n  push   %r12\n  mov    %edx,%r8d\n  xor    %r10d,%r10d\n  push   %rbp\n  lea    -0x1(%rdx),%ebp\n  push   %rbx\n  lea    0x8(%rdi,%rax,8),%rbx\n  mov    %edx,%eax\n  mov    %edx,%edi\n  shr    $0x2,%eax\n  and    $0xfffffffc,%edi\n  lea    -0x1(%rax),%r11d\n  add    $0x1,%r11\n  shl    $0x4,%r11\n  nop\nL5:\n  test   %r8d,%r8d\n  jle    L1\n  mov    (%rcx),%rsi\n  cmp    $0x2,%ebp\n  jbe    L2\n  mov    %rsi,%rax\n  lea    (%r11,%rsi,1),%rdx\n  pxor   %xmm0,%xmm0\nL3:\n  movdqu (%rax),%xmm2\n  add    $0x10,%rax\n  paddd  %xmm2,%xmm0\n  cmp    %rdx,%rax\n  jne    L3\n  movdqa %xmm0,%xmm1\n  mov    %edi,%edx\n  psrldq $0x8,%xmm1\n  paddd  %xmm1,%xmm0\n  movdqa %xmm0,%xmm1\n  psrldq $0x4,%xmm1\n  paddd  %xmm1,%xmm0\n  movd   %xmm0,%eax\n  cmp    %edi,%r8d\n  je     L4\nL6:\n  movslq %edx,%r12\n  lea    0x0(,%r12,4),%r13\n  add    (%rsi,%r12,4),%eax\n  lea    0x1(%rdx),%r12d\n  cmp    %r12d,%r8d\n  jle    L4\n  add    $0x2,%edx\n  add    0x4(%rsi,%r13,1),%eax\n  cmp    %edx,%r8d\n  jle    L4\n  add    0x8(%rsi,%r13,1),%eax\nL4:\n  test   %eax,%eax\n  jle    L1\n  lea    -0x1(%rax,%r9,1),%eax\n  cltd\n  idiv   %r9d\n  add    %eax,%r10d\nL1:\n  add    $0x8,%rcx\n  cmp    %rbx,%rcx\n  jne    L5\n  pop    %rbx\n  mov    %r10d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL2:\n  xor    %edx,%edx\n  xor    %eax,%eax\n  jmp    L6\nL0:\n  xor    %eax,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4589
            },
            "L1": {
                "label": "L1",
                "addr": 4560
            },
            "L2": {
                "label": "L2",
                "addr": 4583
            },
            "L3": {
                "label": "L3",
                "addr": 4448
            },
            "L4": {
                "label": "L4",
                "addr": 4544
            },
            "L5": {
                "label": "L5",
                "addr": 4416
            },
            "L6": {
                "label": "L6",
                "addr": 4502
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 116,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    124d <func0+0x154>\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    123d <func0+0x144>\n  movl   $0x0,-0x18(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    1169 <func0+0x70>\n  mov    -0x14(%rbp),%eax\n  and    $0x1,%eax\n  add    %eax,-0x18(%rbp)\n  sarl   -0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     115d <func0+0x64>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    118a <func0+0x91>\n  mov    -0x10(%rbp),%eax\n  and    $0x1,%eax\n  add    %eax,-0x18(%rbp)\n  sarl   -0x10(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jg     117e <func0+0x85>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     11da <func0+0xe1>\n  mov    -0x10(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    1239 <func0+0x140>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    1239 <func0+0x140>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1122 <func0+0x29>\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1114 <func0+0x1b>\n  nop\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL9:\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    L1\nL8:\n  movl   $0x0,-0x18(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x10(%rbp)\n  jmp    L2\nL3:\n  mov    -0x14(%rbp),%eax\n  and    $0x1,%eax\n  add    %eax,-0x18(%rbp)\n  sarl   -0x14(%rbp)\nL2:\n  cmpl   $0x0,-0x14(%rbp)\n  jg     L3\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  jmp    L4\nL5:\n  mov    -0x10(%rbp),%eax\n  and    $0x1,%eax\n  add    %eax,-0x18(%rbp)\n  sarl   -0x10(%rbp)\nL4:\n  cmpl   $0x0,-0x10(%rbp)\n  jg     L5\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jl     L6\n  mov    -0x10(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jne    L7\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L7\nL6:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\nL7:\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L8\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L9\n  nop\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4685
            },
            "L1": {
                "label": "L1",
                "addr": 4669
            },
            "L2": {
                "label": "L2",
                "addr": 4457
            },
            "L3": {
                "label": "L3",
                "addr": 4445
            },
            "L4": {
                "label": "L4",
                "addr": 4490
            },
            "L5": {
                "label": "L5",
                "addr": 4478
            },
            "L6": {
                "label": "L6",
                "addr": 4570
            },
            "L7": {
                "label": "L7",
                "addr": 4665
            },
            "L8": {
                "label": "L8",
                "addr": 4386
            },
            "L9": {
                "label": "L9",
                "addr": 4372
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 116,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    11cd <func0+0xd4>\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r13\n  lea    0x4(%rdi),%r9\n  lea    -0x1(%rsi),%r14d\n  mov    %esi,%r12d\n  mov    $0x1,%ebp\n  add    $0x8,%r13\n  jmp    1198 <func0+0x9f>\n  mov    $0x0,%ecx\n  jmp    1181 <func0+0x88>\n  mov    %r8d,-0x4(%r11)\n  mov    %edi,(%r10)\n  add    $0x4,%rsi\n  cmp    %rbx,%rsi\n  je     1190 <func0+0x97>\n  mov    %r9,%r11\n  mov    -0x4(%r9),%edi\n  mov    %rsi,%r10\n  mov    (%rsi),%r8d\n  test   %edi,%edi\n  jle    11b1 <func0+0xb8>\n  mov    %edi,%eax\n  mov    $0x0,%edx\n  mov    %eax,%ecx\n  and    $0x1,%ecx\n  add    %ecx,%edx\n  sar    %eax\n  test   %eax,%eax\n  jg     1157 <func0+0x5e>\n  test   %r8d,%r8d\n  jle    1128 <func0+0x2f>\n  mov    %r8d,%eax\n  mov    $0x0,%ecx\n  mov    %eax,%r15d\n  and    $0x1,%r15d\n  add    %r15d,%ecx\n  sar    %eax\n  test   %eax,%eax\n  jg     1171 <func0+0x78>\n  cmp    %ecx,%edx\n  jg     112f <func0+0x36>\n  cmp    %r8d,%edi\n  jle    1136 <func0+0x3d>\n  cmp    %edx,%ecx\n  jne    1136 <func0+0x3d>\n  jmp    112f <func0+0x36>\n  add    $0x1,%rbp\n  add    $0x4,%r9\n  cmp    %r12,%rbp\n  je     11c2 <func0+0xc9>\n  mov    %r14d,%eax\n  sub    %ebp,%eax\n  lea    -0x1(%rbp,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rbx\n  mov    %r9,%rsi\n  jmp    113f <func0+0x46>\n  mov    $0x0,%edx\n  mov    $0x0,%ecx\n  test   %r8d,%r8d\n  jg     1169 <func0+0x70>\n  jmp    1185 <func0+0x8c>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r13\n  lea    0x4(%rdi),%r9\n  lea    -0x1(%rsi),%r14d\n  mov    %esi,%r12d\n  mov    $0x1,%ebp\n  add    $0x8,%r13\n  jmp    L1\nL6:\n  mov    $0x0,%ecx\n  jmp    L2\nL8:\n  mov    %r8d,-0x4(%r11)\n  mov    %edi,(%r10)\nL9:\n  add    $0x4,%rsi\n  cmp    %rbx,%rsi\n  je     L3\nL11:\n  mov    %r9,%r11\n  mov    -0x4(%r9),%edi\n  mov    %rsi,%r10\n  mov    (%rsi),%r8d\n  test   %edi,%edi\n  jle    L4\n  mov    %edi,%eax\n  mov    $0x0,%edx\nL5:\n  mov    %eax,%ecx\n  and    $0x1,%ecx\n  add    %ecx,%edx\n  sar    %eax\n  test   %eax,%eax\n  jg     L5\n  test   %r8d,%r8d\n  jle    L6\nL12:\n  mov    %r8d,%eax\n  mov    $0x0,%ecx\nL7:\n  mov    %eax,%r15d\n  and    $0x1,%r15d\n  add    %r15d,%ecx\n  sar    %eax\n  test   %eax,%eax\n  jg     L7\nL2:\n  cmp    %ecx,%edx\n  jg     L8\nL13:\n  cmp    %r8d,%edi\n  jle    L9\n  cmp    %edx,%ecx\n  jne    L9\n  jmp    L8\nL3:\n  add    $0x1,%rbp\n  add    $0x4,%r9\nL1:\n  cmp    %r12,%rbp\n  je     L10\n  mov    %r14d,%eax\n  sub    %ebp,%eax\n  lea    -0x1(%rbp,%rax,1),%rax\n  lea    0x0(%r13,%rax,4),%rbx\n  mov    %r9,%rsi\n  jmp    L11\nL4:\n  mov    $0x0,%edx\n  mov    $0x0,%ecx\n  test   %r8d,%r8d\n  jg     L12\n  jmp    L13\nL10:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4557
            },
            "L1": {
                "label": "L1",
                "addr": 4504
            },
            "L2": {
                "label": "L2",
                "addr": 4481
            },
            "L3": {
                "label": "L3",
                "addr": 4496
            },
            "L4": {
                "label": "L4",
                "addr": 4529
            },
            "L5": {
                "label": "L5",
                "addr": 4439
            },
            "L6": {
                "label": "L6",
                "addr": 4392
            },
            "L7": {
                "label": "L7",
                "addr": 4465
            },
            "L8": {
                "label": "L8",
                "addr": 4399
            },
            "L9": {
                "label": "L9",
                "addr": 4406
            },
            "L10": {
                "label": "L10",
                "addr": 4546
            },
            "L11": {
                "label": "L11",
                "addr": 4415
            },
            "L12": {
                "label": "L12",
                "addr": 4457
            },
            "L13": {
                "label": "L13",
                "addr": 4485
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 116,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  test   %ebp,%ebp\n  jle    11a9 <func0+0xa9>\n  mov    %rdi,%r12\n  lea    0x4(%rdi),%r10\n  lea    -0x1(%rbp),%r13d\n  mov    $0x1,%ebx\n  add    $0x8,%r12\n  cmp    %rbp,%rbx\n  je     11a9 <func0+0xa9>\n  nopl   (%rax)\n  mov    %r13d,%eax\n  mov    %r10,%rdi\n  sub    %ebx,%eax\n  lea    -0x1(%rbx,%rax,1),%rax\n  lea    (%r12,%rax,4),%r11\n  nopl   0x0(%rax)\n  mov    -0x4(%r10),%r8d\n  mov    (%rdi),%r9d\n  test   %r8d,%r8d\n  jle    11c0 <func0+0xc0>\n  mov    %r8d,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax)\n  mov    %eax,%edx\n  and    $0x1,%edx\n  add    %edx,%ecx\n  sar    %eax\n  jne    1160 <func0+0x60>\n  test   %r9d,%r9d\n  jle    1183 <func0+0x83>\n  mov    %r9d,%edx\n  xor    %eax,%eax\n  nopl   (%rax)\n  mov    %edx,%esi\n  and    $0x1,%esi\n  add    %esi,%eax\n  sar    %edx\n  jne    1178 <func0+0x78>\n  cmp    %eax,%ecx\n  jg     11b0 <func0+0xb0>\n  sete   %al\n  cmp    %r9d,%r8d\n  jle    1193 <func0+0x93>\n  test   %al,%al\n  jne    11b0 <func0+0xb0>\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  jne    1148 <func0+0x48>\n  add    $0x1,%rbx\n  add    $0x4,%r10\n  cmp    %rbp,%rbx\n  jne    1130 <func0+0x30>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  mov    %r9d,-0x4(%r10)\n  mov    %r8d,(%rdi)\n  jmp    1193 <func0+0x93>\n  nopl   0x0(%rax)\n  xor    %ecx,%ecx\n  mov    $0x1,%eax\n  test   %r9d,%r9d\n  jg     1170 <func0+0x70>\n  jmp    118a <func0+0x8a>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %esi,%ebp\n  push   %rbx\n  test   %ebp,%ebp\n  jle    L0\n  mov    %rdi,%r12\n  lea    0x4(%rdi),%r10\n  lea    -0x1(%rbp),%r13d\n  mov    $0x1,%ebx\n  add    $0x8,%r12\n  cmp    %rbp,%rbx\n  je     L0\n  nopl   (%rax)\nL8:\n  mov    %r13d,%eax\n  mov    %r10,%rdi\n  sub    %ebx,%eax\n  lea    -0x1(%rbx,%rax,1),%rax\n  lea    (%r12,%rax,4),%r11\n  nopl   0x0(%rax)\nL7:\n  mov    -0x4(%r10),%r8d\n  mov    (%rdi),%r9d\n  test   %r8d,%r8d\n  jle    L1\n  mov    %r8d,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax)\nL2:\n  mov    %eax,%edx\n  and    $0x1,%edx\n  add    %edx,%ecx\n  sar    %eax\n  jne    L2\n  test   %r9d,%r9d\n  jle    L3\nL9:\n  mov    %r9d,%edx\n  xor    %eax,%eax\n  nopl   (%rax)\nL4:\n  mov    %edx,%esi\n  and    $0x1,%esi\n  add    %esi,%eax\n  sar    %edx\n  jne    L4\nL3:\n  cmp    %eax,%ecx\n  jg     L5\n  sete   %al\nL10:\n  cmp    %r9d,%r8d\n  jle    L6\n  test   %al,%al\n  jne    L5\nL6:\n  add    $0x4,%rdi\n  cmp    %r11,%rdi\n  jne    L7\n  add    $0x1,%rbx\n  add    $0x4,%r10\n  cmp    %rbp,%rbx\n  jne    L8\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL5:\n  mov    %r9d,-0x4(%r10)\n  mov    %r8d,(%rdi)\n  jmp    L6\n  nopl   0x0(%rax)\nL1:\n  xor    %ecx,%ecx\n  mov    $0x1,%eax\n  test   %r9d,%r9d\n  jg     L9\n  jmp    L10",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4521
            },
            "L1": {
                "label": "L1",
                "addr": 4544
            },
            "L2": {
                "label": "L2",
                "addr": 4448
            },
            "L3": {
                "label": "L3",
                "addr": 4483
            },
            "L4": {
                "label": "L4",
                "addr": 4472
            },
            "L5": {
                "label": "L5",
                "addr": 4528
            },
            "L6": {
                "label": "L6",
                "addr": 4499
            },
            "L7": {
                "label": "L7",
                "addr": 4424
            },
            "L8": {
                "label": "L8",
                "addr": 4400
            },
            "L9": {
                "label": "L9",
                "addr": 4464
            },
            "L10": {
                "label": "L10",
                "addr": 4490
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 116,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int *arr, int size) {\n    int count_ones, x, y, temp;\n    for (int i = 0; i < size; i++) {\n        for (int j = i + 1; j < size; j++) {\n            count_ones = 0;\n            x = arr[i];\n            y = arr[j];\n            while (x > 0) {\n                count_ones += x & 1;\n                x >>= 1;\n            }\n            x = count_ones;\n            count_ones = 0;\n            while (y > 0) {\n                count_ones += y & 1;\n                y >>= 1;\n            }\n            y = count_ones;\n            if (y < x || (y == x && arr[j] < arr[i])) {\n                temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 5, 2, 3, 4};\n    int expected1[] = {1, 2, 4, 3, 5};\n    func0(test1, 5);\n    assert(issame(test1, 5, expected1, 5));\n\n    int test3[] = {1, 0, 2, 3, 4};\n    int expected3[] = {0, 1, 2, 4, 3};\n    func0(test3, 5);\n    assert(issame(test3, 5, expected3, 5));\n\n    int test4[] = {2, 5, 77, 4, 5, 3, 5, 7, 2, 3, 4};\n    int expected4[] = {2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77};\n    func0(test4, 11);\n    assert(issame(test4, 11, expected4, 11));\n\n    int test5[] = {3, 6, 44, 12, 32, 5};\n    int expected5[] = {32, 3, 5, 6, 12, 44};\n    func0(test5, 6);\n    assert(issame(test5, 6, expected5, 6));\n\n    int test6[] = {2, 4, 8, 16, 32};\n    int expected6[] = {2, 4, 8, 16, 32};\n    func0(test6, 5);\n    assert(issame(test6, 5, expected6, 5));\n\n    printf(\"All tests passed!\\n\");\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    11ae <func0+0xae>\n  push   %rbp\n  mov    %rdi,%r10\n  movslq %esi,%rbp\n  mov    $0x1,%r11d\n  push   %rbx\n  mov    %esi,%ebx\n  nopl   (%rax)\n  mov    %r11,%rdi\n  nopl   0x0(%rax,%rax,1)\n  mov    -0x4(%r10,%r11,4),%r8d\n  mov    (%r10,%rdi,4),%r9d\n  test   %r8d,%r8d\n  jle    11a0 <func0+0xa0>\n  mov    %r8d,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\n  mov    %eax,%edx\n  and    $0x1,%edx\n  add    %edx,%ecx\n  sar    %eax\n  jne    1140 <func0+0x40>\n  test   %r9d,%r9d\n  jle    1163 <func0+0x63>\n  mov    %r9d,%edx\n  xor    %eax,%eax\n  nopl   (%rax)\n  mov    %edx,%esi\n  and    $0x1,%esi\n  add    %esi,%eax\n  sar    %edx\n  jne    1158 <func0+0x58>\n  cmp    %eax,%ecx\n  jg     1190 <func0+0x90>\n  sete   %al\n  cmp    %r9d,%r8d\n  jle    1173 <func0+0x73>\n  test   %al,%al\n  jne    1190 <func0+0x90>\n  add    $0x1,%rdi\n  cmp    %edi,%ebx\n  jg     1128 <func0+0x28>\n  add    $0x1,%r11\n  cmp    %r11,%rbp\n  jne    1120 <func0+0x20>\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %r9d,-0x4(%r10,%r11,4)\n  mov    %r8d,(%r10,%rdi,4)\n  jmp    1173 <func0+0x73>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ecx,%ecx\n  mov    $0x1,%eax\n  test   %r9d,%r9d\n  jg     1150 <func0+0x50>\n  jmp    116a <func0+0x6a>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  push   %rbp\n  mov    %rdi,%r10\n  movslq %esi,%rbp\n  mov    $0x1,%r11d\n  push   %rbx\n  mov    %esi,%ebx\n  nopl   (%rax)\nL8:\n  mov    %r11,%rdi\n  nopl   0x0(%rax,%rax,1)\nL7:\n  mov    -0x4(%r10,%r11,4),%r8d\n  mov    (%r10,%rdi,4),%r9d\n  test   %r8d,%r8d\n  jle    L1\n  mov    %r8d,%eax\n  xor    %ecx,%ecx\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    %eax,%edx\n  and    $0x1,%edx\n  add    %edx,%ecx\n  sar    %eax\n  jne    L2\n  test   %r9d,%r9d\n  jle    L3\nL9:\n  mov    %r9d,%edx\n  xor    %eax,%eax\n  nopl   (%rax)\nL4:\n  mov    %edx,%esi\n  and    $0x1,%esi\n  add    %esi,%eax\n  sar    %edx\n  jne    L4\nL3:\n  cmp    %eax,%ecx\n  jg     L5\n  sete   %al\nL10:\n  cmp    %r9d,%r8d\n  jle    L6\n  test   %al,%al\n  jne    L5\nL6:\n  add    $0x1,%rdi\n  cmp    %edi,%ebx\n  jg     L7\n  add    $0x1,%r11\n  cmp    %r11,%rbp\n  jne    L8\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopw   0x0(%rax,%rax,1)\nL5:\n  mov    %r9d,-0x4(%r10,%r11,4)\n  mov    %r8d,(%r10,%rdi,4)\n  jmp    L6\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %ecx,%ecx\n  mov    $0x1,%eax\n  test   %r9d,%r9d\n  jg     L9\n  jmp    L10\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4526
            },
            "L1": {
                "label": "L1",
                "addr": 4512
            },
            "L2": {
                "label": "L2",
                "addr": 4416
            },
            "L3": {
                "label": "L3",
                "addr": 4451
            },
            "L4": {
                "label": "L4",
                "addr": 4440
            },
            "L5": {
                "label": "L5",
                "addr": 4496
            },
            "L6": {
                "label": "L6",
                "addr": 4467
            },
            "L7": {
                "label": "L7",
                "addr": 4392
            },
            "L8": {
                "label": "L8",
                "addr": 4384
            },
            "L9": {
                "label": "L9",
                "addr": 4432
            },
            "L10": {
                "label": "L10",
                "addr": 4458
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 117,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x58,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %rdx,-0x58(%rbp)\n  lea    0xe08(%rip),%rax        # 2000 <_fini+0xc10>\n  mov    %rax,-0x28(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strlen@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x20(%rbp),%rax\n  add    $0x1,%rax\n  mov    %rax,%rdi\n  call   10f0 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  jmp    13c2 <func0+0x1e9>\n  call   1110 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    1292 <func0+0xb9>\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1341 <func0+0x168>\n  mov    -0x40(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jne    132f <func0+0x156>\n  mov    -0x34(%rbp),%eax\n  sub    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x3c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x30(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1100 <realloc@plt>\n  mov    %rax,-0x30(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   10d0 <strlen@plt>\n  add    $0x1,%rax\n  mov    -0x3c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x30(%rbp),%rdx\n  lea    (%rcx,%rdx,1),%rbx\n  mov    %rax,%rdi\n  call   10f0 <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x18(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10c0 <strcpy@plt>\n  addl   $0x1,-0x3c(%rbp)\n  mov    -0x34(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x38(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  jmp    13be <func0+0x1e5>\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  sub    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x28(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   10e0 <strchr@plt>\n  test   %rax,%rax\n  jne    13be <func0+0x1e5>\n  call   1110 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     13be <func0+0x1e5>\n  addl   $0x1,-0x40(%rbp)\n  addl   $0x1,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cltq\n  cmp    %rax,-0x20(%rbp)\n  jae    1249 <func0+0x70>\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <free@plt>\n  mov    -0x58(%rbp),%rax\n  mov    -0x3c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x30(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x58,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %rdx,-0x58(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x28(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x20(%rbp),%rax\n  add    $0x1,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x34(%rbp)\n  jmp    L0\nL5:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x2000,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\nL1:\n  mov    -0x40(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jne    L3\n  mov    -0x34(%rbp),%eax\n  sub    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x3c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x30(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x30(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  add    $0x1,%rax\n  mov    -0x3c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x30(%rbp),%rdx\n  lea    (%rcx,%rdx,1),%rbx\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x18(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcpy@plt>\n  addl   $0x1,-0x3c(%rbp)\nL3:\n  mov    -0x34(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x38(%rbp)\n  movl   $0x0,-0x40(%rbp)\n  jmp    L4\nL2:\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x34(%rbp),%eax\n  sub    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x28(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L4\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x48(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     L4\n  addl   $0x1,-0x40(%rbp)\nL4:\n  addl   $0x1,-0x34(%rbp)\nL0:\n  mov    -0x34(%rbp),%eax\n  cltq\n  cmp    %rax,-0x20(%rbp)\n  jae    L5\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x58(%rbp),%rax\n  mov    -0x3c(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x30(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3592
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5058
            },
            "L1": {
                "label": "L1",
                "addr": 4754
            },
            "L2": {
                "label": "L2",
                "addr": 4929
            },
            "L3": {
                "label": "L3",
                "addr": 4911
            },
            "L4": {
                "label": "L4",
                "addr": 5054
            },
            "L5": {
                "label": "L5",
                "addr": 4681
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 117,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%r14\n  mov    %esi,0x10(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   10d0 <strlen@plt>\n  mov    %rax,%r13\n  lea    0x1(%rax),%rdi\n  call   10f0 <malloc@plt>\n  mov    %rax,0x20(%rsp)\n  call   1110 <__ctype_b_loc@plt>\n  mov    %rax,%r15\n  mov    $0x0,%ebx\n  movl   $0x0,0xc(%rsp)\n  movl   $0x0,0x14(%rsp)\n  movl   $0x0,0x8(%rsp)\n  movq   $0x0,0x18(%rsp)\n  jmp    126a <func0+0x91>\n  mov    0x8(%rsp),%esi\n  cmp    %esi,0x10(%rsp)\n  je     12c5 <func0+0xec>\n  mov    0x4(%rsp),%eax\n  add    $0x1,%eax\n  mov    %eax,0xc(%rsp)\n  movl   $0x0,0x8(%rsp)\n  lea    0x1(%rbx),%rax\n  cmp    %rbx,%r13\n  je     1322 <func0+0x149>\n  mov    %rax,%rbx\n  mov    %ebx,0x4(%rsp)\n  mov    %ebx,%eax\n  mov    (%r15),%r12\n  movzbl (%r14,%rbx,1),%ebp\n  movsbq %bpl,%rdx\n  testb  $0x20,0x1(%r12,%rdx,2)\n  jne    123d <func0+0x64>\n  test   %bpl,%bpl\n  je     123d <func0+0x64>\n  sub    0xc(%rsp),%eax\n  cltq\n  mov    0x20(%rsp),%rcx\n  mov    %bpl,(%rcx,%rax,1)\n  movsbl %bpl,%esi\n  lea    0xd5d(%rip),%rdi        # 2000 <_fini+0xcb4>\n  call   10e0 <strchr@plt>\n  test   %rax,%rax\n  jne    125a <func0+0x81>\n  movzbl %bpl,%ebp\n  movzwl (%r12,%rbp,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbbl   $0xffffffff,0x8(%rsp)\n  jmp    125a <func0+0x81>\n  sub    0xc(%rsp),%eax\n  cltq\n  mov    0x20(%rsp),%r12\n  movb   $0x0,(%r12,%rax,1)\n  addl   $0x1,0x14(%rsp)\n  mov    0x14(%rsp),%eax\n  movslq %eax,%rbp\n  shl    $0x3,%rbp\n  mov    %rbp,%rsi\n  mov    0x18(%rsp),%rdi\n  call   1100 <realloc@plt>\n  mov    %rax,0x18(%rsp)\n  mov    %r12,%rdi\n  call   10d0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   10f0 <malloc@plt>\n  mov    %rax,%rdi\n  mov    0x18(%rsp),%rax\n  mov    %rdi,-0x8(%rax,%rbp,1)\n  mov    %r12,%rsi\n  call   10c0 <strcpy@plt>\n  jmp    1247 <func0+0x6e>\n  mov    0x20(%rsp),%rdi\n  call   10b0 <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x14(%rsp),%ecx\n  mov    %ecx,(%rax)\n  mov    0x18(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%r14\n  mov    %esi,0x10(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   <strlen@plt>\n  mov    %rax,%r13\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,0x20(%rsp)\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r15\n  mov    $0x0,%ebx\n  movl   $0x0,0xc(%rsp)\n  movl   $0x0,0x14(%rsp)\n  movl   $0x0,0x8(%rsp)\n  movq   $0x0,0x18(%rsp)\n  jmp    L0\nL3:\n  mov    0x8(%rsp),%esi\n  cmp    %esi,0x10(%rsp)\n  je     L1\nL5:\n  mov    0x4(%rsp),%eax\n  add    $0x1,%eax\n  mov    %eax,0xc(%rsp)\n  movl   $0x0,0x8(%rsp)\nL4:\n  lea    0x1(%rbx),%rax\n  cmp    %rbx,%r13\n  je     L2\n  mov    %rax,%rbx\nL0:\n  mov    %ebx,0x4(%rsp)\n  mov    %ebx,%eax\n  mov    (%r15),%r12\n  movzbl (%r14,%rbx,1),%ebp\n  movsbq %bpl,%rdx\n  testb  $0x20,0x1(%r12,%rdx,2)\n  jne    L3\n  test   %bpl,%bpl\n  je     L3\n  sub    0xc(%rsp),%eax\n  cltq\n  mov    0x20(%rsp),%rcx\n  mov    %bpl,(%rcx,%rax,1)\n  movsbl %bpl,%esi\n  lea    D0(%rip),%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L4\n  movzbl %bpl,%ebp\n  movzwl (%r12,%rbp,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbbl   $0xffffffff,0x8(%rsp)\n  jmp    L4\nL1:\n  sub    0xc(%rsp),%eax\n  cltq\n  mov    0x20(%rsp),%r12\n  movb   $0x0,(%r12,%rax,1)\n  addl   $0x1,0x14(%rsp)\n  mov    0x14(%rsp),%eax\n  movslq %eax,%rbp\n  shl    $0x3,%rbp\n  mov    %rbp,%rsi\n  mov    0x18(%rsp),%rdi\n  call   <realloc@plt>\n  mov    %rax,0x18(%rsp)\n  mov    %r12,%rdi\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  mov    0x18(%rsp),%rax\n  mov    %rdi,-0x8(%rax,%rbp,1)\n  mov    %r12,%rsi\n  call   <strcpy@plt>\n  jmp    L5\nL2:\n  mov    0x20(%rsp),%rdi\n  call   <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x14(%rsp),%ecx\n  mov    %ecx,(%rax)\n  mov    0x18(%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3421
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4714
            },
            "L1": {
                "label": "L1",
                "addr": 4805
            },
            "L2": {
                "label": "L2",
                "addr": 4898
            },
            "L3": {
                "label": "L3",
                "addr": 4669
            },
            "L4": {
                "label": "L4",
                "addr": 4698
            },
            "L5": {
                "label": "L5",
                "addr": 4679
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 117,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x38,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   10c0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  mov    %rax,%r15\n  call   10f0 <malloc@plt>\n  add    $0x1,%r15d\n  mov    %rax,%rbp\n  call   1110 <__ctype_b_loc@plt>\n  movl   $0x0,0x20(%rsp)\n  xor    %r11d,%r11d\n  xor    %r8d,%r8d\n  mov    (%rax),%r12\n  jmp    1252 <func0+0x72>\n  nopl   0x0(%rax,%rax,1)\n  cmp    %r8d,0xc(%rsp)\n  je     12f0 <func0+0x110>\n  mov    %ebx,%r11d\n  xor    %r8d,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  je     12c1 <func0+0xe1>\n  movsbq (%r14),%rsi\n  mov    %ebx,%eax\n  add    $0x1,%ebx\n  mov    %rsi,%rdx\n  testb  $0x20,0x1(%r12,%rsi,2)\n  jne    1238 <func0+0x58>\n  test   %sil,%sil\n  je     1238 <func0+0x58>\n  sub    %r11d,%eax\n  lea    0xd8b(%rip),%rdi        # 2000 <_fini+0xcb0>\n  mov    %r8d,0x24(%rsp)\n  cltq\n  mov    %r11d,0x18(%rsp)\n  mov    %sil,0x0(%rbp,%rax,1)\n  movsbl %sil,%esi\n  mov    %dl,0x10(%rsp)\n  call   10d0 <strchr@plt>\n  movzbl 0x10(%rsp),%edx\n  mov    0x18(%rsp),%r11d\n  test   %rax,%rax\n  mov    0x24(%rsp),%r8d\n  jne    1249 <func0+0x69>\n  movzwl (%r12,%rdx,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbb    $0xffffffff,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  jne    1252 <func0+0x72>\n  mov    %rbp,%rdi\n  call   10b0 <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x20(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x38,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  addl   $0x1,0x20(%rsp)\n  movslq 0x20(%rsp),%rsi\n  sub    %r11d,%eax\n  mov    %r13,%rdi\n  cltq\n  shl    $0x3,%rsi\n  movb   $0x0,0x0(%rbp,%rax,1)\n  mov    %rsi,0x18(%rsp)\n  call   1100 <realloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r13\n  call   10c0 <strlen@plt>\n  lea    0x1(%rax),%rdx\n  mov    %rdx,%rdi\n  mov    %rdx,0x10(%rsp)\n  call   10f0 <malloc@plt>\n  mov    0x18(%rsp),%rsi\n  mov    0x10(%rsp),%rdx\n  mov    %rax,%rdi\n  mov    %rax,-0x8(%r13,%rsi,1)\n  mov    %rbp,%rsi\n  call   10e0 <memcpy@plt>\n  jmp    1243 <func0+0x63>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x38,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  mov    %rax,%r15\n  call   <malloc@plt>\n  add    $0x1,%r15d\n  mov    %rax,%rbp\n  call   <__ctype_b_loc@plt>\n  movl   $0x0,0x20(%rsp)\n  xor    %r11d,%r11d\n  xor    %r8d,%r8d\n  mov    (%rax),%r12\n  jmp    L0\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    %r8d,0xc(%rsp)\n  je     L1\nL5:\n  mov    %ebx,%r11d\n  xor    %r8d,%r8d\nL4:\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  je     L2\nL0:\n  movsbq (%r14),%rsi\n  mov    %ebx,%eax\n  add    $0x1,%ebx\n  mov    %rsi,%rdx\n  testb  $0x20,0x1(%r12,%rsi,2)\n  jne    L3\n  test   %sil,%sil\n  je     L3\n  sub    %r11d,%eax\n  lea    D0(%rip),%rdi\n  mov    %r8d,0x24(%rsp)\n  cltq\n  mov    %r11d,0x18(%rsp)\n  mov    %sil,0x0(%rbp,%rax,1)\n  movsbl %sil,%esi\n  mov    %dl,0x10(%rsp)\n  call   <strchr@plt>\n  movzbl 0x10(%rsp),%edx\n  mov    0x18(%rsp),%r11d\n  test   %rax,%rax\n  mov    0x24(%rsp),%r8d\n  jne    L4\n  movzwl (%r12,%rdx,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbb    $0xffffffff,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  jne    L0\nL2:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x20(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x38,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  addl   $0x1,0x20(%rsp)\n  movslq 0x20(%rsp),%rsi\n  sub    %r11d,%eax\n  mov    %r13,%rdi\n  cltq\n  shl    $0x3,%rsi\n  movb   $0x0,0x0(%rbp,%rax,1)\n  mov    %rsi,0x18(%rsp)\n  call   <realloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r13\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdx\n  mov    %rdx,%rdi\n  mov    %rdx,0x10(%rsp)\n  call   <malloc@plt>\n  mov    0x18(%rsp),%rsi\n  mov    0x10(%rsp),%rdx\n  mov    %rax,%rdi\n  mov    %rax,-0x8(%r13,%rsi,1)\n  mov    %rbp,%rsi\n  call   <memcpy@plt>\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3467
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4690
            },
            "L1": {
                "label": "L1",
                "addr": 4848
            },
            "L2": {
                "label": "L2",
                "addr": 4801
            },
            "L3": {
                "label": "L3",
                "addr": 4664
            },
            "L4": {
                "label": "L4",
                "addr": 4681
            },
            "L5": {
                "label": "L5",
                "addr": 4675
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 117,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar **func0(const char *s, int n, int *returnSize) {\n    const char *vowels = \"aeiouAEIOU\";\n    char **out = NULL;\n    int numc = 0, word_count = 0, begin = 0;\n    size_t length = strlen(s);\n    char *current = (char *)malloc(length + 1);\n\n    for (int i = 0; i <= length; i++) {\n        if (isspace(s[i]) || s[i] == '\\0') {\n            if (numc == n) {\n                current[i - begin] = '\\0';\n                out = (char **)realloc(out, sizeof(char *) * (word_count + 1));\n                out[word_count] = (char *)malloc(strlen(current) + 1);\n                strcpy(out[word_count], current);\n                word_count++;\n            }\n            begin = i + 1;\n            numc = 0;\n        } else {\n            current[i - begin] = s[i];\n            if (strchr(vowels, s[i]) == NULL && isalpha((unsigned char)s[i])) {\n                numc++;\n            }\n        }\n    }\n    free(current);\n\n    *returnSize = word_count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int count) {\n    for (int i = 0; i < count; i++) {\n        free(words[i]);\n    }\n    free(words);\n}\n\nint main() {\n    int size;\n    char **words;\n    \n    words = func0(\"Mary had a little lamb\", 4, &size);\n    char *expected1[] = {\"little\"};\n    assert(issame(words, size, expected1, 1));\n    free_words(words, size);\n\n    words = func0(\"Mary had a little lamb\", 3, &size);\n    char *expected2[] = {\"Mary\", \"lamb\"};\n    assert(issame(words, size, expected2, 2));\n    free_words(words, size);\n\n    words = func0(\"simple white space\", 2, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"Hello world\", 4, &size);\n    char *expected3[] = {\"world\"};\n    assert(issame(words, size, expected3, 1));\n    free_words(words, size);\n\n    words = func0(\"Uncle sam\", 3, &size);\n    char *expected4[] = {\"Uncle\"};\n    assert(issame(words, size, expected4, 1));\n    free_words(words, size);\n\n    words = func0(\"\", 4, &size);\n    assert(size == 0);\n    free_words(words, size);\n\n    words = func0(\"a b c d e f\", 1, &size);\n    char *expected5[] = {\"b\", \"c\", \"d\", \"f\"};\n    assert(issame(words, size, expected5, 4));\n    free_words(words, size);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x38,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   10c0 <strlen@plt>\n  lea    0x1(%rax),%rdi\n  mov    %rax,%r15\n  call   10f0 <malloc@plt>\n  add    $0x1,%r15d\n  mov    %rax,%rbp\n  call   1110 <__ctype_b_loc@plt>\n  movl   $0x0,0x20(%rsp)\n  xor    %r11d,%r11d\n  xor    %r8d,%r8d\n  mov    (%rax),%r12\n  jmp    1252 <func0+0x72>\n  nopl   0x0(%rax,%rax,1)\n  cmp    %r8d,0xc(%rsp)\n  je     12f0 <func0+0x110>\n  mov    %ebx,%r11d\n  xor    %r8d,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  je     12c1 <func0+0xe1>\n  movsbq (%r14),%rsi\n  mov    %ebx,%eax\n  add    $0x1,%ebx\n  mov    %rsi,%rdx\n  testb  $0x20,0x1(%r12,%rsi,2)\n  jne    1238 <func0+0x58>\n  test   %sil,%sil\n  je     1238 <func0+0x58>\n  sub    %r11d,%eax\n  lea    0xd8b(%rip),%rdi        # 2000 <_fini+0xcb0>\n  mov    %r8d,0x24(%rsp)\n  cltq\n  mov    %r11d,0x18(%rsp)\n  mov    %sil,0x0(%rbp,%rax,1)\n  movsbl %sil,%esi\n  mov    %dl,0x10(%rsp)\n  call   10d0 <strchr@plt>\n  movzbl 0x10(%rsp),%edx\n  mov    0x18(%rsp),%r11d\n  test   %rax,%rax\n  mov    0x24(%rsp),%r8d\n  jne    1249 <func0+0x69>\n  movzwl (%r12,%rdx,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbb    $0xffffffff,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  jne    1252 <func0+0x72>\n  mov    %rbp,%rdi\n  call   10b0 <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x20(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x38,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  addl   $0x1,0x20(%rsp)\n  movslq 0x20(%rsp),%rsi\n  sub    %r11d,%eax\n  mov    %r13,%rdi\n  cltq\n  shl    $0x3,%rsi\n  movb   $0x0,0x0(%rbp,%rax,1)\n  mov    %rsi,0x18(%rsp)\n  call   1100 <realloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r13\n  call   10c0 <strlen@plt>\n  lea    0x1(%rax),%rdx\n  mov    %rdx,%rdi\n  mov    %rdx,0x10(%rsp)\n  call   10f0 <malloc@plt>\n  mov    0x18(%rsp),%rsi\n  mov    0x10(%rsp),%rdx\n  mov    %rax,%rdi\n  mov    %rax,-0x8(%r13,%rsi,1)\n  mov    %rbp,%rsi\n  call   10e0 <memcpy@plt>\n  jmp    1243 <func0+0x63>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x38,%rsp\n  mov    %esi,0xc(%rsp)\n  mov    %rdx,0x28(%rsp)\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdi\n  mov    %rax,%r15\n  call   <malloc@plt>\n  add    $0x1,%r15d\n  mov    %rax,%rbp\n  call   <__ctype_b_loc@plt>\n  movl   $0x0,0x20(%rsp)\n  xor    %r11d,%r11d\n  xor    %r8d,%r8d\n  mov    (%rax),%r12\n  jmp    L0\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    %r8d,0xc(%rsp)\n  je     L1\nL5:\n  mov    %ebx,%r11d\n  xor    %r8d,%r8d\nL4:\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  je     L2\nL0:\n  movsbq (%r14),%rsi\n  mov    %ebx,%eax\n  add    $0x1,%ebx\n  mov    %rsi,%rdx\n  testb  $0x20,0x1(%r12,%rsi,2)\n  jne    L3\n  test   %sil,%sil\n  je     L3\n  sub    %r11d,%eax\n  lea    D0(%rip),%rdi\n  mov    %r8d,0x24(%rsp)\n  cltq\n  mov    %r11d,0x18(%rsp)\n  mov    %sil,0x0(%rbp,%rax,1)\n  movsbl %sil,%esi\n  mov    %dl,0x10(%rsp)\n  call   <strchr@plt>\n  movzbl 0x10(%rsp),%edx\n  mov    0x18(%rsp),%r11d\n  test   %rax,%rax\n  mov    0x24(%rsp),%r8d\n  jne    L4\n  movzwl (%r12,%rdx,2),%eax\n  and    $0x400,%ax\n  cmp    $0x1,%ax\n  sbb    $0xffffffff,%r8d\n  add    $0x1,%r14\n  cmp    %ebx,%r15d\n  jne    L0\nL2:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    0x28(%rsp),%rax\n  mov    0x20(%rsp),%ecx\n  mov    %ecx,(%rax)\n  add    $0x38,%rsp\n  mov    %r13,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL1:\n  addl   $0x1,0x20(%rsp)\n  movslq 0x20(%rsp),%rsi\n  sub    %r11d,%eax\n  mov    %r13,%rdi\n  cltq\n  shl    $0x3,%rsi\n  movb   $0x0,0x0(%rbp,%rax,1)\n  mov    %rsi,0x18(%rsp)\n  call   <realloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r13\n  call   <strlen@plt>\n  lea    0x1(%rax),%rdx\n  mov    %rdx,%rdi\n  mov    %rdx,0x10(%rsp)\n  call   <malloc@plt>\n  mov    0x18(%rsp),%rsi\n  mov    0x10(%rsp),%rdx\n  mov    %rax,%rdi\n  mov    %rax,-0x8(%r13,%rsi,1)\n  mov    %rbp,%rsi\n  call   <memcpy@plt>\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3467
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4690
            },
            "L1": {
                "label": "L1",
                "addr": 4848
            },
            "L2": {
                "label": "L2",
                "addr": 4801
            },
            "L3": {
                "label": "L3",
                "addr": 4664
            },
            "L4": {
                "label": "L4",
                "addr": 4681
            },
            "L5": {
                "label": "L5",
                "addr": 4675
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6165696f754145494f5500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"aeiouAEIOU\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 118,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    0xeb0(%rip),%rax        # 2000 <_fini+0xdd8>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  sub    $0x2,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    120e <func0+0xd5>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     120a <func0+0xd1>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    120a <func0+0xd1>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    120a <func0+0xd1>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,0x2e30(%rip)        # 4031 <out.0>\n  lea    0x2e29(%rip),%rax        # 4031 <out.0>\n  jmp    1226 <func0+0xed>\n  subl   $0x1,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     1173 <func0+0x3a>\n  movb   $0x0,0x2e12(%rip)        # 4031 <out.0>\n  lea    0x2e0b(%rip),%rax        # 4031 <out.0>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  lea    D0(%rip),%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  sub    $0x2,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    L0\nL3:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L1\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  mov    -0x10(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L1\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,D1(%rip)\n  lea    D1(%rip),%rax\n  jmp    L2\nL1:\n  subl   $0x1,-0x14(%rbp)\nL0:\n  cmpl   $0x0,-0x14(%rbp)\n  jg     L3\n  movb   $0x0,D1(%rip)\n  lea    D1(%rip),%rax\nL2:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3760
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 16433,
                "bias": [
                    11824,
                    11817,
                    11794,
                    11787
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4622
            },
            "L1": {
                "label": "L1",
                "addr": 4618
            },
            "L2": {
                "label": "L2",
                "addr": 4646
            },
            "L3": {
                "label": "L3",
                "addr": 4467
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f556165696f7500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOUaeiou\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 118,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbp\n  call   1060 <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    11cd <func0+0x94>\n  movslq %edx,%rdx\n  lea    0x0(%rbp,%rdx,1),%rbx\n  lea    -0x1(%rbp,%rdx,1),%r14\n  lea    -0x3(%rax),%eax\n  sub    %rax,%r14\n  lea    0xe92(%rip),%r12        # 2000 <_fini+0xe2c>\n  jmp    1179 <func0+0x40>\n  sub    $0x1,%rbx\n  cmp    %r14,%rbx\n  je     11b1 <func0+0x78>\n  movzbl (%rbx),%ebp\n  movsbl %bpl,%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     1170 <func0+0x37>\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1170 <func0+0x37>\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1170 <func0+0x37>\n  jmp    11b6 <func0+0x7d>\n  mov    $0x0,%ebp\n  mov    %bpl,0x2e74(%rip)        # 4031 <out.0>\n  lea    0x2e6d(%rip),%rax        # 4031 <out.0>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x0,%ebp\n  jmp    11b6 <func0+0x7d>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbp\n  call   <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    L0\n  movslq %edx,%rdx\n  lea    0x0(%rbp,%rdx,1),%rbx\n  lea    -0x1(%rbp,%rdx,1),%r14\n  lea    -0x3(%rax),%eax\n  sub    %rax,%r14\n  lea    D0(%rip),%r12\n  jmp    L1\nL3:\n  sub    $0x1,%rbx\n  cmp    %r14,%rbx\n  je     L2\nL1:\n  movzbl (%rbx),%ebp\n  movsbl %bpl,%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L3\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L3\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L3\n  jmp    L4\nL2:\n  mov    $0x0,%ebp\nL4:\n  mov    %bpl,D1(%rip)\n  lea    D1(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  mov    $0x0,%ebp\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3730
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 16433,
                "bias": [
                    11892,
                    11885
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4557
            },
            "L1": {
                "label": "L1",
                "addr": 4473
            },
            "L2": {
                "label": "L2",
                "addr": 4529
            },
            "L3": {
                "label": "L3",
                "addr": 4464
            },
            "L4": {
                "label": "L4",
                "addr": 4534
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f556165696f7500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOUaeiou\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 118,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    11e0 <func0+0xa0>\n  movslq %edx,%rdx\n  sub    $0x3,%eax\n  lea    0xe92(%rip),%r12        # 2000 <_fini+0xe1c>\n  lea    -0x1(%rbp,%rdx,1),%r13\n  lea    0x0(%rbp,%rdx,1),%rbx\n  sub    %rax,%r13\n  jmp    1189 <func0+0x49>\n  nopl   (%rax)\n  sub    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     11e0 <func0+0xa0>\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  mov    %esi,%ebp\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     1180 <func0+0x40>\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1180 <func0+0x40>\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1180 <func0+0x40>\n  mov    %bpl,0x2e6d(%rip)        # 4031 <out.0>\n  add    $0x8,%rsp\n  lea    0x2e62(%rip),%rax        # 4031 <out.0>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  xor    %ebp,%ebp\n  jmp    11bd <func0+0x7d>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    L0\n  movslq %edx,%rdx\n  sub    $0x3,%eax\n  lea    D0(%rip),%r12\n  lea    -0x1(%rbp,%rdx,1),%r13\n  lea    0x0(%rbp,%rdx,1),%rbx\n  sub    %rax,%r13\n  jmp    L1\n  nopl   (%rax)\nL2:\n  sub    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  mov    %esi,%ebp\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L2\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\nL3:\n  mov    %bpl,D1(%rip)\n  add    $0x8,%rsp\n  lea    D1(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  xor    %ebp,%ebp\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3730
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 16433,
                "bias": [
                    11885,
                    11874
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4576
            },
            "L1": {
                "label": "L1",
                "addr": 4489
            },
            "L2": {
                "label": "L2",
                "addr": 4480
            },
            "L3": {
                "label": "L3",
                "addr": 4541
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f556165696f7500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOUaeiou\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 118,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(const char *word) {\n    static char out[2] = {0};\n    const char *vowels = \"AEIOUaeiou\";\n    size_t len = strlen(word);\n    \n    for (int i = len - 2; i >= 1; i--) {\n        if (strchr(vowels, word[i]) && !strchr(vowels, word[i + 1]) && !strchr(vowels, word[i - 1])) {\n            out[0] = word[i];\n            return out;\n        }\n    }\n    out[0] = '\\0';\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"yogurt\"), \"u\") == 0);\n    assert(strcmp(func0(\"full\"), \"u\") == 0);\n    assert(strcmp(func0(\"easy\"), \"\") == 0);\n    assert(strcmp(func0(\"eAsy\"), \"\") == 0);\n    assert(strcmp(func0(\"ali\"), \"\") == 0);\n    assert(strcmp(func0(\"bad\"), \"a\") == 0);\n    assert(strcmp(func0(\"most\"), \"o\") == 0);\n    assert(strcmp(func0(\"ab\"), \"\") == 0);\n    assert(strcmp(func0(\"ba\"), \"\") == 0);\n    assert(strcmp(func0(\"quick\"), \"\") == 0);\n    assert(strcmp(func0(\"anime\"), \"i\") == 0);\n    assert(strcmp(func0(\"Asia\"), \"\") == 0);\n    assert(strcmp(func0(\"Above\"), \"o\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    11e0 <func0+0xa0>\n  movslq %edx,%rdx\n  sub    $0x3,%eax\n  lea    0xe92(%rip),%r12        # 2000 <_fini+0xe1c>\n  lea    -0x1(%rbp,%rdx,1),%r13\n  lea    0x0(%rbp,%rdx,1),%rbx\n  sub    %rax,%r13\n  jmp    1189 <func0+0x49>\n  nopl   (%rax)\n  sub    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     11e0 <func0+0xa0>\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  mov    %esi,%ebp\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  je     1180 <func0+0x40>\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1180 <func0+0x40>\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   1070 <strchr@plt>\n  test   %rax,%rax\n  jne    1180 <func0+0x40>\n  mov    %bpl,0x2e6d(%rip)        # 4031 <out.0>\n  add    $0x8,%rsp\n  lea    0x2e62(%rip),%rax        # 4031 <out.0>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\n  xor    %ebp,%ebp\n  jmp    11bd <func0+0x7d>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  lea    -0x2(%rax),%edx\n  test   %edx,%edx\n  jle    L0\n  movslq %edx,%rdx\n  sub    $0x3,%eax\n  lea    D0(%rip),%r12\n  lea    -0x1(%rbp,%rdx,1),%r13\n  lea    0x0(%rbp,%rdx,1),%rbx\n  sub    %rax,%r13\n  jmp    L1\n  nopl   (%rax)\nL2:\n  sub    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L0\nL1:\n  movsbl (%rbx),%esi\n  mov    %r12,%rdi\n  mov    %esi,%ebp\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L2\n  movsbl 0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\n  movsbl -0x1(%rbx),%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\nL3:\n  mov    %bpl,D1(%rip)\n  add    $0x8,%rsp\n  lea    D1(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  cs nopw 0x0(%rax,%rax,1)\nL0:\n  xor    %ebp,%ebp\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3730
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 16433,
                "bias": [
                    11885,
                    11874
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4576
            },
            "L1": {
                "label": "L1",
                "addr": 4489
            },
            "L2": {
                "label": "L2",
                "addr": 4480
            },
            "L3": {
                "label": "L3",
                "addr": 4541
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4145494f556165696f7500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"AEIOUaeiou\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 119,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11a3 <func0+0x8a>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    117a <func0+0x61>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    1192 <func0+0x79>\n  subl   $0x1,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jns    119f <func0+0x86>\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     1162 <func0+0x49>\n  movl   $0x0,-0x10(%rbp)\n  jmp    11f5 <func0+0xdc>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    11cc <func0+0xb3>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    11e4 <func0+0xcb>\n  subl   $0x1,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jns    11f1 <func0+0xd8>\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     11b4 <func0+0x9b>\n  cmpl   $0x0,-0x14(%rbp)\n  jne    1215 <func0+0xfc>\n  cmpl   $0x0,-0xc(%rbp)\n  je     1215 <func0+0xfc>\n  lea    0xdf0(%rip),%rax        # 2000 <_fini+0xd18>\n  jmp    12e3 <func0+0x1ca>\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    126d <func0+0x154>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    1244 <func0+0x12b>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    125c <func0+0x143>\n  subl   $0x1,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jns    1269 <func0+0x150>\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     122c <func0+0x113>\n  movl   $0x0,-0x10(%rbp)\n  jmp    12bf <func0+0x1a6>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    1296 <func0+0x17d>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    12ae <func0+0x195>\n  subl   $0x1,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jns    12bb <func0+0x1a2>\n  movl   $0x0,-0xc(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     127e <func0+0x165>\n  cmpl   $0x0,-0x14(%rbp)\n  jne    12dc <func0+0x1c3>\n  cmpl   $0x0,-0xc(%rbp)\n  je     12dc <func0+0x1c3>\n  lea    0xd26(%rip),%rax        # 2000 <_fini+0xd18>\n  jmp    12e3 <func0+0x1ca>\n  lea    0xd21(%rip),%rax        # 2004 <_fini+0xd1c>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x8(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL4:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    L1\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    L2\n  subl   $0x1,-0x14(%rbp)\nL2:\n  cmpl   $0x0,-0x14(%rbp)\n  jns    L3\n  movl   $0x0,-0xc(%rbp)\nL3:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     L4\n  movl   $0x0,-0x10(%rbp)\n  jmp    L5\nL9:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    L6\n  addl   $0x1,-0x14(%rbp)\nL6:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    L7\n  subl   $0x1,-0x14(%rbp)\nL7:\n  cmpl   $0x0,-0x14(%rbp)\n  jns    L8\n  movl   $0x0,-0xc(%rbp)\nL8:\n  addl   $0x1,-0x10(%rbp)\nL5:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L9\n  cmpl   $0x0,-0x14(%rbp)\n  jne    L10\n  cmpl   $0x0,-0xc(%rbp)\n  je     L10\n  lea    D0(%rip),%rax\n  jmp    L11\nL10:\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L12\nL16:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    L13\n  addl   $0x1,-0x14(%rbp)\nL13:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    L14\n  subl   $0x1,-0x14(%rbp)\nL14:\n  cmpl   $0x0,-0x14(%rbp)\n  jns    L15\n  movl   $0x0,-0xc(%rbp)\nL15:\n  addl   $0x1,-0x10(%rbp)\nL12:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L16\n  movl   $0x0,-0x10(%rbp)\n  jmp    L17\nL21:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x28,%al\n  jne    L18\n  addl   $0x1,-0x14(%rbp)\nL18:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x29,%al\n  jne    L19\n  subl   $0x1,-0x14(%rbp)\nL19:\n  cmpl   $0x0,-0x14(%rbp)\n  jns    L20\n  movl   $0x0,-0xc(%rbp)\nL20:\n  addl   $0x1,-0x10(%rbp)\nL17:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x8(%rbp),%eax\n  jl     L21\n  cmpl   $0x0,-0x14(%rbp)\n  jne    L22\n  cmpl   $0x0,-0xc(%rbp)\n  je     L22\n  lea    D0(%rip),%rax\n  jmp    L11\nL22:\n  lea    D1(%rip),%rax\nL11:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3568,
                    3366
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3361
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4515
            },
            "L1": {
                "label": "L1",
                "addr": 4474
            },
            "L2": {
                "label": "L2",
                "addr": 4498
            },
            "L3": {
                "label": "L3",
                "addr": 4511
            },
            "L4": {
                "label": "L4",
                "addr": 4450
            },
            "L5": {
                "label": "L5",
                "addr": 4597
            },
            "L6": {
                "label": "L6",
                "addr": 4556
            },
            "L7": {
                "label": "L7",
                "addr": 4580
            },
            "L8": {
                "label": "L8",
                "addr": 4593
            },
            "L9": {
                "label": "L9",
                "addr": 4532
            },
            "L10": {
                "label": "L10",
                "addr": 4629
            },
            "L11": {
                "label": "L11",
                "addr": 4835
            },
            "L12": {
                "label": "L12",
                "addr": 4717
            },
            "L13": {
                "label": "L13",
                "addr": 4676
            },
            "L14": {
                "label": "L14",
                "addr": 4700
            },
            "L15": {
                "label": "L15",
                "addr": 4713
            },
            "L16": {
                "label": "L16",
                "addr": 4652
            },
            "L17": {
                "label": "L17",
                "addr": 4799
            },
            "L18": {
                "label": "L18",
                "addr": 4758
            },
            "L19": {
                "label": "L19",
                "addr": 4782
            },
            "L20": {
                "label": "L20",
                "addr": 4795
            },
            "L21": {
                "label": "L21",
                "addr": 4734
            },
            "L22": {
                "label": "L22",
                "addr": 4828
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "596573004e6f00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Yes\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"No\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 119,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,%rbp\n  call   1050 <strlen@plt>\n  mov    %rax,%r12\n  mov    %eax,%r13d\n  mov    %rbp,%rdi\n  call   1050 <strlen@plt>\n  mov    %eax,%r8d\n  test   %r12d,%r12d\n  jle    12b0 <func0+0x197>\n  mov    %rbx,%rsi\n  lea    -0x1(%r12),%edx\n  lea    0x1(%rbx,%rdx,1),%r10\n  mov    $0x1,%ecx\n  mov    $0x0,%edx\n  mov    $0x0,%r9d\n  jmp    1188 <func0+0x6f>\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rsi\n  cmp    %r10,%rsi\n  je     1196 <func0+0x7d>\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    116b <func0+0x52>\n  add    $0x1,%edx\n  jmp    1179 <func0+0x60>\n  test   %eax,%eax\n  jle    11d4 <func0+0xbb>\n  mov    %rbp,%rsi\n  lea    -0x1(%rax),%eax\n  lea    0x1(%rbp,%rax,1),%r9\n  mov    $0x0,%edi\n  jmp    11c1 <func0+0xa8>\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %edi,%ecx\n  add    $0x1,%rsi\n  cmp    %rsi,%r9\n  je     1288 <func0+0x16f>\n  movzbl (%rsi),%eax\n  cmp    $0x28,%al\n  je     11ac <func0+0x93>\n  cmp    $0x29,%al\n  sete   %al\n  movzbl %al,%eax\n  sub    %eax,%edx\n  jmp    11af <func0+0x96>\n  test   %edx,%edx\n  jne    11e7 <func0+0xce>\n  lea    0xe21(%rip),%rax        # 2000 <_fini+0xd34>\n  test   %ecx,%ecx\n  jne    127d <func0+0x164>\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  test   %r12d,%r12d\n  jg     1230 <func0+0x117>\n  lea    0xe03(%rip),%rax        # 2000 <_fini+0xd34>\n  jmp    127d <func0+0x164>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r8d\n  jle    122b <func0+0x112>\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  je     11ff <func0+0xe6>\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    1202 <func0+0xe9>\n  test   %r12d,%r12d\n  jle    1267 <func0+0x14e>\n  mov    $0x0,%ecx\n  mov    $0x0,%edi\n  jmp    124d <func0+0x134>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r13d\n  jle    1267 <func0+0x14e>\n  movzbl (%rbx,%rcx,1),%esi\n  cmp    $0x28,%sil\n  je     123c <func0+0x123>\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    123f <func0+0x126>\n  test   %eax,%eax\n  jne    1276 <func0+0x15d>\n  lea    0xd8e(%rip),%rax        # 2000 <_fini+0xd34>\n  test   %edx,%edx\n  jne    127d <func0+0x164>\n  lea    0xd87(%rip),%rax        # 2004 <_fini+0xd38>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  test   %ecx,%ecx\n  je     1297 <func0+0x17e>\n  lea    0xd6d(%rip),%rax        # 2000 <_fini+0xd34>\n  test   %edx,%edx\n  je     127d <func0+0x164>\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  mov    $0x0,%edi\n  jmp    1210 <func0+0xf7>\n  mov    $0x1,%ecx\n  mov    $0x0,%edx\n  test   %eax,%eax\n  jg     119a <func0+0x81>\n  lea    0xd37(%rip),%rax        # 2000 <_fini+0xd34>\n  jmp    127d <func0+0x164>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%rbx\n  mov    %rsi,%rbp\n  call   <strlen@plt>\n  mov    %rax,%r12\n  mov    %eax,%r13d\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  mov    %eax,%r8d\n  test   %r12d,%r12d\n  jle    L0\n  mov    %rbx,%rsi\n  lea    -0x1(%r12),%edx\n  lea    0x1(%rbx,%rdx,1),%r10\n  mov    $0x1,%ecx\n  mov    $0x0,%edx\n  mov    $0x0,%r9d\n  jmp    L1\nL3:\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\nL4:\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rsi\n  cmp    %r10,%rsi\n  je     L2\nL1:\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    L3\n  add    $0x1,%edx\n  jmp    L4\nL2:\n  test   %eax,%eax\n  jle    L5\nL23:\n  mov    %rbp,%rsi\n  lea    -0x1(%rax),%eax\n  lea    0x1(%rbp,%rax,1),%r9\n  mov    $0x0,%edi\n  jmp    L6\nL8:\n  add    $0x1,%edx\nL9:\n  test   %edx,%edx\n  cmovs  %edi,%ecx\n  add    $0x1,%rsi\n  cmp    %rsi,%r9\n  je     L7\nL6:\n  movzbl (%rsi),%eax\n  cmp    $0x28,%al\n  je     L8\n  cmp    $0x29,%al\n  sete   %al\n  movzbl %al,%eax\n  sub    %eax,%edx\n  jmp    L9\nL5:\n  test   %edx,%edx\n  jne    L10\n  lea    D0(%rip),%rax\n  test   %ecx,%ecx\n  jne    L11\nL10:\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  test   %r12d,%r12d\n  jg     L12\n  lea    D0(%rip),%rax\n  jmp    L11\nL14:\n  add    $0x1,%eax\nL15:\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r8d\n  jle    L13\nL22:\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  je     L14\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    L15\nL13:\n  test   %r12d,%r12d\n  jle    L16\nL12:\n  mov    $0x0,%ecx\n  mov    $0x0,%edi\n  jmp    L17\nL18:\n  add    $0x1,%eax\nL19:\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r13d\n  jle    L16\nL17:\n  movzbl (%rbx,%rcx,1),%esi\n  cmp    $0x28,%sil\n  je     L18\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    L19\nL16:\n  test   %eax,%eax\n  jne    L20\n  lea    D0(%rip),%rax\n  test   %edx,%edx\n  jne    L11\nL20:\n  lea    D1(%rip),%rax\nL11:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL7:\n  test   %ecx,%ecx\n  je     L21\n  lea    D0(%rip),%rax\n  test   %edx,%edx\n  je     L11\nL21:\n  mov    $0x0,%ecx\n  mov    $0x1,%edx\n  mov    $0x0,%eax\n  mov    $0x0,%edi\n  jmp    L22\nL0:\n  mov    $0x1,%ecx\n  mov    $0x0,%edx\n  test   %eax,%eax\n  jg     L23\n  lea    D0(%rip),%rax\n  jmp    L11",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3617,
                    3587,
                    3470,
                    3437,
                    3383
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3463
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4784
            },
            "L1": {
                "label": "L1",
                "addr": 4488
            },
            "L2": {
                "label": "L2",
                "addr": 4502
            },
            "L3": {
                "label": "L3",
                "addr": 4459
            },
            "L4": {
                "label": "L4",
                "addr": 4473
            },
            "L5": {
                "label": "L5",
                "addr": 4564
            },
            "L6": {
                "label": "L6",
                "addr": 4545
            },
            "L7": {
                "label": "L7",
                "addr": 4744
            },
            "L8": {
                "label": "L8",
                "addr": 4524
            },
            "L9": {
                "label": "L9",
                "addr": 4527
            },
            "L10": {
                "label": "L10",
                "addr": 4583
            },
            "L11": {
                "label": "L11",
                "addr": 4733
            },
            "L12": {
                "label": "L12",
                "addr": 4656
            },
            "L13": {
                "label": "L13",
                "addr": 4651
            },
            "L14": {
                "label": "L14",
                "addr": 4607
            },
            "L15": {
                "label": "L15",
                "addr": 4610
            },
            "L16": {
                "label": "L16",
                "addr": 4711
            },
            "L17": {
                "label": "L17",
                "addr": 4685
            },
            "L18": {
                "label": "L18",
                "addr": 4668
            },
            "L19": {
                "label": "L19",
                "addr": 4671
            },
            "L20": {
                "label": "L20",
                "addr": 4726
            },
            "L21": {
                "label": "L21",
                "addr": 4759
            },
            "L22": {
                "label": "L22",
                "addr": 4624
            },
            "L23": {
                "label": "L23",
                "addr": 4506
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "596573004e6f00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Yes\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"No\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 119,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  call   1050 <strlen@plt>\n  test   %r13d,%r13d\n  jle    12e0 <func0+0x1c0>\n  lea    -0x1(%r13),%edx\n  mov    %rbp,%rsi\n  mov    $0x1,%ecx\n  xor    %r8d,%r8d\n  lea    0x1(%rbp,%rdx,1),%r9\n  xor    %edx,%edx\n  jmp    118d <func0+0x6d>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     11a8 <func0+0x88>\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    1170 <func0+0x50>\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  jne    118d <func0+0x6d>\n  test   %eax,%eax\n  jle    12f8 <func0+0x1d8>\n  sub    $0x1,%eax\n  mov    %rbx,%rsi\n  xor    %r9d,%r9d\n  lea    0x1(%rbx,%rax,1),%r8\n  mov    %rbx,%rax\n  jmp    11e5 <func0+0xc5>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  je     1200 <func0+0xe0>\n  movzbl (%rax),%edi\n  cmp    $0x28,%dil\n  jne    11c8 <func0+0xa8>\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  jne    11e5 <func0+0xc5>\n  test   %edx,%edx\n  jne    1220 <func0+0x100>\n  and    $0x1,%ecx\n  lea    0xdf2(%rip),%rax        # 2000 <_fini+0xce8>\n  je     1220 <func0+0x100>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x1,%edx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    1249 <func0+0x129>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %r8,%rsi\n  je     1262 <func0+0x142>\n  movzbl (%rsi),%ecx\n  cmp    $0x28,%cl\n  jne    1230 <func0+0x110>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %r8,%rsi\n  jne    1249 <func0+0x129>\n  test   %r13d,%r13d\n  jle    12a8 <func0+0x188>\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    128c <func0+0x16c>\n  nopl   (%rax)\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jle    12a8 <func0+0x188>\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  jne    1270 <func0+0x150>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jg     128c <func0+0x16c>\n  test   %eax,%eax\n  jne    12c8 <func0+0x1a8>\n  and    $0x1,%edx\n  je     12c8 <func0+0x1a8>\n  add    $0x8,%rsp\n  lea    0xd44(%rip),%rax        # 2000 <_fini+0xce8>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\n  add    $0x8,%rsp\n  lea    0xd31(%rip),%rax        # 2004 <_fini+0xcec>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  test   %eax,%eax\n  jg     11b0 <func0+0x90>\n  jmp    12b1 <func0+0x191>\n  nopl   0x0(%rax)\n  test   %edx,%edx\n  jne    130c <func0+0x1ec>\n  and    $0x1,%ecx\n  lea    0xcfa(%rip),%rax        # 2000 <_fini+0xce8>\n  jne    1210 <func0+0xf0>\n  xor    %eax,%eax\n  mov    $0x1,%edx\n  jmp    1267 <func0+0x147>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  call   <strlen@plt>\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%edx\n  mov    %rbp,%rsi\n  mov    $0x1,%ecx\n  xor    %r8d,%r8d\n  lea    0x1(%rbp,%rdx,1),%r9\n  xor    %edx,%edx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     L2\nL1:\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    L3\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  jne    L1\nL2:\n  test   %eax,%eax\n  jle    L4\nL16:\n  sub    $0x1,%eax\n  mov    %rbx,%rsi\n  xor    %r9d,%r9d\n  lea    0x1(%rbx,%rax,1),%r8\n  mov    %rbx,%rax\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL7:\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  je     L6\nL5:\n  movzbl (%rax),%edi\n  cmp    $0x28,%dil\n  jne    L7\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  jne    L5\nL6:\n  test   %edx,%edx\n  jne    L8\n  and    $0x1,%ecx\n  lea    D0(%rip),%rax\n  je     L8\nL19:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\nL8:\n  mov    $0x1,%edx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL11:\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %r8,%rsi\n  je     L10\nL9:\n  movzbl (%rsi),%ecx\n  cmp    $0x28,%cl\n  jne    L11\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %r8,%rsi\n  jne    L9\nL10:\n  test   %r13d,%r13d\n  jle    L12\nL20:\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    L13\n  nopl   (%rax)\nL14:\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jle    L12\nL13:\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  jne    L14\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jg     L13\nL12:\n  test   %eax,%eax\n  jne    L15\n  and    $0x1,%edx\n  je     L15\nL17:\n  add    $0x8,%rsp\n  lea    D0(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\nL15:\n  add    $0x8,%rsp\n  lea    D1(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  test   %eax,%eax\n  jg     L16\n  jmp    L17\n  nopl   0x0(%rax)\nL4:\n  test   %edx,%edx\n  jne    L18\n  and    $0x1,%ecx\n  lea    D0(%rip),%rax\n  jne    L19\nL18:\n  xor    %eax,%eax\n  mov    $0x1,%edx\n  jmp    L20",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3570,
                    3396,
                    3322
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3377
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4832
            },
            "L1": {
                "label": "L1",
                "addr": 4493
            },
            "L2": {
                "label": "L2",
                "addr": 4520
            },
            "L3": {
                "label": "L3",
                "addr": 4464
            },
            "L4": {
                "label": "L4",
                "addr": 4856
            },
            "L5": {
                "label": "L5",
                "addr": 4581
            },
            "L6": {
                "label": "L6",
                "addr": 4608
            },
            "L7": {
                "label": "L7",
                "addr": 4552
            },
            "L8": {
                "label": "L8",
                "addr": 4640
            },
            "L9": {
                "label": "L9",
                "addr": 4681
            },
            "L10": {
                "label": "L10",
                "addr": 4706
            },
            "L11": {
                "label": "L11",
                "addr": 4656
            },
            "L12": {
                "label": "L12",
                "addr": 4776
            },
            "L13": {
                "label": "L13",
                "addr": 4748
            },
            "L14": {
                "label": "L14",
                "addr": 4720
            },
            "L15": {
                "label": "L15",
                "addr": 4808
            },
            "L16": {
                "label": "L16",
                "addr": 4528
            },
            "L17": {
                "label": "L17",
                "addr": 4785
            },
            "L18": {
                "label": "L18",
                "addr": 4876
            },
            "L19": {
                "label": "L19",
                "addr": 4624
            },
            "L20": {
                "label": "L20",
                "addr": 4711
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "596573004e6f00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Yes\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"No\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 119,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char *func0(const char *s1, const char *s2) {\n    int count = 0;\n    int len1 = strlen(s1);\n    int len2 = strlen(s2);\n    int i;\n    int can = 1;\n\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    count = 0;\n    can = 1;\n\n    for (i = 0; i < len2; i++) {\n        if (s2[i] == '(') count++;\n        if (s2[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    for (i = 0; i < len1; i++) {\n        if (s1[i] == '(') count++;\n        if (s1[i] == ')') count--;\n        if (count < 0) can = 0;\n    }\n    if (count == 0 && can) return \"Yes\";\n\n    return \"No\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"()(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \")\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(())\", \"())())\"), \"No\") == 0);\n    assert(strcmp(func0(\")())\", \"(()()(\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"(())))\", \"(()())((\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"()\", \"())\"), \"No\") == 0);\n    assert(strcmp(func0(\"(()(\", \"()))()\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"((((\", \"((())\"), \"No\") == 0);\n    assert(strcmp(func0(\")(()\", \"(()(\"), \"No\") == 0);\n    assert(strcmp(func0(\")(\", \")(\"), \"No\") == 0);\n    assert(strcmp(func0(\"(\", \")\"), \"Yes\") == 0);\n    assert(strcmp(func0(\")\", \"(\"), \"Yes\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  call   1050 <strlen@plt>\n  test   %r13d,%r13d\n  jle    12e0 <func0+0x1c0>\n  lea    -0x1(%r13),%edx\n  mov    %rbp,%rsi\n  mov    $0x1,%ecx\n  xor    %r8d,%r8d\n  lea    0x1(%rbp,%rdx,1),%r9\n  xor    %edx,%edx\n  jmp    118d <func0+0x6d>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     11a8 <func0+0x88>\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    1170 <func0+0x50>\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  jne    118d <func0+0x6d>\n  test   %eax,%eax\n  jle    12f8 <func0+0x1d8>\n  sub    $0x1,%eax\n  mov    %rbx,%rsi\n  xor    %r9d,%r9d\n  lea    0x1(%rbx,%rax,1),%r8\n  mov    %rbx,%rax\n  jmp    11e5 <func0+0xc5>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  je     1200 <func0+0xe0>\n  movzbl (%rax),%edi\n  cmp    $0x28,%dil\n  jne    11c8 <func0+0xa8>\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  jne    11e5 <func0+0xc5>\n  test   %edx,%edx\n  jne    1220 <func0+0x100>\n  and    $0x1,%ecx\n  lea    0xdf2(%rip),%rax        # 2000 <_fini+0xce8>\n  je     1220 <func0+0x100>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0x1,%edx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    1249 <func0+0x129>\n  nopl   0x0(%rax,%rax,1)\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %rsi,%r8\n  je     1262 <func0+0x142>\n  movzbl (%rsi),%ecx\n  cmp    $0x28,%cl\n  jne    1230 <func0+0x110>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %rsi,%r8\n  jne    1249 <func0+0x129>\n  test   %r13d,%r13d\n  jle    12a8 <func0+0x188>\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    128c <func0+0x16c>\n  nopl   (%rax)\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jle    12a8 <func0+0x188>\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  jne    1270 <func0+0x150>\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jg     128c <func0+0x16c>\n  test   %eax,%eax\n  jne    12c8 <func0+0x1a8>\n  and    $0x1,%edx\n  je     12c8 <func0+0x1a8>\n  add    $0x8,%rsp\n  lea    0xd44(%rip),%rax        # 2000 <_fini+0xce8>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\n  add    $0x8,%rsp\n  lea    0xd31(%rip),%rax        # 2004 <_fini+0xcec>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  test   %eax,%eax\n  jg     11b0 <func0+0x90>\n  jmp    12b1 <func0+0x191>\n  nopl   0x0(%rax)\n  test   %edx,%edx\n  jne    130c <func0+0x1ec>\n  and    $0x1,%ecx\n  lea    0xcfa(%rip),%rax        # 2000 <_fini+0xce8>\n  jne    1210 <func0+0xf0>\n  xor    %eax,%eax\n  mov    $0x1,%edx\n  jmp    1267 <func0+0x147>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r13\n  mov    %eax,%r12d\n  call   <strlen@plt>\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%edx\n  mov    %rbp,%rsi\n  mov    $0x1,%ecx\n  xor    %r8d,%r8d\n  lea    0x1(%rbp,%rdx,1),%r9\n  xor    %edx,%edx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  je     L2\nL1:\n  movzbl (%rsi),%edi\n  cmp    $0x28,%dil\n  jne    L3\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r8d,%ecx\n  add    $0x1,%rsi\n  cmp    %r9,%rsi\n  jne    L1\nL2:\n  test   %eax,%eax\n  jle    L4\nL16:\n  sub    $0x1,%eax\n  mov    %rbx,%rsi\n  xor    %r9d,%r9d\n  lea    0x1(%rbx,%rax,1),%r8\n  mov    %rbx,%rax\n  jmp    L5\n  nopl   0x0(%rax,%rax,1)\nL7:\n  cmp    $0x29,%dil\n  sete   %dil\n  movzbl %dil,%edi\n  sub    %edi,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  je     L6\nL5:\n  movzbl (%rax),%edi\n  cmp    $0x28,%dil\n  jne    L7\n  add    $0x1,%edx\n  test   %edx,%edx\n  cmovs  %r9d,%ecx\n  add    $0x1,%rax\n  cmp    %rax,%r8\n  jne    L5\nL6:\n  test   %edx,%edx\n  jne    L8\n  and    $0x1,%ecx\n  lea    D0(%rip),%rax\n  je     L8\nL19:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\nL8:\n  mov    $0x1,%edx\n  xor    %eax,%eax\n  xor    %edi,%edi\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL11:\n  cmp    $0x29,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  sub    %ecx,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %rsi,%r8\n  je     L10\nL9:\n  movzbl (%rsi),%ecx\n  cmp    $0x28,%cl\n  jne    L11\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rsi\n  cmp    %rsi,%r8\n  jne    L9\nL10:\n  test   %r13d,%r13d\n  jle    L12\nL20:\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    L13\n  nopl   (%rax)\nL14:\n  cmp    $0x29,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jle    L12\nL13:\n  movzbl 0x0(%rbp,%rcx,1),%esi\n  cmp    $0x28,%sil\n  jne    L14\n  add    $0x1,%eax\n  test   %eax,%eax\n  cmovs  %edi,%edx\n  add    $0x1,%rcx\n  cmp    %ecx,%r12d\n  jg     L13\nL12:\n  test   %eax,%eax\n  jne    L15\n  and    $0x1,%edx\n  je     L15\nL17:\n  add    $0x8,%rsp\n  lea    D0(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax,%rax,1)\nL15:\n  add    $0x8,%rsp\n  lea    D1(%rip),%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %edx,%edx\n  mov    $0x1,%ecx\n  test   %eax,%eax\n  jg     L16\n  jmp    L17\n  nopl   0x0(%rax)\nL4:\n  test   %edx,%edx\n  jne    L18\n  and    $0x1,%ecx\n  lea    D0(%rip),%rax\n  jne    L19\nL18:\n  xor    %eax,%eax\n  mov    $0x1,%edx\n  jmp    L20",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3570,
                    3396,
                    3322
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3377
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4832
            },
            "L1": {
                "label": "L1",
                "addr": 4493
            },
            "L2": {
                "label": "L2",
                "addr": 4520
            },
            "L3": {
                "label": "L3",
                "addr": 4464
            },
            "L4": {
                "label": "L4",
                "addr": 4856
            },
            "L5": {
                "label": "L5",
                "addr": 4581
            },
            "L6": {
                "label": "L6",
                "addr": 4608
            },
            "L7": {
                "label": "L7",
                "addr": 4552
            },
            "L8": {
                "label": "L8",
                "addr": 4640
            },
            "L9": {
                "label": "L9",
                "addr": 4681
            },
            "L10": {
                "label": "L10",
                "addr": 4706
            },
            "L11": {
                "label": "L11",
                "addr": 4656
            },
            "L12": {
                "label": "L12",
                "addr": 4776
            },
            "L13": {
                "label": "L13",
                "addr": 4748
            },
            "L14": {
                "label": "L14",
                "addr": 4720
            },
            "L15": {
                "label": "L15",
                "addr": 4808
            },
            "L16": {
                "label": "L16",
                "addr": 4528
            },
            "L17": {
                "label": "L17",
                "addr": 4785
            },
            "L18": {
                "label": "L18",
                "addr": 4876
            },
            "L19": {
                "label": "L19",
                "addr": 4624
            },
            "L20": {
                "label": "L20",
                "addr": 4711
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "596573004e6f00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Yes\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"No\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 120,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11dc <func0+0xe3>\n  movl   $0x0,-0xc(%rbp)\n  jmp    11c6 <func0+0xcd>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    11c2 <func0+0xc9>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0x1c(%rbp),%eax\n  sub    -0x10(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     1127 <func0+0x2e>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x10(%rbp)\n  jl     111b <func0+0x22>\n  movl   $0x0,-0x8(%rbp)\n  jmp    122f <func0+0x136>\n  mov    -0x1c(%rbp),%eax\n  sub    -0x20(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     11f4 <func0+0xfb>\n  nop\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %edx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL4:\n  movl   $0x0,-0xc(%rbp)\n  jmp    L1\nL3:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L2\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0xc(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL1:\n  mov    -0x1c(%rbp),%eax\n  sub    -0x10(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     L3\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x10(%rbp)\n  jl     L4\n  movl   $0x0,-0x8(%rbp)\n  jmp    L5\nL6:\n  mov    -0x1c(%rbp),%eax\n  sub    -0x20(%rbp),%eax\n  mov    %eax,%edx\n  mov    -0x8(%rbp),%eax\n  add    %edx,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\nL5:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jl     L6\n  nop\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4572
            },
            "L1": {
                "label": "L1",
                "addr": 4550
            },
            "L2": {
                "label": "L2",
                "addr": 4546
            },
            "L3": {
                "label": "L3",
                "addr": 4391
            },
            "L4": {
                "label": "L4",
                "addr": 4379
            },
            "L5": {
                "label": "L5",
                "addr": 4655
            },
            "L6": {
                "label": "L6",
                "addr": 4596
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 120,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%r8\n  mov    %esi,%r10d\n  mov    %edx,%ebx\n  mov    %rcx,%r9\n  lea    -0x1(%rsi),%edi\n  test   %edi,%edi\n  jle    1144 <func0+0x4b>\n  lea    0x4(%r8),%r11\n  jmp    1134 <func0+0x3b>\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     112f <func0+0x36>\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    1116 <func0+0x1d>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    1116 <func0+0x1d>\n  sub    $0x1,%edi\n  je     1144 <func0+0x4b>\n  test   %edi,%edi\n  jle    112f <func0+0x36>\n  mov    %r8,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r11,%rdx,4),%rsi\n  jmp    111f <func0+0x26>\n  test   %ebx,%ebx\n  jle    116c <func0+0x73>\n  mov    %ebx,%esi\n  movslq %r10d,%r10\n  movslq %ebx,%rbx\n  sub    %rbx,%r10\n  lea    (%r8,%r10,4),%rcx\n  mov    $0x0,%eax\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r9,%rax,4)\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    115c <func0+0x63>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%r8\n  mov    %esi,%r10d\n  mov    %edx,%ebx\n  mov    %rcx,%r9\n  lea    -0x1(%rsi),%edi\n  test   %edi,%edi\n  jle    L0\n  lea    0x4(%r8),%r11\n  jmp    L1\nL3:\n  add    $0x4,%rax\n  cmp    %rsi,%rax\n  je     L2\nL4:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L3\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  jmp    L3\nL2:\n  sub    $0x1,%edi\n  je     L0\nL1:\n  test   %edi,%edi\n  jle    L2\n  mov    %r8,%rax\n  lea    -0x1(%rdi),%edx\n  lea    (%r11,%rdx,4),%rsi\n  jmp    L4\nL0:\n  test   %ebx,%ebx\n  jle    L5\n  mov    %ebx,%esi\n  movslq %r10d,%r10\n  movslq %ebx,%rbx\n  sub    %rbx,%r10\n  lea    (%r8,%r10,4),%rcx\n  mov    $0x0,%eax\nL6:\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r9,%rax,4)\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    L6\nL5:\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4420
            },
            "L1": {
                "label": "L1",
                "addr": 4404
            },
            "L2": {
                "label": "L2",
                "addr": 4399
            },
            "L3": {
                "label": "L3",
                "addr": 4374
            },
            "L4": {
                "label": "L4",
                "addr": 4383
            },
            "L5": {
                "label": "L5",
                "addr": 4460
            },
            "L6": {
                "label": "L6",
                "addr": 4444
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 120,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edx,%ebx\n  lea    -0x1(%rsi),%edx\n  mov    %rdi,%r8\n  mov    %esi,%r11d\n  mov    %rcx,%r9\n  test   %edx,%edx\n  jle    114d <func0+0x4d>\n  lea    0x4(%rdi),%r10\n  nopl   0x0(%rax,%rax,1)\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r10,%rdx,4),%rsi\n  nopl   (%rax)\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    113e <func0+0x3e>\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    1130 <func0+0x30>\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    1120 <func0+0x20>\n  test   %ebx,%ebx\n  jle    1170 <func0+0x70>\n  sub    %ebx,%r11d\n  movslq %ebx,%rsi\n  movslq %r11d,%rax\n  lea    (%r8,%rax,4),%rcx\n  xor    %eax,%eax\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r9,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    1160 <func0+0x60>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edx,%ebx\n  lea    -0x1(%rsi),%edx\n  mov    %rdi,%r8\n  mov    %esi,%r11d\n  mov    %rcx,%r9\n  test   %edx,%edx\n  jle    L0\n  lea    0x4(%rdi),%r10\n  nopl   0x0(%rax,%rax,1)\nL3:\n  sub    $0x1,%edx\n  mov    %r8,%rax\n  mov    %rdx,%rdi\n  lea    (%r10,%rdx,4),%rsi\n  nopl   (%rax)\nL2:\n  mov    (%rax),%edx\n  mov    0x4(%rax),%ecx\n  cmp    %ecx,%edx\n  jle    L1\n  mov    %ecx,(%rax)\n  mov    %edx,0x4(%rax)\nL1:\n  add    $0x4,%rax\n  cmp    %rax,%rsi\n  jne    L2\n  mov    %edi,%edx\n  test   %edi,%edi\n  jne    L3\nL0:\n  test   %ebx,%ebx\n  jle    L4\n  sub    %ebx,%r11d\n  movslq %ebx,%rsi\n  movslq %r11d,%rax\n  lea    (%r8,%rax,4),%rcx\n  xor    %eax,%eax\nL5:\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r9,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  jne    L5\nL4:\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4429
            },
            "L1": {
                "label": "L1",
                "addr": 4414
            },
            "L2": {
                "label": "L2",
                "addr": 4400
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4464
            },
            "L5": {
                "label": "L5",
                "addr": 4448
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 120,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* arr, int arr_size, int k, int* out) {\n    for (int i = 0; i < arr_size - 1; i++) {\n        for (int j = 0; j < arr_size - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < k; i++) {\n        out[i] = arr[arr_size - k + i];\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int arr1[] = {-3, -4, 5};\n    int out1[3];\n    func0(arr1, 3, 3, out1);\n    int expected1[] = {-4, -3, 5};\n    assert(issame(out1, expected1, 3));\n\n    int arr2[] = {4, -4, 4};\n    int out2[2];\n    func0(arr2, 3, 2, out2);\n    int expected2[] = {4, 4};\n    assert(issame(out2, expected2, 2));\n\n    int arr3[] = {-3, 2, 1, 2, -1, -2, 1};\n    int out3[1];\n    func0(arr3, 7, 1, out3);\n    int expected3[] = {2};\n    assert(issame(out3, expected3, 1));\n\n    int arr4[] = {123, -123, 20, 0, 1, 2, -3};\n    int out4[3];\n    func0(arr4, 7, 3, out4);\n    int expected4[] = {2, 20, 123};\n    assert(issame(out4, expected4, 3));\n\n    int arr5[] = {-123, 20, 0, 1, 2, -3};\n    int out5[4];\n    func0(arr5, 6, 4, out5);\n    int expected5[] = {0, 1, 2, 20};\n    assert(issame(out5, expected5, 4));\n\n    int arr6[] = {5, 15, 0, 3, -13, -8, 0};\n    int out6[7];\n    func0(arr6, 7, 7, out6);\n    int expected6[] = {-13, -8, 0, 0, 3, 5, 15};\n    assert(issame(out6, expected6, 7));\n\n    int arr7[] = {-1, 0, 2, 5, 3, -10};\n    int out7[2];\n    func0(arr7, 6, 2, out7);\n    int expected7[] = {3, 5};\n    assert(issame(out7, expected7, 2));\n\n    int arr8[] = {1, 0, 5, -7};\n    int out8[1];\n    func0(arr8, 4, 1, out8);\n    int expected8[] = {5};\n    assert(issame(out8, expected8, 1));\n\n    int arr9[] = {4, -4};\n    int out9[2];\n    func0(arr9, 2, 2, out9);\n    int expected9[] = {-4, 4};\n    assert(issame(out9, expected9, 2));\n\n    int arr10[] = {-10, 10};\n    int out10[2];\n    func0(arr10, 2, 2, out10);\n    int expected10[] = {-10, 10};\n    assert(issame(out10, expected10, 2));\n\n    int arr11[] = {1, 2, 3, -23, 243, -400, 0};\n    int out11[0];\n    func0(arr11, 7, 0, out11); // Empty output expected\n    int expected11[] = {}; // Empty array\n    assert(issame(out11, expected11, 0));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movslq %esi,%r11\n  push   %rbx\n  mov    %rdi,%r8\n  mov    %edx,%r9d\n  lea    -0x1(%r11),%eax\n  mov    %rcx,%r10\n  test   %eax,%eax\n  jle    115d <func0+0x5d>\n  lea    0x4(%rdi),%rbx\n  nopl   (%rax)\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%rbx,%rax,4),%rsi\n  nopl   (%rax)\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%eax\n  movd   %xmm2,%ecx\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jge    114e <func0+0x4e>\n  movq   %xmm1,(%rdx)\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    1130 <func0+0x30>\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    1120 <func0+0x20>\n  test   %r9d,%r9d\n  jle    1212 <func0+0x112>\n  movslq %r9d,%rax\n  mov    %r11d,%esi\n  mov    %r10,%rdx\n  sub    %rax,%r11\n  sub    %r9d,%esi\n  lea    0x4(,%r11,4),%rax\n  lea    (%r8,%rax,1),%rcx\n  sub    %rcx,%rdx\n  cmp    $0x8,%rdx\n  jbe    1214 <func0+0x114>\n  lea    -0x1(%r9),%edx\n  cmp    $0x2,%edx\n  jbe    1214 <func0+0x114>\n  mov    %r9d,%edx\n  lea    -0x4(%r8,%rax,1),%rcx\n  xor    %eax,%eax\n  shr    $0x2,%edx\n  shl    $0x4,%rdx\n  nopl   0x0(%rax,%rax,1)\n  movdqu (%rcx,%rax,1),%xmm3\n  movups %xmm3,(%r10,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rdx\n  jne    11b0 <func0+0xb0>\n  mov    %r9d,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%r9b\n  je     1212 <func0+0x112>\n  lea    (%rsi,%rax,1),%edx\n  mov    %eax,%ecx\n  movslq %edx,%rdx\n  lea    0x0(,%rcx,4),%rdi\n  mov    (%r8,%rdx,4),%edx\n  mov    %edx,(%r10,%rcx,4)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%r9d\n  jle    1212 <func0+0x112>\n  add    %esi,%edx\n  add    $0x2,%eax\n  movslq %edx,%rdx\n  mov    (%r8,%rdx,4),%edx\n  mov    %edx,0x4(%r10,%rdi,1)\n  cmp    %eax,%r9d\n  jle    1212 <func0+0x112>\n  add    %esi,%eax\n  cltq\n  mov    (%r8,%rax,4),%eax\n  mov    %eax,0x8(%r10,%rdi,1)\n  pop    %rbx\n  ret\n  mov    %r9d,%r9d\n  lea    (%r8,%r11,4),%rcx\n  xor    %eax,%eax\n  nopl   (%rax)\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r10,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r9\n  jne    1220 <func0+0x120>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movslq %esi,%r11\n  push   %rbx\n  mov    %rdi,%r8\n  mov    %edx,%r9d\n  lea    -0x1(%r11),%eax\n  mov    %rcx,%r10\n  test   %eax,%eax\n  jle    L0\n  lea    0x4(%rdi),%rbx\n  nopl   (%rax)\nL3:\n  sub    $0x1,%eax\n  mov    %r8,%rdx\n  mov    %rax,%rdi\n  lea    (%rbx,%rax,4),%rsi\n  nopl   (%rax)\nL2:\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%eax\n  movd   %xmm2,%ecx\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%ecx\n  jge    L1\n  movq   %xmm1,(%rdx)\nL1:\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  jne    L2\n  mov    %edi,%eax\n  test   %edi,%edi\n  jne    L3\nL0:\n  test   %r9d,%r9d\n  jle    L4\n  movslq %r9d,%rax\n  mov    %r11d,%esi\n  mov    %r10,%rdx\n  sub    %rax,%r11\n  sub    %r9d,%esi\n  lea    0x4(,%r11,4),%rax\n  lea    (%r8,%rax,1),%rcx\n  sub    %rcx,%rdx\n  cmp    $0x8,%rdx\n  jbe    L5\n  lea    -0x1(%r9),%edx\n  cmp    $0x2,%edx\n  jbe    L5\n  mov    %r9d,%edx\n  lea    -0x4(%r8,%rax,1),%rcx\n  xor    %eax,%eax\n  shr    $0x2,%edx\n  shl    $0x4,%rdx\n  nopl   0x0(%rax,%rax,1)\nL6:\n  movdqu (%rcx,%rax,1),%xmm3\n  movups %xmm3,(%r10,%rax,1)\n  add    $0x10,%rax\n  cmp    %rax,%rdx\n  jne    L6\n  mov    %r9d,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%r9b\n  je     L4\n  lea    (%rsi,%rax,1),%edx\n  mov    %eax,%ecx\n  movslq %edx,%rdx\n  lea    0x0(,%rcx,4),%rdi\n  mov    (%r8,%rdx,4),%edx\n  mov    %edx,(%r10,%rcx,4)\n  lea    0x1(%rax),%edx\n  cmp    %edx,%r9d\n  jle    L4\n  add    %esi,%edx\n  add    $0x2,%eax\n  movslq %edx,%rdx\n  mov    (%r8,%rdx,4),%edx\n  mov    %edx,0x4(%r10,%rdi,1)\n  cmp    %eax,%r9d\n  jle    L4\n  add    %esi,%eax\n  cltq\n  mov    (%r8,%rax,4),%eax\n  mov    %eax,0x8(%r10,%rdi,1)\nL4:\n  pop    %rbx\n  ret\nL5:\n  mov    %r9d,%r9d\n  lea    (%r8,%r11,4),%rcx\n  xor    %eax,%eax\n  nopl   (%rax)\nL7:\n  mov    (%rcx,%rax,4),%edx\n  mov    %edx,(%r10,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%r9\n  jne    L7\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4445
            },
            "L1": {
                "label": "L1",
                "addr": 4430
            },
            "L2": {
                "label": "L2",
                "addr": 4400
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4626
            },
            "L5": {
                "label": "L5",
                "addr": 4628
            },
            "L6": {
                "label": "L6",
                "addr": 4528
            },
            "L7": {
                "label": "L7",
                "addr": 4640
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 121,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    115f <func0+0x66>\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    115b <func0+0x62>\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jg     1118 <func0+0x1f>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  add    %eax,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jg     L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4447
            },
            "L1": {
                "label": "L1",
                "addr": 4443
            },
            "L2": {
                "label": "L2",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 121,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1138 <func0+0x3f>\n  mov    %rdi,%rcx\n  sub    $0x1,%esi\n  shr    %esi\n  mov    %esi,%esi\n  lea    0x8(%rdi,%rsi,8),%r8\n  mov    $0x0,%esi\n  mov    (%rcx),%eax\n  mov    %eax,%edi\n  shr    $0x1f,%edi\n  lea    (%rax,%rdi,1),%edx\n  and    $0x1,%edx\n  sub    %edi,%edx\n  add    %esi,%eax\n  cmp    $0x1,%edx\n  cmove  %eax,%esi\n  add    $0x8,%rcx\n  cmp    %r8,%rcx\n  jne    1115 <func0+0x1c>\n  mov    %esi,%eax\n  ret\n  mov    $0x0,%esi\n  jmp    1135 <func0+0x3c>",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rcx\n  sub    $0x1,%esi\n  shr    %esi\n  mov    %esi,%esi\n  lea    0x8(%rdi,%rsi,8),%r8\n  mov    $0x0,%esi\nL1:\n  mov    (%rcx),%eax\n  mov    %eax,%edi\n  shr    $0x1f,%edi\n  lea    (%rax,%rdi,1),%edx\n  and    $0x1,%edx\n  sub    %edi,%edx\n  add    %esi,%eax\n  cmp    $0x1,%edx\n  cmove  %eax,%esi\n  add    $0x8,%rcx\n  cmp    %r8,%rcx\n  jne    L1\nL2:\n  mov    %esi,%eax\n  ret\nL0:\n  mov    $0x0,%esi\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4373
            },
            "L2": {
                "label": "L2",
                "addr": 4405
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 121,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1140 <func0+0x40>\n  sub    $0x1,%esi\n  xor    %r8d,%r8d\n  shr    %esi\n  lea    0x8(%rdi,%rsi,8),%rsi\n  nopl   (%rax)\n  mov    (%rdi),%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rax,%rcx,1),%edx\n  add    %r8d,%eax\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  cmove  %eax,%r8d\n  add    $0x8,%rdi\n  cmp    %rsi,%rdi\n  jne    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret\n  xchg   %ax,%ax\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  sub    $0x1,%esi\n  xor    %r8d,%r8d\n  shr    %esi\n  lea    0x8(%rdi,%rsi,8),%rsi\n  nopl   (%rax)\nL1:\n  mov    (%rdi),%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rax,%rcx,1),%edx\n  add    %r8d,%eax\n  and    $0x1,%edx\n  sub    %ecx,%edx\n  cmp    $0x1,%edx\n  cmove  %eax,%r8d\n  add    $0x8,%rdi\n  cmp    %rsi,%rdi\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  xchg   %ax,%ax\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 121,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i * 2 < size; i++)\n        if (lst[i * 2] % 2 == 1) sum += lst[i * 2];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {5, 8, 7, 1};\n    assert(func0(test1, 4) == 12);\n\n    int test2[] = {3, 3, 3, 3, 3};\n    assert(func0(test2, 5) == 9);\n\n    int test3[] = {30, 13, 24, 321};\n    assert(func0(test3, 4) == 0);\n\n    int test4[] = {5, 9};\n    assert(func0(test4, 2) == 5);\n\n    int test5[] = {2, 4, 8};\n    assert(func0(test5, 3) == 0);\n\n    int test6[] = {30, 13, 23, 32};\n    assert(func0(test6, 4) == 23);\n\n    int test7[] = {3, 13, 2, 9};\n    assert(func0(test7, 4) == 3);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  test   %esi,%esi\n  jle    1240 <func0+0x140>\n  lea    -0x1(%rsi),%edx\n  cmp    $0x7,%edx\n  jbe    1243 <func0+0x143>\n  shr    $0x3,%edx\n  mov    %rdi,%rax\n  movdqa 0xed7(%rip),%xmm4        # 2000 <_fini+0xdb0>\n  pxor   %xmm2,%xmm2\n  lea    -0x1(%rdx),%edi\n  shl    $0x5,%rdi\n  lea    0x20(%rcx,%rdi,1),%rdi\n  nopl   0x0(%rax)\n  movdqu (%rax),%xmm1\n  movdqu 0x10(%rax),%xmm5\n  add    $0x20,%rax\n  shufps $0x88,%xmm5,%xmm1\n  movdqa %xmm1,%xmm3\n  movdqa %xmm1,%xmm0\n  psrld  $0x1f,%xmm3\n  paddd  %xmm3,%xmm0\n  pand   %xmm4,%xmm0\n  psubd  %xmm3,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pand   %xmm1,%xmm0\n  paddd  %xmm0,%xmm2\n  cmp    %rdi,%rax\n  jne    1140 <func0+0x40>\n  movdqa %xmm2,%xmm0\n  lea    0x0(,%rdx,4),%r9d\n  shl    $0x3,%edx\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%eax\n  movslq %edx,%rdx\n  mov    (%rcx,%rdx,4),%edx\n  mov    %edx,%r8d\n  shr    $0x1f,%r8d\n  lea    (%rdx,%r8,1),%edi\n  add    %eax,%edx\n  and    $0x1,%edi\n  sub    %r8d,%edi\n  cmp    $0x1,%edi\n  cmove  %edx,%eax\n  lea    0x2(%r9,%r9,1),%edx\n  cmp    %esi,%edx\n  jge    1242 <func0+0x142>\n  movslq %edx,%rdi\n  lea    0x0(,%rdi,4),%r9\n  mov    (%rcx,%rdi,4),%edi\n  mov    %edi,%r10d\n  shr    $0x1f,%r10d\n  lea    (%rdi,%r10,1),%r8d\n  add    %eax,%edi\n  and    $0x1,%r8d\n  sub    %r10d,%r8d\n  cmp    $0x1,%r8d\n  cmove  %edi,%eax\n  lea    0x2(%rdx),%edi\n  cmp    %edi,%esi\n  jle    1242 <func0+0x142>\n  mov    0x8(%rcx,%r9,1),%edi\n  mov    %edi,%r10d\n  shr    $0x1f,%r10d\n  lea    (%rdi,%r10,1),%r8d\n  add    %eax,%edi\n  and    $0x1,%r8d\n  sub    %r10d,%r8d\n  cmp    $0x1,%r8d\n  cmove  %edi,%eax\n  add    $0x4,%edx\n  cmp    %edx,%esi\n  jle    1242 <func0+0x142>\n  mov    0x10(%rcx,%r9,1),%edx\n  mov    %edx,%esi\n  shr    $0x1f,%esi\n  lea    (%rdx,%rsi,1),%ecx\n  add    %eax,%edx\n  and    $0x1,%ecx\n  sub    %esi,%ecx\n  cmp    $0x1,%ecx\n  cmove  %edx,%eax\n  ret\n  xchg   %ax,%ax\n  xor    %eax,%eax\n  ret\n  xor    %r9d,%r9d\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    11a4 <func0+0xa4>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%edx\n  cmp    $0x7,%edx\n  jbe    L1\n  shr    $0x3,%edx\n  mov    %rdi,%rax\n  movdqa D0(%rip),%xmm4\n  pxor   %xmm2,%xmm2\n  lea    -0x1(%rdx),%edi\n  shl    $0x5,%rdi\n  lea    0x20(%rcx,%rdi,1),%rdi\n  nopl   0x0(%rax)\nL2:\n  movdqu (%rax),%xmm1\n  movdqu 0x10(%rax),%xmm5\n  add    $0x20,%rax\n  shufps $0x88,%xmm5,%xmm1\n  movdqa %xmm1,%xmm3\n  movdqa %xmm1,%xmm0\n  psrld  $0x1f,%xmm3\n  paddd  %xmm3,%xmm0\n  pand   %xmm4,%xmm0\n  psubd  %xmm3,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pand   %xmm1,%xmm0\n  paddd  %xmm0,%xmm2\n  cmp    %rdi,%rax\n  jne    L2\n  movdqa %xmm2,%xmm0\n  lea    0x0(,%rdx,4),%r9d\n  shl    $0x3,%edx\n  psrldq $0x8,%xmm0\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%eax\nL4:\n  movslq %edx,%rdx\n  mov    (%rcx,%rdx,4),%edx\n  mov    %edx,%r8d\n  shr    $0x1f,%r8d\n  lea    (%rdx,%r8,1),%edi\n  add    %eax,%edx\n  and    $0x1,%edi\n  sub    %r8d,%edi\n  cmp    $0x1,%edi\n  cmove  %edx,%eax\n  lea    0x2(%r9,%r9,1),%edx\n  cmp    %esi,%edx\n  jge    L3\n  movslq %edx,%rdi\n  lea    0x0(,%rdi,4),%r9\n  mov    (%rcx,%rdi,4),%edi\n  mov    %edi,%r10d\n  shr    $0x1f,%r10d\n  lea    (%rdi,%r10,1),%r8d\n  add    %eax,%edi\n  and    $0x1,%r8d\n  sub    %r10d,%r8d\n  cmp    $0x1,%r8d\n  cmove  %edi,%eax\n  lea    0x2(%rdx),%edi\n  cmp    %edi,%esi\n  jle    L3\n  mov    0x8(%rcx,%r9,1),%edi\n  mov    %edi,%r10d\n  shr    $0x1f,%r10d\n  lea    (%rdi,%r10,1),%r8d\n  add    %eax,%edi\n  and    $0x1,%r8d\n  sub    %r10d,%r8d\n  cmp    $0x1,%r8d\n  cmove  %edi,%eax\n  add    $0x4,%edx\n  cmp    %edx,%esi\n  jle    L3\n  mov    0x10(%rcx,%r9,1),%edx\n  mov    %edx,%esi\n  shr    $0x1f,%esi\n  lea    (%rdx,%rsi,1),%ecx\n  add    %eax,%edx\n  and    $0x1,%ecx\n  sub    %esi,%ecx\n  cmp    $0x1,%ecx\n  cmove  %edx,%eax\n  ret\n  xchg   %ax,%ax\nL0:\n  xor    %eax,%eax\nL3:\n  ret\nL1:\n  xor    %r9d,%r9d\n  xor    %eax,%eax\n  xor    %edx,%edx\n  jmp    L4",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3799
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4672
            },
            "L1": {
                "label": "L1",
                "addr": 4675
            },
            "L2": {
                "label": "L2",
                "addr": 4416
            },
            "L3": {
                "label": "L3",
                "addr": 4674
            },
            "L4": {
                "label": "L4",
                "addr": 4516
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "01000000010000000100000001000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 122,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    116b <func0+0x72>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0xffffff9d,%eax\n  jl     1167 <func0+0x6e>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x63,%eax\n  jg     1167 <func0+0x6e>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1118 <func0+0x1f>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0xffffff9d,%eax\n  jl     L1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x63,%eax\n  jg     L1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4459
            },
            "L1": {
                "label": "L1",
                "addr": 4455
            },
            "L2": {
                "label": "L2",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 122,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    112d <func0+0x34>\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rdi\n  mov    $0x0,%ecx\n  mov    (%rdx),%eax\n  lea    0x63(%rax),%esi\n  add    %ecx,%eax\n  cmp    $0xc7,%esi\n  cmovb  %eax,%ecx\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    1111 <func0+0x18>\n  mov    %ecx,%eax\n  ret\n  mov    $0x0,%ecx\n  jmp    112a <func0+0x31>",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rdi\n  mov    $0x0,%ecx\nL1:\n  mov    (%rdx),%eax\n  lea    0x63(%rax),%esi\n  add    %ecx,%eax\n  cmp    $0xc7,%esi\n  cmovb  %eax,%ecx\n  add    $0x4,%rdx\n  cmp    %rdi,%rdx\n  jne    L1\nL2:\n  mov    %ecx,%eax\n  ret\nL0:\n  mov    $0x0,%ecx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4397
            },
            "L1": {
                "label": "L1",
                "addr": 4369
            },
            "L2": {
                "label": "L2",
                "addr": 4394
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 122,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1140 <func0+0x40>\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%rcx\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdi),%eax\n  lea    0x63(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0xc7,%edx\n  cmovb  %eax,%r8d\n  add    $0x4,%rdi\n  cmp    %rcx,%rdi\n  jne    1118 <func0+0x18>\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%rcx\n  nopl   0x0(%rax,%rax,1)\nL1:\n  mov    (%rdi),%eax\n  lea    0x63(%rax),%edx\n  add    %r8d,%eax\n  cmp    $0xc7,%edx\n  cmovb  %eax,%r8d\n  add    $0x4,%rdi\n  cmp    %rcx,%rdi\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 122,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int arr[], int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++)\n        if (arr[i] >= -99 && arr[i] <= 99)\n            sum += arr[i];\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int test1[] = {1, -2, -3, 41, 57, 76, 87, 88, 99};\n    assert(func0(test1, 3) == -4);\n\n    int test2[] = {111, 121, 3, 4000, 5, 6};\n    assert(func0(test2, 2) == 0);\n\n    int test3[] = {11, 21, 3, 90, 5, 6, 7, 8, 9};\n    assert(func0(test3, 4) == 125);\n\n    int test4[] = {111, 21, 3, 4000, 5, 6, 7, 8, 9};\n    assert(func0(test4, 4) == 24);\n    \n    int test5[] = {1};\n    assert(func0(test5, 1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  mov    %esi,%edx\n  test   %esi,%esi\n  jle    11f8 <func0+0xf8>\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    1201 <func0+0x101>\n  shr    $0x2,%esi\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  movdqa 0xef1(%rip),%xmm3        # 2020 <_fini+0xe18>\n  movdqa 0xed9(%rip),%xmm2        # 2010 <_fini+0xe08>\n  sub    $0x1,%esi\n  movdqa 0xebe(%rip),%xmm4        # 2000 <_fini+0xdf8>\n  shl    $0x4,%rsi\n  lea    0x10(%rdi,%rsi,1),%rsi\n  psubd  %xmm3,%xmm2\n  nop\n  movdqu (%rax),%xmm0\n  movdqu (%rax),%xmm5\n  add    $0x10,%rax\n  paddd  %xmm4,%xmm0\n  psubd  %xmm3,%xmm0\n  pcmpgtd %xmm2,%xmm0\n  pandn  %xmm5,%xmm0\n  paddd  %xmm0,%xmm1\n  cmp    %rax,%rsi\n  jne    1150 <func0+0x50>\n  movdqa %xmm1,%xmm0\n  mov    %edx,%esi\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%esi\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%dl\n  je     1200 <func0+0x100>\n  movslq %esi,%rdi\n  lea    0x0(,%rdi,4),%r8\n  mov    (%rcx,%rdi,4),%edi\n  lea    0x63(%rdi),%r9d\n  add    %eax,%edi\n  cmp    $0xc7,%r9d\n  cmovb  %edi,%eax\n  lea    0x1(%rsi),%edi\n  cmp    %edx,%edi\n  jge    11fa <func0+0xfa>\n  mov    0x4(%rcx,%r8,1),%edi\n  lea    0x63(%rdi),%r9d\n  add    %eax,%edi\n  cmp    $0xc7,%r9d\n  cmovb  %edi,%eax\n  add    $0x2,%esi\n  cmp    %edx,%esi\n  jge    11fa <func0+0xfa>\n  mov    0x8(%rcx,%r8,1),%edx\n  lea    0x63(%rdx),%ecx\n  add    %eax,%edx\n  cmp    $0xc7,%ecx\n  cmovb  %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  ret\n  xor    %esi,%esi\n  xor    %eax,%eax\n  jmp    119d <func0+0x9d>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%rcx\n  mov    %esi,%edx\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  cmp    $0x2,%eax\n  jbe    L1\n  shr    $0x2,%esi\n  mov    %rdi,%rax\n  pxor   %xmm1,%xmm1\n  movdqa D0(%rip),%xmm3\n  movdqa D1(%rip),%xmm2\n  sub    $0x1,%esi\n  movdqa D2(%rip),%xmm4\n  shl    $0x4,%rsi\n  lea    0x10(%rdi,%rsi,1),%rsi\n  psubd  %xmm3,%xmm2\n  nop\nL2:\n  movdqu (%rax),%xmm0\n  movdqu (%rax),%xmm5\n  add    $0x10,%rax\n  paddd  %xmm4,%xmm0\n  psubd  %xmm3,%xmm0\n  pcmpgtd %xmm2,%xmm0\n  pandn  %xmm5,%xmm0\n  paddd  %xmm0,%xmm1\n  cmp    %rax,%rsi\n  jne    L2\n  movdqa %xmm1,%xmm0\n  mov    %edx,%esi\n  psrldq $0x8,%xmm0\n  and    $0xfffffffc,%esi\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm1\n  movd   %xmm1,%eax\n  test   $0x3,%dl\n  je     L3\nL5:\n  movslq %esi,%rdi\n  lea    0x0(,%rdi,4),%r8\n  mov    (%rcx,%rdi,4),%edi\n  lea    0x63(%rdi),%r9d\n  add    %eax,%edi\n  cmp    $0xc7,%r9d\n  cmovb  %edi,%eax\n  lea    0x1(%rsi),%edi\n  cmp    %edx,%edi\n  jge    L4\n  mov    0x4(%rcx,%r8,1),%edi\n  lea    0x63(%rdi),%r9d\n  add    %eax,%edi\n  cmp    $0xc7,%r9d\n  cmovb  %edi,%eax\n  add    $0x2,%esi\n  cmp    %edx,%esi\n  jge    L4\n  mov    0x8(%rcx,%r8,1),%edx\n  lea    0x63(%rdx),%ecx\n  add    %eax,%edx\n  cmp    $0xc7,%ecx\n  cmovb  %edx,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\nL4:\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  ret\nL1:\n  xor    %esi,%esi\n  xor    %eax,%eax\n  jmp    L5",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8224,
                "bias": [
                    3825
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3801
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8192,
                "bias": [
                    3774
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4600
            },
            "L1": {
                "label": "L1",
                "addr": 4609
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4608
            },
            "L4": {
                "label": "L4",
                "addr": 4602
            },
            "L5": {
                "label": "L5",
                "addr": 4509
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "63000000630000006300000063000000c6000000c6000000c6000000c600000000000080000000800000008000000080",
        "rodata_parsed": {
            "func0": {
                "0x2020": {
                    "type": "byte[16]",
                    "value": [
                        0,
                        0,
                        0,
                        128,
                        0,
                        0,
                        0,
                        128,
                        0,
                        0,
                        0,
                        128,
                        0,
                        0,
                        0,
                        128
                    ]
                },
                "0x2010": {
                    "type": "byte[16]",
                    "value": [
                        198,
                        0,
                        0,
                        0,
                        198,
                        0,
                        0,
                        0,
                        198,
                        0,
                        0,
                        0,
                        198,
                        0,
                        0,
                        0
                    ]
                },
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        99,
                        0,
                        0,
                        0,
                        99,
                        0,
                        0,
                        0,
                        99,
                        0,
                        0,
                        0,
                        99,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 123,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0xa,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x1,(%rax)\n  mov    -0x20(%rbp),%rax\n  movl   $0x1,(%rax)\n  jmp    11d6 <func0+0xbd>\n  mov    -0x14(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    11c7 <func0+0xae>\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jg     1191 <func0+0x78>\n  shll   -0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1050 <realloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x14(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  add    $0x1,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    11d6 <func0+0xbd>\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x14(%rbp)\n  cmpl   $0x1,-0x14(%rbp)\n  jne    1150 <func0+0x37>\n  movl   $0x1,-0xc(%rbp)\n  jmp    1287 <func0+0x16e>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    1245 <func0+0x12c>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  subl   $0x1,-0x8(%rbp)\n  cmpl   $0x0,-0x8(%rbp)\n  js     1266 <func0+0x14d>\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x4(%rbp)\n  jl     1210 <func0+0xf7>\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     11ec <func0+0xd3>\n  nop\n  nop\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0xa,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x1,(%rax)\n  mov    -0x20(%rbp),%rax\n  movl   $0x1,(%rax)\n  jmp    L0\nL3:\n  mov    -0x14(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x10(%rbp)\n  jg     L2\n  shll   -0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <realloc@plt>\n  mov    %rax,-0x20(%rbp)\nL2:\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x14(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x14(%rbp),%edx\n  mov    %edx,%eax\n  add    %eax,%eax\n  add    %edx,%eax\n  add    $0x1,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    L0\nL1:\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,-0x14(%rbp)\nL0:\n  cmpl   $0x1,-0x14(%rbp)\n  jne    L3\n  movl   $0x1,-0xc(%rbp)\n  jmp    L4\nL8:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0xc(%rbp),%eax\n  sub    $0x1,%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    L5\nL7:\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  subl   $0x1,-0x8(%rbp)\nL5:\n  cmpl   $0x0,-0x8(%rbp)\n  js     L6\n  mov    -0x8(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x4(%rbp)\n  jl     L7\nL6:\n  mov    -0x8(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x4(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0xc(%rbp)\nL4:\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jl     L8\n  nop\n  nop\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4566
            },
            "L1": {
                "label": "L1",
                "addr": 4551
            },
            "L2": {
                "label": "L2",
                "addr": 4497
            },
            "L3": {
                "label": "L3",
                "addr": 4432
            },
            "L4": {
                "label": "L4",
                "addr": 4743
            },
            "L5": {
                "label": "L5",
                "addr": 4677
            },
            "L6": {
                "label": "L6",
                "addr": 4710
            },
            "L7": {
                "label": "L7",
                "addr": 4624
            },
            "L8": {
                "label": "L8",
                "addr": 4588
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 123,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rsi,%r8\n  mov    %rdx,%rbx\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%edi\n  je     1194 <func0+0x7b>\n  mov    %edi,%ebp\n  mov    $0xa,%r12d\n  jmp    115d <func0+0x44>\n  cmp    %r12d,(%rbx)\n  jge    117d <func0+0x64>\n  mov    (%rbx),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,(%rbx)\n  cltq\n  mov    %ebp,(%r8,%rax,4)\n  lea    0x1(%rbp,%rbp,2),%ebp\n  cmp    $0x1,%ebp\n  je     1194 <func0+0x7b>\n  mov    %ebp,%edx\n  shr    $0x1f,%edx\n  lea    0x0(%rbp,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     1142 <func0+0x29>\n  mov    %ebp,%eax\n  shr    $0x1f,%eax\n  add    %ebp,%eax\n  sar    %eax\n  mov    %eax,%ebp\n  jmp    1158 <func0+0x3f>\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  mov    %r8,%rdi\n  call   1050 <realloc@plt>\n  mov    %rax,%r8\n  jmp    1147 <func0+0x2e>\n  cmpl   $0x1,(%rbx)\n  jle    11de <func0+0xc5>\n  mov    %r8,%r9\n  mov    $0x0,%edi\n  jmp    11ba <func0+0xa1>\n  movslq %edx,%rdx\n  mov    %esi,0x4(%r8,%rdx,4)\n  add    $0x1,%rdi\n  add    $0x4,%r9\n  lea    0x1(%rdi),%eax\n  cmp    %eax,(%rbx)\n  jle    11de <func0+0xc5>\n  mov    0x4(%r9),%esi\n  mov    %edi,%edx\n  mov    %r9,%rax\n  test   %edi,%edi\n  js     11a3 <func0+0x8a>\n  mov    (%rax),%ecx\n  cmp    %esi,%ecx\n  jle    11a3 <func0+0x8a>\n  mov    %ecx,0x4(%rax)\n  sub    $0x1,%edx\n  sub    $0x4,%rax\n  cmp    $0xffffffff,%edx\n  jne    11c7 <func0+0xae>\n  jmp    11a3 <func0+0x8a>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rsi,%r8\n  mov    %rdx,%rbx\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%edi\n  je     L0\n  mov    %edi,%ebp\n  mov    $0xa,%r12d\n  jmp    L1\nL3:\n  cmp    %r12d,(%rbx)\n  jge    L2\nL5:\n  mov    (%rbx),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,(%rbx)\n  cltq\n  mov    %ebp,(%r8,%rax,4)\n  lea    0x1(%rbp,%rbp,2),%ebp\nL4:\n  cmp    $0x1,%ebp\n  je     L0\nL1:\n  mov    %ebp,%edx\n  shr    $0x1f,%edx\n  lea    0x0(%rbp,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  je     L3\n  mov    %ebp,%eax\n  shr    $0x1f,%eax\n  add    %ebp,%eax\n  sar    %eax\n  mov    %eax,%ebp\n  jmp    L4\nL2:\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  mov    %r8,%rdi\n  call   <realloc@plt>\n  mov    %rax,%r8\n  jmp    L5\nL0:\n  cmpl   $0x1,(%rbx)\n  jle    L6\n  mov    %r8,%r9\n  mov    $0x0,%edi\n  jmp    L7\nL8:\n  movslq %edx,%rdx\n  mov    %esi,0x4(%r8,%rdx,4)\n  add    $0x1,%rdi\n  add    $0x4,%r9\n  lea    0x1(%rdi),%eax\n  cmp    %eax,(%rbx)\n  jle    L6\nL7:\n  mov    0x4(%r9),%esi\n  mov    %edi,%edx\n  mov    %r9,%rax\n  test   %edi,%edi\n  js     L8\nL9:\n  mov    (%rax),%ecx\n  cmp    %esi,%ecx\n  jle    L8\n  mov    %ecx,0x4(%rax)\n  sub    $0x1,%edx\n  sub    $0x4,%rax\n  cmp    $0xffffffff,%edx\n  jne    L9\n  jmp    L8\nL6:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4500
            },
            "L1": {
                "label": "L1",
                "addr": 4445
            },
            "L2": {
                "label": "L2",
                "addr": 4477
            },
            "L3": {
                "label": "L3",
                "addr": 4418
            },
            "L4": {
                "label": "L4",
                "addr": 4440
            },
            "L5": {
                "label": "L5",
                "addr": 4423
            },
            "L6": {
                "label": "L6",
                "addr": 4574
            },
            "L7": {
                "label": "L7",
                "addr": 4538
            },
            "L8": {
                "label": "L8",
                "addr": 4515
            },
            "L9": {
                "label": "L9",
                "addr": 4551
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 123,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    %rsi,%rdi\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%ebx\n  je     118d <func0+0x6d>\n  mov    $0xa,%r12d\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax)\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  cmp    $0x1,%ebx\n  je     118d <func0+0x6d>\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  lea    (%rbx,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1150 <func0+0x30>\n  movslq 0x0(%rbp),%rax\n  cmp    %eax,%r12d\n  jle    11f0 <func0+0xd0>\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  mov    %ebx,(%rdi,%rax,4)\n  lea    0x1(%rbx,%rbx,2),%ebx\n  cmp    $0x1,%ebx\n  jne    1160 <func0+0x40>\n  cmpl   $0x1,0x0(%rbp)\n  mov    $0x1,%r8d\n  jle    11d5 <func0+0xb5>\n  nopl   0x0(%rax)\n  mov    (%rdi,%r8,4),%esi\n  lea    -0x1(%r8),%rax\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdi,%rax,4),%edx\n  mov    %eax,%ecx\n  cmp    %esi,%edx\n  jle    11e0 <func0+0xc0>\n  mov    %edx,0x4(%rdi,%rax,4)\n  sub    $0x1,%rax\n  cmp    $0xffffffff,%eax\n  jne    11b0 <func0+0x90>\n  mov    %rdi,%rax\n  mov    %esi,(%rax)\n  add    $0x1,%r8\n  cmp    %r8d,0x0(%rbp)\n  jg     11a0 <func0+0x80>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%ecx\n  movslq %ecx,%rcx\n  lea    (%rdi,%rcx,4),%rax\n  jmp    11c9 <func0+0xa9>\n  nopl   0x0(%rax)\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  call   1050 <realloc@plt>\n  mov    %rax,%rdi\n  movslq 0x0(%rbp),%rax\n  jmp    117b <func0+0x5b>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    %rsi,%rdi\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%ebx\n  je     L0\n  mov    $0xa,%r12d\n  jmp    L1\n  nopl   0x0(%rax)\nL2:\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  cmp    $0x1,%ebx\n  je     L0\nL1:\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  lea    (%rbx,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L2\n  movslq 0x0(%rbp),%rax\n  cmp    %eax,%r12d\n  jle    L3\nL9:\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  mov    %ebx,(%rdi,%rax,4)\n  lea    0x1(%rbx,%rbx,2),%ebx\n  cmp    $0x1,%ebx\n  jne    L1\nL0:\n  cmpl   $0x1,0x0(%rbp)\n  mov    $0x1,%r8d\n  jle    L4\n  nopl   0x0(%rax)\nL7:\n  mov    (%rdi,%r8,4),%esi\n  lea    -0x1(%r8),%rax\n  nopl   0x0(%rax,%rax,1)\nL6:\n  mov    (%rdi,%rax,4),%edx\n  mov    %eax,%ecx\n  cmp    %esi,%edx\n  jle    L5\n  mov    %edx,0x4(%rdi,%rax,4)\n  sub    $0x1,%rax\n  cmp    $0xffffffff,%eax\n  jne    L6\n  mov    %rdi,%rax\nL8:\n  mov    %esi,(%rax)\n  add    $0x1,%r8\n  cmp    %r8d,0x0(%rbp)\n  jg     L7\nL4:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL5:\n  add    $0x1,%ecx\n  movslq %ecx,%rcx\n  lea    (%rdi,%rcx,4),%rax\n  jmp    L8\n  nopl   0x0(%rax)\nL3:\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  call   <realloc@plt>\n  mov    %rax,%rdi\n  movslq 0x0(%rbp),%rax\n  jmp    L9",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4493
            },
            "L1": {
                "label": "L1",
                "addr": 4448
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4592
            },
            "L4": {
                "label": "L4",
                "addr": 4565
            },
            "L5": {
                "label": "L5",
                "addr": 4576
            },
            "L6": {
                "label": "L6",
                "addr": 4528
            },
            "L7": {
                "label": "L7",
                "addr": 4512
            },
            "L8": {
                "label": "L8",
                "addr": 4553
            },
            "L9": {
                "label": "L9",
                "addr": 4475
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 123,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int n, int *out, int *size) {\n    int capacity = 10;\n    *size = 1;\n    out[0] = 1;\n    \n    while (n != 1) {\n        if (n % 2 == 1) {\n            if (*size >= capacity) {\n                capacity *= 2;\n                out = (int*)realloc(out, capacity * sizeof(int));\n            }\n            out[(*size)++] = n;\n            n = n * 3 + 1;\n        } else {\n            n = n / 2;\n        }\n    }\n\n    for (int i = 1; i < *size; i++) {\n        int key = out[i];\n        int j = i - 1;\n\n        while (j >= 0 && out[j] > key) {\n            out[j + 1] = out[j];\n            j = j - 1;\n        }\n        out[j + 1] = key;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <stdlib.h>\n\nint issame(int *a, int size_a, int *b, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    int *result;\n\n    // Test 1\n    int expected1[] = {1, 5, 7, 11, 13, 17};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(14, result, &size);\n    assert(issame(result, size, expected1, 6));\n    free(result);\n\n    // Test 2\n    int expected2[] = {1, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(5, result, &size);\n    assert(issame(result, size, expected2, 2));\n    free(result);\n\n    // Test 3\n    int expected3[] = {1, 3, 5};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(12, result, &size);\n    assert(issame(result, size, expected3, 3));\n    free(result);\n\n    // Test 4\n    int expected4[] = {1};\n    result = (int*)malloc(100 * sizeof(int));\n    func0(1, result, &size);\n    assert(issame(result, size, expected4, 1));\n    free(result);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    %rsi,%rdi\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%ebx\n  je     118d <func0+0x6d>\n  mov    $0xa,%r12d\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax)\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  cmp    $0x1,%ebx\n  je     118d <func0+0x6d>\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  lea    (%rbx,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1150 <func0+0x30>\n  movslq 0x0(%rbp),%rax\n  cmp    %eax,%r12d\n  jle    11f0 <func0+0xd0>\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  mov    %ebx,(%rdi,%rax,4)\n  lea    0x1(%rbx,%rbx,2),%ebx\n  cmp    $0x1,%ebx\n  jne    1160 <func0+0x40>\n  cmpl   $0x1,0x0(%rbp)\n  mov    $0x1,%r8d\n  jle    11d5 <func0+0xb5>\n  nopl   0x0(%rax)\n  mov    (%rdi,%r8,4),%esi\n  lea    -0x1(%r8),%rax\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rdi,%rax,4),%edx\n  mov    %eax,%ecx\n  cmp    %esi,%edx\n  jle    11e0 <func0+0xc0>\n  mov    %edx,0x4(%rdi,%rax,4)\n  sub    $0x1,%rax\n  cmp    $0xffffffff,%eax\n  jne    11b0 <func0+0x90>\n  mov    %rdi,%rax\n  mov    %esi,(%rax)\n  add    $0x1,%r8\n  cmp    %r8d,0x0(%rbp)\n  jg     11a0 <func0+0x80>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\n  add    $0x1,%ecx\n  movslq %ecx,%rcx\n  lea    (%rdi,%rcx,4),%rax\n  jmp    11c9 <func0+0xa9>\n  nopl   0x0(%rax)\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  call   1050 <realloc@plt>\n  mov    %rax,%rdi\n  movslq 0x0(%rbp),%rax\n  jmp    117b <func0+0x5b>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  mov    %rdx,%rbp\n  push   %rbx\n  mov    %edi,%ebx\n  mov    %rsi,%rdi\n  movl   $0x1,(%rdx)\n  movl   $0x1,(%rsi)\n  cmp    $0x1,%ebx\n  je     L0\n  mov    $0xa,%r12d\n  jmp    L1\n  nopl   0x0(%rax)\nL2:\n  mov    %ebx,%eax\n  shr    $0x1f,%eax\n  add    %ebx,%eax\n  sar    %eax\n  mov    %eax,%ebx\n  cmp    $0x1,%ebx\n  je     L0\nL1:\n  mov    %ebx,%edx\n  shr    $0x1f,%edx\n  lea    (%rbx,%rdx,1),%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L2\n  movslq 0x0(%rbp),%rax\n  cmp    %eax,%r12d\n  jle    L3\nL9:\n  lea    0x1(%rax),%edx\n  mov    %edx,0x0(%rbp)\n  mov    %ebx,(%rdi,%rax,4)\n  lea    0x1(%rbx,%rbx,2),%ebx\n  cmp    $0x1,%ebx\n  jne    L1\nL0:\n  cmpl   $0x1,0x0(%rbp)\n  mov    $0x1,%r8d\n  jle    L4\n  nopl   0x0(%rax)\nL7:\n  mov    (%rdi,%r8,4),%esi\n  lea    -0x1(%r8),%rax\n  nopl   0x0(%rax,%rax,1)\nL6:\n  mov    (%rdi,%rax,4),%edx\n  mov    %eax,%ecx\n  cmp    %esi,%edx\n  jle    L5\n  mov    %edx,0x4(%rdi,%rax,4)\n  sub    $0x1,%rax\n  cmp    $0xffffffff,%eax\n  jne    L6\n  mov    %rdi,%rax\nL8:\n  mov    %esi,(%rax)\n  add    $0x1,%r8\n  cmp    %r8d,0x0(%rbp)\n  jg     L7\nL4:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopw   0x0(%rax,%rax,1)\nL5:\n  add    $0x1,%ecx\n  movslq %ecx,%rcx\n  lea    (%rdi,%rcx,4),%rax\n  jmp    L8\n  nopl   0x0(%rax)\nL3:\n  add    %r12d,%r12d\n  movslq %r12d,%rsi\n  shl    $0x2,%rsi\n  call   <realloc@plt>\n  mov    %rax,%rdi\n  movslq 0x0(%rbp),%rax\n  jmp    L9",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4493
            },
            "L1": {
                "label": "L1",
                "addr": 4448
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4592
            },
            "L4": {
                "label": "L4",
                "addr": 4565
            },
            "L5": {
                "label": "L5",
                "addr": 4576
            },
            "L6": {
                "label": "L6",
                "addr": 4528
            },
            "L7": {
                "label": "L7",
                "addr": 4512
            },
            "L8": {
                "label": "L8",
                "addr": 4553
            },
            "L9": {
                "label": "L9",
                "addr": 4475
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 124,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  cmp    $0xa,%rax\n  je     1194 <func0+0x3b>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  movl   $0x0,-0x24(%rbp)\n  jmp    11fd <func0+0xa4>\n  cmpl   $0x2,-0x24(%rbp)\n  je     11a9 <func0+0x50>\n  cmpl   $0x5,-0x24(%rbp)\n  jne    11c7 <func0+0x6e>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2d,%al\n  je     11f9 <func0+0xa0>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    11ef <func0+0x96>\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jle    11f9 <func0+0xa0>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  addl   $0x1,-0x24(%rbp)\n  cmpl   $0x9,-0x24(%rbp)\n  jle    119d <func0+0x44>\n  mov    -0x38(%rbp),%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x13(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x1,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x12(%rbp)\n  movb   $0x0,-0x11(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x3,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x10(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xf(%rbp)\n  movb   $0x0,-0xe(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x6,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xd(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x7,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xc(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x8,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xb(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x9,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xa(%rbp)\n  movb   $0x0,-0x9(%rbp)\n  lea    -0x13(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <atoi@plt>\n  mov    %eax,-0x20(%rbp)\n  lea    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <atoi@plt>\n  mov    %eax,-0x1c(%rbp)\n  lea    -0xd(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <atoi@plt>\n  mov    %eax,-0x18(%rbp)\n  cmpl   $0x0,-0x20(%rbp)\n  jle    12b4 <func0+0x15b>\n  cmpl   $0xc,-0x20(%rbp)\n  jle    12bb <func0+0x162>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    12c7 <func0+0x16e>\n  cmpl   $0x1f,-0x1c(%rbp)\n  jle    12ce <func0+0x175>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  cmpl   $0x4,-0x20(%rbp)\n  je     12e6 <func0+0x18d>\n  cmpl   $0x6,-0x20(%rbp)\n  je     12e6 <func0+0x18d>\n  cmpl   $0x9,-0x20(%rbp)\n  je     12e6 <func0+0x18d>\n  cmpl   $0xb,-0x20(%rbp)\n  jne    12f3 <func0+0x19a>\n  cmpl   $0x1f,-0x1c(%rbp)\n  jne    12f3 <func0+0x19a>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  cmpl   $0x2,-0x20(%rbp)\n  jne    1306 <func0+0x1ad>\n  cmpl   $0x1d,-0x1c(%rbp)\n  jle    1306 <func0+0x1ad>\n  mov    $0x0,%eax\n  jmp    130b <func0+0x1b2>\n  mov    $0x1,%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     131f <func0+0x1c6>\n  call   1080 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x38(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    $0xa,%rax\n  je     L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0x24(%rbp)\n  jmp    L2\nL7:\n  cmpl   $0x2,-0x24(%rbp)\n  je     L3\n  cmpl   $0x5,-0x24(%rbp)\n  jne    L4\nL3:\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2d,%al\n  je     L5\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    L6\n  mov    -0x24(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jle    L5\nL6:\n  mov    $0x0,%eax\n  jmp    L1\nL5:\n  addl   $0x1,-0x24(%rbp)\nL2:\n  cmpl   $0x9,-0x24(%rbp)\n  jle    L7\n  mov    -0x38(%rbp),%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x13(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x1,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x12(%rbp)\n  movb   $0x0,-0x11(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x3,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x10(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x4,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xf(%rbp)\n  movb   $0x0,-0xe(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x6,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xd(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x7,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xc(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x8,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xb(%rbp)\n  mov    -0x38(%rbp),%rax\n  add    $0x9,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0xa(%rbp)\n  movb   $0x0,-0x9(%rbp)\n  lea    -0x13(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0x20(%rbp)\n  lea    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0x1c(%rbp)\n  lea    -0xd(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0x18(%rbp)\n  cmpl   $0x0,-0x20(%rbp)\n  jle    L8\n  cmpl   $0xc,-0x20(%rbp)\n  jle    L9\nL8:\n  mov    $0x0,%eax\n  jmp    L1\nL9:\n  cmpl   $0x0,-0x1c(%rbp)\n  jle    L10\n  cmpl   $0x1f,-0x1c(%rbp)\n  jle    L11\nL10:\n  mov    $0x0,%eax\n  jmp    L1\nL11:\n  cmpl   $0x4,-0x20(%rbp)\n  je     L12\n  cmpl   $0x6,-0x20(%rbp)\n  je     L12\n  cmpl   $0x9,-0x20(%rbp)\n  je     L12\n  cmpl   $0xb,-0x20(%rbp)\n  jne    L13\nL12:\n  cmpl   $0x1f,-0x1c(%rbp)\n  jne    L13\n  mov    $0x0,%eax\n  jmp    L1\nL13:\n  cmpl   $0x2,-0x20(%rbp)\n  jne    L14\n  cmpl   $0x1d,-0x1c(%rbp)\n  jle    L14\n  mov    $0x0,%eax\n  jmp    L1\nL14:\n  mov    $0x1,%eax\nL1:\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L15\n  call   <__stack_chk_fail@plt>\nL15:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4500
            },
            "L1": {
                "label": "L1",
                "addr": 4875
            },
            "L2": {
                "label": "L2",
                "addr": 4605
            },
            "L3": {
                "label": "L3",
                "addr": 4521
            },
            "L4": {
                "label": "L4",
                "addr": 4551
            },
            "L5": {
                "label": "L5",
                "addr": 4601
            },
            "L6": {
                "label": "L6",
                "addr": 4591
            },
            "L7": {
                "label": "L7",
                "addr": 4509
            },
            "L8": {
                "label": "L8",
                "addr": 4788
            },
            "L9": {
                "label": "L9",
                "addr": 4795
            },
            "L10": {
                "label": "L10",
                "addr": 4807
            },
            "L11": {
                "label": "L11",
                "addr": 4814
            },
            "L12": {
                "label": "L12",
                "addr": 4838
            },
            "L13": {
                "label": "L13",
                "addr": 4851
            },
            "L14": {
                "label": "L14",
                "addr": 4870
            },
            "L15": {
                "label": "L15",
                "addr": 4895
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 124,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,%rbx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1070 <strlen@plt>\n  mov    %rax,%rdx\n  mov    $0x0,%eax\n  cmp    $0xa,%rdx\n  jne    129b <func0+0x142>\n  mov    $0x0,%eax\n  jmp    11a8 <func0+0x4f>\n  cmpb   $0x2d,(%rbx,%rax,1)\n  jne    12b2 <func0+0x159>\n  add    $0x1,%rax\n  cmp    $0xa,%rax\n  je     11c8 <func0+0x6f>\n  cmp    $0x2,%eax\n  je     1194 <func0+0x3b>\n  cmp    $0x5,%eax\n  je     1194 <func0+0x3b>\n  movzbl (%rbx,%rax,1),%ecx\n  lea    -0x30(%rcx),%edx\n  cmp    $0x9,%dl\n  jbe    119e <func0+0x45>\n  mov    $0x0,%eax\n  jmp    129b <func0+0x142>\n  movzbl (%rbx),%eax\n  mov    %al,0xd(%rsp)\n  movzbl 0x1(%rbx),%eax\n  mov    %al,0xe(%rsp)\n  movb   $0x0,0xf(%rsp)\n  movzbl 0x3(%rbx),%eax\n  mov    %al,0x10(%rsp)\n  movzbl 0x4(%rbx),%eax\n  mov    %al,0x11(%rsp)\n  movb   $0x0,0x12(%rsp)\n  movzbl 0x6(%rbx),%eax\n  mov    %al,0x13(%rsp)\n  movzbl 0x7(%rbx),%eax\n  mov    %al,0x14(%rsp)\n  movzbl 0x8(%rbx),%eax\n  mov    %al,0x15(%rsp)\n  movzbl 0x9(%rbx),%eax\n  mov    %al,0x16(%rsp)\n  movb   $0x0,0x17(%rsp)\n  lea    0xd(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1090 <strtol@plt>\n  mov    %rax,%rbx\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1090 <strtol@plt>\n  mov    %rax,%rbp\n  lea    0x13(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1090 <strtol@plt>\n  lea    -0x1(%rbx),%edx\n  mov    $0x0,%eax\n  cmp    $0xb,%edx\n  ja     129b <func0+0x142>\n  lea    -0x1(%rbp),%edx\n  cmp    $0x1e,%edx\n  ja     129b <func0+0x142>\n  cmp    $0xb,%ebx\n  ja     1287 <func0+0x12e>\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    1287 <func0+0x12e>\n  mov    $0x0,%eax\n  cmp    $0x1f,%ebp\n  je     129b <func0+0x142>\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12b9 <func0+0x160>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  mov    $0x0,%eax\n  jmp    129b <func0+0x142>\n  call   1080 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,%rbx\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%rdx\n  mov    $0x0,%eax\n  cmp    $0xa,%rdx\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  cmpb   $0x2d,(%rbx,%rax,1)\n  jne    L2\nL5:\n  add    $0x1,%rax\n  cmp    $0xa,%rax\n  je     L3\nL1:\n  cmp    $0x2,%eax\n  je     L4\n  cmp    $0x5,%eax\n  je     L4\n  movzbl (%rbx,%rax,1),%ecx\n  lea    -0x30(%rcx),%edx\n  cmp    $0x9,%dl\n  jbe    L5\n  mov    $0x0,%eax\n  jmp    L0\nL3:\n  movzbl (%rbx),%eax\n  mov    %al,0xd(%rsp)\n  movzbl 0x1(%rbx),%eax\n  mov    %al,0xe(%rsp)\n  movb   $0x0,0xf(%rsp)\n  movzbl 0x3(%rbx),%eax\n  mov    %al,0x10(%rsp)\n  movzbl 0x4(%rbx),%eax\n  mov    %al,0x11(%rsp)\n  movb   $0x0,0x12(%rsp)\n  movzbl 0x6(%rbx),%eax\n  mov    %al,0x13(%rsp)\n  movzbl 0x7(%rbx),%eax\n  mov    %al,0x14(%rsp)\n  movzbl 0x8(%rbx),%eax\n  mov    %al,0x15(%rsp)\n  movzbl 0x9(%rbx),%eax\n  mov    %al,0x16(%rsp)\n  movb   $0x0,0x17(%rsp)\n  lea    0xd(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%rbx\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%rbp\n  lea    0x13(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  lea    -0x1(%rbx),%edx\n  mov    $0x0,%eax\n  cmp    $0xb,%edx\n  ja     L0\n  lea    -0x1(%rbp),%edx\n  cmp    $0x1e,%edx\n  ja     L0\n  cmp    $0xb,%ebx\n  ja     L6\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    L6\n  mov    $0x0,%eax\n  cmp    $0x1f,%ebp\n  je     L0\nL6:\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\nL0:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L7\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL2:\n  mov    $0x0,%eax\n  jmp    L0\nL7:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4763
            },
            "L1": {
                "label": "L1",
                "addr": 4520
            },
            "L2": {
                "label": "L2",
                "addr": 4786
            },
            "L3": {
                "label": "L3",
                "addr": 4552
            },
            "L4": {
                "label": "L4",
                "addr": 4500
            },
            "L5": {
                "label": "L5",
                "addr": 4510
            },
            "L6": {
                "label": "L6",
                "addr": 4743
            },
            "L7": {
                "label": "L7",
                "addr": 4793
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 124,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1070 <strlen@plt>\n  cmp    $0xa,%rax\n  jne    11c0 <func0+0x60>\n  xor    %eax,%eax\n  mov    $0x24,%ecx\n  jmp    11a7 <func0+0x47>\n  nopl   0x0(%rax)\n  cmp    $0x2d,%dl\n  jne    11c0 <func0+0x60>\n  add    $0x1,%rax\n  cmp    $0xa,%rax\n  je     11e0 <func0+0x80>\n  bt     %rax,%rcx\n  movzbl (%rbx,%rax,1),%edx\n  jb     1198 <func0+0x38>\n  sub    $0x30,%edx\n  cmp    $0x9,%dl\n  jbe    119d <func0+0x3d>\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    128a <func0+0x12a>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\n  movzwl (%rbx),%eax\n  lea    0xd(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0xf(%rsp)\n  mov    %ax,0xd(%rsp)\n  movzwl 0x3(%rbx),%eax\n  movb   $0x0,0x12(%rsp)\n  mov    %ax,0x10(%rsp)\n  mov    0x6(%rbx),%eax\n  movb   $0x0,0x17(%rsp)\n  mov    %eax,0x13(%rsp)\n  call   1090 <strtol@plt>\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbx\n  call   1090 <strtol@plt>\n  lea    0x13(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbp\n  call   1090 <strtol@plt>\n  lea    -0x1(%rbx),%eax\n  cmp    $0xb,%eax\n  ja     11c0 <func0+0x60>\n  lea    -0x1(%rbp),%eax\n  cmp    $0x1e,%eax\n  ja     11c0 <func0+0x60>\n  cmp    $0xb,%ebx\n  ja     1271 <func0+0x111>\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    1271 <func0+0x111>\n  cmp    $0x1f,%ebp\n  je     11c0 <func0+0x60>\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\n  jmp    11c2 <func0+0x62>\n  call   1080 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  cmp    $0xa,%rax\n  jne    L0\n  xor    %eax,%eax\n  mov    $0x24,%ecx\n  jmp    L1\n  nopl   0x0(%rax)\nL3:\n  cmp    $0x2d,%dl\n  jne    L0\nL4:\n  add    $0x1,%rax\n  cmp    $0xa,%rax\n  je     L2\nL1:\n  bt     %rax,%rcx\n  movzbl (%rbx,%rax,1),%edx\n  jb     L3\n  sub    $0x30,%edx\n  cmp    $0x9,%dl\n  jbe    L4\n  nopl   0x0(%rax)\nL0:\n  xor    %eax,%eax\nL7:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L5\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  nopl   (%rax)\nL2:\n  movzwl (%rbx),%eax\n  lea    0xd(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0xf(%rsp)\n  mov    %ax,0xd(%rsp)\n  movzwl 0x3(%rbx),%eax\n  movb   $0x0,0x12(%rsp)\n  mov    %ax,0x10(%rsp)\n  mov    0x6(%rbx),%eax\n  movb   $0x0,0x17(%rsp)\n  mov    %eax,0x13(%rsp)\n  call   <strtol@plt>\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbx\n  call   <strtol@plt>\n  lea    0x13(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbp\n  call   <strtol@plt>\n  lea    -0x1(%rbx),%eax\n  cmp    $0xb,%eax\n  ja     L0\n  lea    -0x1(%rbp),%eax\n  cmp    $0x1e,%eax\n  ja     L0\n  cmp    $0xb,%ebx\n  ja     L6\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    L6\n  cmp    $0x1f,%ebp\n  je     L0\nL6:\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\n  jmp    L7\nL5:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4544
            },
            "L1": {
                "label": "L1",
                "addr": 4519
            },
            "L2": {
                "label": "L2",
                "addr": 4576
            },
            "L3": {
                "label": "L3",
                "addr": 4504
            },
            "L4": {
                "label": "L4",
                "addr": 4509
            },
            "L5": {
                "label": "L5",
                "addr": 4746
            },
            "L6": {
                "label": "L6",
                "addr": 4721
            },
            "L7": {
                "label": "L7",
                "addr": 4546
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 124,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint func0(const char *date) {\n    int mm, dd, yy;\n\n    if (strlen(date) != 10) return 0;\n    for (int i = 0; i < 10; i++) {\n        if (i == 2 || i == 5) {\n            if (date[i] != '-') return 0;\n        } else {\n            if (date[i] < '0' || date[i] > '9') return 0;\n        }\n    }\n\n    char str_month[3] = {date[0], date[1], '\\0'};\n    char str_day[3] = {date[3], date[4], '\\0'};\n    char str_year[5] = {date[6], date[7], date[8], date[9], '\\0'};\n\n    mm = atoi(str_month);\n    dd = atoi(str_day);\n    yy = atoi(str_year);\n\n    if (mm < 1 || mm > 12) return 0;\n    if (dd < 1 || dd > 31) return 0;\n    if ((mm == 4 || mm == 6 || mm == 9 || mm == 11) && dd == 31) return 0;\n    if (mm == 2 && dd > 29) return 0;\n\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    assert(func0(\"03-11-2000\") == 1);\n    assert(func0(\"15-01-2012\") == 0);\n    assert(func0(\"04-0-2040\") == 0);\n    assert(func0(\"06-04-2020\") == 1);\n    assert(func0(\"01-01-2007\") == 1);\n    assert(func0(\"03-32-2011\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"04-31-3000\") == 0);\n    assert(func0(\"06-06-2005\") == 1);\n    assert(func0(\"21-31-2000\") == 0);\n    assert(func0(\"04-12-2003\") == 1);\n    assert(func0(\"04122003\") == 0);\n    assert(func0(\"20030412\") == 0);\n    assert(func0(\"2003-04\") == 0);\n    assert(func0(\"2003-04-12\") == 0);\n    assert(func0(\"04-2003\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   1070 <strlen@plt>\n  cmp    $0xa,%rax\n  jne    12b8 <func0+0x158>\n  movzbl (%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  movzbl 0x1(%rbx),%eax\n  movzwl (%rbx),%edx\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  cmpb   $0x2d,0x2(%rbx)\n  jne    12b8 <func0+0x158>\n  movzbl 0x3(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  movzbl 0x4(%rbx),%eax\n  movzwl 0x3(%rbx),%ecx\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  cmpb   $0x2d,0x5(%rbx)\n  jne    12b8 <func0+0x158>\n  movzbl 0x6(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  movzbl 0x7(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  movzbl 0x8(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  movzbl 0x9(%rbx),%eax\n  mov    0x6(%rbx),%esi\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     12b8 <func0+0x158>\n  mov    %dx,0x8(%rsp)\n  lea    0x8(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    %esi,0x10(%rsp)\n  xor    %esi,%esi\n  mov    %cx,0xc(%rsp)\n  movb   $0x0,0xa(%rsp)\n  movb   $0x0,0xe(%rsp)\n  movb   $0x0,0x14(%rsp)\n  call   1090 <strtol@plt>\n  lea    0xc(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbx\n  call   1090 <strtol@plt>\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbp\n  call   1090 <strtol@plt>\n  lea    -0x1(%rbx),%eax\n  cmp    $0xb,%eax\n  ja     12b8 <func0+0x158>\n  lea    -0x1(%rbp),%eax\n  cmp    $0x1e,%eax\n  ja     12b8 <func0+0x158>\n  cmp    $0xb,%ebx\n  ja     129c <func0+0x13c>\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    129c <func0+0x13c>\n  cmp    $0x1f,%ebp\n  je     12b8 <func0+0x158>\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\n  jmp    12ba <func0+0x15a>\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12d1 <func0+0x171>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\n  call   1080 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  cmp    $0xa,%rax\n  jne    L0\n  movzbl (%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  movzbl 0x1(%rbx),%eax\n  movzwl (%rbx),%edx\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  cmpb   $0x2d,0x2(%rbx)\n  jne    L0\n  movzbl 0x3(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  movzbl 0x4(%rbx),%eax\n  movzwl 0x3(%rbx),%ecx\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  cmpb   $0x2d,0x5(%rbx)\n  jne    L0\n  movzbl 0x6(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  movzbl 0x7(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  movzbl 0x8(%rbx),%eax\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  movzbl 0x9(%rbx),%eax\n  mov    0x6(%rbx),%esi\n  sub    $0x30,%eax\n  cmp    $0x9,%al\n  ja     L0\n  mov    %dx,0x8(%rsp)\n  lea    0x8(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    %esi,0x10(%rsp)\n  xor    %esi,%esi\n  mov    %cx,0xc(%rsp)\n  movb   $0x0,0xa(%rsp)\n  movb   $0x0,0xe(%rsp)\n  movb   $0x0,0x14(%rsp)\n  call   <strtol@plt>\n  lea    0xc(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbx\n  call   <strtol@plt>\n  lea    0x10(%rsp),%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %rax,%rbp\n  call   <strtol@plt>\n  lea    -0x1(%rbx),%eax\n  cmp    $0xb,%eax\n  ja     L0\n  lea    -0x1(%rbp),%eax\n  cmp    $0x1e,%eax\n  ja     L0\n  cmp    $0xb,%ebx\n  ja     L1\n  mov    $0xa50,%eax\n  bt     %rbx,%rax\n  jae    L1\n  cmp    $0x1f,%ebp\n  je     L0\nL1:\n  cmp    $0x2,%ebx\n  sete   %al\n  cmp    $0x1d,%ebp\n  setg   %dl\n  and    %edx,%eax\n  xor    $0x1,%eax\n  movzbl %al,%eax\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL0:\n  xor    %eax,%eax\nL2:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L3\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret\nL3:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4792
            },
            "L1": {
                "label": "L1",
                "addr": 4764
            },
            "L2": {
                "label": "L2",
                "addr": 4794
            },
            "L3": {
                "label": "L3",
                "addr": 4817
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 125,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0xa8,%rsp\n  mov    %rdi,-0xa8(%rbp)\n  mov    %rsi,-0xb0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x18(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x98(%rbp)\n  movl   $0x0,-0x94(%rbp)\n  movl   $0x0,-0x90(%rbp)\n  mov    -0xa8(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,-0x8c(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  movq   $0x0,-0x68(%rbp)\n  movq   $0x0,-0x60(%rbp)\n  movq   $0x0,-0x58(%rbp)\n  movq   $0x0,-0x50(%rbp)\n  movq   $0x0,-0x48(%rbp)\n  movq   $0x0,-0x40(%rbp)\n  movq   $0x0,-0x38(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movq   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movb   $0x0,-0x1c(%rbp)\n  mov    -0xa8(%rbp),%rax\n  mov    $0x20,%esi\n  mov    %rax,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  jne    12e5 <func0+0x10c>\n  mov    -0xa8(%rbp),%rax\n  mov    $0x2c,%esi\n  mov    %rax,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  je     13fd <func0+0x224>\n  mov    -0x8c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rax,-0x88(%rbp)\n  movl   $0x0,-0x9c(%rbp)\n  jmp    13e6 <func0+0x20d>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     1360 <func0+0x187>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  je     1360 <func0+0x187>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    13b3 <func0+0x1da>\n  cmpl   $0x0,-0x98(%rbp)\n  jle    13df <func0+0x206>\n  mov    -0x98(%rbp),%eax\n  cltq\n  movb   $0x0,-0x80(%rbp,%rax,1)\n  mov    -0x90(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x88(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  lea    -0x80(%rbp),%rax\n  mov    %rax,%rdi\n  call   1100 <strdup@plt>\n  mov    %rax,(%rbx)\n  addl   $0x1,-0x90(%rbp)\n  movl   $0x0,-0x98(%rbp)\n  jmp    13df <func0+0x206>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x98(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x98(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x80(%rbp,%rax,1)\n  addl   $0x1,-0x9c(%rbp)\n  mov    -0x9c(%rbp),%eax\n  cmp    -0x8c(%rbp),%eax\n  jle    1312 <func0+0x139>\n  jmp    14e1 <func0+0x308>\n  movl   $0x0,-0x9c(%rbp)\n  jmp    147a <func0+0x2a1>\n  call   1110 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0xa8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     1473 <func0+0x29a>\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1473 <func0+0x29a>\n  addl   $0x1,-0x94(%rbp)\n  addl   $0x1,-0x9c(%rbp)\n  mov    -0x9c(%rbp),%eax\n  cmp    -0x8c(%rbp),%eax\n  jl     1409 <func0+0x230>\n  mov    $0x8,%edi\n  call   10e0 <malloc@plt>\n  mov    %rax,-0x88(%rbp)\n  mov    $0xc,%edi\n  call   10e0 <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x88(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%rax\n  mov    -0x94(%rbp),%edx\n  lea    0xb39(%rip),%rcx        # 2000 <_fini+0xaec>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   10f0 <sprintf@plt>\n  movl   $0x1,-0x90(%rbp)\n  mov    -0xb0(%rbp),%rax\n  mov    -0x90(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    -0x18(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     150b <func0+0x332>\n  call   10c0 <__stack_chk_fail@plt>\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0xa8,%rsp\n  mov    %rdi,-0xa8(%rbp)\n  mov    %rsi,-0xb0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x18(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0x98(%rbp)\n  movl   $0x0,-0x94(%rbp)\n  movl   $0x0,-0x90(%rbp)\n  mov    -0xa8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x8c(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  movq   $0x0,-0x68(%rbp)\n  movq   $0x0,-0x60(%rbp)\n  movq   $0x0,-0x58(%rbp)\n  movq   $0x0,-0x50(%rbp)\n  movq   $0x0,-0x48(%rbp)\n  movq   $0x0,-0x40(%rbp)\n  movq   $0x0,-0x38(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movq   $0x0,-0x28(%rbp)\n  movl   $0x0,-0x20(%rbp)\n  movb   $0x0,-0x1c(%rbp)\n  mov    -0xa8(%rbp),%rax\n  mov    $0x20,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L0\n  mov    -0xa8(%rbp),%rax\n  mov    $0x2c,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L1\nL0:\n  mov    -0x8c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x88(%rbp)\n  movl   $0x0,-0x9c(%rbp)\n  jmp    L2\nL6:\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L3\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  je     L3\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L4\nL3:\n  cmpl   $0x0,-0x98(%rbp)\n  jle    L5\n  mov    -0x98(%rbp),%eax\n  cltq\n  movb   $0x0,-0x80(%rbp,%rax,1)\n  mov    -0x90(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x88(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  lea    -0x80(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,(%rbx)\n  addl   $0x1,-0x90(%rbp)\n  movl   $0x0,-0x98(%rbp)\n  jmp    L5\nL4:\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x98(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x98(%rbp)\n  movzbl (%rcx),%edx\n  cltq\n  mov    %dl,-0x80(%rbp,%rax,1)\nL5:\n  addl   $0x1,-0x9c(%rbp)\nL2:\n  mov    -0x9c(%rbp),%eax\n  cmp    -0x8c(%rbp),%eax\n  jle    L6\n  jmp    L7\nL1:\n  movl   $0x0,-0x9c(%rbp)\n  jmp    L8\nL10:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0xa8(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movsbq %al,%rax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     L9\n  mov    -0x9c(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xa8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L9\n  addl   $0x1,-0x94(%rbp)\nL9:\n  addl   $0x1,-0x9c(%rbp)\nL8:\n  mov    -0x9c(%rbp),%eax\n  cmp    -0x8c(%rbp),%eax\n  jl     L10\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x88(%rbp)\n  mov    $0xc,%edi\n  call   <malloc@plt>\n  mov    %rax,%rdx\n  mov    -0x88(%rbp),%rax\n  mov    %rdx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%rax\n  mov    -0x94(%rbp),%edx\n  lea    D0(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  movl   $0x1,-0x90(%rbp)\nL7:\n  mov    -0xb0(%rbp),%rax\n  mov    -0x90(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    -0x18(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L11\n  call   <__stack_chk_fail@plt>\nL11:\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    2873
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4837
            },
            "L1": {
                "label": "L1",
                "addr": 5117
            },
            "L2": {
                "label": "L2",
                "addr": 5094
            },
            "L3": {
                "label": "L3",
                "addr": 4960
            },
            "L4": {
                "label": "L4",
                "addr": 5043
            },
            "L5": {
                "label": "L5",
                "addr": 5087
            },
            "L6": {
                "label": "L6",
                "addr": 4882
            },
            "L7": {
                "label": "L7",
                "addr": 5345
            },
            "L8": {
                "label": "L8",
                "addr": 5242
            },
            "L9": {
                "label": "L9",
                "addr": 5235
            },
            "L10": {
                "label": "L10",
                "addr": 5129
            },
            "L11": {
                "label": "L11",
                "addr": 5387
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 125,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x78,%rsp\n  mov    %rdi,%r12\n  mov    %rsi,%r14\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strlen@plt>\n  mov    %rax,%rbp\n  movq   $0x0,(%rsp)\n  movq   $0x0,0x8(%rsp)\n  movq   $0x0,0x10(%rsp)\n  movq   $0x0,0x18(%rsp)\n  movq   $0x0,0x20(%rsp)\n  movq   $0x0,0x28(%rsp)\n  movq   $0x0,0x30(%rsp)\n  movq   $0x0,0x38(%rsp)\n  movq   $0x0,0x40(%rsp)\n  movq   $0x0,0x48(%rsp)\n  movq   $0x0,0x50(%rsp)\n  movq   $0x0,0x58(%rsp)\n  movl   $0x0,0x60(%rsp)\n  movb   $0x0,0x64(%rsp)\n  mov    $0x20,%esi\n  mov    %r12,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  je     12c6 <func0+0xed>\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rax,%r13\n  test   %ebp,%ebp\n  js     13e6 <func0+0x20d>\n  mov    %r12,%rbx\n  mov    %ebp,%ebp\n  lea    0x1(%r12,%rbp,1),%r12\n  mov    $0x0,%ebp\n  mov    $0x0,%edx\n  mov    %rsp,%r15\n  jmp    1310 <func0+0x137>\n  mov    $0x2c,%esi\n  mov    %r12,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  jne    1293 <func0+0xba>\n  mov    $0x0,%ebx\n  test   %ebp,%ebp\n  jle    1380 <func0+0x1a7>\n  call   1100 <__ctype_b_loc@plt>\n  mov    (%rax),%rdi\n  mov    %r12,%rdx\n  lea    -0x1(%rbp),%eax\n  lea    0x1(%r12,%rax,1),%rsi\n  mov    $0x0,%ebx\n  jmp    1353 <func0+0x17a>\n  test   %edx,%edx\n  jg     1326 <func0+0x14d>\n  add    $0x1,%rbx\n  cmp    %r12,%rbx\n  je     13c1 <func0+0x1e8>\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     12ff <func0+0x126>\n  cmp    $0x2c,%al\n  je     12ff <func0+0x126>\n  movslq %edx,%rcx\n  mov    %al,(%rsp,%rcx,1)\n  lea    0x1(%rdx),%edx\n  jmp    1303 <func0+0x12a>\n  movslq %edx,%rdx\n  movb   $0x0,(%rsp,%rdx,1)\n  mov    %r15,%rdi\n  call   10f0 <strdup@plt>\n  mov    %rax,%rdx\n  movslq %ebp,%rax\n  mov    %rdx,0x0(%r13,%rax,8)\n  add    $0x1,%ebp\n  mov    $0x0,%edx\n  jmp    1303 <func0+0x12a>\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  je     1380 <func0+0x1a7>\n  movzbl (%rdx),%eax\n  movsbq %al,%rcx\n  testb  $0x2,0x1(%rdi,%rcx,2)\n  je     134a <func0+0x171>\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebx\n  jmp    134a <func0+0x171>\n  mov    $0x8,%edi\n  call   10e0 <malloc@plt>\n  mov    %rax,%r13\n  mov    $0xc,%edi\n  call   10e0 <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13)\n  mov    %ebx,%r8d\n  lea    0xc58(%rip),%rcx        # 2000 <_fini+0xc0c>\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%eax\n  call   1110 <__sprintf_chk@plt>\n  mov    $0x1,%ebp\n  mov    %ebp,(%r14)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    13ed <func0+0x214>\n  mov    %r13,%rax\n  add    $0x78,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    $0x0,%ebp\n  jmp    13c1 <func0+0x1e8>\n  call   10c0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x78,%rsp\n  mov    %rdi,%r12\n  mov    %rsi,%r14\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  movq   $0x0,(%rsp)\n  movq   $0x0,0x8(%rsp)\n  movq   $0x0,0x10(%rsp)\n  movq   $0x0,0x18(%rsp)\n  movq   $0x0,0x20(%rsp)\n  movq   $0x0,0x28(%rsp)\n  movq   $0x0,0x30(%rsp)\n  movq   $0x0,0x38(%rsp)\n  movq   $0x0,0x40(%rsp)\n  movq   $0x0,0x48(%rsp)\n  movq   $0x0,0x50(%rsp)\n  movq   $0x0,0x58(%rsp)\n  movl   $0x0,0x60(%rsp)\n  movb   $0x0,0x64(%rsp)\n  mov    $0x20,%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L0\nL3:\n  lea    0x1(%rbp),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %ebp,%ebp\n  js     L1\n  mov    %r12,%rbx\n  mov    %ebp,%ebp\n  lea    0x1(%r12,%rbp,1),%r12\n  mov    $0x0,%ebp\n  mov    $0x0,%edx\n  mov    %rsp,%r15\n  jmp    L2\nL0:\n  mov    $0x2c,%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L3\n  mov    $0x0,%ebx\n  test   %ebp,%ebp\n  jle    L4\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdi\n  mov    %r12,%rdx\n  lea    -0x1(%rbp),%eax\n  lea    0x1(%r12,%rax,1),%rsi\n  mov    $0x0,%ebx\n  jmp    L5\nL8:\n  test   %edx,%edx\n  jg     L6\nL9:\n  add    $0x1,%rbx\n  cmp    %r12,%rbx\n  je     L7\nL2:\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     L8\n  cmp    $0x2c,%al\n  je     L8\n  movslq %edx,%rcx\n  mov    %al,(%rsp,%rcx,1)\n  lea    0x1(%rdx),%edx\n  jmp    L9\nL6:\n  movslq %edx,%rdx\n  movb   $0x0,(%rsp,%rdx,1)\n  mov    %r15,%rdi\n  call   <strdup@plt>\n  mov    %rax,%rdx\n  movslq %ebp,%rax\n  mov    %rdx,0x0(%r13,%rax,8)\n  add    $0x1,%ebp\n  mov    $0x0,%edx\n  jmp    L9\nL10:\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  je     L4\nL5:\n  movzbl (%rdx),%eax\n  movsbq %al,%rcx\n  testb  $0x2,0x1(%rdi,%rcx,2)\n  je     L10\n  movsbl %al,%eax\n  sub    $0x61,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%ebx\n  jmp    L10\nL4:\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  mov    $0xc,%edi\n  call   <malloc@plt>\n  mov    %rax,%rdi\n  mov    %rax,0x0(%r13)\n  mov    %ebx,%r8d\n  lea    D0(%rip),%rcx\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\n  mov    $0x1,%ebp\nL7:\n  mov    %ebp,(%r14)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L11\n  mov    %r13,%rax\n  add    $0x78,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL1:\n  mov    $0x0,%ebp\n  jmp    L7\nL11:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3160
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4806
            },
            "L1": {
                "label": "L1",
                "addr": 5094
            },
            "L2": {
                "label": "L2",
                "addr": 4880
            },
            "L3": {
                "label": "L3",
                "addr": 4755
            },
            "L4": {
                "label": "L4",
                "addr": 4992
            },
            "L5": {
                "label": "L5",
                "addr": 4947
            },
            "L6": {
                "label": "L6",
                "addr": 4902
            },
            "L7": {
                "label": "L7",
                "addr": 5057
            },
            "L8": {
                "label": "L8",
                "addr": 4863
            },
            "L9": {
                "label": "L9",
                "addr": 4867
            },
            "L10": {
                "label": "L10",
                "addr": 4938
            },
            "L11": {
                "label": "L11",
                "addr": 5101
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 125,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x78,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strlen@plt>\n  pxor   %xmm0,%xmm0\n  mov    %rbx,%rdi\n  mov    $0x20,%esi\n  movl   $0x0,0x60(%rsp)\n  mov    %rax,%r12\n  movb   $0x0,0x64(%rsp)\n  movaps %xmm0,(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  movaps %xmm0,0x20(%rsp)\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  je     1308 <func0+0x128>\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rax,%r14\n  test   %r12d,%r12d\n  js     13b8 <func0+0x1d8>\n  mov    %r12d,%r12d\n  xor    %edx,%edx\n  mov    %rsp,%r15\n  lea    0x1(%rbx,%r12,1),%r13\n  xor    %r12d,%r12d\n  jmp    12b4 <func0+0xd4>\n  nopl   0x0(%rax,%rax,1)\n  test   %edx,%edx\n  je     12ab <func0+0xcb>\n  movslq %edx,%rdx\n  mov    %r15,%rdi\n  movb   $0x0,(%rsp,%rdx,1)\n  call   10f0 <strdup@plt>\n  xor    %edx,%edx\n  mov    %rax,%r8\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r8,(%r14,%rax,8)\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     12d8 <func0+0xf8>\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     1288 <func0+0xa8>\n  cmp    $0x2c,%al\n  je     1288 <func0+0xa8>\n  movslq %edx,%rcx\n  add    $0x1,%rbx\n  add    $0x1,%edx\n  mov    %al,(%rsp,%rcx,1)\n  cmp    %rbx,%r13\n  jne    12b4 <func0+0xd4>\n  nopl   0x0(%rax)\n  mov    %r12d,0x0(%rbp)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    13c5 <func0+0x1e5>\n  add    $0x78,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x2c,%esi\n  mov    %rbx,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  jne    1254 <func0+0x74>\n  test   %r12d,%r12d\n  jle    13c0 <func0+0x1e0>\n  call   1100 <__ctype_b_loc@plt>\n  mov    (%rax),%rsi\n  lea    -0x1(%r12),%eax\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%rcx\n  nopl   0x0(%rax)\n  movsbq (%rbx),%rdx\n  mov    %rdx,%rax\n  testb  $0x2,0x1(%rsi,%rdx,2)\n  je     1369 <func0+0x189>\n  sub    $0x61,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\n  add    $0x1,%rbx\n  cmp    %rbx,%rcx\n  jne    1340 <func0+0x160>\n  mov    $0x8,%edi\n  call   10e0 <malloc@plt>\n  mov    $0xc,%edi\n  mov    %rax,%r14\n  call   10e0 <malloc@plt>\n  mov    %r12d,%r8d\n  mov    $0xc,%edx\n  lea    0xc68(%rip),%rcx        # 2000 <_fini+0xc34>\n  mov    %rax,(%r14)\n  mov    %rax,%rdi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  mov    $0x1,%r12d\n  call   1110 <__sprintf_chk@plt>\n  jmp    12d8 <func0+0xf8>\n  nopl   (%rax)\n  xor    %r12d,%r12d\n  jmp    12d8 <func0+0xf8>\n  xor    %r12d,%r12d\n  jmp    1372 <func0+0x192>\n  call   10c0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x78,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  pxor   %xmm0,%xmm0\n  mov    %rbx,%rdi\n  mov    $0x20,%esi\n  movl   $0x0,0x60(%rsp)\n  mov    %rax,%r12\n  movb   $0x0,0x64(%rsp)\n  movaps %xmm0,(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  movaps %xmm0,0x20(%rsp)\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L0\nL7:\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %r12d,%r12d\n  js     L1\n  mov    %r12d,%r12d\n  xor    %edx,%edx\n  mov    %rsp,%r15\n  lea    0x1(%rbx,%r12,1),%r13\n  xor    %r12d,%r12d\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL5:\n  test   %edx,%edx\n  je     L3\n  movslq %edx,%rdx\n  mov    %r15,%rdi\n  movb   $0x0,(%rsp,%rdx,1)\n  call   <strdup@plt>\n  xor    %edx,%edx\n  mov    %rax,%r8\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r8,(%r14,%rax,8)\nL3:\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     L4\nL2:\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     L5\n  cmp    $0x2c,%al\n  je     L5\n  movslq %edx,%rcx\n  add    $0x1,%rbx\n  add    $0x1,%edx\n  mov    %al,(%rsp,%rcx,1)\n  cmp    %rbx,%r13\n  jne    L2\n  nopl   0x0(%rax)\nL4:\n  mov    %r12d,0x0(%rbp)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x78,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    $0x2c,%esi\n  mov    %rbx,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L7\n  test   %r12d,%r12d\n  jle    L8\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rsi\n  lea    -0x1(%r12),%eax\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%rcx\n  nopl   0x0(%rax)\nL10:\n  movsbq (%rbx),%rdx\n  mov    %rdx,%rax\n  testb  $0x2,0x1(%rsi,%rdx,2)\n  je     L9\n  sub    $0x61,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\nL9:\n  add    $0x1,%rbx\n  cmp    %rbx,%rcx\n  jne    L10\nL11:\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    $0xc,%edi\n  mov    %rax,%r14\n  call   <malloc@plt>\n  mov    %r12d,%r8d\n  mov    $0xc,%edx\n  lea    D0(%rip),%rcx\n  mov    %rax,(%r14)\n  mov    %rax,%rdi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  mov    $0x1,%r12d\n  call   <__sprintf_chk@plt>\n  jmp    L4\n  nopl   (%rax)\nL1:\n  xor    %r12d,%r12d\n  jmp    L4\nL8:\n  xor    %r12d,%r12d\n  jmp    L11\nL6:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3176
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4872
            },
            "L1": {
                "label": "L1",
                "addr": 5048
            },
            "L2": {
                "label": "L2",
                "addr": 4788
            },
            "L3": {
                "label": "L3",
                "addr": 4779
            },
            "L4": {
                "label": "L4",
                "addr": 4824
            },
            "L5": {
                "label": "L5",
                "addr": 4744
            },
            "L6": {
                "label": "L6",
                "addr": 5061
            },
            "L7": {
                "label": "L7",
                "addr": 4692
            },
            "L8": {
                "label": "L8",
                "addr": 5056
            },
            "L9": {
                "label": "L9",
                "addr": 4969
            },
            "L10": {
                "label": "L10",
                "addr": 4928
            },
            "L11": {
                "label": "L11",
                "addr": 4978
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 125,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>\n\nchar **func0(const char *txt, int *returnSize) {\n    int i, j = 0, num = 0, count = 0;\n    int len = strlen(txt);\n    char **out = NULL;\n    char current[101] = {0};\n\n    if (strchr(txt, ' ') || strchr(txt, ',')) {\n        out = malloc(sizeof(char *) * (len + 1));\n        for (i = 0; i <= len; ++i) {\n            if (txt[i] == ' ' || txt[i] == ',' || txt[i] == '\\0') {\n                if (j > 0) {\n                    current[j] = '\\0';\n                    out[count] = strdup(current);\n                    count++;\n                    j = 0;\n                }\n            } else {\n                current[j++] = txt[i];\n            }\n        }\n    } else {\n        for (i = 0; i < len; ++i) {\n            if (islower(txt[i]) && ((txt[i] - 'a') % 2 == 1)) {\n                num++;\n            }\n        }\n\n        out = malloc(sizeof(char *));\n        out[0] = malloc(sizeof(char) * 12);\n        sprintf(out[0], \"%d\", num);\n        count = 1;\n    }\n\n    *returnSize = count;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n\nint issame(char **a, int aSize, char **b, int bSize) {\n    if (aSize != bSize) return 0;\n    for (int i = 0; i < aSize; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nvoid free_words(char **words, int size) {\n    for (int i = 0; i < size; i++) free(words[i]);\n    free(words);\n}\n\nint main() {\n    int size;\n    char *expected[3];\n    char **result;\n\n    result = func0(\"Hello world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size)); \n    free_words(result, size);\n\n    result = func0(\"Hello,world!\", &size);\n    expected[0] = \"Hello\";\n    expected[1] = \"world!\";\n    assert(issame(expected, 2,result, size));\n    free_words(result, size);\n\n    result = func0(\"abcdef\", &size);\n    expected[0] = \"3\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaabb\", &size);\n    expected[0] = \"2\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"aaaBb\", &size);\n    expected[0] = \"1\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    result = func0(\"\", &size);\n    expected[0] = \"0\";\n    assert(issame(expected, 1,result, size));\n    free_words(result, size);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x78,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strlen@plt>\n  pxor   %xmm0,%xmm0\n  mov    %rbx,%rdi\n  mov    $0x20,%esi\n  movl   $0x0,0x60(%rsp)\n  mov    %rax,%r12\n  movb   $0x0,0x64(%rsp)\n  movaps %xmm0,(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  movaps %xmm0,0x20(%rsp)\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  je     1308 <func0+0x128>\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   10e0 <malloc@plt>\n  mov    %rax,%r14\n  test   %r12d,%r12d\n  js     13b8 <func0+0x1d8>\n  mov    %r12d,%r12d\n  xor    %edx,%edx\n  mov    %rsp,%r15\n  lea    0x1(%rbx,%r12,1),%r13\n  xor    %r12d,%r12d\n  jmp    12b4 <func0+0xd4>\n  nopl   0x0(%rax,%rax,1)\n  test   %edx,%edx\n  je     12ab <func0+0xcb>\n  movslq %edx,%rdx\n  mov    %r15,%rdi\n  movb   $0x0,(%rsp,%rdx,1)\n  call   10f0 <strdup@plt>\n  xor    %edx,%edx\n  mov    %rax,%r8\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r8,(%r14,%rax,8)\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     12d8 <func0+0xf8>\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     1288 <func0+0xa8>\n  cmp    $0x2c,%al\n  je     1288 <func0+0xa8>\n  movslq %edx,%rcx\n  add    $0x1,%rbx\n  add    $0x1,%edx\n  mov    %al,(%rsp,%rcx,1)\n  cmp    %rbx,%r13\n  jne    12b4 <func0+0xd4>\n  nopl   0x0(%rax)\n  mov    %r12d,0x0(%rbp)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    13c5 <func0+0x1e5>\n  add    $0x78,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x2c,%esi\n  mov    %rbx,%rdi\n  call   10d0 <strchr@plt>\n  test   %rax,%rax\n  jne    1254 <func0+0x74>\n  test   %r12d,%r12d\n  jle    13c0 <func0+0x1e0>\n  call   1100 <__ctype_b_loc@plt>\n  mov    (%rax),%rsi\n  lea    -0x1(%r12),%eax\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%rcx\n  nopl   0x0(%rax)\n  movsbq (%rbx),%rdx\n  mov    %rdx,%rax\n  testb  $0x2,0x1(%rsi,%rdx,2)\n  je     1369 <func0+0x189>\n  sub    $0x61,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\n  add    $0x1,%rbx\n  cmp    %rbx,%rcx\n  jne    1340 <func0+0x160>\n  mov    $0x8,%edi\n  call   10e0 <malloc@plt>\n  mov    $0xc,%edi\n  mov    %rax,%r14\n  call   10e0 <malloc@plt>\n  mov    %r12d,%r8d\n  mov    $0xc,%edx\n  lea    0xc68(%rip),%rcx        # 2000 <_fini+0xc34>\n  mov    %rax,(%r14)\n  mov    %rax,%rdi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  mov    $0x1,%r12d\n  call   1110 <__sprintf_chk@plt>\n  jmp    12d8 <func0+0xf8>\n  nopl   (%rax)\n  xor    %r12d,%r12d\n  jmp    12d8 <func0+0xf8>\n  xor    %r12d,%r12d\n  jmp    1372 <func0+0x192>\n  call   10c0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  sub    $0x78,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x68(%rsp)\n  xor    %eax,%eax\n  call   <strlen@plt>\n  pxor   %xmm0,%xmm0\n  mov    %rbx,%rdi\n  mov    $0x20,%esi\n  movl   $0x0,0x60(%rsp)\n  mov    %rax,%r12\n  movb   $0x0,0x64(%rsp)\n  movaps %xmm0,(%rsp)\n  movaps %xmm0,0x10(%rsp)\n  movaps %xmm0,0x20(%rsp)\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L0\nL7:\n  lea    0x1(%r12),%edi\n  movslq %edi,%rdi\n  shl    $0x3,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  test   %r12d,%r12d\n  js     L1\n  mov    %r12d,%r12d\n  xor    %edx,%edx\n  mov    %rsp,%r15\n  lea    0x1(%rbx,%r12,1),%r13\n  xor    %r12d,%r12d\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL5:\n  test   %edx,%edx\n  je     L3\n  movslq %edx,%rdx\n  mov    %r15,%rdi\n  movb   $0x0,(%rsp,%rdx,1)\n  call   <strdup@plt>\n  xor    %edx,%edx\n  mov    %rax,%r8\n  movslq %r12d,%rax\n  add    $0x1,%r12d\n  mov    %r8,(%r14,%rax,8)\nL3:\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     L4\nL2:\n  movzbl (%rbx),%eax\n  test   $0xdf,%al\n  je     L5\n  cmp    $0x2c,%al\n  je     L5\n  movslq %edx,%rcx\n  add    $0x1,%rbx\n  add    $0x1,%edx\n  mov    %al,(%rsp,%rcx,1)\n  cmp    %rbx,%r13\n  jne    L2\n  nopl   0x0(%rax)\nL4:\n  mov    %r12d,0x0(%rbp)\n  mov    0x68(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x78,%rsp\n  mov    %r14,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    $0x2c,%esi\n  mov    %rbx,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L7\n  test   %r12d,%r12d\n  jle    L8\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rsi\n  lea    -0x1(%r12),%eax\n  xor    %r12d,%r12d\n  lea    0x1(%rbx,%rax,1),%rcx\n  nopl   0x0(%rax)\nL10:\n  movsbq (%rbx),%rdx\n  mov    %rdx,%rax\n  testb  $0x2,0x1(%rsi,%rdx,2)\n  je     L9\n  sub    $0x61,%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r12d\nL9:\n  add    $0x1,%rbx\n  cmp    %rbx,%rcx\n  jne    L10\nL11:\n  mov    $0x8,%edi\n  call   <malloc@plt>\n  mov    $0xc,%edi\n  mov    %rax,%r14\n  call   <malloc@plt>\n  mov    %r12d,%r8d\n  mov    $0xc,%edx\n  lea    D0(%rip),%rcx\n  mov    %rax,(%r14)\n  mov    %rax,%rdi\n  xor    %eax,%eax\n  mov    $0x1,%esi\n  mov    $0x1,%r12d\n  call   <__sprintf_chk@plt>\n  jmp    L4\n  nopl   (%rax)\nL1:\n  xor    %r12d,%r12d\n  jmp    L4\nL8:\n  xor    %r12d,%r12d\n  jmp    L11\nL6:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3176
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4872
            },
            "L1": {
                "label": "L1",
                "addr": 5048
            },
            "L2": {
                "label": "L2",
                "addr": 4788
            },
            "L3": {
                "label": "L3",
                "addr": 4779
            },
            "L4": {
                "label": "L4",
                "addr": 4824
            },
            "L5": {
                "label": "L5",
                "addr": 4744
            },
            "L6": {
                "label": "L6",
                "addr": 5061
            },
            "L7": {
                "label": "L7",
                "addr": 4692
            },
            "L8": {
                "label": "L8",
                "addr": 5056
            },
            "L9": {
                "label": "L9",
                "addr": 4969
            },
            "L10": {
                "label": "L10",
                "addr": 4928
            },
            "L11": {
                "label": "L11",
                "addr": 4978
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 126,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    1118 <func0+0x1f>\n  mov    $0x1,%eax\n  jmp    11e0 <func0+0xe7>\n  movl   $0x1,-0x4(%rbp)\n  jmp    11cf <func0+0xd6>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    115e <func0+0x65>\n  mov    $0x0,%eax\n  jmp    11e0 <func0+0xe7>\n  cmpl   $0x1,-0x4(%rbp)\n  jle    11cb <func0+0xd2>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    11cb <func0+0xd2>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x8(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    11cb <func0+0xd2>\n  mov    $0x0,%eax\n  jmp    11e0 <func0+0xe7>\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1124 <func0+0x2b>\n  mov    $0x1,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    L0\n  mov    $0x1,%eax\n  jmp    L1\nL0:\n  movl   $0x1,-0x4(%rbp)\n  jmp    L2\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L3\n  mov    $0x0,%eax\n  jmp    L1\nL3:\n  cmpl   $0x1,-0x4(%rbp)\n  jle    L4\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L4\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x8(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L4\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    $0x1,%eax\nL1:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4376
            },
            "L1": {
                "label": "L1",
                "addr": 4576
            },
            "L2": {
                "label": "L2",
                "addr": 4559
            },
            "L3": {
                "label": "L3",
                "addr": 4446
            },
            "L4": {
                "label": "L4",
                "addr": 4555
            },
            "L5": {
                "label": "L5",
                "addr": 4388
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 126,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1138 <func0+0x3f>\n  mov    %esi,%esi\n  mov    $0x1,%eax\n  jmp    1114 <func0+0x1b>\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     1132 <func0+0x39>\n  mov    (%rdi,%rax,4),%edx\n  mov    -0x4(%rdi,%rax,4),%ecx\n  cmp    %ecx,%edx\n  jl     113e <func0+0x45>\n  jne    110b <func0+0x12>\n  cmp    $0x1,%eax\n  jle    110b <func0+0x12>\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    110b <func0+0x12>\n  mov    $0x0,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x1,%eax\n  ret\n  mov    $0x0,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %esi,%esi\n  mov    $0x1,%eax\n  jmp    L1\nL4:\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     L2\nL1:\n  mov    (%rdi,%rax,4),%edx\n  mov    -0x4(%rdi,%rax,4),%ecx\n  cmp    %ecx,%edx\n  jl     L3\n  jne    L4\n  cmp    $0x1,%eax\n  jle    L4\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    L4\n  mov    $0x0,%eax\n  ret\nL2:\n  mov    $0x1,%eax\n  ret\nL0:\n  mov    $0x1,%eax\n  ret\nL3:\n  mov    $0x0,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4372
            },
            "L2": {
                "label": "L2",
                "addr": 4402
            },
            "L3": {
                "label": "L3",
                "addr": 4414
            },
            "L4": {
                "label": "L4",
                "addr": 4363
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 126,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1140 <func0+0x40>\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  jmp    1121 <func0+0x21>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  je     1140 <func0+0x40>\n  mov    (%rdi,%rax,4),%edx\n  cmp    -0x4(%rdi,%rax,4),%edx\n  jl     1137 <func0+0x37>\n  jne    1118 <func0+0x18>\n  cmp    $0x1,%eax\n  je     1118 <func0+0x18>\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    1118 <func0+0x18>\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  je     L0\nL1:\n  mov    (%rdi,%rax,4),%edx\n  cmp    -0x4(%rdi,%rax,4),%edx\n  jl     L2\n  jne    L3\n  cmp    $0x1,%eax\n  je     L3\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    L3\nL2:\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4385
            },
            "L2": {
                "label": "L2",
                "addr": 4407
            },
            "L3": {
                "label": "L3",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 126,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdbool.h>\n\nbool func0(const int *lst, int lst_size) {\n    if (lst_size == 0) return true;\n\n    for (int i = 1; i < lst_size; i++) {\n        if (lst[i] < lst[i - 1]) return false;\n        if (i >= 2 && lst[i] == lst[i - 1] && lst[i] == lst[i - 2]) return false;\n    }\n    return true;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    int list1[] = {5};\n    assert(func0(list1, 1) == true);\n\n    int list2[] = {1, 2, 3, 4, 5};\n    assert(func0(list2, 5) == true);\n\n    int list3[] = {1, 3, 2, 4, 5};\n    assert(func0(list3, 5) == false);\n\n    int list4[] = {1, 2, 3, 4, 5, 6};\n    assert(func0(list4, 6) == true);\n\n    int list5[] = {1, 2, 3, 4, 5, 6, 7};\n    assert(func0(list5, 7) == true);\n\n    int list6[] = {1, 3, 2, 4, 5, 6, 7};\n    assert(func0(list6, 7) == false);\n\n    assert(func0(NULL, 0) == true);\n\n    int list7[] = {1};\n    assert(func0(list7, 1) == true);\n\n    int list8[] = {3, 2, 1};\n    assert(func0(list8, 3) == false);\n\n    int list9[] = {1, 2, 2, 2, 3, 4};\n    assert(func0(list9, 6) == false);\n\n    int list10[] = {1, 2, 3, 3, 3, 4};\n    assert(func0(list10, 6) == false);\n\n    int list11[] = {1, 2, 2, 3, 3, 4};\n    assert(func0(list11, 6) == true);\n\n    int list12[] = {1, 2, 3, 4};\n    assert(func0(list12, 4) == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1140 <func0+0x40>\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  jmp    1121 <func0+0x21>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  je     1140 <func0+0x40>\n  mov    (%rdi,%rax,4),%edx\n  cmp    -0x4(%rdi,%rax,4),%edx\n  jl     1137 <func0+0x37>\n  jne    1118 <func0+0x18>\n  cmp    $0x1,%eax\n  je     1118 <func0+0x18>\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    1118 <func0+0x18>\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    $0x1,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%rax\n  cmp    %rax,%rsi\n  je     L0\nL1:\n  mov    (%rdi,%rax,4),%edx\n  cmp    -0x4(%rdi,%rax,4),%edx\n  jl     L2\n  jne    L3\n  cmp    $0x1,%eax\n  je     L3\n  cmp    -0x8(%rdi,%rax,4),%edx\n  jne    L3\nL2:\n  xor    %eax,%eax\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    $0x1,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4385
            },
            "L2": {
                "label": "L2",
                "addr": 4407
            },
            "L3": {
                "label": "L3",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 127,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %edx,-0x1c(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  mov    -0x1c(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  cmp    %eax,%edx\n  cmovge %edx,%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x20(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  sub    -0xc(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jg     1141 <func0+0x48>\n  lea    0xec1(%rip),%rax        # 2000 <_fini+0xe88>\n  jmp    1176 <func0+0x7d>\n  movl   $0x2,-0x10(%rbp)\n  jmp    1164 <func0+0x6b>\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x10(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1160 <func0+0x67>\n  lea    0xea2(%rip),%rax        # 2000 <_fini+0xe88>\n  jmp    1176 <func0+0x7d>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    114a <func0+0x51>\n  lea    0xe8d(%rip),%rax        # 2003 <_fini+0xe8b>\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %edx,-0x1c(%rbp)\n  mov    %ecx,-0x20(%rbp)\n  mov    -0x1c(%rbp),%edx\n  mov    -0x14(%rbp),%eax\n  cmp    %eax,%edx\n  cmovge %edx,%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x20(%rbp),%edx\n  mov    -0x18(%rbp),%eax\n  cmp    %eax,%edx\n  cmovle %edx,%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  sub    -0xc(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x1,-0x4(%rbp)\n  jg     L0\n  lea    D0(%rip),%rax\n  jmp    L1\nL0:\n  movl   $0x2,-0x10(%rbp)\n  jmp    L2\nL4:\n  mov    -0x4(%rbp),%eax\n  cltd\n  idivl  -0x10(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L3\n  lea    D0(%rip),%rax\n  jmp    L1\nL3:\n  addl   $0x1,-0x10(%rbp)\nL2:\n  mov    -0x10(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x4(%rbp)\n  jge    L4\n  lea    D1(%rip),%rax\nL1:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3777,
                    3746
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8195,
                "bias": [
                    3725
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4417
            },
            "L1": {
                "label": "L1",
                "addr": 4470
            },
            "L2": {
                "label": "L2",
                "addr": 4452
            },
            "L3": {
                "label": "L3",
                "addr": 4448
            },
            "L4": {
                "label": "L4",
                "addr": 4426
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e4f0059455300",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"NO\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"YES\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 127,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  lea    0xef0(%rip),%rax        # 2000 <_fini+0xea8>\n  cmp    $0x1,%ecx\n  jle    114e <func0+0x55>\n  lea    0xee7(%rip),%rax        # 2003 <_fini+0xeab>\n  cmp    $0x3,%ecx\n  jle    114e <func0+0x55>\n  lea    0xed8(%rip),%rax        # 2000 <_fini+0xea8>\n  test   $0x1,%cl\n  je     114e <func0+0x55>\n  mov    $0x2,%esi\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jg     114f <func0+0x56>\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  jne    1132 <func0+0x39>\n  lea    0xeb2(%rip),%rax        # 2000 <_fini+0xea8>\n  ret\n  lea    0xead(%rip),%rax        # 2003 <_fini+0xeab>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  lea    D0(%rip),%rax\n  cmp    $0x1,%ecx\n  jle    L0\n  lea    D1(%rip),%rax\n  cmp    $0x3,%ecx\n  jle    L0\n  lea    D0(%rip),%rax\n  test   $0x1,%cl\n  je     L0\n  mov    $0x2,%esi\nL2:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jg     L1\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  jne    L2\n  lea    D0(%rip),%rax\nL0:\n  ret\nL1:\n  lea    D1(%rip),%rax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3824,
                    3800,
                    3762
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8195,
                "bias": [
                    3815,
                    3757
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4430
            },
            "L1": {
                "label": "L1",
                "addr": 4431
            },
            "L2": {
                "label": "L2",
                "addr": 4402
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e4f0059455300",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"NO\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"YES\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 127,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  lea    0xef3(%rip),%rax        # 2000 <_fini+0xe98>\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  cmp    $0x1,%ecx\n  jle    1167 <func0+0x67>\n  lea    0xee0(%rip),%rax        # 2003 <_fini+0xe9b>\n  cmp    $0x3,%ecx\n  jle    1167 <func0+0x67>\n  lea    0xed1(%rip),%rax        # 2000 <_fini+0xe98>\n  test   $0x1,%cl\n  je     1167 <func0+0x67>\n  mov    $0x2,%esi\n  jmp    1149 <func0+0x49>\n  nopl   0x0(%rax,%rax,1)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     1160 <func0+0x60>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1140 <func0+0x40>\n  lea    0xea7(%rip),%rax        # 2003 <_fini+0xe9b>\n  ret\n  nopl   (%rax)\n  lea    0xe99(%rip),%rax        # 2000 <_fini+0xe98>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  lea    D0(%rip),%rax\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  cmp    $0x1,%ecx\n  jle    L0\n  lea    D1(%rip),%rax\n  cmp    $0x3,%ecx\n  jle    L0\n  lea    D0(%rip),%rax\n  test   $0x1,%cl\n  je     L0\n  mov    $0x2,%esi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L2\nL1:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L3\n  lea    D1(%rip),%rax\n  ret\n  nopl   (%rax)\nL2:\n  lea    D0(%rip),%rax\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3827,
                    3793,
                    3737
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8195,
                "bias": [
                    3808,
                    3751
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4455
            },
            "L1": {
                "label": "L1",
                "addr": 4425
            },
            "L2": {
                "label": "L2",
                "addr": 4448
            },
            "L3": {
                "label": "L3",
                "addr": 4416
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e4f0059455300",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"NO\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"YES\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 127,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nconst char* func0(int interval1_start, int interval1_end, int interval2_start, int interval2_end) {\n    int inter1, inter2, l, i;\n    inter1 = interval1_start > interval2_start ? interval1_start : interval2_start;\n    inter2 = interval1_end < interval2_end ? interval1_end : interval2_end;\n    l = inter2 - inter1;\n    \n    if (l < 2) return \"NO\";\n    \n    for (i = 2; i * i <= l; i++)\n        if (l % i == 0) return \"NO\";\n    \n    return \"YES\";\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(1, 2, 2, 3), \"NO\") == 0);\n    assert(strcmp(func0(-1, 1, 0, 4), \"NO\") == 0);\n    assert(strcmp(func0(-3, -1, -5, 5), \"YES\") == 0);\n    assert(strcmp(func0(-2, 2, -4, 0), \"YES\") == 0);\n    assert(strcmp(func0(-11, 2, -1, -1), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 3, 5), \"NO\") == 0);\n    assert(strcmp(func0(1, 2, 1, 2), \"NO\") == 0);\n    assert(strcmp(func0(-2, -2, -3, -2), \"NO\") == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  lea    0xef3(%rip),%rax        # 2000 <_fini+0xe98>\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  cmp    $0x1,%ecx\n  jle    1167 <func0+0x67>\n  lea    0xee0(%rip),%rax        # 2003 <_fini+0xe9b>\n  cmp    $0x3,%ecx\n  jle    1167 <func0+0x67>\n  lea    0xed1(%rip),%rax        # 2000 <_fini+0xe98>\n  test   $0x1,%cl\n  je     1167 <func0+0x67>\n  mov    $0x2,%esi\n  jmp    1149 <func0+0x49>\n  nopl   0x0(%rax,%rax,1)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     1160 <func0+0x60>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1140 <func0+0x40>\n  lea    0xea7(%rip),%rax        # 2003 <_fini+0xe9b>\n  ret\n  nopl   (%rax)\n  lea    0xe99(%rip),%rax        # 2000 <_fini+0xe98>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    %esi,%ecx\n  lea    D0(%rip),%rax\n  cmovg  %esi,%ecx\n  cmp    %edi,%edx\n  cmovl  %edi,%edx\n  sub    %edx,%ecx\n  cmp    $0x1,%ecx\n  jle    L0\n  lea    D1(%rip),%rax\n  cmp    $0x3,%ecx\n  jle    L0\n  lea    D0(%rip),%rax\n  test   $0x1,%cl\n  je     L0\n  mov    $0x2,%esi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L2\nL1:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L3\n  lea    D1(%rip),%rax\n  ret\n  nopl   (%rax)\nL2:\n  lea    D0(%rip),%rax\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3827,
                    3793,
                    3737
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8195,
                "bias": [
                    3808,
                    3751
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4455
            },
            "L1": {
                "label": "L1",
                "addr": 4425
            },
            "L2": {
                "label": "L2",
                "addr": 4448
            },
            "L3": {
                "label": "L3",
                "addr": 4416
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e4f0059455300",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"NO\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"YES\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 128,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    1118 <func0+0x1f>\n  mov    $0xffff8000,%eax\n  jmp    11a0 <func0+0xa7>\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    1191 <func0+0x98>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  add    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jne    1170 <func0+0x77>\n  movl   $0x0,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jns    118d <func0+0x94>\n  negl   -0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     112f <func0+0x36>\n  mov    -0xc(%rbp),%eax\n  imul   -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jne    L0\n  mov    $0xffff8000,%eax\n  jmp    L1\nL0:\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L2\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  add    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jne    L3\n  movl   $0x0,-0x8(%rbp)\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jns    L4\n  negl   -0x8(%rbp)\nL4:\n  addl   $0x1,-0x4(%rbp)\nL2:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    -0xc(%rbp),%eax\n  imul   -0x8(%rbp),%eax\nL1:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4376
            },
            "L1": {
                "label": "L1",
                "addr": 4512
            },
            "L2": {
                "label": "L2",
                "addr": 4497
            },
            "L3": {
                "label": "L3",
                "addr": 4464
            },
            "L4": {
                "label": "L4",
                "addr": 4493
            },
            "L5": {
                "label": "L5",
                "addr": 4399
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 128,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     114d <func0+0x54>\n  jle    113f <func0+0x46>\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x1,%edi\n  mov    $0x0,%eax\n  jmp    1125 <func0+0x2c>\n  mov    %edx,%edi\n  add    $0x4,%rcx\n  cmp    %r8,%rcx\n  je     1149 <func0+0x50>\n  mov    (%rcx),%edx\n  mov    %edx,%esi\n  neg    %esi\n  cmovs  %edx,%esi\n  add    %esi,%eax\n  test   %edx,%edx\n  je     111a <func0+0x21>\n  mov    %edi,%esi\n  neg    %esi\n  test   %edx,%edx\n  cmovs  %esi,%edi\n  jmp    111c <func0+0x23>\n  mov    $0x1,%edi\n  mov    $0x0,%eax\n  imul   %edi,%eax\n  ret\n  mov    $0xffff8000,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x1,%edi\n  mov    $0x0,%eax\n  jmp    L2\nL4:\n  mov    %edx,%edi\nL5:\n  add    $0x4,%rcx\n  cmp    %r8,%rcx\n  je     L3\nL2:\n  mov    (%rcx),%edx\n  mov    %edx,%esi\n  neg    %esi\n  cmovs  %edx,%esi\n  add    %esi,%eax\n  test   %edx,%edx\n  je     L4\n  mov    %edi,%esi\n  neg    %esi\n  test   %edx,%edx\n  cmovs  %esi,%edi\n  jmp    L5\nL1:\n  mov    $0x1,%edi\n  mov    $0x0,%eax\nL3:\n  imul   %edi,%eax\n  ret\nL0:\n  mov    $0xffff8000,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4429
            },
            "L1": {
                "label": "L1",
                "addr": 4415
            },
            "L2": {
                "label": "L2",
                "addr": 4389
            },
            "L3": {
                "label": "L3",
                "addr": 4425
            },
            "L4": {
                "label": "L4",
                "addr": 4378
            },
            "L5": {
                "label": "L5",
                "addr": 4380
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 128,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     1153 <func0+0x53>\n  jle    1150 <func0+0x50>\n  lea    -0x1(%rsi),%eax\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x1,%eax\n  jmp    1132 <func0+0x32>\n  nopl   0x0(%rax,%rax,1)\n  mov    %eax,%ecx\n  neg    %ecx\n  test   %edx,%edx\n  cmovs  %ecx,%eax\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     114c <func0+0x4c>\n  mov    (%rdi),%edx\n  mov    %edx,%ecx\n  neg    %ecx\n  cmovs  %edx,%ecx\n  add    %ecx,%esi\n  test   %edx,%edx\n  jne    1120 <func0+0x20>\n  add    $0x4,%rdi\n  xor    %eax,%eax\n  cmp    %r8,%rdi\n  jne    1132 <func0+0x32>\n  imul   %esi,%eax\n  ret\n  xor    %eax,%eax\n  ret\n  mov    $0xffff8000,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  lea    -0x1(%rsi),%eax\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x1,%eax\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    %eax,%ecx\n  neg    %ecx\n  test   %edx,%edx\n  cmovs  %ecx,%eax\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     L3\nL2:\n  mov    (%rdi),%edx\n  mov    %edx,%ecx\n  neg    %ecx\n  cmovs  %edx,%ecx\n  add    %ecx,%esi\n  test   %edx,%edx\n  jne    L4\n  add    $0x4,%rdi\n  xor    %eax,%eax\n  cmp    %r8,%rdi\n  jne    L2\nL3:\n  imul   %esi,%eax\n  ret\nL1:\n  xor    %eax,%eax\n  ret\nL0:\n  mov    $0xffff8000,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4435
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            },
            "L2": {
                "label": "L2",
                "addr": 4402
            },
            "L3": {
                "label": "L3",
                "addr": 4428
            },
            "L4": {
                "label": "L4",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 128,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int *arr, int arr_size) {\n    if (arr_size == 0) return -32768;\n    int sum = 0, prods = 1, i;\n    for (i = 0; i < arr_size; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] == 0) prods = 0;\n        if (arr[i] < 0) prods = -prods;\n    }\n    return sum * prods;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 2, -4};\n    assert(func0(arr1, 4) == -9);\n\n    int arr2[] = {0, 1};\n    assert(func0(arr2, 2) == 0);\n\n    int arr3[] = {1, 1, 1, 2, 3, -1, 1};\n    assert(func0(arr3, 7) == -10);\n\n    assert(func0(NULL, 0) == -32768);\n\n    int arr5[] = {2, 4, 1, 2, -1, -1, 9};\n    assert(func0(arr5, 7) == 20);\n\n    int arr6[] = {-1, 1, -1, 1};\n    assert(func0(arr6, 4) == 4);\n\n    int arr7[] = {-1, 1, 1, 1};\n    assert(func0(arr7, 4) == -4);\n\n    int arr8[] = {-1, 1, 1, 0};\n    assert(func0(arr8, 4) == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     1153 <func0+0x53>\n  jle    1150 <func0+0x50>\n  lea    -0x1(%rsi),%eax\n  mov    $0x1,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  xor    %eax,%eax\n  jmp    1132 <func0+0x32>\n  nopl   0x0(%rax,%rax,1)\n  mov    %esi,%ecx\n  neg    %ecx\n  test   %edx,%edx\n  cmovs  %ecx,%esi\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  je     114c <func0+0x4c>\n  mov    (%rdi),%edx\n  mov    %edx,%ecx\n  neg    %ecx\n  cmovs  %edx,%ecx\n  add    %ecx,%eax\n  test   %edx,%edx\n  jne    1120 <func0+0x20>\n  add    $0x4,%rdi\n  xor    %esi,%esi\n  cmp    %rdi,%r8\n  jne    1132 <func0+0x32>\n  imul   %esi,%eax\n  ret\n  xor    %eax,%eax\n  ret\n  mov    $0xffff8000,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  je     L0\n  jle    L1\n  lea    -0x1(%rsi),%eax\n  mov    $0x1,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  xor    %eax,%eax\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL4:\n  mov    %esi,%ecx\n  neg    %ecx\n  test   %edx,%edx\n  cmovs  %ecx,%esi\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  je     L3\nL2:\n  mov    (%rdi),%edx\n  mov    %edx,%ecx\n  neg    %ecx\n  cmovs  %edx,%ecx\n  add    %ecx,%eax\n  test   %edx,%edx\n  jne    L4\n  add    $0x4,%rdi\n  xor    %esi,%esi\n  cmp    %rdi,%r8\n  jne    L2\nL3:\n  imul   %esi,%eax\n  ret\nL1:\n  xor    %eax,%eax\n  ret\nL0:\n  mov    $0xffff8000,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4435
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            },
            "L2": {
                "label": "L2",
                "addr": 4402
            },
            "L3": {
                "label": "L3",
                "addr": 4428
            },
            "L4": {
                "label": "L4",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 129,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %edx,-0x30(%rbp)\n  mov    %rcx,-0x38(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    118b <func0+0x72>\n  movl   $0x0,-0x18(%rbp)\n  jmp    117f <func0+0x66>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x1,%eax\n  jne    117b <func0+0x62>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1145 <func0+0x2c>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     113c <func0+0x23>\n  mov    -0x2c(%rbp),%eax\n  imul   %eax,%eax\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jle    11f4 <func0+0xdb>\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    11f4 <func0+0xdb>\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    1259 <func0+0x140>\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    1259 <func0+0x140>\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x0,-0x10(%rbp)\n  jle    12b9 <func0+0x1a0>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  sub    $0x4,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    12b9 <func0+0x1a0>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  sub    $0x4,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    131e <func0+0x205>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    131e <func0+0x205>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x38(%rbp),%rax\n  mov    -0x30(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    1388 <func0+0x26f>\n  mov    -0x1c(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    136b <func0+0x252>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x1,(%rax)\n  jmp    1384 <func0+0x26b>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     1345 <func0+0x22c>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x40,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  mov    %edx,-0x30(%rbp)\n  mov    %rcx,-0x38(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL4:\n  movl   $0x0,-0x18(%rbp)\n  jmp    L1\nL3:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x18(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0x1,%eax\n  jne    L2\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x10(%rbp)\nL2:\n  addl   $0x1,-0x18(%rbp)\nL1:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L3\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L4\n  mov    -0x2c(%rbp),%eax\n  imul   %eax,%eax\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jle    L5\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L5\n  mov    -0x14(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\nL5:\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L6\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L6\n  mov    -0x14(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\nL6:\n  cmpl   $0x0,-0x10(%rbp)\n  jle    L7\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  sub    $0x4,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L7\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  sub    $0x4,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\nL7:\n  mov    -0x2c(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x10(%rbp)\n  jge    L8\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jle    L8\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x10(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\nL8:\n  mov    -0x38(%rbp),%rax\n  mov    -0x30(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x30(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L9\nL12:\n  mov    -0x1c(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L10\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movl   $0x1,(%rax)\n  jmp    L11\nL10:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0xc(%rbp),%eax\n  mov    %eax,(%rdx)\nL11:\n  addl   $0x1,-0x1c(%rbp)\nL9:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x30(%rbp),%eax\n  jl     L12\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4491
            },
            "L1": {
                "label": "L1",
                "addr": 4479
            },
            "L2": {
                "label": "L2",
                "addr": 4475
            },
            "L3": {
                "label": "L3",
                "addr": 4421
            },
            "L4": {
                "label": "L4",
                "addr": 4412
            },
            "L5": {
                "label": "L5",
                "addr": 4596
            },
            "L6": {
                "label": "L6",
                "addr": 4697
            },
            "L7": {
                "label": "L7",
                "addr": 4793
            },
            "L8": {
                "label": "L8",
                "addr": 4894
            },
            "L9": {
                "label": "L9",
                "addr": 5000
            },
            "L10": {
                "label": "L10",
                "addr": 4971
            },
            "L11": {
                "label": "L11",
                "addr": 4996
            },
            "L12": {
                "label": "L12",
                "addr": 4933
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 129,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r10\n  mov    %esi,%r11d\n  mov    %edx,%ebx\n  mov    %rcx,%r12\n  test   %esi,%esi\n  jle    1160 <func0+0x47>\n  mov    %esi,%ecx\n  mov    $0x0,%edi\n  mov    %edi,%esi\n  mov    (%r10,%rdi,8),%rdx\n  mov    $0x0,%eax\n  cmpl   $0x1,(%rdx,%rax,4)\n  cmove  %eax,%r8d\n  cmove  %esi,%r9d\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    1142 <func0+0x29>\n  add    $0x1,%rdi\n  cmp    %rcx,%rdi\n  jne    1137 <func0+0x1e>\n  mov    %r11d,%ebp\n  imul   %r11d,%ebp\n  test   %r9d,%r9d\n  jle    117f <func0+0x66>\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    -0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  sub    $0x1,%r11d\n  cmp    %r9d,%r11d\n  jle    119b <func0+0x82>\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  test   %r8d,%r8d\n  jle    11b3 <func0+0x9a>\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    (%r10,%rdx,8),%rdx\n  mov    -0x4(%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  cmp    %r8d,%r11d\n  jle    11cc <func0+0xb3>\n  movslq %r9d,%r9\n  movslq %r8d,%r8\n  mov    (%r10,%r9,8),%rax\n  mov    0x4(%rax,%r8,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  mov    %ebx,(%r12)\n  movslq %ebx,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  test   %ebx,%ebx\n  jle    1200 <func0+0xe7>\n  mov    %ebx,%ebx\n  mov    $0x0,%edx\n  mov    $0x1,%esi\n  test   $0x1,%dl\n  mov    %esi,%ecx\n  cmovne %ebp,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rbx,%rdx\n  jne    11ec <func0+0xd3>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r10\n  mov    %esi,%r11d\n  mov    %edx,%ebx\n  mov    %rcx,%r12\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%ecx\n  mov    $0x0,%edi\nL2:\n  mov    %edi,%esi\n  mov    (%r10,%rdi,8),%rdx\n  mov    $0x0,%eax\nL1:\n  cmpl   $0x1,(%rdx,%rax,4)\n  cmove  %eax,%r8d\n  cmove  %esi,%r9d\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    L1\n  add    $0x1,%rdi\n  cmp    %rcx,%rdi\n  jne    L2\nL0:\n  mov    %r11d,%ebp\n  imul   %r11d,%ebp\n  test   %r9d,%r9d\n  jle    L3\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    -0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL3:\n  sub    $0x1,%r11d\n  cmp    %r9d,%r11d\n  jle    L4\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL4:\n  test   %r8d,%r8d\n  jle    L5\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    (%r10,%rdx,8),%rdx\n  mov    -0x4(%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL5:\n  cmp    %r8d,%r11d\n  jle    L6\n  movslq %r9d,%r9\n  movslq %r8d,%r8\n  mov    (%r10,%r9,8),%rax\n  mov    0x4(%rax,%r8,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL6:\n  mov    %ebx,(%r12)\n  movslq %ebx,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  test   %ebx,%ebx\n  jle    L7\n  mov    %ebx,%ebx\n  mov    $0x0,%edx\n  mov    $0x1,%esi\nL8:\n  test   $0x1,%dl\n  mov    %esi,%ecx\n  cmovne %ebp,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rbx,%rdx\n  jne    L8\nL7:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4448
            },
            "L1": {
                "label": "L1",
                "addr": 4418
            },
            "L2": {
                "label": "L2",
                "addr": 4407
            },
            "L3": {
                "label": "L3",
                "addr": 4479
            },
            "L4": {
                "label": "L4",
                "addr": 4507
            },
            "L5": {
                "label": "L5",
                "addr": 4531
            },
            "L6": {
                "label": "L6",
                "addr": 4556
            },
            "L7": {
                "label": "L7",
                "addr": 4608
            },
            "L8": {
                "label": "L8",
                "addr": 4588
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 129,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdi,%r10\n  mov    %esi,%r11d\n  mov    %rcx,%r12\n  push   %rbp\n  push   %rbx\n  mov    %edx,%ebx\n  test   %esi,%esi\n  jle    116e <func0+0x4e>\n  movslq %esi,%rdx\n  xor    %edi,%edi\n  nopl   0x0(%rax)\n  mov    (%r10,%rdi,8),%rcx\n  mov    %edi,%esi\n  xor    %eax,%eax\n  nopl   0x0(%rax,%rax,1)\n  cmpl   $0x1,(%rcx,%rax,4)\n  cmove  %eax,%r8d\n  cmove  %esi,%r9d\n  add    $0x1,%rax\n  cmp    %rdx,%rax\n  jne    1150 <func0+0x30>\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  jne    1140 <func0+0x20>\n  mov    %r11d,%ebp\n  imul   %r11d,%ebp\n  test   %r9d,%r9d\n  je     118d <func0+0x6d>\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    -0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  sub    $0x1,%r11d\n  cmp    %r9d,%r11d\n  jle    11ac <func0+0x8c>\n  lea    0x1(%r9),%edx\n  movslq %r8d,%rax\n  movslq %edx,%rdx\n  mov    (%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  test   %r8d,%r8d\n  je     11c4 <func0+0xa4>\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    (%r10,%rdx,8),%rdx\n  mov    -0x4(%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  cmp    %r8d,%r11d\n  jle    11de <func0+0xbe>\n  movslq %r9d,%r9\n  lea    0x1(%r8),%eax\n  mov    (%r10,%r9,8),%rdx\n  cltq\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\n  mov    %ebx,(%r12)\n  movslq %ebx,%r12\n  lea    0x0(,%r12,4),%rdi\n  call   1050 <malloc@plt>\n  xor    %edx,%edx\n  mov    $0x1,%esi\n  test   %ebx,%ebx\n  jle    1214 <func0+0xf4>\n  nopl   (%rax)\n  test   $0x1,%dl\n  mov    %esi,%ecx\n  cmovne %ebp,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%r12\n  jne    1200 <func0+0xe0>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  mov    %rdi,%r10\n  mov    %esi,%r11d\n  mov    %rcx,%r12\n  push   %rbp\n  push   %rbx\n  mov    %edx,%ebx\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rdx\n  xor    %edi,%edi\n  nopl   0x0(%rax)\nL2:\n  mov    (%r10,%rdi,8),%rcx\n  mov    %edi,%esi\n  xor    %eax,%eax\n  nopl   0x0(%rax,%rax,1)\nL1:\n  cmpl   $0x1,(%rcx,%rax,4)\n  cmove  %eax,%r8d\n  cmove  %esi,%r9d\n  add    $0x1,%rax\n  cmp    %rdx,%rax\n  jne    L1\n  add    $0x1,%rdi\n  cmp    %rdx,%rdi\n  jne    L2\nL0:\n  mov    %r11d,%ebp\n  imul   %r11d,%ebp\n  test   %r9d,%r9d\n  je     L3\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    -0x8(%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL3:\n  sub    $0x1,%r11d\n  cmp    %r9d,%r11d\n  jle    L4\n  lea    0x1(%r9),%edx\n  movslq %r8d,%rax\n  movslq %edx,%rdx\n  mov    (%r10,%rdx,8),%rdx\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL4:\n  test   %r8d,%r8d\n  je     L5\n  movslq %r9d,%rdx\n  movslq %r8d,%rax\n  mov    (%r10,%rdx,8),%rdx\n  mov    -0x4(%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL5:\n  cmp    %r8d,%r11d\n  jle    L6\n  movslq %r9d,%r9\n  lea    0x1(%r8),%eax\n  mov    (%r10,%r9,8),%rdx\n  cltq\n  mov    (%rdx,%rax,4),%eax\n  cmp    %eax,%ebp\n  cmovg  %eax,%ebp\nL6:\n  mov    %ebx,(%r12)\n  movslq %ebx,%r12\n  lea    0x0(,%r12,4),%rdi\n  call   <malloc@plt>\n  xor    %edx,%edx\n  mov    $0x1,%esi\n  test   %ebx,%ebx\n  jle    L7\n  nopl   (%rax)\nL8:\n  test   $0x1,%dl\n  mov    %esi,%ecx\n  cmovne %ebp,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %rdx,%r12\n  jne    L8\nL7:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4462
            },
            "L1": {
                "label": "L1",
                "addr": 4432
            },
            "L2": {
                "label": "L2",
                "addr": 4416
            },
            "L3": {
                "label": "L3",
                "addr": 4493
            },
            "L4": {
                "label": "L4",
                "addr": 4524
            },
            "L5": {
                "label": "L5",
                "addr": 4548
            },
            "L6": {
                "label": "L6",
                "addr": 4574
            },
            "L7": {
                "label": "L7",
                "addr": 4628
            },
            "L8": {
                "label": "L8",
                "addr": 4608
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 129,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint *func0(int **grid, int N, int k, int *returnSize) {\n    int i, j, x, y, min;\n    for (i = 0; i < N; i++)\n        for (j = 0; j < N; j++)\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            }\n    min = N * N;\n    if (x > 0 && grid[x - 1][y] < min) min = grid[x - 1][y];\n    if (x < N - 1 && grid[x + 1][y] < min) min = grid[x + 1][y];\n    if (y > 0 && grid[x][y - 1] < min) min = grid[x][y - 1];\n    if (y < N - 1 && grid[x][y + 1] < min) min = grid[x][y + 1];\n    \n    *returnSize = k;\n    int *out = (int *)malloc(k * sizeof(int));\n    for (i = 0; i < k; i++)\n        if (i % 2 == 0) out[i] = 1;\n        else out[i] = min;\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int *a, int *b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    // Test case 1\n    int grid1[3][3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    int *grid1_ptrs[] = {grid1[0], grid1[1], grid1[2]};\n    int result1[] = {1, 2, 1};\n    int *out1 = func0(grid1_ptrs, 3, 3, &size);\n    assert(issame(out1, result1, size));\n    free(out1);\n\n    // Test case 2\n    int grid2[3][3] = {{5, 9, 3}, {4, 1, 6}, {7, 8, 2}};\n    int *grid2_ptrs[] = {grid2[0], grid2[1], grid2[2]};\n    int result2[] = {1};\n    int *out2 = func0(grid2_ptrs, 3, 1, &size);\n    assert(issame(out2, result2, size));\n    free(out2);\n\n    // Test case 3\n    int grid3[4][4] = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    int *grid3_ptrs[] = {grid3[0], grid3[1], grid3[2], grid3[3]};\n    int result3[] = {1, 2, 1, 2};\n    int *out3 = func0(grid3_ptrs, 4, 4, &size);\n    assert(issame(out3, result3, size));\n    free(out3);\n\n    // Test case 4\n    int grid4[4][4] = {{6, 4, 13, 10}, {5, 7, 12, 1}, {3, 16, 11, 15}, {8, 14, 9, 2}};\n    int *grid4_ptrs[] = {grid4[0], grid4[1], grid4[2], grid4[3]};\n    int result4[] = {1, 10, 1, 10, 1, 10, 1};\n    int *out4 = func0(grid4_ptrs, 4, 7, &size);\n    assert(issame(out4, result4, size));\n    free(out4);\n    \n    // Test case 5\n    int grid5[4][4] = {{8, 14, 9, 2}, {6, 4, 13, 15}, {5, 7, 1, 12}, {3, 10, 11, 16}};\n    int *grid5_ptrs[] = {grid5[0], grid5[1], grid5[2], grid5[3]};\n    int result5[] = {1, 7, 1, 7, 1};\n    int *out5 = func0(grid5_ptrs, 4, 5, &size);\n    assert(issame(out5, result5, size));\n    free(out5);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  lea    -0x1(%rsi),%r15d\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %edx,0x4(%rsp)\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    13a8 <func0+0x288>\n  mov    %esi,%edx\n  mov    %esi,%r13d\n  movdqa 0xec9(%rip),%xmm7        # 2020 <_fini+0xac8>\n  mov    %esi,%ebp\n  shr    $0x2,%edx\n  and    $0xfffffffc,%r13d\n  pcmpeqd %xmm10,%xmm10\n  xor    %ecx,%ecx\n  movdqa 0xec0(%rip),%xmm9        # 2030 <_fini+0xad8>\n  lea    -0x1(%rdx),%r14d\n  add    $0x1,%r14\n  shl    $0x4,%r14\n  nopl   0x0(%rax)\n  mov    (%r12,%rcx,8),%rdx\n  mov    %ecx,%r10d\n  cmp    $0x7,%r15d\n  jbe    1530 <func0+0x410>\n  movd   %eax,%xmm4\n  lea    (%r14,%rdx,1),%rdi\n  pxor   %xmm2,%xmm2\n  mov    %rdx,%rax\n  pshufd $0x0,%xmm4,%xmm5\n  movd   %ecx,%xmm4\n  movdqa %xmm10,%xmm6\n  movdqa 0xe5a(%rip),%xmm3        # 2010 <_fini+0xab8>\n  pshufd $0x0,%xmm4,%xmm11\n  movdqa 0xe3c(%rip),%xmm4        # 2000 <_fini+0xaa8>\n  nopl   0x0(%rax)\n  movdqu (%rax),%xmm0\n  movdqa %xmm11,%xmm8\n  movdqa %xmm3,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm7,%xmm3\n  pcmpeqd %xmm9,%xmm0\n  movdqa %xmm0,%xmm12\n  pand   %xmm0,%xmm8\n  pand   %xmm0,%xmm1\n  pandn  %xmm5,%xmm12\n  movdqa %xmm12,%xmm5\n  por    %xmm8,%xmm5\n  movdqa %xmm0,%xmm8\n  pandn  %xmm6,%xmm8\n  movdqa %xmm8,%xmm6\n  por    %xmm1,%xmm6\n  movdqa %xmm4,%xmm1\n  paddd  %xmm7,%xmm4\n  pand   %xmm0,%xmm1\n  pandn  %xmm2,%xmm0\n  movdqa %xmm0,%xmm2\n  por    %xmm1,%xmm2\n  cmp    %rax,%rdi\n  jne    11c8 <func0+0xa8>\n  movdqa %xmm6,%xmm0\n  movd   %xmm2,%ebx\n  psrldq $0x8,%xmm0\n  movdqa %xmm0,%xmm1\n  pcmpgtd %xmm6,%xmm1\n  pand   %xmm1,%xmm0\n  pandn  %xmm6,%xmm1\n  por    %xmm0,%xmm1\n  movdqa %xmm1,%xmm3\n  psrldq $0x4,%xmm3\n  movdqa %xmm3,%xmm0\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm1,%xmm0\n  por    %xmm3,%xmm0\n  movd   %xmm0,%eax\n  pshufd $0x55,%xmm2,%xmm0\n  cmp    $0xffffffff,%eax\n  movd   %xmm0,%r9d\n  cmovne %eax,%r8d\n  movd   %xmm0,%eax\n  movdqa %xmm2,%xmm0\n  cmp    %r9d,%ebx\n  punpckhdq %xmm2,%xmm0\n  cmovae %ebx,%eax\n  movd   %xmm0,%edi\n  cmp    %edi,%eax\n  jb     1518 <func0+0x3f8>\n  pshufd $0x55,%xmm5,%xmm0\n  movd   %xmm5,%r11d\n  cmp    %r9d,%ebx\n  movd   %xmm0,(%rsp)\n  cmovb  (%rsp),%r11d\n  pshufd $0xff,%xmm2,%xmm2\n  pshufd $0xff,%xmm5,%xmm5\n  cmp    %edi,%eax\n  cmovb  %edi,%eax\n  movd   %xmm2,%edi\n  cmp    %edi,%eax\n  movd   %xmm5,%eax\n  mov    %r13d,%edi\n  cmovae %r11d,%eax\n  cmp    %r13d,%esi\n  je     139b <func0+0x27b>\n  movslq %edi,%r11\n  cmpl   $0x1,(%rdx,%r11,4)\n  lea    0x0(,%r11,4),%r9\n  lea    0x1(%rdi),%r11d\n  cmove  %edi,%r8d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    139b <func0+0x27b>\n  cmpl   $0x1,0x4(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x2(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    139b <func0+0x27b>\n  cmpl   $0x1,0x8(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x3(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %esi,%r11d\n  jge    139b <func0+0x27b>\n  cmpl   $0x1,0xc(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x4(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    139b <func0+0x27b>\n  cmpl   $0x1,0x10(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x5(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %esi,%r11d\n  jge    139b <func0+0x27b>\n  cmpl   $0x1,0x14(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x6(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    139b <func0+0x27b>\n  cmpl   $0x1,0x18(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  cmove  %r10d,%eax\n  add    $0x7,%edi\n  cmp    %edi,%esi\n  jle    139b <func0+0x27b>\n  cmpl   $0x1,0x1c(%rdx,%r9,1)\n  cmove  %edi,%r8d\n  cmove  %r10d,%eax\n  add    $0x1,%rcx\n  cmp    %rbp,%rcx\n  jne    1180 <func0+0x60>\n  mov    %esi,%ebx\n  imul   %esi,%ebx\n  test   %eax,%eax\n  jle    13c4 <func0+0x2a4>\n  movslq %eax,%rcx\n  movslq %r8d,%rdx\n  mov    -0x8(%r12,%rcx,8),%rcx\n  mov    (%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\n  cmp    %eax,%r15d\n  jle    13de <func0+0x2be>\n  lea    0x1(%rax),%ecx\n  movslq %r8d,%rdx\n  movslq %ecx,%rcx\n  mov    (%r12,%rcx,8),%rcx\n  mov    (%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\n  test   %r8d,%r8d\n  jle    13f6 <func0+0x2d6>\n  movslq %eax,%rcx\n  movslq %r8d,%rdx\n  mov    (%r12,%rcx,8),%rcx\n  mov    -0x4(%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\n  cmp    %r8d,%r15d\n  jle    1410 <func0+0x2f0>\n  cltq\n  lea    0x1(%r8),%edx\n  mov    (%r12,%rax,8),%rax\n  movslq %edx,%rdx\n  mov    (%rax,%rdx,4),%eax\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\n  movslq 0x4(%rsp),%rdi\n  mov    0x8(%rsp),%rax\n  mov    %edi,(%rax)\n  mov    %rdi,%r14\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,%r8\n  test   %r14d,%r14d\n  jle    1501 <func0+0x3e1>\n  lea    -0x1(%r14),%eax\n  cmp    $0x2,%eax\n  jbe    1537 <func0+0x417>\n  movd   %ebx,%xmm7\n  shr    $0x2,%r14d\n  mov    %r8,%rax\n  pxor   %xmm4,%xmm4\n  mov    %r14d,%edx\n  movdqa 0xbb5(%rip),%xmm1        # 2010 <_fini+0xab8>\n  movdqa 0xbbd(%rip),%xmm5        # 2020 <_fini+0xac8>\n  pshufd $0x0,%xmm7,%xmm6\n  shl    $0x4,%rdx\n  movdqa 0xbbc(%rip),%xmm2        # 2030 <_fini+0xad8>\n  add    %r8,%rdx\n  nopw   0x0(%rax,%rax,1)\n  movdqa %xmm1,%xmm0\n  movdqa %xmm2,%xmm3\n  paddd  %xmm5,%xmm1\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm6,%xmm0\n  por    %xmm3,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rdx,%rax\n  jne    1480 <func0+0x360>\n  mov    0x4(%rsp),%esi\n  mov    %esi,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%sil\n  je     1501 <func0+0x3e1>\n  movslq %eax,%rcx\n  add    $0x1,%eax\n  movl   $0x1,(%r8,%rcx,4)\n  lea    0x0(,%rcx,4),%rdx\n  cmp    %eax,%esi\n  jle    1501 <func0+0x3e1>\n  add    $0x4,%rdx\n  mov    $0x1,%ecx\n  lea    (%r8,%rdx,1),%rsi\n  test   $0x1,%al\n  jne    1553 <func0+0x433>\n  mov    %ecx,(%rsi)\n  add    $0x1,%eax\n  cmp    %eax,0x4(%rsp)\n  jle    1501 <func0+0x3e1>\n  test   $0x1,%al\n  mov    $0x1,%eax\n  cmove  %eax,%ebx\n  mov    %ebx,0x4(%r8,%rdx,1)\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  movdqa %xmm5,%xmm0\n  punpckhdq %xmm5,%xmm0\n  movd   %xmm0,%r11d\n  jmp    12b7 <func0+0x197>\n  nopw   0x0(%rax,%rax,1)\n  xor    %edi,%edi\n  jmp    12e0 <func0+0x1c0>\n  cmpl   $0x1,0x4(%rsp)\n  movl   $0x1,(%r8)\n  jle    1501 <func0+0x3e1>\n  lea    0x4(%r8),%rsi\n  mov    $0x1,%eax\n  mov    $0x4,%edx\n  mov    %ebx,%ecx\n  jmp    14e7 <func0+0x3c7>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  lea    -0x1(%rsi),%r15d\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %edx,0x4(%rsp)\n  mov    %rcx,0x8(%rsp)\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%edx\n  mov    %esi,%r13d\n  movdqa D0(%rip),%xmm7\n  mov    %esi,%ebp\n  shr    $0x2,%edx\n  and    $0xfffffffc,%r13d\n  pcmpeqd %xmm10,%xmm10\n  xor    %ecx,%ecx\n  movdqa D1(%rip),%xmm9\n  lea    -0x1(%rdx),%r14d\n  add    $0x1,%r14\n  shl    $0x4,%r14\n  nopl   0x0(%rax)\nL5:\n  mov    (%r12,%rcx,8),%rdx\n  mov    %ecx,%r10d\n  cmp    $0x7,%r15d\n  jbe    L1\n  movd   %eax,%xmm4\n  lea    (%r14,%rdx,1),%rdi\n  pxor   %xmm2,%xmm2\n  mov    %rdx,%rax\n  pshufd $0x0,%xmm4,%xmm5\n  movd   %ecx,%xmm4\n  movdqa %xmm10,%xmm6\n  movdqa D2(%rip),%xmm3\n  pshufd $0x0,%xmm4,%xmm11\n  movdqa D3(%rip),%xmm4\n  nopl   0x0(%rax)\nL2:\n  movdqu (%rax),%xmm0\n  movdqa %xmm11,%xmm8\n  movdqa %xmm3,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm7,%xmm3\n  pcmpeqd %xmm9,%xmm0\n  movdqa %xmm0,%xmm12\n  pand   %xmm0,%xmm8\n  pand   %xmm0,%xmm1\n  pandn  %xmm5,%xmm12\n  movdqa %xmm12,%xmm5\n  por    %xmm8,%xmm5\n  movdqa %xmm0,%xmm8\n  pandn  %xmm6,%xmm8\n  movdqa %xmm8,%xmm6\n  por    %xmm1,%xmm6\n  movdqa %xmm4,%xmm1\n  paddd  %xmm7,%xmm4\n  pand   %xmm0,%xmm1\n  pandn  %xmm2,%xmm0\n  movdqa %xmm0,%xmm2\n  por    %xmm1,%xmm2\n  cmp    %rax,%rdi\n  jne    L2\n  movdqa %xmm6,%xmm0\n  movd   %xmm2,%ebx\n  psrldq $0x8,%xmm0\n  movdqa %xmm0,%xmm1\n  pcmpgtd %xmm6,%xmm1\n  pand   %xmm1,%xmm0\n  pandn  %xmm6,%xmm1\n  por    %xmm0,%xmm1\n  movdqa %xmm1,%xmm3\n  psrldq $0x4,%xmm3\n  movdqa %xmm3,%xmm0\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm1,%xmm0\n  por    %xmm3,%xmm0\n  movd   %xmm0,%eax\n  pshufd $0x55,%xmm2,%xmm0\n  cmp    $0xffffffff,%eax\n  movd   %xmm0,%r9d\n  cmovne %eax,%r8d\n  movd   %xmm0,%eax\n  movdqa %xmm2,%xmm0\n  cmp    %r9d,%ebx\n  punpckhdq %xmm2,%xmm0\n  cmovae %ebx,%eax\n  movd   %xmm0,%edi\n  cmp    %edi,%eax\n  jb     L3\n  pshufd $0x55,%xmm5,%xmm0\n  movd   %xmm5,%r11d\n  cmp    %r9d,%ebx\n  movd   %xmm0,(%rsp)\n  cmovb  (%rsp),%r11d\nL14:\n  pshufd $0xff,%xmm2,%xmm2\n  pshufd $0xff,%xmm5,%xmm5\n  cmp    %edi,%eax\n  cmovb  %edi,%eax\n  movd   %xmm2,%edi\n  cmp    %edi,%eax\n  movd   %xmm5,%eax\n  mov    %r13d,%edi\n  cmovae %r11d,%eax\n  cmp    %r13d,%esi\n  je     L4\nL15:\n  movslq %edi,%r11\n  cmpl   $0x1,(%rdx,%r11,4)\n  lea    0x0(,%r11,4),%r9\n  lea    0x1(%rdi),%r11d\n  cmove  %edi,%r8d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    L4\n  cmpl   $0x1,0x4(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x2(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    L4\n  cmpl   $0x1,0x8(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x3(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %esi,%r11d\n  jge    L4\n  cmpl   $0x1,0xc(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x4(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    L4\n  cmpl   $0x1,0x10(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x5(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %esi,%r11d\n  jge    L4\n  cmpl   $0x1,0x14(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  lea    0x6(%rdi),%r11d\n  cmove  %r10d,%eax\n  cmp    %r11d,%esi\n  jle    L4\n  cmpl   $0x1,0x18(%rdx,%r9,1)\n  cmove  %r11d,%r8d\n  cmove  %r10d,%eax\n  add    $0x7,%edi\n  cmp    %edi,%esi\n  jle    L4\n  cmpl   $0x1,0x1c(%rdx,%r9,1)\n  cmove  %edi,%r8d\n  cmove  %r10d,%eax\nL4:\n  add    $0x1,%rcx\n  cmp    %rbp,%rcx\n  jne    L5\nL0:\n  mov    %esi,%ebx\n  imul   %esi,%ebx\n  test   %eax,%eax\n  jle    L6\n  movslq %eax,%rcx\n  movslq %r8d,%rdx\n  mov    -0x8(%r12,%rcx,8),%rcx\n  mov    (%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\nL6:\n  cmp    %eax,%r15d\n  jle    L7\n  lea    0x1(%rax),%ecx\n  movslq %r8d,%rdx\n  movslq %ecx,%rcx\n  mov    (%r12,%rcx,8),%rcx\n  mov    (%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\nL7:\n  test   %r8d,%r8d\n  jle    L8\n  movslq %eax,%rcx\n  movslq %r8d,%rdx\n  mov    (%r12,%rcx,8),%rcx\n  mov    -0x4(%rcx,%rdx,4),%edx\n  cmp    %edx,%ebx\n  cmovg  %edx,%ebx\nL8:\n  cmp    %r8d,%r15d\n  jle    L9\n  cltq\n  lea    0x1(%r8),%edx\n  mov    (%r12,%rax,8),%rax\n  movslq %edx,%rdx\n  mov    (%rax,%rdx,4),%eax\n  cmp    %eax,%ebx\n  cmovg  %eax,%ebx\nL9:\n  movslq 0x4(%rsp),%rdi\n  mov    0x8(%rsp),%rax\n  mov    %edi,(%rax)\n  mov    %rdi,%r14\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  test   %r14d,%r14d\n  jle    L10\n  lea    -0x1(%r14),%eax\n  cmp    $0x2,%eax\n  jbe    L11\n  movd   %ebx,%xmm7\n  shr    $0x2,%r14d\n  mov    %r8,%rax\n  pxor   %xmm4,%xmm4\n  mov    %r14d,%edx\n  movdqa D2(%rip),%xmm1\n  movdqa D0(%rip),%xmm5\n  pshufd $0x0,%xmm7,%xmm6\n  shl    $0x4,%rdx\n  movdqa D1(%rip),%xmm2\n  add    %r8,%rdx\n  nopw   0x0(%rax,%rax,1)\nL12:\n  movdqa %xmm1,%xmm0\n  movdqa %xmm2,%xmm3\n  paddd  %xmm5,%xmm1\n  add    $0x10,%rax\n  pand   %xmm2,%xmm0\n  pcmpeqd %xmm4,%xmm0\n  pand   %xmm0,%xmm3\n  pandn  %xmm6,%xmm0\n  por    %xmm3,%xmm0\n  movups %xmm0,-0x10(%rax)\n  cmp    %rdx,%rax\n  jne    L12\n  mov    0x4(%rsp),%esi\n  mov    %esi,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%sil\n  je     L10\n  movslq %eax,%rcx\n  add    $0x1,%eax\n  movl   $0x1,(%r8,%rcx,4)\n  lea    0x0(,%rcx,4),%rdx\n  cmp    %eax,%esi\n  jle    L10\n  add    $0x4,%rdx\n  mov    $0x1,%ecx\n  lea    (%r8,%rdx,1),%rsi\n  test   $0x1,%al\n  jne    L13\nL16:\n  mov    %ecx,(%rsi)\n  add    $0x1,%eax\n  cmp    %eax,0x4(%rsp)\n  jle    L10\n  test   $0x1,%al\n  mov    $0x1,%eax\n  cmove  %eax,%ebx\n  mov    %ebx,0x4(%r8,%rdx,1)\nL10:\n  add    $0x18,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL3:\n  movdqa %xmm5,%xmm0\n  punpckhdq %xmm5,%xmm0\n  movd   %xmm0,%r11d\n  jmp    L14\n  nopw   0x0(%rax,%rax,1)\nL1:\n  xor    %edi,%edi\n  jmp    L15\nL11:\n  cmpl   $0x1,0x4(%rsp)\n  movl   $0x1,(%r8)\n  jle    L10\n  lea    0x4(%r8),%rsi\n  mov    $0x1,%eax\n  mov    $0x4,%edx\nL13:\n  mov    %ebx,%ecx\n  jmp    L16",
        "num_missing": 4,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8224,
                "bias": [
                    3785,
                    3005
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8240,
                "bias": [
                    3776,
                    3004
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8208,
                "bias": [
                    3674,
                    2997
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8192,
                "bias": [
                    3644
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5032
            },
            "L1": {
                "label": "L1",
                "addr": 5424
            },
            "L2": {
                "label": "L2",
                "addr": 4552
            },
            "L3": {
                "label": "L3",
                "addr": 5400
            },
            "L4": {
                "label": "L4",
                "addr": 5019
            },
            "L5": {
                "label": "L5",
                "addr": 4480
            },
            "L6": {
                "label": "L6",
                "addr": 5060
            },
            "L7": {
                "label": "L7",
                "addr": 5086
            },
            "L8": {
                "label": "L8",
                "addr": 5110
            },
            "L9": {
                "label": "L9",
                "addr": 5136
            },
            "L10": {
                "label": "L10",
                "addr": 5377
            },
            "L11": {
                "label": "L11",
                "addr": 5431
            },
            "L12": {
                "label": "L12",
                "addr": 5248
            },
            "L13": {
                "label": "L13",
                "addr": 5459
            },
            "L14": {
                "label": "L14",
                "addr": 4791
            },
            "L15": {
                "label": "L15",
                "addr": 4832
            },
            "L16": {
                "label": "L16",
                "addr": 5351
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "01000000020000000300000004000000000000000100000002000000030000000400000004000000040000000400000001000000010000000100000001000000",
        "rodata_parsed": {
            "func0": {
                "0x2020": {
                    "type": "byte[16]",
                    "value": [
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0
                    ]
                },
                "0x2030": {
                    "type": "byte[16]",
                    "value": [
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0
                    ]
                },
                "0x2010": {
                    "type": "byte[16]",
                    "value": [
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        2,
                        0,
                        0,
                        0,
                        3,
                        0,
                        0,
                        0
                    ]
                },
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        1,
                        0,
                        0,
                        0,
                        2,
                        0,
                        0,
                        0,
                        3,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 130,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1050 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movl   $0x1,(%rax)\n  cmpl   $0x0,-0x14(%rbp)\n  jne    1159 <func0+0x40>\n  mov    -0x8(%rbp),%rax\n  jmp    1214 <func0+0xfb>\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x3,(%rax)\n  movl   $0x2,-0xc(%rbp)\n  jmp    1204 <func0+0xeb>\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    11a6 <func0+0x8d>\n  mov    -0xc(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  jmp    1200 <func0+0xe7>\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x8(%rax),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  lea    0x1(%rax),%edx\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  sar    %eax\n  mov    %eax,%esi\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    %esi,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    1173 <func0+0x5a>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %edi,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  movl   $0x1,(%rax)\n  cmpl   $0x0,-0x14(%rbp)\n  jne    L0\n  mov    -0x8(%rbp),%rax\n  jmp    L1\nL0:\n  mov    -0x8(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x3,(%rax)\n  movl   $0x2,-0xc(%rbp)\n  jmp    L2\nL5:\n  mov    -0xc(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L3\n  mov    -0xc(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  jmp    L4\nL3:\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0xc(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x8(%rax),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  add    %edx,%eax\n  lea    0x1(%rax),%edx\n  mov    -0xc(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,%ecx\n  shr    $0x1f,%ecx\n  add    %ecx,%eax\n  sar    %eax\n  mov    %eax,%esi\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  add    %esi,%edx\n  mov    %edx,(%rax)\nL4:\n  addl   $0x1,-0xc(%rbp)\nL2:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jle    L5\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4441
            },
            "L1": {
                "label": "L1",
                "addr": 4628
            },
            "L2": {
                "label": "L2",
                "addr": 4612
            },
            "L3": {
                "label": "L3",
                "addr": 4518
            },
            "L4": {
                "label": "L4",
                "addr": 4608
            },
            "L5": {
                "label": "L5",
                "addr": 4467
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 130,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  lea    0x1(%rdi),%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     118a <func0+0x71>\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    118a <func0+0x71>\n  lea    0x1(%rbx),%r8d\n  mov    $0x2,%edx\n  jmp    1174 <func0+0x5b>\n  mov    -0x8(%rax,%rdx,4),%esi\n  add    -0x4(%rax,%rdx,4),%esi\n  lea    0x1(%rdx),%edi\n  mov    %edi,%ecx\n  shr    $0x1f,%ecx\n  add    %edi,%ecx\n  sar    %ecx\n  lea    0x1(%rsi,%rcx,1),%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  add    $0x1,%rdx\n  cmp    %r8,%rdx\n  je     118a <func0+0x71>\n  test   $0x1,%dl\n  jne    1150 <func0+0x37>\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  add    %edx,%ecx\n  sar    %ecx\n  add    $0x1,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  jmp    116b <func0+0x52>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  lea    0x1(%rdi),%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     L0\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  lea    0x1(%rbx),%r8d\n  mov    $0x2,%edx\n  jmp    L1\nL2:\n  mov    -0x8(%rax,%rdx,4),%esi\n  add    -0x4(%rax,%rdx,4),%esi\n  lea    0x1(%rdx),%edi\n  mov    %edi,%ecx\n  shr    $0x1f,%ecx\n  add    %edi,%ecx\n  sar    %ecx\n  lea    0x1(%rsi,%rcx,1),%ecx\n  mov    %ecx,(%rax,%rdx,4)\nL3:\n  add    $0x1,%rdx\n  cmp    %r8,%rdx\n  je     L0\nL1:\n  test   $0x1,%dl\n  jne    L2\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  add    %edx,%ecx\n  sar    %ecx\n  add    $0x1,%ecx\n  mov    %ecx,(%rax,%rdx,4)\n  jmp    L3\nL0:\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4490
            },
            "L1": {
                "label": "L1",
                "addr": 4468
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4459
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 130,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     119b <func0+0x7b>\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    119b <func0+0x7b>\n  mov    %rax,%rcx\n  mov    $0x2,%edx\n  jmp    1172 <func0+0x52>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    %esi,%edi\n  add    $0x4,%rcx\n  sar    %edi\n  add    $0x1,%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  je     119b <func0+0x7b>\n  mov    %edx,%edi\n  mov    %edx,%esi\n  add    $0x1,%edx\n  and    $0x1,%edi\n  test   %edi,%edi\n  je     1160 <func0+0x40>\n  mov    %edx,%r8d\n  mov    (%rcx),%edi\n  add    0x4(%rcx),%edi\n  add    $0x4,%rcx\n  sar    %r8d\n  lea    0x1(%rdi,%r8,1),%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  jne    1172 <func0+0x52>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     L0\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  mov    %rax,%rcx\n  mov    $0x2,%edx\n  jmp    L1\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  mov    %esi,%edi\n  add    $0x4,%rcx\n  sar    %edi\n  add    $0x1,%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  je     L0\nL1:\n  mov    %edx,%edi\n  mov    %edx,%esi\n  add    $0x1,%edx\n  and    $0x1,%edi\n  test   %edi,%edi\n  je     L2\n  mov    %edx,%r8d\n  mov    (%rcx),%edi\n  add    0x4(%rcx),%edi\n  add    $0x4,%rcx\n  sar    %r8d\n  lea    0x1(%rdi,%r8,1),%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4507
            },
            "L1": {
                "label": "L1",
                "addr": 4466
            },
            "L2": {
                "label": "L2",
                "addr": 4448
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 130,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint* func0(int n) {\n    int* out = (int*)malloc((n + 1) * sizeof(int));\n    out[0] = 1;\n    if (n == 0) return out;\n    out[1] = 3;\n    for (int i = 2; i <= n; i++) {\n        if (i % 2 == 0) out[i] = 1 + i / 2;\n        else out[i] = out[i - 1] + out[i - 2] + 1 + (i + 1) / 2;\n    }\n    return out;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n\n\nint issame(int* a, int* b, int size) {\n    for (int i = 0; i < size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n\n    int tri_3[] = {1, 3, 2, 8};\n    size = 4;\n    int* out3 = func0(3);\n    assert(issame(out3, tri_3, size));\n    free(out3);\n\n    int tri_4[] = {1, 3, 2, 8, 3};\n    size = 5;\n    int* out4 = func0(4);\n    assert(issame(out4, tri_4, size));\n    free(out4);\n\n    int tri_5[] = {1, 3, 2, 8, 3, 15};\n    size = 6;\n    int* out5 = func0(5);\n    assert(issame(out5, tri_5, size));\n    free(out5);\n\n    int tri_6[] = {1, 3, 2, 8, 3, 15, 4};\n    size = 7;\n    int* out6 = func0(6);\n    assert(issame(out6, tri_6, size));\n    free(out6);\n\n    int tri_7[] = {1, 3, 2, 8, 3, 15, 4, 24};\n    size = 8;\n    int* out7 = func0(7);\n    assert(issame(out7, tri_7, size));\n    free(out7);\n\n    int tri_8[] = {1, 3, 2, 8, 3, 15, 4, 24, 5};\n    size = 9;\n    int* out8 = func0(8);\n    assert(issame(out8, tri_8, size));\n    free(out8);\n\n    int tri_9[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35};\n    size = 10;\n    int* out9 = func0(9);\n    assert(issame(out9, tri_9, size));\n    free(out9);\n\n    int tri_20[] = {1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11};\n    size = 21;\n    int* out20 = func0(20);\n    assert(issame(out20, tri_20, size));\n    free(out20);\n\n    int tri_0[] = {1};\n    size = 1;\n    int* out0 = func0(0);\n    assert(issame(out0, tri_0, size));\n    free(out0);\n\n    int tri_1[] = {1, 3};\n    size = 2;\n    int* out1 = func0(1);\n    assert(issame(out1, tri_1, size));\n    free(out1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1050 <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     119b <func0+0x7b>\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    119b <func0+0x7b>\n  mov    %rax,%rcx\n  mov    $0x2,%edx\n  jmp    1172 <func0+0x52>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    %esi,%edi\n  add    $0x4,%rcx\n  sar    %edi\n  add    $0x1,%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  je     119b <func0+0x7b>\n  mov    %edx,%edi\n  mov    %edx,%esi\n  add    $0x1,%edx\n  and    $0x1,%edi\n  test   %edi,%edi\n  je     1160 <func0+0x40>\n  mov    %edx,%r8d\n  mov    (%rcx),%edi\n  add    0x4(%rcx),%edi\n  add    $0x4,%rcx\n  sar    %r8d\n  lea    0x1(%rdi,%r8,1),%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  jne    1172 <func0+0x52>\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %edi,%ebx\n  add    $0x1,%edi\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  movl   $0x1,(%rax)\n  test   %ebx,%ebx\n  je     L0\n  movl   $0x3,0x4(%rax)\n  cmp    $0x1,%ebx\n  jle    L0\n  mov    %rax,%rcx\n  mov    $0x2,%edx\n  jmp    L1\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  mov    %esi,%edi\n  add    $0x4,%rcx\n  sar    %edi\n  add    $0x1,%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  je     L0\nL1:\n  mov    %edx,%edi\n  mov    %edx,%esi\n  add    $0x1,%edx\n  and    $0x1,%edi\n  test   %edi,%edi\n  je     L2\n  mov    %edx,%r8d\n  mov    (%rcx),%edi\n  add    0x4(%rcx),%edi\n  add    $0x4,%rcx\n  sar    %r8d\n  lea    0x1(%rdi,%r8,1),%edi\n  mov    %edi,0x4(%rcx)\n  cmp    %esi,%ebx\n  jne    L1\nL0:\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4507
            },
            "L1": {
                "label": "L1",
                "addr": 4466
            },
            "L2": {
                "label": "L2",
                "addr": 4448
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 131,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    1183 <func0+0x8a>\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1163 <func0+0x6a>\n  movl   $0x1,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     1114 <func0+0x1b>\n  cmpl   $0x0,-0x8(%rbp)\n  je     1194 <func0+0x9b>\n  mov    -0xc(%rbp),%eax\n  jmp    1199 <func0+0xa0>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  movl   $0x1,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  jmp    L0\nL2:\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  movl   $0x1,-0x8(%rbp)\n  mov    -0xc(%rbp),%eax\n  imul   -0x4(%rbp),%eax\n  mov    %eax,-0xc(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\nL0:\n  cmpl   $0x0,-0x14(%rbp)\n  jg     L2\n  cmpl   $0x0,-0x8(%rbp)\n  je     L3\n  mov    -0xc(%rbp),%eax\n  jmp    L4\nL3:\n  mov    $0x0,%eax\nL4:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4483
            },
            "L1": {
                "label": "L1",
                "addr": 4451
            },
            "L2": {
                "label": "L2",
                "addr": 4372
            },
            "L3": {
                "label": "L3",
                "addr": 4500
            },
            "L4": {
                "label": "L4",
                "addr": 4505
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 131,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  test   %edi,%edi\n  jle    116e <func0+0x75>\n  mov    $0x0,%edi\n  mov    $0x1,%esi\n  jmp    112b <func0+0x32>\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    1166 <func0+0x6d>\n  mov    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,%r8d\n  shr    $0x1f,%r8d\n  lea    (%rax,%r8,1),%ecx\n  and    $0x1,%ecx\n  sub    %r8d,%ecx\n  cmp    $0x1,%ecx\n  jne    110f <func0+0x16>\n  imul   %eax,%esi\n  mov    %ecx,%edi\n  jmp    110f <func0+0x16>\n  test   %edi,%edi\n  cmove  %edi,%esi\n  mov    %esi,%eax\n  ret\n  mov    $0x0,%esi\n  jmp    116b <func0+0x72>",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  test   %edi,%edi\n  jle    L0\n  mov    $0x0,%edi\n  mov    $0x1,%esi\n  jmp    L1\nL3:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    L2\n  mov    %eax,%edx\nL1:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  lea    (%rax,%rax,4),%ecx\n  add    %ecx,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,%r8d\n  shr    $0x1f,%r8d\n  lea    (%rax,%r8,1),%ecx\n  and    $0x1,%ecx\n  sub    %r8d,%ecx\n  cmp    $0x1,%ecx\n  jne    L3\n  imul   %eax,%esi\n  mov    %ecx,%edi\n  jmp    L3\nL2:\n  test   %edi,%edi\n  cmove  %edi,%esi\nL4:\n  mov    %esi,%eax\n  ret\nL0:\n  mov    $0x0,%esi\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4462
            },
            "L1": {
                "label": "L1",
                "addr": 4395
            },
            "L2": {
                "label": "L2",
                "addr": 4454
            },
            "L3": {
                "label": "L3",
                "addr": 4367
            },
            "L4": {
                "label": "L4",
                "addr": 4459
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 131,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  test   %edi,%edi\n  jle    115a <func0+0x5a>\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%esi\n  jmp    1122 <func0+0x22>\n  nopl   0x0(%rax,%rax,1)\n  mov    %eax,%edi\n  mov    %edi,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%ecx\n  mov    %edi,%edx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  mov    %edi,%ecx\n  and    $0x1,%ecx\n  je     1146 <func0+0x46>\n  imul   %edx,%r9d\n  mov    %ecx,%r8d\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x9,%edi\n  jg     1120 <func0+0x20>\n  test   %r8d,%r8d\n  cmovne %r9d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  test   %edi,%edi\n  jle    L0\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%esi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    %eax,%edi\nL1:\n  mov    %edi,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%ecx\n  mov    %edi,%edx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  mov    %edi,%ecx\n  and    $0x1,%ecx\n  je     L2\n  imul   %edx,%r9d\n  mov    %ecx,%r8d\nL2:\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x9,%edi\n  jg     L3\n  test   %r8d,%r8d\n  cmovne %r9d,%r8d\nL0:\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4442
            },
            "L1": {
                "label": "L1",
                "addr": 4386
            },
            "L2": {
                "label": "L2",
                "addr": 4422
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 131,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    int prod = 1, has_odd = 0, digit;\n    while (n > 0) {\n        digit = n % 10;\n        if (digit % 2 == 1) {\n            has_odd = 1;\n            prod *= digit;\n        }\n        n /= 10;\n    }\n    return has_odd ? prod : 0;\n}",
        "c_test": "#include <assert.h>\n\nint main(){\n    assert(func0(5) == 5);\n    assert(func0(54) == 5);\n    assert(func0(120) == 1);\n    assert(func0(5014) == 5);\n    assert(func0(98765) == 315);\n    assert(func0(5576543) == 2625);\n    assert(func0(2468) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  test   %edi,%edi\n  jle    115a <func0+0x5a>\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%esi\n  jmp    1122 <func0+0x22>\n  nopl   0x0(%rax,%rax,1)\n  mov    %eax,%edi\n  mov    %edi,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%ecx\n  mov    %edi,%edx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  mov    %edi,%ecx\n  and    $0x1,%ecx\n  je     1146 <func0+0x46>\n  imul   %edx,%r9d\n  mov    %ecx,%r8d\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x9,%edi\n  jg     1120 <func0+0x20>\n  test   %r8d,%r8d\n  cmovne %r9d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  test   %edi,%edi\n  jle    L0\n  mov    $0x1,%r9d\n  mov    $0xcccccccd,%esi\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  mov    %eax,%edi\nL1:\n  mov    %edi,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rdx\n  shr    $0x23,%rdx\n  lea    (%rdx,%rdx,4),%ecx\n  mov    %edi,%edx\n  add    %ecx,%ecx\n  sub    %ecx,%edx\n  mov    %edi,%ecx\n  and    $0x1,%ecx\n  je     L2\n  imul   %edx,%r9d\n  mov    %ecx,%r8d\nL2:\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x9,%edi\n  jg     L3\n  test   %r8d,%r8d\n  cmovne %r9d,%r8d\nL0:\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4442
            },
            "L1": {
                "label": "L1",
                "addr": 4386
            },
            "L2": {
                "label": "L2",
                "addr": 4422
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 132,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11a2 <func0+0x89>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5b,%al\n  jne    1159 <func0+0x40>\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5d,%al\n  jne    1171 <func0+0x58>\n  subl   $0x1,-0x1c(%rbp)\n  cmpl   $0x0,-0x1c(%rbp)\n  jns    117e <func0+0x65>\n  movl   $0x0,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    118c <func0+0x73>\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jge    119e <func0+0x85>\n  mov    $0x1,%eax\n  jmp    11be <func0+0xa5>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     1141 <func0+0x28>\n  mov    $0x0,%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL7:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5b,%al\n  jne    L1\n  addl   $0x1,-0x1c(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x5d,%al\n  jne    L2\n  subl   $0x1,-0x1c(%rbp)\nL2:\n  cmpl   $0x0,-0x1c(%rbp)\n  jns    L3\n  movl   $0x0,-0x1c(%rbp)\nL3:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    L4\n  mov    -0x1c(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\nL4:\n  mov    -0x18(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x1c(%rbp)\n  jge    L5\n  mov    $0x1,%eax\n  jmp    L6\nL5:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L7\n  mov    $0x0,%eax\nL6:\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4514
            },
            "L1": {
                "label": "L1",
                "addr": 4441
            },
            "L2": {
                "label": "L2",
                "addr": 4465
            },
            "L3": {
                "label": "L3",
                "addr": 4478
            },
            "L4": {
                "label": "L4",
                "addr": 4492
            },
            "L5": {
                "label": "L5",
                "addr": 4510
            },
            "L6": {
                "label": "L6",
                "addr": 4542
            },
            "L7": {
                "label": "L7",
                "addr": 4417
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 132,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdx\n  lea    (%rbx,%rax,1),%rdi\n  mov    $0x0,%ecx\n  mov    $0x0,%eax\n  jmp    1156 <func0+0x3d>\n  add    $0x1,%eax\n  test   %eax,%eax\n  mov    $0x0,%esi\n  cmovs  %esi,%eax\n  cmp    %eax,%ecx\n  cmovl  %eax,%ecx\n  add    $0x1,%rdx\n  lea    -0x1(%rcx),%esi\n  cmp    %esi,%eax\n  jl     117b <func0+0x62>\n  cmp    %rdi,%rdx\n  je     1174 <func0+0x5b>\n  movzbl (%rdx),%esi\n  cmp    $0x5b,%sil\n  je     1139 <func0+0x20>\n  cmp    $0x5d,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    113c <func0+0x23>\n  mov    $0x0,%eax\n  pop    %rbx\n  ret\n  mov    $0x1,%eax\n  jmp    1179 <func0+0x60>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdx\n  lea    (%rbx,%rax,1),%rdi\n  mov    $0x0,%ecx\n  mov    $0x0,%eax\n  jmp    L0\nL3:\n  add    $0x1,%eax\nL4:\n  test   %eax,%eax\n  mov    $0x0,%esi\n  cmovs  %esi,%eax\n  cmp    %eax,%ecx\n  cmovl  %eax,%ecx\n  add    $0x1,%rdx\n  lea    -0x1(%rcx),%esi\n  cmp    %esi,%eax\n  jl     L1\nL0:\n  cmp    %rdi,%rdx\n  je     L2\n  movzbl (%rdx),%esi\n  cmp    $0x5b,%sil\n  je     L3\n  cmp    $0x5d,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  sub    %esi,%eax\n  jmp    L4\nL2:\n  mov    $0x0,%eax\nL5:\n  pop    %rbx\n  ret\nL1:\n  mov    $0x1,%eax\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4438
            },
            "L1": {
                "label": "L1",
                "addr": 4475
            },
            "L2": {
                "label": "L2",
                "addr": 4468
            },
            "L3": {
                "label": "L3",
                "addr": 4409
            },
            "L4": {
                "label": "L4",
                "addr": 4412
            },
            "L5": {
                "label": "L5",
                "addr": 4473
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 132,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  add    %rbx,%rax\n  jmp    115d <func0+0x3d>\n  nopl   0x0(%rax)\n  cmp    $0x5d,%sil\n  jne    114d <func0+0x2d>\n  sub    $0x1,%edx\n  jae    114d <func0+0x2d>\n  xor    %edx,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jg     117e <func0+0x5e>\n  cmp    %rdi,%rax\n  je     1188 <func0+0x68>\n  movzbl (%rdi),%esi\n  cmp    $0x5b,%sil\n  jne    1140 <func0+0x20>\n  add    $0x1,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jle    115d <func0+0x3d>\n  mov    $0x1,%eax\n  pop    %rbx\n  ret\n  nopl   (%rax)\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  add    %rbx,%rax\n  jmp    L0\n  nopl   0x0(%rax)\nL4:\n  cmp    $0x5d,%sil\n  jne    L1\n  sub    $0x1,%edx\n  jae    L1\n  xor    %edx,%edx\nL1:\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jg     L2\nL0:\n  cmp    %rdi,%rax\n  je     L3\n  movzbl (%rdi),%esi\n  cmp    $0x5b,%sil\n  jne    L4\n  add    $0x1,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jle    L0\nL2:\n  mov    $0x1,%eax\n  pop    %rbx\n  ret\n  nopl   (%rax)\nL3:\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4445
            },
            "L1": {
                "label": "L1",
                "addr": 4429
            },
            "L2": {
                "label": "L2",
                "addr": 4478
            },
            "L3": {
                "label": "L3",
                "addr": 4488
            },
            "L4": {
                "label": "L4",
                "addr": 4416
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 132,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nint func0(const char *str) {\n    int count = 0, maxcount = 0;\n    for (int i = 0; i < strlen(str); i++) {\n        if (str[i] == '[') count += 1;\n        if (str[i] == ']') count -= 1;\n        if (count < 0) count = 0;\n        if (count > maxcount) maxcount = count;\n        if (count <= maxcount - 2) return 1;\n    }\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint func0(const char *str);\n\nint main() {\n    assert(func0(\"[[]]\") == 1);\n    assert(func0(\"[]]]]]]][[[[[]\") == 0);\n    assert(func0(\"[][]\") == 0);\n    assert(func0(\"[]\") == 0);\n    assert(func0(\"[[[[]]]]\") == 1);\n    assert(func0(\"[]]]]]]]]]]\") == 0);\n    assert(func0(\"[][][[]]\") == 1);\n    assert(func0(\"[[]\") == 0);\n    assert(func0(\"[]]\") == 0);\n    assert(func0(\"[[]][[\") == 1);\n    assert(func0(\"[[][]]\") == 1);\n    assert(func0(\"\") == 0);\n    assert(func0(\"[[[[[[[[\") == 0);\n    assert(func0(\"]]]]]]]]\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1050 <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  add    %rbx,%rax\n  jmp    115d <func0+0x3d>\n  nopl   0x0(%rax)\n  cmp    $0x5d,%sil\n  jne    114d <func0+0x2d>\n  sub    $0x1,%edx\n  jae    114d <func0+0x2d>\n  xor    %edx,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jg     117e <func0+0x5e>\n  cmp    %rdi,%rax\n  je     1188 <func0+0x68>\n  movzbl (%rdi),%esi\n  cmp    $0x5b,%sil\n  jne    1140 <func0+0x20>\n  add    $0x1,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jle    115d <func0+0x3d>\n  mov    $0x1,%eax\n  pop    %rbx\n  ret\n  nopl   (%rax)\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rbx,%rdi\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  add    %rbx,%rax\n  jmp    L0\n  nopl   0x0(%rax)\nL4:\n  cmp    $0x5d,%sil\n  jne    L1\n  sub    $0x1,%edx\n  jae    L1\n  xor    %edx,%edx\nL1:\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jg     L2\nL0:\n  cmp    %rdi,%rax\n  je     L3\n  movzbl (%rdi),%esi\n  cmp    $0x5b,%sil\n  jne    L4\n  add    $0x1,%edx\n  cmp    %edx,%ecx\n  cmovl  %edx,%ecx\n  add    $0x1,%rdi\n  lea    -0x1(%rcx),%esi\n  cmp    %edx,%esi\n  jle    L0\nL2:\n  mov    $0x1,%eax\n  pop    %rbx\n  ret\n  nopl   (%rax)\nL3:\n  xor    %eax,%eax\n  pop    %rbx\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4445
            },
            "L1": {
                "label": "L1",
                "addr": 4429
            },
            "L2": {
                "label": "L2",
                "addr": 4478
            },
            "L3": {
                "label": "L3",
                "addr": 4488
            },
            "L4": {
                "label": "L4",
                "addr": 4416
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 133,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11ad <func0+0x94>\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movq   %xmm1,%rax\n  movq   %rax,%xmm0\n  call   1050 <ceil@plt>\n  cvttsd2si %xmm0,%ebx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  movq   %xmm2,%rax\n  movq   %rax,%xmm0\n  call   1050 <ceil@plt>\n  cvttsd2si %xmm0,%eax\n  imul   %ebx,%eax\n  add    %eax,-0x18(%rbp)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     113d <func0+0x24>\n  mov    -0x18(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL1:\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movq   %xmm1,%rax\n  movq   %rax,%xmm0\n  call   <ceil@plt>\n  cvttsd2si %xmm0,%ebx\n  mov    -0x14(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  movq   %xmm2,%rax\n  movq   %rax,%xmm0\n  call   <ceil@plt>\n  cvttsd2si %xmm0,%eax\n  imul   %ebx,%eax\n  add    %eax,-0x18(%rbp)\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L1\n  mov    -0x18(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4525
            },
            "L1": {
                "label": "L1",
                "addr": 4413
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 133,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1172 <func0+0x79>\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rsi\n  mov    $0x0,%ecx\n  movss  0xee7(%rip),%xmm4        # 2000 <_fini+0xe84>\n  movss  0xeef(%rip),%xmm3        # 2010 <_fini+0xe94>\n  movss  0xedb(%rip),%xmm5        # 2004 <_fini+0xe88>\n  jmp    113d <func0+0x44>\n  cvttss2si %xmm2,%eax\n  imul   %eax,%eax\n  add    %eax,%ecx\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  je     1177 <func0+0x7e>\n  movss  (%rdx),%xmm1\n  movaps %xmm1,%xmm2\n  movaps %xmm1,%xmm0\n  andps  %xmm3,%xmm0\n  ucomiss %xmm0,%xmm4\n  jbe    112b <func0+0x32>\n  cvttss2si %xmm1,%eax\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  cmpnless %xmm0,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm0\n  movaps %xmm3,%xmm2\n  andnps %xmm1,%xmm2\n  orps   %xmm0,%xmm2\n  jmp    112b <func0+0x32>\n  mov    $0x0,%ecx\n  mov    %ecx,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rsi\n  mov    $0x0,%ecx\n  movss  D0(%rip),%xmm4\n  movss  D1(%rip),%xmm3\n  movss  D2(%rip),%xmm5\n  jmp    L1\nL3:\n  cvttss2si %xmm2,%eax\n  imul   %eax,%eax\n  add    %eax,%ecx\n  add    $0x4,%rdx\n  cmp    %rsi,%rdx\n  je     L2\nL1:\n  movss  (%rdx),%xmm1\n  movaps %xmm1,%xmm2\n  movaps %xmm1,%xmm0\n  andps  %xmm3,%xmm0\n  ucomiss %xmm0,%xmm4\n  jbe    L3\n  cvttss2si %xmm1,%eax\n  pxor   %xmm0,%xmm0\n  cvtsi2ss %eax,%xmm0\n  cmpnless %xmm0,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm0\n  movaps %xmm3,%xmm2\n  andnps %xmm1,%xmm2\n  orps   %xmm0,%xmm2\n  jmp    L3\nL0:\n  mov    $0x0,%ecx\nL2:\n  mov    %ecx,%eax\n  ret",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3815
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3823
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8196,
                "bias": [
                    3803
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4466
            },
            "L1": {
                "label": "L1",
                "addr": 4413
            },
            "L2": {
                "label": "L2",
                "addr": 4471
            },
            "L3": {
                "label": "L3",
                "addr": 4395
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000004b0000803f0000000000000000ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        0,
                        75
                    ]
                },
                "0x2010": {
                    "type": "byte[4]",
                    "value": [
                        255,
                        255,
                        255,
                        127
                    ]
                },
                "0x2004": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        128,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 133,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1180 <func0+0x80>\n  lea    -0x1(%rsi),%eax\n  movss  0xeed(%rip),%xmm4        # 2000 <_fini+0xe78>\n  xor    %r8d,%r8d\n  movss  0xef2(%rip),%xmm3        # 2010 <_fini+0xe88>\n  movss  0xede(%rip),%xmm5        # 2004 <_fini+0xe7c>\n  lea    0x4(%rdi,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rdi),%xmm0\n  movaps %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  ucomiss %xmm1,%xmm4\n  jbe    1166 <func0+0x66>\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  movaps %xmm0,%xmm2\n  cvtsi2ss %eax,%xmm1\n  cmpnless %xmm1,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm1\n  movaps %xmm3,%xmm2\n  andnps %xmm0,%xmm2\n  movaps %xmm1,%xmm0\n  orps   %xmm2,%xmm0\n  cvttss2si %xmm0,%eax\n  add    $0x4,%rdi\n  imul   %eax,%eax\n  add    %eax,%r8d\n  cmp    %rdx,%rdi\n  jne    1130 <func0+0x30>\n  mov    %r8d,%eax\n  ret\n  nopl   (%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movss  D0(%rip),%xmm4\n  xor    %r8d,%r8d\n  movss  D1(%rip),%xmm3\n  movss  D2(%rip),%xmm5\n  lea    0x4(%rdi,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\nL2:\n  movss  (%rdi),%xmm0\n  movaps %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  ucomiss %xmm1,%xmm4\n  jbe    L1\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  movaps %xmm0,%xmm2\n  cvtsi2ss %eax,%xmm1\n  cmpnless %xmm1,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm1\n  movaps %xmm3,%xmm2\n  andnps %xmm0,%xmm2\n  movaps %xmm1,%xmm0\n  orps   %xmm2,%xmm0\nL1:\n  cvttss2si %xmm0,%eax\n  add    $0x4,%rdi\n  imul   %eax,%eax\n  add    %eax,%r8d\n  cmp    %rdx,%rdi\n  jne    L2\n  mov    %r8d,%eax\n  ret\n  nopl   (%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3821
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3826
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8196,
                "bias": [
                    3806
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4480
            },
            "L1": {
                "label": "L1",
                "addr": 4454
            },
            "L2": {
                "label": "L2",
                "addr": 4400
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000004b0000803f0000000000000000ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        0,
                        75
                    ]
                },
                "0x2010": {
                    "type": "byte[4]",
                    "value": [
                        255,
                        255,
                        255,
                        127
                    ]
                },
                "0x2004": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        128,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 133,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float *lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        sum += (int)ceil(lst[i]) * (int)ceil(lst[i]);\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\n\nint main() {\n    float lst1[] = {1, 2, 3};\n    assert(func0(lst1, 3) == 14);\n\n    float lst2[] = {1.0, 2, 3};\n    assert(func0(lst2, 3) == 14);\n\n    float lst3[] = {1, 3, 5, 7};\n    assert(func0(lst3, 4) == 84);\n\n    float lst4[] = {1.4, 4.2, 0};\n    assert(func0(lst4, 3) == 29);\n\n    float lst5[] = {-2.4, 1, 1};\n    assert(func0(lst5, 3) == 6);\n\n    float lst6[] = {100, 1, 15, 2};\n    assert(func0(lst6, 4) == 10230);\n\n    float lst7[] = {10000, 10000};\n    assert(func0(lst7, 2) == 200000000);\n\n    float lst8[] = {-1.4, 4.6, 6.3};\n    assert(func0(lst8, 3) == 75);\n\n    float lst9[] = {-1.4, 17.9, 18.9, 19.9};\n    assert(func0(lst9, 4) == 1086);\n\n    float lst10[] = {0};\n    assert(func0(lst10, 1) == 0);\n\n    float lst11[] = {-1};\n    assert(func0(lst11, 1) == 1);\n\n    float lst12[] = {-1, 1, 0};\n    assert(func0(lst12, 3) == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1180 <func0+0x80>\n  lea    -0x1(%rsi),%eax\n  movss  0xeed(%rip),%xmm4        # 2000 <_fini+0xe78>\n  xor    %r8d,%r8d\n  movss  0xef2(%rip),%xmm3        # 2010 <_fini+0xe88>\n  movss  0xede(%rip),%xmm5        # 2004 <_fini+0xe7c>\n  lea    0x4(%rdi,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\n  movss  (%rdi),%xmm0\n  movaps %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  ucomiss %xmm1,%xmm4\n  jbe    1166 <func0+0x66>\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  movaps %xmm0,%xmm2\n  cvtsi2ss %eax,%xmm1\n  cmpnless %xmm1,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm1\n  movaps %xmm3,%xmm2\n  andnps %xmm0,%xmm2\n  movaps %xmm1,%xmm0\n  orps   %xmm2,%xmm0\n  cvttss2si %xmm0,%eax\n  add    $0x4,%rdi\n  imul   %eax,%eax\n  add    %eax,%r8d\n  cmp    %rdi,%rdx\n  jne    1130 <func0+0x30>\n  mov    %r8d,%eax\n  ret\n  nopl   (%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movss  D0(%rip),%xmm4\n  xor    %r8d,%r8d\n  movss  D1(%rip),%xmm3\n  movss  D2(%rip),%xmm5\n  lea    0x4(%rdi,%rax,4),%rdx\n  nopl   0x0(%rax,%rax,1)\nL2:\n  movss  (%rdi),%xmm0\n  movaps %xmm0,%xmm1\n  andps  %xmm3,%xmm1\n  ucomiss %xmm1,%xmm4\n  jbe    L1\n  cvttss2si %xmm0,%eax\n  pxor   %xmm1,%xmm1\n  movaps %xmm0,%xmm2\n  cvtsi2ss %eax,%xmm1\n  cmpnless %xmm1,%xmm2\n  andps  %xmm5,%xmm2\n  addss  %xmm2,%xmm1\n  movaps %xmm3,%xmm2\n  andnps %xmm0,%xmm2\n  movaps %xmm1,%xmm0\n  orps   %xmm2,%xmm0\nL1:\n  cvttss2si %xmm0,%eax\n  add    $0x4,%rdi\n  imul   %eax,%eax\n  add    %eax,%r8d\n  cmp    %rdi,%rdx\n  jne    L2\n  mov    %r8d,%eax\n  ret\n  nopl   (%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3821
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3826
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8196,
                "bias": [
                    3806
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4480
            },
            "L1": {
                "label": "L1",
                "addr": 4454
            },
            "L2": {
                "label": "L2",
                "addr": 4400
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000004b0000803f0000000000000000ffffff7f000000000000000000000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        0,
                        75
                    ]
                },
                "0x2010": {
                    "type": "byte[4]",
                    "value": [
                        255,
                        255,
                        255,
                        127
                    ]
                },
                "0x2004": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        128,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 134,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x0,-0x4(%rbp)\n  jne    1168 <func0+0x2f>\n  mov    $0x0,%eax\n  jmp    11fc <func0+0xc3>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x6(%rbp)\n  call   1070 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x6(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  jne    11a9 <func0+0x70>\n  mov    $0x0,%eax\n  jmp    11fc <func0+0xc3>\n  cmpl   $0x1,-0x4(%rbp)\n  jne    11b6 <func0+0x7d>\n  mov    $0x1,%eax\n  jmp    11fc <func0+0xc3>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    -0x2(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x5(%rbp)\n  call   1070 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x5(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     11f7 <func0+0xbe>\n  mov    $0x0,%eax\n  jmp    11fc <func0+0xc3>\n  mov    $0x1,%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x20,%rsp\n  mov    %rdi,-0x18(%rbp)\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  cmpl   $0x0,-0x4(%rbp)\n  jne    L0\n  mov    $0x0,%eax\n  jmp    L1\nL0:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x6(%rbp)\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x6(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  jne    L2\n  mov    $0x0,%eax\n  jmp    L1\nL2:\n  cmpl   $0x1,-0x4(%rbp)\n  jne    L3\n  mov    $0x1,%eax\n  jmp    L1\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    -0x2(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x5(%rbp)\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  movzbl -0x5(%rbp),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     L4\n  mov    $0x0,%eax\n  jmp    L1\nL4:\n  mov    $0x1,%eax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4456
            },
            "L1": {
                "label": "L1",
                "addr": 4604
            },
            "L2": {
                "label": "L2",
                "addr": 4521
            },
            "L3": {
                "label": "L3",
                "addr": 4534
            },
            "L4": {
                "label": "L4",
                "addr": 4599
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 134,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r12\n  call   1060 <strlen@plt>\n  mov    %eax,%ebp\n  test   %eax,%eax\n  je     1186 <func0+0x4d>\n  movslq %eax,%r13\n  call   1070 <__ctype_b_loc@plt>\n  mov    (%rax),%rax\n  movzbl -0x1(%r12,%r13,1),%edx\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     1193 <func0+0x5a>\n  cmp    $0x1,%ebp\n  je     1186 <func0+0x4d>\n  movzbl -0x2(%r12,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%ebp\n  shr    $0xa,%bp\n  xor    $0x1,%ebp\n  and    $0x1,%ebp\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  mov    $0x0,%ebp\n  jmp    1186 <func0+0x4d>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r12\n  call   <strlen@plt>\n  mov    %eax,%ebp\n  test   %eax,%eax\n  je     L0\n  movslq %eax,%r13\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rax\n  movzbl -0x1(%r12,%r13,1),%edx\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     L1\n  cmp    $0x1,%ebp\n  je     L0\n  movzbl -0x2(%r12,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%ebp\n  shr    $0xa,%bp\n  xor    $0x1,%ebp\n  and    $0x1,%ebp\nL0:\n  mov    %ebp,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\nL1:\n  mov    $0x0,%ebp\n  jmp    L0",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4486
            },
            "L1": {
                "label": "L1",
                "addr": 4499
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 134,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     1193 <func0+0x53>\n  movslq %eax,%r13\n  call   1070 <__ctype_b_loc@plt>\n  movzbl -0x1(%rbp,%r13,1),%edx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     11a8 <func0+0x68>\n  cmp    $0x1,%r12d\n  je     1193 <func0+0x53>\n  movzbl -0x2(%rbp,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%r12d\n  shr    $0xa,%r12w\n  xor    $0x1,%r12d\n  and    $0x1,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     L0\n  movslq %eax,%r13\n  call   <__ctype_b_loc@plt>\n  movzbl -0x1(%rbp,%r13,1),%edx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     L1\n  cmp    $0x1,%r12d\n  je     L0\n  movzbl -0x2(%rbp,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%r12d\n  shr    $0xa,%r12w\n  xor    $0x1,%r12d\n  and    $0x1,%r12d\nL0:\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\nL1:\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4499
            },
            "L1": {
                "label": "L1",
                "addr": 4520
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 134,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint func0(const char *txt) {\n    int len = strlen(txt);\n    if (len == 0) return 0;\n    char last_char = txt[len - 1];\n    if (!isalpha((unsigned char)last_char)) return 0;\n    if (len == 1) return 1;\n    char second_last_char = txt[len - 2];\n    if (isalpha((unsigned char)second_last_char)) return 0;\n    return 1;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"apple\") == 0);\n    assert(func0(\"apple pi e\") == 1);\n    assert(func0(\"eeeee\") == 0);\n    assert(func0(\"A\") == 1);\n    assert(func0(\"Pumpkin pie \") == 0);\n    assert(func0(\"Pumpkin pie 1\") == 0);\n    assert(func0(\"\") == 0);\n    assert(func0(\"eeeee e \") == 0);\n    assert(func0(\"apple pie\") == 0);\n    assert(func0(\"apple pi e \") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   1060 <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     1193 <func0+0x53>\n  movslq %eax,%r13\n  call   1070 <__ctype_b_loc@plt>\n  movzbl -0x1(%rbp,%r13,1),%edx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     11a8 <func0+0x68>\n  cmp    $0x1,%r12d\n  je     1193 <func0+0x53>\n  movzbl -0x2(%rbp,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%r12d\n  shr    $0xa,%r12w\n  xor    $0x1,%r12d\n  and    $0x1,%r12d\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  call   <strlen@plt>\n  mov    %eax,%r12d\n  test   %eax,%eax\n  je     L0\n  movslq %eax,%r13\n  call   <__ctype_b_loc@plt>\n  movzbl -0x1(%rbp,%r13,1),%edx\n  mov    (%rax),%rax\n  testb  $0x4,0x1(%rax,%rdx,2)\n  je     L1\n  cmp    $0x1,%r12d\n  je     L0\n  movzbl -0x2(%rbp,%r13,1),%edx\n  movzwl (%rax,%rdx,2),%r12d\n  shr    $0xa,%r12w\n  xor    $0x1,%r12d\n  and    $0x1,%r12d\nL0:\n  add    $0x8,%rsp\n  mov    %r12d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopl   0x0(%rax)\nL1:\n  add    $0x8,%rsp\n  xor    %r12d,%r12d\n  pop    %rbx\n  mov    %r12d,%eax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4499
            },
            "L1": {
                "label": "L1",
                "addr": 4520
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 135,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0xffffffff,-0x8(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    1152 <func0+0x59>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    114e <func0+0x55>\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1118 <func0+0x1f>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0xffffffff,-0x8(%rbp)\n  movl   $0x1,-0x4(%rbp)\n  jmp    L0\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jge    L1\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\nL1:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L2\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4434
            },
            "L1": {
                "label": "L1",
                "addr": 4430
            },
            "L2": {
                "label": "L2",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 135,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1124 <func0+0x2b>\n  mov    %esi,%esi\n  mov    $0x1,%eax\n  mov    $0xffffffff,%edx\n  mov    -0x4(%rdi,%rax,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    110e <func0+0x15>\n  mov    %edx,%eax\n  ret\n  mov    $0xffffffff,%edx\n  jmp    1121 <func0+0x28>",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  mov    %esi,%esi\n  mov    $0x1,%eax\n  mov    $0xffffffff,%edx\nL1:\n  mov    -0x4(%rdi,%rax,4),%ecx\n  cmp    %ecx,(%rdi,%rax,4)\n  cmovl  %eax,%edx\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    L1\nL2:\n  mov    %edx,%eax\n  ret\nL0:\n  mov    $0xffffffff,%edx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4388
            },
            "L1": {
                "label": "L1",
                "addr": 4366
            },
            "L2": {
                "label": "L2",
                "addr": 4385
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 135,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    1140 <func0+0x40>\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  mov    $0xffffffff,%r8d\n  nopw   0x0(%rax,%rax,1)\n  mov    -0x4(%rdi,%rax,4),%edx\n  cmp    %edx,(%rdi,%rax,4)\n  cmovl  %eax,%r8d\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    1120 <func0+0x20>\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    $0xffffffff,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  movslq %esi,%rsi\n  mov    $0x1,%eax\n  mov    $0xffffffff,%r8d\n  nopw   0x0(%rax,%rax,1)\nL1:\n  mov    -0x4(%rdi,%rax,4),%edx\n  cmp    %edx,(%rdi,%rax,4)\n  cmovl  %eax,%r8d\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    L1\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    $0xffffffff,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4416
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 135,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int *arr, int size) {\n    int max = -1;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] < arr[i - 1]) max = i;\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    int arr1[] = {1, 2, 4, 3, 5};\n    assert(func0(arr1, 5) == 3);\n\n    int arr2[] = {1, 2, 4, 5};\n    assert(func0(arr2, 4) == -1);\n\n    int arr3[] = {1, 4, 2, 5, 6, 7, 8, 9, 10};\n    assert(func0(arr3, 9) == 2);\n\n    int arr4[] = {4, 8, 5, 7, 3};\n    assert(func0(arr4, 5) == 4);\n\n    assert(func0(NULL, 0) == -1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    12b0 <func0+0x1b0>\n  lea    -0x2(%rsi),%eax\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%r8d\n  mov    %esi,%ecx\n  cmp    $0x2,%eax\n  jbe    12b6 <func0+0x1b6>\n  mov    %r8d,%esi\n  movdqa 0xed3(%rip),%xmm2        # 2000 <_fini+0xd2c>\n  mov    %rdi,%rax\n  pxor   %xmm3,%xmm3\n  shr    $0x2,%esi\n  movdqa 0xed1(%rip),%xmm4        # 2010 <_fini+0xd3c>\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  lea    0x10(%rdi,%rsi,1),%rsi\n  nopl   0x0(%rax,%rax,1)\n  movdqu (%rax),%xmm0\n  movdqu 0x4(%rax),%xmm5\n  movdqa %xmm2,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm4,%xmm2\n  pcmpgtd %xmm5,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm3,%xmm0\n  movdqa %xmm0,%xmm3\n  por    %xmm1,%xmm3\n  cmp    %rsi,%rax\n  jne    1150 <func0+0x50>\n  movdqa %xmm3,%xmm0\n  mov    $0xffffffff,%esi\n  mov    %r8d,%edi\n  psrldq $0x8,%xmm0\n  movdqa %xmm0,%xmm1\n  pcmpgtd %xmm3,%xmm1\n  pand   %xmm1,%xmm0\n  pandn  %xmm3,%xmm1\n  por    %xmm0,%xmm1\n  movdqa %xmm1,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm0\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm2\n  pandn  %xmm1,%xmm0\n  por    %xmm2,%xmm0\n  movd   %xmm0,%eax\n  test   %eax,%eax\n  cmove  %esi,%eax\n  and    $0xfffffffc,%edi\n  lea    0x1(%rdi),%esi\n  cmp    %edi,%r8d\n  je     12a8 <func0+0x1a8>\n  movslq %esi,%rdi\n  lea    0x1(%rsi),%r9d\n  push   %rbx\n  shl    $0x2,%rdi\n  lea    (%rdx,%rdi,1),%r10\n  cmp    %r8d,%r9d\n  jge    12c5 <func0+0x1c5>\n  cmp    %esi,%ecx\n  jle    12c5 <func0+0x1c5>\n  mov    (%r10),%r11d\n  cmp    %r11d,-0x4(%r10)\n  mov    0x4(%rdx,%rdi,1),%r10d\n  cmovg  %esi,%eax\n  cmp    %r10d,%r11d\n  lea    0x2(%rsi),%r11d\n  cmovg  %r9d,%eax\n  lea    0x3(%rsi),%r9d\n  cmp    %r9d,%r8d\n  jg     1260 <func0+0x160>\n  movslq %r11d,%rsi\n  mov    (%rdx,%rsi,4),%r8d\n  lea    0x0(,%rsi,4),%rdi\n  cmp    -0x4(%rdx,%rsi,4),%r8d\n  lea    0x1(%r11),%esi\n  cmovl  %r11d,%eax\n  cmp    %esi,%ecx\n  jle    125b <func0+0x15b>\n  cmp    0x4(%rdx,%rdi,1),%r8d\n  cmovle %eax,%esi\n  lea    0x2(%r11),%eax\n  cmp    %eax,%ecx\n  jle    12cd <func0+0x1cd>\n  mov    0x8(%rdx,%rdi,1),%ebx\n  cmp    %ebx,0x4(%rdx,%rdi,1)\n  cmovle %esi,%eax\n  pop    %rbx\n  ret\n  nopl   (%rax)\n  mov    0x8(%rdx,%rdi,1),%ebx\n  cmp    %ebx,%r10d\n  mov    0xc(%rdx,%rdi,1),%r10d\n  cmovg  %r11d,%eax\n  lea    0x4(%rsi),%r11d\n  cmp    %r10d,%ebx\n  cmovg  %r9d,%eax\n  lea    0x5(%rsi),%r9d\n  cmp    %r9d,%r8d\n  jle    121c <func0+0x11c>\n  mov    0x10(%rdx,%rdi,1),%r8d\n  cmp    %r10d,%r8d\n  cmovge %eax,%r11d\n  cmp    0x14(%rdx,%rdi,1),%r8d\n  mov    %r11d,%eax\n  lea    0x6(%rsi),%r11d\n  cmovg  %r9d,%eax\n  jmp    121c <func0+0x11c>\n  nopl   (%rax)\n  ret\n  nopl   0x0(%rax)\n  mov    $0xffffffff,%eax\n  ret\n  mov    $0x1,%esi\n  mov    $0xffffffff,%eax\n  jmp    11d8 <func0+0xd8>\n  mov    %esi,%r11d\n  jmp    121c <func0+0x11c>\n  mov    %esi,%eax\n  pop    %rbx\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x1,%esi\n  jle    L0\n  lea    -0x2(%rsi),%eax\n  mov    %rdi,%rdx\n  lea    -0x1(%rsi),%r8d\n  mov    %esi,%ecx\n  cmp    $0x2,%eax\n  jbe    L1\n  mov    %r8d,%esi\n  movdqa D0(%rip),%xmm2\n  mov    %rdi,%rax\n  pxor   %xmm3,%xmm3\n  shr    $0x2,%esi\n  movdqa D1(%rip),%xmm4\n  sub    $0x1,%esi\n  shl    $0x4,%rsi\n  lea    0x10(%rdi,%rsi,1),%rsi\n  nopl   0x0(%rax,%rax,1)\nL2:\n  movdqu (%rax),%xmm0\n  movdqu 0x4(%rax),%xmm5\n  movdqa %xmm2,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm4,%xmm2\n  pcmpgtd %xmm5,%xmm0\n  pand   %xmm0,%xmm1\n  pandn  %xmm3,%xmm0\n  movdqa %xmm0,%xmm3\n  por    %xmm1,%xmm3\n  cmp    %rsi,%rax\n  jne    L2\n  movdqa %xmm3,%xmm0\n  mov    $0xffffffff,%esi\n  mov    %r8d,%edi\n  psrldq $0x8,%xmm0\n  movdqa %xmm0,%xmm1\n  pcmpgtd %xmm3,%xmm1\n  pand   %xmm1,%xmm0\n  pandn  %xmm3,%xmm1\n  por    %xmm0,%xmm1\n  movdqa %xmm1,%xmm2\n  psrldq $0x4,%xmm2\n  movdqa %xmm2,%xmm0\n  pcmpgtd %xmm1,%xmm0\n  pand   %xmm0,%xmm2\n  pandn  %xmm1,%xmm0\n  por    %xmm2,%xmm0\n  movd   %xmm0,%eax\n  test   %eax,%eax\n  cmove  %esi,%eax\n  and    $0xfffffffc,%edi\n  lea    0x1(%rdi),%esi\n  cmp    %edi,%r8d\n  je     L3\nL9:\n  movslq %esi,%rdi\n  lea    0x1(%rsi),%r9d\n  push   %rbx\n  shl    $0x2,%rdi\n  lea    (%rdx,%rdi,1),%r10\n  cmp    %r8d,%r9d\n  jge    L4\n  cmp    %esi,%ecx\n  jle    L4\n  mov    (%r10),%r11d\n  cmp    %r11d,-0x4(%r10)\n  mov    0x4(%rdx,%rdi,1),%r10d\n  cmovg  %esi,%eax\n  cmp    %r10d,%r11d\n  lea    0x2(%rsi),%r11d\n  cmovg  %r9d,%eax\n  lea    0x3(%rsi),%r9d\n  cmp    %r9d,%r8d\n  jg     L5\nL8:\n  movslq %r11d,%rsi\n  mov    (%rdx,%rsi,4),%r8d\n  lea    0x0(,%rsi,4),%rdi\n  cmp    -0x4(%rdx,%rsi,4),%r8d\n  lea    0x1(%r11),%esi\n  cmovl  %r11d,%eax\n  cmp    %esi,%ecx\n  jle    L6\n  cmp    0x4(%rdx,%rdi,1),%r8d\n  cmovle %eax,%esi\n  lea    0x2(%r11),%eax\n  cmp    %eax,%ecx\n  jle    L7\n  mov    0x8(%rdx,%rdi,1),%ebx\n  cmp    %ebx,0x4(%rdx,%rdi,1)\n  cmovle %esi,%eax\nL6:\n  pop    %rbx\n  ret\n  nopl   (%rax)\nL5:\n  mov    0x8(%rdx,%rdi,1),%ebx\n  cmp    %ebx,%r10d\n  mov    0xc(%rdx,%rdi,1),%r10d\n  cmovg  %r11d,%eax\n  lea    0x4(%rsi),%r11d\n  cmp    %r10d,%ebx\n  cmovg  %r9d,%eax\n  lea    0x5(%rsi),%r9d\n  cmp    %r9d,%r8d\n  jle    L8\n  mov    0x10(%rdx,%rdi,1),%r8d\n  cmp    %r10d,%r8d\n  cmovge %eax,%r11d\n  cmp    0x14(%rdx,%rdi,1),%r8d\n  mov    %r11d,%eax\n  lea    0x6(%rsi),%r11d\n  cmovg  %r9d,%eax\n  jmp    L8\n  nopl   (%rax)\nL3:\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0xffffffff,%eax\n  ret\nL1:\n  mov    $0x1,%esi\n  mov    $0xffffffff,%eax\n  jmp    L9\nL4:\n  mov    %esi,%r11d\n  jmp    L8\nL7:\n  mov    %esi,%eax\n  pop    %rbx\n  ret",
        "num_missing": 2,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3795
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3793
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4784
            },
            "L1": {
                "label": "L1",
                "addr": 4790
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4776
            },
            "L4": {
                "label": "L4",
                "addr": 4805
            },
            "L5": {
                "label": "L5",
                "addr": 4704
            },
            "L6": {
                "label": "L6",
                "addr": 4699
            },
            "L7": {
                "label": "L7",
                "addr": 4813
            },
            "L8": {
                "label": "L8",
                "addr": 4636
            },
            "L9": {
                "label": "L9",
                "addr": 4568
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0100000002000000030000000400000004000000040000000400000004000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        1,
                        0,
                        0,
                        0,
                        2,
                        0,
                        0,
                        0,
                        3,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0
                    ]
                },
                "0x2010": {
                    "type": "byte[16]",
                    "value": [
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 136,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    11d2 <func0+0xd9>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jns    117a <func0+0x81>\n  cmpl   $0x0,-0xc(%rbp)\n  je     1161 <func0+0x68>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jge    117a <func0+0x81>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    11ce <func0+0xd5>\n  cmpl   $0x0,-0x8(%rbp)\n  je     11b5 <func0+0xbc>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x8(%rbp)\n  jle    11ce <func0+0xd5>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     1126 <func0+0x2d>\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL5:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jns    L1\n  cmpl   $0x0,-0xc(%rbp)\n  je     L2\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0xc(%rbp)\n  jge    L1\nL2:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    L3\n  cmpl   $0x0,-0x8(%rbp)\n  je     L4\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x8(%rbp)\n  jle    L3\nL4:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x8(%rbp)\nL3:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L5\n  mov    -0x28(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x28(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4562
            },
            "L1": {
                "label": "L1",
                "addr": 4474
            },
            "L2": {
                "label": "L2",
                "addr": 4449
            },
            "L3": {
                "label": "L3",
                "addr": 4558
            },
            "L4": {
                "label": "L4",
                "addr": 4533
            },
            "L5": {
                "label": "L5",
                "addr": 4390
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 136,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1141 <func0+0x48>\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  jmp    112f <func0+0x36>\n  cmp    %edi,%eax\n  jg     1120 <func0+0x27>\n  test   %edi,%edi\n  jne    1126 <func0+0x2d>\n  mov    %eax,%edi\n  jmp    1126 <func0+0x2d>\n  mov    %eax,%esi\n  add    $0x4,%rcx\n  cmp    %r8,%rcx\n  je     114b <func0+0x52>\n  mov    (%rcx),%eax\n  test   %eax,%eax\n  js     1118 <func0+0x1f>\n  jle    1126 <func0+0x2d>\n  cmp    %esi,%eax\n  jl     1124 <func0+0x2b>\n  test   %esi,%esi\n  je     1124 <func0+0x2b>\n  jmp    1126 <func0+0x2d>\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  mov    %edi,(%rdx)\n  mov    %esi,0x4(%rdx)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rcx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r8\n  mov    $0x0,%esi\n  mov    $0x0,%edi\n  jmp    L1\nL5:\n  cmp    %edi,%eax\n  jg     L2\n  test   %edi,%edi\n  jne    L3\nL2:\n  mov    %eax,%edi\n  jmp    L3\nL6:\n  mov    %eax,%esi\nL3:\n  add    $0x4,%rcx\n  cmp    %r8,%rcx\n  je     L4\nL1:\n  mov    (%rcx),%eax\n  test   %eax,%eax\n  js     L5\n  jle    L3\n  cmp    %esi,%eax\n  jl     L6\n  test   %esi,%esi\n  je     L6\n  jmp    L3\nL0:\n  mov    $0x0,%esi\n  mov    $0x0,%edi\nL4:\n  mov    %edi,(%rdx)\n  mov    %esi,0x4(%rdx)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4417
            },
            "L1": {
                "label": "L1",
                "addr": 4399
            },
            "L2": {
                "label": "L2",
                "addr": 4384
            },
            "L3": {
                "label": "L3",
                "addr": 4390
            },
            "L4": {
                "label": "L4",
                "addr": 4427
            },
            "L5": {
                "label": "L5",
                "addr": 4376
            },
            "L6": {
                "label": "L6",
                "addr": 4388
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 136,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1150 <func0+0x50>\n  lea    -0x1(%rsi),%eax\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopl   0x0(%rax)\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     1140 <func0+0x40>\n  je     112a <func0+0x2a>\n  test   %ecx,%ecx\n  je     1128 <func0+0x28>\n  cmp    %ecx,%eax\n  jge    112a <func0+0x2a>\n  mov    %eax,%ecx\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  jne    1118 <func0+0x18>\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  nopl   0x0(%rax)\n  cmp    %esi,%eax\n  jg     1148 <func0+0x48>\n  test   %esi,%esi\n  jne    112a <func0+0x2a>\n  mov    %eax,%esi\n  jmp    112a <func0+0x2a>\n  nopl   0x0(%rax)\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopl   0x0(%rax)\nL4:\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     L1\n  je     L2\n  test   %ecx,%ecx\n  je     L3\n  cmp    %ecx,%eax\n  jge    L2\nL3:\n  mov    %eax,%ecx\nL2:\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  jne    L4\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  nopl   0x0(%rax)\nL1:\n  cmp    %esi,%eax\n  jg     L5\n  test   %esi,%esi\n  jne    L2\nL5:\n  mov    %eax,%esi\n  jmp    L2\n  nopl   0x0(%rax)\nL0:\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4432
            },
            "L1": {
                "label": "L1",
                "addr": 4416
            },
            "L2": {
                "label": "L2",
                "addr": 4394
            },
            "L3": {
                "label": "L3",
                "addr": 4392
            },
            "L4": {
                "label": "L4",
                "addr": 4376
            },
            "L5": {
                "label": "L5",
                "addr": 4424
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 136,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(const int *lst, int size, int result[2]) {\n    int maxneg = 0;\n    int minpos = 0;\n    for (int i = 0; i < size; i++) {\n        if (lst[i] < 0 && (maxneg == 0 || lst[i] > maxneg)) maxneg = lst[i];\n        if (lst[i] > 0 && (minpos == 0 || lst[i] < minpos)) minpos = lst[i];\n    }\n    result[0] = maxneg;\n    result[1] = minpos;\n}",
        "c_test": "#include <assert.h>\n\nint issame(const int a[2], const int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n    \n    func0((const int[]){2, 4, 1, 3, 5, 7}, 6, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){2, 4, 1, 3, 5, 7, 0}, 7, result);\n    assert(issame(result, (const int[]){0, 1}));\n\n    func0((const int[]){1, 3, 2, 4, 5, 6, -2}, 7, result);\n    assert(issame(result, (const int[]){-2, 1}));\n\n    func0((const int[]){4, 5, 3, 6, 2, 7, -7}, 7, result);\n    assert(issame(result, (const int[]){-7, 2}));\n\n    func0((const int[]){7, 3, 8, 4, 9, 2, 5, -9}, 8, result);\n    assert(issame(result, (const int[]){-9, 2}));\n\n    func0((const int[]){}, 0, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){0}, 1, result);\n    assert(issame(result, (const int[]){0, 0}));\n\n    func0((const int[]){-1, -3, -5, -6}, 4, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-1, -3, -5, -6, 0}, 5, result);\n    assert(issame(result, (const int[]){-1, 0}));\n\n    func0((const int[]){-6, -4, -4, -3, 1}, 5, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    func0((const int[]){-6, -4, -4, -3, -100, 1}, 6, result);\n    assert(issame(result, (const int[]){-3, 1}));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1150 <func0+0x50>\n  lea    -0x1(%rsi),%eax\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopl   0x0(%rax)\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     1140 <func0+0x40>\n  je     112a <func0+0x2a>\n  test   %ecx,%ecx\n  je     1128 <func0+0x28>\n  cmp    %ecx,%eax\n  jge    112a <func0+0x2a>\n  mov    %eax,%ecx\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  jne    1118 <func0+0x18>\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  nopl   0x0(%rax)\n  cmp    %esi,%eax\n  jg     1148 <func0+0x48>\n  test   %esi,%esi\n  jne    112a <func0+0x2a>\n  mov    %eax,%esi\n  jmp    112a <func0+0x2a>\n  nopl   0x0(%rax)\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  nopl   0x0(%rax)\nL4:\n  mov    (%rdi),%eax\n  test   %eax,%eax\n  js     L1\n  je     L2\n  test   %ecx,%ecx\n  je     L3\n  cmp    %ecx,%eax\n  jge    L2\nL3:\n  mov    %eax,%ecx\nL2:\n  add    $0x4,%rdi\n  cmp    %rdi,%r8\n  jne    L4\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret\n  nopl   0x0(%rax)\nL1:\n  cmp    %esi,%eax\n  jg     L5\n  test   %esi,%esi\n  jne    L2\nL5:\n  mov    %eax,%esi\n  jmp    L2\n  nopl   0x0(%rax)\nL0:\n  xor    %ecx,%ecx\n  xor    %esi,%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,0x4(%rdx)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4432
            },
            "L1": {
                "label": "L1",
                "addr": 4416
            },
            "L2": {
                "label": "L2",
                "addr": 4394
            },
            "L3": {
                "label": "L3",
                "addr": 4392
            },
            "L4": {
                "label": "L4",
                "addr": 4376
            },
            "L5": {
                "label": "L5",
                "addr": 4424
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 137,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strdup@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x50(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strdup@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  jmp    11ed <func0+0x74>\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    11e9 <func0+0x70>\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2e,(%rax)\n  addl   $0x1,-0x38(%rbp)\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11c5 <func0+0x4c>\n  movl   $0x0,-0x34(%rbp)\n  jmp    1232 <func0+0xb9>\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    122e <func0+0xb5>\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2e,(%rax)\n  addl   $0x1,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    120a <func0+0x91>\n  lea    -0x30(%rbp),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strtod@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x18(%rbp)\n  mov    -0x30(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     1291 <func0+0x118>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  lea    0xd74(%rip),%rax        # 2000 <_fini+0xcc0>\n  jmp    1328 <func0+0x1af>\n  lea    -0x30(%rbp),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strtod@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x30(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     12d9 <func0+0x160>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  lea    0xd29(%rip),%rax        # 2000 <_fini+0xcc0>\n  jmp    1328 <func0+0x1af>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  movsd  -0x18(%rbp),%xmm0\n  ucomisd -0x10(%rbp),%xmm0\n  jp     1312 <func0+0x199>\n  movsd  -0x18(%rbp),%xmm0\n  ucomisd -0x10(%rbp),%xmm0\n  jne    1312 <func0+0x199>\n  lea    0xcfe(%rip),%rax        # 200e <_fini+0xcce>\n  jmp    1328 <func0+0x1af>\n  movsd  -0x18(%rbp),%xmm0\n  comisd -0x10(%rbp),%xmm0\n  jbe    1324 <func0+0x1ab>\n  mov    -0x48(%rbp),%rax\n  jmp    1328 <func0+0x1af>\n  mov    -0x50(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     133c <func0+0x1c3>\n  call   10a0 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %rsi,-0x50(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x48(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x50(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x38(%rbp)\n  jmp    L0\nL2:\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    L1\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2e,(%rax)\nL1:\n  addl   $0x1,-0x38(%rbp)\nL0:\n  mov    -0x38(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L2\n  movl   $0x0,-0x34(%rbp)\n  jmp    L3\nL5:\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2c,%al\n  jne    L4\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2e,(%rax)\nL4:\n  addl   $0x1,-0x34(%rbp)\nL3:\n  mov    -0x34(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L5\n  lea    -0x30(%rbp),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strtod@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x18(%rbp)\n  mov    -0x30(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L6\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  lea    D0(%rip),%rax\n  jmp    L7\nL6:\n  lea    -0x30(%rbp),%rdx\n  mov    -0x20(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strtod@plt>\n  movq   %xmm0,%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x30(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  je     L8\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  lea    D0(%rip),%rax\n  jmp    L7\nL8:\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  movsd  -0x18(%rbp),%xmm0\n  ucomisd -0x10(%rbp),%xmm0\n  jp     L9\n  movsd  -0x18(%rbp),%xmm0\n  ucomisd -0x10(%rbp),%xmm0\n  jne    L9\n  lea    D1(%rip),%rax\n  jmp    L7\nL9:\n  movsd  -0x18(%rbp),%xmm0\n  comisd -0x10(%rbp),%xmm0\n  jbe    L10\n  mov    -0x48(%rbp),%rax\n  jmp    L7\nL10:\n  mov    -0x50(%rbp),%rax\nL7:\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L11\n  call   <__stack_chk_fail@plt>\nL11:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3444,
                    3369
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8206,
                "bias": [
                    3326
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4589
            },
            "L1": {
                "label": "L1",
                "addr": 4585
            },
            "L2": {
                "label": "L2",
                "addr": 4549
            },
            "L3": {
                "label": "L3",
                "addr": 4658
            },
            "L4": {
                "label": "L4",
                "addr": 4654
            },
            "L5": {
                "label": "L5",
                "addr": 4618
            },
            "L6": {
                "label": "L6",
                "addr": 4753
            },
            "L7": {
                "label": "L7",
                "addr": 4904
            },
            "L8": {
                "label": "L8",
                "addr": 4825
            },
            "L9": {
                "label": "L9",
                "addr": 4882
            },
            "L10": {
                "label": "L10",
                "addr": 4900
            },
            "L11": {
                "label": "L11",
                "addr": 4924
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "496e76616c696420696e707574004e6f6e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Invalid input\""
                },
                "0x200e": {
                    "type": "string",
                    "value": "\"None\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 137,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  mov    %rdi,%r13\n  mov    %rsi,%r12\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strdup@plt>\n  mov    %rax,%rbx\n  mov    %r12,%rdi\n  call   10b0 <strdup@plt>\n  mov    %rax,%rbp\n  movzbl (%rbx),%edx\n  test   %dl,%dl\n  je     11d3 <func0+0x5a>\n  mov    %rbx,%rax\n  jmp    11c9 <func0+0x50>\n  add    $0x1,%rax\n  movzbl (%rax),%edx\n  test   %dl,%dl\n  je     11d3 <func0+0x5a>\n  cmp    $0x2c,%dl\n  jne    11be <func0+0x45>\n  movb   $0x2e,(%rax)\n  jmp    11be <func0+0x45>\n  movzbl 0x0(%rbp),%edx\n  test   %dl,%dl\n  je     11f5 <func0+0x7c>\n  mov    %rbp,%rax\n  jmp    11eb <func0+0x72>\n  add    $0x1,%rax\n  movzbl (%rax),%edx\n  test   %dl,%dl\n  je     11f5 <func0+0x7c>\n  cmp    $0x2c,%dl\n  jne    11e0 <func0+0x67>\n  movb   $0x2e,(%rax)\n  jmp    11e0 <func0+0x67>\n  lea    0x10(%rsp),%rsi\n  mov    %rbx,%rdi\n  call   1090 <strtod@plt>\n  movq   %xmm0,%r14\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    126c <func0+0xf3>\n  lea    0x10(%rsp),%rsi\n  mov    %rbp,%rdi\n  call   1090 <strtod@plt>\n  movsd  %xmm0,0x8(%rsp)\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    12a0 <func0+0x127>\n  mov    %rbx,%rdi\n  call   1080 <free@plt>\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  movq   %r14,%xmm2\n  movsd  0x8(%rsp),%xmm1\n  ucomisd %xmm1,%xmm2\n  jp     1258 <func0+0xdf>\n  lea    0xdb8(%rip),%rax        # 200e <_fini+0xd4e>\n  je     1283 <func0+0x10a>\n  movq   %r14,%xmm4\n  comisd 0x8(%rsp),%xmm4\n  mov    %r12,%rax\n  cmova  %r13,%rax\n  jmp    1283 <func0+0x10a>\n  mov    %rbx,%rdi\n  call   1080 <free@plt>\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  lea    0xd7d(%rip),%rax        # 2000 <_fini+0xd40>\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12b9 <func0+0x140>\n  add    $0x20,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    %rbx,%rdi\n  call   1080 <free@plt>\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  lea    0xd49(%rip),%rax        # 2000 <_fini+0xd40>\n  jmp    1283 <func0+0x10a>\n  call   10a0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x20,%rsp\n  mov    %rdi,%r13\n  mov    %rsi,%r12\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strdup@plt>\n  mov    %rax,%rbx\n  mov    %r12,%rdi\n  call   <strdup@plt>\n  mov    %rax,%rbp\n  movzbl (%rbx),%edx\n  test   %dl,%dl\n  je     L0\n  mov    %rbx,%rax\n  jmp    L1\nL2:\n  add    $0x1,%rax\n  movzbl (%rax),%edx\n  test   %dl,%dl\n  je     L0\nL1:\n  cmp    $0x2c,%dl\n  jne    L2\n  movb   $0x2e,(%rax)\n  jmp    L2\nL0:\n  movzbl 0x0(%rbp),%edx\n  test   %dl,%dl\n  je     L3\n  mov    %rbp,%rax\n  jmp    L4\nL5:\n  add    $0x1,%rax\n  movzbl (%rax),%edx\n  test   %dl,%dl\n  je     L3\nL4:\n  cmp    $0x2c,%dl\n  jne    L5\n  movb   $0x2e,(%rax)\n  jmp    L5\nL3:\n  lea    0x10(%rsp),%rsi\n  mov    %rbx,%rdi\n  call   <strtod@plt>\n  movq   %xmm0,%r14\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    L6\n  lea    0x10(%rsp),%rsi\n  mov    %rbp,%rdi\n  call   <strtod@plt>\n  movsd  %xmm0,0x8(%rsp)\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    L7\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  movq   %r14,%xmm2\n  movsd  0x8(%rsp),%xmm1\n  ucomisd %xmm1,%xmm2\n  jp     L8\n  lea    D0(%rip),%rax\n  je     L9\nL8:\n  movq   %r14,%xmm4\n  comisd 0x8(%rsp),%xmm4\n  mov    %r12,%rax\n  cmova  %r13,%rax\n  jmp    L9\nL6:\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  lea    D1(%rip),%rax\nL9:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L10\n  add    $0x20,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL7:\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  lea    D1(%rip),%rax\n  jmp    L9\nL10:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8206,
                "bias": [
                    3512
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3453,
                    3401
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4563
            },
            "L1": {
                "label": "L1",
                "addr": 4553
            },
            "L2": {
                "label": "L2",
                "addr": 4542
            },
            "L3": {
                "label": "L3",
                "addr": 4597
            },
            "L4": {
                "label": "L4",
                "addr": 4587
            },
            "L5": {
                "label": "L5",
                "addr": 4576
            },
            "L6": {
                "label": "L6",
                "addr": 4716
            },
            "L7": {
                "label": "L7",
                "addr": 4768
            },
            "L8": {
                "label": "L8",
                "addr": 4696
            },
            "L9": {
                "label": "L9",
                "addr": 4739
            },
            "L10": {
                "label": "L10",
                "addr": 4793
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "496e76616c696420696e707574004e6f6e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Invalid input\""
                },
                "0x200e": {
                    "type": "string",
                    "value": "\"None\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 137,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strdup@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   10b0 <strdup@plt>\n  movzbl (%r12),%edx\n  mov    %rax,%r13\n  test   %dl,%dl\n  je     11e4 <func0+0x64>\n  mov    %r12,%rax\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x2c,%dl\n  jne    11d8 <func0+0x58>\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11d0 <func0+0x50>\n  movzbl 0x0(%r13),%edx\n  test   %dl,%dl\n  je     1204 <func0+0x84>\n  mov    %r13,%rax\n  cmp    $0x2c,%dl\n  jne    11f8 <func0+0x78>\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11f0 <func0+0x70>\n  lea    0x10(%rsp),%r14\n  mov    %r12,%rdi\n  mov    %r14,%rsi\n  call   1090 <strtod@plt>\n  mov    0x10(%rsp),%rax\n  movq   %xmm0,%r15\n  cmpb   $0x0,(%rax)\n  jne    1280 <func0+0x100>\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   1090 <strtod@plt>\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    1280 <func0+0x100>\n  mov    %r12,%rdi\n  movsd  %xmm0,0x8(%rsp)\n  call   1080 <free@plt>\n  mov    %r13,%rdi\n  call   1080 <free@plt>\n  movsd  0x8(%rsp),%xmm0\n  movq   %r15,%xmm1\n  ucomisd %xmm0,%xmm1\n  jp     1268 <func0+0xe8>\n  lea    0xda8(%rip),%rax        # 200e <_fini+0xd52>\n  je     1297 <func0+0x117>\n  movq   %r15,%xmm2\n  mov    %rbx,%rax\n  comisd %xmm0,%xmm2\n  cmova  %rbp,%rax\n  jmp    1297 <func0+0x117>\n  nopw   0x0(%rax,%rax,1)\n  mov    %r12,%rdi\n  call   1080 <free@plt>\n  mov    %r13,%rdi\n  call   1080 <free@plt>\n  lea    0xd69(%rip),%rax        # 2000 <_fini+0xd44>\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12b6 <func0+0x136>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10a0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strdup@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strdup@plt>\n  movzbl (%r12),%edx\n  mov    %rax,%r13\n  test   %dl,%dl\n  je     L0\n  mov    %r12,%rax\n  nopw   0x0(%rax,%rax,1)\nL2:\n  cmp    $0x2c,%dl\n  jne    L1\n  movb   $0x2e,(%rax)\nL1:\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L2\nL0:\n  movzbl 0x0(%r13),%edx\n  test   %dl,%dl\n  je     L3\n  mov    %r13,%rax\nL5:\n  cmp    $0x2c,%dl\n  jne    L4\n  movb   $0x2e,(%rax)\nL4:\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L5\nL3:\n  lea    0x10(%rsp),%r14\n  mov    %r12,%rdi\n  mov    %r14,%rsi\n  call   <strtod@plt>\n  mov    0x10(%rsp),%rax\n  movq   %xmm0,%r15\n  cmpb   $0x0,(%rax)\n  jne    L6\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   <strtod@plt>\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    L6\n  mov    %r12,%rdi\n  movsd  %xmm0,0x8(%rsp)\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  movsd  0x8(%rsp),%xmm0\n  movq   %r15,%xmm1\n  ucomisd %xmm0,%xmm1\n  jp     L7\n  lea    D0(%rip),%rax\n  je     L8\nL7:\n  movq   %r15,%xmm2\n  mov    %rbx,%rax\n  comisd %xmm0,%xmm2\n  cmova  %rbp,%rax\n  jmp    L8\n  nopw   0x0(%rax,%rax,1)\nL6:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  lea    D1(%rip),%rax\nL8:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L9\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL9:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8206,
                "bias": [
                    3496
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3433
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4580
            },
            "L1": {
                "label": "L1",
                "addr": 4568
            },
            "L2": {
                "label": "L2",
                "addr": 4560
            },
            "L3": {
                "label": "L3",
                "addr": 4612
            },
            "L4": {
                "label": "L4",
                "addr": 4600
            },
            "L5": {
                "label": "L5",
                "addr": 4592
            },
            "L6": {
                "label": "L6",
                "addr": 4736
            },
            "L7": {
                "label": "L7",
                "addr": 4712
            },
            "L8": {
                "label": "L8",
                "addr": 4759
            },
            "L9": {
                "label": "L9",
                "addr": 4790
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "496e76616c696420696e707574004e6f6e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Invalid input\""
                },
                "0x200e": {
                    "type": "string",
                    "value": "\"None\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 137,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* func0(const char* a, const char* b) {\n    char *end;\n    char *a_modified = strdup(a);\n    char *b_modified = strdup(b);\n\n    // Replace ',' with '.' if present for atof conversion\n    for (int i = 0; a_modified[i]; ++i) if (a_modified[i] == ',') a_modified[i] = '.';\n    for (int i = 0; b_modified[i]; ++i) if (b_modified[i] == ',') b_modified[i] = '.';\n\n    double numa = strtod(a_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n    double numb = strtod(b_modified, &end);\n    if (*end) { free(a_modified); free(b_modified); return \"Invalid input\"; } // Not a valid number\n\n    free(a_modified);\n    free(b_modified);\n\n    if (numa == numb) return \"None\";\n    return numa > numb ? (char*)a : (char*)b;\n}",
        "c_test": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\nint main() {\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"2.5\"), \"2.5\") == 0);\n    assert(strcmp(func0(\"2\", \"3\"), \"3\") == 0);\n    assert(strcmp(func0(\"5\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2,3\"), \"2,3\") == 0);\n    assert(strcmp(func0(\"5,1\", \"6\"), \"6\") == 0);\n    assert(strcmp(func0(\"1\", \"2\"), \"2\") == 0);\n    assert(strcmp(func0(\"1\", \"1\"), \"None\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   10b0 <strdup@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   10b0 <strdup@plt>\n  movzbl (%r12),%edx\n  mov    %rax,%r13\n  test   %dl,%dl\n  je     11e5 <func0+0x65>\n  mov    %r12,%rax\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x2c,%dl\n  je     12c0 <func0+0x140>\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11d0 <func0+0x50>\n  movzbl 0x0(%r13),%edx\n  test   %dl,%dl\n  je     120d <func0+0x8d>\n  mov    %r13,%rax\n  nopl   0x0(%rax)\n  cmp    $0x2c,%dl\n  je     12e0 <func0+0x160>\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11f8 <func0+0x78>\n  lea    0x10(%rsp),%r14\n  mov    %r12,%rdi\n  mov    %r14,%rsi\n  call   1090 <strtod@plt>\n  mov    0x10(%rsp),%rax\n  movq   %xmm0,%r15\n  cmpb   $0x0,(%rax)\n  jne    1288 <func0+0x108>\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   1090 <strtod@plt>\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    1288 <func0+0x108>\n  mov    %r12,%rdi\n  movsd  %xmm0,0x8(%rsp)\n  call   1080 <free@plt>\n  mov    %r13,%rdi\n  call   1080 <free@plt>\n  movsd  0x8(%rsp),%xmm0\n  movq   %r15,%xmm1\n  ucomisd %xmm0,%xmm1\n  jp     1271 <func0+0xf1>\n  lea    0xd9f(%rip),%rax        # 200e <_fini+0xd0e>\n  je     129f <func0+0x11f>\n  movq   %r15,%xmm2\n  mov    %rbx,%rax\n  comisd %xmm0,%xmm2\n  cmova  %rbp,%rax\n  jmp    129f <func0+0x11f>\n  nopl   0x0(%rax,%rax,1)\n  mov    %r12,%rdi\n  call   1080 <free@plt>\n  mov    %r13,%rdi\n  call   1080 <free@plt>\n  lea    0xd61(%rip),%rax        # 2000 <_fini+0xd00>\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12f8 <func0+0x178>\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11d0 <func0+0x50>\n  jmp    11e5 <func0+0x65>\n  nopl   0x0(%rax,%rax,1)\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    11f8 <func0+0x78>\n  jmp    120d <func0+0x8d>\n  call   10a0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  mov    %rsi,%rbx\n  sub    $0x28,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x18(%rsp)\n  xor    %eax,%eax\n  call   <strdup@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <strdup@plt>\n  movzbl (%r12),%edx\n  mov    %rax,%r13\n  test   %dl,%dl\n  je     L0\n  mov    %r12,%rax\n  nopw   0x0(%rax,%rax,1)\nL2:\n  cmp    $0x2c,%dl\n  je     L1\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L2\nL0:\n  movzbl 0x0(%r13),%edx\n  test   %dl,%dl\n  je     L3\n  mov    %r13,%rax\n  nopl   0x0(%rax)\nL5:\n  cmp    $0x2c,%dl\n  je     L4\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L5\nL3:\n  lea    0x10(%rsp),%r14\n  mov    %r12,%rdi\n  mov    %r14,%rsi\n  call   <strtod@plt>\n  mov    0x10(%rsp),%rax\n  movq   %xmm0,%r15\n  cmpb   $0x0,(%rax)\n  jne    L6\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   <strtod@plt>\n  mov    0x10(%rsp),%rax\n  cmpb   $0x0,(%rax)\n  jne    L6\n  mov    %r12,%rdi\n  movsd  %xmm0,0x8(%rsp)\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  movsd  0x8(%rsp),%xmm0\n  movq   %r15,%xmm1\n  ucomisd %xmm0,%xmm1\n  jp     L7\n  lea    D0(%rip),%rax\n  je     L8\nL7:\n  movq   %r15,%xmm2\n  mov    %rbx,%rax\n  comisd %xmm0,%xmm2\n  cmova  %rbp,%rax\n  jmp    L8\n  nopl   0x0(%rax,%rax,1)\nL6:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  lea    D1(%rip),%rax\nL8:\n  mov    0x18(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L9\n  add    $0x28,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  xchg   %ax,%ax\nL1:\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L2\n  jmp    L0\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movb   $0x2e,(%rax)\n  movzbl 0x1(%rax),%edx\n  add    $0x1,%rax\n  test   %dl,%dl\n  jne    L5\n  jmp    L3\nL9:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8206,
                "bias": [
                    3487
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3425
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4581
            },
            "L1": {
                "label": "L1",
                "addr": 4800
            },
            "L2": {
                "label": "L2",
                "addr": 4560
            },
            "L3": {
                "label": "L3",
                "addr": 4621
            },
            "L4": {
                "label": "L4",
                "addr": 4832
            },
            "L5": {
                "label": "L5",
                "addr": 4600
            },
            "L6": {
                "label": "L6",
                "addr": 4744
            },
            "L7": {
                "label": "L7",
                "addr": 4721
            },
            "L8": {
                "label": "L8",
                "addr": 4767
            },
            "L9": {
                "label": "L9",
                "addr": 4856
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "496e76616c696420696e707574004e6f6e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Invalid input\""
                },
                "0x200e": {
                    "type": "string",
                    "value": "\"None\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 138,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    111b <func0+0x22>\n  cmpl   $0x7,-0x4(%rbp)\n  jle    111b <func0+0x22>\n  mov    $0x1,%eax\n  jmp    1120 <func0+0x27>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L0\n  cmpl   $0x7,-0x4(%rbp)\n  jle    L0\n  mov    $0x1,%eax\n  jmp    L1\nL0:\n  mov    $0x0,%eax\nL1:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4379
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 138,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  xor    $0x1,%edx\n  cmp    $0x7,%edi\n  setg   %al\n  movzbl %al,%eax\n  and    %edx,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  xor    $0x1,%edx\n  cmp    $0x7,%edi\n  setg   %al\n  movzbl %al,%eax\n  and    %edx,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 138,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x7,%edi\n  not    %edi\n  setg   %al\n  and    %edi,%eax\n  movzbl %al,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x7,%edi\n  not    %edi\n  setg   %al\n  and    %edi,%eax\n  movzbl %al,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 138,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n) {\n    if (n % 2 == 0 && n >= 8) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 0);\n    assert(func0(6) == 0);\n    assert(func0(8) == 1);\n    assert(func0(10) == 1);\n    assert(func0(11) == 0);\n    assert(func0(12) == 1);\n    assert(func0(13) == 0);\n    assert(func0(16) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    $0x7,%edi\n  not    %edi\n  setg   %al\n  and    %edi,%eax\n  movzbl %al,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    $0x7,%edi\n  not    %edi\n  setg   %al\n  and    %edi,%eax\n  movzbl %al,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {},
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 139,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x24(%rbp)\n  movq   $0x1,-0x10(%rbp)\n  movq   $0x1,-0x8(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    113f <func0+0x46>\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0x10(%rbp),%rdx\n  imul   %rdx,%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x8(%rbp),%rax\n  imul   -0x10(%rbp),%rax\n  mov    %rax,-0x8(%rbp)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    111d <func0+0x24>\n  mov    -0x8(%rbp),%rax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x24(%rbp)\n  movq   $0x1,-0x10(%rbp)\n  movq   $0x1,-0x8(%rbp)\n  movl   $0x1,-0x14(%rbp)\n  jmp    L0\nL1:\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0x10(%rbp),%rdx\n  imul   %rdx,%rax\n  mov    %rax,-0x10(%rbp)\n  mov    -0x8(%rbp),%rax\n  imul   -0x10(%rbp),%rax\n  mov    %rax,-0x8(%rbp)\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jle    L1\n  mov    -0x8(%rbp),%rax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4415
            },
            "L1": {
                "label": "L1",
                "addr": 4381
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 139,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1128 <func0+0x2f>\n  lea    0x1(%rdi),%esi\n  mov    $0x1,%eax\n  mov    $0x1,%ecx\n  mov    $0x1,%edx\n  imul   %rax,%rdx\n  imul   %rdx,%rcx\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    1113 <func0+0x1a>\n  mov    %rcx,%rax\n  ret\n  mov    $0x1,%ecx\n  jmp    1124 <func0+0x2b>",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  lea    0x1(%rdi),%esi\n  mov    $0x1,%eax\n  mov    $0x1,%ecx\n  mov    $0x1,%edx\nL1:\n  imul   %rax,%rdx\n  imul   %rdx,%rcx\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  jne    L1\nL2:\n  mov    %rcx,%rax\n  ret\nL0:\n  mov    $0x1,%ecx\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4392
            },
            "L1": {
                "label": "L1",
                "addr": 4371
            },
            "L2": {
                "label": "L2",
                "addr": 4388
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 139,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1138 <func0+0x38>\n  lea    0x1(%rdi),%ecx\n  mov    $0x1,%eax\n  mov    $0x1,%r8d\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\n  imul   %rax,%rdx\n  add    $0x1,%rax\n  imul   %rdx,%r8\n  cmp    %rcx,%rax\n  jne    1120 <func0+0x20>\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\n  mov    $0x1,%r8d\n  mov    %r8,%rax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  lea    0x1(%rdi),%ecx\n  mov    $0x1,%eax\n  mov    $0x1,%r8d\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\nL1:\n  imul   %rax,%rdx\n  add    $0x1,%rax\n  imul   %rdx,%r8\n  cmp    %rcx,%rax\n  jne    L1\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\nL0:\n  mov    $0x1,%r8d\n  mov    %r8,%rax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 139,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nlong long func0(int n) {\n    long long fact = 1, bfact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = fact * i;\n        bfact = bfact * fact;\n    }\n    return bfact;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(4) == 288);\n    assert(func0(5) == 34560);\n    assert(func0(7) == 125411328000);\n    assert(func0(1) == 1);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    1138 <func0+0x38>\n  lea    0x1(%rdi),%ecx\n  mov    $0x1,%eax\n  mov    $0x1,%r8d\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\n  imul   %rax,%rdx\n  add    $0x1,%rax\n  imul   %rdx,%r8\n  cmp    %rcx,%rax\n  jne    1120 <func0+0x20>\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\n  mov    $0x1,%r8d\n  mov    %r8,%rax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %edi,%edi\n  jle    L0\n  lea    0x1(%rdi),%ecx\n  mov    $0x1,%eax\n  mov    $0x1,%r8d\n  mov    $0x1,%edx\n  nopl   0x0(%rax,%rax,1)\nL1:\n  imul   %rax,%rdx\n  add    $0x1,%rax\n  imul   %rdx,%r8\n  cmp    %rcx,%rax\n  jne    L1\n  mov    %r8,%rax\n  ret\n  nopl   (%rax)\nL0:\n  mov    $0x1,%r8d\n  mov    %r8,%rax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4408
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 140,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    1200 <func0+0xe7>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  jne    1165 <func0+0x4c>\n  addl   $0x1,-0x1c(%rbp)\n  jmp    11fc <func0+0xe3>\n  cmpl   $0x1,-0x1c(%rbp)\n  jne    1181 <func0+0x68>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  cmpl   $0x2,-0x1c(%rbp)\n  jne    11b3 <func0+0x9a>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  cmpl   $0x2,-0x1c(%rbp)\n  jle    11cf <func0+0xb6>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2d,(%rax)\n  movl   $0x0,-0x1c(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1050 <strlen@plt>\n  cmp    %rax,%rbx\n  jb     1148 <func0+0x2f>\n  cmpl   $0x1,-0x1c(%rbp)\n  jne    1237 <func0+0x11e>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  cmpl   $0x2,-0x1c(%rbp)\n  jne    1269 <func0+0x150>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  cmpl   $0x2,-0x1c(%rbp)\n  jle    1285 <func0+0x16c>\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2d,(%rax)\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL6:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  jne    L1\n  addl   $0x1,-0x1c(%rbp)\n  jmp    L2\nL1:\n  cmpl   $0x1,-0x1c(%rbp)\n  jne    L3\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\nL3:\n  cmpl   $0x2,-0x1c(%rbp)\n  jne    L4\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\nL4:\n  cmpl   $0x2,-0x1c(%rbp)\n  jle    L5\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2d,(%rax)\nL5:\n  movl   $0x0,-0x1c(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rdx\n  movzbl (%rcx),%eax\n  mov    %al,(%rdx)\nL2:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rbx\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jb     L6\n  cmpl   $0x1,-0x1c(%rbp)\n  jne    L7\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\nL7:\n  cmpl   $0x2,-0x1c(%rbp)\n  jne    L8\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x5f,(%rax)\nL8:\n  cmpl   $0x2,-0x1c(%rbp)\n  jle    L9\n  mov    -0x18(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x18(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x2d,(%rax)\nL9:\n  mov    -0x18(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4608
            },
            "L1": {
                "label": "L1",
                "addr": 4453
            },
            "L2": {
                "label": "L2",
                "addr": 4604
            },
            "L3": {
                "label": "L3",
                "addr": 4481
            },
            "L4": {
                "label": "L4",
                "addr": 4531
            },
            "L5": {
                "label": "L5",
                "addr": 4559
            },
            "L6": {
                "label": "L6",
                "addr": 4424
            },
            "L7": {
                "label": "L7",
                "addr": 4663
            },
            "L8": {
                "label": "L8",
                "addr": 4713
            },
            "L9": {
                "label": "L9",
                "addr": 4741
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 140,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %rsi,%r13\n  mov    $0x0,%ebp\n  mov    $0x0,%ebx\n  mov    $0x0,%r14d\n  jmp    1178 <func0+0x5f>\n  add    $0x1,%r14d\n  jmp    1174 <func0+0x5b>\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    115f <func0+0x46>\n  jle    11b2 <func0+0x99>\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x2d,0x0(%r13,%rbx,1)\n  lea    0x1(%rax),%ebx\n  movzbl (%r12,%rbp,1),%edx\n  cltq\n  mov    %dl,0x0(%r13,%rax,1)\n  mov    $0x0,%r14d\n  add    $0x1,%rbp\n  mov    %r12,%rdi\n  call   1050 <strlen@plt>\n  cmp    %rbp,%rax\n  jbe    11b6 <func0+0x9d>\n  cmpb   $0x20,(%r12,%rbp,1)\n  je     113d <func0+0x24>\n  cmp    $0x1,%r14d\n  je     1143 <func0+0x2a>\n  cmp    $0x2,%r14d\n  jne    1151 <func0+0x38>\n  movslq %ebx,%rax\n  movb   $0x5f,0x0(%r13,%rax,1)\n  lea    0x2(%rbx),%eax\n  add    $0x1,%ebx\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    115f <func0+0x46>\n  mov    %ebx,%eax\n  jmp    115f <func0+0x46>\n  cmp    $0x1,%r14d\n  je     11dc <func0+0xc3>\n  cmp    $0x2,%r14d\n  jne    11ea <func0+0xd1>\n  movslq %ebx,%rax\n  movb   $0x5f,0x0(%r13,%rax,1)\n  lea    0x2(%rbx),%eax\n  add    $0x1,%ebx\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    11f8 <func0+0xdf>\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    11f8 <func0+0xdf>\n  jle    1209 <func0+0xf0>\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x2d,0x0(%r13,%rbx,1)\n  cltq\n  movb   $0x0,0x0(%r13,%rax,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    %ebx,%eax\n  jmp    11f8 <func0+0xdf>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%r12\n  mov    %rsi,%r13\n  mov    $0x0,%ebp\n  mov    $0x0,%ebx\n  mov    $0x0,%r14d\n  jmp    L0\nL5:\n  add    $0x1,%r14d\n  jmp    L1\nL6:\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    L2\nL7:\n  jle    L3\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x2d,0x0(%r13,%rbx,1)\nL2:\n  lea    0x1(%rax),%ebx\n  movzbl (%r12,%rbp,1),%edx\n  cltq\n  mov    %dl,0x0(%r13,%rax,1)\n  mov    $0x0,%r14d\nL1:\n  add    $0x1,%rbp\nL0:\n  mov    %r12,%rdi\n  call   <strlen@plt>\n  cmp    %rbp,%rax\n  jbe    L4\n  cmpb   $0x20,(%r12,%rbp,1)\n  je     L5\n  cmp    $0x1,%r14d\n  je     L6\n  cmp    $0x2,%r14d\n  jne    L7\n  movslq %ebx,%rax\n  movb   $0x5f,0x0(%r13,%rax,1)\n  lea    0x2(%rbx),%eax\n  add    $0x1,%ebx\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    L2\nL3:\n  mov    %ebx,%eax\n  jmp    L2\nL4:\n  cmp    $0x1,%r14d\n  je     L8\n  cmp    $0x2,%r14d\n  jne    L9\n  movslq %ebx,%rax\n  movb   $0x5f,0x0(%r13,%rax,1)\n  lea    0x2(%rbx),%eax\n  add    $0x1,%ebx\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    L10\nL8:\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x5f,0x0(%r13,%rbx,1)\n  jmp    L10\nL9:\n  jle    L11\n  lea    0x1(%rbx),%eax\n  movslq %ebx,%rbx\n  movb   $0x2d,0x0(%r13,%rbx,1)\nL10:\n  cltq\n  movb   $0x0,0x0(%r13,%rax,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL11:\n  mov    %ebx,%eax\n  jmp    L10",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4472
            },
            "L1": {
                "label": "L1",
                "addr": 4468
            },
            "L2": {
                "label": "L2",
                "addr": 4447
            },
            "L3": {
                "label": "L3",
                "addr": 4530
            },
            "L4": {
                "label": "L4",
                "addr": 4534
            },
            "L5": {
                "label": "L5",
                "addr": 4413
            },
            "L6": {
                "label": "L6",
                "addr": 4419
            },
            "L7": {
                "label": "L7",
                "addr": 4433
            },
            "L8": {
                "label": "L8",
                "addr": 4572
            },
            "L9": {
                "label": "L9",
                "addr": 4586
            },
            "L10": {
                "label": "L10",
                "addr": 4600
            },
            "L11": {
                "label": "L11",
                "addr": 4617
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 140,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x8,%rsp\n  jmp    1181 <func0+0x61>\n  nopl   (%rax)\n  lea    0x1(%r12),%eax\n  cmp    $0x1,%r13d\n  je     11b0 <func0+0x90>\n  cmp    $0x2,%r13d\n  jne    11a0 <func0+0x80>\n  cltq\n  movb   $0x5f,(%rdx)\n  movb   $0x5f,(%r14,%rax,1)\n  lea    0x2(%r12),%eax\n  movzbl 0x0(%rbp,%rbx,1),%edx\n  lea    0x1(%rax),%r12d\n  cltq\n  xor    %r13d,%r13d\n  movslq %r12d,%r15\n  mov    %dl,(%r14,%rax,1)\n  add    $0x1,%rbx\n  mov    %rbp,%rdi\n  call   1050 <strlen@plt>\n  lea    (%r14,%r15,1),%rdx\n  cmp    %rbx,%rax\n  jbe    11b8 <func0+0x98>\n  cmpb   $0x20,0x0(%rbp,%rbx,1)\n  jne    1148 <func0+0x28>\n  add    $0x1,%r13d\n  jmp    117d <func0+0x5d>\n  nop\n  jle    120c <func0+0xec>\n  movb   $0x2d,(%rdx)\n  jmp    1168 <func0+0x48>\n  nopw   0x0(%rax,%rax,1)\n  movb   $0x5f,(%rdx)\n  jmp    1168 <func0+0x48>\n  nopl   (%rax)\n  cmp    $0x1,%r13d\n  je     1200 <func0+0xe0>\n  cmp    $0x2,%r13d\n  jne    11e0 <func0+0xc0>\n  lea    0x1(%r12),%eax\n  add    $0x2,%r12d\n  movb   $0x5f,(%rdx)\n  cltq\n  movslq %r12d,%r15\n  movb   $0x5f,(%r14,%rax,1)\n  jmp    11ec <func0+0xcc>\n  nopl   0x0(%rax)\n  jle    11ec <func0+0xcc>\n  movb   $0x2d,(%rdx)\n  add    $0x1,%r12d\n  movslq %r12d,%r15\n  movb   $0x0,(%r14,%r15,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  add    $0x1,%r12d\n  movb   $0x5f,(%rdx)\n  movslq %r12d,%r15\n  jmp    11ec <func0+0xcc>\n  mov    %r12d,%eax\n  jmp    1168 <func0+0x48>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x8,%rsp\n  jmp    L0\n  nopl   (%rax)\nL4:\n  lea    0x1(%r12),%eax\n  cmp    $0x1,%r13d\n  je     L1\n  cmp    $0x2,%r13d\n  jne    L2\n  cltq\n  movb   $0x5f,(%rdx)\n  movb   $0x5f,(%r14,%rax,1)\n  lea    0x2(%r12),%eax\nL7:\n  movzbl 0x0(%rbp,%rbx,1),%edx\n  lea    0x1(%rax),%r12d\n  cltq\n  xor    %r13d,%r13d\n  movslq %r12d,%r15\n  mov    %dl,(%r14,%rax,1)\nL5:\n  add    $0x1,%rbx\nL0:\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  lea    (%r14,%r15,1),%rdx\n  cmp    %rbx,%rax\n  jbe    L3\n  cmpb   $0x20,0x0(%rbp,%rbx,1)\n  jne    L4\n  add    $0x1,%r13d\n  jmp    L5\n  nop\nL2:\n  jle    L6\n  movb   $0x2d,(%rdx)\n  jmp    L7\n  nopw   0x0(%rax,%rax,1)\nL1:\n  movb   $0x5f,(%rdx)\n  jmp    L7\n  nopl   (%rax)\nL3:\n  cmp    $0x1,%r13d\n  je     L8\n  cmp    $0x2,%r13d\n  jne    L9\n  lea    0x1(%r12),%eax\n  add    $0x2,%r12d\n  movb   $0x5f,(%rdx)\n  cltq\n  movslq %r12d,%r15\n  movb   $0x5f,(%r14,%rax,1)\n  jmp    L10\n  nopl   0x0(%rax)\nL9:\n  jle    L10\n  movb   $0x2d,(%rdx)\n  add    $0x1,%r12d\n  movslq %r12d,%r15\nL10:\n  movb   $0x0,(%r14,%r15,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  add    $0x1,%r12d\n  movb   $0x5f,(%rdx)\n  movslq %r12d,%r15\n  jmp    L10\nL6:\n  mov    %r12d,%eax\n  jmp    L7",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4481
            },
            "L1": {
                "label": "L1",
                "addr": 4528
            },
            "L2": {
                "label": "L2",
                "addr": 4512
            },
            "L3": {
                "label": "L3",
                "addr": 4536
            },
            "L4": {
                "label": "L4",
                "addr": 4424
            },
            "L5": {
                "label": "L5",
                "addr": 4477
            },
            "L6": {
                "label": "L6",
                "addr": 4620
            },
            "L7": {
                "label": "L7",
                "addr": 4456
            },
            "L8": {
                "label": "L8",
                "addr": 4608
            },
            "L9": {
                "label": "L9",
                "addr": 4576
            },
            "L10": {
                "label": "L10",
                "addr": 4588
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 140,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char *text, char *out) {\n    int space_len = 0;\n    int j = 0;\n    for (int i = 0; i < strlen(text); i++) {\n        if (text[i] == ' ') {\n            space_len++;\n        } else {\n            if (space_len == 1) out[j++] = '_';\n            if (space_len == 2) out[j++] = '_', out[j++] = '_';\n            if (space_len > 2) out[j++] = '-';\n            space_len = 0;\n            out[j++] = text[i];\n        }\n    }\n    if (space_len == 1) out[j++] = '_';\n    if (space_len == 2) out[j++] = '_', out[j++] = '_';\n    if (space_len > 2) out[j++] = '-';\n    out[j] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[100];\n\n    func0(\"Example\", output);\n    assert(strcmp(output, \"Example\") == 0);\n\n    func0(\"Mudasir Hanif \", output);\n    assert(strcmp(output, \"Mudasir_Hanif_\") == 0);\n\n    func0(\"Yellow Yellow  Dirty  Fellow\", output);\n    assert(strcmp(output, \"Yellow_Yellow__Dirty__Fellow\") == 0);\n\n    func0(\"Exa   mple\", output);\n    assert(strcmp(output, \"Exa-mple\") == 0);\n\n    func0(\"   Exa 1 2 2 mple\", output);\n    assert(strcmp(output, \"-Exa_1_2_2_mple\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x8,%rsp\n  jmp    1181 <func0+0x61>\n  nopl   (%rax)\n  lea    0x1(%r12),%eax\n  cmp    $0x1,%r13d\n  je     11b0 <func0+0x90>\n  cmp    $0x2,%r13d\n  jne    11a0 <func0+0x80>\n  cltq\n  movb   $0x5f,(%rdx)\n  movb   $0x5f,(%r14,%rax,1)\n  lea    0x2(%r12),%eax\n  movzbl 0x0(%rbp,%rbx,1),%edx\n  lea    0x1(%rax),%r12d\n  cltq\n  xor    %r13d,%r13d\n  movslq %r12d,%r15\n  mov    %dl,(%r14,%rax,1)\n  add    $0x1,%rbx\n  mov    %rbp,%rdi\n  call   1050 <strlen@plt>\n  lea    (%r14,%r15,1),%rdx\n  cmp    %rbx,%rax\n  jbe    11b8 <func0+0x98>\n  cmpb   $0x20,0x0(%rbp,%rbx,1)\n  jne    1148 <func0+0x28>\n  add    $0x1,%r13d\n  jmp    117d <func0+0x5d>\n  nop\n  jle    120c <func0+0xec>\n  movb   $0x2d,(%rdx)\n  jmp    1168 <func0+0x48>\n  nopw   0x0(%rax,%rax,1)\n  movb   $0x5f,(%rdx)\n  jmp    1168 <func0+0x48>\n  nopl   (%rax)\n  cmp    $0x1,%r13d\n  je     1200 <func0+0xe0>\n  cmp    $0x2,%r13d\n  jne    11e0 <func0+0xc0>\n  lea    0x1(%r12),%eax\n  add    $0x2,%r12d\n  movb   $0x5f,(%rdx)\n  cltq\n  movslq %r12d,%r15\n  movb   $0x5f,(%r14,%rax,1)\n  jmp    11ec <func0+0xcc>\n  nopl   0x0(%rax)\n  jle    11ec <func0+0xcc>\n  movb   $0x2d,(%rdx)\n  add    $0x1,%r12d\n  movslq %r12d,%r15\n  movb   $0x0,(%r14,%r15,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  add    $0x1,%r12d\n  movb   $0x5f,(%rdx)\n  movslq %r12d,%r15\n  jmp    11ec <func0+0xcc>\n  mov    %r12d,%eax\n  jmp    1168 <func0+0x48>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  xor    %r15d,%r15d\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  xor    %r12d,%r12d\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x8,%rsp\n  jmp    L0\n  nopl   (%rax)\nL4:\n  lea    0x1(%r12),%eax\n  cmp    $0x1,%r13d\n  je     L1\n  cmp    $0x2,%r13d\n  jne    L2\n  cltq\n  movb   $0x5f,(%rdx)\n  movb   $0x5f,(%r14,%rax,1)\n  lea    0x2(%r12),%eax\nL7:\n  movzbl 0x0(%rbp,%rbx,1),%edx\n  lea    0x1(%rax),%r12d\n  cltq\n  xor    %r13d,%r13d\n  movslq %r12d,%r15\n  mov    %dl,(%r14,%rax,1)\nL5:\n  add    $0x1,%rbx\nL0:\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  lea    (%r14,%r15,1),%rdx\n  cmp    %rbx,%rax\n  jbe    L3\n  cmpb   $0x20,0x0(%rbp,%rbx,1)\n  jne    L4\n  add    $0x1,%r13d\n  jmp    L5\n  nop\nL2:\n  jle    L6\n  movb   $0x2d,(%rdx)\n  jmp    L7\n  nopw   0x0(%rax,%rax,1)\nL1:\n  movb   $0x5f,(%rdx)\n  jmp    L7\n  nopl   (%rax)\nL3:\n  cmp    $0x1,%r13d\n  je     L8\n  cmp    $0x2,%r13d\n  jne    L9\n  lea    0x1(%r12),%eax\n  add    $0x2,%r12d\n  movb   $0x5f,(%rdx)\n  cltq\n  movslq %r12d,%r15\n  movb   $0x5f,(%r14,%rax,1)\n  jmp    L10\n  nopl   0x0(%rax)\nL9:\n  jle    L10\n  movb   $0x2d,(%rdx)\n  add    $0x1,%r12d\n  movslq %r12d,%r15\nL10:\n  movb   $0x0,(%r14,%r15,1)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  add    $0x1,%r12d\n  movb   $0x5f,(%rdx)\n  movslq %r12d,%r15\n  jmp    L10\nL6:\n  mov    %r12d,%eax\n  jmp    L7",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4481
            },
            "L1": {
                "label": "L1",
                "addr": 4528
            },
            "L2": {
                "label": "L2",
                "addr": 4512
            },
            "L3": {
                "label": "L3",
                "addr": 4536
            },
            "L4": {
                "label": "L4",
                "addr": 4424
            },
            "L5": {
                "label": "L5",
                "addr": 4477
            },
            "L6": {
                "label": "L6",
                "addr": 4620
            },
            "L7": {
                "label": "L7",
                "addr": 4456
            },
            "L8": {
                "label": "L8",
                "addr": 4608
            },
            "L9": {
                "label": "L9",
                "addr": 4576
            },
            "L10": {
                "label": "L10",
                "addr": 4588
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 141,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1060 <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x4,-0xc(%rbp)\n  jg     1178 <func0+0x3f>\n  lea    0xe8d(%rip),%rax        # 2000 <_fini+0xd78>\n  jmp    1286 <func0+0x14d>\n  mov    -0x28(%rbp),%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x19(%rbp)\n  cmpb   $0x40,-0x19(%rbp)\n  jle    119a <func0+0x61>\n  cmpb   $0x5a,-0x19(%rbp)\n  jle    1194 <func0+0x5b>\n  cmpb   $0x60,-0x19(%rbp)\n  jle    119a <func0+0x61>\n  cmpb   $0x7a,-0x19(%rbp)\n  jle    11a6 <func0+0x6d>\n  lea    0xe5f(%rip),%rax        # 2000 <_fini+0xd78>\n  jmp    1286 <func0+0x14d>\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  lea    0xe3e(%rip),%rdx        # 2003 <_fini+0xd7b>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1211 <func0+0xd8>\n  mov    -0x8(%rbp),%rax\n  lea    0xe29(%rip),%rdx        # 2008 <_fini+0xd80>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1211 <func0+0xd8>\n  mov    -0x8(%rbp),%rax\n  lea    0xe14(%rip),%rdx        # 200d <_fini+0xd85>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1211 <func0+0xd8>\n  lea    0xdf1(%rip),%rax        # 2000 <_fini+0xd78>\n  jmp    1286 <func0+0x14d>\n  movl   $0x0,-0x10(%rbp)\n  jmp    1262 <func0+0x129>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    1246 <func0+0x10d>\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jg     1246 <func0+0x10d>\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2e,%al\n  jne    125e <func0+0x125>\n  addl   $0x1,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     121a <func0+0xe1>\n  cmpl   $0x3,-0x18(%rbp)\n  jg     1276 <func0+0x13d>\n  cmpl   $0x1,-0x14(%rbp)\n  je     127f <func0+0x146>\n  lea    0xd83(%rip),%rax        # 2000 <_fini+0xd78>\n  jmp    1286 <func0+0x14d>\n  lea    0xd8c(%rip),%rax        # 2012 <_fini+0xd8a>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x4,-0xc(%rbp)\n  jg     L0\n  lea    D0(%rip),%rax\n  jmp    L1\nL0:\n  mov    -0x28(%rbp),%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x19(%rbp)\n  cmpb   $0x40,-0x19(%rbp)\n  jle    L2\n  cmpb   $0x5a,-0x19(%rbp)\n  jle    L3\n  cmpb   $0x60,-0x19(%rbp)\n  jle    L2\nL3:\n  cmpb   $0x7a,-0x19(%rbp)\n  jle    L4\nL2:\n  lea    D0(%rip),%rax\n  jmp    L1\nL4:\n  mov    -0xc(%rbp),%eax\n  cltq\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0x8(%rbp),%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L5\n  mov    -0x8(%rbp),%rax\n  lea    D2(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L5\n  mov    -0x8(%rbp),%rax\n  lea    D3(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L5\n  lea    D0(%rip),%rax\n  jmp    L1\nL5:\n  movl   $0x0,-0x10(%rbp)\n  jmp    L6\nL9:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jle    L7\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x39,%al\n  jg     L7\n  addl   $0x1,-0x18(%rbp)\nL7:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2e,%al\n  jne    L8\n  addl   $0x1,-0x14(%rbp)\nL8:\n  addl   $0x1,-0x10(%rbp)\nL6:\n  mov    -0x10(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L9\n  cmpl   $0x3,-0x18(%rbp)\n  jg     L10\n  cmpl   $0x1,-0x14(%rbp)\n  je     L11\nL10:\n  lea    D0(%rip),%rax\n  jmp    L1\nL11:\n  lea    D4(%rip),%rax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3725,
                    3679,
                    3569,
                    3459
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8195,
                "bias": [
                    3646
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3625
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8205,
                "bias": [
                    3604
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8210,
                "bias": [
                    3468
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4472
            },
            "L1": {
                "label": "L1",
                "addr": 4742
            },
            "L2": {
                "label": "L2",
                "addr": 4506
            },
            "L3": {
                "label": "L3",
                "addr": 4500
            },
            "L4": {
                "label": "L4",
                "addr": 4518
            },
            "L5": {
                "label": "L5",
                "addr": 4625
            },
            "L6": {
                "label": "L6",
                "addr": 4706
            },
            "L7": {
                "label": "L7",
                "addr": 4678
            },
            "L8": {
                "label": "L8",
                "addr": 4702
            },
            "L9": {
                "label": "L9",
                "addr": 4634
            },
            "L10": {
                "label": "L10",
                "addr": 4726
            },
            "L11": {
                "label": "L11",
                "addr": 4735
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e6f002e747874002e657865002e646c6c0059657300",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"No\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\".txt\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\".exe\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\".dll\""
                },
                "0x2012": {
                    "type": "string",
                    "value": "\"Yes\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 141,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1060 <strlen@plt>\n  mov    %rax,%rbp\n  lea    0xead(%rip),%rax        # 2000 <_fini+0xddc>\n  cmp    $0x4,%ebp\n  jle    121c <func0+0xe3>\n  movzbl (%rbx),%eax\n  lea    -0x5b(%rax),%edx\n  cmp    $0x5,%dl\n  jbe    1215 <func0+0xdc>\n  sub    $0x41,%eax\n  cmp    $0x39,%al\n  ja     1215 <func0+0xdc>\n  movslq %ebp,%rax\n  lea    -0x4(%rbx,%rax,1),%r12\n  lea    0xe82(%rip),%rsi        # 2007 <_fini+0xde3>\n  mov    %r12,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     11c0 <func0+0x87>\n  lea    0xe74(%rip),%rsi        # 200c <_fini+0xde8>\n  mov    %r12,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     11c0 <func0+0x87>\n  lea    0xe66(%rip),%rsi        # 2011 <_fini+0xded>\n  mov    %r12,%rdi\n  call   1070 <strcmp@plt>\n  mov    %eax,%edx\n  lea    0xe44(%rip),%rax        # 2000 <_fini+0xddc>\n  test   %edx,%edx\n  jne    121c <func0+0xe3>\n  mov    %rbx,%rax\n  lea    -0x1(%rbp),%edx\n  lea    0x1(%rbx,%rdx,1),%r8\n  mov    $0x0,%edi\n  mov    $0x0,%esi\n  jmp    11eb <func0+0xb2>\n  cmp    $0x2e,%dl\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%edi\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  je     11fb <func0+0xc2>\n  movzbl (%rax),%edx\n  lea    -0x30(%rdx),%ecx\n  cmp    $0x9,%cl\n  ja     11d7 <func0+0x9e>\n  add    $0x1,%esi\n  jmp    11e2 <func0+0xa9>\n  cmp    $0x3,%esi\n  jg     120c <func0+0xd3>\n  lea    0xdfc(%rip),%rax        # 2003 <_fini+0xddf>\n  cmp    $0x1,%edi\n  je     121c <func0+0xe3>\n  lea    0xded(%rip),%rax        # 2000 <_fini+0xddc>\n  jmp    121c <func0+0xe3>\n  lea    0xde4(%rip),%rax        # 2000 <_fini+0xddc>\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  lea    D0(%rip),%rax\n  cmp    $0x4,%ebp\n  jle    L0\n  movzbl (%rbx),%eax\n  lea    -0x5b(%rax),%edx\n  cmp    $0x5,%dl\n  jbe    L1\n  sub    $0x41,%eax\n  cmp    $0x39,%al\n  ja     L1\n  movslq %ebp,%rax\n  lea    -0x4(%rbx,%rax,1),%r12\n  lea    D1(%rip),%rsi\n  mov    %r12,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L2\n  lea    D2(%rip),%rsi\n  mov    %r12,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L2\n  lea    D3(%rip),%rsi\n  mov    %r12,%rdi\n  call   <strcmp@plt>\n  mov    %eax,%edx\n  lea    D0(%rip),%rax\n  test   %edx,%edx\n  jne    L0\nL2:\n  mov    %rbx,%rax\n  lea    -0x1(%rbp),%edx\n  lea    0x1(%rbx,%rdx,1),%r8\n  mov    $0x0,%edi\n  mov    $0x0,%esi\n  jmp    L3\nL5:\n  cmp    $0x2e,%dl\n  sete   %dl\n  movzbl %dl,%edx\n  add    %edx,%edi\nL6:\n  add    $0x1,%rax\n  cmp    %r8,%rax\n  je     L4\nL3:\n  movzbl (%rax),%edx\n  lea    -0x30(%rdx),%ecx\n  cmp    $0x9,%cl\n  ja     L5\n  add    $0x1,%esi\n  jmp    L6\nL4:\n  cmp    $0x3,%esi\n  jg     L7\n  lea    D4(%rip),%rax\n  cmp    $0x1,%edi\n  je     L0\nL7:\n  lea    D0(%rip),%rax\n  jmp    L0\nL1:\n  lea    D0(%rip),%rax\nL0:\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3757,
                    3652,
                    3565,
                    3556
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8199,
                "bias": [
                    3714
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8204,
                "bias": [
                    3700
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8209,
                "bias": [
                    3686
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8195,
                "bias": [
                    3580
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4636
            },
            "L1": {
                "label": "L1",
                "addr": 4629
            },
            "L2": {
                "label": "L2",
                "addr": 4544
            },
            "L3": {
                "label": "L3",
                "addr": 4587
            },
            "L4": {
                "label": "L4",
                "addr": 4603
            },
            "L5": {
                "label": "L5",
                "addr": 4567
            },
            "L6": {
                "label": "L6",
                "addr": 4578
            },
            "L7": {
                "label": "L7",
                "addr": 4620
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e6f00596573002e747874002e657865002e646c6c00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"No\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"Yes\""
                },
                "0x2007": {
                    "type": "string",
                    "value": "\".txt\""
                },
                "0x200c": {
                    "type": "string",
                    "value": "\".exe\""
                },
                "0x2011": {
                    "type": "string",
                    "value": "\".dll\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 141,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    0xeaf(%rip),%r12        # 2000 <_fini+0xdc8>\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1060 <strlen@plt>\n  cmp    $0x4,%eax\n  jle    11e3 <func0+0xa3>\n  movzbl (%rbx),%r13d\n  mov    %rax,%rbp\n  lea    -0x5b(%r13),%eax\n  cmp    $0x5,%al\n  jbe    11f0 <func0+0xb0>\n  lea    -0x41(%r13),%eax\n  cmp    $0x39,%al\n  ja     11f0 <func0+0xb0>\n  movslq %ebp,%rax\n  lea    0xe82(%rip),%rsi        # 2007 <_fini+0xdcf>\n  lea    -0x4(%rbx,%rax,1),%r14\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  jne    1208 <func0+0xc8>\n  lea    -0x1(%rbp),%ecx\n  mov    %rbx,%rax\n  xor    %edi,%edi\n  xor    %esi,%esi\n  add    %rbx,%rcx\n  jmp    11b9 <func0+0x79>\n  nopl   (%rax)\n  add    $0x1,%esi\n  cmp    %rax,%rcx\n  je     11d2 <func0+0x92>\n  movzbl 0x1(%rax),%r13d\n  add    $0x1,%rax\n  lea    -0x30(%r13),%edx\n  cmp    $0x9,%dl\n  jbe    11a8 <func0+0x68>\n  xor    %edx,%edx\n  cmp    $0x2e,%r13b\n  sete   %dl\n  add    %edx,%edi\n  cmp    %rax,%rcx\n  jne    11b0 <func0+0x70>\n  cmp    $0x3,%esi\n  jg     11f0 <func0+0xb0>\n  lea    0xe25(%rip),%r12        # 2003 <_fini+0xdcb>\n  cmp    $0x1,%edi\n  jne    11f0 <func0+0xb0>\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nop\n  lea    0xe09(%rip),%r12        # 2000 <_fini+0xdc8>\n  pop    %rbx\n  pop    %rbp\n  mov    %r12,%rax\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax,%rax,1)\n  lea    0xdfd(%rip),%rsi        # 200c <_fini+0xdd4>\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1196 <func0+0x56>\n  lea    0xdeb(%rip),%rsi        # 2011 <_fini+0xdd9>\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     1196 <func0+0x56>\n  jmp    11e3 <func0+0xa3>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    D0(%rip),%r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  cmp    $0x4,%eax\n  jle    L0\n  movzbl (%rbx),%r13d\n  mov    %rax,%rbp\n  lea    -0x5b(%r13),%eax\n  cmp    $0x5,%al\n  jbe    L1\n  lea    -0x41(%r13),%eax\n  cmp    $0x39,%al\n  ja     L1\n  movslq %ebp,%rax\n  lea    D1(%rip),%rsi\n  lea    -0x4(%rbx,%rax,1),%r14\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L2\nL7:\n  lea    -0x1(%rbp),%ecx\n  mov    %rbx,%rax\n  xor    %edi,%edi\n  xor    %esi,%esi\n  add    %rbx,%rcx\n  jmp    L3\n  nopl   (%rax)\nL5:\n  add    $0x1,%esi\n  cmp    %rax,%rcx\n  je     L4\nL6:\n  movzbl 0x1(%rax),%r13d\n  add    $0x1,%rax\nL3:\n  lea    -0x30(%r13),%edx\n  cmp    $0x9,%dl\n  jbe    L5\n  xor    %edx,%edx\n  cmp    $0x2e,%r13b\n  sete   %dl\n  add    %edx,%edi\n  cmp    %rax,%rcx\n  jne    L6\nL4:\n  cmp    $0x3,%esi\n  jg     L1\n  lea    D2(%rip),%r12\n  cmp    $0x1,%edi\n  jne    L1\nL0:\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nop\nL1:\n  lea    D0(%rip),%r12\n  pop    %rbx\n  pop    %rbp\n  mov    %r12,%rax\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  lea    D3(%rip),%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L7\n  lea    D4(%rip),%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L7\n  jmp    L0",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3759,
                    3593
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8199,
                "bias": [
                    3714
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8195,
                "bias": [
                    3621
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8204,
                "bias": [
                    3581
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8209,
                "bias": [
                    3563
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4579
            },
            "L1": {
                "label": "L1",
                "addr": 4592
            },
            "L2": {
                "label": "L2",
                "addr": 4616
            },
            "L3": {
                "label": "L3",
                "addr": 4537
            },
            "L4": {
                "label": "L4",
                "addr": 4562
            },
            "L5": {
                "label": "L5",
                "addr": 4520
            },
            "L6": {
                "label": "L6",
                "addr": 4528
            },
            "L7": {
                "label": "L7",
                "addr": 4502
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e6f00596573002e747874002e657865002e646c6c00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"No\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"Yes\""
                },
                "0x2007": {
                    "type": "string",
                    "value": "\".txt\""
                },
                "0x200c": {
                    "type": "string",
                    "value": "\".exe\""
                },
                "0x2011": {
                    "type": "string",
                    "value": "\".dll\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 141,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nconst char* func0(const char* file_name) {\n    int num_digit = 0, num_dot = 0;\n    int length = strlen(file_name);\n    if (length < 5) return \"No\";\n    char w = file_name[0];\n    if (w < 'A' || (w > 'Z' && w < 'a') || w > 'z') return \"No\";\n    const char* last = file_name + length - 4;\n    if (strcmp(last, \".txt\") != 0 && strcmp(last, \".exe\") != 0 && strcmp(last, \".dll\") != 0) return \"No\";\n    for (int i = 0; i < length; i++) {\n        if (file_name[i] >= '0' && file_name[i] <= '9') num_digit++;\n        if (file_name[i] == '.') num_dot++;\n    }\n    if (num_digit > 3 || num_dot != 1) return \"No\";\n    return \"Yes\";\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    assert(strcmp(func0(\"example.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1example.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"s1sdf3.asd\"), \"No\") == 0);\n    assert(strcmp(func0(\"K.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"MY16FILE3.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"His12FILE94.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"_Y.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"?aREYA.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"/this_is_valid.dll\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.wow\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"this_is_valid.txtexe\"), \"No\") == 0);\n    assert(strcmp(func0(\"#this2_i4s_5valid.ten\"), \"No\") == 0);\n    assert(strcmp(func0(\"@this1_is6_valid.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"this_is_12valid.6exe4.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"all.exe.txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_No.exe\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"Is3youfault.txt\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"no_one#knows.dll\"), \"Yes\") == 0);\n    assert(strcmp(func0(\"1I563_Yes3.exe\"), \"No\") == 0);\n    assert(strcmp(func0(\"I563_Yes3.txtt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final..txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"final132\"), \"No\") == 0);\n    assert(strcmp(func0(\"_f4indsartal132.\"), \"No\") == 0);\n    assert(strcmp(func0(\".txt\"), \"No\") == 0);\n    assert(strcmp(func0(\"s.\"), \"No\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    0xeaf(%rip),%r12        # 2000 <_fini+0x8e0>\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   1060 <strlen@plt>\n  cmp    $0x4,%eax\n  jle    15ef <func0+0x4af>\n  movzbl (%rbx),%r13d\n  mov    %rax,%rbp\n  lea    -0x5b(%r13),%eax\n  cmp    $0x5,%al\n  jbe    15e8 <func0+0x4a8>\n  lea    -0x41(%r13),%eax\n  cmp    $0x39,%al\n  ja     15e8 <func0+0x4a8>\n  movslq %ebp,%rax\n  lea    0xe7a(%rip),%rsi        # 2007 <_fini+0x8e7>\n  lea    -0x4(%rbx,%rax,1),%r14\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  jne    1600 <func0+0x4c0>\n  lea    -0x1(%rbp),%eax\n  cmp    $0xe,%eax\n  jbe    16e0 <func0+0x5a0>\n  mov    %ebp,%edx\n  pxor   %xmm2,%xmm2\n  movdqa 0xe63(%rip),%xmm8        # 2020 <_fini+0x900>\n  movdqa 0xe6b(%rip),%xmm7        # 2030 <_fini+0x910>\n  shr    $0x4,%edx\n  movdqa %xmm2,%xmm10\n  pxor   %xmm4,%xmm4\n  mov    %rbx,%rax\n  sub    $0x1,%edx\n  movdqa 0xe61(%rip),%xmm6        # 2040 <_fini+0x920>\n  movdqa 0xe69(%rip),%xmm5        # 2050 <_fini+0x930>\n  pxor   %xmm3,%xmm3\n  shl    $0x4,%rdx\n  lea    0x10(%rbx,%rdx,1),%rdx\n  nopl   0x0(%rax)\n  movdqu (%rax),%xmm0\n  movdqu (%rax),%xmm9\n  movdqa %xmm4,%xmm11\n  add    $0x10,%rax\n  paddb  %xmm8,%xmm0\n  pcmpeqb %xmm6,%xmm9\n  psubusb %xmm7,%xmm0\n  pcmpeqb %xmm4,%xmm0\n  movdqa %xmm0,%xmm1\n  pand   %xmm5,%xmm0\n  pcmpeqb %xmm4,%xmm1\n  pand   %xmm9,%xmm1\n  pcmpgtb %xmm1,%xmm11\n  movdqa %xmm1,%xmm9\n  punpcklbw %xmm11,%xmm9\n  punpckhbw %xmm11,%xmm1\n  movdqa %xmm3,%xmm11\n  pcmpgtw %xmm9,%xmm11\n  movdqa %xmm9,%xmm12\n  punpcklwd %xmm11,%xmm12\n  punpckhwd %xmm11,%xmm9\n  movdqa %xmm1,%xmm11\n  psubd  %xmm12,%xmm2\n  psubd  %xmm9,%xmm2\n  movdqa %xmm3,%xmm9\n  pcmpgtw %xmm1,%xmm9\n  punpcklwd %xmm9,%xmm11\n  punpckhwd %xmm9,%xmm1\n  movdqa %xmm0,%xmm9\n  psubd  %xmm11,%xmm2\n  movdqa %xmm3,%xmm11\n  psubd  %xmm1,%xmm2\n  movdqa %xmm4,%xmm1\n  pcmpgtb %xmm0,%xmm1\n  punpcklbw %xmm1,%xmm9\n  punpckhbw %xmm1,%xmm0\n  pcmpgtw %xmm9,%xmm11\n  movdqa %xmm9,%xmm1\n  punpcklwd %xmm11,%xmm1\n  punpckhwd %xmm11,%xmm9\n  paddd  %xmm10,%xmm1\n  movdqa %xmm0,%xmm10\n  paddd  %xmm9,%xmm1\n  movdqa %xmm3,%xmm9\n  pcmpgtw %xmm0,%xmm9\n  punpcklwd %xmm9,%xmm10\n  punpckhwd %xmm9,%xmm0\n  paddd  %xmm10,%xmm1\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm10\n  cmp    %rdx,%rax\n  jne    11f8 <func0+0xb8>\n  movdqa %xmm1,%xmm0\n  mov    %ebp,%ecx\n  psrldq $0x8,%xmm0\n  and    $0xfffffff0,%ecx\n  paddd  %xmm0,%xmm10\n  movdqa %xmm10,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm10\n  movdqa %xmm2,%xmm0\n  psrldq $0x8,%xmm0\n  movd   %xmm10,%eax\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%edx\n  test   $0xf,%bpl\n  je     15d0 <func0+0x490>\n  movslq %ecx,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1368 <func0+0x228>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  jmp    136b <func0+0x22b>\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  xor    %eax,%eax\n  nopl   0x0(%rax)\n  add    $0x1,%eax\n  add    $0x1,%ecx\n  cmp    %ecx,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %ecx,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1630 <func0+0x4f0>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x1(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1640 <func0+0x500>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x2(%rcx),%esi\n  cmp    %ebp,%esi\n  jge    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1650 <func0+0x510>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x3(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1660 <func0+0x520>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x4(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1670 <func0+0x530>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x5(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1680 <func0+0x540>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x6(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1690 <func0+0x550>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x7(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    16a0 <func0+0x560>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x8(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    16b0 <func0+0x570>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0x9(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    16c0 <func0+0x580>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0xa(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    16d0 <func0+0x590>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0xb(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1700 <func0+0x5c0>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  lea    0xc(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    1708 <func0+0x5c8>\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  add    $0xd,%ecx\n  cmp    %ecx,%ebp\n  jle    15d0 <func0+0x490>\n  movslq %ecx,%rcx\n  movzbl (%rbx,%rcx,1),%ecx\n  lea    -0x30(%rcx),%esi\n  cmp    $0x9,%sil\n  ja     1710 <func0+0x5d0>\n  add    $0x1,%eax\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x3,%eax\n  jg     15e8 <func0+0x4a8>\n  lea    0xa27(%rip),%r12        # 2003 <_fini+0x8e3>\n  cmp    $0x1,%edx\n  je     15ef <func0+0x4af>\n  nopl   0x0(%rax)\n  lea    0xa11(%rip),%r12        # 2000 <_fini+0x8e0>\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax,%rax,1)\n  lea    0xa05(%rip),%rsi        # 200c <_fini+0x8ec>\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     11a2 <func0+0x62>\n  lea    0x9f3(%rip),%rsi        # 2011 <_fini+0x8f1>\n  mov    %r14,%rdi\n  call   1070 <strcmp@plt>\n  test   %eax,%eax\n  je     11a2 <func0+0x62>\n  jmp    15ef <func0+0x4af>\n  add    $0x1,%eax\n  jmp    1398 <func0+0x258>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    13c5 <func0+0x285>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    13f2 <func0+0x2b2>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    141f <func0+0x2df>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    144c <func0+0x30c>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    1479 <func0+0x339>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    14a6 <func0+0x366>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    14d3 <func0+0x393>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    1500 <func0+0x3c0>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    152d <func0+0x3ed>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%eax\n  jmp    155a <func0+0x41a>\n  nopl   0x0(%rax,%rax,1)\n  sub    $0x30,%r13d\n  cmp    $0x9,%r13b\n  jbe    135e <func0+0x21e>\n  xor    %edx,%edx\n  xor    %eax,%eax\n  mov    $0x1,%ecx\n  jmp    1376 <func0+0x236>\n  nopl   0x0(%rax)\n  add    $0x1,%eax\n  jmp    1583 <func0+0x443>\n  add    $0x1,%eax\n  jmp    15ac <func0+0x46c>\n  cmp    $0x2e,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  jmp    15d0 <func0+0x490>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  lea    D0(%rip),%r12\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  call   <strlen@plt>\n  cmp    $0x4,%eax\n  jle    L0\n  movzbl (%rbx),%r13d\n  mov    %rax,%rbp\n  lea    -0x5b(%r13),%eax\n  cmp    $0x5,%al\n  jbe    L1\n  lea    -0x41(%r13),%eax\n  cmp    $0x39,%al\n  ja     L1\n  movslq %ebp,%rax\n  lea    D1(%rip),%rsi\n  lea    -0x4(%rbx,%rax,1),%r14\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L2\nL22:\n  lea    -0x1(%rbp),%eax\n  cmp    $0xe,%eax\n  jbe    L3\n  mov    %ebp,%edx\n  pxor   %xmm2,%xmm2\n  movdqa D2(%rip),%xmm8\n  movdqa D3(%rip),%xmm7\n  shr    $0x4,%edx\n  movdqa %xmm2,%xmm10\n  pxor   %xmm4,%xmm4\n  mov    %rbx,%rax\n  sub    $0x1,%edx\n  movdqa D4(%rip),%xmm6\n  movdqa D5(%rip),%xmm5\n  pxor   %xmm3,%xmm3\n  shl    $0x4,%rdx\n  lea    0x10(%rbx,%rdx,1),%rdx\n  nopl   0x0(%rax)\nL4:\n  movdqu (%rax),%xmm0\n  movdqu (%rax),%xmm9\n  movdqa %xmm4,%xmm11\n  add    $0x10,%rax\n  paddb  %xmm8,%xmm0\n  pcmpeqb %xmm6,%xmm9\n  psubusb %xmm7,%xmm0\n  pcmpeqb %xmm4,%xmm0\n  movdqa %xmm0,%xmm1\n  pand   %xmm5,%xmm0\n  pcmpeqb %xmm4,%xmm1\n  pand   %xmm9,%xmm1\n  pcmpgtb %xmm1,%xmm11\n  movdqa %xmm1,%xmm9\n  punpcklbw %xmm11,%xmm9\n  punpckhbw %xmm11,%xmm1\n  movdqa %xmm3,%xmm11\n  pcmpgtw %xmm9,%xmm11\n  movdqa %xmm9,%xmm12\n  punpcklwd %xmm11,%xmm12\n  punpckhwd %xmm11,%xmm9\n  movdqa %xmm1,%xmm11\n  psubd  %xmm12,%xmm2\n  psubd  %xmm9,%xmm2\n  movdqa %xmm3,%xmm9\n  pcmpgtw %xmm1,%xmm9\n  punpcklwd %xmm9,%xmm11\n  punpckhwd %xmm9,%xmm1\n  movdqa %xmm0,%xmm9\n  psubd  %xmm11,%xmm2\n  movdqa %xmm3,%xmm11\n  psubd  %xmm1,%xmm2\n  movdqa %xmm4,%xmm1\n  pcmpgtb %xmm0,%xmm1\n  punpcklbw %xmm1,%xmm9\n  punpckhbw %xmm1,%xmm0\n  pcmpgtw %xmm9,%xmm11\n  movdqa %xmm9,%xmm1\n  punpcklwd %xmm11,%xmm1\n  punpckhwd %xmm11,%xmm9\n  paddd  %xmm10,%xmm1\n  movdqa %xmm0,%xmm10\n  paddd  %xmm9,%xmm1\n  movdqa %xmm3,%xmm9\n  pcmpgtw %xmm0,%xmm9\n  punpcklwd %xmm9,%xmm10\n  punpckhwd %xmm9,%xmm0\n  paddd  %xmm10,%xmm1\n  paddd  %xmm0,%xmm1\n  movdqa %xmm1,%xmm10\n  cmp    %rdx,%rax\n  jne    L4\n  movdqa %xmm1,%xmm0\n  mov    %ebp,%ecx\n  psrldq $0x8,%xmm0\n  and    $0xfffffff0,%ecx\n  paddd  %xmm0,%xmm10\n  movdqa %xmm10,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm10\n  movdqa %xmm2,%xmm0\n  psrldq $0x8,%xmm0\n  movd   %xmm10,%eax\n  paddd  %xmm0,%xmm2\n  movdqa %xmm2,%xmm0\n  psrldq $0x4,%xmm0\n  paddd  %xmm0,%xmm2\n  movd   %xmm2,%edx\n  test   $0xf,%bpl\n  je     L5\n  movslq %ecx,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L6\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\n  jmp    L7\nL34:\n  xor    %ecx,%ecx\n  xor    %edx,%edx\n  xor    %eax,%eax\n  nopl   0x0(%rax)\nL6:\n  add    $0x1,%eax\nL7:\n  add    $0x1,%ecx\n  cmp    %ecx,%ebp\n  jle    L5\nL35:\n  movslq %ecx,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L8\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL23:\n  lea    0x1(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L9\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL24:\n  lea    0x2(%rcx),%esi\n  cmp    %ebp,%esi\n  jge    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L10\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL25:\n  lea    0x3(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L11\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL26:\n  lea    0x4(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L12\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL27:\n  lea    0x5(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L13\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL28:\n  lea    0x6(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L14\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL29:\n  lea    0x7(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L15\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL30:\n  lea    0x8(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L16\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL31:\n  lea    0x9(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L17\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL32:\n  lea    0xa(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L18\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL33:\n  lea    0xb(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L19\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL36:\n  lea    0xc(%rcx),%esi\n  cmp    %esi,%ebp\n  jle    L5\n  movslq %esi,%rsi\n  movzbl (%rbx,%rsi,1),%esi\n  lea    -0x30(%rsi),%edi\n  cmp    $0x9,%dil\n  jbe    L20\n  cmp    $0x2e,%sil\n  sete   %sil\n  movzbl %sil,%esi\n  add    %esi,%edx\nL37:\n  add    $0xd,%ecx\n  cmp    %ecx,%ebp\n  jle    L5\n  movslq %ecx,%rcx\n  movzbl (%rbx,%rcx,1),%ecx\n  lea    -0x30(%rcx),%esi\n  cmp    $0x9,%sil\n  ja     L21\n  add    $0x1,%eax\n  nopw   0x0(%rax,%rax,1)\nL5:\n  cmp    $0x3,%eax\n  jg     L1\n  lea    D6(%rip),%r12\n  cmp    $0x1,%edx\n  je     L0\n  nopl   0x0(%rax)\nL1:\n  lea    D0(%rip),%r12\nL0:\n  pop    %rbx\n  mov    %r12,%rax\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  lea    D7(%rip),%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L22\n  lea    D8(%rip),%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L22\n  jmp    L0\nL8:\n  add    $0x1,%eax\n  jmp    L23\n  nopl   0x0(%rax,%rax,1)\nL9:\n  add    $0x1,%eax\n  jmp    L24\n  nopl   0x0(%rax,%rax,1)\nL10:\n  add    $0x1,%eax\n  jmp    L25\n  nopl   0x0(%rax,%rax,1)\nL11:\n  add    $0x1,%eax\n  jmp    L26\n  nopl   0x0(%rax,%rax,1)\nL12:\n  add    $0x1,%eax\n  jmp    L27\n  nopl   0x0(%rax,%rax,1)\nL13:\n  add    $0x1,%eax\n  jmp    L28\n  nopl   0x0(%rax,%rax,1)\nL14:\n  add    $0x1,%eax\n  jmp    L29\n  nopl   0x0(%rax,%rax,1)\nL15:\n  add    $0x1,%eax\n  jmp    L30\n  nopl   0x0(%rax,%rax,1)\nL16:\n  add    $0x1,%eax\n  jmp    L31\n  nopl   0x0(%rax,%rax,1)\nL17:\n  add    $0x1,%eax\n  jmp    L32\n  nopl   0x0(%rax,%rax,1)\nL18:\n  add    $0x1,%eax\n  jmp    L33\n  nopl   0x0(%rax,%rax,1)\nL3:\n  sub    $0x30,%r13d\n  cmp    $0x9,%r13b\n  jbe    L34\n  xor    %edx,%edx\n  xor    %eax,%eax\n  mov    $0x1,%ecx\n  jmp    L35\n  nopl   0x0(%rax)\nL19:\n  add    $0x1,%eax\n  jmp    L36\nL20:\n  add    $0x1,%eax\n  jmp    L37\nL21:\n  cmp    $0x2e,%cl\n  sete   %cl\n  movzbl %cl,%ecx\n  add    %ecx,%edx\n  jmp    L5",
        "num_missing": 4,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3759,
                    2577
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8199,
                "bias": [
                    3706
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8224,
                "bias": [
                    3683
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8240,
                "bias": [
                    3691
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8256,
                "bias": [
                    3681
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8272,
                "bias": [
                    3689
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8195,
                "bias": [
                    2599
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8204,
                "bias": [
                    2565
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8209,
                "bias": [
                    2547
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5615
            },
            "L1": {
                "label": "L1",
                "addr": 5608
            },
            "L2": {
                "label": "L2",
                "addr": 5632
            },
            "L3": {
                "label": "L3",
                "addr": 5856
            },
            "L4": {
                "label": "L4",
                "addr": 4600
            },
            "L5": {
                "label": "L5",
                "addr": 5584
            },
            "L6": {
                "label": "L6",
                "addr": 4968
            },
            "L7": {
                "label": "L7",
                "addr": 4971
            },
            "L8": {
                "label": "L8",
                "addr": 5680
            },
            "L9": {
                "label": "L9",
                "addr": 5696
            },
            "L10": {
                "label": "L10",
                "addr": 5712
            },
            "L11": {
                "label": "L11",
                "addr": 5728
            },
            "L12": {
                "label": "L12",
                "addr": 5744
            },
            "L13": {
                "label": "L13",
                "addr": 5760
            },
            "L14": {
                "label": "L14",
                "addr": 5776
            },
            "L15": {
                "label": "L15",
                "addr": 5792
            },
            "L16": {
                "label": "L16",
                "addr": 5808
            },
            "L17": {
                "label": "L17",
                "addr": 5824
            },
            "L18": {
                "label": "L18",
                "addr": 5840
            },
            "L19": {
                "label": "L19",
                "addr": 5888
            },
            "L20": {
                "label": "L20",
                "addr": 5896
            },
            "L21": {
                "label": "L21",
                "addr": 5904
            },
            "L22": {
                "label": "L22",
                "addr": 4514
            },
            "L23": {
                "label": "L23",
                "addr": 5016
            },
            "L24": {
                "label": "L24",
                "addr": 5061
            },
            "L25": {
                "label": "L25",
                "addr": 5106
            },
            "L26": {
                "label": "L26",
                "addr": 5151
            },
            "L27": {
                "label": "L27",
                "addr": 5196
            },
            "L28": {
                "label": "L28",
                "addr": 5241
            },
            "L29": {
                "label": "L29",
                "addr": 5286
            },
            "L30": {
                "label": "L30",
                "addr": 5331
            },
            "L31": {
                "label": "L31",
                "addr": 5376
            },
            "L32": {
                "label": "L32",
                "addr": 5421
            },
            "L33": {
                "label": "L33",
                "addr": 5466
            },
            "L34": {
                "label": "L34",
                "addr": 4958
            },
            "L35": {
                "label": "L35",
                "addr": 4982
            },
            "L36": {
                "label": "L36",
                "addr": 5507
            },
            "L37": {
                "label": "L37",
                "addr": 5548
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e6f00596573002e747874002e657865002e646c6c0000000000000000000000d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0d0090909090909090909090909090909092e2e2e2e2e2e2e2e2e2e2e2e2e2e2e2e01010101010101010101010101010101",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"No\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"Yes\""
                },
                "0x2007": {
                    "type": "string",
                    "value": "\".txt\""
                },
                "0x200c": {
                    "type": "string",
                    "value": "\".exe\""
                },
                "0x2011": {
                    "type": "string",
                    "value": "\".dll\""
                },
                "0x2020": {
                    "type": "byte[16]",
                    "value": [
                        208,
                        208,
                        208,
                        208,
                        208,
                        208,
                        208,
                        208,
                        208,
                        208,
                        208,
                        208,
                        208,
                        208,
                        208,
                        208
                    ]
                },
                "0x2030": {
                    "type": "byte[16]",
                    "value": [
                        9,
                        9,
                        9,
                        9,
                        9,
                        9,
                        9,
                        9,
                        9,
                        9,
                        9,
                        9,
                        9,
                        9,
                        9,
                        9
                    ]
                },
                "0x2040": {
                    "type": "byte[16]",
                    "value": [
                        46,
                        46,
                        46,
                        46,
                        46,
                        46,
                        46,
                        46,
                        46,
                        46,
                        46,
                        46,
                        46,
                        46,
                        46,
                        46
                    ]
                },
                "0x2050": {
                    "type": "byte[16]",
                    "value": [
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1,
                        1
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 142,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    11e9 <func0+0xf0>\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  test   %eax,%eax\n  jne    1175 <func0+0x7c>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %edx,%eax\n  add    %eax,-0x8(%rbp)\n  jmp    11e5 <func0+0xec>\n  mov    -0x4(%rbp),%eax\n  and    $0x3,%eax\n  test   %eax,%eax\n  jne    11cc <func0+0xd3>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %eax,%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %edx,%eax\n  add    %eax,-0x8(%rbp)\n  jmp    11e5 <func0+0xec>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     111b <func0+0x22>\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %esi,-0x1c(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL4:\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  test   %eax,%eax\n  jne    L1\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %edx,%eax\n  add    %eax,-0x8(%rbp)\n  jmp    L2\nL1:\n  mov    -0x4(%rbp),%eax\n  and    $0x3,%eax\n  test   %eax,%eax\n  jne    L3\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %eax,%edx\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x18(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  imul   %edx,%eax\n  add    %eax,-0x8(%rbp)\n  jmp    L2\nL3:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  add    %eax,-0x8(%rbp)\nL2:\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x1c(%rbp),%eax\n  jl     L4\n  mov    -0x8(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4585
            },
            "L1": {
                "label": "L1",
                "addr": 4469
            },
            "L2": {
                "label": "L2",
                "addr": 4581
            },
            "L3": {
                "label": "L3",
                "addr": 4556
            },
            "L4": {
                "label": "L4",
                "addr": 4379
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 142,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  test   %esi,%esi\n  jle    115b <func0+0x62>\n  mov    %esi,%esi\n  mov    $0x0,%edx\n  mov    $0x0,%ecx\n  jmp    112e <func0+0x35>\n  test   $0x3,%dl\n  jne    1155 <func0+0x5c>\n  mov    (%r8,%rdx,4),%edi\n  mov    %edi,%eax\n  imul   %edi,%eax\n  imul   %edi,%eax\n  add    %eax,%ecx\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  je     1160 <func0+0x67>\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  lea    (%rax,%rax,2),%eax\n  cmp    %edx,%eax\n  jne    1112 <func0+0x19>\n  mov    (%r8,%rdx,4),%eax\n  imul   %eax,%eax\n  add    %eax,%ecx\n  jmp    1125 <func0+0x2c>\n  add    (%r8,%rdx,4),%ecx\n  jmp    1125 <func0+0x2c>\n  mov    $0x0,%ecx\n  mov    %ecx,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r8\n  test   %esi,%esi\n  jle    L0\n  mov    %esi,%esi\n  mov    $0x0,%edx\n  mov    $0x0,%ecx\n  jmp    L1\nL4:\n  test   $0x3,%dl\n  jne    L2\n  mov    (%r8,%rdx,4),%edi\n  mov    %edi,%eax\n  imul   %edi,%eax\n  imul   %edi,%eax\n  add    %eax,%ecx\nL5:\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  je     L3\nL1:\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  lea    (%rax,%rax,2),%eax\n  cmp    %edx,%eax\n  jne    L4\n  mov    (%r8,%rdx,4),%eax\n  imul   %eax,%eax\n  add    %eax,%ecx\n  jmp    L5\nL2:\n  add    (%r8,%rdx,4),%ecx\n  jmp    L5\nL0:\n  mov    $0x0,%ecx\nL3:\n  mov    %ecx,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4443
            },
            "L1": {
                "label": "L1",
                "addr": 4398
            },
            "L2": {
                "label": "L2",
                "addr": 4437
            },
            "L3": {
                "label": "L3",
                "addr": 4448
            },
            "L4": {
                "label": "L4",
                "addr": 4370
            },
            "L5": {
                "label": "L5",
                "addr": 4389
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 142,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1160 <func0+0x60>\n  movslq %esi,%rsi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  jmp    1127 <func0+0x27>\n  nopw   0x0(%rax,%rax,1)\n  imul   %edx,%edx\n  add    %edx,%r8d\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     1150 <func0+0x50>\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  mov    (%rdi,%rax,4),%edx\n  jbe    1118 <func0+0x18>\n  test   $0x3,%al\n  jne    1158 <func0+0x58>\n  mov    %edx,%ecx\n  add    $0x1,%rax\n  imul   %edx,%ecx\n  imul   %ecx,%edx\n  add    %edx,%r8d\n  cmp    %rsi,%rax\n  jne    1127 <func0+0x27>\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\n  add    %edx,%r8d\n  jmp    111e <func0+0x1e>\n  nopl   (%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rsi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  imul   %edx,%edx\n  add    %edx,%r8d\nL5:\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     L2\nL1:\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  mov    (%rdi,%rax,4),%edx\n  jbe    L3\n  test   $0x3,%al\n  jne    L4\n  mov    %edx,%ecx\n  add    $0x1,%rax\n  imul   %edx,%ecx\n  imul   %ecx,%edx\n  add    %edx,%r8d\n  cmp    %rsi,%rax\n  jne    L1\nL2:\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\nL4:\n  add    %edx,%r8d\n  jmp    L5\n  nopl   (%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4448
            },
            "L1": {
                "label": "L1",
                "addr": 4391
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4376
            },
            "L4": {
                "label": "L4",
                "addr": 4440
            },
            "L5": {
                "label": "L5",
                "addr": 4382
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 142,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int* lst, int size) {\n    int sum = 0;\n    for (int i = 0; i < size; i++) {\n        if (i % 3 == 0) sum += lst[i] * lst[i];\n        else if (i % 4 == 0) sum += lst[i] * lst[i] * lst[i];\n        else sum += lst[i];\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int lst[] = {1, 2, 3};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 6);\n    }\n    {\n        int lst[] = {1, 4, 9};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 14);\n    }\n    {\n        int lst[] = {};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {1, 1, 1, 1, 1, 1, 1, 1, 1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 9);\n    }\n    {\n        int lst[] = {-1, -1, -1, -1, -1, -1, -1, -1, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -3);\n    }\n    {\n        int lst[] = {0};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-1, -5, 2, -1, -5};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -126);\n    }\n    {\n        int lst[] = {-56, -99, 1, 0, -2};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 3030);\n    }\n    {\n        int lst[] = {-1, 0, 0, 0, 0, 0, 0, 0, -1};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == 0);\n    }\n    {\n        int lst[] = {-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -14196);\n    }\n    {\n        int lst[] = {-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10};\n        assert(func0(lst, sizeof(lst)/sizeof(lst[0])) == -1448);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1160 <func0+0x60>\n  movslq %esi,%rsi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  jmp    1127 <func0+0x27>\n  nopw   0x0(%rax,%rax,1)\n  imul   %edx,%edx\n  add    %edx,%r8d\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     1150 <func0+0x50>\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  mov    (%rdi,%rax,4),%edx\n  jbe    1118 <func0+0x18>\n  test   $0x3,%al\n  jne    1158 <func0+0x58>\n  mov    %edx,%ecx\n  add    $0x1,%rax\n  imul   %edx,%ecx\n  imul   %ecx,%edx\n  add    %edx,%r8d\n  cmp    %rsi,%rax\n  jne    1127 <func0+0x27>\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\n  add    %edx,%r8d\n  jmp    111e <func0+0x1e>\n  nopl   (%rax)\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  movslq %esi,%rsi\n  xor    %eax,%eax\n  xor    %r8d,%r8d\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  imul   %edx,%edx\n  add    %edx,%r8d\nL5:\n  add    $0x1,%rax\n  cmp    %rsi,%rax\n  je     L2\nL1:\n  imul   $0xaaaaaaab,%eax,%edx\n  cmp    $0x55555555,%edx\n  mov    (%rdi,%rax,4),%edx\n  jbe    L3\n  test   $0x3,%al\n  jne    L4\n  mov    %edx,%ecx\n  add    $0x1,%rax\n  imul   %edx,%ecx\n  imul   %ecx,%edx\n  add    %edx,%r8d\n  cmp    %rsi,%rax\n  jne    L1\nL2:\n  mov    %r8d,%eax\n  ret\n  nopl   0x0(%rax)\nL4:\n  add    %edx,%r8d\n  jmp    L5\n  nopl   (%rax)\nL0:\n  xor    %r8d,%r8d\n  mov    %r8d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4448
            },
            "L1": {
                "label": "L1",
                "addr": 4391
            },
            "L2": {
                "label": "L2",
                "addr": 4432
            },
            "L3": {
                "label": "L3",
                "addr": 4376
            },
            "L4": {
                "label": "L4",
                "addr": 4440
            },
            "L5": {
                "label": "L5",
                "addr": 4382
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 143,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    120f <func0+0xf6>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     116b <func0+0x52>\n  addl   $0x1,-0x14(%rbp)\n  jmp    120b <func0+0xf2>\n  cmpl   $0x1,-0x14(%rbp)\n  jle    11a2 <func0+0x89>\n  movb   $0x1,-0x15(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    1195 <func0+0x7c>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1191 <func0+0x78>\n  movb   $0x0,-0x15(%rbp)\n  jmp    11a6 <func0+0x8d>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    117e <func0+0x65>\n  jmp    11a6 <func0+0x8d>\n  movb   $0x0,-0x15(%rbp)\n  cmpb   $0x0,-0x15(%rbp)\n  je     1204 <func0+0xeb>\n  cmpl   $0x0,-0x10(%rbp)\n  jle    11c8 <func0+0xaf>\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  mov    %rdx,%rsi\n  sub    %rcx,%rsi\n  mov    -0x28(%rbp),%rdx\n  add    %rdx,%rsi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x30(%rbp),%rdx\n  add    %rdx,%rcx\n  mov    %rax,%rdx\n  mov    %rcx,%rdi\n  call   1050 <memcpy@plt>\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x10(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    114e <func0+0x35>\n  cmpl   $0x1,-0x14(%rbp)\n  jle    125e <func0+0x145>\n  movb   $0x1,-0x15(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    1251 <func0+0x138>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    124d <func0+0x134>\n  movb   $0x0,-0x15(%rbp)\n  jmp    1262 <func0+0x149>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    123a <func0+0x121>\n  jmp    1262 <func0+0x149>\n  movb   $0x0,-0x15(%rbp)\n  cmpb   $0x0,-0x15(%rbp)\n  je     12c0 <func0+0x1a7>\n  cmpl   $0x0,-0x10(%rbp)\n  jle    1284 <func0+0x16b>\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  mov    %rdx,%rsi\n  sub    %rcx,%rsi\n  mov    -0x28(%rbp),%rdx\n  add    %rdx,%rsi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x30(%rbp),%rdx\n  add    %rdx,%rcx\n  mov    %rax,%rdx\n  mov    %rcx,%rdi\n  call   1050 <memcpy@plt>\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL10:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x20,%al\n  je     L1\n  addl   $0x1,-0x14(%rbp)\n  jmp    L2\nL1:\n  cmpl   $0x1,-0x14(%rbp)\n  jle    L3\n  movb   $0x1,-0x15(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    L4\nL7:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L5\n  movb   $0x0,-0x15(%rbp)\n  jmp    L6\nL5:\n  addl   $0x1,-0x8(%rbp)\nL4:\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L7\n  jmp    L6\nL3:\n  movb   $0x0,-0x15(%rbp)\nL6:\n  cmpb   $0x0,-0x15(%rbp)\n  je     L8\n  cmpl   $0x0,-0x10(%rbp)\n  jle    L9\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\nL9:\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  mov    %rdx,%rsi\n  sub    %rcx,%rsi\n  mov    -0x28(%rbp),%rdx\n  add    %rdx,%rsi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x30(%rbp),%rdx\n  add    %rdx,%rcx\n  mov    %rax,%rdx\n  mov    %rcx,%rdi\n  call   <memcpy@plt>\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x10(%rbp)\nL8:\n  movl   $0x0,-0x14(%rbp)\nL2:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L10\n  cmpl   $0x1,-0x14(%rbp)\n  jle    L11\n  movb   $0x1,-0x15(%rbp)\n  movl   $0x2,-0x8(%rbp)\n  jmp    L12\nL15:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x8(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L13\n  movb   $0x0,-0x15(%rbp)\n  jmp    L14\nL13:\n  addl   $0x1,-0x8(%rbp)\nL12:\n  mov    -0x8(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L15\n  jmp    L14\nL11:\n  movb   $0x0,-0x15(%rbp)\nL14:\n  cmpb   $0x0,-0x15(%rbp)\n  je     L16\n  cmpl   $0x0,-0x10(%rbp)\n  jle    L17\n  mov    -0x10(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    %edx,-0x10(%rbp)\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x20,(%rax)\nL17:\n  mov    -0x14(%rbp),%eax\n  cltq\n  mov    -0xc(%rbp),%edx\n  movslq %edx,%rdx\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  mov    %rdx,%rsi\n  sub    %rcx,%rsi\n  mov    -0x28(%rbp),%rdx\n  add    %rdx,%rsi\n  mov    -0x10(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x30(%rbp),%rdx\n  add    %rdx,%rcx\n  mov    %rax,%rdx\n  mov    %rcx,%rdi\n  call   <memcpy@plt>\n  mov    -0x14(%rbp),%eax\n  add    %eax,-0x10(%rbp)\nL16:\n  mov    -0x10(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x30(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  nop\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4623
            },
            "L1": {
                "label": "L1",
                "addr": 4459
            },
            "L2": {
                "label": "L2",
                "addr": 4619
            },
            "L3": {
                "label": "L3",
                "addr": 4514
            },
            "L4": {
                "label": "L4",
                "addr": 4501
            },
            "L5": {
                "label": "L5",
                "addr": 4497
            },
            "L6": {
                "label": "L6",
                "addr": 4518
            },
            "L7": {
                "label": "L7",
                "addr": 4478
            },
            "L8": {
                "label": "L8",
                "addr": 4612
            },
            "L9": {
                "label": "L9",
                "addr": 4552
            },
            "L10": {
                "label": "L10",
                "addr": 4430
            },
            "L11": {
                "label": "L11",
                "addr": 4702
            },
            "L12": {
                "label": "L12",
                "addr": 4689
            },
            "L13": {
                "label": "L13",
                "addr": 4685
            },
            "L14": {
                "label": "L14",
                "addr": 4706
            },
            "L15": {
                "label": "L15",
                "addr": 4666
            },
            "L16": {
                "label": "L16",
                "addr": 4800
            },
            "L17": {
                "label": "L17",
                "addr": 4740
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 143,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rsi,%r14\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     11ca <func0+0xb1>\n  mov    %rdi,%r12\n  mov    $0x0,%r13d\n  mov    $0x0,%ebx\n  mov    $0x0,%ebp\n  jmp    115f <func0+0x46>\n  cmp    $0x1,%ebx\n  jg     1168 <func0+0x4f>\n  mov    $0x0,%ebx\n  add    $0x1,%rbp\n  movzbl (%r12,%rbp,1),%eax\n  test   %al,%al\n  je     119f <func0+0x86>\n  cmp    $0x20,%al\n  je     1148 <func0+0x2f>\n  add    $0x1,%ebx\n  jmp    1152 <func0+0x39>\n  cmp    $0x3,%ebx\n  jle    120c <func0+0xf3>\n  test   $0x1,%bl\n  je     1198 <func0+0x7f>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     120c <func0+0xf3>\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    117b <func0+0x62>\n  mov    %edx,%ebx\n  jmp    1152 <func0+0x39>\n  mov    $0x0,%ebx\n  jmp    1152 <func0+0x39>\n  cmp    $0x1,%ebx\n  jle    11fb <func0+0xe2>\n  cmp    $0x3,%ebx\n  jle    11d2 <func0+0xb9>\n  test   $0x1,%bl\n  je     11fb <func0+0xe2>\n  mov    $0x2,%ecx\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     11d2 <func0+0xb9>\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    11b3 <func0+0x9a>\n  jmp    11fb <func0+0xe2>\n  mov    $0x0,%r13d\n  jmp    11fb <func0+0xe2>\n  test   %r13d,%r13d\n  jle    11e3 <func0+0xca>\n  movslq %r13d,%rax\n  movb   $0x20,(%r14,%rax,1)\n  lea    0x1(%r13),%r13d\n  movslq %ebx,%rdx\n  movslq %r13d,%rdi\n  add    %r14,%rdi\n  sub    %rdx,%rbp\n  lea    (%r12,%rbp,1),%rsi\n  call   1050 <memcpy@plt>\n  add    %ebx,%r13d\n  movslq %r13d,%r13\n  movb   $0x0,(%r14,%r13,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  test   %r13d,%r13d\n  jle    121d <func0+0x104>\n  movslq %r13d,%rax\n  movb   $0x20,(%r14,%rax,1)\n  lea    0x1(%r13),%r13d\n  movslq %ebx,%rdx\n  movslq %r13d,%rdi\n  add    %r14,%rdi\n  mov    %rbp,%rsi\n  sub    %rdx,%rsi\n  add    %r12,%rsi\n  call   1050 <memcpy@plt>\n  add    %ebx,%r13d\n  mov    $0x0,%ebx\n  jmp    1152 <func0+0x39>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %rsi,%r14\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  mov    %rdi,%r12\n  mov    $0x0,%r13d\n  mov    $0x0,%ebx\n  mov    $0x0,%ebp\n  jmp    L1\nL4:\n  cmp    $0x1,%ebx\n  jg     L2\n  mov    $0x0,%ebx\nL5:\n  add    $0x1,%rbp\n  movzbl (%r12,%rbp,1),%eax\n  test   %al,%al\n  je     L3\nL1:\n  cmp    $0x20,%al\n  je     L4\n  add    $0x1,%ebx\n  jmp    L5\nL2:\n  cmp    $0x3,%ebx\n  jle    L6\n  test   $0x1,%bl\n  je     L7\n  mov    $0x2,%ecx\nL8:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     L6\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L8\n  mov    %edx,%ebx\n  jmp    L5\nL7:\n  mov    $0x0,%ebx\n  jmp    L5\nL3:\n  cmp    $0x1,%ebx\n  jle    L9\n  cmp    $0x3,%ebx\n  jle    L10\n  test   $0x1,%bl\n  je     L9\n  mov    $0x2,%ecx\nL11:\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %ebx,%eax\n  jg     L10\n  mov    %ebx,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  jne    L11\n  jmp    L9\nL0:\n  mov    $0x0,%r13d\n  jmp    L9\nL10:\n  test   %r13d,%r13d\n  jle    L12\n  movslq %r13d,%rax\n  movb   $0x20,(%r14,%rax,1)\n  lea    0x1(%r13),%r13d\nL12:\n  movslq %ebx,%rdx\n  movslq %r13d,%rdi\n  add    %r14,%rdi\n  sub    %rdx,%rbp\n  lea    (%r12,%rbp,1),%rsi\n  call   <memcpy@plt>\n  add    %ebx,%r13d\nL9:\n  movslq %r13d,%r13\n  movb   $0x0,(%r14,%r13,1)\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL6:\n  test   %r13d,%r13d\n  jle    L13\n  movslq %r13d,%rax\n  movb   $0x20,(%r14,%rax,1)\n  lea    0x1(%r13),%r13d\nL13:\n  movslq %ebx,%rdx\n  movslq %r13d,%rdi\n  add    %r14,%rdi\n  mov    %rbp,%rsi\n  sub    %rdx,%rsi\n  add    %r12,%rsi\n  call   <memcpy@plt>\n  add    %ebx,%r13d\n  mov    $0x0,%ebx\n  jmp    L5",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4554
            },
            "L1": {
                "label": "L1",
                "addr": 4447
            },
            "L2": {
                "label": "L2",
                "addr": 4456
            },
            "L3": {
                "label": "L3",
                "addr": 4511
            },
            "L4": {
                "label": "L4",
                "addr": 4424
            },
            "L5": {
                "label": "L5",
                "addr": 4434
            },
            "L6": {
                "label": "L6",
                "addr": 4620
            },
            "L7": {
                "label": "L7",
                "addr": 4504
            },
            "L8": {
                "label": "L8",
                "addr": 4475
            },
            "L9": {
                "label": "L9",
                "addr": 4603
            },
            "L10": {
                "label": "L10",
                "addr": 4562
            },
            "L11": {
                "label": "L11",
                "addr": 4531
            },
            "L12": {
                "label": "L12",
                "addr": 4579
            },
            "L13": {
                "label": "L13",
                "addr": 4637
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 143,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     11e2 <func0+0xc2>\n  mov    %rdi,%rbp\n  xor    %r13d,%r13d\n  xor    %ecx,%ecx\n  xor    %ebx,%ebx\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%ecx\n  add    $0x1,%rbx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  je     117c <func0+0x5c>\n  cmp    $0x20,%al\n  jne    1150 <func0+0x30>\n  cmp    $0x1,%ecx\n  jg     11f8 <func0+0xd8>\n  add    $0x1,%rbx\n  xor    %ecx,%ecx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  jne    1160 <func0+0x40>\n  cmp    $0x1,%ecx\n  jle    11dc <func0+0xbc>\n  cmp    $0x3,%ecx\n  jle    11ad <func0+0x8d>\n  mov    $0x2,%esi\n  test   $0x1,%cl\n  jne    11a1 <func0+0x81>\n  jmp    11dc <func0+0xbc>\n  nopw   0x0(%rax,%rax,1)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     11dc <func0+0xbc>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1198 <func0+0x78>\n  test   %r13d,%r13d\n  je     1260 <func0+0x140>\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rcx,%rax,1),%r13d\n  add    %r12,%rdi\n  movslq %ecx,%rdx\n  sub    %rdx,%rbx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  call   1050 <memcpy@plt>\n  movslq %r13d,%r13\n  add    %r13,%r12\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x3,%ecx\n  jle    1229 <func0+0x109>\n  test   $0x1,%cl\n  je     116d <func0+0x4d>\n  mov    $0x2,%esi\n  jmp    121d <func0+0xfd>\n  nopl   (%rax)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     116d <func0+0x4d>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1210 <func0+0xf0>\n  test   %r13d,%r13d\n  je     1270 <func0+0x150>\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rax,%rcx,1),%r13d\n  add    %r12,%rdi\n  movslq %ecx,%rdx\n  mov    %rbx,%rsi\n  sub    %rdx,%rsi\n  add    %rbp,%rsi\n  call   1050 <memcpy@plt>\n  xor    %ecx,%ecx\n  jmp    1153 <func0+0x33>\n  nopl   0x0(%rax)\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    11cc <func0+0xac>\n  nopl   0x0(%rax,%rax,1)\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    1244 <func0+0x124>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  mov    %rdi,%rbp\n  xor    %r13d,%r13d\n  xor    %ecx,%ecx\n  xor    %ebx,%ebx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%ecx\nL15:\n  add    $0x1,%rbx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  je     L2\nL1:\n  cmp    $0x20,%al\n  jne    L3\n  cmp    $0x1,%ecx\n  jg     L4\nL11:\n  add    $0x1,%rbx\n  xor    %ecx,%ecx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  jne    L1\nL2:\n  cmp    $0x1,%ecx\n  jle    L5\n  cmp    $0x3,%ecx\n  jle    L6\n  mov    $0x2,%esi\n  test   $0x1,%cl\n  jne    L7\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L5\nL7:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L8\nL6:\n  test   %r13d,%r13d\n  je     L9\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rcx,%rax,1),%r13d\n  add    %r12,%rdi\nL16:\n  movslq %ecx,%rdx\n  sub    %rdx,%rbx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  call   <memcpy@plt>\nL5:\n  movslq %r13d,%r13\n  add    %r13,%r12\nL0:\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    $0x3,%ecx\n  jle    L10\n  test   $0x1,%cl\n  je     L11\n  mov    $0x2,%esi\n  jmp    L12\n  nopl   (%rax)\nL13:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L11\nL12:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L13\nL10:\n  test   %r13d,%r13d\n  je     L14\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rax,%rcx,1),%r13d\n  add    %r12,%rdi\nL17:\n  movslq %ecx,%rdx\n  mov    %rbx,%rsi\n  sub    %rdx,%rsi\n  add    %rbp,%rsi\n  call   <memcpy@plt>\n  xor    %ecx,%ecx\n  jmp    L15\n  nopl   0x0(%rax)\nL9:\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    L16\n  nopl   0x0(%rax,%rax,1)\nL14:\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    L17",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4578
            },
            "L1": {
                "label": "L1",
                "addr": 4448
            },
            "L2": {
                "label": "L2",
                "addr": 4476
            },
            "L3": {
                "label": "L3",
                "addr": 4432
            },
            "L4": {
                "label": "L4",
                "addr": 4600
            },
            "L5": {
                "label": "L5",
                "addr": 4572
            },
            "L6": {
                "label": "L6",
                "addr": 4525
            },
            "L7": {
                "label": "L7",
                "addr": 4513
            },
            "L8": {
                "label": "L8",
                "addr": 4504
            },
            "L9": {
                "label": "L9",
                "addr": 4704
            },
            "L10": {
                "label": "L10",
                "addr": 4649
            },
            "L11": {
                "label": "L11",
                "addr": 4461
            },
            "L12": {
                "label": "L12",
                "addr": 4637
            },
            "L13": {
                "label": "L13",
                "addr": 4624
            },
            "L14": {
                "label": "L14",
                "addr": 4720
            },
            "L15": {
                "label": "L15",
                "addr": 4435
            },
            "L16": {
                "label": "L16",
                "addr": 4556
            },
            "L17": {
                "label": "L17",
                "addr": 4676
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 143,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nvoid func0(const char* sentence, char* out) {\n    int index = 0, word_len = 0;\n    int out_index = 0;\n    bool is_prime;\n    int i, j;\n\n    for (i = 0; sentence[i] != '\\0'; ++i) {\n        if (sentence[i] != ' ') {\n            word_len++;\n        } else {\n            if (word_len > 1) {\n                is_prime = true;\n                for (j = 2; j * j <= word_len; ++j) {\n                    if (word_len % j == 0) {\n                        is_prime = false;\n                        break;\n                    }\n                }\n            } else {\n                is_prime = false;\n            }\n\n            if (is_prime) {\n                if (out_index > 0) {\n                    out[out_index++] = ' ';\n                }\n                memcpy(out + out_index, sentence + i - word_len, word_len);\n                out_index += word_len;\n            }\n            word_len = 0;\n        }\n    }\n\n    if (word_len > 1) {\n        is_prime = true;\n        for (j = 2; j * j <= word_len; ++j) {\n            if (word_len % j == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n    } else {\n        is_prime = false;\n    }\n\n    if (is_prime) {\n        if (out_index > 0) {\n            out[out_index++] = ' ';\n        }\n        memcpy(out + out_index, sentence + i - word_len, word_len);\n        out_index += word_len;\n    }\n\n    out[out_index] = '\\0';\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char output[101];\n\n    func0(\"This is a test\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    func0(\"lets go for swimming\", output);\n    assert(strcmp(output, \"go for\") == 0);\n\n    func0(\"there is no place available here\", output);\n    assert(strcmp(output, \"there is no place\") == 0);\n\n    func0(\"Hi I am Hussein\", output);\n    assert(strcmp(output, \"Hi am Hussein\") == 0);\n\n    func0(\"go for it\", output);\n    assert(strcmp(output, \"go for it\") == 0);\n\n    func0(\"here\", output);\n    assert(strcmp(output, \"\") == 0);\n\n    func0(\"here is\", output);\n    assert(strcmp(output, \"is\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     11e2 <func0+0xc2>\n  mov    %rdi,%rbp\n  xor    %r13d,%r13d\n  xor    %ecx,%ecx\n  xor    %ebx,%ebx\n  jmp    1160 <func0+0x40>\n  nopl   0x0(%rax,%rax,1)\n  add    $0x1,%ecx\n  add    $0x1,%rbx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  je     117c <func0+0x5c>\n  cmp    $0x20,%al\n  jne    1150 <func0+0x30>\n  cmp    $0x1,%ecx\n  jg     11f8 <func0+0xd8>\n  add    $0x1,%rbx\n  xor    %ecx,%ecx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  jne    1160 <func0+0x40>\n  cmp    $0x1,%ecx\n  jle    11dc <func0+0xbc>\n  cmp    $0x3,%ecx\n  jle    11ad <func0+0x8d>\n  mov    $0x2,%esi\n  test   $0x1,%cl\n  jne    11a1 <func0+0x81>\n  jmp    11dc <func0+0xbc>\n  nopw   0x0(%rax,%rax,1)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     11dc <func0+0xbc>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1198 <func0+0x78>\n  test   %r13d,%r13d\n  je     1260 <func0+0x140>\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rcx,%rax,1),%r13d\n  add    %r12,%rdi\n  movslq %ecx,%rdx\n  sub    %rdx,%rbx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  call   1050 <memcpy@plt>\n  movslq %r13d,%r13\n  add    %r13,%r12\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x3,%ecx\n  jle    1229 <func0+0x109>\n  test   $0x1,%cl\n  je     116d <func0+0x4d>\n  mov    $0x2,%esi\n  jmp    121d <func0+0xfd>\n  nopl   (%rax)\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     116d <func0+0x4d>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    1210 <func0+0xf0>\n  test   %r13d,%r13d\n  je     1270 <func0+0x150>\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rax,%rcx,1),%r13d\n  add    %r12,%rdi\n  movslq %ecx,%rdx\n  mov    %rbx,%rsi\n  sub    %rdx,%rsi\n  add    %rbp,%rsi\n  call   1050 <memcpy@plt>\n  xor    %ecx,%ecx\n  jmp    1153 <func0+0x33>\n  nopl   0x0(%rax)\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    11cc <func0+0xac>\n  nopl   0x0(%rax,%rax,1)\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    1244 <func0+0x124>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  mov    %rdi,%rbp\n  xor    %r13d,%r13d\n  xor    %ecx,%ecx\n  xor    %ebx,%ebx\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL3:\n  add    $0x1,%ecx\nL15:\n  add    $0x1,%rbx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  je     L2\nL1:\n  cmp    $0x20,%al\n  jne    L3\n  cmp    $0x1,%ecx\n  jg     L4\nL11:\n  add    $0x1,%rbx\n  xor    %ecx,%ecx\n  movzbl 0x0(%rbp,%rbx,1),%eax\n  test   %al,%al\n  jne    L1\nL2:\n  cmp    $0x1,%ecx\n  jle    L5\n  cmp    $0x3,%ecx\n  jle    L6\n  mov    $0x2,%esi\n  test   $0x1,%cl\n  jne    L7\n  jmp    L5\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L5\nL7:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L8\nL6:\n  test   %r13d,%r13d\n  je     L9\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rcx,%rax,1),%r13d\n  add    %r12,%rdi\nL16:\n  movslq %ecx,%rdx\n  sub    %rdx,%rbx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  call   <memcpy@plt>\nL5:\n  movslq %r13d,%r13\n  add    %r13,%r12\nL0:\n  movb   $0x0,(%r12)\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  ret\n  nopw   0x0(%rax,%rax,1)\nL4:\n  cmp    $0x3,%ecx\n  jle    L10\n  test   $0x1,%cl\n  je     L11\n  mov    $0x2,%esi\n  jmp    L12\n  nopl   (%rax)\nL13:\n  mov    %ecx,%eax\n  cltd\n  idiv   %esi\n  test   %edx,%edx\n  je     L11\nL12:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  imul   %esi,%eax\n  cmp    %ecx,%eax\n  jle    L13\nL10:\n  test   %r13d,%r13d\n  je     L14\n  lea    0x1(%r13),%eax\n  movslq %r13d,%r13\n  movslq %eax,%rdi\n  movb   $0x20,(%r12,%r13,1)\n  lea    (%rax,%rcx,1),%r13d\n  add    %r12,%rdi\nL17:\n  movslq %ecx,%rdx\n  mov    %rbx,%rsi\n  sub    %rdx,%rsi\n  add    %rbp,%rsi\n  call   <memcpy@plt>\n  xor    %ecx,%ecx\n  jmp    L15\n  nopl   0x0(%rax)\nL9:\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    L16\n  nopl   0x0(%rax,%rax,1)\nL14:\n  mov    %ecx,%r13d\n  mov    %r12,%rdi\n  jmp    L17",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4578
            },
            "L1": {
                "label": "L1",
                "addr": 4448
            },
            "L2": {
                "label": "L2",
                "addr": 4476
            },
            "L3": {
                "label": "L3",
                "addr": 4432
            },
            "L4": {
                "label": "L4",
                "addr": 4600
            },
            "L5": {
                "label": "L5",
                "addr": 4572
            },
            "L6": {
                "label": "L6",
                "addr": 4525
            },
            "L7": {
                "label": "L7",
                "addr": 4513
            },
            "L8": {
                "label": "L8",
                "addr": 4504
            },
            "L9": {
                "label": "L9",
                "addr": 4704
            },
            "L10": {
                "label": "L10",
                "addr": 4649
            },
            "L11": {
                "label": "L11",
                "addr": 4461
            },
            "L12": {
                "label": "L12",
                "addr": 4637
            },
            "L13": {
                "label": "L13",
                "addr": 4624
            },
            "L14": {
                "label": "L14",
                "addr": 4720
            },
            "L15": {
                "label": "L15",
                "addr": 4435
            },
            "L16": {
                "label": "L16",
                "addr": 4556
            },
            "L17": {
                "label": "L17",
                "addr": 4676
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 144,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x110,%rsp\n  mov    %rdi,-0x108(%rbp)\n  mov    %rsi,-0x110(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0xf8(%rbp)\n  jmp    119d <func0+0x64>\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf8(%rbp),%eax\n  cltq\n  mov    %dl,-0xe0(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jne    1171 <func0+0x38>\n  mov    -0xf8(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe0(%rbp,%rax,1)\n  lea    -0xe0(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <atoi@plt>\n  mov    %eax,-0xf0(%rbp)\n  movl   $0x0,-0xf4(%rbp)\n  addl   $0x1,-0xf8(%rbp)\n  jmp    121f <func0+0xe6>\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf4(%rbp),%eax\n  cltq\n  mov    %dl,-0x70(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  addl   $0x1,-0xf4(%rbp)\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    11ef <func0+0xb6>\n  mov    -0xf4(%rbp),%eax\n  cltq\n  movb   $0x0,-0x70(%rbp,%rax,1)\n  lea    -0x70(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <atoi@plt>\n  mov    %eax,-0xec(%rbp)\n  movl   $0x0,-0xf8(%rbp)\n  jmp    1290 <func0+0x157>\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf8(%rbp),%eax\n  cltq\n  mov    %dl,-0xe0(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jne    1264 <func0+0x12b>\n  mov    -0xf8(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe0(%rbp,%rax,1)\n  lea    -0xe0(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <atoi@plt>\n  mov    %eax,-0xe8(%rbp)\n  movl   $0x0,-0xf4(%rbp)\n  addl   $0x1,-0xf8(%rbp)\n  jmp    1312 <func0+0x1d9>\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf4(%rbp),%eax\n  cltq\n  mov    %dl,-0x70(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  addl   $0x1,-0xf4(%rbp)\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    12e2 <func0+0x1a9>\n  mov    -0xf4(%rbp),%eax\n  cltq\n  movb   $0x0,-0x70(%rbp,%rax,1)\n  lea    -0x70(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <atoi@plt>\n  mov    %eax,-0xe4(%rbp)\n  mov    -0xf0(%rbp),%eax\n  imul   -0xe8(%rbp),%eax\n  mov    -0xec(%rbp),%edx\n  mov    %edx,%ecx\n  imul   -0xe4(%rbp),%ecx\n  cltd\n  idiv   %ecx\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    1377 <func0+0x23e>\n  mov    $0x1,%eax\n  jmp    137c <func0+0x243>\n  mov    $0x0,%eax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     1390 <func0+0x257>\n  call   1060 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x110,%rsp\n  mov    %rdi,-0x108(%rbp)\n  mov    %rsi,-0x110(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  movl   $0x0,-0xf8(%rbp)\n  jmp    L0\nL1:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf8(%rbp),%eax\n  cltq\n  mov    %dl,-0xe0(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\nL0:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jne    L1\n  mov    -0xf8(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe0(%rbp,%rax,1)\n  lea    -0xe0(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0xf0(%rbp)\n  movl   $0x0,-0xf4(%rbp)\n  addl   $0x1,-0xf8(%rbp)\n  jmp    L2\nL3:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf4(%rbp),%eax\n  cltq\n  mov    %dl,-0x70(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  addl   $0x1,-0xf4(%rbp)\nL2:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x108(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L3\n  mov    -0xf4(%rbp),%eax\n  cltq\n  movb   $0x0,-0x70(%rbp,%rax,1)\n  lea    -0x70(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0xec(%rbp)\n  movl   $0x0,-0xf8(%rbp)\n  jmp    L4\nL5:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf8(%rbp),%eax\n  cltq\n  mov    %dl,-0xe0(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\nL4:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  cmp    $0x2f,%al\n  jne    L5\n  mov    -0xf8(%rbp),%eax\n  cltq\n  movb   $0x0,-0xe0(%rbp,%rax,1)\n  lea    -0xe0(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0xe8(%rbp)\n  movl   $0x0,-0xf4(%rbp)\n  addl   $0x1,-0xf8(%rbp)\n  jmp    L6\nL7:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0xf4(%rbp),%eax\n  cltq\n  mov    %dl,-0x70(%rbp,%rax,1)\n  addl   $0x1,-0xf8(%rbp)\n  addl   $0x1,-0xf4(%rbp)\nL6:\n  mov    -0xf8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x110(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L7\n  mov    -0xf4(%rbp),%eax\n  cltq\n  movb   $0x0,-0x70(%rbp,%rax,1)\n  lea    -0x70(%rbp),%rax\n  mov    %rax,%rdi\n  call   <atoi@plt>\n  mov    %eax,-0xe4(%rbp)\n  mov    -0xf0(%rbp),%eax\n  imul   -0xe8(%rbp),%eax\n  mov    -0xec(%rbp),%edx\n  mov    %edx,%ecx\n  imul   -0xe4(%rbp),%ecx\n  cltd\n  idiv   %ecx\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L8\n  mov    $0x1,%eax\n  jmp    L9\nL8:\n  mov    $0x0,%eax\nL9:\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L10\n  call   <__stack_chk_fail@plt>\nL10:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4509
            },
            "L1": {
                "label": "L1",
                "addr": 4465
            },
            "L2": {
                "label": "L2",
                "addr": 4639
            },
            "L3": {
                "label": "L3",
                "addr": 4591
            },
            "L4": {
                "label": "L4",
                "addr": 4752
            },
            "L5": {
                "label": "L5",
                "addr": 4708
            },
            "L6": {
                "label": "L6",
                "addr": 4882
            },
            "L7": {
                "label": "L7",
                "addr": 4834
            },
            "L8": {
                "label": "L8",
                "addr": 4983
            },
            "L9": {
                "label": "L9",
                "addr": 4988
            },
            "L10": {
                "label": "L10",
                "addr": 5008
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 144,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xe0,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xd8(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%edx\n  cmp    $0x2f,%dl\n  je     12cd <func0+0x194>\n  mov    $0x1,%eax\n  lea    -0x1(%rsp),%rcx\n  mov    %dl,(%rcx,%rax,1)\n  mov    %eax,%r13d\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    117b <func0+0x42>\n  movslq %r13d,%rax\n  movb   $0x0,(%rsp,%rax,1)\n  mov    %rsp,%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1070 <strtol@plt>\n  mov    %rax,%r12\n  lea    0x1(%r13),%eax\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%eax\n  test   %al,%al\n  je     12d8 <func0+0x19f>\n  mov    $0x1,%edx\n  lea    0x6f(%rsp),%rsi\n  movslq %r13d,%r13\n  add    %r13,%rbp\n  mov    %al,(%rsi,%rdx,1)\n  mov    %edx,%ecx\n  add    $0x1,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    11ce <func0+0x95>\n  movslq %ecx,%rcx\n  movb   $0x0,0x70(%rsp,%rcx,1)\n  lea    0x70(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1070 <strtol@plt>\n  mov    %rax,%r13\n  movzbl (%rbx),%eax\n  cmp    $0x2f,%al\n  je     12e2 <func0+0x1a9>\n  mov    $0x1,%edx\n  lea    -0x1(%rsp),%rcx\n  mov    %al,(%rcx,%rdx,1)\n  mov    %edx,%ebp\n  add    $0x1,%rdx\n  movzbl -0x1(%rbx,%rdx,1),%eax\n  cmp    $0x2f,%al\n  jne    1214 <func0+0xdb>\n  movslq %ebp,%rax\n  movb   $0x0,(%rsp,%rax,1)\n  mov    %rsp,%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1070 <strtol@plt>\n  mov    %rax,%r14\n  lea    0x1(%rbp),%eax\n  cltq\n  movzbl (%rbx,%rax,1),%eax\n  test   %al,%al\n  je     12ec <func0+0x1b3>\n  mov    $0x1,%edx\n  lea    0x6f(%rsp),%rsi\n  movslq %ebp,%rbp\n  add    %rbp,%rbx\n  mov    %al,(%rsi,%rdx,1)\n  mov    %edx,%ecx\n  add    $0x1,%rdx\n  movzbl (%rbx,%rdx,1),%eax\n  test   %al,%al\n  jne    1263 <func0+0x12a>\n  movslq %ecx,%rcx\n  movb   $0x0,0x70(%rsp,%rcx,1)\n  lea    0x70(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   1070 <strtol@plt>\n  mov    %rax,%rdx\n  mov    %r14d,%eax\n  imul   %r12d,%eax\n  imul   %edx,%r13d\n  cltd\n  idiv   %r13d\n  test   %edx,%edx\n  sete   %al\n  movzbl %al,%eax\n  mov    0xd8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12f3 <func0+0x1ba>\n  add    $0xe0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  mov    $0x0,%r13d\n  jmp    118f <func0+0x56>\n  mov    $0x0,%ecx\n  jmp    11e0 <func0+0xa7>\n  mov    $0x0,%ebp\n  jmp    1226 <func0+0xed>\n  mov    $0x0,%ecx\n  jmp    1274 <func0+0x13b>\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xe0,%rsp\n  mov    %rdi,%rbp\n  mov    %rsi,%rbx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xd8(%rsp)\n  xor    %eax,%eax\n  movzbl (%rdi),%edx\n  cmp    $0x2f,%dl\n  je     L0\n  mov    $0x1,%eax\n  lea    -0x1(%rsp),%rcx\nL1:\n  mov    %dl,(%rcx,%rax,1)\n  mov    %eax,%r13d\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    L1\nL9:\n  movslq %r13d,%rax\n  movb   $0x0,(%rsp,%rax,1)\n  mov    %rsp,%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%r12\n  lea    0x1(%r13),%eax\n  cltq\n  movzbl 0x0(%rbp,%rax,1),%eax\n  test   %al,%al\n  je     L2\n  mov    $0x1,%edx\n  lea    0x6f(%rsp),%rsi\n  movslq %r13d,%r13\n  add    %r13,%rbp\nL3:\n  mov    %al,(%rsi,%rdx,1)\n  mov    %edx,%ecx\n  add    $0x1,%rdx\n  movzbl 0x0(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    L3\nL10:\n  movslq %ecx,%rcx\n  movb   $0x0,0x70(%rsp,%rcx,1)\n  lea    0x70(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%r13\n  movzbl (%rbx),%eax\n  cmp    $0x2f,%al\n  je     L4\n  mov    $0x1,%edx\n  lea    -0x1(%rsp),%rcx\nL5:\n  mov    %al,(%rcx,%rdx,1)\n  mov    %edx,%ebp\n  add    $0x1,%rdx\n  movzbl -0x1(%rbx,%rdx,1),%eax\n  cmp    $0x2f,%al\n  jne    L5\nL11:\n  movslq %ebp,%rax\n  movb   $0x0,(%rsp,%rax,1)\n  mov    %rsp,%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%r14\n  lea    0x1(%rbp),%eax\n  cltq\n  movzbl (%rbx,%rax,1),%eax\n  test   %al,%al\n  je     L6\n  mov    $0x1,%edx\n  lea    0x6f(%rsp),%rsi\n  movslq %ebp,%rbp\n  add    %rbp,%rbx\nL7:\n  mov    %al,(%rsi,%rdx,1)\n  mov    %edx,%ecx\n  add    $0x1,%rdx\n  movzbl (%rbx,%rdx,1),%eax\n  test   %al,%al\n  jne    L7\nL12:\n  movslq %ecx,%rcx\n  movb   $0x0,0x70(%rsp,%rcx,1)\n  lea    0x70(%rsp),%rdi\n  mov    $0xa,%edx\n  mov    $0x0,%esi\n  call   <strtol@plt>\n  mov    %rax,%rdx\n  mov    %r14d,%eax\n  imul   %r12d,%eax\n  imul   %edx,%r13d\n  cltd\n  idiv   %r13d\n  test   %edx,%edx\n  sete   %al\n  movzbl %al,%eax\n  mov    0xd8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L8\n  add    $0xe0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL0:\n  mov    $0x0,%r13d\n  jmp    L9\nL2:\n  mov    $0x0,%ecx\n  jmp    L10\nL4:\n  mov    $0x0,%ebp\n  jmp    L11\nL6:\n  mov    $0x0,%ecx\n  jmp    L12\nL8:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4813
            },
            "L1": {
                "label": "L1",
                "addr": 4475
            },
            "L2": {
                "label": "L2",
                "addr": 4824
            },
            "L3": {
                "label": "L3",
                "addr": 4558
            },
            "L4": {
                "label": "L4",
                "addr": 4834
            },
            "L5": {
                "label": "L5",
                "addr": 4628
            },
            "L6": {
                "label": "L6",
                "addr": 4844
            },
            "L7": {
                "label": "L7",
                "addr": 4707
            },
            "L8": {
                "label": "L8",
                "addr": 4851
            },
            "L9": {
                "label": "L9",
                "addr": 4495
            },
            "L10": {
                "label": "L10",
                "addr": 4576
            },
            "L11": {
                "label": "L11",
                "addr": 4646
            },
            "L12": {
                "label": "L12",
                "addr": 4724
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 144,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0xf8,%rsp\n  movzbl (%rdi),%edx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xe8(%rsp)\n  xor    %eax,%eax\n  cmp    $0x2f,%dl\n  je     12f0 <func0+0x1b0>\n  mov    $0x1,%eax\n  lea    0xf(%rsp),%rsi\n  nopl   0x0(%rax)\n  mov    %dl,(%rsi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    1188 <func0+0x48>\n  lea    0x1(%rcx),%r15d\n  movslq %r15d,%r14\n  lea    0x10(%rsp),%r13\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rcx,1)\n  mov    %r13,%rdi\n  call   1070 <strtol@plt>\n  mov    %rax,0x8(%rsp)\n  movzbl 0x0(%rbp,%r14,1),%eax\n  test   %al,%al\n  je     1308 <func0+0x1c8>\n  movslq %r15d,%r15\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r15,%rbp\n  nop\n  mov    %al,(%rsi,%rdx,1)\n  movslq %edx,%rcx\n  add    $0x1,%rdx\n  movzbl -0x1(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    11e0 <func0+0xa0>\n  lea    0x80(%rsp),%r14\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x80(%rsp,%rcx,1)\n  mov    %r14,%rdi\n  call   1070 <strtol@plt>\n  movzbl (%r12),%ecx\n  mov    %rax,%rbp\n  cmp    $0x2f,%cl\n  je     1310 <func0+0x1d0>\n  mov    $0x1,%edx\n  lea    0xf(%rsp),%rsi\n  nopl   (%rax)\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  cmp    $0x2f,%cl\n  jne    1230 <func0+0xf0>\n  lea    0x1(%rax),%ebx\n  movslq %ebx,%r15\n  mov    %r13,%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rax,1)\n  call   1070 <strtol@plt>\n  movzbl (%r12,%r15,1),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     1328 <func0+0x1e8>\n  movslq %ebx,%r8\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r8,%r12\n  nop\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  test   %cl,%cl\n  jne    1280 <func0+0x140>\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %r14,%rdi\n  movb   $0x0,0x80(%rsp,%rax,1)\n  call   1070 <strtol@plt>\n  mov    %rax,%r8\n  mov    0x8(%rsp),%eax\n  imul   %r8d,%ebp\n  imul   %r13d,%eax\n  cltd\n  idiv   %ebp\n  xor    %eax,%eax\n  test   %edx,%edx\n  sete   %al\n  mov    0xe8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    132f <func0+0x1ef>\n  add    $0xf8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  mov    $0x1,%r14d\n  mov    $0x1,%r15d\n  xor    %ecx,%ecx\n  jmp    11a3 <func0+0x63>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ecx,%ecx\n  jmp    11f3 <func0+0xb3>\n  nop\n  mov    $0x1,%r15d\n  mov    $0x1,%ebx\n  xor    %eax,%eax\n  jmp    124b <func0+0x10b>\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  jmp    1294 <func0+0x154>\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0xf8,%rsp\n  movzbl (%rdi),%edx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xe8(%rsp)\n  xor    %eax,%eax\n  cmp    $0x2f,%dl\n  je     L0\n  mov    $0x1,%eax\n  lea    0xf(%rsp),%rsi\n  nopl   0x0(%rax)\nL1:\n  mov    %dl,(%rsi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    L1\n  lea    0x1(%rcx),%r15d\n  movslq %r15d,%r14\nL9:\n  lea    0x10(%rsp),%r13\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rcx,1)\n  mov    %r13,%rdi\n  call   <strtol@plt>\n  mov    %rax,0x8(%rsp)\n  movzbl 0x0(%rbp,%r14,1),%eax\n  test   %al,%al\n  je     L2\n  movslq %r15d,%r15\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r15,%rbp\n  nop\nL3:\n  mov    %al,(%rsi,%rdx,1)\n  movslq %edx,%rcx\n  add    $0x1,%rdx\n  movzbl -0x1(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    L3\nL10:\n  lea    0x80(%rsp),%r14\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x80(%rsp,%rcx,1)\n  mov    %r14,%rdi\n  call   <strtol@plt>\n  movzbl (%r12),%ecx\n  mov    %rax,%rbp\n  cmp    $0x2f,%cl\n  je     L4\n  mov    $0x1,%edx\n  lea    0xf(%rsp),%rsi\n  nopl   (%rax)\nL5:\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  cmp    $0x2f,%cl\n  jne    L5\n  lea    0x1(%rax),%ebx\n  movslq %ebx,%r15\nL11:\n  mov    %r13,%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rax,1)\n  call   <strtol@plt>\n  movzbl (%r12,%r15,1),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     L6\n  movslq %ebx,%r8\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r8,%r12\n  nop\nL7:\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  test   %cl,%cl\n  jne    L7\nL12:\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %r14,%rdi\n  movb   $0x0,0x80(%rsp,%rax,1)\n  call   <strtol@plt>\n  mov    %rax,%r8\n  mov    0x8(%rsp),%eax\n  imul   %r8d,%ebp\n  imul   %r13d,%eax\n  cltd\n  idiv   %ebp\n  xor    %eax,%eax\n  test   %edx,%edx\n  sete   %al\n  mov    0xe8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L8\n  add    $0xf8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x1,%r14d\n  mov    $0x1,%r15d\n  xor    %ecx,%ecx\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL2:\n  xor    %ecx,%ecx\n  jmp    L10\n  nop\nL4:\n  mov    $0x1,%r15d\n  mov    $0x1,%ebx\n  xor    %eax,%eax\n  jmp    L11\n  nopw   0x0(%rax,%rax,1)\nL6:\n  xor    %eax,%eax\n  jmp    L12\nL8:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4848
            },
            "L1": {
                "label": "L1",
                "addr": 4488
            },
            "L2": {
                "label": "L2",
                "addr": 4872
            },
            "L3": {
                "label": "L3",
                "addr": 4576
            },
            "L4": {
                "label": "L4",
                "addr": 4880
            },
            "L5": {
                "label": "L5",
                "addr": 4656
            },
            "L6": {
                "label": "L6",
                "addr": 4904
            },
            "L7": {
                "label": "L7",
                "addr": 4736
            },
            "L8": {
                "label": "L8",
                "addr": 4911
            },
            "L9": {
                "label": "L9",
                "addr": 4515
            },
            "L10": {
                "label": "L10",
                "addr": 4595
            },
            "L11": {
                "label": "L11",
                "addr": 4683
            },
            "L12": {
                "label": "L12",
                "addr": 4756
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 144,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(const char* x, const char* n){\n    int a, b, c, d, i, j;\n    char num[101], den[101];\n\n    for (i = 0; x[i] != '/'; i++) {\n        num[i] = x[i];\n    }\n    num[i] = '\\0';\n    a = atoi(num);\n\n    for (j = 0, i = i + 1; x[i] != '\\0'; i++, j++) {\n        den[j] = x[i];\n    }\n    den[j] = '\\0';\n    b = atoi(den);\n\n    for (i = 0; n[i] != '/'; i++) {\n        num[i] = n[i];\n    }\n    num[i] = '\\0';\n    c = atoi(num);\n\n    for (j = 0, i = i + 1; n[i] != '\\0'; i++, j++) {\n        den[j] = n[i];\n    }\n    den[j] = '\\0';\n    d = atoi(den);\n\n    if ((a * c) % (b * d) == 0) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/6\", \"2/1\") == 0);\n    assert(func0(\"5/1\", \"3/1\") == 1);\n    assert(func0(\"7/10\", \"10/2\") == 0);\n    assert(func0(\"2/10\", \"50/10\") == 1);\n    assert(func0(\"7/2\", \"4/2\") == 1);\n    assert(func0(\"11/6\", \"6/1\") == 1);\n    assert(func0(\"2/3\", \"5/2\") == 0);\n    assert(func0(\"5/2\", \"3/5\") == 0);\n    assert(func0(\"2/4\", \"8/4\") == 1);\n    assert(func0(\"2/4\", \"4/2\") == 1);\n    assert(func0(\"1/5\", \"5/1\") == 1);\n    assert(func0(\"1/5\", \"1/5\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0xf8,%rsp\n  movzbl (%rdi),%edx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xe8(%rsp)\n  xor    %eax,%eax\n  cmp    $0x2f,%dl\n  je     12f0 <func0+0x1b0>\n  mov    $0x1,%eax\n  lea    0xf(%rsp),%rsi\n  nopl   0x0(%rax)\n  mov    %dl,(%rsi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    1188 <func0+0x48>\n  lea    0x1(%rcx),%r15d\n  movslq %r15d,%r14\n  lea    0x10(%rsp),%r13\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rcx,1)\n  mov    %r13,%rdi\n  call   1070 <strtol@plt>\n  mov    %rax,0x8(%rsp)\n  movzbl 0x0(%rbp,%r14,1),%eax\n  test   %al,%al\n  je     1308 <func0+0x1c8>\n  movslq %r15d,%r15\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r15,%rbp\n  nop\n  mov    %al,(%rsi,%rdx,1)\n  movslq %edx,%rcx\n  add    $0x1,%rdx\n  movzbl -0x1(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    11e0 <func0+0xa0>\n  lea    0x80(%rsp),%r14\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x80(%rsp,%rcx,1)\n  mov    %r14,%rdi\n  call   1070 <strtol@plt>\n  movzbl (%r12),%ecx\n  mov    %rax,%rbp\n  cmp    $0x2f,%cl\n  je     1310 <func0+0x1d0>\n  mov    $0x1,%edx\n  lea    0xf(%rsp),%rsi\n  nopl   (%rax)\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  cmp    $0x2f,%cl\n  jne    1230 <func0+0xf0>\n  lea    0x1(%rax),%ebx\n  movslq %ebx,%r15\n  mov    %r13,%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rax,1)\n  call   1070 <strtol@plt>\n  movzbl (%r12,%r15,1),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     1328 <func0+0x1e8>\n  movslq %ebx,%r8\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r8,%r12\n  nop\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  test   %cl,%cl\n  jne    1280 <func0+0x140>\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %r14,%rdi\n  movb   $0x0,0x80(%rsp,%rax,1)\n  call   1070 <strtol@plt>\n  mov    %rax,%r8\n  mov    0x8(%rsp),%eax\n  imul   %r8d,%ebp\n  imul   %r13d,%eax\n  cltd\n  idiv   %ebp\n  xor    %eax,%eax\n  test   %edx,%edx\n  sete   %al\n  mov    0xe8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    132f <func0+0x1ef>\n  add    $0xf8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  mov    $0x1,%r14d\n  mov    $0x1,%r15d\n  xor    %ecx,%ecx\n  jmp    11a3 <func0+0x63>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ecx,%ecx\n  jmp    11f3 <func0+0xb3>\n  nop\n  mov    $0x1,%r15d\n  mov    $0x1,%ebx\n  xor    %eax,%eax\n  jmp    124b <func0+0x10b>\n  nopw   0x0(%rax,%rax,1)\n  xor    %eax,%eax\n  jmp    1294 <func0+0x154>\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rsi,%r12\n  push   %rbp\n  mov    %rdi,%rbp\n  push   %rbx\n  sub    $0xf8,%rsp\n  movzbl (%rdi),%edx\n  mov    %fs:0x28,%rax\n  mov    %rax,0xe8(%rsp)\n  xor    %eax,%eax\n  cmp    $0x2f,%dl\n  je     L0\n  mov    $0x1,%eax\n  lea    0xf(%rsp),%rsi\n  nopl   0x0(%rax)\nL1:\n  mov    %dl,(%rsi,%rax,1)\n  movslq %eax,%rcx\n  add    $0x1,%rax\n  movzbl -0x1(%rbp,%rax,1),%edx\n  cmp    $0x2f,%dl\n  jne    L1\n  lea    0x1(%rcx),%r15d\n  movslq %r15d,%r14\nL9:\n  lea    0x10(%rsp),%r13\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rcx,1)\n  mov    %r13,%rdi\n  call   <strtol@plt>\n  mov    %rax,0x8(%rsp)\n  movzbl 0x0(%rbp,%r14,1),%eax\n  test   %al,%al\n  je     L2\n  movslq %r15d,%r15\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r15,%rbp\n  nop\nL3:\n  mov    %al,(%rsi,%rdx,1)\n  movslq %edx,%rcx\n  add    $0x1,%rdx\n  movzbl -0x1(%rbp,%rdx,1),%eax\n  test   %al,%al\n  jne    L3\nL10:\n  lea    0x80(%rsp),%r14\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x80(%rsp,%rcx,1)\n  mov    %r14,%rdi\n  call   <strtol@plt>\n  movzbl (%r12),%ecx\n  mov    %rax,%rbp\n  cmp    $0x2f,%cl\n  je     L4\n  mov    $0x1,%edx\n  lea    0xf(%rsp),%rsi\n  nopl   (%rax)\nL5:\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  cmp    $0x2f,%cl\n  jne    L5\n  lea    0x1(%rax),%ebx\n  movslq %ebx,%r15\nL11:\n  mov    %r13,%rdi\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  movb   $0x0,0x10(%rsp,%rax,1)\n  call   <strtol@plt>\n  movzbl (%r12,%r15,1),%ecx\n  mov    %rax,%r13\n  test   %cl,%cl\n  je     L6\n  movslq %ebx,%r8\n  mov    $0x1,%edx\n  lea    0x7f(%rsp),%rsi\n  add    %r8,%r12\n  nop\nL7:\n  mov    %cl,(%rsi,%rdx,1)\n  movslq %edx,%rax\n  add    $0x1,%rdx\n  movzbl -0x1(%r12,%rdx,1),%ecx\n  test   %cl,%cl\n  jne    L7\nL12:\n  mov    $0xa,%edx\n  xor    %esi,%esi\n  mov    %r14,%rdi\n  movb   $0x0,0x80(%rsp,%rax,1)\n  call   <strtol@plt>\n  mov    %rax,%r8\n  mov    0x8(%rsp),%eax\n  imul   %r8d,%ebp\n  imul   %r13d,%eax\n  cltd\n  idiv   %ebp\n  xor    %eax,%eax\n  test   %edx,%edx\n  sete   %al\n  mov    0xe8(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L8\n  add    $0xf8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL0:\n  mov    $0x1,%r14d\n  mov    $0x1,%r15d\n  xor    %ecx,%ecx\n  jmp    L9\n  nopl   0x0(%rax,%rax,1)\nL2:\n  xor    %ecx,%ecx\n  jmp    L10\n  nop\nL4:\n  mov    $0x1,%r15d\n  mov    $0x1,%ebx\n  xor    %eax,%eax\n  jmp    L11\n  nopw   0x0(%rax,%rax,1)\nL6:\n  xor    %eax,%eax\n  jmp    L12\nL8:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4848
            },
            "L1": {
                "label": "L1",
                "addr": 4488
            },
            "L2": {
                "label": "L2",
                "addr": 4872
            },
            "L3": {
                "label": "L3",
                "addr": 4576
            },
            "L4": {
                "label": "L4",
                "addr": 4880
            },
            "L5": {
                "label": "L5",
                "addr": 4656
            },
            "L6": {
                "label": "L6",
                "addr": 4904
            },
            "L7": {
                "label": "L7",
                "addr": 4736
            },
            "L8": {
                "label": "L8",
                "addr": 4911
            },
            "L9": {
                "label": "L9",
                "addr": 4515
            },
            "L10": {
                "label": "L10",
                "addr": 4595
            },
            "L11": {
                "label": "L11",
                "addr": 4683
            },
            "L12": {
                "label": "L12",
                "addr": 4756
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 145,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x4c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  jmp    12a5 <func0+0x10c>\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  lea    -0x14(%rbp),%rax\n  lea    0xdfc(%rip),%rcx        # 2000 <_fini+0xbfc>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   10d0 <sprintf@plt>\n  movl   $0x0,-0x38(%rbp)\n  lea    -0x14(%rbp),%rax\n  mov    %rax,%rdi\n  call   10a0 <strlen@plt>\n  mov    %eax,-0x24(%rbp)\n  movl   $0x1,-0x34(%rbp)\n  jmp    124a <func0+0xb1>\n  mov    -0x34(%rbp),%eax\n  cltq\n  movzbl -0x14(%rbp,%rax,1),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x38(%rbp)\n  addl   $0x1,-0x34(%rbp)\n  mov    -0x34(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     1233 <func0+0x9a>\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    127b <func0+0xe2>\n  movzbl -0x14(%rbp),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x38(%rbp)\n  jmp    1288 <func0+0xef>\n  movzbl -0x14(%rbp),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  sub    %eax,-0x38(%rbp)\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x3c(%rbp)\n  mov    -0x3c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     11dc <func0+0x43>\n  movl   $0x0,-0x30(%rbp)\n  jmp    13cf <func0+0x236>\n  movl   $0x1,-0x2c(%rbp)\n  jmp    13bf <func0+0x226>\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x20(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    13bb <func0+0x222>\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x2c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x28(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x2c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x48(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x28(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x2c(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     12c9 <func0+0x130>\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     12bd <func0+0x124>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    -0x48(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     13ff <func0+0x266>\n  call   10b0 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x48(%rbp)\n  mov    %esi,-0x4c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  mov    -0x4c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x3c(%rbp)\n  jmp    L0\nL5:\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovs  %eax,%edx\n  lea    -0x14(%rbp),%rax\n  lea    D0(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  movl   $0x0,-0x38(%rbp)\n  lea    -0x14(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x24(%rbp)\n  movl   $0x1,-0x34(%rbp)\n  jmp    L1\nL2:\n  mov    -0x34(%rbp),%eax\n  cltq\n  movzbl -0x14(%rbp,%rax,1),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x38(%rbp)\n  addl   $0x1,-0x34(%rbp)\nL1:\n  mov    -0x34(%rbp),%eax\n  cmp    -0x24(%rbp),%eax\n  jl     L2\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jle    L3\n  movzbl -0x14(%rbp),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  add    %eax,-0x38(%rbp)\n  jmp    L4\nL3:\n  movzbl -0x14(%rbp),%eax\n  movsbl %al,%eax\n  sub    $0x30,%eax\n  sub    %eax,-0x38(%rbp)\nL4:\n  mov    -0x3c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x38(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x3c(%rbp)\nL0:\n  mov    -0x3c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     L5\n  movl   $0x0,-0x30(%rbp)\n  jmp    L6\nL10:\n  movl   $0x1,-0x2c(%rbp)\n  jmp    L7\nL9:\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x20(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jle    L8\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x2c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x28(%rbp),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x28(%rbp)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x2c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x48(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x2c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x48(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x28(%rbp),%eax\n  mov    %eax,(%rdx)\nL8:\n  addl   $0x1,-0x2c(%rbp)\nL7:\n  mov    -0x2c(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     L9\n  addl   $0x1,-0x30(%rbp)\nL6:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x4c(%rbp),%eax\n  jl     L10\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x48(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L11\n  call   <__stack_chk_fail@plt>\nL11:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3580
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4773
            },
            "L1": {
                "label": "L1",
                "addr": 4682
            },
            "L2": {
                "label": "L2",
                "addr": 4659
            },
            "L3": {
                "label": "L3",
                "addr": 4731
            },
            "L4": {
                "label": "L4",
                "addr": 4744
            },
            "L5": {
                "label": "L5",
                "addr": 4572
            },
            "L6": {
                "label": "L6",
                "addr": 5071
            },
            "L7": {
                "label": "L7",
                "addr": 5055
            },
            "L8": {
                "label": "L8",
                "addr": 5051
            },
            "L9": {
                "label": "L9",
                "addr": 4809
            },
            "L10": {
                "label": "L10",
                "addr": 4797
            },
            "L11": {
                "label": "L11",
                "addr": 5119
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 145,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%rbx\n  mov    %rdi,(%rsp)\n  mov    %esi,%r13d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%r15\n  test   %r13d,%r13d\n  jle    12e1 <func0+0x148>\n  lea    -0x1(%r13),%eax\n  lea    0x4(%rbx,%rax,4),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %r15,%rbp\n  jmp    1213 <func0+0x7a>\n  mov    $0x0,%eax\n  jmp    1274 <func0+0xdb>\n  movsbl 0x1c(%rsp),%edx\n  sub    $0x30,%edx\n  sub    %edx,%eax\n  mov    %eax,0x0(%rbp)\n  add    $0x4,%rbx\n  add    $0x4,%rbp\n  cmp    0x8(%rsp),%rbx\n  je     128c <func0+0xf3>\n  mov    %rbx,%r14\n  lea    0x1c(%rsp),%r12\n  mov    (%rbx),%eax\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  lea    0xdd2(%rip),%rcx        # 2000 <_fini+0xcec>\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    %r12,%rdi\n  mov    $0x0,%eax\n  call   10d0 <__sprintf_chk@plt>\n  mov    %r12,%rdi\n  call   10a0 <strlen@plt>\n  cmp    $0x1,%eax\n  jle    11f0 <func0+0x57>\n  lea    0x1d(%rsp),%rdx\n  lea    -0x2(%rax),%eax\n  lea    0x1e(%rsp,%rax,1),%rsi\n  mov    $0x0,%eax\n  movsbl (%rdx),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    1264 <func0+0xcb>\n  cmpl   $0x0,(%r14)\n  jle    11f7 <func0+0x5e>\n  movsbl 0x1c(%rsp),%edx\n  lea    -0x30(%rax,%rdx,1),%eax\n  jmp    1201 <func0+0x68>\n  lea    -0x2(%r13),%eax\n  lea    0x8(%r15,%rax,4),%rdi\n  mov    $0x0,%r8d\n  jmp    12cd <func0+0x134>\n  add    $0x4,%rax\n  add    $0x4,%rdx\n  cmp    %rdi,%rax\n  je     12c4 <func0+0x12b>\n  mov    -0x4(%rax),%esi\n  mov    (%rax),%ecx\n  cmp    %ecx,%esi\n  jle    129d <func0+0x104>\n  mov    %esi,(%rax)\n  mov    %ecx,-0x4(%rax)\n  mov    (%rdx),%ecx\n  mov    -0x4(%rdx),%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,-0x4(%rdx)\n  jmp    129d <func0+0x104>\n  add    $0x1,%r8d\n  cmp    %r8d,%r13d\n  je     12e1 <func0+0x148>\n  lea    0x4(%r15),%rax\n  mov    (%rsp),%rbx\n  lea    0x4(%rbx),%rdx\n  cmp    $0x1,%r13d\n  jg     12aa <func0+0x111>\n  jmp    12c4 <func0+0x12b>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    130c <func0+0x173>\n  mov    (%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10b0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,%rbx\n  mov    %rdi,(%rsp)\n  mov    %esi,%r13d\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  movslq %esi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r15\n  test   %r13d,%r13d\n  jle    L0\n  lea    -0x1(%r13),%eax\n  lea    0x4(%rbx,%rax,4),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %r15,%rbp\n  jmp    L1\nL4:\n  mov    $0x0,%eax\n  jmp    L2\nL6:\n  movsbl 0x1c(%rsp),%edx\n  sub    $0x30,%edx\n  sub    %edx,%eax\nL7:\n  mov    %eax,0x0(%rbp)\n  add    $0x4,%rbx\n  add    $0x4,%rbp\n  cmp    0x8(%rsp),%rbx\n  je     L3\nL1:\n  mov    %rbx,%r14\n  lea    0x1c(%rsp),%r12\n  mov    (%rbx),%eax\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  lea    D0(%rip),%rcx\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    %r12,%rdi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\n  mov    %r12,%rdi\n  call   <strlen@plt>\n  cmp    $0x1,%eax\n  jle    L4\n  lea    0x1d(%rsp),%rdx\n  lea    -0x2(%rax),%eax\n  lea    0x1e(%rsp,%rax,1),%rsi\n  mov    $0x0,%eax\nL5:\n  movsbl (%rdx),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  add    $0x1,%rdx\n  cmp    %rsi,%rdx\n  jne    L5\nL2:\n  cmpl   $0x0,(%r14)\n  jle    L6\n  movsbl 0x1c(%rsp),%edx\n  lea    -0x30(%rax,%rdx,1),%eax\n  jmp    L7\nL3:\n  lea    -0x2(%r13),%eax\n  lea    0x8(%r15,%rax,4),%rdi\n  mov    $0x0,%r8d\n  jmp    L8\nL10:\n  add    $0x4,%rax\n  add    $0x4,%rdx\n  cmp    %rdi,%rax\n  je     L9\nL11:\n  mov    -0x4(%rax),%esi\n  mov    (%rax),%ecx\n  cmp    %ecx,%esi\n  jle    L10\n  mov    %esi,(%rax)\n  mov    %ecx,-0x4(%rax)\n  mov    (%rdx),%ecx\n  mov    -0x4(%rdx),%esi\n  mov    %esi,(%rdx)\n  mov    %ecx,-0x4(%rdx)\n  jmp    L10\nL9:\n  add    $0x1,%r8d\n  cmp    %r8d,%r13d\n  je     L0\nL8:\n  lea    0x4(%r15),%rax\n  mov    (%rsp),%rbx\n  lea    0x4(%rbx),%rdx\n  cmp    $0x1,%r13d\n  jg     L11\n  jmp    L9\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L12\n  mov    (%rsp),%rax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL12:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3538
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4833
            },
            "L1": {
                "label": "L1",
                "addr": 4627
            },
            "L2": {
                "label": "L2",
                "addr": 4724
            },
            "L3": {
                "label": "L3",
                "addr": 4748
            },
            "L4": {
                "label": "L4",
                "addr": 4592
            },
            "L5": {
                "label": "L5",
                "addr": 4708
            },
            "L6": {
                "label": "L6",
                "addr": 4599
            },
            "L7": {
                "label": "L7",
                "addr": 4609
            },
            "L8": {
                "label": "L8",
                "addr": 4813
            },
            "L9": {
                "label": "L9",
                "addr": 4804
            },
            "L10": {
                "label": "L10",
                "addr": 4765
            },
            "L11": {
                "label": "L11",
                "addr": 4778
            },
            "L12": {
                "label": "L12",
                "addr": 4876
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 145,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,(%rsp)\n  movslq %esi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   10c0 <malloc@plt>\n  mov    %rax,%r12\n  test   %ebx,%ebx\n  jle    12fe <func0+0x15e>\n  lea    0x4(%r14),%rdi\n  lea    -0x1(%rbx),%eax\n  mov    %r12,0x10(%rsp)\n  mov    %r14,%r13\n  lea    (%rdi,%rax,4),%rax\n  mov    %rdi,0x8(%rsp)\n  lea    0x2e(%rsp),%rdi\n  mov    %ebx,0x1c(%rsp)\n  lea    0x2c(%rsp),%rbp\n  mov    %r13,%rbx\n  mov    %rdi,%r15\n  lea    0xdea(%rip),%r14        # 2000 <_fini+0xcc4>\n  mov    %rax,%r13\n  nopl   0x0(%rax)\n  mov    (%rbx),%eax\n  mov    %rbp,%rdi\n  mov    %r14,%rcx\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  xor    %eax,%eax\n  call   10d0 <__sprintf_chk@plt>\n  mov    %rbp,%rdi\n  call   10a0 <strlen@plt>\n  cmp    $0x1,%rax\n  jbe    1330 <func0+0x190>\n  lea    -0x2(%rax),%esi\n  lea    0x2d(%rsp),%rdx\n  xor    %eax,%eax\n  add    %r15,%rsi\n  nopw   0x0(%rax,%rax,1)\n  movsbl (%rdx),%ecx\n  add    $0x1,%rdx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    %rsi,%rdx\n  jne    1268 <func0+0xc8>\n  movsbl 0x2c(%rsp),%edx\n  sub    $0x30,%edx\n  lea    (%rax,%rdx,1),%ecx\n  sub    %edx,%eax\n  mov    (%rbx),%edx\n  test   %edx,%edx\n  cmovg  %ecx,%eax\n  add    $0x4,%rbx\n  add    $0x4,%r12\n  mov    %eax,-0x4(%r12)\n  cmp    %r13,%rbx\n  jne    1220 <func0+0x80>\n  mov    0x1c(%rsp),%ebx\n  mov    0x10(%rsp),%r12\n  xor    %r8d,%r8d\n  mov    0x8(%rsp),%r9\n  lea    -0x2(%rbx),%eax\n  lea    0x8(%r12,%rax,4),%rdi\n  nopw   0x0(%rax,%rax,1)\n  lea    0x4(%r12),%rax\n  mov    %r9,%rdx\n  cmp    $0x1,%ebx\n  je     12f5 <func0+0x155>\n  nopl   (%rax)\n  mov    -0x4(%rax),%esi\n  mov    (%rax),%ecx\n  cmp    %ecx,%esi\n  jle    12e8 <func0+0x148>\n  mov    %esi,(%rax)\n  mov    -0x4(%rdx),%esi\n  mov    %ecx,-0x4(%rax)\n  mov    (%rdx),%ecx\n  mov    %esi,(%rdx)\n  mov    %ecx,-0x4(%rdx)\n  add    $0x4,%rax\n  add    $0x4,%rdx\n  cmp    %rax,%rdi\n  jne    12d0 <func0+0x130>\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jne    12c0 <func0+0x120>\n  mov    %r12,%rdi\n  call   1090 <free@plt>\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1337 <func0+0x197>\n  mov    (%rsp),%rax\n  add    $0x48,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  xor    %eax,%eax\n  jmp    1278 <func0+0xd8>\n  call   10b0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rdi,%r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x48,%rsp\n  mov    %rdi,(%rsp)\n  movslq %esi,%rdi\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  mov    %fs:0x28,%rax\n  mov    %rax,0x38(%rsp)\n  xor    %eax,%eax\n  call   <malloc@plt>\n  mov    %rax,%r12\n  test   %ebx,%ebx\n  jle    L0\n  lea    0x4(%r14),%rdi\n  lea    -0x1(%rbx),%eax\n  mov    %r12,0x10(%rsp)\n  mov    %r14,%r13\n  lea    (%rdi,%rax,4),%rax\n  mov    %rdi,0x8(%rsp)\n  lea    0x2e(%rsp),%rdi\n  mov    %ebx,0x1c(%rsp)\n  lea    0x2c(%rsp),%rbp\n  mov    %r13,%rbx\n  mov    %rdi,%r15\n  lea    D0(%rip),%r14\n  mov    %rax,%r13\n  nopl   0x0(%rax)\nL3:\n  mov    (%rbx),%eax\n  mov    %rbp,%rdi\n  mov    %r14,%rcx\n  mov    $0xc,%edx\n  mov    $0x1,%esi\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  xor    %eax,%eax\n  call   <__sprintf_chk@plt>\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  cmp    $0x1,%rax\n  jbe    L1\n  lea    -0x2(%rax),%esi\n  lea    0x2d(%rsp),%rdx\n  xor    %eax,%eax\n  add    %r15,%rsi\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movsbl (%rdx),%ecx\n  add    $0x1,%rdx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    %rsi,%rdx\n  jne    L2\nL9:\n  movsbl 0x2c(%rsp),%edx\n  sub    $0x30,%edx\n  lea    (%rax,%rdx,1),%ecx\n  sub    %edx,%eax\n  mov    (%rbx),%edx\n  test   %edx,%edx\n  cmovg  %ecx,%eax\n  add    $0x4,%rbx\n  add    $0x4,%r12\n  mov    %eax,-0x4(%r12)\n  cmp    %r13,%rbx\n  jne    L3\n  mov    0x1c(%rsp),%ebx\n  mov    0x10(%rsp),%r12\n  xor    %r8d,%r8d\n  mov    0x8(%rsp),%r9\n  lea    -0x2(%rbx),%eax\n  lea    0x8(%r12,%rax,4),%rdi\n  nopw   0x0(%rax,%rax,1)\nL7:\n  lea    0x4(%r12),%rax\n  mov    %r9,%rdx\n  cmp    $0x1,%ebx\n  je     L4\n  nopl   (%rax)\nL6:\n  mov    -0x4(%rax),%esi\n  mov    (%rax),%ecx\n  cmp    %ecx,%esi\n  jle    L5\n  mov    %esi,(%rax)\n  mov    -0x4(%rdx),%esi\n  mov    %ecx,-0x4(%rax)\n  mov    (%rdx),%ecx\n  mov    %esi,(%rdx)\n  mov    %ecx,-0x4(%rdx)\nL5:\n  add    $0x4,%rax\n  add    $0x4,%rdx\n  cmp    %rax,%rdi\n  jne    L6\nL4:\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jne    L7\nL0:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    0x38(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L8\n  mov    (%rsp),%rax\n  add    $0x48,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL1:\n  xor    %eax,%eax\n  jmp    L9\nL8:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3562
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4862
            },
            "L1": {
                "label": "L1",
                "addr": 4912
            },
            "L2": {
                "label": "L2",
                "addr": 4712
            },
            "L3": {
                "label": "L3",
                "addr": 4640
            },
            "L4": {
                "label": "L4",
                "addr": 4853
            },
            "L5": {
                "label": "L5",
                "addr": 4840
            },
            "L6": {
                "label": "L6",
                "addr": 4816
            },
            "L7": {
                "label": "L7",
                "addr": 4800
            },
            "L8": {
                "label": "L8",
                "addr": 4919
            },
            "L9": {
                "label": "L9",
                "addr": 4728
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 145,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint* func0(int nums[], int size) {\n    int* sumdigit = (int*)malloc(size * sizeof(int));\n    for (int i = 0; i < size; i++) {\n        char w[12]; // Assuming the integer won't exceed the length of an int in string form.\n        sprintf(w, \"%d\", abs(nums[i]));\n        int sum = 0, length = strlen(w);\n        for (int j = 1; j < length; j++)\n            sum += w[j] - '0';\n        if (nums[i] > 0) sum += w[0] - '0';\n        else sum -= w[0] - '0';\n        sumdigit[i] = sum;\n    }\n    int m;\n    for (int i = 0; i < size; i++)\n        for (int j = 1; j < size; j++)\n            if (sumdigit[j - 1] > sumdigit[j]) {\n                m = sumdigit[j]; sumdigit[j] = sumdigit[j - 1]; sumdigit[j - 1] = m;\n                m = nums[j]; nums[j] = nums[j - 1]; nums[j - 1] = m;\n            }\n    \n    free(sumdigit);\n    return nums;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(int* a, int* b, int size_a, int size_b) {\n    if (size_a != size_b) return 0;\n    for (int i = 0; i < size_a; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int test1[] = {1, 11, -1, -11, -12};\n    int expected1[] = {-1, -11, 1, -12, 11};\n    assert(issame(func0(test1, 5), expected1, 5, 5));\n\n    int test2[] = {1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46};\n    int expected2[] = {0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457};\n    assert(issame(func0(test2, 15), expected2, 15, 15));\n\n    int test3[] = {};\n    int expected3[] = {};\n    assert(issame(func0(test3, 0), expected3, 0, 0));\n\n    int test4[] = {1, -11, -32, 43, 54, -98, 2, -3};\n    int expected4[] = {-3, -32, -98, -11, 1, 2, 43, 54};\n    assert(issame(func0(test4, 8), expected4, 8, 8));\n\n    int test5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n    int expected5[] = {1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9};\n    assert(issame(func0(test5, 11), expected5, 11, 11));\n\n    int test6[] = {0, 6, 6, -76, -21, 23, 4};\n    int expected6[] = {-76, -21, 0, 4, 23, 6, 6};\n    assert(issame(func0(test6, 7), expected6, 7, 7));\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  movslq %esi,%rdi\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x38,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  call   10c0 <malloc@plt>\n  mov    %rax,(%rsp)\n  test   %ebx,%ebx\n  jle    1358 <func0+0x1b8>\n  mov    %rax,%rbp\n  lea    -0x1(%rbx),%eax\n  mov    %r12,%r15\n  lea    0x4(%r12,%rax,4),%rax\n  lea    0x1c(%rsp),%r13\n  mov    %rax,0x8(%rsp)\n  lea    0xe01(%rip),%r14        # 2000 <_fini+0xc78>\n  jmp    12b5 <func0+0x115>\n  nopl   0x0(%rax)\n  movsbl 0x1d(%rsp),%eax\n  sub    $0x30,%eax\n  cmp    $0x2,%edx\n  je     128e <func0+0xee>\n  movsbl 0x1e(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x3,%edx\n  je     128e <func0+0xee>\n  movsbl 0x1f(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x4,%edx\n  je     128e <func0+0xee>\n  movsbl 0x20(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x5,%edx\n  je     128e <func0+0xee>\n  movsbl 0x21(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x6,%edx\n  je     128e <func0+0xee>\n  movsbl 0x22(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x7,%edx\n  je     128e <func0+0xee>\n  movsbl 0x23(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x8,%edx\n  je     128e <func0+0xee>\n  movsbl 0x24(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x9,%edx\n  je     128e <func0+0xee>\n  movsbl 0x25(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0xb,%edx\n  jne    128e <func0+0xee>\n  movsbl 0x26(%rsp),%edx\n  lea    -0x30(%rax,%rdx,1),%eax\n  movsbl 0x1c(%rsp),%edx\n  sub    $0x30,%edx\n  lea    (%rax,%rdx,1),%ecx\n  sub    %edx,%eax\n  mov    (%r15),%edx\n  test   %edx,%edx\n  cmovg  %ecx,%eax\n  add    $0x4,%r15\n  add    $0x4,%rbp\n  mov    %eax,-0x4(%rbp)\n  cmp    %r15,0x8(%rsp)\n  je     12f8 <func0+0x158>\n  mov    (%r15),%eax\n  mov    $0xc,%edx\n  mov    %r14,%rcx\n  mov    $0x1,%esi\n  mov    %r13,%rdi\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  xor    %eax,%eax\n  call   10d0 <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   10a0 <strlen@plt>\n  mov    %rax,%rdx\n  cmp    $0x1,%rax\n  ja     1208 <func0+0x68>\n  xor    %eax,%eax\n  jmp    128e <func0+0xee>\n  nopw   0x0(%rax,%rax,1)\n  cmp    $0x1,%ebx\n  je     1358 <func0+0x1b8>\n  mov    (%rsp),%rdi\n  lea    -0x2(%rbx),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%rdi\n  nopl   0x0(%rax)\n  mov    (%rsp),%rdx\n  mov    %r12,%rcx\n  nopw   0x0(%rax,%rax,1)\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%eax\n  movd   %xmm2,%esi\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%esi\n  jge    1342 <func0+0x1a2>\n  movq   %xmm1,(%rdx)\n  rolq   $0x20,(%rcx)\n  add    $0x4,%rdx\n  add    $0x4,%rcx\n  cmp    %rdx,%rdi\n  jne    1320 <func0+0x180>\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jne    1310 <func0+0x170>\n  mov    (%rsp),%rdi\n  call   1090 <free@plt>\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1383 <func0+0x1e3>\n  add    $0x38,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   10b0 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  movslq %esi,%rdi\n  push   %rbp\n  push   %rbx\n  mov    %rdi,%rbx\n  shl    $0x2,%rdi\n  sub    $0x38,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x28(%rsp)\n  xor    %eax,%eax\n  call   <malloc@plt>\n  mov    %rax,(%rsp)\n  test   %ebx,%ebx\n  jle    L0\n  mov    %rax,%rbp\n  lea    -0x1(%rbx),%eax\n  mov    %r12,%r15\n  lea    0x4(%r12,%rax,4),%rax\n  lea    0x1c(%rsp),%r13\n  mov    %rax,0x8(%rsp)\n  lea    D0(%rip),%r14\n  jmp    L1\n  nopl   0x0(%rax)\nL4:\n  movsbl 0x1d(%rsp),%eax\n  sub    $0x30,%eax\n  cmp    $0x2,%edx\n  je     L2\n  movsbl 0x1e(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x3,%edx\n  je     L2\n  movsbl 0x1f(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x4,%edx\n  je     L2\n  movsbl 0x20(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x5,%edx\n  je     L2\n  movsbl 0x21(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x6,%edx\n  je     L2\n  movsbl 0x22(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x7,%edx\n  je     L2\n  movsbl 0x23(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x8,%edx\n  je     L2\n  movsbl 0x24(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0x9,%edx\n  je     L2\n  movsbl 0x25(%rsp),%ecx\n  lea    -0x30(%rax,%rcx,1),%eax\n  cmp    $0xb,%edx\n  jne    L2\n  movsbl 0x26(%rsp),%edx\n  lea    -0x30(%rax,%rdx,1),%eax\nL2:\n  movsbl 0x1c(%rsp),%edx\n  sub    $0x30,%edx\n  lea    (%rax,%rdx,1),%ecx\n  sub    %edx,%eax\n  mov    (%r15),%edx\n  test   %edx,%edx\n  cmovg  %ecx,%eax\n  add    $0x4,%r15\n  add    $0x4,%rbp\n  mov    %eax,-0x4(%rbp)\n  cmp    %r15,0x8(%rsp)\n  je     L3\nL1:\n  mov    (%r15),%eax\n  mov    $0xc,%edx\n  mov    %r14,%rcx\n  mov    $0x1,%esi\n  mov    %r13,%rdi\n  mov    %eax,%r8d\n  neg    %r8d\n  cmovs  %eax,%r8d\n  xor    %eax,%eax\n  call   <__sprintf_chk@plt>\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rdx\n  cmp    $0x1,%rax\n  ja     L4\n  xor    %eax,%eax\n  jmp    L2\n  nopw   0x0(%rax,%rax,1)\nL3:\n  cmp    $0x1,%ebx\n  je     L0\n  mov    (%rsp),%rdi\n  lea    -0x2(%rbx),%eax\n  xor    %r8d,%r8d\n  lea    0x4(%rdi,%rax,4),%rdi\n  nopl   0x0(%rax)\nL7:\n  mov    (%rsp),%rdx\n  mov    %r12,%rcx\n  nopw   0x0(%rax,%rax,1)\nL6:\n  movq   (%rdx),%xmm0\n  pshufd $0xe5,%xmm0,%xmm2\n  movd   %xmm0,%eax\n  movd   %xmm2,%esi\n  pshufd $0xe1,%xmm0,%xmm1\n  cmp    %eax,%esi\n  jge    L5\n  movq   %xmm1,(%rdx)\n  rolq   $0x20,(%rcx)\nL5:\n  add    $0x4,%rdx\n  add    $0x4,%rcx\n  cmp    %rdx,%rdi\n  jne    L6\n  add    $0x1,%r8d\n  cmp    %r8d,%ebx\n  jne    L7\nL0:\n  mov    (%rsp),%rdi\n  call   <free@plt>\n  mov    0x28(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L8\n  add    $0x38,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL8:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3585
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4952
            },
            "L1": {
                "label": "L1",
                "addr": 4789
            },
            "L2": {
                "label": "L2",
                "addr": 4750
            },
            "L3": {
                "label": "L3",
                "addr": 4856
            },
            "L4": {
                "label": "L4",
                "addr": 4616
            },
            "L5": {
                "label": "L5",
                "addr": 4930
            },
            "L6": {
                "label": "L6",
                "addr": 4896
            },
            "L7": {
                "label": "L7",
                "addr": 4880
            },
            "L8": {
                "label": "L8",
                "addr": 4995
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "256400",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%d\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 146,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11f1 <func0+0xf8>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0xa,%eax\n  jle    11ed <func0+0xf4>\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x8(%rbp),%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x8(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    11b7 <func0+0xbe>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0xc(%rbp)\n  cmpl   $0x9,-0xc(%rbp)\n  jg     1197 <func0+0x9e>\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    11ed <func0+0xf4>\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    11ed <func0+0xf4>\n  addl   $0x1,-0x14(%rbp)\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     111b <func0+0x22>\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L0\nL4:\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cmp    $0xa,%eax\n  jle    L1\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,-0x8(%rbp)\n  mov    -0x8(%rbp),%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x8(%rbp)\n  mov    -0x10(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    %eax,-0xc(%rbp)\n  jmp    L2\nL3:\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0xc(%rbp)\nL2:\n  cmpl   $0x9,-0xc(%rbp)\n  jg     L3\n  mov    -0xc(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  mov    -0x8(%rbp),%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  addl   $0x1,-0x14(%rbp)\nL1:\n  addl   $0x1,-0x10(%rbp)\nL0:\n  mov    -0x10(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L4\n  mov    -0x14(%rbp),%eax\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4593
            },
            "L1": {
                "label": "L1",
                "addr": 4589
            },
            "L2": {
                "label": "L2",
                "addr": 4535
            },
            "L3": {
                "label": "L3",
                "addr": 4503
            },
            "L4": {
                "label": "L4",
                "addr": 4379
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 146,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    118e <func0+0x95>\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%r10d\n  jmp    1121 <func0+0x28>\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  je     1194 <func0+0x9b>\n  mov    (%r8),%edi\n  cmp    $0xa,%edi\n  jle    1118 <func0+0x1f>\n  mov    %edi,%edx\n  mov    %edx,%ecx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  cmp    $0x63,%ecx\n  jg     112b <func0+0x32>\n  shr    $0x1f,%eax\n  add    %eax,%edx\n  and    $0x1,%edx\n  sub    %eax,%edx\n  cmp    $0x1,%edx\n  jne    1118 <func0+0x1f>\n  movslq %edi,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edi,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  sub    %eax,%edi\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%edi\n  and    $0x1,%edi\n  sub    %eax,%edi\n  cmp    $0x1,%edi\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r10d\n  jmp    1118 <func0+0x1f>\n  mov    $0x0,%r10d\n  mov    %r10d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r8\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%r9\n  mov    $0x0,%r10d\n  jmp    L1\nL3:\n  add    $0x4,%r8\n  cmp    %r9,%r8\n  je     L2\nL1:\n  mov    (%r8),%edi\n  cmp    $0xa,%edi\n  jle    L3\n  mov    %edi,%edx\nL4:\n  mov    %edx,%ecx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%edx\n  cmp    $0x63,%ecx\n  jg     L4\n  shr    $0x1f,%eax\n  add    %eax,%edx\n  and    $0x1,%edx\n  sub    %eax,%edx\n  cmp    $0x1,%edx\n  jne    L3\n  movslq %edi,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edi,%edx\n  sar    $0x1f,%edx\n  sub    %edx,%eax\n  lea    (%rax,%rax,4),%eax\n  add    %eax,%eax\n  sub    %eax,%edi\n  mov    %edi,%eax\n  shr    $0x1f,%eax\n  add    %eax,%edi\n  and    $0x1,%edi\n  sub    %eax,%edi\n  cmp    $0x1,%edi\n  sete   %al\n  movzbl %al,%eax\n  add    %eax,%r10d\n  jmp    L3\nL0:\n  mov    $0x0,%r10d\nL2:\n  mov    %r10d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4494
            },
            "L1": {
                "label": "L1",
                "addr": 4385
            },
            "L2": {
                "label": "L2",
                "addr": 4500
            },
            "L3": {
                "label": "L3",
                "addr": 4376
            },
            "L4": {
                "label": "L4",
                "addr": 4395
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 146,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1165 <func0+0x65>\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  jmp    1129 <func0+0x29>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     1161 <func0+0x61>\n  mov    (%rdi),%ecx\n  cmp    $0xa,%ecx\n  jle    1120 <func0+0x20>\n  mov    %ecx,%eax\n  nopw   0x0(%rax,%rax,1)\n  mov    %eax,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x63,%edx\n  jg     1138 <func0+0x38>\n  test   $0x1,%al\n  je     1120 <func0+0x20>\n  and    $0x1,%ecx\n  cmp    $0x1,%ecx\n  sbb    $0xffffffff,%r9d\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  jne    1129 <func0+0x29>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     L2\nL1:\n  mov    (%rdi),%ecx\n  cmp    $0xa,%ecx\n  jle    L3\n  mov    %ecx,%eax\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %eax,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x63,%edx\n  jg     L4\n  test   $0x1,%al\n  je     L3\n  and    $0x1,%ecx\n  cmp    $0x1,%ecx\n  sbb    $0xffffffff,%r9d\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  jne    L1\nL2:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4453
            },
            "L1": {
                "label": "L1",
                "addr": 4393
            },
            "L2": {
                "label": "L2",
                "addr": 4449
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4408
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 146,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int nums[], int size) {\n    int num = 0;\n    for (int i = 0; i < size; i++) {\n        if (nums[i] > 10) {\n            int first, last;\n            last = nums[i] % 10;\n            int n = nums[i];\n            while (n >= 10) {\n                n /= 10;\n            }\n            first = n;\n            if (first % 2 == 1 && last % 2 == 1) {\n                num += 1;\n            }\n        }\n    }\n    return num;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    {\n        int nums[] = {5, -2, 1, -5};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {15, -73, 14, -15};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 1);\n    }\n\n    {\n        int nums[] = {33, -2, -3, 45, 21, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 2);\n    }\n\n    {\n        int nums[] = {43, -12, 93, 125, 121, 109};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 4);\n    }\n\n    {\n        int nums[] = {71, -2, -33, 75, 21, 19};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 3);\n    }\n\n    {\n        int nums[] = {1};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    {\n        int nums[] = {};\n        assert(func0(nums, sizeof(nums) / sizeof(nums[0])) == 0);\n    }\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    1165 <func0+0x65>\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  jmp    1129 <func0+0x29>\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     1161 <func0+0x61>\n  mov    (%rdi),%ecx\n  cmp    $0xa,%ecx\n  jle    1120 <func0+0x20>\n  mov    %ecx,%eax\n  nopw   0x0(%rax,%rax,1)\n  mov    %eax,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x63,%edx\n  jg     1138 <func0+0x38>\n  test   $0x1,%al\n  je     1120 <func0+0x20>\n  and    $0x1,%ecx\n  cmp    $0x1,%ecx\n  sbb    $0xffffffff,%r9d\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  jne    1129 <func0+0x29>\n  mov    %r9d,%eax\n  ret\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  xor    %r9d,%r9d\n  mov    $0xcccccccd,%esi\n  lea    0x4(%rdi,%rax,4),%r8\n  jmp    L1\n  nopw   0x0(%rax,%rax,1)\nL3:\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  je     L2\nL1:\n  mov    (%rdi),%ecx\n  cmp    $0xa,%ecx\n  jle    L3\n  mov    %ecx,%eax\n  nopw   0x0(%rax,%rax,1)\nL4:\n  mov    %eax,%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x23,%rax\n  cmp    $0x63,%edx\n  jg     L4\n  test   $0x1,%al\n  je     L3\n  and    $0x1,%ecx\n  cmp    $0x1,%ecx\n  sbb    $0xffffffff,%r9d\n  add    $0x4,%rdi\n  cmp    %r8,%rdi\n  jne    L1\nL2:\n  mov    %r9d,%eax\n  ret\nL0:\n  xor    %r9d,%r9d\n  mov    %r9d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4453
            },
            "L1": {
                "label": "L1",
                "addr": 4393
            },
            "L2": {
                "label": "L2",
                "addr": 4449
            },
            "L3": {
                "label": "L3",
                "addr": 4384
            },
            "L4": {
                "label": "L4",
                "addr": 4408
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 147,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %edi,-0x64(%rbp)\n  mov    -0x64(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x64(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x64(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x54(%rbp)\n  jmp    1209 <func0+0xb0>\n  mov    -0x54(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x54(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    %rax,(%rbx)\n  addl   $0x1,-0x54(%rbp)\n  mov    -0x54(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    11b7 <func0+0x5e>\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%rax\n  lea    0x8(%rax),%rdx\n  movl   $0x0,(%rdx)\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%rax\n  add    $0x4,%rax\n  mov    (%rdx),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rdx\n  mov    (%rdx),%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%rax\n  lea    0x8(%rax),%rdx\n  movl   $0x0,(%rdx)\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%rax\n  add    $0x4,%rax\n  mov    (%rdx),%edx\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rdx\n  mov    (%rdx),%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  movl   $0x1,-0x50(%rbp)\n  jmp    138b <func0+0x232>\n  mov    -0x50(%rbp),%eax\n  imul   %eax,%eax\n  sub    -0x50(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  lea    (%rcx,%rax,1),%rsi\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,(%rsi)\n  movl   $0x0,-0x4c(%rbp)\n  jmp    130e <func0+0x1b5>\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x4c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x50(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x4c(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x4c(%rbp)\n  cmpl   $0x2,-0x4c(%rbp)\n  jle    12be <func0+0x165>\n  mov    -0x50(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x50(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x20(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rcx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rsi\n  mov    -0x28(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x50(%rbp)\n  mov    -0x50(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    1273 <func0+0x11a>\n  movl   $0x1,-0x48(%rbp)\n  jmp    1594 <func0+0x43b>\n  movl   $0x1,-0x44(%rbp)\n  jmp    14e0 <func0+0x387>\n  movl   $0x0,-0x40(%rbp)\n  jmp    1408 <func0+0x2af>\n  mov    -0x44(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x40(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x40(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x40(%rbp)\n  cmpl   $0x2,-0x40(%rbp)\n  jle    13b8 <func0+0x25f>\n  cmpl   $0x0,-0x44(%rbp)\n  jle    14dc <func0+0x383>\n  movl   $0x0,-0x3c(%rbp)\n  jmp    14d2 <func0+0x379>\n  mov    -0x44(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rsi\n  mov    -0x44(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x3c(%rbp),%eax\n  add    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  movslq %eax,%rdx\n  shl    $0x2,%rdx\n  add    %rsi,%rdx\n  mov    (%rdx),%esi\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x3,%rdx\n  lea    -0x8(%rdx),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x3c(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%ecx\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rdi\n  mov    -0x18(%rbp),%rdx\n  add    %rdi,%rdx\n  mov    (%rdx),%rdx\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  lea    (%rsi,%rcx,1),%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x3c(%rbp)\n  cmpl   $0x2,-0x3c(%rbp)\n  jle    1424 <func0+0x2cb>\n  addl   $0x1,-0x44(%rbp)\n  mov    -0x44(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    13af <func0+0x256>\n  movl   $0x0,-0x38(%rbp)\n  jmp    1584 <func0+0x42b>\n  movl   $0x0,-0x34(%rbp)\n  jmp    157a <func0+0x421>\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x38(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x34(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  movl   $0x0,(%rax)\n  addl   $0x1,-0x34(%rbp)\n  cmpl   $0x2,-0x34(%rbp)\n  jle    1501 <func0+0x3a8>\n  addl   $0x1,-0x38(%rbp)\n  mov    -0x38(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    14f8 <func0+0x39f>\n  addl   $0x1,-0x48(%rbp)\n  cmpl   $0x2,-0x48(%rbp)\n  jle    13a3 <func0+0x24a>\n  mov    -0x64(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x2c(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    1605 <func0+0x4ac>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  addl   $0x1,-0x30(%rbp)\n  mov    -0x30(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    15c3 <func0+0x46a>\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1070 <free@plt>\n  mov    -0x2c(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %edi,-0x64(%rbp)\n  mov    -0x64(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x28(%rbp)\n  mov    -0x64(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  mov    -0x64(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x18(%rbp)\n  movl   $0x0,-0x54(%rbp)\n  jmp    L0\nL1:\n  mov    -0x54(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    %rax,(%rbx)\n  mov    -0x54(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  lea    (%rdx,%rax,1),%rbx\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    %rax,(%rbx)\n  addl   $0x1,-0x54(%rbp)\nL0:\n  mov    -0x54(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L1\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%rax\n  lea    0x8(%rax),%rdx\n  movl   $0x0,(%rdx)\n  mov    -0x20(%rbp),%rax\n  mov    (%rax),%rax\n  add    $0x4,%rax\n  mov    (%rdx),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rdx\n  mov    (%rdx),%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%rax\n  lea    0x8(%rax),%rdx\n  movl   $0x0,(%rdx)\n  mov    -0x18(%rbp),%rax\n  mov    (%rax),%rax\n  add    $0x4,%rax\n  mov    (%rdx),%edx\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rdx\n  mov    (%rdx),%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  movl   $0x1,-0x50(%rbp)\n  jmp    L2\nL5:\n  mov    -0x50(%rbp),%eax\n  imul   %eax,%eax\n  sub    -0x50(%rbp),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  lea    (%rcx,%rax,1),%rsi\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,(%rsi)\n  movl   $0x0,-0x4c(%rbp)\n  jmp    L3\nL4:\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x4c(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x50(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x4c(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x4c(%rbp)\nL3:\n  cmpl   $0x2,-0x4c(%rbp)\n  jle    L4\n  mov    -0x50(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x50(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x20(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rcx\n  mov    -0x50(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rsi\n  mov    -0x28(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rcx,%rax\n  add    $0x1,%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x50(%rbp)\nL2:\n  mov    -0x50(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L5\n  movl   $0x1,-0x48(%rbp)\n  jmp    L6\nL18:\n  movl   $0x1,-0x44(%rbp)\n  jmp    L7\nL13:\n  movl   $0x0,-0x40(%rbp)\n  jmp    L8\nL9:\n  mov    -0x44(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x40(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x18(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x40(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x40(%rbp)\nL8:\n  cmpl   $0x2,-0x40(%rbp)\n  jle    L9\n  cmpl   $0x0,-0x44(%rbp)\n  jle    L10\n  movl   $0x0,-0x3c(%rbp)\n  jmp    L11\nL12:\n  mov    -0x44(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rsi\n  mov    -0x44(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  lea    -0x4(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x3c(%rbp),%eax\n  add    %eax,%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  mov    %eax,%ecx\n  add    %ecx,%ecx\n  add    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  movslq %eax,%rdx\n  shl    $0x2,%rdx\n  add    %rsi,%rdx\n  mov    (%rdx),%esi\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x3,%rdx\n  lea    -0x8(%rdx),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x3c(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%ecx\n  mov    -0x44(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rdi\n  mov    -0x18(%rbp),%rdx\n  add    %rdi,%rdx\n  mov    (%rdx),%rdx\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  lea    (%rsi,%rcx,1),%edx\n  mov    %edx,(%rax)\n  addl   $0x1,-0x3c(%rbp)\nL11:\n  cmpl   $0x2,-0x3c(%rbp)\n  jle    L12\nL10:\n  addl   $0x1,-0x44(%rbp)\nL7:\n  mov    -0x44(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L13\n  movl   $0x0,-0x38(%rbp)\n  jmp    L14\nL17:\n  movl   $0x0,-0x34(%rbp)\n  jmp    L15\nL16:\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  mov    -0x38(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%rcx\n  mov    -0x34(%rbp),%edx\n  movslq %edx,%rdx\n  shl    $0x2,%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x38(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x34(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  add    %rdx,%rax\n  movl   $0x0,(%rax)\n  addl   $0x1,-0x34(%rbp)\nL15:\n  cmpl   $0x2,-0x34(%rbp)\n  jle    L16\n  addl   $0x1,-0x38(%rbp)\nL14:\n  mov    -0x38(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L17\n  addl   $0x1,-0x48(%rbp)\nL6:\n  cmpl   $0x2,-0x48(%rbp)\n  jle    L18\n  mov    -0x64(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x2c(%rbp)\n  movl   $0x0,-0x30(%rbp)\n  jmp    L19\nL20:\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x30(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  addl   $0x1,-0x30(%rbp)\nL19:\n  mov    -0x30(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L20\n  mov    -0x20(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x18(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x2c(%rbp),%eax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4617
            },
            "L1": {
                "label": "L1",
                "addr": 4535
            },
            "L2": {
                "label": "L2",
                "addr": 5003
            },
            "L3": {
                "label": "L3",
                "addr": 4878
            },
            "L4": {
                "label": "L4",
                "addr": 4798
            },
            "L5": {
                "label": "L5",
                "addr": 4723
            },
            "L6": {
                "label": "L6",
                "addr": 5524
            },
            "L7": {
                "label": "L7",
                "addr": 5344
            },
            "L8": {
                "label": "L8",
                "addr": 5128
            },
            "L9": {
                "label": "L9",
                "addr": 5048
            },
            "L10": {
                "label": "L10",
                "addr": 5340
            },
            "L11": {
                "label": "L11",
                "addr": 5330
            },
            "L12": {
                "label": "L12",
                "addr": 5156
            },
            "L13": {
                "label": "L13",
                "addr": 5039
            },
            "L14": {
                "label": "L14",
                "addr": 5508
            },
            "L15": {
                "label": "L15",
                "addr": 5498
            },
            "L16": {
                "label": "L16",
                "addr": 5377
            },
            "L17": {
                "label": "L17",
                "addr": 5368
            },
            "L18": {
                "label": "L18",
                "addr": 5027
            },
            "L19": {
                "label": "L19",
                "addr": 5637
            },
            "L20": {
                "label": "L20",
                "addr": 5571
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 147,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %edi,%r13d\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%r14\n  lea    0x1(%r13),%eax\n  cltq\n  lea    0x0(,%rax,8),%rbx\n  mov    %rbx,0x8(%rsp)\n  mov    %rbx,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%rbp\n  mov    %rbx,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,%rbx\n  test   %r13d,%r13d\n  js     11e9 <func0+0x90>\n  lea    0x1(%r13),%r15d\n  shl    $0x3,%r15\n  mov    $0x0,%r12d\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    %rax,0x0(%rbp,%r12,1)\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    %rax,(%rbx,%r12,1)\n  add    $0x8,%r12\n  cmp    %r12,%r15\n  jne    11b9 <func0+0x60>\n  mov    0x0(%rbp),%rax\n  movl   $0x0,0x8(%rax)\n  movl   $0x0,0x4(%rax)\n  movl   $0x0,(%rax)\n  mov    (%rbx),%rax\n  movl   $0x0,0x8(%rax)\n  movl   $0x0,0x4(%rax)\n  movl   $0x0,(%rax)\n  test   %r13d,%r13d\n  jle    127e <func0+0x125>\n  lea    0x1(%r13),%esi\n  mov    $0x1,%ecx\n  mov    %ecx,%edx\n  imul   %ecx,%edx\n  sub    %ecx,%edx\n  add    $0x1,%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  lea    (%rax,%rax,2),%edi\n  mov    %edx,%eax\n  sub    %edi,%eax\n  mov    %eax,-0x4(%r14,%rcx,4)\n  mov    -0x8(%rbp,%rcx,8),%rdi\n  mov    0x0(%rbp,%rcx,8),%rdx\n  mov    (%rdi),%r8d\n  mov    %r8d,(%rdx)\n  mov    0x4(%rdi),%r8d\n  mov    %r8d,0x4(%rdx)\n  mov    0x8(%rdi),%edi\n  mov    %edi,0x8(%rdx)\n  cltq\n  addl   $0x1,(%rdx,%rax,4)\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  jne    1226 <func0+0xcd>\n  mov    $0x2,%r10d\n  lea    0x1(%r13),%r9d\n  jmp    133e <func0+0x1e5>\n  add    $0x1,%rcx\n  cmp    %rcx,%r9\n  je     12fd <func0+0x1a4>\n  mov    -0x8(%rbx,%rcx,8),%rax\n  mov    (%rbx,%rcx,8),%rsi\n  mov    (%rax),%edx\n  mov    %edx,(%rsi)\n  mov    0x4(%rax),%edx\n  mov    %edx,0x4(%rsi)\n  mov    0x8(%rax),%eax\n  mov    %eax,0x8(%rsi)\n  test   %ecx,%ecx\n  jle    128d <func0+0x134>\n  mov    -0x4(%r14,%rcx,4),%r8d\n  mov    -0x8(%rbp,%rcx,8),%rdi\n  mov    $0x0,%edx\n  lea    (%r8,%rdx,1),%eax\n  movslq %eax,%r11\n  imul   $0x55555556,%r11,%r11\n  shr    $0x20,%r11\n  mov    %eax,%r12d\n  sar    $0x1f,%r12d\n  sub    %r12d,%r11d\n  lea    (%r11,%r11,2),%r11d\n  sub    %r11d,%eax\n  cltq\n  mov    (%rdi,%rdx,4),%r11d\n  add    %r11d,(%rsi,%rax,4)\n  add    $0x1,%rdx\n  cmp    $0x3,%rdx\n  jne    12c2 <func0+0x169>\n  jmp    128d <func0+0x134>\n  jne    1338 <func0+0x1df>\n  mov    $0x0,%edx\n  mov    (%rbx,%rdx,8),%rax\n  mov    0x0(%rbp,%rdx,8),%rcx\n  mov    (%rax),%esi\n  mov    %esi,(%rcx)\n  movl   $0x0,(%rax)\n  mov    0x4(%rax),%esi\n  mov    %esi,0x4(%rcx)\n  movl   $0x0,0x4(%rax)\n  mov    0x8(%rax),%esi\n  mov    %esi,0x8(%rcx)\n  movl   $0x0,0x8(%rax)\n  add    $0x1,%rdx\n  cmp    %edx,%r13d\n  jge    1302 <func0+0x1a9>\n  sub    $0x1,%r10d\n  je     134d <func0+0x1f4>\n  test   %r13d,%r13d\n  jle    12fb <func0+0x1a2>\n  mov    $0x1,%ecx\n  jmp    1296 <func0+0x13d>\n  mov    0x8(%rsp),%rax\n  mov    -0x8(%rbp,%rax,1),%rax\n  mov    (%rax),%r15d\n  test   %r13d,%r13d\n  js     1389 <func0+0x230>\n  lea    0x1(%r13),%r13d\n  shl    $0x3,%r13\n  mov    $0x0,%r12d\n  mov    0x0(%rbp,%r12,1),%rdi\n  call   1070 <free@plt>\n  mov    (%rbx,%r12,1),%rdi\n  call   1070 <free@plt>\n  add    $0x8,%r12\n  cmp    %r13,%r12\n  jne    136d <func0+0x214>\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  mov    %rbx,%rdi\n  call   1070 <free@plt>\n  mov    %r14,%rdi\n  call   1070 <free@plt>\n  mov    %r15d,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %edi,%r13d\n  movslq %edi,%rdi\n  shl    $0x2,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r14\n  lea    0x1(%r13),%eax\n  cltq\n  lea    0x0(,%rax,8),%rbx\n  mov    %rbx,0x8(%rsp)\n  mov    %rbx,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  mov    %rbx,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbx\n  test   %r13d,%r13d\n  js     L0\n  lea    0x1(%r13),%r15d\n  shl    $0x3,%r15\n  mov    $0x0,%r12d\nL1:\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    %rax,0x0(%rbp,%r12,1)\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    %rax,(%rbx,%r12,1)\n  add    $0x8,%r12\n  cmp    %r12,%r15\n  jne    L1\nL0:\n  mov    0x0(%rbp),%rax\n  movl   $0x0,0x8(%rax)\n  movl   $0x0,0x4(%rax)\n  movl   $0x0,(%rax)\n  mov    (%rbx),%rax\n  movl   $0x0,0x8(%rax)\n  movl   $0x0,0x4(%rax)\n  movl   $0x0,(%rax)\n  test   %r13d,%r13d\n  jle    L2\n  lea    0x1(%r13),%esi\n  mov    $0x1,%ecx\nL3:\n  mov    %ecx,%edx\n  imul   %ecx,%edx\n  sub    %ecx,%edx\n  add    $0x1,%edx\n  movslq %edx,%rax\n  imul   $0x55555556,%rax,%rax\n  shr    $0x20,%rax\n  mov    %edx,%edi\n  sar    $0x1f,%edi\n  sub    %edi,%eax\n  lea    (%rax,%rax,2),%edi\n  mov    %edx,%eax\n  sub    %edi,%eax\n  mov    %eax,-0x4(%r14,%rcx,4)\n  mov    -0x8(%rbp,%rcx,8),%rdi\n  mov    0x0(%rbp,%rcx,8),%rdx\n  mov    (%rdi),%r8d\n  mov    %r8d,(%rdx)\n  mov    0x4(%rdi),%r8d\n  mov    %r8d,0x4(%rdx)\n  mov    0x8(%rdi),%edi\n  mov    %edi,0x8(%rdx)\n  cltq\n  addl   $0x1,(%rdx,%rax,4)\n  add    $0x1,%rcx\n  cmp    %rcx,%rsi\n  jne    L3\nL2:\n  mov    $0x2,%r10d\n  lea    0x1(%r13),%r9d\n  jmp    L4\nL6:\n  add    $0x1,%rcx\n  cmp    %rcx,%r9\n  je     L5\nL12:\n  mov    -0x8(%rbx,%rcx,8),%rax\n  mov    (%rbx,%rcx,8),%rsi\n  mov    (%rax),%edx\n  mov    %edx,(%rsi)\n  mov    0x4(%rax),%edx\n  mov    %edx,0x4(%rsi)\n  mov    0x8(%rax),%eax\n  mov    %eax,0x8(%rsi)\n  test   %ecx,%ecx\n  jle    L6\n  mov    -0x4(%r14,%rcx,4),%r8d\n  mov    -0x8(%rbp,%rcx,8),%rdi\n  mov    $0x0,%edx\nL7:\n  lea    (%r8,%rdx,1),%eax\n  movslq %eax,%r11\n  imul   $0x55555556,%r11,%r11\n  shr    $0x20,%r11\n  mov    %eax,%r12d\n  sar    $0x1f,%r12d\n  sub    %r12d,%r11d\n  lea    (%r11,%r11,2),%r11d\n  sub    %r11d,%eax\n  cltq\n  mov    (%rdi,%rdx,4),%r11d\n  add    %r11d,(%rsi,%rax,4)\n  add    $0x1,%rdx\n  cmp    $0x3,%rdx\n  jne    L7\n  jmp    L6\nL11:\n  jne    L8\nL5:\n  mov    $0x0,%edx\nL9:\n  mov    (%rbx,%rdx,8),%rax\n  mov    0x0(%rbp,%rdx,8),%rcx\n  mov    (%rax),%esi\n  mov    %esi,(%rcx)\n  movl   $0x0,(%rax)\n  mov    0x4(%rax),%esi\n  mov    %esi,0x4(%rcx)\n  movl   $0x0,0x4(%rax)\n  mov    0x8(%rax),%esi\n  mov    %esi,0x8(%rcx)\n  movl   $0x0,0x8(%rax)\n  add    $0x1,%rdx\n  cmp    %edx,%r13d\n  jge    L9\nL8:\n  sub    $0x1,%r10d\n  je     L10\nL4:\n  test   %r13d,%r13d\n  jle    L11\n  mov    $0x1,%ecx\n  jmp    L12\nL10:\n  mov    0x8(%rsp),%rax\n  mov    -0x8(%rbp,%rax,1),%rax\n  mov    (%rax),%r15d\n  test   %r13d,%r13d\n  js     L13\n  lea    0x1(%r13),%r13d\n  shl    $0x3,%r13\n  mov    $0x0,%r12d\nL14:\n  mov    0x0(%rbp,%r12,1),%rdi\n  call   <free@plt>\n  mov    (%rbx,%r12,1),%rdi\n  call   <free@plt>\n  add    $0x8,%r12\n  cmp    %r13,%r12\n  jne    L14\nL13:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %r14,%rdi\n  call   <free@plt>\n  mov    %r15d,%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4585
            },
            "L1": {
                "label": "L1",
                "addr": 4537
            },
            "L2": {
                "label": "L2",
                "addr": 4734
            },
            "L3": {
                "label": "L3",
                "addr": 4646
            },
            "L4": {
                "label": "L4",
                "addr": 4926
            },
            "L5": {
                "label": "L5",
                "addr": 4861
            },
            "L6": {
                "label": "L6",
                "addr": 4749
            },
            "L7": {
                "label": "L7",
                "addr": 4802
            },
            "L8": {
                "label": "L8",
                "addr": 4920
            },
            "L9": {
                "label": "L9",
                "addr": 4866
            },
            "L10": {
                "label": "L10",
                "addr": 4941
            },
            "L11": {
                "label": "L11",
                "addr": 4859
            },
            "L12": {
                "label": "L12",
                "addr": 4758
            },
            "L13": {
                "label": "L13",
                "addr": 5001
            },
            "L14": {
                "label": "L14",
                "addr": 4973
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 147,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  movslq %edi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  mov    %rbx,%r14\n  sub    $0x18,%rsp\n  call   1090 <malloc@plt>\n  mov    %rax,%rbp\n  lea    0x1(%rbx),%eax\n  cltq\n  lea    0x0(,%rax,8),%r15\n  mov    %r15,%rdi\n  mov    %r15,0x8(%rsp)\n  call   1090 <malloc@plt>\n  mov    %r15,%rdi\n  mov    %rax,%r12\n  call   1090 <malloc@plt>\n  mov    %rax,%r13\n  test   %ebx,%ebx\n  js     13fe <func0+0x29e>\n  lea    0x8(,%rbx,8),%rax\n  xor    %r15d,%r15d\n  mov    %rbx,(%rsp)\n  mov    %r15,%rbx\n  mov    %rax,%r15\n  nopl   (%rax)\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  mov    %rax,(%r12,%rbx,1)\n  call   1080 <calloc@plt>\n  mov    %rax,0x0(%r13,%rbx,1)\n  add    $0x8,%rbx\n  cmp    %rbx,%r15\n  jne    11d0 <func0+0x70>\n  mov    (%r12),%r9\n  mov    0x0(%r13),%r10\n  mov    (%rsp),%rbx\n  movq   $0x0,(%r9)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r10)\n  movl   $0x0,0x8(%r10)\n  test   %r14d,%r14d\n  jle    128b <func0+0x12b>\n  mov    %r9,%rdi\n  mov    $0x1,%ecx\n  mov    $0xaaaaaaab,%esi\n  jmp    1247 <func0+0xe7>\n  xchg   %ax,%ax\n  add    $0x1,%rcx\n  mov    %rdx,%rdi\n  lea    -0x1(%rcx),%edx\n  imul   %ecx,%edx\n  lea    0x1(%rdx),%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x21,%rax\n  lea    (%rax,%rax,2),%r8d\n  mov    %edx,%eax\n  mov    (%r12,%rcx,8),%rdx\n  sub    %r8d,%eax\n  mov    (%rdi),%r8d\n  mov    %eax,-0x4(%rbp,%rcx,4)\n  cltq\n  mov    %r8d,(%rdx)\n  mov    0x4(%rdi),%r8d\n  mov    %r8d,0x4(%rdx)\n  mov    0x8(%rdi),%edi\n  mov    %edi,0x8(%rdx)\n  addl   $0x1,(%rdx,%rax,4)\n  cmp    %rbx,%rcx\n  jne    1240 <func0+0xe0>\n  movl   $0x2,(%rsp)\n  test   %r14d,%r14d\n  jle    136a <func0+0x20a>\n  mov    %r9,%r15\n  mov    %r10,%rax\n  mov    $0x1,%r11d\n  nopw   0x0(%rax,%rax,1)\n  mov    (%rax),%edx\n  mov    0x0(%r13,%r11,8),%rcx\n  mov    -0x4(%rbp,%r11,4),%esi\n  mov    %edx,(%rcx)\n  mov    0x4(%rax),%edx\n  mov    %edx,0x4(%rcx)\n  mov    0x8(%rax),%eax\n  xor    %edx,%edx\n  mov    %eax,0x8(%rcx)\n  lea    (%rsi,%rdx,1),%eax\n  movslq %eax,%rdi\n  mov    %eax,%r8d\n  imul   $0x55555556,%rdi,%rdi\n  sar    $0x1f,%r8d\n  shr    $0x20,%rdi\n  sub    %r8d,%edi\n  lea    (%rdi,%rdi,2),%edi\n  sub    %edi,%eax\n  mov    (%r15,%rdx,4),%edi\n  add    $0x1,%rdx\n  cltq\n  add    %edi,(%rcx,%rax,4)\n  cmp    $0x3,%rdx\n  jne    12cc <func0+0x16c>\n  cmp    %rbx,%r11\n  je     1318 <func0+0x1b8>\n  mov    (%r12,%r11,8),%r15\n  mov    %rcx,%rax\n  add    $0x1,%r11\n  jmp    12b0 <func0+0x150>\n  nopl   0x0(%rax)\n  mov    %r9,%rcx\n  mov    %r10,%rax\n  xor    %edx,%edx\n  jmp    1331 <func0+0x1d1>\n  nopw   0x0(%rax,%rax,1)\n  mov    0x0(%r13,%rdx,8),%rax\n  mov    (%r12,%rdx,8),%rcx\n  mov    (%rax),%rsi\n  add    $0x1,%rdx\n  movq   $0x0,(%rax)\n  mov    %rsi,(%rcx)\n  mov    0x8(%rax),%esi\n  movl   $0x0,0x8(%rax)\n  mov    %esi,0x8(%rcx)\n  cmp    %edx,%r14d\n  jge    1328 <func0+0x1c8>\n  cmpl   $0x1,(%rsp)\n  je     1390 <func0+0x230>\n  movl   $0x1,(%rsp)\n  test   %r14d,%r14d\n  jg     129b <func0+0x13b>\n  jne    1354 <func0+0x1f4>\n  mov    (%r10),%rax\n  mov    $0x3,%ecx\n  mov    %r10,%rdi\n  mov    %rax,(%r9)\n  mov    0x8(%r10),%eax\n  mov    %eax,0x8(%r9)\n  mov    %r14d,%eax\n  rep stos %eax,%es:(%rdi)\n  jmp    1354 <func0+0x1f4>\n  nopl   0x0(%rax)\n  mov    0x8(%rsp),%rax\n  mov    -0x8(%r12,%rax,1),%rax\n  mov    (%rax),%r15d\n  test   %r14d,%r14d\n  js     13d4 <func0+0x274>\n  lea    0x8(,%rbx,8),%rbx\n  xor    %r14d,%r14d\n  mov    %r9,%rdi\n  jmp    13bc <func0+0x25c>\n  nopw   0x0(%rax,%rax,1)\n  mov    (%r12,%r14,1),%rdi\n  call   1070 <free@plt>\n  mov    0x0(%r13,%r14,1),%rdi\n  add    $0x8,%r14\n  call   1070 <free@plt>\n  cmp    %rbx,%r14\n  jne    13b8 <func0+0x258>\n  mov    %r12,%rdi\n  call   1070 <free@plt>\n  mov    %r13,%rdi\n  call   1070 <free@plt>\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  add    $0x18,%rsp\n  mov    %r15d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    (%r12),%r9\n  mov    (%rax),%r10\n  movq   $0x0,(%r9)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r10)\n  movl   $0x0,0x8(%r10)\n  jmp    128b <func0+0x12b>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  movslq %edi,%rbx\n  lea    0x0(,%rbx,4),%rdi\n  mov    %rbx,%r14\n  sub    $0x18,%rsp\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  lea    0x1(%rbx),%eax\n  cltq\n  lea    0x0(,%rax,8),%r15\n  mov    %r15,%rdi\n  mov    %r15,0x8(%rsp)\n  call   <malloc@plt>\n  mov    %r15,%rdi\n  mov    %rax,%r12\n  call   <malloc@plt>\n  mov    %rax,%r13\n  test   %ebx,%ebx\n  js     L0\n  lea    0x8(,%rbx,8),%rax\n  xor    %r15d,%r15d\n  mov    %rbx,(%rsp)\n  mov    %r15,%rbx\n  mov    %rax,%r15\n  nopl   (%rax)\nL1:\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  mov    %rax,(%r12,%rbx,1)\n  call   <calloc@plt>\n  mov    %rax,0x0(%r13,%rbx,1)\n  add    $0x8,%rbx\n  cmp    %rbx,%r15\n  jne    L1\n  mov    (%r12),%r9\n  mov    0x0(%r13),%r10\n  mov    (%rsp),%rbx\n  movq   $0x0,(%r9)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r10)\n  movl   $0x0,0x8(%r10)\n  test   %r14d,%r14d\n  jle    L2\n  mov    %r9,%rdi\n  mov    $0x1,%ecx\n  mov    $0xaaaaaaab,%esi\n  jmp    L3\n  xchg   %ax,%ax\nL4:\n  add    $0x1,%rcx\n  mov    %rdx,%rdi\nL3:\n  lea    -0x1(%rcx),%edx\n  imul   %ecx,%edx\n  lea    0x1(%rdx),%eax\n  mov    %rax,%rdx\n  imul   %rsi,%rax\n  shr    $0x21,%rax\n  lea    (%rax,%rax,2),%r8d\n  mov    %edx,%eax\n  mov    (%r12,%rcx,8),%rdx\n  sub    %r8d,%eax\n  mov    (%rdi),%r8d\n  mov    %eax,-0x4(%rbp,%rcx,4)\n  cltq\n  mov    %r8d,(%rdx)\n  mov    0x4(%rdi),%r8d\n  mov    %r8d,0x4(%rdx)\n  mov    0x8(%rdi),%edi\n  mov    %edi,0x8(%rdx)\n  addl   $0x1,(%rdx,%rax,4)\n  cmp    %rbx,%rcx\n  jne    L4\nL2:\n  movl   $0x2,(%rsp)\n  test   %r14d,%r14d\n  jle    L5\nL12:\n  mov    %r9,%r15\n  mov    %r10,%rax\n  mov    $0x1,%r11d\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    (%rax),%edx\n  mov    0x0(%r13,%r11,8),%rcx\n  mov    -0x4(%rbp,%r11,4),%esi\n  mov    %edx,(%rcx)\n  mov    0x4(%rax),%edx\n  mov    %edx,0x4(%rcx)\n  mov    0x8(%rax),%eax\n  xor    %edx,%edx\n  mov    %eax,0x8(%rcx)\nL6:\n  lea    (%rsi,%rdx,1),%eax\n  movslq %eax,%rdi\n  mov    %eax,%r8d\n  imul   $0x55555556,%rdi,%rdi\n  sar    $0x1f,%r8d\n  shr    $0x20,%rdi\n  sub    %r8d,%edi\n  lea    (%rdi,%rdi,2),%edi\n  sub    %edi,%eax\n  mov    (%r15,%rdx,4),%edi\n  add    $0x1,%rdx\n  cltq\n  add    %edi,(%rcx,%rax,4)\n  cmp    $0x3,%rdx\n  jne    L6\n  cmp    %rbx,%r11\n  je     L7\n  mov    (%r12,%r11,8),%r15\n  mov    %rcx,%rax\n  add    $0x1,%r11\n  jmp    L8\n  nopl   0x0(%rax)\nL7:\n  mov    %r9,%rcx\n  mov    %r10,%rax\n  xor    %edx,%edx\n  jmp    L9\n  nopw   0x0(%rax,%rax,1)\nL10:\n  mov    0x0(%r13,%rdx,8),%rax\n  mov    (%r12,%rdx,8),%rcx\nL9:\n  mov    (%rax),%rsi\n  add    $0x1,%rdx\n  movq   $0x0,(%rax)\n  mov    %rsi,(%rcx)\n  mov    0x8(%rax),%esi\n  movl   $0x0,0x8(%rax)\n  mov    %esi,0x8(%rcx)\n  cmp    %edx,%r14d\n  jge    L10\nL13:\n  cmpl   $0x1,(%rsp)\n  je     L11\n  movl   $0x1,(%rsp)\n  test   %r14d,%r14d\n  jg     L12\nL5:\n  jne    L13\n  mov    (%r10),%rax\n  mov    $0x3,%ecx\n  mov    %r10,%rdi\n  mov    %rax,(%r9)\n  mov    0x8(%r10),%eax\n  mov    %eax,0x8(%r9)\n  mov    %r14d,%eax\n  rep stos %eax,%es:(%rdi)\n  jmp    L13\n  nopl   0x0(%rax)\nL11:\n  mov    0x8(%rsp),%rax\n  mov    -0x8(%r12,%rax,1),%rax\n  mov    (%rax),%r15d\n  test   %r14d,%r14d\n  js     L14\n  lea    0x8(,%rbx,8),%rbx\n  xor    %r14d,%r14d\n  mov    %r9,%rdi\n  jmp    L15\n  nopw   0x0(%rax,%rax,1)\nL16:\n  mov    (%r12,%r14,1),%rdi\nL15:\n  call   <free@plt>\n  mov    0x0(%r13,%r14,1),%rdi\n  add    $0x8,%r14\n  call   <free@plt>\n  cmp    %rbx,%r14\n  jne    L16\nL14:\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  mov    %r15d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  mov    (%r12),%r9\n  mov    (%rax),%r10\n  movq   $0x0,(%r9)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r10)\n  movl   $0x0,0x8(%r10)\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 5118
            },
            "L1": {
                "label": "L1",
                "addr": 4560
            },
            "L2": {
                "label": "L2",
                "addr": 4747
            },
            "L3": {
                "label": "L3",
                "addr": 4679
            },
            "L4": {
                "label": "L4",
                "addr": 4672
            },
            "L5": {
                "label": "L5",
                "addr": 4970
            },
            "L6": {
                "label": "L6",
                "addr": 4812
            },
            "L7": {
                "label": "L7",
                "addr": 4888
            },
            "L8": {
                "label": "L8",
                "addr": 4784
            },
            "L9": {
                "label": "L9",
                "addr": 4913
            },
            "L10": {
                "label": "L10",
                "addr": 4904
            },
            "L11": {
                "label": "L11",
                "addr": 5008
            },
            "L12": {
                "label": "L12",
                "addr": 4763
            },
            "L13": {
                "label": "L13",
                "addr": 4948
            },
            "L14": {
                "label": "L14",
                "addr": 5076
            },
            "L15": {
                "label": "L15",
                "addr": 5052
            },
            "L16": {
                "label": "L16",
                "addr": 5048
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 147,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nint func0(int n) {\n    int *a = (int *)malloc(n * sizeof(int));\n    int **sum = (int **)malloc((n + 1) * sizeof(int *));\n    int **sum2 = (int **)malloc((n + 1) * sizeof(int *));\n    for (int i = 0; i <= n; i++) {\n        sum[i] = (int *)calloc(3, sizeof(int));\n        sum2[i] = (int *)calloc(3, sizeof(int));\n    }\n    sum[0][0] = sum[0][1] = sum[0][2] = 0;\n    sum2[0][0] = sum2[0][1] = sum2[0][2] = 0;\n    for (int i = 1; i <= n; i++) {\n        a[i - 1] = (i * i - i + 1) % 3;\n        for (int j = 0; j < 3; j++) {\n            sum[i][j] = sum[i - 1][j];\n        }\n        sum[i][a[i - 1]] += 1;\n    }\n    for (int times = 1; times < 3; times++) {\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum2[i][j] = sum2[i - 1][j];\n            }\n            if (i >= 1) {\n                for (int j = 0; j <= 2; j++) {\n                    sum2[i][(a[i - 1] + j) % 3] += sum[i - 1][j];\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j < 3; j++) {\n                sum[i][j] = sum2[i][j];\n                sum2[i][j] = 0;\n            }\n        }\n    }\n\n    int result = sum[n][0];\n    for (int i = 0; i <= n; ++i) {\n        free(sum[i]);\n        free(sum2[i]);\n    }\n    free(sum);\n    free(sum2);\n    free(a);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(5) == 1);\n    assert(func0(6) == 4);\n    assert(func0(10) == 36);\n    assert(func0(100) == 53361);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  movslq %edi,%r14\n  push   %r13\n  lea    0x0(,%r14,4),%rdi\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %r14,%rbx\n  sub    $0x18,%rsp\n  call   1090 <malloc@plt>\n  mov    %rax,%r13\n  lea    0x1(%r14),%eax\n  cltq\n  lea    0x0(,%rax,8),%r15\n  mov    %r15,%rdi\n  mov    %r15,0x8(%rsp)\n  call   1090 <malloc@plt>\n  mov    %r15,%rdi\n  xor    %r15d,%r15d\n  mov    %rax,%rbp\n  call   1090 <malloc@plt>\n  mov    %rax,%r12\n  lea    0x8(,%r14,8),%rax\n  mov    %rax,(%rsp)\n  test   %r14d,%r14d\n  js     1426 <func0+0x2c6>\n  nopl   0x0(%rax)\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   1080 <calloc@plt>\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  mov    %rax,0x0(%rbp,%r15,1)\n  call   1080 <calloc@plt>\n  mov    %rax,(%r12,%r15,1)\n  add    $0x8,%r15\n  cmp    (%rsp),%r15\n  jne    11d0 <func0+0x70>\n  mov    0x0(%rbp),%rax\n  mov    (%r12),%r9\n  movl   $0x0,0x8(%rax)\n  movq   $0x0,(%rax)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r9)\n  test   %ebx,%ebx\n  jle    128a <func0+0x12a>\n  xor    %edx,%edx\n  xor    %edi,%edi\n  mov    $0xaaaaaaab,%esi\n  jmp    123f <func0+0xdf>\n  nopl   (%rax)\n  mov    0x0(%rbp,%rdx,8),%rax\n  mov    (%rax),%edi\n  lea    0x1(%rdx),%ecx\n  imul   %edx,%ecx\n  lea    0x1(%rcx),%eax\n  mov    %rax,%rcx\n  imul   %rsi,%rax\n  shr    $0x21,%rax\n  lea    (%rax,%rax,2),%r10d\n  mov    %ecx,%eax\n  mov    0x8(%rbp,%rdx,8),%rcx\n  sub    %r10d,%eax\n  mov    0x0(%rbp,%rdx,8),%r10\n  mov    %edi,(%rcx)\n  mov    0x4(%r10),%edi\n  mov    %eax,0x0(%r13,%rdx,4)\n  cltq\n  add    $0x1,%rdx\n  mov    %edi,0x4(%rcx)\n  mov    0x8(%r10),%edi\n  mov    %edi,0x8(%rcx)\n  addl   $0x1,(%rcx,%rax,4)\n  cmp    %r14,%rdx\n  jne    1238 <func0+0xd8>\n  mov    $0x2,%r10d\n  mov    %r9,%rdx\n  xor    %esi,%esi\n  test   %ebx,%ebx\n  jle    1394 <func0+0x234>\n  nopl   (%rax)\n  mov    %rdx,%rax\n  mov    0x8(%r12,%rsi,8),%rdx\n  mov    (%rax),%ecx\n  mov    %ecx,(%rdx)\n  mov    0x4(%rax),%ecx\n  mov    %ecx,0x4(%rdx)\n  movslq 0x0(%r13,%rsi,4),%rcx\n  mov    0x8(%rax),%eax\n  mov    %eax,0x8(%rdx)\n  mov    %rcx,%rax\n  imul   $0x55555556,%rcx,%rcx\n  mov    %eax,%edi\n  sar    $0x1f,%edi\n  shr    $0x20,%rcx\n  sub    %edi,%ecx\n  lea    (%rcx,%rcx,2),%edi\n  mov    %eax,%ecx\n  sub    %edi,%ecx\n  mov    0x0(%rbp,%rsi,8),%rdi\n  add    $0x1,%rsi\n  movslq %ecx,%rcx\n  mov    (%rdi),%r11d\n  add    %r11d,(%rdx,%rcx,4)\n  lea    0x1(%rax),%ecx\n  add    $0x2,%eax\n  movslq %ecx,%r11\n  mov    %ecx,%r15d\n  imul   $0x55555556,%r11,%r11\n  sar    $0x1f,%r15d\n  shr    $0x20,%r11\n  sub    %r15d,%r11d\n  lea    (%r11,%r11,2),%r11d\n  sub    %r11d,%ecx\n  mov    0x4(%rdi),%r11d\n  movslq %ecx,%rcx\n  add    %r11d,(%rdx,%rcx,4)\n  movslq %eax,%rcx\n  mov    %eax,%r11d\n  imul   $0x55555556,%rcx,%rcx\n  sar    $0x1f,%r11d\n  shr    $0x20,%rcx\n  sub    %r11d,%ecx\n  lea    (%rcx,%rcx,2),%ecx\n  sub    %ecx,%eax\n  mov    0x8(%rdi),%ecx\n  cltq\n  add    %ecx,(%rdx,%rax,4)\n  cmp    %r14,%rsi\n  jne    12a0 <func0+0x140>\n  xor    %eax,%eax\n  nopl   0x0(%rax)\n  mov    (%r12,%rax,8),%rdx\n  mov    0x0(%rbp,%rax,8),%rcx\n  add    $0x1,%rax\n  mov    (%rdx),%rsi\n  movq   $0x0,(%rdx)\n  mov    %rsi,(%rcx)\n  mov    0x8(%rdx),%esi\n  movl   $0x0,0x8(%rdx)\n  mov    %esi,0x8(%rcx)\n  cmp    %eax,%ebx\n  jge    1350 <func0+0x1f0>\n  cmp    $0x1,%r10d\n  je     13c0 <func0+0x260>\n  mov    $0x1,%r10d\n  mov    %r9,%rdx\n  xor    %esi,%esi\n  test   %ebx,%ebx\n  jg     12a0 <func0+0x140>\n  jne    137b <func0+0x21b>\n  mov    (%r12),%rax\n  mov    0x0(%rbp),%rdx\n  mov    (%rax),%rcx\n  movq   $0x0,(%rax)\n  mov    %rcx,(%rdx)\n  mov    0x8(%rax),%ecx\n  movl   $0x0,0x8(%rax)\n  mov    %ecx,0x8(%rdx)\n  jmp    137b <func0+0x21b>\n  nopw   0x0(%rax,%rax,1)\n  mov    0x8(%rsp),%rax\n  lea    0x8(,%r14,8),%r15\n  xor    %r14d,%r14d\n  mov    -0x8(%rbp,%rax,1),%rax\n  mov    (%rax),%eax\n  mov    %eax,(%rsp)\n  test   %ebx,%ebx\n  js     13fc <func0+0x29c>\n  xchg   %ax,%ax\n  mov    0x0(%rbp,%r14,1),%rdi\n  call   1070 <free@plt>\n  mov    (%r12,%r14,1),%rdi\n  add    $0x8,%r14\n  call   1070 <free@plt>\n  cmp    %r15,%r14\n  jne    13e0 <func0+0x280>\n  mov    %rbp,%rdi\n  call   1070 <free@plt>\n  mov    %r12,%rdi\n  call   1070 <free@plt>\n  mov    %r13,%rdi\n  call   1070 <free@plt>\n  mov    (%rsp),%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    0x0(%rbp),%rax\n  mov    (%r12),%r9\n  movl   $0x0,0x8(%rax)\n  movq   $0x0,(%rax)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r9)\n  jmp    128a <func0+0x12a>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  movslq %edi,%r14\n  push   %r13\n  lea    0x0(,%r14,4),%rdi\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %r14,%rbx\n  sub    $0x18,%rsp\n  call   <malloc@plt>\n  mov    %rax,%r13\n  lea    0x1(%r14),%eax\n  cltq\n  lea    0x0(,%rax,8),%r15\n  mov    %r15,%rdi\n  mov    %r15,0x8(%rsp)\n  call   <malloc@plt>\n  mov    %r15,%rdi\n  xor    %r15d,%r15d\n  mov    %rax,%rbp\n  call   <malloc@plt>\n  mov    %rax,%r12\n  lea    0x8(,%r14,8),%rax\n  mov    %rax,(%rsp)\n  test   %r14d,%r14d\n  js     L0\n  nopl   0x0(%rax)\nL1:\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  call   <calloc@plt>\n  mov    $0x4,%esi\n  mov    $0x3,%edi\n  mov    %rax,0x0(%rbp,%r15,1)\n  call   <calloc@plt>\n  mov    %rax,(%r12,%r15,1)\n  add    $0x8,%r15\n  cmp    (%rsp),%r15\n  jne    L1\n  mov    0x0(%rbp),%rax\n  mov    (%r12),%r9\n  movl   $0x0,0x8(%rax)\n  movq   $0x0,(%rax)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r9)\n  test   %ebx,%ebx\n  jle    L2\n  xor    %edx,%edx\n  xor    %edi,%edi\n  mov    $0xaaaaaaab,%esi\n  jmp    L3\n  nopl   (%rax)\nL4:\n  mov    0x0(%rbp,%rdx,8),%rax\n  mov    (%rax),%edi\nL3:\n  lea    0x1(%rdx),%ecx\n  imul   %edx,%ecx\n  lea    0x1(%rcx),%eax\n  mov    %rax,%rcx\n  imul   %rsi,%rax\n  shr    $0x21,%rax\n  lea    (%rax,%rax,2),%r10d\n  mov    %ecx,%eax\n  mov    0x8(%rbp,%rdx,8),%rcx\n  sub    %r10d,%eax\n  mov    0x0(%rbp,%rdx,8),%r10\n  mov    %edi,(%rcx)\n  mov    0x4(%r10),%edi\n  mov    %eax,0x0(%r13,%rdx,4)\n  cltq\n  add    $0x1,%rdx\n  mov    %edi,0x4(%rcx)\n  mov    0x8(%r10),%edi\n  mov    %edi,0x8(%rcx)\n  addl   $0x1,(%rcx,%rax,4)\n  cmp    %r14,%rdx\n  jne    L4\nL2:\n  mov    $0x2,%r10d\n  mov    %r9,%rdx\n  xor    %esi,%esi\n  test   %ebx,%ebx\n  jle    L5\n  nopl   (%rax)\nL6:\n  mov    %rdx,%rax\n  mov    0x8(%r12,%rsi,8),%rdx\n  mov    (%rax),%ecx\n  mov    %ecx,(%rdx)\n  mov    0x4(%rax),%ecx\n  mov    %ecx,0x4(%rdx)\n  movslq 0x0(%r13,%rsi,4),%rcx\n  mov    0x8(%rax),%eax\n  mov    %eax,0x8(%rdx)\n  mov    %rcx,%rax\n  imul   $0x55555556,%rcx,%rcx\n  mov    %eax,%edi\n  sar    $0x1f,%edi\n  shr    $0x20,%rcx\n  sub    %edi,%ecx\n  lea    (%rcx,%rcx,2),%edi\n  mov    %eax,%ecx\n  sub    %edi,%ecx\n  mov    0x0(%rbp,%rsi,8),%rdi\n  add    $0x1,%rsi\n  movslq %ecx,%rcx\n  mov    (%rdi),%r11d\n  add    %r11d,(%rdx,%rcx,4)\n  lea    0x1(%rax),%ecx\n  add    $0x2,%eax\n  movslq %ecx,%r11\n  mov    %ecx,%r15d\n  imul   $0x55555556,%r11,%r11\n  sar    $0x1f,%r15d\n  shr    $0x20,%r11\n  sub    %r15d,%r11d\n  lea    (%r11,%r11,2),%r11d\n  sub    %r11d,%ecx\n  mov    0x4(%rdi),%r11d\n  movslq %ecx,%rcx\n  add    %r11d,(%rdx,%rcx,4)\n  movslq %eax,%rcx\n  mov    %eax,%r11d\n  imul   $0x55555556,%rcx,%rcx\n  sar    $0x1f,%r11d\n  shr    $0x20,%rcx\n  sub    %r11d,%ecx\n  lea    (%rcx,%rcx,2),%ecx\n  sub    %ecx,%eax\n  mov    0x8(%rdi),%ecx\n  cltq\n  add    %ecx,(%rdx,%rax,4)\n  cmp    %r14,%rsi\n  jne    L6\n  xor    %eax,%eax\n  nopl   0x0(%rax)\nL7:\n  mov    (%r12,%rax,8),%rdx\n  mov    0x0(%rbp,%rax,8),%rcx\n  add    $0x1,%rax\n  mov    (%rdx),%rsi\n  movq   $0x0,(%rdx)\n  mov    %rsi,(%rcx)\n  mov    0x8(%rdx),%esi\n  movl   $0x0,0x8(%rdx)\n  mov    %esi,0x8(%rcx)\n  cmp    %eax,%ebx\n  jge    L7\nL9:\n  cmp    $0x1,%r10d\n  je     L8\n  mov    $0x1,%r10d\n  mov    %r9,%rdx\n  xor    %esi,%esi\n  test   %ebx,%ebx\n  jg     L6\nL5:\n  jne    L9\n  mov    (%r12),%rax\n  mov    0x0(%rbp),%rdx\n  mov    (%rax),%rcx\n  movq   $0x0,(%rax)\n  mov    %rcx,(%rdx)\n  mov    0x8(%rax),%ecx\n  movl   $0x0,0x8(%rax)\n  mov    %ecx,0x8(%rdx)\n  jmp    L9\n  nopw   0x0(%rax,%rax,1)\nL8:\n  mov    0x8(%rsp),%rax\n  lea    0x8(,%r14,8),%r15\n  xor    %r14d,%r14d\n  mov    -0x8(%rbp,%rax,1),%rax\n  mov    (%rax),%eax\n  mov    %eax,(%rsp)\n  test   %ebx,%ebx\n  js     L10\n  xchg   %ax,%ax\nL11:\n  mov    0x0(%rbp,%r14,1),%rdi\n  call   <free@plt>\n  mov    (%r12,%r14,1),%rdi\n  add    $0x8,%r14\n  call   <free@plt>\n  cmp    %r15,%r14\n  jne    L11\nL10:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    %r12,%rdi\n  call   <free@plt>\n  mov    %r13,%rdi\n  call   <free@plt>\n  mov    (%rsp),%eax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL0:\n  mov    0x0(%rbp),%rax\n  mov    (%r12),%r9\n  movl   $0x0,0x8(%rax)\n  movq   $0x0,(%rax)\n  movl   $0x0,0x8(%r9)\n  movq   $0x0,(%r9)\n  jmp    L2",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 5158
            },
            "L1": {
                "label": "L1",
                "addr": 4560
            },
            "L2": {
                "label": "L2",
                "addr": 4746
            },
            "L3": {
                "label": "L3",
                "addr": 4671
            },
            "L4": {
                "label": "L4",
                "addr": 4664
            },
            "L5": {
                "label": "L5",
                "addr": 5012
            },
            "L6": {
                "label": "L6",
                "addr": 4768
            },
            "L7": {
                "label": "L7",
                "addr": 4944
            },
            "L8": {
                "label": "L8",
                "addr": 5056
            },
            "L9": {
                "label": "L9",
                "addr": 4987
            },
            "L10": {
                "label": "L10",
                "addr": 5116
            },
            "L11": {
                "label": "L11",
                "addr": 5088
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 148,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x90,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %rsi,-0x80(%rbp)\n  mov    %rdx,-0x88(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    0xe73(%rip),%rax        # 2000 <_fini+0xcd0>\n  mov    %rax,-0x50(%rbp)\n  lea    0xe70(%rip),%rax        # 2008 <_fini+0xcd8>\n  mov    %rax,-0x48(%rbp)\n  lea    0xe6b(%rip),%rax        # 200e <_fini+0xcde>\n  mov    %rax,-0x40(%rbp)\n  lea    0xe66(%rip),%rax        # 2014 <_fini+0xce4>\n  mov    %rax,-0x38(%rbp)\n  lea    0xe60(%rip),%rax        # 2019 <_fini+0xce9>\n  mov    %rax,-0x30(%rbp)\n  lea    0xe5d(%rip),%rax        # 2021 <_fini+0xcf1>\n  mov    %rax,-0x28(%rbp)\n  lea    0xe59(%rip),%rax        # 2028 <_fini+0xcf8>\n  mov    %rax,-0x20(%rbp)\n  lea    0xe55(%rip),%rax        # 202f <_fini+0xcff>\n  mov    %rax,-0x18(%rbp)\n  movl   $0xffffffff,-0x68(%rbp)\n  movl   $0xffffffff,-0x64(%rbp)\n  movl   $0x0,-0x60(%rbp)\n  jmp    123f <func0+0xe6>\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    -0x78(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  jne    1218 <func0+0xbf>\n  mov    -0x60(%rbp),%eax\n  mov    %eax,-0x68(%rbp)\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    -0x80(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  jne    123b <func0+0xe2>\n  mov    -0x60(%rbp),%eax\n  mov    %eax,-0x64(%rbp)\n  addl   $0x1,-0x60(%rbp)\n  cmpl   $0x7,-0x60(%rbp)\n  jle    11f5 <func0+0x9c>\n  cmpl   $0xffffffff,-0x68(%rbp)\n  je     1259 <func0+0x100>\n  cmpl   $0xffffffff,-0x64(%rbp)\n  je     1259 <func0+0x100>\n  mov    -0x68(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jne    1270 <func0+0x117>\n  mov    -0x88(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    1317 <func0+0x1be>\n  mov    -0x68(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    128a <func0+0x131>\n  mov    -0x68(%rbp),%eax\n  mov    %eax,-0x5c(%rbp)\n  mov    -0x64(%rbp),%eax\n  mov    %eax,-0x68(%rbp)\n  mov    -0x5c(%rbp),%eax\n  mov    %eax,-0x64(%rbp)\n  mov    -0x64(%rbp),%eax\n  sub    -0x68(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    -0x88(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jg     12bd <func0+0x164>\n  mov    -0x88(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    1317 <func0+0x1be>\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x58(%rbp)\n  mov    -0x68(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x60(%rbp)\n  jmp    130b <func0+0x1b2>\n  mov    -0x60(%rbp),%eax\n  sub    -0x68(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x60(%rbp)\n  mov    -0x60(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jl     12e3 <func0+0x18a>\n  mov    -0x58(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     132b <func0+0x1d2>\n  call   1070 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x90,%rsp\n  mov    %rdi,-0x78(%rbp)\n  mov    %rsi,-0x80(%rbp)\n  mov    %rdx,-0x88(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,-0x50(%rbp)\n  lea    D1(%rip),%rax\n  mov    %rax,-0x48(%rbp)\n  lea    D2(%rip),%rax\n  mov    %rax,-0x40(%rbp)\n  lea    D3(%rip),%rax\n  mov    %rax,-0x38(%rbp)\n  lea    D4(%rip),%rax\n  mov    %rax,-0x30(%rbp)\n  lea    D5(%rip),%rax\n  mov    %rax,-0x28(%rbp)\n  lea    D6(%rip),%rax\n  mov    %rax,-0x20(%rbp)\n  lea    D7(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  movl   $0xffffffff,-0x68(%rbp)\n  movl   $0xffffffff,-0x64(%rbp)\n  movl   $0x0,-0x60(%rbp)\n  jmp    L0\nL3:\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    -0x78(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L1\n  mov    -0x60(%rbp),%eax\n  mov    %eax,-0x68(%rbp)\nL1:\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    -0x80(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L2\n  mov    -0x60(%rbp),%eax\n  mov    %eax,-0x64(%rbp)\nL2:\n  addl   $0x1,-0x60(%rbp)\nL0:\n  cmpl   $0x7,-0x60(%rbp)\n  jle    L3\n  cmpl   $0xffffffff,-0x68(%rbp)\n  je     L4\n  cmpl   $0xffffffff,-0x64(%rbp)\n  je     L4\n  mov    -0x68(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jne    L5\nL4:\n  mov    -0x88(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    L6\nL5:\n  mov    -0x68(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jle    L7\n  mov    -0x68(%rbp),%eax\n  mov    %eax,-0x5c(%rbp)\n  mov    -0x64(%rbp),%eax\n  mov    %eax,-0x68(%rbp)\n  mov    -0x5c(%rbp),%eax\n  mov    %eax,-0x64(%rbp)\nL7:\n  mov    -0x64(%rbp),%eax\n  sub    -0x68(%rbp),%eax\n  lea    -0x1(%rax),%edx\n  mov    -0x88(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%eax\n  test   %eax,%eax\n  jg     L8\n  mov    -0x88(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    L6\nL8:\n  mov    -0x88(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x58(%rbp)\n  mov    -0x68(%rbp),%eax\n  add    $0x1,%eax\n  mov    %eax,-0x60(%rbp)\n  jmp    L9\nL10:\n  mov    -0x60(%rbp),%eax\n  sub    -0x68(%rbp),%eax\n  cltq\n  shl    $0x3,%rax\n  lea    -0x8(%rax),%rdx\n  mov    -0x58(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x60(%rbp),%eax\n  cltq\n  mov    -0x50(%rbp,%rax,8),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x60(%rbp)\nL9:\n  mov    -0x60(%rbp),%eax\n  cmp    -0x64(%rbp),%eax\n  jl     L10\n  mov    -0x58(%rbp),%rax\nL6:\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L11\n  call   <__stack_chk_fail@plt>\nL11:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3699
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8200,
                "bias": [
                    3696
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8206,
                "bias": [
                    3691
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8212,
                "bias": [
                    3686
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8217,
                "bias": [
                    3680
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8225,
                "bias": [
                    3677
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8232,
                "bias": [
                    3673
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8239,
                "bias": [
                    3669
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4671
            },
            "L1": {
                "label": "L1",
                "addr": 4632
            },
            "L2": {
                "label": "L2",
                "addr": 4667
            },
            "L3": {
                "label": "L3",
                "addr": 4597
            },
            "L4": {
                "label": "L4",
                "addr": 4697
            },
            "L5": {
                "label": "L5",
                "addr": 4720
            },
            "L6": {
                "label": "L6",
                "addr": 4887
            },
            "L7": {
                "label": "L7",
                "addr": 4746
            },
            "L8": {
                "label": "L8",
                "addr": 4797
            },
            "L9": {
                "label": "L9",
                "addr": 4875
            },
            "L10": {
                "label": "L10",
                "addr": 4835
            },
            "L11": {
                "label": "L11",
                "addr": 4907
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4d6572637572790056656e7573004561727468004d617273004a7570697465720053617475726e005572616e7573004e657074756e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Mercury\""
                },
                "0x2021": {
                    "type": "string",
                    "value": "\"Saturn\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"Venus\""
                },
                "0x2028": {
                    "type": "string",
                    "value": "\"Uranus\""
                },
                "0x200e": {
                    "type": "string",
                    "value": "\"Earth\""
                },
                "0x202f": {
                    "type": "string",
                    "value": "\"Neptune\""
                },
                "0x2014": {
                    "type": "string",
                    "value": "\"Mars\""
                },
                "0x2019": {
                    "type": "string",
                    "value": "\"Jupiter\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 148,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %rdi,%r15\n  mov    %rsi,(%rsp)\n  mov    %rdx,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    0xe72(%rip),%rax        # 2000 <_fini+0xd1c>\n  mov    %rax,0x10(%rsp)\n  lea    0xe6e(%rip),%rax        # 2008 <_fini+0xd24>\n  mov    %rax,0x18(%rsp)\n  lea    0xe68(%rip),%rax        # 200e <_fini+0xd2a>\n  mov    %rax,0x20(%rsp)\n  lea    0xe62(%rip),%rax        # 2014 <_fini+0xd30>\n  mov    %rax,0x28(%rsp)\n  lea    0xe5b(%rip),%rax        # 2019 <_fini+0xd35>\n  mov    %rax,0x30(%rsp)\n  lea    0xe57(%rip),%rax        # 2021 <_fini+0xd3d>\n  mov    %rax,0x38(%rsp)\n  lea    0xe52(%rip),%rax        # 2028 <_fini+0xd44>\n  mov    %rax,0x40(%rsp)\n  lea    0xe4d(%rip),%rax        # 202f <_fini+0xd4b>\n  mov    %rax,0x48(%rsp)\n  mov    $0x0,%ebx\n  mov    $0xffffffff,%ebp\n  mov    $0xffffffff,%r13d\n  mov    0x10(%rsp,%rbx,8),%r12\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%r13d\n  mov    (%rsp),%rsi\n  mov    %r12,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%ebp\n  add    $0x1,%rbx\n  cmp    $0x8,%rbx\n  jne    11f7 <func0+0x9e>\n  cmp    $0xffffffff,%ebp\n  sete   %al\n  cmp    %ebp,%r13d\n  sete   %dl\n  or     %dl,%al\n  jne    12c0 <func0+0x167>\n  cmp    $0xffffffff,%r13d\n  je     12c0 <func0+0x167>\n  cmp    %ebp,%r13d\n  jle    124f <func0+0xf6>\n  mov    %r13d,%eax\n  mov    %ebp,%r13d\n  mov    %eax,%ebp\n  mov    %ebp,%eax\n  sub    %r13d,%eax\n  sub    $0x1,%eax\n  mov    0x8(%rsp),%rcx\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    12d2 <func0+0x179>\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   1090 <malloc@plt>\n  lea    0x1(%r13),%edx\n  cmp    %edx,%ebp\n  jle    12a1 <func0+0x148>\n  sub    $0x2,%ebp\n  sub    %r13d,%ebp\n  movslq %r13d,%r13\n  lea    0x10(%rsp,%r13,8),%rsi\n  mov    $0x0,%edx\n  mov    0x8(%rsi,%rdx,8),%rcx\n  mov    %rcx,(%rax,%rdx,8)\n  mov    %rdx,%rcx\n  add    $0x1,%rdx\n  cmp    %rbp,%rcx\n  jne    128c <func0+0x133>\n  mov    0x58(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    12df <func0+0x186>\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    0x8(%rsp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    12a1 <func0+0x148>\n  movl   $0x0,(%rcx)\n  mov    $0x0,%eax\n  jmp    12a1 <func0+0x148>\n  call   1070 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x68,%rsp\n  mov    %rdi,%r15\n  mov    %rsi,(%rsp)\n  mov    %rdx,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,0x10(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x18(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x20(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x28(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x30(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  mov    $0x0,%ebx\n  mov    $0xffffffff,%ebp\n  mov    $0xffffffff,%r13d\nL0:\n  mov    0x10(%rsp,%rbx,8),%r12\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%r13d\n  mov    (%rsp),%rsi\n  mov    %r12,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%ebp\n  add    $0x1,%rbx\n  cmp    $0x8,%rbx\n  jne    L0\n  cmp    $0xffffffff,%ebp\n  sete   %al\n  cmp    %ebp,%r13d\n  sete   %dl\n  or     %dl,%al\n  jne    L1\n  cmp    $0xffffffff,%r13d\n  je     L1\n  cmp    %ebp,%r13d\n  jle    L2\n  mov    %r13d,%eax\n  mov    %ebp,%r13d\n  mov    %eax,%ebp\nL2:\n  mov    %ebp,%eax\n  sub    %r13d,%eax\n  sub    $0x1,%eax\n  mov    0x8(%rsp),%rcx\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    L3\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   <malloc@plt>\n  lea    0x1(%r13),%edx\n  cmp    %edx,%ebp\n  jle    L4\n  sub    $0x2,%ebp\n  sub    %r13d,%ebp\n  movslq %r13d,%r13\n  lea    0x10(%rsp,%r13,8),%rsi\n  mov    $0x0,%edx\nL5:\n  mov    0x8(%rsi,%rdx,8),%rcx\n  mov    %rcx,(%rax,%rdx,8)\n  mov    %rdx,%rcx\n  add    $0x1,%rdx\n  cmp    %rbp,%rcx\n  jne    L5\nL4:\n  mov    0x58(%rsp),%rdx\n  sub    %fs:0x28,%rdx\n  jne    L6\n  add    $0x68,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL1:\n  mov    0x8(%rsp),%rax\n  movl   $0x0,(%rax)\n  mov    $0x0,%eax\n  jmp    L4\nL3:\n  movl   $0x0,(%rcx)\n  mov    $0x0,%eax\n  jmp    L4\nL6:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3698
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8200,
                "bias": [
                    3694
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8206,
                "bias": [
                    3688
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8212,
                "bias": [
                    3682
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8217,
                "bias": [
                    3675
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8225,
                "bias": [
                    3671
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8232,
                "bias": [
                    3666
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8239,
                "bias": [
                    3661
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4599
            },
            "L1": {
                "label": "L1",
                "addr": 4800
            },
            "L2": {
                "label": "L2",
                "addr": 4687
            },
            "L3": {
                "label": "L3",
                "addr": 4818
            },
            "L4": {
                "label": "L4",
                "addr": 4769
            },
            "L5": {
                "label": "L5",
                "addr": 4748
            },
            "L6": {
                "label": "L6",
                "addr": 4831
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4d6572637572790056656e7573004561727468004d617273004a7570697465720053617475726e005572616e7573004e657074756e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Mercury\""
                },
                "0x2021": {
                    "type": "string",
                    "value": "\"Saturn\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"Venus\""
                },
                "0x2028": {
                    "type": "string",
                    "value": "\"Uranus\""
                },
                "0x200e": {
                    "type": "string",
                    "value": "\"Earth\""
                },
                "0x202f": {
                    "type": "string",
                    "value": "\"Neptune\""
                },
                "0x2014": {
                    "type": "string",
                    "value": "\"Mars\""
                },
                "0x2019": {
                    "type": "string",
                    "value": "\"Jupiter\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 148,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    $0xffffffff,%r15d\n  push   %r14\n  mov    %rdi,%r14\n  lea    0xe68(%rip),%rdi        # 2000 <_fini+0xcf0>\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  mov    $0xffffffff,%ebp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x68,%rsp\n  mov    %rdx,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    0xe40(%rip),%rax        # 2008 <_fini+0xcf8>\n  mov    %rdi,0x10(%rsp)\n  mov    %rax,0x18(%rsp)\n  lea    0xe35(%rip),%rax        # 200e <_fini+0xcfe>\n  mov    %rax,0x20(%rsp)\n  lea    0xe2f(%rip),%rax        # 2014 <_fini+0xd04>\n  mov    %rax,0x28(%rsp)\n  lea    0xe28(%rip),%rax        # 2019 <_fini+0xd09>\n  mov    %rax,0x30(%rsp)\n  lea    0xe24(%rip),%rax        # 2021 <_fini+0xd11>\n  mov    %rax,0x38(%rsp)\n  lea    0xe1f(%rip),%rax        # 2028 <_fini+0xd18>\n  mov    %rax,0x40(%rsp)\n  lea    0xe1a(%rip),%rax        # 202f <_fini+0xd1f>\n  mov    %rax,0x48(%rsp)\n  jmp    1225 <func0+0xa5>\n  nopl   0x0(%rax)\n  mov    0x10(%rsp,%rbx,8),%rdi\n  mov    %r14,%rsi\n  mov    %rdi,(%rsp)\n  call   1090 <strcmp@plt>\n  mov    (%rsp),%rdi\n  mov    %r13,%rsi\n  test   %eax,%eax\n  cmove  %ebx,%ebp\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%r15d\n  add    $0x1,%rbx\n  cmp    $0x8,%rbx\n  jne    1220 <func0+0xa0>\n  cmp    $0xffffffff,%r15d\n  sete   %al\n  cmp    %r15d,%ebp\n  sete   %cl\n  or     %cl,%al\n  jne    12f8 <func0+0x178>\n  cmp    $0xffffffff,%ebp\n  je     12f8 <func0+0x178>\n  cmp    %r15d,%ebp\n  jg     12e8 <func0+0x168>\n  mov    %r15d,%eax\n  mov    0x8(%rsp),%rcx\n  sub    %ebp,%eax\n  sub    $0x1,%eax\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    12f8 <func0+0x178>\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r8\n  lea    0x1(%rbp),%eax\n  cmp    %eax,%r15d\n  jle    12c2 <func0+0x142>\n  lea    -0x2(%r15),%edx\n  cltq\n  mov    %r8,%rdi\n  sub    %ebp,%edx\n  lea    0x10(%rsp,%rax,8),%rsi\n  lea    0x8(,%rdx,8),%rdx\n  call   10a0 <memcpy@plt>\n  mov    %rax,%r8\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1308 <func0+0x188>\n  add    $0x68,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  mov    %ebp,%eax\n  mov    %r15d,%ebp\n  mov    %eax,%r15d\n  jmp    1275 <func0+0xf5>\n  nopw   0x0(%rax,%rax,1)\n  mov    0x8(%rsp),%rax\n  xor    %r8d,%r8d\n  movl   $0x0,(%rax)\n  jmp    12c2 <func0+0x142>\n  call   1080 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    $0xffffffff,%r15d\n  push   %r14\n  mov    %rdi,%r14\n  lea    D0(%rip),%rdi\n  push   %r13\n  mov    %rsi,%r13\n  push   %r12\n  push   %rbp\n  mov    $0xffffffff,%ebp\n  push   %rbx\n  xor    %ebx,%ebx\n  sub    $0x68,%rsp\n  mov    %rdx,0x8(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  lea    D1(%rip),%rax\n  mov    %rdi,0x10(%rsp)\n  mov    %rax,0x18(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x20(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x28(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x30(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x38(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  jmp    L0\n  nopl   0x0(%rax)\nL1:\n  mov    0x10(%rsp,%rbx,8),%rdi\nL0:\n  mov    %r14,%rsi\n  mov    %rdi,(%rsp)\n  call   <strcmp@plt>\n  mov    (%rsp),%rdi\n  mov    %r13,%rsi\n  test   %eax,%eax\n  cmove  %ebx,%ebp\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmove  %ebx,%r15d\n  add    $0x1,%rbx\n  cmp    $0x8,%rbx\n  jne    L1\n  cmp    $0xffffffff,%r15d\n  sete   %al\n  cmp    %r15d,%ebp\n  sete   %cl\n  or     %cl,%al\n  jne    L2\n  cmp    $0xffffffff,%ebp\n  je     L2\n  cmp    %r15d,%ebp\n  jg     L3\nL6:\n  mov    %r15d,%eax\n  mov    0x8(%rsp),%rcx\n  sub    %ebp,%eax\n  sub    $0x1,%eax\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    L2\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  lea    0x1(%rbp),%eax\n  cmp    %eax,%r15d\n  jle    L4\n  lea    -0x2(%r15),%edx\n  cltq\n  mov    %r8,%rdi\n  sub    %ebp,%edx\n  lea    0x10(%rsp,%rax,8),%rsi\n  lea    0x8(,%rdx,8),%rdx\n  call   <memcpy@plt>\n  mov    %rax,%r8\nL4:\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  add    $0x68,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL3:\n  mov    %ebp,%eax\n  mov    %r15d,%ebp\n  mov    %eax,%r15d\n  jmp    L6\n  nopw   0x0(%rax,%rax,1)\nL2:\n  mov    0x8(%rsp),%rax\n  xor    %r8d,%r8d\n  movl   $0x0,(%rax)\n  jmp    L4\nL5:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3688
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8200,
                "bias": [
                    3648
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8206,
                "bias": [
                    3637
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8212,
                "bias": [
                    3631
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8217,
                "bias": [
                    3624
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8225,
                "bias": [
                    3620
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8232,
                "bias": [
                    3615
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8239,
                "bias": [
                    3610
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4645
            },
            "L1": {
                "label": "L1",
                "addr": 4640
            },
            "L2": {
                "label": "L2",
                "addr": 4856
            },
            "L3": {
                "label": "L3",
                "addr": 4840
            },
            "L4": {
                "label": "L4",
                "addr": 4802
            },
            "L5": {
                "label": "L5",
                "addr": 4872
            },
            "L6": {
                "label": "L6",
                "addr": 4725
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4d6572637572790056656e7573004561727468004d617273004a7570697465720053617475726e005572616e7573004e657074756e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Mercury\""
                },
                "0x2021": {
                    "type": "string",
                    "value": "\"Saturn\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"Venus\""
                },
                "0x2028": {
                    "type": "string",
                    "value": "\"Uranus\""
                },
                "0x200e": {
                    "type": "string",
                    "value": "\"Earth\""
                },
                "0x202f": {
                    "type": "string",
                    "value": "\"Neptune\""
                },
                "0x2014": {
                    "type": "string",
                    "value": "\"Mars\""
                },
                "0x2019": {
                    "type": "string",
                    "value": "\"Jupiter\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 148,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nchar** func0(const char* planet1, const char* planet2, int* returnSize) {\n    const char* planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"};\n    int pos1 = -1, pos2 = -1, m;\n    for (m = 0; m < 8; m++) {\n        if (strcmp(planets[m], planet1) == 0) pos1 = m;\n        if (strcmp(planets[m], planet2) == 0) pos2 = m;\n    }\n    if (pos1 == -1 || pos2 == -1 || pos1 == pos2) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (pos1 > pos2) { int temp = pos1; pos1 = pos2; pos2 = temp; }\n    *returnSize = pos2 - pos1 - 1;\n    if (*returnSize <= 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    char** out = malloc(*returnSize * sizeof(char*));\n    for (m = pos1 + 1; m < pos2; m++) {\n        out[m - pos1 - 1] = (char*)planets[m];\n    }\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char** a, const char** b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char** result;\n\n    const char* test1[] = {\"Saturn\", \"Uranus\"};\n    result = func0(\"Jupiter\", \"Neptune\", &size);\n    assert(issame(result, test1, size, 2));\n    free(result);\n\n    const char* test2[] = {\"Venus\"};\n    result = func0(\"Earth\", \"Mercury\", &size);\n    assert(issame(result, test2, size, 1));\n    free(result);\n\n    const char* test3[] = {\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"};\n    result = func0(\"Mercury\", \"Uranus\", &size);\n    assert(issame(result, test3, size, 5));\n    free(result);\n\n    const char* test4[] = {\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"};\n    result = func0(\"Neptune\", \"Venus\", &size);\n    assert(issame(result, test4, size, 5));\n    free(result);\n\n    result = func0(\"Earth\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Mars\", \"Earth\", &size);\n    assert(size == 0 && result == NULL);\n\n    result = func0(\"Jupiter\", \"Makemake\", &size);\n    assert(size == 0 && result == NULL);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  lea    0xe70(%rip),%rdi        # 2000 <_fini+0xb74>\n  lea    0xe91(%rip),%r9        # 2028 <_fini+0xb9c>\n  push   %r14\n  movq   %rdi,%xmm0\n  lea    0xe69(%rip),%r14        # 200e <_fini+0xb82>\n  push   %r13\n  lea    0xe6b(%rip),%r13        # 2019 <_fini+0xb8d>\n  push   %r12\n  mov    %rsi,%r12\n  mov    %r15,%rsi\n  push   %rbp\n  lea    0xe4a(%rip),%rbp        # 2008 <_fini+0xb7c>\n  push   %rbx\n  movq   %rbp,%xmm1\n  xor    %ebx,%ebx\n  punpcklqdq %xmm1,%xmm0\n  sub    $0x68,%rsp\n  mov    %rdx,(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  movaps %xmm0,0x10(%rsp)\n  movq   %r14,%xmm0\n  movhps 0x2c15(%rip),%xmm0        # 3e08 <__do_global_dtors_aux_fini_array_entry+0x8>\n  movaps %xmm0,0x20(%rsp)\n  movq   %r13,%xmm0\n  movhps 0x2c0c(%rip),%xmm0        # 3e10 <__do_global_dtors_aux_fini_array_entry+0x10>\n  movaps %xmm0,0x30(%rsp)\n  movq   %r9,%xmm0\n  movhps 0x2c03(%rip),%xmm0        # 3e18 <__do_global_dtors_aux_fini_array_entry+0x18>\n  movaps %xmm0,0x40(%rsp)\n  call   1090 <strcmp@plt>\n  mov    %r12,%rsi\n  lea    0xdd7(%rip),%rdi        # 2000 <_fini+0xb74>\n  test   %eax,%eax\n  setne  %bl\n  call   1090 <strcmp@plt>\n  mov    %rbp,%rdi\n  mov    %r15,%rsi\n  test   %eax,%eax\n  setne  %al\n  neg    %ebx\n  movzbl %al,%eax\n  mov    %eax,0xc(%rsp)\n  call   1090 <strcmp@plt>\n  mov    $0x1,%edx\n  mov    %rbp,%rdi\n  mov    %r12,%rsi\n  test   %eax,%eax\n  cmove  %edx,%ebx\n  call   1090 <strcmp@plt>\n  mov    0xc(%rsp),%ebp\n  mov    %r14,%rdi\n  mov    %r15,%rsi\n  mov    $0x1,%edx\n  neg    %ebp\n  test   %eax,%eax\n  cmove  %edx,%ebp\n  call   1090 <strcmp@plt>\n  mov    $0x2,%edx\n  mov    %r14,%rdi\n  mov    %r12,%rsi\n  test   %eax,%eax\n  mov    $0x4,%r14d\n  cmove  %edx,%ebx\n  call   1090 <strcmp@plt>\n  mov    $0x2,%edx\n  mov    %r15,%rsi\n  test   %eax,%eax\n  lea    0xd6c(%rip),%rdi        # 2014 <_fini+0xb88>\n  cmove  %edx,%ebp\n  call   1090 <strcmp@plt>\n  mov    $0x3,%edx\n  mov    %r12,%rsi\n  test   %eax,%eax\n  lea    0xd53(%rip),%rdi        # 2014 <_fini+0xb88>\n  cmove  %edx,%ebx\n  call   1090 <strcmp@plt>\n  mov    $0x3,%edx\n  mov    %r13,%rdi\n  mov    %r15,%rsi\n  test   %eax,%eax\n  cmove  %edx,%ebp\n  call   1090 <strcmp@plt>\n  mov    %r13,%rdi\n  mov    %r12,%rsi\n  mov    $0x6,%r13d\n  test   %eax,%eax\n  cmove  %r14d,%ebx\n  call   1090 <strcmp@plt>\n  mov    %r15,%rsi\n  lea    0xd22(%rip),%rdi        # 2021 <_fini+0xb95>\n  test   %eax,%eax\n  cmove  %r14d,%ebp\n  mov    $0x5,%r14d\n  call   1090 <strcmp@plt>\n  mov    %r12,%rsi\n  lea    0xd07(%rip),%rdi        # 2021 <_fini+0xb95>\n  test   %eax,%eax\n  cmove  %r14d,%ebx\n  call   1090 <strcmp@plt>\n  lea    0xcfc(%rip),%r9        # 2028 <_fini+0xb9c>\n  mov    %r15,%rsi\n  test   %eax,%eax\n  mov    %r9,%rdi\n  cmove  %r14d,%ebp\n  call   1090 <strcmp@plt>\n  lea    0xce4(%rip),%r9        # 2028 <_fini+0xb9c>\n  mov    %r12,%rsi\n  test   %eax,%eax\n  mov    %r9,%rdi\n  cmove  %r13d,%ebx\n  call   1090 <strcmp@plt>\n  mov    %r15,%rsi\n  lea    0xcd0(%rip),%rdi        # 202f <_fini+0xba3>\n  test   %eax,%eax\n  cmove  %r13d,%ebp\n  call   1090 <strcmp@plt>\n  mov    %r12,%rsi\n  lea    0xcbb(%rip),%rdi        # 202f <_fini+0xba3>\n  test   %eax,%eax\n  je     13a0 <func0+0x220>\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    1460 <func0+0x2e0>\n  cmp    $0x7,%ebx\n  je     1450 <func0+0x2d0>\n  cmp    $0xffffffff,%ebx\n  je     1450 <func0+0x2d0>\n  mov    $0x7,%r12d\n  jmp    13dc <func0+0x25c>\n  nop\n  call   1090 <strcmp@plt>\n  mov    $0x7,%r12d\n  test   %eax,%eax\n  je     1450 <func0+0x2d0>\n  cmp    $0xffffffff,%ebp\n  sete   %al\n  cmp    %ebp,%r12d\n  sete   %dl\n  or     %dl,%al\n  jne    1450 <func0+0x2d0>\n  cmp    $0xffffffff,%r12d\n  je     1450 <func0+0x2d0>\n  cmp    %ebp,%r12d\n  jle    147e <func0+0x2fe>\n  mov    %ebp,%ebx\n  mov    %r12d,%eax\n  mov    (%rsp),%rcx\n  sub    %ebx,%eax\n  sub    $0x1,%eax\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    1450 <func0+0x2d0>\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r8\n  lea    0x1(%rbx),%eax\n  cmp    %eax,%r12d\n  jle    1429 <func0+0x2a9>\n  sub    $0x2,%r12d\n  cltq\n  mov    %r8,%rdi\n  sub    %ebx,%r12d\n  lea    0x10(%rsp,%rax,8),%rsi\n  lea    0x8(,%r12,8),%rdx\n  call   10a0 <memcpy@plt>\n  mov    %rax,%r8\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1479 <func0+0x2f9>\n  add    $0x68,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    (%rsp),%rax\n  xor    %r8d,%r8d\n  movl   $0x0,(%rax)\n  jmp    1429 <func0+0x2a9>\n  nop\n  cmp    $0xffffffff,%ebp\n  mov    %ebx,%r12d\n  sete   %al\n  cmp    %ebp,%r12d\n  sete   %dl\n  or     %dl,%al\n  je     13c7 <func0+0x247>\n  jmp    1450 <func0+0x2d0>\n  call   1080 <__stack_chk_fail@plt>\n  mov    %r12d,%ebx\n  mov    %ebp,%r12d\n  jmp    13dc <func0+0x25c>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rdi,%r15\n  lea    D0(%rip),%rdi\n  lea    D1(%rip),%r9\n  push   %r14\n  movq   %rdi,%xmm0\n  lea    D2(%rip),%r14\n  push   %r13\n  lea    D3(%rip),%r13\n  push   %r12\n  mov    %rsi,%r12\n  mov    %r15,%rsi\n  push   %rbp\n  lea    D4(%rip),%rbp\n  push   %rbx\n  movq   %rbp,%xmm1\n  xor    %ebx,%ebx\n  punpcklqdq %xmm1,%xmm0\n  sub    $0x68,%rsp\n  mov    %rdx,(%rsp)\n  mov    %fs:0x28,%rax\n  mov    %rax,0x58(%rsp)\n  xor    %eax,%eax\n  movaps %xmm0,0x10(%rsp)\n  movq   %r14,%xmm0\n  movhps D5(%rip),%xmm0\n  movaps %xmm0,0x20(%rsp)\n  movq   %r13,%xmm0\n  movhps D6(%rip),%xmm0\n  movaps %xmm0,0x30(%rsp)\n  movq   %r9,%xmm0\n  movhps D7(%rip),%xmm0\n  movaps %xmm0,0x40(%rsp)\n  call   <strcmp@plt>\n  mov    %r12,%rsi\n  lea    D0(%rip),%rdi\n  test   %eax,%eax\n  setne  %bl\n  call   <strcmp@plt>\n  mov    %rbp,%rdi\n  mov    %r15,%rsi\n  test   %eax,%eax\n  setne  %al\n  neg    %ebx\n  movzbl %al,%eax\n  mov    %eax,0xc(%rsp)\n  call   <strcmp@plt>\n  mov    $0x1,%edx\n  mov    %rbp,%rdi\n  mov    %r12,%rsi\n  test   %eax,%eax\n  cmove  %edx,%ebx\n  call   <strcmp@plt>\n  mov    0xc(%rsp),%ebp\n  mov    %r14,%rdi\n  mov    %r15,%rsi\n  mov    $0x1,%edx\n  neg    %ebp\n  test   %eax,%eax\n  cmove  %edx,%ebp\n  call   <strcmp@plt>\n  mov    $0x2,%edx\n  mov    %r14,%rdi\n  mov    %r12,%rsi\n  test   %eax,%eax\n  mov    $0x4,%r14d\n  cmove  %edx,%ebx\n  call   <strcmp@plt>\n  mov    $0x2,%edx\n  mov    %r15,%rsi\n  test   %eax,%eax\n  lea    D8(%rip),%rdi\n  cmove  %edx,%ebp\n  call   <strcmp@plt>\n  mov    $0x3,%edx\n  mov    %r12,%rsi\n  test   %eax,%eax\n  lea    D8(%rip),%rdi\n  cmove  %edx,%ebx\n  call   <strcmp@plt>\n  mov    $0x3,%edx\n  mov    %r13,%rdi\n  mov    %r15,%rsi\n  test   %eax,%eax\n  cmove  %edx,%ebp\n  call   <strcmp@plt>\n  mov    %r13,%rdi\n  mov    %r12,%rsi\n  mov    $0x6,%r13d\n  test   %eax,%eax\n  cmove  %r14d,%ebx\n  call   <strcmp@plt>\n  mov    %r15,%rsi\n  lea    D9(%rip),%rdi\n  test   %eax,%eax\n  cmove  %r14d,%ebp\n  mov    $0x5,%r14d\n  call   <strcmp@plt>\n  mov    %r12,%rsi\n  lea    D9(%rip),%rdi\n  test   %eax,%eax\n  cmove  %r14d,%ebx\n  call   <strcmp@plt>\n  lea    D1(%rip),%r9\n  mov    %r15,%rsi\n  test   %eax,%eax\n  mov    %r9,%rdi\n  cmove  %r14d,%ebp\n  call   <strcmp@plt>\n  lea    D1(%rip),%r9\n  mov    %r12,%rsi\n  test   %eax,%eax\n  mov    %r9,%rdi\n  cmove  %r13d,%ebx\n  call   <strcmp@plt>\n  mov    %r15,%rsi\n  lea    D10(%rip),%rdi\n  test   %eax,%eax\n  cmove  %r13d,%ebp\n  call   <strcmp@plt>\n  mov    %r12,%rsi\n  lea    D10(%rip),%rdi\n  test   %eax,%eax\n  je     L0\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L1\n  cmp    $0x7,%ebx\n  je     L2\n  cmp    $0xffffffff,%ebx\n  je     L2\n  mov    $0x7,%r12d\n  jmp    L3\n  nop\nL0:\n  call   <strcmp@plt>\n  mov    $0x7,%r12d\n  test   %eax,%eax\n  je     L2\n  cmp    $0xffffffff,%ebp\n  sete   %al\n  cmp    %ebp,%r12d\n  sete   %dl\n  or     %dl,%al\n  jne    L2\nL7:\n  cmp    $0xffffffff,%r12d\n  je     L2\n  cmp    %ebp,%r12d\n  jle    L4\n  mov    %ebp,%ebx\nL3:\n  mov    %r12d,%eax\n  mov    (%rsp),%rcx\n  sub    %ebx,%eax\n  sub    $0x1,%eax\n  mov    %eax,(%rcx)\n  test   %eax,%eax\n  jle    L2\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  lea    0x1(%rbx),%eax\n  cmp    %eax,%r12d\n  jle    L5\n  sub    $0x2,%r12d\n  cltq\n  mov    %r8,%rdi\n  sub    %ebx,%r12d\n  lea    0x10(%rsp,%rax,8),%rsi\n  lea    0x8(,%r12,8),%rdx\n  call   <memcpy@plt>\n  mov    %rax,%r8\nL5:\n  mov    0x58(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L6\n  add    $0x68,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  mov    (%rsp),%rax\n  xor    %r8d,%r8d\n  movl   $0x0,(%rax)\n  jmp    L5\n  nop\nL1:\n  cmp    $0xffffffff,%ebp\n  mov    %ebx,%r12d\n  sete   %al\n  cmp    %ebp,%r12d\n  sete   %dl\n  or     %dl,%al\n  je     L7\n  jmp    L2\nL6:\n  call   <__stack_chk_fail@plt>\nL4:\n  mov    %r12d,%ebx\n  mov    %ebp,%r12d\n  jmp    L3",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3696,
                    3543
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8232,
                "bias": [
                    3729,
                    3324,
                    3300
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8206,
                "bias": [
                    3689
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8217,
                "bias": [
                    3691
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8200,
                "bias": [
                    3658
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 15880,
                "bias": [
                    11285
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 15888,
                "bias": [
                    11276
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 15896,
                "bias": [
                    11267
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8212,
                "bias": [
                    3436,
                    3411
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8225,
                "bias": [
                    3362,
                    3335
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 8239,
                "bias": [
                    3280,
                    3259
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5024
            },
            "L1": {
                "label": "L1",
                "addr": 5216
            },
            "L2": {
                "label": "L2",
                "addr": 5200
            },
            "L3": {
                "label": "L3",
                "addr": 5084
            },
            "L4": {
                "label": "L4",
                "addr": 5246
            },
            "L5": {
                "label": "L5",
                "addr": 5161
            },
            "L6": {
                "label": "L6",
                "addr": 5241
            },
            "L7": {
                "label": "L7",
                "addr": 5063
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4d6572637572790056656e7573004561727468004d617273004a7570697465720053617475726e005572616e7573004e657074756e6500",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"Mercury\""
                },
                "0x2021": {
                    "type": "string",
                    "value": "\"Saturn\""
                },
                "0x2028": {
                    "type": "string",
                    "value": "\"Uranus\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"Venus\""
                },
                "0x200e": {
                    "type": "string",
                    "value": "\"Earth\""
                },
                "0x202f": {
                    "type": "string",
                    "value": "\"Neptune\""
                },
                "0x2014": {
                    "type": "string",
                    "value": "\"Mars\""
                },
                "0x2019": {
                    "type": "string",
                    "value": "\"Jupiter\""
                },
                "0x3e08": {
                    "type": "byte[8]",
                    "value": []
                },
                "0x3e10": {
                    "type": "byte[8]",
                    "value": []
                },
                "0x3e18": {
                    "type": "byte[8]",
                    "value": []
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 149,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    -0x48(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x28(%rbp)\n  jmp    11ef <func0+0x96>\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  and    $0x1,%eax\n  test   %rax,%rax\n  jne    11eb <func0+0x92>\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%rax\n  mov    %rax,(%rdx)\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x48(%rbp),%rax\n  mov    %edx,(%rax)\n  addl   $0x1,-0x28(%rbp)\n  mov    -0x28(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     1183 <func0+0x2a>\n  movl   $0x0,-0x28(%rbp)\n  jmp    133c <func0+0x1e3>\n  movl   $0x0,-0x24(%rbp)\n  jmp    1323 <func0+0x1ca>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   1070 <strlen@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  cmp    -0x10(%rbp),%rax\n  ja     12b2 <func0+0x159>\n  mov    -0x18(%rbp),%rax\n  cmp    -0x10(%rbp),%rax\n  jne    131f <func0+0x1c6>\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  jle    131f <func0+0x1c6>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x24(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  sub    -0x28(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x24(%rbp)\n  jl     120f <func0+0xb6>\n  addl   $0x1,-0x28(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x28(%rbp)\n  jl     1203 <func0+0xaa>\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   1090 <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  jmp    13a2 <func0+0x249>\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x28(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x28(%rbp)\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x28(%rbp)\n  jl     136f <func0+0x216>\n  mov    -0x20(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %esi,-0x3c(%rbp)\n  mov    %rdx,-0x48(%rbp)\n  mov    -0x48(%rbp),%rax\n  movl   $0x0,(%rax)\n  movl   $0x0,-0x28(%rbp)\n  jmp    L0\nL2:\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  and    $0x1,%eax\n  test   %rax,%rax\n  jne    L1\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  lea    (%rdx,%rax,1),%rcx\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    (%rcx),%rax\n  mov    %rax,(%rdx)\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%edx\n  mov    -0x48(%rbp),%rax\n  mov    %edx,(%rax)\nL1:\n  addl   $0x1,-0x28(%rbp)\nL0:\n  mov    -0x28(%rbp),%eax\n  cmp    -0x3c(%rbp),%eax\n  jl     L2\n  movl   $0x0,-0x28(%rbp)\n  jmp    L3\nL8:\n  movl   $0x0,-0x24(%rbp)\n  jmp    L4\nL7:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x18(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x18(%rbp),%rax\n  cmp    -0x10(%rbp),%rax\n  ja     L5\n  mov    -0x18(%rbp),%rax\n  cmp    -0x10(%rbp),%rax\n  jne    L6\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rcx\n  mov    -0x38(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jle    L6\nL5:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x24(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x38(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%rax\n  mov    %rax,(%rdx)\nL6:\n  addl   $0x1,-0x24(%rbp)\nL4:\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  sub    -0x28(%rbp),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x24(%rbp)\n  jl     L7\n  addl   $0x1,-0x28(%rbp)\nL3:\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  sub    $0x1,%eax\n  cmp    %eax,-0x28(%rbp)\n  jl     L8\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cltq\n  shl    $0x3,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x20(%rbp)\n  movl   $0x0,-0x28(%rbp)\n  jmp    L9\nL10:\n  mov    -0x28(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x28(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,8),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%rax\n  mov    %rax,(%rdx)\n  addl   $0x1,-0x28(%rbp)\nL9:\n  mov    -0x48(%rbp),%rax\n  mov    (%rax),%eax\n  cmp    %eax,-0x28(%rbp)\n  jl     L10\n  mov    -0x20(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4591
            },
            "L1": {
                "label": "L1",
                "addr": 4587
            },
            "L2": {
                "label": "L2",
                "addr": 4483
            },
            "L3": {
                "label": "L3",
                "addr": 4924
            },
            "L4": {
                "label": "L4",
                "addr": 4899
            },
            "L5": {
                "label": "L5",
                "addr": 4786
            },
            "L6": {
                "label": "L6",
                "addr": 4895
            },
            "L7": {
                "label": "L7",
                "addr": 4623
            },
            "L8": {
                "label": "L8",
                "addr": 4611
            },
            "L9": {
                "label": "L9",
                "addr": 5026
            },
            "L10": {
                "label": "L10",
                "addr": 4975
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 149,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  mov    %rdx,%r15\n  movl   $0x0,(%rdx)\n  test   %esi,%esi\n  jle    123b <func0+0xe2>\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r13\n  jmp    1195 <func0+0x3c>\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  je     11b1 <func0+0x58>\n  mov    (%rbx),%rbp\n  mov    %rbp,%rdi\n  call   1070 <strlen@plt>\n  test   $0x1,%al\n  jne    118c <func0+0x33>\n  movslq (%r15),%rax\n  mov    %rbp,(%r12,%rax,8)\n  addl   $0x1,(%r15)\n  jmp    118c <func0+0x33>\n  mov    (%r15),%eax\n  cmp    $0x1,%eax\n  jle    1240 <func0+0xe7>\n  movl   $0x0,0xc(%rsp)\n  jmp    1228 <func0+0xcf>\n  mov    %r14,(%r12,%rbx,8)\n  mov    %r13,0x8(%r12,%rbx,8)\n  add    $0x1,%rbx\n  mov    0xc(%rsp),%eax\n  not    %eax\n  add    (%r15),%eax\n  cmp    %ebx,%eax\n  jle    1215 <func0+0xbc>\n  mov    (%r12,%rbx,8),%r13\n  mov    %r13,%rdi\n  call   1070 <strlen@plt>\n  mov    %rax,%rbp\n  mov    0x8(%r12,%rbx,8),%r14\n  mov    %r14,%rdi\n  call   1070 <strlen@plt>\n  cmp    %rax,%rbp\n  ja     11c7 <func0+0x6e>\n  jne    11d0 <func0+0x77>\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   1080 <strcmp@plt>\n  test   %eax,%eax\n  jg     11c7 <func0+0x6e>\n  jmp    11d0 <func0+0x77>\n  addl   $0x1,0xc(%rsp)\n  mov    0xc(%rsp),%ecx\n  mov    (%r15),%eax\n  lea    -0x1(%rax),%edx\n  cmp    %ecx,%edx\n  jle    1240 <func0+0xe7>\n  mov    (%r15),%eax\n  sub    0xc(%rsp),%eax\n  mov    $0x0,%ebx\n  cmp    $0x1,%eax\n  jg     11e1 <func0+0x88>\n  jmp    1215 <func0+0xbc>\n  mov    $0x0,%eax\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   1090 <malloc@plt>\n  mov    (%r15),%esi\n  test   %esi,%esi\n  jle    126e <func0+0x115>\n  mov    %esi,%esi\n  mov    $0x0,%edx\n  mov    (%r12,%rdx,8),%rcx\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    125d <func0+0x104>\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  mov    %rdx,%r15\n  movl   $0x0,(%rdx)\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%r13\n  jmp    L1\nL3:\n  add    $0x8,%rbx\n  cmp    %r13,%rbx\n  je     L2\nL1:\n  mov    (%rbx),%rbp\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  test   $0x1,%al\n  jne    L3\n  movslq (%r15),%rax\n  mov    %rbp,(%r12,%rax,8)\n  addl   $0x1,(%r15)\n  jmp    L3\nL2:\n  mov    (%r15),%eax\n  cmp    $0x1,%eax\n  jle    L4\n  movl   $0x0,0xc(%rsp)\n  jmp    L5\nL7:\n  mov    %r14,(%r12,%rbx,8)\n  mov    %r13,0x8(%r12,%rbx,8)\nL8:\n  add    $0x1,%rbx\n  mov    0xc(%rsp),%eax\n  not    %eax\n  add    (%r15),%eax\n  cmp    %ebx,%eax\n  jle    L6\nL9:\n  mov    (%r12,%rbx,8),%r13\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rbp\n  mov    0x8(%r12,%rbx,8),%r14\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbp\n  ja     L7\n  jne    L8\n  mov    %r14,%rsi\n  mov    %r13,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jg     L7\n  jmp    L8\nL6:\n  addl   $0x1,0xc(%rsp)\n  mov    0xc(%rsp),%ecx\n  mov    (%r15),%eax\n  lea    -0x1(%rax),%edx\n  cmp    %ecx,%edx\n  jle    L4\nL5:\n  mov    (%r15),%eax\n  sub    0xc(%rsp),%eax\n  mov    $0x0,%ebx\n  cmp    $0x1,%eax\n  jg     L9\n  jmp    L6\nL0:\n  mov    $0x0,%eax\nL4:\n  cltq\n  lea    0x0(,%rax,8),%rdi\n  call   <malloc@plt>\n  mov    (%r15),%esi\n  test   %esi,%esi\n  jle    L10\n  mov    %esi,%esi\n  mov    $0x0,%edx\nL11:\n  mov    (%r12,%rdx,8),%rcx\n  mov    %rcx,(%rax,%rdx,8)\n  add    $0x1,%rdx\n  cmp    %rdx,%rsi\n  jne    L11\nL10:\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4667
            },
            "L1": {
                "label": "L1",
                "addr": 4501
            },
            "L2": {
                "label": "L2",
                "addr": 4529
            },
            "L3": {
                "label": "L3",
                "addr": 4492
            },
            "L4": {
                "label": "L4",
                "addr": 4672
            },
            "L5": {
                "label": "L5",
                "addr": 4648
            },
            "L6": {
                "label": "L6",
                "addr": 4629
            },
            "L7": {
                "label": "L7",
                "addr": 4551
            },
            "L8": {
                "label": "L8",
                "addr": 4560
            },
            "L9": {
                "label": "L9",
                "addr": 4577
            },
            "L10": {
                "label": "L10",
                "addr": 4718
            },
            "L11": {
                "label": "L11",
                "addr": 4701
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 149,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movl   $0x0,(%rdx)\n  mov    %rdi,(%rsp)\n  mov    %rdx,0x10(%rsp)\n  test   %esi,%esi\n  jle    12d4 <func0+0x154>\n  lea    0x8(%rdi),%rdx\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  mov    %rdx,0x8(%rsp)\n  lea    (%rdx,%rax,8),%r12\n  xchg   %ax,%ax\n  mov    (%rbx),%r13\n  mov    %r13,%rdi\n  call   1080 <strlen@plt>\n  test   $0x1,%al\n  jne    11e4 <func0+0x64>\n  mov    (%rsp),%rdx\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  mov    %r13,(%rdx,%rax,8)\n  mov    0x10(%rsp),%rax\n  mov    %ebp,(%rax)\n  add    $0x8,%rbx\n  cmp    %r12,%rbx\n  jne    11c0 <func0+0x40>\n  lea    -0x1(%rbp),%r12d\n  movslq %ebp,%rbp\n  lea    0x0(,%rbp,8),%rax\n  mov    %rax,0x18(%rsp)\n  test   %r12d,%r12d\n  jle    1273 <func0+0xf3>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    0x8(%rsp),%rcx\n  lea    -0x1(%r12),%eax\n  mov    (%rsp),%r15\n  mov    %rax,%r12\n  lea    (%rcx,%rax,8),%rbp\n  jmp    123f <func0+0xbf>\n  nopw   0x0(%rax,%rax,1)\n  je     12b8 <func0+0x138>\n  add    $0x8,%r15\n  cmp    %r15,%rbp\n  je     126e <func0+0xee>\n  mov    (%r15),%r14\n  mov    %r14,%rdi\n  call   1080 <strlen@plt>\n  mov    0x8(%r15),%r13\n  mov    %rax,%rbx\n  mov    %r13,%rdi\n  call   1080 <strlen@plt>\n  cmp    %rax,%rbx\n  jbe    1230 <func0+0xb0>\n  mov    %r13,(%r15)\n  mov    %r14,0x8(%r15)\n  add    $0x8,%r15\n  cmp    %r15,%rbp\n  jne    123f <func0+0xbf>\n  test   %r12d,%r12d\n  jne    1210 <func0+0x90>\n  mov    0x18(%rsp),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r8\n  mov    0x10(%rsp),%rax\n  movslq (%rax),%rax\n  test   %eax,%eax\n  jle    12a3 <func0+0x123>\n  mov    (%rsp),%rsi\n  mov    %r8,%rdi\n  lea    0x0(,%rax,8),%rdx\n  call   10a0 <memcpy@plt>\n  mov    %rax,%r8\n  add    $0x28,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jle    1236 <func0+0xb6>\n  mov    %r13,(%r15)\n  mov    %r14,0x8(%r15)\n  jmp    1265 <func0+0xe5>\n  movq   $0x0,0x18(%rsp)\n  jmp    1273 <func0+0xf3>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x28,%rsp\n  movl   $0x0,(%rdx)\n  mov    %rdi,(%rsp)\n  mov    %rdx,0x10(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    0x8(%rdi),%rdx\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  mov    %rdx,0x8(%rsp)\n  lea    (%rdx,%rax,8),%r12\n  xchg   %ax,%ax\nL2:\n  mov    (%rbx),%r13\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  test   $0x1,%al\n  jne    L1\n  mov    (%rsp),%rdx\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  mov    %r13,(%rdx,%rax,8)\n  mov    0x10(%rsp),%rax\n  mov    %ebp,(%rax)\nL1:\n  add    $0x8,%rbx\n  cmp    %r12,%rbx\n  jne    L2\n  lea    -0x1(%rbp),%r12d\n  movslq %ebp,%rbp\n  lea    0x0(,%rbp,8),%rax\n  mov    %rax,0x18(%rsp)\n  test   %r12d,%r12d\n  jle    L3\n  cs nopw 0x0(%rax,%rax,1)\nL8:\n  mov    0x8(%rsp),%rcx\n  lea    -0x1(%r12),%eax\n  mov    (%rsp),%r15\n  mov    %rax,%r12\n  lea    (%rcx,%rax,8),%rbp\n  jmp    L4\n  nopw   0x0(%rax,%rax,1)\nL7:\n  je     L5\nL10:\n  add    $0x8,%r15\n  cmp    %r15,%rbp\n  je     L6\nL4:\n  mov    (%r15),%r14\n  mov    %r14,%rdi\n  call   <strlen@plt>\n  mov    0x8(%r15),%r13\n  mov    %rax,%rbx\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jbe    L7\n  mov    %r13,(%r15)\n  mov    %r14,0x8(%r15)\nL11:\n  add    $0x8,%r15\n  cmp    %r15,%rbp\n  jne    L4\nL6:\n  test   %r12d,%r12d\n  jne    L8\nL3:\n  mov    0x18(%rsp),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  mov    0x10(%rsp),%rax\n  movslq (%rax),%rax\n  test   %eax,%eax\n  jle    L9\n  mov    (%rsp),%rsi\n  mov    %r8,%rdi\n  lea    0x0(,%rax,8),%rdx\n  call   <memcpy@plt>\n  mov    %rax,%r8\nL9:\n  add    $0x28,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   (%rax)\nL5:\n  mov    %r13,%rsi\n  mov    %r14,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jle    L10\n  mov    %r13,(%r15)\n  mov    %r14,0x8(%r15)\n  jmp    L11\nL0:\n  movq   $0x0,0x18(%rsp)\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4820
            },
            "L1": {
                "label": "L1",
                "addr": 4580
            },
            "L2": {
                "label": "L2",
                "addr": 4544
            },
            "L3": {
                "label": "L3",
                "addr": 4723
            },
            "L4": {
                "label": "L4",
                "addr": 4671
            },
            "L5": {
                "label": "L5",
                "addr": 4792
            },
            "L6": {
                "label": "L6",
                "addr": 4718
            },
            "L7": {
                "label": "L7",
                "addr": 4656
            },
            "L8": {
                "label": "L8",
                "addr": 4624
            },
            "L9": {
                "label": "L9",
                "addr": 4771
            },
            "L10": {
                "label": "L10",
                "addr": 4662
            },
            "L11": {
                "label": "L11",
                "addr": 4709
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 149,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar** func0(char **lst, int lst_size, int *return_size) {\n    int i, j;\n    char *temp;\n\n    *return_size = 0;\n    for (i = 0; i < lst_size; ++i) {\n        if (strlen(lst[i]) % 2 == 0) {\n            lst[*return_size] = lst[i];\n            (*return_size)++;\n        }\n    }\n\n    for (i = 0; i < *return_size - 1; ++i) {\n        for (j = 0; j < *return_size - i - 1; ++j) {\n            size_t len_j = strlen(lst[j]);\n            size_t len_j1 = strlen(lst[j + 1]);\n            if (len_j > len_j1 || (len_j == len_j1 && strcmp(lst[j], lst[j + 1]) > 0)) {\n                temp = lst[j];\n                lst[j] = lst[j + 1];\n                lst[j + 1] = temp;\n            }\n        }\n    }\n\n    char **out = malloc(*return_size * sizeof(char *));\n    for (i = 0; i < *return_size; ++i) {\n        out[i] = lst[i];\n    }\n\n    return out;\n}",
        "c_test": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint issame(char **a, char **b, int a_size, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (strcmp(a[i], b[i]) != 0) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int size;\n    char **result;\n\n    char *test1[] = {\"aa\", \"a\", \"aaa\"};\n    char *expected1[] = {\"aa\"};\n    result = func0(test1, 3, &size);\n    assert(issame(result, expected1, size, 1));\n    free(result);\n\n    char *test2[] = {\"school\", \"AI\", \"asdf\", \"b\"};\n    char *expected2[] = {\"AI\", \"asdf\", \"school\"};\n    result = func0(test2, 4, &size);\n    assert(issame(result, expected2, size, 3));\n    free(result);\n\n    char *test3[] = {\"d\", \"b\", \"c\", \"a\"};\n    result = func0(test3, 4, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test4[] = {\"d\", \"dcba\", \"abcd\", \"a\"};\n    char *expected4[] = {\"abcd\", \"dcba\"};\n    result = func0(test4, 4, &size);\n    assert(issame(result, expected4, size, 2));\n    free(result);\n\n    char *test5[] = {\"AI\", \"ai\", \"au\"};\n    char *expected5[] = {\"AI\", \"ai\", \"au\"};\n    result = func0(test5, 3, &size);\n    assert(issame(result, expected5, size, 3));\n    free(result);\n\n    char *test6[] = {\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"};\n    result = func0(test6, 6, &size);\n    assert(size == 0);\n    free(result);\n\n    char *test7[] = {\"aaaa\", \"bbbb\", \"dd\", \"cc\"};\n    char *expected7[] = {\"cc\", \"dd\", \"aaaa\", \"bbbb\"};\n    result = func0(test7, 4, &size);\n    assert(issame(result, expected7, size, 4));\n    free(result);\n\n    printf(\"All tests passed!\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  movl   $0x0,(%rdx)\n  mov    %rdi,0x10(%rsp)\n  mov    %rdx,0x20(%rsp)\n  test   %esi,%esi\n  jle    12ee <func0+0x16e>\n  lea    0x8(%rdi),%rdx\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  mov    %rdx,0x18(%rsp)\n  lea    (%rdx,%rax,8),%r12\n  nop\n  mov    (%rbx),%r13\n  mov    %r13,%rdi\n  call   1080 <strlen@plt>\n  test   $0x1,%al\n  jne    11e5 <func0+0x65>\n  mov    0x10(%rsp),%rdx\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  mov    %r13,(%rdx,%rax,8)\n  mov    0x20(%rsp),%rax\n  mov    %ebp,(%rax)\n  add    $0x8,%rbx\n  cmp    %rbx,%r12\n  jne    11c0 <func0+0x40>\n  lea    -0x1(%rbp),%r13d\n  movslq %ebp,%rbp\n  lea    0x0(,%rbp,8),%rax\n  mov    %rax,0x28(%rsp)\n  test   %r13d,%r13d\n  jle    1287 <func0+0x107>\n  nopl   0x0(%rax,%rax,1)\n  mov    0x18(%rsp),%rcx\n  lea    -0x1(%r13),%eax\n  mov    0x10(%rsp),%r15\n  mov    %rax,%r13\n  lea    (%rcx,%rax,8),%r12\n  jmp    123f <func0+0xbf>\n  nopw   0x0(%rax,%rax,1)\n  je     12d0 <func0+0x150>\n  add    $0x8,%r15\n  cmp    %r12,%r15\n  je     1282 <func0+0x102>\n  mov    (%r15),%rbp\n  mov    %rbp,%rdi\n  call   1080 <strlen@plt>\n  mov    0x8(%r15),%r14\n  movq   %rbp,%xmm1\n  mov    %rax,%rbx\n  movq   %r14,%xmm0\n  mov    %r14,%rdi\n  punpcklqdq %xmm1,%xmm0\n  movaps %xmm0,(%rsp)\n  call   1080 <strlen@plt>\n  cmp    %rax,%rbx\n  jbe    1230 <func0+0xb0>\n  movdqa (%rsp),%xmm2\n  movups %xmm2,(%r15)\n  add    $0x8,%r15\n  cmp    %r12,%r15\n  jne    123f <func0+0xbf>\n  test   %r13d,%r13d\n  jne    1210 <func0+0x90>\n  mov    0x28(%rsp),%rdi\n  call   10b0 <malloc@plt>\n  mov    %rax,%r8\n  mov    0x20(%rsp),%rax\n  movslq (%rax),%rax\n  test   %eax,%eax\n  jle    12b8 <func0+0x138>\n  mov    0x10(%rsp),%rsi\n  mov    %r8,%rdi\n  lea    0x0(,%rax,8),%rdx\n  call   10a0 <memcpy@plt>\n  mov    %rax,%r8\n  add    $0x38,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\n  mov    %r14,%rsi\n  mov    %rbp,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jle    1236 <func0+0xb6>\n  movdqa (%rsp),%xmm2\n  movups %xmm2,(%r15)\n  jmp    1279 <func0+0xf9>\n  movq   $0x0,0x28(%rsp)\n  jmp    1287 <func0+0x107>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  movl   $0x0,(%rdx)\n  mov    %rdi,0x10(%rsp)\n  mov    %rdx,0x20(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    0x8(%rdi),%rdx\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %ebp,%ebp\n  mov    %rdx,0x18(%rsp)\n  lea    (%rdx,%rax,8),%r12\n  nop\nL2:\n  mov    (%rbx),%r13\n  mov    %r13,%rdi\n  call   <strlen@plt>\n  test   $0x1,%al\n  jne    L1\n  mov    0x10(%rsp),%rdx\n  movslq %ebp,%rax\n  add    $0x1,%ebp\n  mov    %r13,(%rdx,%rax,8)\n  mov    0x20(%rsp),%rax\n  mov    %ebp,(%rax)\nL1:\n  add    $0x8,%rbx\n  cmp    %rbx,%r12\n  jne    L2\n  lea    -0x1(%rbp),%r13d\n  movslq %ebp,%rbp\n  lea    0x0(,%rbp,8),%rax\n  mov    %rax,0x28(%rsp)\n  test   %r13d,%r13d\n  jle    L3\n  nopl   0x0(%rax,%rax,1)\nL8:\n  mov    0x18(%rsp),%rcx\n  lea    -0x1(%r13),%eax\n  mov    0x10(%rsp),%r15\n  mov    %rax,%r13\n  lea    (%rcx,%rax,8),%r12\n  jmp    L4\n  nopw   0x0(%rax,%rax,1)\nL7:\n  je     L5\nL10:\n  add    $0x8,%r15\n  cmp    %r12,%r15\n  je     L6\nL4:\n  mov    (%r15),%rbp\n  mov    %rbp,%rdi\n  call   <strlen@plt>\n  mov    0x8(%r15),%r14\n  movq   %rbp,%xmm1\n  mov    %rax,%rbx\n  movq   %r14,%xmm0\n  mov    %r14,%rdi\n  punpcklqdq %xmm1,%xmm0\n  movaps %xmm0,(%rsp)\n  call   <strlen@plt>\n  cmp    %rax,%rbx\n  jbe    L7\n  movdqa (%rsp),%xmm2\n  movups %xmm2,(%r15)\nL11:\n  add    $0x8,%r15\n  cmp    %r12,%r15\n  jne    L4\nL6:\n  test   %r13d,%r13d\n  jne    L8\nL3:\n  mov    0x28(%rsp),%rdi\n  call   <malloc@plt>\n  mov    %rax,%r8\n  mov    0x20(%rsp),%rax\n  movslq (%rax),%rax\n  test   %eax,%eax\n  jle    L9\n  mov    0x10(%rsp),%rsi\n  mov    %r8,%rdi\n  lea    0x0(,%rax,8),%rdx\n  call   <memcpy@plt>\n  mov    %rax,%r8\nL9:\n  add    $0x38,%rsp\n  mov    %r8,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopw   0x0(%rax,%rax,1)\nL5:\n  mov    %r14,%rsi\n  mov    %rbp,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jle    L10\n  movdqa (%rsp),%xmm2\n  movups %xmm2,(%r15)\n  jmp    L11\nL0:\n  movq   $0x0,0x28(%rsp)\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4846
            },
            "L1": {
                "label": "L1",
                "addr": 4581
            },
            "L2": {
                "label": "L2",
                "addr": 4544
            },
            "L3": {
                "label": "L3",
                "addr": 4743
            },
            "L4": {
                "label": "L4",
                "addr": 4671
            },
            "L5": {
                "label": "L5",
                "addr": 4816
            },
            "L6": {
                "label": "L6",
                "addr": 4738
            },
            "L7": {
                "label": "L7",
                "addr": 4656
            },
            "L8": {
                "label": "L8",
                "addr": 4624
            },
            "L9": {
                "label": "L9",
                "addr": 4792
            },
            "L10": {
                "label": "L10",
                "addr": 4662
            },
            "L11": {
                "label": "L11",
                "addr": 4729
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 150,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %edx,-0x1c(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  cmpl   $0x1,-0x14(%rbp)\n  jg     111e <func0+0x25>\n  movl   $0x0,-0x8(%rbp)\n  movl   $0x2,-0x4(%rbp)\n  jmp    113f <func0+0x46>\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    113b <func0+0x42>\n  movl   $0x0,-0x8(%rbp)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    1127 <func0+0x2e>\n  cmpl   $0x0,-0x8(%rbp)\n  je     1155 <func0+0x5c>\n  mov    -0x18(%rbp),%eax\n  jmp    1158 <func0+0x5f>\n  mov    -0x1c(%rbp),%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %edx,-0x1c(%rbp)\n  movl   $0x1,-0x8(%rbp)\n  cmpl   $0x1,-0x14(%rbp)\n  jg     L0\n  movl   $0x0,-0x8(%rbp)\nL0:\n  movl   $0x2,-0x4(%rbp)\n  jmp    L1\nL3:\n  mov    -0x14(%rbp),%eax\n  cltd\n  idivl  -0x4(%rbp)\n  mov    %edx,%eax\n  test   %eax,%eax\n  jne    L2\n  movl   $0x0,-0x8(%rbp)\nL2:\n  addl   $0x1,-0x4(%rbp)\nL1:\n  mov    -0x4(%rbp),%eax\n  imul   %eax,%eax\n  cmp    %eax,-0x14(%rbp)\n  jge    L3\n  cmpl   $0x0,-0x8(%rbp)\n  je     L4\n  mov    -0x18(%rbp),%eax\n  jmp    L5\nL4:\n  mov    -0x1c(%rbp),%eax\nL5:\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4382
            },
            "L1": {
                "label": "L1",
                "addr": 4415
            },
            "L2": {
                "label": "L2",
                "addr": 4411
            },
            "L3": {
                "label": "L3",
                "addr": 4391
            },
            "L4": {
                "label": "L4",
                "addr": 4437
            },
            "L5": {
                "label": "L5",
                "addr": 4440
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 150,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edx,%r9d\n  cmp    $0x1,%edi\n  setg   %r8b\n  movzbl %r8b,%r8d\n  cmp    $0x3,%edi\n  jle    112c <func0+0x33>\n  mov    $0x2,%ecx\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %edx,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1115 <func0+0x1c>\n  test   %r8d,%r8d\n  cmovne %esi,%r9d\n  mov    %r9d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edx,%r9d\n  cmp    $0x1,%edi\n  setg   %r8b\n  movzbl %r8b,%r8d\n  cmp    $0x3,%edi\n  jle    L0\n  mov    $0x2,%ecx\nL1:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %edx,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L1\nL0:\n  test   %r8d,%r8d\n  cmovne %esi,%r9d\n  mov    %r9d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4396
            },
            "L1": {
                "label": "L1",
                "addr": 4373
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 150,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  cmp    $0x1,%edi\n  mov    %edx,%r10d\n  setg   %r8b\n  cmp    $0x3,%edi\n  jle    1137 <func0+0x37>\n  mov    $0x2,%ecx\n  xor    %r9d,%r9d\n  xchg   %ax,%ax\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %r9d,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    1120 <func0+0x20>\n  test   %r8d,%r8d\n  cmovne %esi,%r10d\n  mov    %r10d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  cmp    $0x1,%edi\n  mov    %edx,%r10d\n  setg   %r8b\n  cmp    $0x3,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  xor    %r9d,%r9d\n  xchg   %ax,%ax\nL1:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %r9d,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %edi,%eax\n  jle    L1\nL0:\n  test   %r8d,%r8d\n  cmovne %esi,%r10d\n  mov    %r10d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4407
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 150,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nint func0(int n, int x, int y) {\n    int isp = 1;\n    if (n < 2) isp = 0;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) isp = 0;\n    }\n    if (isp) return x;\n    return y;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(7, 34, 12) == 34);\n    assert(func0(15, 8, 5) == 5);\n    assert(func0(3, 33, 5212) == 33);\n    assert(func0(1259, 3, 52) == 3);\n    assert(func0(7919, -1, 12) == -1);\n    assert(func0(3609, 1245, 583) == 583);\n    assert(func0(91, 56, 129) == 129);\n    assert(func0(6, 34, 1234) == 1234);\n    assert(func0(1, 2, 0) == 0);\n    assert(func0(2, 2, 0) == 2);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  cmp    $0x1,%edi\n  mov    %edx,%r10d\n  setg   %r8b\n  cmp    $0x3,%edi\n  jle    1137 <func0+0x37>\n  mov    $0x2,%ecx\n  xor    %r9d,%r9d\n  xchg   %ax,%ax\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %r9d,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %eax,%edi\n  jge    1120 <func0+0x20>\n  test   %r8d,%r8d\n  cmovne %esi,%r10d\n  mov    %r10d,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  xor    %r8d,%r8d\n  cmp    $0x1,%edi\n  mov    %edx,%r10d\n  setg   %r8b\n  cmp    $0x3,%edi\n  jle    L0\n  mov    $0x2,%ecx\n  xor    %r9d,%r9d\n  xchg   %ax,%ax\nL1:\n  mov    %edi,%eax\n  cltd\n  idiv   %ecx\n  test   %edx,%edx\n  cmove  %r9d,%r8d\n  add    $0x1,%ecx\n  mov    %ecx,%eax\n  imul   %ecx,%eax\n  cmp    %eax,%edi\n  jge    L1\nL0:\n  test   %r8d,%r8d\n  cmovne %esi,%r10d\n  mov    %r10d,%eax\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4407
            },
            "L1": {
                "label": "L1",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 151,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movq   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    129b <func0+0x182>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  movsd  %xmm2,-0x38(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm3,%xmm3\n  cvtss2sd %xmm0,%xmm3\n  movq   %xmm3,%rax\n  movq   %rax,%xmm0\n  call   1050 <round@plt>\n  movapd %xmm0,%xmm1\n  movsd  -0x38(%rbp),%xmm0\n  subsd  %xmm1,%xmm0\n  movq   0xe56(%rip),%xmm1        # 2000 <_fini+0xd4c>\n  andpd  %xmm0,%xmm1\n  movsd  0xe5a(%rip),%xmm0        # 2010 <_fini+0xd5c>\n  comisd %xmm1,%xmm0\n  jbe    1297 <func0+0x17e>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    1297 <func0+0x17e>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm4,%xmm4\n  cvtss2sd %xmm0,%xmm4\n  movq   %xmm4,%rax\n  movq   %rax,%xmm0\n  call   1050 <round@plt>\n  cvttsd2si %xmm0,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    1297 <func0+0x17e>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm5,%xmm5\n  cvtss2sd %xmm0,%xmm5\n  movq   %xmm5,%rax\n  movq   %rax,%xmm0\n  call   1050 <round@plt>\n  cvttsd2si %xmm0,%ebx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm6,%xmm6\n  cvtss2sd %xmm0,%xmm6\n  movq   %xmm6,%rax\n  movq   %rax,%xmm0\n  call   1050 <round@plt>\n  cvttsd2si %xmm0,%eax\n  imul   %ebx,%eax\n  cltq\n  add    %rax,-0x18(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1141 <func0+0x28>\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %esi,-0x2c(%rbp)\n  movq   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL2:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  movsd  %xmm2,-0x38(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm3,%xmm3\n  cvtss2sd %xmm0,%xmm3\n  movq   %xmm3,%rax\n  movq   %rax,%xmm0\n  call   <round@plt>\n  movapd %xmm0,%xmm1\n  movsd  -0x38(%rbp),%xmm0\n  subsd  %xmm1,%xmm0\n  movq   D0(%rip),%xmm1\n  andpd  %xmm0,%xmm1\n  movsd  D1(%rip),%xmm0\n  comisd %xmm1,%xmm0\n  jbe    L1\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm1,%xmm1\n  comiss %xmm1,%xmm0\n  jbe    L1\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm4,%xmm4\n  cvtss2sd %xmm0,%xmm4\n  movq   %xmm4,%rax\n  movq   %rax,%xmm0\n  call   <round@plt>\n  cvttsd2si %xmm0,%eax\n  cltd\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  and    $0x1,%eax\n  sub    %edx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm5,%xmm5\n  cvtss2sd %xmm0,%xmm5\n  movq   %xmm5,%rax\n  movq   %rax,%xmm0\n  call   <round@plt>\n  cvttsd2si %xmm0,%ebx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movss  (%rax),%xmm0\n  pxor   %xmm6,%xmm6\n  cvtss2sd %xmm0,%xmm6\n  movq   %xmm6,%rax\n  movq   %rax,%xmm0\n  call   <round@plt>\n  cvttsd2si %xmm0,%eax\n  imul   %ebx,%eax\n  cltq\n  add    %rax,-0x18(%rbp)\nL1:\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L2\n  mov    -0x18(%rbp),%rax\n  mov    -0x8(%rbp),%rbx\n  leave\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3670
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3674
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4763
            },
            "L1": {
                "label": "L1",
                "addr": 4759
            },
            "L2": {
                "label": "L2",
                "addr": 4417
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffffffffffff7f00000000000000002d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "qword",
                    "value": 9223372036854775807
                },
                "0x2010": {
                    "type": "byte[8]",
                    "value": [
                        45,
                        67,
                        28,
                        235,
                        226,
                        54,
                        26,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 151,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    11b5 <func0+0x9c>\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rbp\n  mov    $0x0,%r12d\n  jmp    1149 <func0+0x30>\n  add    $0x4,%rbx\n  cmp    %rbp,%rbx\n  je     11bb <func0+0xa2>\n  movss  (%rbx),%xmm3\n  movss  %xmm3,0xc(%rsp)\n  movaps %xmm3,%xmm0\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm3\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm3,%xmm1\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  subsd  %xmm2,%xmm1\n  andpd  0xe83(%rip),%xmm1        # 2000 <_fini+0xe38>\n  movsd  0xe8b(%rip),%xmm4        # 2010 <_fini+0xe48>\n  comisd %xmm1,%xmm4\n  jbe    1140 <func0+0x27>\n  comiss 0xe76(%rip),%xmm3        # 2008 <_fini+0xe40>\n  jbe    1140 <func0+0x27>\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    1140 <func0+0x27>\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  jmp    1140 <func0+0x27>\n  mov    $0x0,%r12d\n  mov    %r12,%rax\n  add    $0x10,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%rbx\n  lea    -0x1(%rsi),%eax\n  lea    0x4(%rdi,%rax,4),%rbp\n  mov    $0x0,%r12d\n  jmp    L1\nL3:\n  add    $0x4,%rbx\n  cmp    %rbp,%rbx\n  je     L2\nL1:\n  movss  (%rbx),%xmm3\n  movss  %xmm3,0xc(%rsp)\n  movaps %xmm3,%xmm0\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm3\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm3,%xmm1\n  pxor   %xmm2,%xmm2\n  cvtss2sd %xmm0,%xmm2\n  subsd  %xmm2,%xmm1\n  andpd  D0(%rip),%xmm1\n  movsd  D1(%rip),%xmm4\n  comisd %xmm1,%xmm4\n  jbe    L3\n  comiss D2(%rip),%xmm3\n  jbe    L3\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    L3\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  jmp    L3\nL0:\n  mov    $0x0,%r12d\nL2:\n  mov    %r12,%rax\n  add    $0x10,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 2,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3715
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3723
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8200,
                "bias": [
                    3702
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4533
            },
            "L1": {
                "label": "L1",
                "addr": 4425
            },
            "L2": {
                "label": "L2",
                "addr": 4539
            },
            "L3": {
                "label": "L3",
                "addr": 4416
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffffffffffff7f00000000000000002d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "qword[2]",
                    "value": [
                        9223372036854775807,
                        0
                    ]
                },
                "0x2010": {
                    "type": "byte[8]",
                    "value": [
                        45,
                        67,
                        28,
                        235,
                        226,
                        54,
                        26,
                        63
                    ]
                },
                "0x2008": {
                    "type": "byte[4]",
                    "value": [
                        0,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 151,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    11d0 <func0+0xb0>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x4(%rdi,%rax,4),%rbp\n  nopw   0x0(%rax,%rax,1)\n  movss  (%rbx),%xmm2\n  movaps %xmm2,%xmm0\n  movss  %xmm2,0xc(%rsp)\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm2\n  pxor   %xmm1,%xmm1\n  pxor   %xmm3,%xmm3\n  movsd  0xea0(%rip),%xmm4        # 2010 <_fini+0xe30>\n  cvtss2sd %xmm0,%xmm3\n  cvtss2sd %xmm2,%xmm1\n  subsd  %xmm3,%xmm1\n  andpd  0xe7c(%rip),%xmm1        # 2000 <_fini+0xe20>\n  comisd %xmm1,%xmm4\n  jbe    11b8 <func0+0x98>\n  pxor   %xmm5,%xmm5\n  comiss %xmm5,%xmm2\n  jbe    11b8 <func0+0x98>\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    11b8 <func0+0x98>\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rbx\n  cmp    %rbx,%rbp\n  jne    1148 <func0+0x28>\n  add    $0x10,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   (%rax)\n  add    $0x10,%rsp\n  xor    %r12d,%r12d\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x4(%rdi,%rax,4),%rbp\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movss  (%rbx),%xmm2\n  movaps %xmm2,%xmm0\n  movss  %xmm2,0xc(%rsp)\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm2\n  pxor   %xmm1,%xmm1\n  pxor   %xmm3,%xmm3\n  movsd  D0(%rip),%xmm4\n  cvtss2sd %xmm0,%xmm3\n  cvtss2sd %xmm2,%xmm1\n  subsd  %xmm3,%xmm1\n  andpd  D1(%rip),%xmm1\n  comisd %xmm1,%xmm4\n  jbe    L1\n  pxor   %xmm5,%xmm5\n  comiss %xmm5,%xmm2\n  jbe    L1\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  nopw   0x0(%rax,%rax,1)\nL1:\n  add    $0x4,%rbx\n  cmp    %rbx,%rbp\n  jne    L2\n  add    $0x10,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   (%rax)\nL0:\n  add    $0x10,%rsp\n  xor    %r12d,%r12d\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8208,
                "bias": [
                    3744
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3708
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4560
            },
            "L1": {
                "label": "L1",
                "addr": 4536
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffffffffffff7f00000000000000002d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "qword[2]",
                    "value": [
                        9223372036854775807,
                        0
                    ]
                },
                "0x2010": {
                    "type": "byte[8]",
                    "value": [
                        45,
                        67,
                        28,
                        235,
                        226,
                        54,
                        26,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 151,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nlong long func0(float lst[], int lst_size) {\n    long long sum = 0;\n    for (int i = 0; i < lst_size; i++) {\n        if (fabs(lst[i] - round(lst[i])) < 1e-4) {\n            if (lst[i] > 0 && (int)(round(lst[i])) % 2 == 1) {\n                sum += (int)(round(lst[i])) * (int)(round(lst[i]));\n            }\n        }\n    }\n    return sum;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0((const float[]){}, 0) == 0);\n    assert(func0((const float[]){5, 4}, 2) == 25);\n    assert(func0((const float[]){0.1, 0.2, 0.3}, 3) == 0);\n    assert(func0((const float[]){-10, -20, -30}, 3) == 0);\n    assert(func0((const float[]){-1, -2, 8}, 3) == 0);\n    assert(func0((const float[]){0.2, 3, 5}, 3) == 34);\n    \n    long long odd_sum = 0;\n    float lst[200];\n    int lst_size = 0;\n\n    for (int i = -99; i < 100; i += 2) {\n        lst[lst_size++] = i + 0.0f;\n        if (i > 0 && i % 2 == 1) odd_sum += i * i;\n    }\n\n    assert(func0(lst, lst_size) == odd_sum);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    11d0 <func0+0xb0>\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x4(%rdi,%rax,4),%rbp\n  nopw   0x0(%rax,%rax,1)\n  movss  (%rbx),%xmm2\n  movaps %xmm2,%xmm0\n  movss  %xmm2,0xc(%rsp)\n  call   1050 <roundf@plt>\n  movss  0xc(%rsp),%xmm2\n  pxor   %xmm1,%xmm1\n  pxor   %xmm3,%xmm3\n  movsd  0xea0(%rip),%xmm4        # 2010 <_fini+0xe30>\n  cvtss2sd %xmm0,%xmm3\n  cvtss2sd %xmm2,%xmm1\n  subsd  %xmm3,%xmm1\n  andpd  0xe7c(%rip),%xmm1        # 2000 <_fini+0xe20>\n  comisd %xmm1,%xmm4\n  jbe    11b8 <func0+0x98>\n  pxor   %xmm5,%xmm5\n  comiss %xmm5,%xmm2\n  jbe    11b8 <func0+0x98>\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    11b8 <func0+0x98>\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  nopw   0x0(%rax,%rax,1)\n  add    $0x4,%rbx\n  cmp    %rbx,%rbp\n  jne    1148 <func0+0x28>\n  add    $0x10,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   (%rax)\n  add    $0x10,%rsp\n  xor    %r12d,%r12d\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x10,%rsp\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  mov    %rdi,%rbx\n  xor    %r12d,%r12d\n  lea    0x4(%rdi,%rax,4),%rbp\n  nopw   0x0(%rax,%rax,1)\nL2:\n  movss  (%rbx),%xmm2\n  movaps %xmm2,%xmm0\n  movss  %xmm2,0xc(%rsp)\n  call   <roundf@plt>\n  movss  0xc(%rsp),%xmm2\n  pxor   %xmm1,%xmm1\n  pxor   %xmm3,%xmm3\n  movsd  D0(%rip),%xmm4\n  cvtss2sd %xmm0,%xmm3\n  cvtss2sd %xmm2,%xmm1\n  subsd  %xmm3,%xmm1\n  andpd  D1(%rip),%xmm1\n  comisd %xmm1,%xmm4\n  jbe    L1\n  pxor   %xmm5,%xmm5\n  comiss %xmm5,%xmm2\n  jbe    L1\n  cvttss2si %xmm0,%edx\n  mov    %edx,%ecx\n  shr    $0x1f,%ecx\n  lea    (%rdx,%rcx,1),%eax\n  and    $0x1,%eax\n  sub    %ecx,%eax\n  cmp    $0x1,%eax\n  jne    L1\n  imul   %edx,%edx\n  movslq %edx,%rdx\n  add    %rdx,%r12\n  nopw   0x0(%rax,%rax,1)\nL1:\n  add    $0x4,%rbx\n  cmp    %rbx,%rbp\n  jne    L2\n  add    $0x10,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret\n  nopl   (%rax)\nL0:\n  add    $0x10,%rsp\n  xor    %r12d,%r12d\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8208,
                "bias": [
                    3744
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3708
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4560
            },
            "L1": {
                "label": "L1",
                "addr": 4536
            },
            "L2": {
                "label": "L2",
                "addr": 4424
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffffffffffff7f00000000000000002d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "qword[2]",
                    "value": [
                        9223372036854775807,
                        0
                    ]
                },
                "0x2010": {
                    "type": "byte[8]",
                    "value": [
                        45,
                        67,
                        28,
                        235,
                        226,
                        54,
                        26,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 152,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x2c(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    116a <func0+0x71>\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edx\n  sub    %edx,%eax\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     1119 <func0+0x20>\n  nop\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %rdi,-0x18(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  mov    %rdx,-0x28(%rbp)\n  mov    %ecx,-0x2c(%rbp)\n  movl   $0x0,-0x4(%rbp)\n  jmp    L0\nL1:\n  mov    -0x4(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x18(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x20(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edx\n  sub    %edx,%eax\n  mov    -0x4(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    %eax,%ecx\n  neg    %ecx\n  cmovns %ecx,%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x4(%rbp)\nL0:\n  mov    -0x4(%rbp),%eax\n  cmp    -0x2c(%rbp),%eax\n  jl     L1\n  nop\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4458
            },
            "L1": {
                "label": "L1",
                "addr": 4377
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 152,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  test   %ecx,%ecx\n  jle    1128 <func0+0x2f>\n  mov    %ecx,%ecx\n  mov    $0x0,%eax\n  mov    (%r9,%rax,4),%edi\n  sub    (%rsi,%rax,4),%edi\n  mov    %edi,%r8d\n  neg    %r8d\n  cmovns %r8d,%edi\n  mov    %edi,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    110b <func0+0x12>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  test   %ecx,%ecx\n  jle    L0\n  mov    %ecx,%ecx\n  mov    $0x0,%eax\nL1:\n  mov    (%r9,%rax,4),%edi\n  sub    (%rsi,%rax,4),%edi\n  mov    %edi,%r8d\n  neg    %r8d\n  cmovns %r8d,%edi\n  mov    %edi,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    L1\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4392
            },
            "L1": {
                "label": "L1",
                "addr": 4363
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 152,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  test   %ecx,%ecx\n  jle    112d <func0+0x2d>\n  movslq %ecx,%rcx\n  xor    %eax,%eax\n  mov    (%r9,%rax,4),%edi\n  sub    (%rsi,%rax,4),%edi\n  mov    %edi,%r8d\n  neg    %r8d\n  cmovns %r8d,%edi\n  mov    %edi,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  jne    1110 <func0+0x10>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %rdi,%r9\n  test   %ecx,%ecx\n  jle    L0\n  movslq %ecx,%rcx\n  xor    %eax,%eax\nL1:\n  mov    (%r9,%rax,4),%edi\n  sub    (%rsi,%rax,4),%edi\n  mov    %edi,%r8d\n  neg    %r8d\n  cmovns %r8d,%edi\n  mov    %edi,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rax,%rcx\n  jne    L1\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4397
            },
            "L1": {
                "label": "L1",
                "addr": 4368
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 152,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int* game, int* guess, int* out, int length) {\n    for (int i = 0; i < length; i++) {\n        out[i] = abs(game[i] - guess[i]);\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(int* a, int* b, int length) {\n    for (int i = 0; i < length; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[6];\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,5,0,0,0,4}, (const int[]){4,1,1,0,0,-2}, result, 6);\n    assert(issame(result, (const int[]){4,4,1,0,0,6}, 6));\n\n    func0((const int[]){1,2,3,4,5,1}, (const int[]){1,2,3,4,2,-2}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,3,3}, 6));\n\n    func0((const int[]){0,0,0,0,0,0}, (const int[]){0,0,0,0,0,0}, result, 6);\n    assert(issame(result, (const int[]){0,0,0,0,0,0}, 6));\n\n    func0((const int[]){1,2,3}, (const int[]){-1,-2,-3}, result, 3);\n    assert(issame(result, (const int[]){2,4,6}, 3));\n\n    func0((const int[]){1,2,3,5}, (const int[]){-1,2,3,4}, result, 4);\n    assert(issame(result, (const int[]){2,0,0,1}, 4));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  test   %ecx,%ecx\n  jle    121f <func0+0x11f>\n  lea    0x4(%rdi),%r8\n  mov    %rdx,%rax\n  sub    %r8,%rax\n  cmp    $0x8,%rax\n  lea    -0x1(%rcx),%eax\n  seta   %r8b\n  cmp    $0x2,%eax\n  seta   %al\n  test   %al,%r8b\n  je     11f8 <func0+0xf8>\n  lea    0x4(%rsi),%r8\n  mov    %rdx,%rax\n  sub    %r8,%rax\n  cmp    $0x8,%rax\n  jbe    11f8 <func0+0xf8>\n  mov    %ecx,%r8d\n  xor    %eax,%eax\n  shr    $0x2,%r8d\n  shl    $0x4,%r8\n  nopl   0x0(%rax)\n  movdqu (%rdi,%rax,1),%xmm0\n  movdqu (%rsi,%rax,1),%xmm2\n  psubd  %xmm2,%xmm0\n  movdqa %xmm0,%xmm1\n  psrad  $0x1f,%xmm1\n  pxor   %xmm1,%xmm0\n  psubd  %xmm1,%xmm0\n  movups %xmm0,(%rdx,%rax,1)\n  add    $0x10,%rax\n  cmp    %r8,%rax\n  jne    1158 <func0+0x58>\n  mov    %ecx,%r8d\n  and    $0xfffffffc,%r8d\n  test   $0x3,%cl\n  je     121f <func0+0x11f>\n  mov    %r8d,%r10d\n  mov    (%rdi,%r10,4),%r9d\n  sub    (%rsi,%r10,4),%r9d\n  lea    0x0(,%r10,4),%rax\n  mov    %r9d,%r11d\n  neg    %r11d\n  cmovns %r11d,%r9d\n  mov    %r9d,(%rdx,%r10,4)\n  lea    0x1(%r8),%r9d\n  cmp    %r9d,%ecx\n  jle    121f <func0+0x11f>\n  mov    0x4(%rdi,%rax,1),%r9d\n  sub    0x4(%rsi,%rax,1),%r9d\n  mov    %r9d,%r10d\n  neg    %r10d\n  cmovns %r10d,%r9d\n  add    $0x2,%r8d\n  mov    %r9d,0x4(%rdx,%rax,1)\n  cmp    %r8d,%ecx\n  jle    121f <func0+0x11f>\n  mov    0x8(%rdi,%rax,1),%ecx\n  sub    0x8(%rsi,%rax,1),%ecx\n  mov    %ecx,%esi\n  neg    %esi\n  cmovns %esi,%ecx\n  mov    %ecx,0x8(%rdx,%rax,1)\n  ret\n  nopl   0x0(%rax)\n  mov    %ecx,%ecx\n  xor    %eax,%eax\n  nopl   0x0(%rax)\n  mov    (%rdi,%rax,4),%r8d\n  sub    (%rsi,%rax,4),%r8d\n  mov    %r8d,%r9d\n  neg    %r9d\n  cmovns %r9d,%r8d\n  mov    %r8d,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    1200 <func0+0x100>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  test   %ecx,%ecx\n  jle    L0\n  lea    0x4(%rdi),%r8\n  mov    %rdx,%rax\n  sub    %r8,%rax\n  cmp    $0x8,%rax\n  lea    -0x1(%rcx),%eax\n  seta   %r8b\n  cmp    $0x2,%eax\n  seta   %al\n  test   %al,%r8b\n  je     L1\n  lea    0x4(%rsi),%r8\n  mov    %rdx,%rax\n  sub    %r8,%rax\n  cmp    $0x8,%rax\n  jbe    L1\n  mov    %ecx,%r8d\n  xor    %eax,%eax\n  shr    $0x2,%r8d\n  shl    $0x4,%r8\n  nopl   0x0(%rax)\nL2:\n  movdqu (%rdi,%rax,1),%xmm0\n  movdqu (%rsi,%rax,1),%xmm2\n  psubd  %xmm2,%xmm0\n  movdqa %xmm0,%xmm1\n  psrad  $0x1f,%xmm1\n  pxor   %xmm1,%xmm0\n  psubd  %xmm1,%xmm0\n  movups %xmm0,(%rdx,%rax,1)\n  add    $0x10,%rax\n  cmp    %r8,%rax\n  jne    L2\n  mov    %ecx,%r8d\n  and    $0xfffffffc,%r8d\n  test   $0x3,%cl\n  je     L0\n  mov    %r8d,%r10d\n  mov    (%rdi,%r10,4),%r9d\n  sub    (%rsi,%r10,4),%r9d\n  lea    0x0(,%r10,4),%rax\n  mov    %r9d,%r11d\n  neg    %r11d\n  cmovns %r11d,%r9d\n  mov    %r9d,(%rdx,%r10,4)\n  lea    0x1(%r8),%r9d\n  cmp    %r9d,%ecx\n  jle    L0\n  mov    0x4(%rdi,%rax,1),%r9d\n  sub    0x4(%rsi,%rax,1),%r9d\n  mov    %r9d,%r10d\n  neg    %r10d\n  cmovns %r10d,%r9d\n  add    $0x2,%r8d\n  mov    %r9d,0x4(%rdx,%rax,1)\n  cmp    %r8d,%ecx\n  jle    L0\n  mov    0x8(%rdi,%rax,1),%ecx\n  sub    0x8(%rsi,%rax,1),%ecx\n  mov    %ecx,%esi\n  neg    %esi\n  cmovns %esi,%ecx\n  mov    %ecx,0x8(%rdx,%rax,1)\n  ret\n  nopl   0x0(%rax)\nL1:\n  mov    %ecx,%ecx\n  xor    %eax,%eax\n  nopl   0x0(%rax)\nL3:\n  mov    (%rdi,%rax,4),%r8d\n  sub    (%rsi,%rax,4),%r8d\n  mov    %r8d,%r9d\n  neg    %r9d\n  cmovns %r9d,%r8d\n  mov    %r8d,(%rdx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    L3\nL0:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4639
            },
            "L1": {
                "label": "L1",
                "addr": 4600
            },
            "L2": {
                "label": "L2",
                "addr": 4440
            },
            "L3": {
                "label": "L3",
                "addr": 4608
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 153,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %edx,-0x44(%rbp)\n  mov    %rcx,-0x50(%rbp)\n  movl   $0xfffffc18,-0x20(%rbp)\n  movq   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    11df <func0+0xc6>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x40(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    11b1 <func0+0x98>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x21(%rbp)\n  cmpb   $0x40,-0x21(%rbp)\n  jle    119d <func0+0x84>\n  cmpb   $0x5a,-0x21(%rbp)\n  jg     119d <func0+0x84>\n  addl   $0x1,-0x18(%rbp)\n  cmpb   $0x60,-0x21(%rbp)\n  jle    11ad <func0+0x94>\n  cmpb   $0x7a,-0x21(%rbp)\n  jg     11ad <func0+0x94>\n  subl   $0x1,-0x18(%rbp)\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    117a <func0+0x61>\n  mov    -0x18(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jle    11db <func0+0xc2>\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x20(%rbp)\n  mov    -0x8(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     114f <func0+0x36>\n  mov    -0x10(%rbp),%rcx\n  mov    -0x38(%rbp),%rdx\n  mov    -0x50(%rbp),%rax\n  lea    0xe02(%rip),%rsi        # 2000 <_fini+0xdf0>\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1050 <sprintf@plt>\n  nop\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %edx,-0x44(%rbp)\n  mov    %rcx,-0x50(%rbp)\n  movl   $0xfffffc18,-0x20(%rbp)\n  movq   $0x0,-0x10(%rbp)\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L0\nL6:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x40(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L1\nL4:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x21(%rbp)\n  cmpb   $0x40,-0x21(%rbp)\n  jle    L2\n  cmpb   $0x5a,-0x21(%rbp)\n  jg     L2\n  addl   $0x1,-0x18(%rbp)\nL2:\n  cmpb   $0x60,-0x21(%rbp)\n  jle    L3\n  cmpb   $0x7a,-0x21(%rbp)\n  jg     L3\n  subl   $0x1,-0x18(%rbp)\nL3:\n  addl   $0x1,-0x14(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L4\n  mov    -0x18(%rbp),%eax\n  cmp    -0x20(%rbp),%eax\n  jle    L5\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x20(%rbp)\n  mov    -0x8(%rbp),%rax\n  mov    %rax,-0x10(%rbp)\nL5:\n  addl   $0x1,-0x1c(%rbp)\nL0:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     L6\n  mov    -0x10(%rbp),%rcx\n  mov    -0x38(%rbp),%rdx\n  mov    -0x50(%rbp),%rax\n  lea    D0(%rip),%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\n  nop\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3586
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4575
            },
            "L1": {
                "label": "L1",
                "addr": 4529
            },
            "L2": {
                "label": "L2",
                "addr": 4509
            },
            "L3": {
                "label": "L3",
                "addr": 4525
            },
            "L4": {
                "label": "L4",
                "addr": 4474
            },
            "L5": {
                "label": "L5",
                "addr": 4571
            },
            "L6": {
                "label": "L6",
                "addr": 4431
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "25732e257300",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%s.%s\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 153,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r8\n  mov    %rcx,%rbp\n  test   %edx,%edx\n  jle    1197 <func0+0x7e>\n  mov    %rsi,%rdi\n  lea    -0x1(%rdx),%eax\n  lea    0x8(%rsi,%rax,8),%rbx\n  mov    $0x0,%r9d\n  mov    $0xfffffc18,%r11d\n  jmp    1181 <func0+0x68>\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%eax\n  test   %al,%al\n  je     116d <func0+0x54>\n  lea    -0x41(%rax),%esi\n  cmp    $0x19,%sil\n  ja     1146 <func0+0x2d>\n  add    $0x1,%ecx\n  jmp    114e <func0+0x35>\n  mov    $0x0,%ecx\n  cmp    %ecx,%r11d\n  jge    1178 <func0+0x5f>\n  mov    %r10,%r9\n  mov    %ecx,%r11d\n  add    $0x8,%rdi\n  cmp    %rbx,%rdi\n  je     119d <func0+0x84>\n  mov    (%rdi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     1168 <func0+0x4f>\n  lea    0x1(%r10),%rdx\n  mov    $0x0,%ecx\n  jmp    115a <func0+0x41>\n  mov    $0x0,%r9d\n  lea    0xe5c(%rip),%rcx        # 2000 <_fini+0xe3c>\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  mov    %rbp,%rdi\n  mov    $0x0,%eax\n  call   1050 <__sprintf_chk@plt>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r8\n  mov    %rcx,%rbp\n  test   %edx,%edx\n  jle    L0\n  mov    %rsi,%rdi\n  lea    -0x1(%rdx),%eax\n  lea    0x8(%rsi,%rax,8),%rbx\n  mov    $0x0,%r9d\n  mov    $0xfffffc18,%r11d\n  jmp    L1\nL3:\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\nL4:\n  add    $0x1,%rdx\n  movzbl -0x1(%rdx),%eax\n  test   %al,%al\n  je     L2\nL8:\n  lea    -0x41(%rax),%esi\n  cmp    $0x19,%sil\n  ja     L3\n  add    $0x1,%ecx\n  jmp    L4\nL7:\n  mov    $0x0,%ecx\nL2:\n  cmp    %ecx,%r11d\n  jge    L5\n  mov    %r10,%r9\n  mov    %ecx,%r11d\nL5:\n  add    $0x8,%rdi\n  cmp    %rbx,%rdi\n  je     L6\nL1:\n  mov    (%rdi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     L7\n  lea    0x1(%r10),%rdx\n  mov    $0x0,%ecx\n  jmp    L8\nL0:\n  mov    $0x0,%r9d\nL6:\n  lea    D0(%rip),%rcx\n  mov    $0xffffffffffffffff,%rdx\n  mov    $0x1,%esi\n  mov    %rbp,%rdi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3676
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4503
            },
            "L1": {
                "label": "L1",
                "addr": 4481
            },
            "L2": {
                "label": "L2",
                "addr": 4461
            },
            "L3": {
                "label": "L3",
                "addr": 4422
            },
            "L4": {
                "label": "L4",
                "addr": 4430
            },
            "L5": {
                "label": "L5",
                "addr": 4472
            },
            "L6": {
                "label": "L6",
                "addr": 4509
            },
            "L7": {
                "label": "L7",
                "addr": 4456
            },
            "L8": {
                "label": "L8",
                "addr": 4442
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "25732e257300",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%s.%s\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 153,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%r8\n  mov    %rcx,%r11\n  push   %rbx\n  test   %edx,%edx\n  jle    11c4 <func0+0xa4>\n  lea    -0x1(%rdx),%eax\n  xor    %r9d,%r9d\n  mov    $0xfffffc18,%ebx\n  lea    0x8(%rsi,%rax,8),%rbp\n  nopl   0x0(%rax)\n  mov    (%rsi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     11c0 <func0+0xa0>\n  lea    0x1(%r10),%rdx\n  xor    %ecx,%ecx\n  jmp    116e <func0+0x4e>\n  nopl   0x0(%rax,%rax,1)\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  add    $0x1,%ecx\n  test   %al,%al\n  je     118a <func0+0x6a>\n  lea    -0x41(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    1160 <func0+0x40>\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    116e <func0+0x4e>\n  cmp    %ecx,%ebx\n  jge    1193 <func0+0x73>\n  mov    %r10,%r9\n  mov    %ecx,%ebx\n  add    $0x8,%rsi\n  cmp    %rbp,%rsi\n  jne    1148 <func0+0x28>\n  pop    %rbx\n  lea    0xe5c(%rip),%rcx        # 2000 <_fini+0xe34>\n  mov    $0xffffffffffffffff,%rdx\n  pop    %rbp\n  mov    $0x1,%esi\n  mov    %r11,%rdi\n  xor    %eax,%eax\n  jmp    1050 <__sprintf_chk@plt>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ecx,%ecx\n  jmp    118a <func0+0x6a>\n  xor    %r9d,%r9d\n  jmp    119c <func0+0x7c>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%r8\n  mov    %rcx,%r11\n  push   %rbx\n  test   %edx,%edx\n  jle    L0\n  lea    -0x1(%rdx),%eax\n  xor    %r9d,%r9d\n  mov    $0xfffffc18,%ebx\n  lea    0x8(%rsi,%rax,8),%rbp\n  nopl   0x0(%rax)\nL6:\n  mov    (%rsi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     L1\n  lea    0x1(%r10),%rdx\n  xor    %ecx,%ecx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  add    $0x1,%ecx\n  test   %al,%al\n  je     L3\nL2:\n  lea    -0x41(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    L4\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    L2\nL3:\n  cmp    %ecx,%ebx\n  jge    L5\n  mov    %r10,%r9\n  mov    %ecx,%ebx\nL5:\n  add    $0x8,%rsi\n  cmp    %rbp,%rsi\n  jne    L6\nL7:\n  pop    %rbx\n  lea    D0(%rip),%rcx\n  mov    $0xffffffffffffffff,%rdx\n  pop    %rbp\n  mov    $0x1,%esi\n  mov    %r11,%rdi\n  xor    %eax,%eax\n  jmp    1050 <__sprintf_chk@plt>\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %ecx,%ecx\n  jmp    L3\nL0:\n  xor    %r9d,%r9d\n  jmp    L7",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3676
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4548
            },
            "L1": {
                "label": "L1",
                "addr": 4544
            },
            "L2": {
                "label": "L2",
                "addr": 4462
            },
            "L3": {
                "label": "L3",
                "addr": 4490
            },
            "L4": {
                "label": "L4",
                "addr": 4448
            },
            "L5": {
                "label": "L5",
                "addr": 4499
            },
            "L6": {
                "label": "L6",
                "addr": 4424
            },
            "L7": {
                "label": "L7",
                "addr": 4508
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "25732e257300",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%s.%s\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 153,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(const char* class_name, const char** extensions, int ext_count, char* output) {\n    int max_strength = -1000;\n    const char* strongest = NULL;\n    for (int i = 0; i < ext_count; i++) {\n        const char* extension = extensions[i];\n        int strength = 0;\n        for (int j = 0; extension[j] != '\\0'; j++) {\n            char chr = extension[j];\n            if (chr >= 'A' && chr <= 'Z') strength++;\n            if (chr >= 'a' && chr <= 'z') strength--;\n        }\n        if (strength > max_strength) {\n            max_strength = strength;\n            strongest = extension;\n        }\n    }\n    sprintf(output, \"%s.%s\", class_name, strongest);\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[50];\n\n    const char* tmp1[] = {\"tEN\", \"niNE\", \"eIGHt8OKe\"};\n    func0(\"Watashi\", tmp1, 3, result);\n    assert(strcmp(result, \"Watashi.eIGHt8OKe\") == 0);\n\n    const char* tmp2[] = {\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"};\n    func0(\"Boku123\", tmp2, 4, result);\n    assert(strcmp(result, \"Boku123.YEs.WeCaNe\") == 0);\n\n    const char* tmp3[] = {\"t\", \"eMptY\", \"(nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"};\n    func0(\"__YESIMHERE\", tmp3, 6, result);\n    assert(strcmp(result, \"__YESIMHERE.NuLl__\") == 0);\n\n    const char* tmp4[] = {\"Ta\", \"TAR\", \"t234An\", \"cosSo\"};\n    func0(\"K\", tmp4, 4, result);\n    assert(strcmp(result, \"K.TAR\") == 0);\n\n    const char* tmp5[] = {\"Tab\", \"123\", \"781345\", \"-_-\"};\n    func0(\"__HAHA\", tmp5, 4, result);\n    assert(strcmp(result, \"__HAHA.123\") == 0);\n\n    const char* tmp[] = {\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"};\n    func0(\"YameRore\", tmp, 5, result);\n    assert(strcmp(result, \"YameRore.okIWILL123\") == 0);\n\n    const char* tmp6[] = {\"Die\", \"NowW\", \"Wow\", \"WoW\"};\n    func0(\"finNNalLLly\", tmp6, 4, result);\n    assert(strcmp(result, \"finNNalLLly.WoW\") == 0);\n\n    const char* tmp7[] = {\"Bb\", \"91245\"};\n    func0(\"_\", tmp7, 2, result);\n    assert(strcmp(result, \"_.Bb\") == 0);\n\n    const char* tmp8[] = {\"671235\", \"Bb\"};\n    func0(\"Sp\", tmp8, 2, result);\n    assert(strcmp(result, \"Sp.671235\") == 0);\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%r8\n  mov    %rcx,%r11\n  push   %rbx\n  test   %edx,%edx\n  jle    11c4 <func0+0xa4>\n  lea    -0x1(%rdx),%eax\n  xor    %r9d,%r9d\n  mov    $0xfffffc18,%ebx\n  lea    0x8(%rsi,%rax,8),%rbp\n  nopl   0x0(%rax)\n  mov    (%rsi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     11c0 <func0+0xa0>\n  lea    0x1(%r10),%rdx\n  xor    %ecx,%ecx\n  jmp    116e <func0+0x4e>\n  nopl   0x0(%rax,%rax,1)\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  add    $0x1,%ecx\n  test   %al,%al\n  je     118a <func0+0x6a>\n  lea    -0x41(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    1160 <func0+0x40>\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    116e <func0+0x4e>\n  cmp    %ecx,%ebx\n  jge    1193 <func0+0x73>\n  mov    %r10,%r9\n  mov    %ecx,%ebx\n  add    $0x8,%rsi\n  cmp    %rbp,%rsi\n  jne    1148 <func0+0x28>\n  pop    %rbx\n  lea    0xe5c(%rip),%rcx        # 2000 <_fini+0xe34>\n  mov    $0xffffffffffffffff,%rdx\n  pop    %rbp\n  mov    $0x1,%esi\n  mov    %r11,%rdi\n  xor    %eax,%eax\n  jmp    1050 <__sprintf_chk@plt>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ecx,%ecx\n  jmp    118a <func0+0x6a>\n  xor    %r9d,%r9d\n  jmp    119c <func0+0x7c>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rdi,%r8\n  mov    %rcx,%r11\n  push   %rbx\n  test   %edx,%edx\n  jle    L0\n  lea    -0x1(%rdx),%eax\n  xor    %r9d,%r9d\n  mov    $0xfffffc18,%ebx\n  lea    0x8(%rsi,%rax,8),%rbp\n  nopl   0x0(%rax)\nL6:\n  mov    (%rsi),%r10\n  movzbl (%r10),%eax\n  test   %al,%al\n  je     L1\n  lea    0x1(%r10),%rdx\n  xor    %ecx,%ecx\n  jmp    L2\n  nopl   0x0(%rax,%rax,1)\nL4:\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  add    $0x1,%ecx\n  test   %al,%al\n  je     L3\nL2:\n  lea    -0x41(%rax),%edi\n  cmp    $0x19,%dil\n  jbe    L4\n  sub    $0x61,%eax\n  cmp    $0x1a,%al\n  sbb    $0x0,%ecx\n  movzbl (%rdx),%eax\n  add    $0x1,%rdx\n  test   %al,%al\n  jne    L2\nL3:\n  cmp    %ecx,%ebx\n  jge    L5\n  mov    %r10,%r9\n  mov    %ecx,%ebx\nL5:\n  add    $0x8,%rsi\n  cmp    %rbp,%rsi\n  jne    L6\nL7:\n  pop    %rbx\n  lea    D0(%rip),%rcx\n  mov    $0xffffffffffffffff,%rdx\n  pop    %rbp\n  mov    $0x1,%esi\n  mov    %r11,%rdi\n  xor    %eax,%eax\n  jmp    1050 <__sprintf_chk@plt>\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %ecx,%ecx\n  jmp    L3\nL0:\n  xor    %r9d,%r9d\n  jmp    L7",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3676
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4548
            },
            "L1": {
                "label": "L1",
                "addr": 4544
            },
            "L2": {
                "label": "L2",
                "addr": 4462
            },
            "L3": {
                "label": "L3",
                "addr": 4490
            },
            "L4": {
                "label": "L4",
                "addr": 4448
            },
            "L5": {
                "label": "L5",
                "addr": 4499
            },
            "L6": {
                "label": "L6",
                "addr": 4424
            },
            "L7": {
                "label": "L7",
                "addr": 4508
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "25732e257300",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"%s.%s\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 154,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,-0x10(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   10b0 <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    127f <func0+0xe6>\n  mov    -0xc(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   10a0 <strncpy@plt>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xc(%rbp),%eax\n  cltq\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  sub    %rcx,%rax\n  mov    %rax,%rsi\n  mov    -0x8(%rbp),%rax\n  lea    (%rsi,%rax,1),%rcx\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   10a0 <strncpy@plt>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10d0 <strstr@plt>\n  test   %rax,%rax\n  je     127b <func0+0xe2>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    $0x1,%eax\n  jmp    129c <func0+0x103>\n  addl   $0x1,-0x14(%rbp)\n  mov    -0x14(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     11ed <func0+0x54>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <free@plt>\n  mov    $0x0,%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    %rsi,-0x30(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x10(%rbp)\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  add    %eax,%eax\n  add    $0x1,%eax\n  cltq\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x14(%rbp)\n  jmp    L0\nL3:\n  mov    -0xc(%rbp),%eax\n  sub    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x30(%rbp),%rax\n  add    %rax,%rcx\n  mov    -0x8(%rbp),%rax\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  call   <strncpy@plt>\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0xc(%rbp),%eax\n  cltq\n  mov    -0x14(%rbp),%ecx\n  movslq %ecx,%rcx\n  sub    %rcx,%rax\n  mov    %rax,%rsi\n  mov    -0x8(%rbp),%rax\n  lea    (%rsi,%rax,1),%rcx\n  mov    -0x30(%rbp),%rax\n  mov    %rax,%rsi\n  mov    %rcx,%rdi\n  call   <strncpy@plt>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  movb   $0x0,(%rax)\n  mov    -0x8(%rbp),%rdx\n  mov    -0x28(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L1\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    $0x1,%eax\n  jmp    L2\nL1:\n  addl   $0x1,-0x14(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jl     L3\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    $0x0,%eax\nL2:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4735
            },
            "L1": {
                "label": "L1",
                "addr": 4731
            },
            "L2": {
                "label": "L2",
                "addr": 4764
            },
            "L3": {
                "label": "L3",
                "addr": 4589
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 154,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %rsi,%r13\n  mov    %rsi,%rdi\n  call   10b0 <strlen@plt>\n  mov    %rax,%rbx\n  mov    %eax,%r12d\n  lea    0x1(%rax,%rax,1),%edi\n  movslq %edi,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jle    1228 <func0+0x8f>\n  lea    -0x1(%rbx),%r15d\n  mov    $0x0,%ebx\n  movslq %r12d,%r12\n  jmp    11e3 <func0+0x4a>\n  mov    %rax,%rbx\n  mov    %r12,%rdx\n  sub    %rbx,%rdx\n  lea    0x0(%r13,%rbx,1),%rsi\n  mov    %rbp,%rdi\n  call   10a0 <strncpy@plt>\n  lea    0x0(%rbp,%r12,1),%rdi\n  sub    %rbx,%rdi\n  mov    %rbx,%rdx\n  mov    %r13,%rsi\n  call   10a0 <strncpy@plt>\n  movb   $0x0,0x0(%rbp,%r12,1)\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   10d0 <strstr@plt>\n  test   %rax,%rax\n  jne    1244 <func0+0xab>\n  lea    0x1(%rbx),%rax\n  cmp    %r15,%rbx\n  jne    11e0 <func0+0x47>\n  mov    %rbp,%rdi\n  call   1090 <free@plt>\n  mov    $0x0,%eax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    %rbp,%rdi\n  call   1090 <free@plt>\n  mov    $0x1,%eax\n  jmp    1235 <func0+0x9c>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  mov    %rdi,%r14\n  mov    %rsi,%r13\n  mov    %rsi,%rdi\n  call   <strlen@plt>\n  mov    %rax,%rbx\n  mov    %eax,%r12d\n  lea    0x1(%rax,%rax,1),%edi\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %ebx,%ebx\n  jle    L0\n  lea    -0x1(%rbx),%r15d\n  mov    $0x0,%ebx\n  movslq %r12d,%r12\n  jmp    L1\nL3:\n  mov    %rax,%rbx\nL1:\n  mov    %r12,%rdx\n  sub    %rbx,%rdx\n  lea    0x0(%r13,%rbx,1),%rsi\n  mov    %rbp,%rdi\n  call   <strncpy@plt>\n  lea    0x0(%rbp,%r12,1),%rdi\n  sub    %rbx,%rdi\n  mov    %rbx,%rdx\n  mov    %r13,%rsi\n  call   <strncpy@plt>\n  movb   $0x0,0x0(%rbp,%r12,1)\n  mov    %rbp,%rsi\n  mov    %r14,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  jne    L2\n  lea    0x1(%rbx),%rax\n  cmp    %r15,%rbx\n  jne    L3\nL0:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    $0x0,%eax\nL4:\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL2:\n  mov    %rbp,%rdi\n  call   <free@plt>\n  mov    $0x1,%eax\n  jmp    L4",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4648
            },
            "L1": {
                "label": "L1",
                "addr": 4579
            },
            "L2": {
                "label": "L2",
                "addr": 4676
            },
            "L3": {
                "label": "L3",
                "addr": 4576
            },
            "L4": {
                "label": "L4",
                "addr": 4661
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 154,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  mov    %rsi,%rdi\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   10b0 <strlen@plt>\n  lea    0x1(%rax,%rax,1),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    1258 <func0+0xb8>\n  movslq %ebx,%r14\n  lea    (%rax,%r14,1),%r12\n  lea    -0x1(%rbx),%eax\n  xor    %ebx,%ebx\n  mov    %rax,0x8(%rsp)\n  jmp    11fe <func0+0x5e>\n  nopl   (%rax)\n  lea    0x1(%rbx),%rax\n  cmp    0x8(%rsp),%rbx\n  je     1258 <func0+0xb8>\n  mov    %rax,%rbx\n  mov    %r14,%rdx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  mov    %r15,%rdi\n  sub    %rbx,%rdx\n  call   10a0 <strncpy@plt>\n  mov    %r12,%rdi\n  mov    %rbp,%rsi\n  mov    %rbx,%rdx\n  sub    %rbx,%rdi\n  call   10a0 <strncpy@plt>\n  movb   $0x0,(%r12)\n  mov    %r15,%rsi\n  mov    %r13,%rdi\n  call   10d0 <strstr@plt>\n  test   %rax,%rax\n  je     11f0 <func0+0x50>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  mov    $0x1,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  mov    %rsi,%rdi\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  lea    0x1(%rax,%rax,1),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    L0\n  movslq %ebx,%r14\n  lea    (%rax,%r14,1),%r12\n  lea    -0x1(%rbx),%eax\n  xor    %ebx,%ebx\n  mov    %rax,0x8(%rsp)\n  jmp    L1\n  nopl   (%rax)\nL2:\n  lea    0x1(%rbx),%rax\n  cmp    0x8(%rsp),%rbx\n  je     L0\n  mov    %rax,%rbx\nL1:\n  mov    %r14,%rdx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  mov    %r15,%rdi\n  sub    %rbx,%rdx\n  call   <strncpy@plt>\n  mov    %r12,%rdi\n  mov    %rbp,%rsi\n  mov    %rbx,%rdx\n  sub    %rbx,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,(%r12)\n  mov    %r15,%rsi\n  mov    %r13,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L2\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  mov    $0x1,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4696
            },
            "L1": {
                "label": "L1",
                "addr": 4606
            },
            "L2": {
                "label": "L2",
                "addr": 4592
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 154,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nbool func0(const char *a, const char *b) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    char *temp = (char *)malloc(2 * len_b + 1);\n\n    for (int i = 0; i < len_b; i++) {\n        strncpy(temp, b + i, len_b - i);\n        strncpy(temp + len_b - i, b, i);\n        temp[len_b] = '\\0';\n        if (strstr(a, temp)) {\n            free(temp);\n            return true;\n        }\n    }\n\n    free(temp);\n    return false;\n}",
        "c_test": "#include <assert.h>\n#include <stdbool.h>\n\nint main() {\n    assert(func0(\"xyzw\", \"xyw\") == false);\n    assert(func0(\"yello\", \"ell\") == true);\n    assert(func0(\"whattup\", \"ptut\") == false);\n    assert(func0(\"efef\", \"fee\") == true);\n    assert(func0(\"abab\", \"aabb\") == false);\n    assert(func0(\"winemtt\", \"tinem\") == true);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  mov    %rsi,%rdi\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   10b0 <strlen@plt>\n  lea    0x1(%rax,%rax,1),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   10c0 <malloc@plt>\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    1258 <func0+0xb8>\n  movslq %ebx,%r14\n  lea    (%rax,%r14,1),%r12\n  lea    -0x1(%rbx),%eax\n  xor    %ebx,%ebx\n  mov    %rax,0x8(%rsp)\n  jmp    11fe <func0+0x5e>\n  nopl   (%rax)\n  lea    0x1(%rbx),%rax\n  cmp    0x8(%rsp),%rbx\n  je     1258 <func0+0xb8>\n  mov    %rax,%rbx\n  mov    %r14,%rdx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  mov    %r15,%rdi\n  sub    %rbx,%rdx\n  call   10a0 <strncpy@plt>\n  mov    %r12,%rdi\n  mov    %rbp,%rsi\n  mov    %rbx,%rdx\n  sub    %rbx,%rdi\n  call   10a0 <strncpy@plt>\n  movb   $0x0,(%r12)\n  mov    %r15,%rsi\n  mov    %r13,%rdi\n  call   10d0 <strstr@plt>\n  test   %rax,%rax\n  je     11f0 <func0+0x50>\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  mov    $0x1,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  mov    %r15,%rdi\n  call   1090 <free@plt>\n  add    $0x18,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  mov    %rdi,%r13\n  mov    %rsi,%rdi\n  push   %r12\n  push   %rbp\n  mov    %rsi,%rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  lea    0x1(%rax,%rax,1),%edi\n  mov    %rax,%rbx\n  movslq %edi,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r15\n  test   %ebx,%ebx\n  jle    L0\n  movslq %ebx,%r14\n  lea    (%rax,%r14,1),%r12\n  lea    -0x1(%rbx),%eax\n  xor    %ebx,%ebx\n  mov    %rax,0x8(%rsp)\n  jmp    L1\n  nopl   (%rax)\nL2:\n  lea    0x1(%rbx),%rax\n  cmp    0x8(%rsp),%rbx\n  je     L0\n  mov    %rax,%rbx\nL1:\n  mov    %r14,%rdx\n  lea    0x0(%rbp,%rbx,1),%rsi\n  mov    %r15,%rdi\n  sub    %rbx,%rdx\n  call   <strncpy@plt>\n  mov    %r12,%rdi\n  mov    %rbp,%rsi\n  mov    %rbx,%rdx\n  sub    %rbx,%rdi\n  call   <strncpy@plt>\n  movb   $0x0,(%r12)\n  mov    %r15,%rsi\n  mov    %r13,%rdi\n  call   <strstr@plt>\n  test   %rax,%rax\n  je     L2\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  mov    $0x1,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL0:\n  mov    %r15,%rdi\n  call   <free@plt>\n  add    $0x18,%rsp\n  xor    %eax,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4696
            },
            "L1": {
                "label": "L1",
                "addr": 4606
            },
            "L2": {
                "label": "L2",
                "addr": 4592
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 155,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    115e <func0+0x65>\n  addl   $0x1,-0xc(%rbp)\n  jmp    1162 <func0+0x69>\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     1123 <func0+0x2a>\n  mov    -0x20(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %rsi,-0x20(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  movl   $0x0,-0x8(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,%edx\n  neg    %edx\n  cmovns %edx,%eax\n  mov    %eax,-0x14(%rbp)\nL2:\n  mov    -0x14(%rbp),%edx\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  shr    $0x20,%rax\n  sar    $0x2,%eax\n  mov    %edx,%esi\n  sar    $0x1f,%esi\n  sub    %esi,%eax\n  mov    %eax,%ecx\n  mov    %ecx,%eax\n  shl    $0x2,%eax\n  add    %ecx,%eax\n  add    %eax,%eax\n  sub    %eax,%edx\n  mov    %edx,-0x4(%rbp)\n  mov    -0x4(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L0\n  addl   $0x1,-0xc(%rbp)\n  jmp    L1\nL0:\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x14(%rbp),%eax\n  movslq %eax,%rdx\n  imul   $0x66666667,%rdx,%rdx\n  shr    $0x20,%rdx\n  sar    $0x2,%edx\n  sar    $0x1f,%eax\n  mov    %eax,%ecx\n  mov    %edx,%eax\n  sub    %ecx,%eax\n  mov    %eax,-0x14(%rbp)\n  cmpl   $0x0,-0x14(%rbp)\n  jg     L2\n  mov    -0x20(%rbp),%rax\n  mov    -0xc(%rbp),%edx\n  mov    %edx,(%rax)\n  mov    -0x20(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4446
            },
            "L1": {
                "label": "L1",
                "addr": 4450
            },
            "L2": {
                "label": "L2",
                "addr": 4387
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 155,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  neg    %edx\n  cmovs  %edi,%edx\n  mov    $0x0,%edi\n  mov    $0x0,%r8d\n  jmp    1131 <func0+0x38>\n  add    $0x1,%r8d\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    113b <func0+0x42>\n  mov    %eax,%edx\n  test   $0x1,%dl\n  je     1111 <func0+0x18>\n  add    $0x1,%edi\n  jmp    1115 <func0+0x1c>\n  mov    %r8d,(%rsi)\n  mov    %edi,0x4(%rsi)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  neg    %edx\n  cmovs  %edi,%edx\n  mov    $0x0,%edi\n  mov    $0x0,%r8d\n  jmp    L0\nL2:\n  add    $0x1,%r8d\nL3:\n  movslq %edx,%rax\n  imul   $0x66666667,%rax,%rax\n  sar    $0x22,%rax\n  mov    %edx,%ecx\n  sar    $0x1f,%ecx\n  sub    %ecx,%eax\n  cmp    $0x9,%edx\n  jle    L1\n  mov    %eax,%edx\nL0:\n  test   $0x1,%dl\n  je     L2\n  add    $0x1,%edi\n  jmp    L3\nL1:\n  mov    %r8d,(%rsi)\n  mov    %edi,0x4(%rsi)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4401
            },
            "L1": {
                "label": "L1",
                "addr": 4411
            },
            "L2": {
                "label": "L2",
                "addr": 4369
            },
            "L3": {
                "label": "L3",
                "addr": 4373
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 155,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  mov    $0xcccccccd,%r8d\n  neg    %edx\n  cmovs  %edi,%edx\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    1132 <func0+0x32>\n  nopw   0x0(%rax,%rax,1)\n  imul   %r8,%rax\n  add    $0x1,%edi\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jle    1149 <func0+0x49>\n  mov    %eax,%edx\n  mov    %edx,%eax\n  test   $0x1,%dl\n  je     1120 <func0+0x20>\n  imul   %r8,%rax\n  add    $0x1,%ecx\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jg     1130 <func0+0x30>\n  mov    %edi,(%rsi)\n  mov    %ecx,0x4(%rsi)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  mov    $0xcccccccd,%r8d\n  neg    %edx\n  cmovs  %edi,%edx\n  xor    %ecx,%ecx\n  xor    %edi,%edi\n  jmp    L0\n  nopw   0x0(%rax,%rax,1)\nL2:\n  imul   %r8,%rax\n  add    $0x1,%edi\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jle    L1\nL3:\n  mov    %eax,%edx\nL0:\n  mov    %edx,%eax\n  test   $0x1,%dl\n  je     L2\n  imul   %r8,%rax\n  add    $0x1,%ecx\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jg     L3\nL1:\n  mov    %edi,(%rsi)\n  mov    %ecx,0x4(%rsi)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4402
            },
            "L1": {
                "label": "L1",
                "addr": 4425
            },
            "L2": {
                "label": "L2",
                "addr": 4384
            },
            "L3": {
                "label": "L3",
                "addr": 4400
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 155,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid func0(int num, int *result) {\n    int even_count = 0, odd_count = 0;\n    num = abs(num);\n    \n    do {\n        int digit = num % 10;\n        if (digit % 2 == 0) {\n            even_count++;\n        } else {\n            odd_count++;\n        }\n        num /= 10;\n    } while (num > 0);\n\n    result[0] = even_count;\n    result[1] = odd_count;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint issame(const int *a, const int *b, int size) {\n    return memcmp(a, b, size * sizeof(int)) == 0;\n}\n\nint main() {\n    int result[2];\n\n    func0(7, result);\n    assert(issame(result, (const int[]){0, 1}, 2));\n\n    func0(-78, result);\n    assert(issame(result, (const int[]){1, 1}, 2));\n\n    func0(3452, result);\n    assert(issame(result, (const int[]){2, 2}, 2));\n\n    func0(346211, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-345821, result);\n    assert(issame(result, (const int[]){3, 3}, 2));\n\n    func0(-2, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    func0(-45347, result);\n    assert(issame(result, (const int[]){2, 3}, 2));\n\n    func0(0, result);\n    assert(issame(result, (const int[]){1, 0}, 2));\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  mov    $0xcccccccd,%r8d\n  neg    %edx\n  cmovs  %edi,%edx\n  xor    %edi,%edi\n  xor    %ecx,%ecx\n  jmp    1132 <func0+0x32>\n  nopw   0x0(%rax,%rax,1)\n  imul   %r8,%rax\n  add    $0x1,%ecx\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jle    1149 <func0+0x49>\n  mov    %eax,%edx\n  mov    %edx,%eax\n  test   $0x1,%dl\n  je     1120 <func0+0x20>\n  imul   %r8,%rax\n  add    $0x1,%edi\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jg     1130 <func0+0x30>\n  movd   %ecx,%xmm0\n  movd   %edi,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rsi)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  mov    %edi,%edx\n  mov    $0xcccccccd,%r8d\n  neg    %edx\n  cmovs  %edi,%edx\n  xor    %edi,%edi\n  xor    %ecx,%ecx\n  jmp    L0\n  nopw   0x0(%rax,%rax,1)\nL2:\n  imul   %r8,%rax\n  add    $0x1,%ecx\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jle    L1\nL3:\n  mov    %eax,%edx\nL0:\n  mov    %edx,%eax\n  test   $0x1,%dl\n  je     L2\n  imul   %r8,%rax\n  add    $0x1,%edi\n  shr    $0x23,%rax\n  cmp    $0x9,%edx\n  jg     L3\nL1:\n  movd   %ecx,%xmm0\n  movd   %edi,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rsi)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4402
            },
            "L1": {
                "label": "L1",
                "addr": 4425
            },
            "L2": {
                "label": "L2",
                "addr": 4384
            },
            "L3": {
                "label": "L3",
                "addr": 4400
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 156,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xd0,%rsp\n  mov    %edi,-0xc4(%rbp)\n  mov    %rsi,-0xd0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    0xe95(%rip),%rax        # 2000 <_fini+0xcfc>\n  mov    %rax,-0x70(%rbp)\n  lea    0xe8c(%rip),%rax        # 2002 <_fini+0xcfe>\n  mov    %rax,-0x68(%rbp)\n  lea    0xe84(%rip),%rax        # 2005 <_fini+0xd01>\n  mov    %rax,-0x60(%rbp)\n  lea    0xe7b(%rip),%rax        # 2007 <_fini+0xd03>\n  mov    %rax,-0x58(%rbp)\n  lea    0xe73(%rip),%rax        # 200a <_fini+0xd06>\n  mov    %rax,-0x50(%rbp)\n  lea    0xe6a(%rip),%rax        # 200c <_fini+0xd08>\n  mov    %rax,-0x48(%rbp)\n  lea    0xe62(%rip),%rax        # 200f <_fini+0xd0b>\n  mov    %rax,-0x40(%rbp)\n  lea    0xe59(%rip),%rax        # 2011 <_fini+0xd0d>\n  mov    %rax,-0x38(%rbp)\n  lea    0xe51(%rip),%rax        # 2014 <_fini+0xd10>\n  mov    %rax,-0x30(%rbp)\n  lea    0xe48(%rip),%rax        # 2016 <_fini+0xd12>\n  mov    %rax,-0x28(%rbp)\n  lea    0xe40(%rip),%rax        # 2019 <_fini+0xd15>\n  mov    %rax,-0x20(%rbp)\n  lea    0xe37(%rip),%rax        # 201b <_fini+0xd17>\n  mov    %rax,-0x18(%rbp)\n  lea    0xe2f(%rip),%rax        # 201e <_fini+0xd1a>\n  mov    %rax,-0x10(%rbp)\n  movl   $0x3e8,-0xb0(%rbp)\n  movl   $0x384,-0xac(%rbp)\n  movl   $0x1f4,-0xa8(%rbp)\n  movl   $0x190,-0xa4(%rbp)\n  movl   $0x64,-0xa0(%rbp)\n  movl   $0x5a,-0x9c(%rbp)\n  movl   $0x32,-0x98(%rbp)\n  movl   $0x28,-0x94(%rbp)\n  movl   $0xa,-0x90(%rbp)\n  movl   $0x9,-0x8c(%rbp)\n  movl   $0x5,-0x88(%rbp)\n  movl   $0x4,-0x84(%rbp)\n  movl   $0x1,-0x80(%rbp)\n  movl   $0x0,-0xb4(%rbp)\n  mov    -0xd0(%rbp),%rax\n  movb   $0x0,(%rax)\n  jmp    12e3 <func0+0x1aa>\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,8),%rdx\n  mov    -0xd0(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1070 <strcat@plt>\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0xb0(%rbp,%rax,4),%eax\n  sub    %eax,-0xc4(%rbp)\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0xb0(%rbp,%rax,4),%eax\n  cmp    %eax,-0xc4(%rbp)\n  jge    1288 <func0+0x14f>\n  cmpl   $0x0,-0xc4(%rbp)\n  jle    12e3 <func0+0x1aa>\n  addl   $0x1,-0xb4(%rbp)\n  cmpl   $0x0,-0xc4(%rbp)\n  jg     12bc <func0+0x183>\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     1301 <func0+0x1c8>\n  call   1060 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0xd0,%rsp\n  mov    %edi,-0xc4(%rbp)\n  mov    %rsi,-0xd0(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,-0x70(%rbp)\n  lea    D1(%rip),%rax\n  mov    %rax,-0x68(%rbp)\n  lea    D2(%rip),%rax\n  mov    %rax,-0x60(%rbp)\n  lea    D3(%rip),%rax\n  mov    %rax,-0x58(%rbp)\n  lea    D4(%rip),%rax\n  mov    %rax,-0x50(%rbp)\n  lea    D5(%rip),%rax\n  mov    %rax,-0x48(%rbp)\n  lea    D6(%rip),%rax\n  mov    %rax,-0x40(%rbp)\n  lea    D7(%rip),%rax\n  mov    %rax,-0x38(%rbp)\n  lea    D8(%rip),%rax\n  mov    %rax,-0x30(%rbp)\n  lea    D9(%rip),%rax\n  mov    %rax,-0x28(%rbp)\n  lea    D10(%rip),%rax\n  mov    %rax,-0x20(%rbp)\n  lea    D11(%rip),%rax\n  mov    %rax,-0x18(%rbp)\n  lea    D12(%rip),%rax\n  mov    %rax,-0x10(%rbp)\n  movl   $0x3e8,-0xb0(%rbp)\n  movl   $0x384,-0xac(%rbp)\n  movl   $0x1f4,-0xa8(%rbp)\n  movl   $0x190,-0xa4(%rbp)\n  movl   $0x64,-0xa0(%rbp)\n  movl   $0x5a,-0x9c(%rbp)\n  movl   $0x32,-0x98(%rbp)\n  movl   $0x28,-0x94(%rbp)\n  movl   $0xa,-0x90(%rbp)\n  movl   $0x9,-0x8c(%rbp)\n  movl   $0x5,-0x88(%rbp)\n  movl   $0x4,-0x84(%rbp)\n  movl   $0x1,-0x80(%rbp)\n  movl   $0x0,-0xb4(%rbp)\n  mov    -0xd0(%rbp),%rax\n  movb   $0x0,(%rax)\n  jmp    L0\nL1:\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0x70(%rbp,%rax,8),%rdx\n  mov    -0xd0(%rbp),%rax\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcat@plt>\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0xb0(%rbp,%rax,4),%eax\n  sub    %eax,-0xc4(%rbp)\nL2:\n  mov    -0xb4(%rbp),%eax\n  cltq\n  mov    -0xb0(%rbp,%rax,4),%eax\n  cmp    %eax,-0xc4(%rbp)\n  jge    L1\n  cmpl   $0x0,-0xc4(%rbp)\n  jle    L0\n  addl   $0x1,-0xb4(%rbp)\nL0:\n  cmpl   $0x0,-0xc4(%rbp)\n  jg     L2\n  nop\n  mov    -0x8(%rbp),%rax\n  sub    %fs:0x28,%rax\n  je     L3\n  call   <__stack_chk_fail@plt>\nL3:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3733
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8194,
                "bias": [
                    3724
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8197,
                "bias": [
                    3716
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8199,
                "bias": [
                    3707
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8202,
                "bias": [
                    3699
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8204,
                "bias": [
                    3690
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8207,
                "bias": [
                    3682
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8209,
                "bias": [
                    3673
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8212,
                "bias": [
                    3665
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8214,
                "bias": [
                    3656
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 8217,
                "bias": [
                    3648
                ]
            },
            "D11": {
                "label": "D11",
                "addr": 8219,
                "bias": [
                    3639
                ]
            },
            "D12": {
                "label": "D12",
                "addr": 8222,
                "bias": [
                    3631
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4835
            },
            "L1": {
                "label": "L1",
                "addr": 4744
            },
            "L2": {
                "label": "L2",
                "addr": 4796
            },
            "L3": {
                "label": "L3",
                "addr": 4865
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "6d00636d00640063640063007863006c00786c00780069780076006976006900",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"m\""
                },
                "0x2002": {
                    "type": "string",
                    "value": "\"cm\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"d\""
                },
                "0x2007": {
                    "type": "string",
                    "value": "\"cd\""
                },
                "0x200a": {
                    "type": "string",
                    "value": "\"c\""
                },
                "0x200c": {
                    "type": "string",
                    "value": "\"xc\""
                },
                "0x200f": {
                    "type": "string",
                    "value": "\"l\""
                },
                "0x2011": {
                    "type": "string",
                    "value": "\"xl\""
                },
                "0x2014": {
                    "type": "string",
                    "value": "\"x\""
                },
                "0x2016": {
                    "type": "string",
                    "value": "\"ix\""
                },
                "0x2019": {
                    "type": "string",
                    "value": "\"v\""
                },
                "0x201b": {
                    "type": "string",
                    "value": "\"iv\""
                },
                "0x201e": {
                    "type": "string",
                    "value": "\"i\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 156,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xb0,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  xor    %eax,%eax\n  lea    0xe9b(%rip),%rax        # 2001 <_fini+0xd2d>\n  mov    %rax,0x40(%rsp)\n  lea    0xe8e(%rip),%rax        # 2000 <_fini+0xd2c>\n  mov    %rax,0x48(%rsp)\n  lea    0xe86(%rip),%rax        # 2004 <_fini+0xd30>\n  mov    %rax,0x50(%rsp)\n  lea    0xe79(%rip),%rax        # 2003 <_fini+0xd2f>\n  mov    %rax,0x58(%rsp)\n  lea    0xe71(%rip),%rax        # 2007 <_fini+0xd33>\n  mov    %rax,0x60(%rsp)\n  lea    0xe64(%rip),%rax        # 2006 <_fini+0xd32>\n  mov    %rax,0x68(%rsp)\n  lea    0xe5c(%rip),%rax        # 200a <_fini+0xd36>\n  mov    %rax,0x70(%rsp)\n  lea    0xe4f(%rip),%rax        # 2009 <_fini+0xd35>\n  mov    %rax,0x78(%rsp)\n  lea    0xe47(%rip),%rax        # 200d <_fini+0xd39>\n  mov    %rax,0x80(%rsp)\n  lea    0xe37(%rip),%rax        # 200c <_fini+0xd38>\n  mov    %rax,0x88(%rsp)\n  lea    0xe2c(%rip),%rax        # 2010 <_fini+0xd3c>\n  mov    %rax,0x90(%rsp)\n  lea    0xe1c(%rip),%rax        # 200f <_fini+0xd3b>\n  mov    %rax,0x98(%rsp)\n  lea    0xe10(%rip),%rax        # 2012 <_fini+0xd3e>\n  mov    %rax,0xa0(%rsp)\n  movl   $0x3e8,(%rsp)\n  movl   $0x384,0x4(%rsp)\n  movl   $0x1f4,0x8(%rsp)\n  movl   $0x190,0xc(%rsp)\n  movl   $0x64,0x10(%rsp)\n  movl   $0x5a,0x14(%rsp)\n  movl   $0x32,0x18(%rsp)\n  movl   $0x28,0x1c(%rsp)\n  movl   $0xa,0x20(%rsp)\n  movl   $0x9,0x24(%rsp)\n  movl   $0x5,0x28(%rsp)\n  movl   $0x4,0x2c(%rsp)\n  movl   $0x1,0x30(%rsp)\n  movb   $0x0,(%rsi)\n  test   %edi,%edi\n  jle    12aa <func0+0x171>\n  mov    %edi,%ebx\n  mov    %rsi,%r13\n  mov    %rsp,%r14\n  lea    0x40(%rsp),%r12\n  mov    (%r14),%ebp\n  cmp    %ebx,%ebp\n  jg     129e <func0+0x165>\n  mov    (%r12),%rsi\n  mov    %r13,%rdi\n  call   1070 <strcat@plt>\n  sub    %ebp,%ebx\n  cmp    %ebp,%ebx\n  jge    128c <func0+0x153>\n  add    $0x4,%r14\n  add    $0x8,%r12\n  test   %ebx,%ebx\n  jg     1285 <func0+0x14c>\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12cd <func0+0x194>\n  add    $0xb0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xb0,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,0x40(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x50(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x58(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x60(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x68(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x70(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x78(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x80(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x88(%rsp)\n  lea    D10(%rip),%rax\n  mov    %rax,0x90(%rsp)\n  lea    D11(%rip),%rax\n  mov    %rax,0x98(%rsp)\n  lea    D12(%rip),%rax\n  mov    %rax,0xa0(%rsp)\n  movl   $0x3e8,(%rsp)\n  movl   $0x384,0x4(%rsp)\n  movl   $0x1f4,0x8(%rsp)\n  movl   $0x190,0xc(%rsp)\n  movl   $0x64,0x10(%rsp)\n  movl   $0x5a,0x14(%rsp)\n  movl   $0x32,0x18(%rsp)\n  movl   $0x28,0x1c(%rsp)\n  movl   $0xa,0x20(%rsp)\n  movl   $0x9,0x24(%rsp)\n  movl   $0x5,0x28(%rsp)\n  movl   $0x4,0x2c(%rsp)\n  movl   $0x1,0x30(%rsp)\n  movb   $0x0,(%rsi)\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%ebx\n  mov    %rsi,%r13\n  mov    %rsp,%r14\n  lea    0x40(%rsp),%r12\nL3:\n  mov    (%r14),%ebp\n  cmp    %ebx,%ebp\n  jg     L1\nL2:\n  mov    (%r12),%rsi\n  mov    %r13,%rdi\n  call   <strcat@plt>\n  sub    %ebp,%ebx\n  cmp    %ebp,%ebx\n  jge    L2\nL1:\n  add    $0x4,%r14\n  add    $0x8,%r12\n  test   %ebx,%ebx\n  jg     L3\nL0:\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L4\n  add    $0xb0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL4:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8193,
                "bias": [
                    3739
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3726
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8196,
                "bias": [
                    3718
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8195,
                "bias": [
                    3705
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8199,
                "bias": [
                    3697
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8198,
                "bias": [
                    3684
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8202,
                "bias": [
                    3676
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8201,
                "bias": [
                    3663
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8205,
                "bias": [
                    3655
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8204,
                "bias": [
                    3639
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 8208,
                "bias": [
                    3628
                ]
            },
            "D11": {
                "label": "D11",
                "addr": 8207,
                "bias": [
                    3612
                ]
            },
            "D12": {
                "label": "D12",
                "addr": 8210,
                "bias": [
                    3600
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4778
            },
            "L1": {
                "label": "L1",
                "addr": 4766
            },
            "L2": {
                "label": "L2",
                "addr": 4748
            },
            "L3": {
                "label": "L3",
                "addr": 4741
            },
            "L4": {
                "label": "L4",
                "addr": 4813
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "636d00636400786300786c006978006976006900",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"cm\""
                },
                "0x2001": {
                    "type": "string",
                    "value": "\"m\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"cd\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"d\""
                },
                "0x2006": {
                    "type": "string",
                    "value": "\"xc\""
                },
                "0x2007": {
                    "type": "string",
                    "value": "\"c\""
                },
                "0x2009": {
                    "type": "string",
                    "value": "\"xl\""
                },
                "0x200a": {
                    "type": "string",
                    "value": "\"l\""
                },
                "0x200c": {
                    "type": "string",
                    "value": "\"ix\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"x\""
                },
                "0x200f": {
                    "type": "string",
                    "value": "\"iv\""
                },
                "0x2010": {
                    "type": "string",
                    "value": "\"v\""
                },
                "0x2012": {
                    "type": "string",
                    "value": "\"i\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 156,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xb0,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  lea    0xe96(%rip),%rax        # 2001 <_fini+0xd11>\n  movb   $0x0,(%rsi)\n  mov    %rax,0x40(%rsp)\n  lea    0xe86(%rip),%rax        # 2000 <_fini+0xd10>\n  mov    %rax,0x48(%rsp)\n  lea    0xe7e(%rip),%rax        # 2004 <_fini+0xd14>\n  mov    %rax,0x50(%rsp)\n  lea    0xe71(%rip),%rax        # 2003 <_fini+0xd13>\n  mov    %rax,0x58(%rsp)\n  lea    0xe69(%rip),%rax        # 2007 <_fini+0xd17>\n  mov    %rax,0x60(%rsp)\n  lea    0xe5c(%rip),%rax        # 2006 <_fini+0xd16>\n  mov    %rax,0x68(%rsp)\n  lea    0xe54(%rip),%rax        # 200a <_fini+0xd1a>\n  mov    %rax,0x70(%rsp)\n  lea    0xe47(%rip),%rax        # 2009 <_fini+0xd19>\n  mov    %rax,0x78(%rsp)\n  lea    0xe3f(%rip),%rax        # 200d <_fini+0xd1d>\n  mov    %rax,0x80(%rsp)\n  lea    0xe2f(%rip),%rax        # 200c <_fini+0xd1c>\n  mov    %rax,0x88(%rsp)\n  lea    0xe24(%rip),%rax        # 2010 <_fini+0xd20>\n  mov    %rax,0x90(%rsp)\n  lea    0xe14(%rip),%rax        # 200f <_fini+0xd1f>\n  mov    %rax,0x98(%rsp)\n  lea    0xe08(%rip),%rax        # 2012 <_fini+0xd22>\n  mov    %rax,0xa0(%rsp)\n  movabs $0x1f400000384,%rax\n  mov    %rax,0x4(%rsp)\n  movabs $0x6400000190,%rax\n  mov    %rax,0xc(%rsp)\n  movabs $0x320000005a,%rax\n  mov    %rax,0x14(%rsp)\n  movabs $0xa00000028,%rax\n  mov    %rax,0x1c(%rsp)\n  movabs $0x500000009,%rax\n  mov    %rax,0x24(%rsp)\n  movabs $0x100000004,%rax\n  mov    %rax,0x2c(%rsp)\n  test   %edi,%edi\n  jle    12c8 <func0+0x188>\n  mov    %edi,%ebx\n  mov    $0x3e8,%ebp\n  mov    %rsi,%rdx\n  xor    %r13d,%r13d\n  lea    0x40(%rsp),%r14\n  cmp    %ebx,%ebp\n  jg     12bc <func0+0x17c>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    (%r14,%r13,2),%r12\n  nopl   0x0(%rax)\n  mov    %rdx,%rdi\n  mov    %r12,%rsi\n  sub    %ebp,%ebx\n  call   1070 <strcat@plt>\n  mov    %rax,%rdx\n  cmp    %ebx,%ebp\n  jle    1298 <func0+0x158>\n  add    $0x4,%r13\n  test   %ebx,%ebx\n  je     12c8 <func0+0x188>\n  mov    (%rsp,%r13,1),%ebp\n  cmp    %ebx,%ebp\n  jle    1290 <func0+0x150>\n  add    $0x4,%r13\n  jmp    12b4 <func0+0x174>\n  nopw   0x0(%rax,%rax,1)\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12eb <func0+0x1ab>\n  add    $0xb0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0xb0,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  lea    D0(%rip),%rax\n  movb   $0x0,(%rsi)\n  mov    %rax,0x40(%rsp)\n  lea    D1(%rip),%rax\n  mov    %rax,0x48(%rsp)\n  lea    D2(%rip),%rax\n  mov    %rax,0x50(%rsp)\n  lea    D3(%rip),%rax\n  mov    %rax,0x58(%rsp)\n  lea    D4(%rip),%rax\n  mov    %rax,0x60(%rsp)\n  lea    D5(%rip),%rax\n  mov    %rax,0x68(%rsp)\n  lea    D6(%rip),%rax\n  mov    %rax,0x70(%rsp)\n  lea    D7(%rip),%rax\n  mov    %rax,0x78(%rsp)\n  lea    D8(%rip),%rax\n  mov    %rax,0x80(%rsp)\n  lea    D9(%rip),%rax\n  mov    %rax,0x88(%rsp)\n  lea    D10(%rip),%rax\n  mov    %rax,0x90(%rsp)\n  lea    D11(%rip),%rax\n  mov    %rax,0x98(%rsp)\n  lea    D12(%rip),%rax\n  mov    %rax,0xa0(%rsp)\n  movabs $0x1f400000384,%rax\n  mov    %rax,0x4(%rsp)\n  movabs $0x6400000190,%rax\n  mov    %rax,0xc(%rsp)\n  movabs $0x320000005a,%rax\n  mov    %rax,0x14(%rsp)\n  movabs $0xa00000028,%rax\n  mov    %rax,0x1c(%rsp)\n  movabs $0x500000009,%rax\n  mov    %rax,0x24(%rsp)\n  movabs $0x100000004,%rax\n  mov    %rax,0x2c(%rsp)\n  test   %edi,%edi\n  jle    L0\n  mov    %edi,%ebx\n  mov    $0x3e8,%ebp\n  mov    %rsi,%rdx\n  xor    %r13d,%r13d\n  lea    0x40(%rsp),%r14\n  cmp    %ebx,%ebp\n  jg     L1\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    (%r14,%r13,2),%r12\n  nopl   0x0(%rax)\nL2:\n  mov    %rdx,%rdi\n  mov    %r12,%rsi\n  sub    %ebp,%ebx\n  call   <strcat@plt>\n  mov    %rax,%rdx\n  cmp    %ebx,%ebp\n  jle    L2\n  add    $0x4,%r13\n  test   %ebx,%ebx\n  je     L0\nL4:\n  mov    (%rsp,%r13,1),%ebp\n  cmp    %ebx,%ebp\n  jle    L3\nL1:\n  add    $0x4,%r13\n  jmp    L4\n  nopw   0x0(%rax,%rax,1)\nL0:\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L5\n  add    $0xb0,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  ret\nL5:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8193,
                "bias": [
                    3734
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3718
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8196,
                "bias": [
                    3710
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8195,
                "bias": [
                    3697
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8199,
                "bias": [
                    3689
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8198,
                "bias": [
                    3676
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8202,
                "bias": [
                    3668
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8201,
                "bias": [
                    3655
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8205,
                "bias": [
                    3647
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8204,
                "bias": [
                    3631
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 8208,
                "bias": [
                    3620
                ]
            },
            "D11": {
                "label": "D11",
                "addr": 8207,
                "bias": [
                    3604
                ]
            },
            "D12": {
                "label": "D12",
                "addr": 8210,
                "bias": [
                    3592
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4808
            },
            "L1": {
                "label": "L1",
                "addr": 4796
            },
            "L2": {
                "label": "L2",
                "addr": 4760
            },
            "L3": {
                "label": "L3",
                "addr": 4752
            },
            "L4": {
                "label": "L4",
                "addr": 4788
            },
            "L5": {
                "label": "L5",
                "addr": 4843
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "636d00636400786300786c006978006976006900",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"cm\""
                },
                "0x2001": {
                    "type": "string",
                    "value": "\"m\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"cd\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"d\""
                },
                "0x2006": {
                    "type": "string",
                    "value": "\"xc\""
                },
                "0x2007": {
                    "type": "string",
                    "value": "\"c\""
                },
                "0x2009": {
                    "type": "string",
                    "value": "\"xl\""
                },
                "0x200a": {
                    "type": "string",
                    "value": "\"l\""
                },
                "0x200c": {
                    "type": "string",
                    "value": "\"ix\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"x\""
                },
                "0x200f": {
                    "type": "string",
                    "value": "\"iv\""
                },
                "0x2010": {
                    "type": "string",
                    "value": "\"v\""
                },
                "0x2012": {
                    "type": "string",
                    "value": "\"i\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 156,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nvoid func0(int number, char *result) {\n    const char *rep[] = {\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"};\n    const int num[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n    int pos = 0;\n    result[0] = '\\0';\n\n    while(number > 0) {\n        while (number >= num[pos]) {\n            strcat(result, rep[pos]);\n            number -= num[pos];\n        }\n        if (number > 0) pos++;\n    }\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char result[64]; // Buffer large enough for all Roman numeral representations of numbers 1-1000\n\n    func0(19, result);\n    assert(strcmp(result, \"xix\") == 0);\n\n    func0(152, result);\n    assert(strcmp(result, \"clii\") == 0);\n\n    func0(251, result);\n    assert(strcmp(result, \"ccli\") == 0);\n\n    func0(426, result);\n    assert(strcmp(result, \"cdxxvi\") == 0);\n\n    func0(500, result);\n    assert(strcmp(result, \"d\") == 0);\n\n    func0(1, result);\n    assert(strcmp(result, \"i\") == 0);\n\n    func0(4, result);\n    assert(strcmp(result, \"iv\") == 0);\n\n    func0(43, result);\n    assert(strcmp(result, \"xliii\") == 0);\n\n    func0(90, result);\n    assert(strcmp(result, \"xc\") == 0);\n\n    func0(94, result);\n    assert(strcmp(result, \"xciv\") == 0);\n\n    func0(532, result);\n    assert(strcmp(result, \"dxxxii\") == 0);\n\n    func0(900, result);\n    assert(strcmp(result, \"cm\") == 0);\n\n    func0(994, result);\n    assert(strcmp(result, \"cmxciv\") == 0);\n\n    func0(1000, result);\n    assert(strcmp(result, \"m\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  lea    0xeb4(%rip),%rcx        # 2001 <_fini+0xd0d>\n  mov    %rsi,%rdx\n  push   %r14\n  movq   %rcx,%xmm0\n  lea    0xea6(%rip),%rcx        # 2004 <_fini+0xd10>\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  sub    $0xb8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  lea    0xe78(%rip),%rax        # 2000 <_fini+0xd0c>\n  lea    0x40(%rsp),%r15\n  movb   $0x0,(%rsi)\n  mov    %rsp,%r14\n  movl   $0x1,0x30(%rsp)\n  movq   %rax,%xmm1\n  lea    0xe5c(%rip),%rax        # 2003 <_fini+0xd0f>\n  punpcklqdq %xmm1,%xmm0\n  movq   %rax,%xmm2\n  lea    0xe4f(%rip),%rax        # 2006 <_fini+0xd12>\n  movaps %xmm0,0x40(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm3\n  lea    0xe3a(%rip),%rcx        # 2007 <_fini+0xd13>\n  punpcklqdq %xmm2,%xmm0\n  lea    0xe31(%rip),%rax        # 2009 <_fini+0xd15>\n  movaps %xmm0,0x50(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm4\n  lea    0xe1c(%rip),%rcx        # 200a <_fini+0xd16>\n  punpcklqdq %xmm3,%xmm0\n  lea    0xe13(%rip),%rax        # 200c <_fini+0xd18>\n  movaps %xmm0,0x60(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm5\n  lea    0xdfe(%rip),%rcx        # 200d <_fini+0xd19>\n  punpcklqdq %xmm4,%xmm0\n  lea    0xdf5(%rip),%rax        # 200f <_fini+0xd1b>\n  movaps %xmm0,0x70(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm6\n  lea    0xde0(%rip),%rcx        # 2010 <_fini+0xd1c>\n  punpcklqdq %xmm5,%xmm0\n  lea    0xdd7(%rip),%rax        # 2012 <_fini+0xd1e>\n  movaps %xmm0,0x80(%rsp)\n  movq   %rcx,%xmm0\n  punpcklqdq %xmm6,%xmm0\n  mov    %rax,0xa0(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movdqa 0xdbc(%rip),%xmm0        # 2020 <_fini+0xd2c>\n  movaps %xmm0,(%rsp)\n  movdqa 0xdc0(%rip),%xmm0        # 2030 <_fini+0xd3c>\n  movaps %xmm0,0x10(%rsp)\n  movdqa 0xdc3(%rip),%xmm0        # 2040 <_fini+0xd4c>\n  movaps %xmm0,0x20(%rsp)\n  test   %edi,%edi\n  jle    12bc <func0+0x17c>\n  cs nopw 0x0(%rax,%rax,1)\n  mov    (%r14,%r13,4),%ebp\n  cmp    %ebx,%ebp\n  jg     12e8 <func0+0x1a8>\n  mov    (%r15,%r13,8),%r12\n  nopl   0x0(%rax)\n  mov    %rdx,%rdi\n  mov    %r12,%rsi\n  sub    %ebp,%ebx\n  call   1070 <strcat@plt>\n  mov    %rax,%rdx\n  cmp    %ebp,%ebx\n  jge    12a0 <func0+0x160>\n  add    $0x1,%r13\n  test   %ebx,%ebx\n  jne    1290 <func0+0x150>\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    12ee <func0+0x1ae>\n  add    $0xb8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  add    $0x1,%r13\n  jmp    1290 <func0+0x150>\n  call   1060 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  lea    D0(%rip),%rcx\n  mov    %rsi,%rdx\n  push   %r14\n  movq   %rcx,%xmm0\n  lea    D1(%rip),%rcx\n  push   %r13\n  xor    %r13d,%r13d\n  push   %r12\n  push   %rbp\n  push   %rbx\n  mov    %edi,%ebx\n  sub    $0xb8,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0xa8(%rsp)\n  lea    D2(%rip),%rax\n  lea    0x40(%rsp),%r15\n  movb   $0x0,(%rsi)\n  mov    %rsp,%r14\n  movl   $0x1,0x30(%rsp)\n  movq   %rax,%xmm1\n  lea    D3(%rip),%rax\n  punpcklqdq %xmm1,%xmm0\n  movq   %rax,%xmm2\n  lea    D4(%rip),%rax\n  movaps %xmm0,0x40(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm3\n  lea    D5(%rip),%rcx\n  punpcklqdq %xmm2,%xmm0\n  lea    D6(%rip),%rax\n  movaps %xmm0,0x50(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm4\n  lea    D7(%rip),%rcx\n  punpcklqdq %xmm3,%xmm0\n  lea    D8(%rip),%rax\n  movaps %xmm0,0x60(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm5\n  lea    D9(%rip),%rcx\n  punpcklqdq %xmm4,%xmm0\n  lea    D10(%rip),%rax\n  movaps %xmm0,0x70(%rsp)\n  movq   %rcx,%xmm0\n  movq   %rax,%xmm6\n  lea    D11(%rip),%rcx\n  punpcklqdq %xmm5,%xmm0\n  lea    D12(%rip),%rax\n  movaps %xmm0,0x80(%rsp)\n  movq   %rcx,%xmm0\n  punpcklqdq %xmm6,%xmm0\n  mov    %rax,0xa0(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movdqa D13(%rip),%xmm0\n  movaps %xmm0,(%rsp)\n  movdqa D14(%rip),%xmm0\n  movaps %xmm0,0x10(%rsp)\n  movdqa D15(%rip),%xmm0\n  movaps %xmm0,0x20(%rsp)\n  test   %edi,%edi\n  jle    L0\n  cs nopw 0x0(%rax,%rax,1)\nL3:\n  mov    (%r14,%r13,4),%ebp\n  cmp    %ebx,%ebp\n  jg     L1\n  mov    (%r15,%r13,8),%r12\n  nopl   0x0(%rax)\nL2:\n  mov    %rdx,%rdi\n  mov    %r12,%rsi\n  sub    %ebp,%ebx\n  call   <strcat@plt>\n  mov    %rax,%rdx\n  cmp    %ebp,%ebx\n  jge    L2\n  add    $0x1,%r13\n  test   %ebx,%ebx\n  jne    L3\nL0:\n  mov    0xa8(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L4\n  add    $0xb8,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL1:\n  add    $0x1,%r13\n  jmp    L3\nL4:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 3,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8193,
                "bias": [
                    3764
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8196,
                "bias": [
                    3750
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8192,
                "bias": [
                    3704
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8195,
                "bias": [
                    3676
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8198,
                "bias": [
                    3663
                ]
            },
            "D5": {
                "label": "D5",
                "addr": 8199,
                "bias": [
                    3642
                ]
            },
            "D6": {
                "label": "D6",
                "addr": 8201,
                "bias": [
                    3633
                ]
            },
            "D7": {
                "label": "D7",
                "addr": 8202,
                "bias": [
                    3612
                ]
            },
            "D8": {
                "label": "D8",
                "addr": 8204,
                "bias": [
                    3603
                ]
            },
            "D9": {
                "label": "D9",
                "addr": 8205,
                "bias": [
                    3582
                ]
            },
            "D10": {
                "label": "D10",
                "addr": 8207,
                "bias": [
                    3573
                ]
            },
            "D11": {
                "label": "D11",
                "addr": 8208,
                "bias": [
                    3552
                ]
            },
            "D12": {
                "label": "D12",
                "addr": 8210,
                "bias": [
                    3543
                ]
            },
            "D13": {
                "label": "D13",
                "addr": 8224,
                "bias": [
                    3516
                ]
            },
            "D14": {
                "label": "D14",
                "addr": 8240,
                "bias": [
                    3520
                ]
            },
            "D15": {
                "label": "D15",
                "addr": 8256,
                "bias": [
                    3523
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4796
            },
            "L1": {
                "label": "L1",
                "addr": 4840
            },
            "L2": {
                "label": "L2",
                "addr": 4768
            },
            "L3": {
                "label": "L3",
                "addr": 4752
            },
            "L4": {
                "label": "L4",
                "addr": 4846
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "636d00636400786300786c006978006976006900000000000000000000000000e803000084030000f401000090010000640000005a00000032000000280000000a000000090000000500000004000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"cm\""
                },
                "0x2001": {
                    "type": "string",
                    "value": "\"m\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"cd\""
                },
                "0x2004": {
                    "type": "string",
                    "value": "\"d\""
                },
                "0x2006": {
                    "type": "string",
                    "value": "\"xc\""
                },
                "0x2007": {
                    "type": "string",
                    "value": "\"c\""
                },
                "0x2009": {
                    "type": "string",
                    "value": "\"xl\""
                },
                "0x200a": {
                    "type": "string",
                    "value": "\"l\""
                },
                "0x200c": {
                    "type": "string",
                    "value": "\"ix\""
                },
                "0x200d": {
                    "type": "string",
                    "value": "\"x\""
                },
                "0x200f": {
                    "type": "string",
                    "value": "\"iv\""
                },
                "0x2010": {
                    "type": "string",
                    "value": "\"v\""
                },
                "0x2012": {
                    "type": "string",
                    "value": "\"i\""
                },
                "0x2020": {
                    "type": "byte[16]",
                    "value": [
                        232,
                        3,
                        0,
                        0,
                        132,
                        3,
                        0,
                        0,
                        244,
                        1,
                        0,
                        0,
                        144,
                        1,
                        0,
                        0
                    ]
                },
                "0x2030": {
                    "type": "byte[16]",
                    "value": [
                        100,
                        0,
                        0,
                        0,
                        90,
                        0,
                        0,
                        0,
                        50,
                        0,
                        0,
                        0,
                        40,
                        0,
                        0,
                        0
                    ]
                },
                "0x2040": {
                    "type": "byte[16]",
                    "value": [
                        10,
                        0,
                        0,
                        0,
                        9,
                        0,
                        0,
                        0,
                        5,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 157,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  %xmm2,-0xc(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  0xebc(%rip),%xmm1        # 2000 <_fini+0xdf4>\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  0xeb9(%rip),%xmm0        # 2010 <_fini+0xe04>\n  comisd %xmm1,%xmm0\n  ja     11fb <func0+0x102>\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  0xe6b(%rip),%xmm1        # 2000 <_fini+0xdf4>\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  0xe68(%rip),%xmm0        # 2010 <_fini+0xe04>\n  comisd %xmm1,%xmm0\n  ja     11fb <func0+0x102>\n  movss  -0x8(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  0xe1e(%rip),%xmm1        # 2000 <_fini+0xdf4>\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  0xe1b(%rip),%xmm0        # 2010 <_fini+0xe04>\n  comisd %xmm1,%xmm0\n  jbe    1202 <func0+0x109>\n  mov    $0x1,%eax\n  jmp    1207 <func0+0x10e>\n  mov    $0x0,%eax\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  movss  %xmm0,-0x4(%rbp)\n  movss  %xmm1,-0x8(%rbp)\n  movss  %xmm2,-0xc(%rbp)\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  D0(%rip),%xmm1\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  D1(%rip),%xmm0\n  comisd %xmm1,%xmm0\n  ja     L0\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0x8(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  D0(%rip),%xmm1\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  D1(%rip),%xmm0\n  comisd %xmm1,%xmm0\n  ja     L0\n  movss  -0x8(%rbp),%xmm0\n  movaps %xmm0,%xmm1\n  mulss  %xmm0,%xmm1\n  movss  -0xc(%rbp),%xmm0\n  mulss  %xmm0,%xmm0\n  addss  %xmm0,%xmm1\n  movss  -0x4(%rbp),%xmm0\n  movaps %xmm0,%xmm2\n  mulss  %xmm0,%xmm2\n  subss  %xmm2,%xmm1\n  movaps %xmm1,%xmm0\n  movss  D0(%rip),%xmm1\n  andps  %xmm1,%xmm0\n  pxor   %xmm1,%xmm1\n  cvtss2sd %xmm0,%xmm1\n  movsd  D1(%rip),%xmm0\n  comisd %xmm1,%xmm0\n  jbe    L1\nL0:\n  mov    $0x1,%eax\n  jmp    L2\nL1:\n  mov    $0x0,%eax\nL2:\n  pop    %rbp\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3772,
                    3691,
                    3614
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3769,
                    3688,
                    3611
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4603
            },
            "L1": {
                "label": "L1",
                "addr": 4610
            },
            "L2": {
                "label": "L2",
                "addr": 4615
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f0000000000000000000000002d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "dword",
                    "value": 2147483647
                },
                "0x2010": {
                    "type": "byte[8]",
                    "value": [
                        45,
                        67,
                        28,
                        235,
                        226,
                        54,
                        26,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 157,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  0xee2(%rip),%xmm0        # 2000 <_fini+0xe90>\n  cvtss2sd %xmm0,%xmm0\n  mov    $0x1,%eax\n  movsd  0xee1(%rip),%xmm4        # 2010 <_fini+0xea0>\n  comisd %xmm0,%xmm4\n  ja     116e <func0+0x75>\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  0xeb9(%rip),%xmm0        # 2000 <_fini+0xe90>\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     116e <func0+0x75>\n  addss  %xmm2,%xmm1\n  subss  %xmm3,%xmm1\n  andps  0xea0(%rip),%xmm1        # 2000 <_fini+0xe90>\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\n  movzbl %al,%eax\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  D0(%rip),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  mov    $0x1,%eax\n  movsd  D1(%rip),%xmm4\n  comisd %xmm0,%xmm4\n  ja     L0\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  D0(%rip),%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     L0\n  addss  %xmm2,%xmm1\n  subss  %xmm3,%xmm1\n  andps  D0(%rip),%xmm1\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\n  movzbl %al,%eax\nL0:\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3810,
                    3769,
                    3744
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3809
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4462
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f0000000000000000000000002d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "dword[4]",
                    "value": [
                        2147483647,
                        0,
                        0,
                        0
                    ]
                },
                "0x2010": {
                    "type": "byte[8]",
                    "value": [
                        45,
                        67,
                        28,
                        235,
                        226,
                        54,
                        26,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 157,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  movsd  0xf01(%rip),%xmm4        # 2010 <_fini+0xe9c>\n  movss  0xee9(%rip),%xmm5        # 2000 <_fini+0xe8c>\n  mov    $0x1,%eax\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     1170 <func0+0x70>\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     1170 <func0+0x70>\n  addss  %xmm2,%xmm1\n  xor    %eax,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm5,%xmm1\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  movsd  D0(%rip),%xmm4\n  movss  D1(%rip),%xmm5\n  mov    $0x1,%eax\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     L0\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     L0\n  addss  %xmm2,%xmm1\n  xor    %eax,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm5,%xmm1\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\nL0:\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8208,
                "bias": [
                    3841
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3817
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4464
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f0000000000000000000000002d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "dword",
                    "value": 2147483647
                },
                "0x2010": {
                    "type": "byte[8]",
                    "value": [
                        45,
                        67,
                        28,
                        235,
                        226,
                        54,
                        26,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 157,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n\nint func0(float a, float b, float c) {\n    if (fabs(a*a + b*b - c*c) < 1e-4 || fabs(a*a + c*c - b*b) < 1e-4 || fabs(b*b + c*c - a*a) < 1e-4) return 1;\n    return 0;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    assert(func0(3, 4, 5) == 1);\n    assert(func0(1, 2, 3) == 0);\n    assert(func0(10, 6, 8) == 1);\n    assert(func0(2, 2, 2) == 0);\n    assert(func0(7, 24, 25) == 1);\n    assert(func0(10, 5, 7) == 0);\n    assert(func0(5, 12, 13) == 1);\n    assert(func0(15, 8, 17) == 1);\n    assert(func0(48, 55, 73) == 1);\n    assert(func0(1, 1, 1) == 0);\n    assert(func0(2, 2, 10) == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  movsd  0xf01(%rip),%xmm4        # 2010 <_fini+0xe9c>\n  movss  0xee9(%rip),%xmm5        # 2000 <_fini+0xe8c>\n  mov    $0x1,%eax\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     1170 <func0+0x70>\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     1170 <func0+0x70>\n  addss  %xmm2,%xmm1\n  xor    %eax,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm5,%xmm1\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movaps %xmm0,%xmm3\n  movsd  D0(%rip),%xmm4\n  movss  D1(%rip),%xmm5\n  mov    $0x1,%eax\n  mulss  %xmm0,%xmm3\n  mulss  %xmm1,%xmm1\n  mulss  %xmm2,%xmm2\n  movaps %xmm3,%xmm0\n  addss  %xmm1,%xmm0\n  subss  %xmm2,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     L0\n  movaps %xmm3,%xmm0\n  addss  %xmm2,%xmm0\n  subss  %xmm1,%xmm0\n  andps  %xmm5,%xmm0\n  cvtss2sd %xmm0,%xmm0\n  comisd %xmm0,%xmm4\n  ja     L0\n  addss  %xmm2,%xmm1\n  xor    %eax,%eax\n  subss  %xmm3,%xmm1\n  andps  %xmm5,%xmm1\n  cvtss2sd %xmm1,%xmm1\n  comisd %xmm1,%xmm4\n  seta   %al\nL0:\n  ret",
        "num_missing": 1,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8208,
                "bias": [
                    3841
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3817
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4464
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "ffffff7f0000000000000000000000002d431cebe2361a3f",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "dword",
                    "value": 2147483647
                },
                "0x2010": {
                    "type": "byte[8]",
                    "value": [
                        45,
                        67,
                        28,
                        235,
                        226,
                        54,
                        26,
                        63
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 158,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x140,%rsp\n  mov    %rdi,-0x138(%rbp)\n  mov    %esi,-0x13c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    0xe55(%rip),%rax        # 2000 <_fini+0xb48>\n  mov    %rax,-0x118(%rbp)\n  movl   $0x0,-0x12c(%rbp)\n  movl   $0x0,-0x128(%rbp)\n  jmp    1487 <func0+0x30e>\n  movq   $0x0,-0x110(%rbp)\n  movq   $0x0,-0x108(%rbp)\n  movq   $0x0,-0x100(%rbp)\n  movq   $0x0,-0xf8(%rbp)\n  movq   $0x0,-0xf0(%rbp)\n  movq   $0x0,-0xe8(%rbp)\n  movq   $0x0,-0xe0(%rbp)\n  movq   $0x0,-0xd8(%rbp)\n  movq   $0x0,-0xd0(%rbp)\n  movq   $0x0,-0xc8(%rbp)\n  movq   $0x0,-0xc0(%rbp)\n  movq   $0x0,-0xb8(%rbp)\n  movq   $0x0,-0xb0(%rbp)\n  movq   $0x0,-0xa8(%rbp)\n  movq   $0x0,-0xa0(%rbp)\n  movq   $0x0,-0x98(%rbp)\n  movq   $0x0,-0x90(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  movq   $0x0,-0x68(%rbp)\n  movq   $0x0,-0x60(%rbp)\n  movq   $0x0,-0x58(%rbp)\n  movq   $0x0,-0x50(%rbp)\n  movq   $0x0,-0x48(%rbp)\n  movq   $0x0,-0x40(%rbp)\n  movq   $0x0,-0x38(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movq   $0x0,-0x28(%rbp)\n  movq   $0x0,-0x20(%rbp)\n  movq   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x124(%rbp)\n  movl   $0x0,-0x120(%rbp)\n  jmp    13ce <func0+0x255>\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  lea    -0x110(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   10a0 <strchr@plt>\n  test   %rax,%rax\n  jne    13c7 <func0+0x24e>\n  lea    -0x110(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <strlen@plt>\n  mov    %eax,-0x11c(%rbp)\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x11c(%rbp),%eax\n  cltq\n  mov    %dl,-0x110(%rbp,%rax,1)\n  mov    -0x11c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  movb   $0x0,-0x110(%rbp,%rax,1)\n  addl   $0x1,-0x124(%rbp)\n  addl   $0x1,-0x120(%rbp)\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    131a <func0+0x1a1>\n  mov    -0x124(%rbp),%eax\n  cmp    -0x12c(%rbp),%eax\n  jg     1450 <func0+0x2d7>\n  mov    -0x124(%rbp),%eax\n  cmp    -0x12c(%rbp),%eax\n  jne    1480 <func0+0x307>\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x118(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   10b0 <strcmp@plt>\n  test   %eax,%eax\n  jns    1480 <func0+0x307>\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x118(%rbp)\n  mov    -0x124(%rbp),%eax\n  mov    %eax,-0x12c(%rbp)\n  addl   $0x1,-0x128(%rbp)\n  mov    -0x128(%rbp),%eax\n  cmp    -0x13c(%rbp),%eax\n  jl     11cb <func0+0x52>\n  mov    -0x118(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     14b4 <func0+0x33b>\n  call   1090 <__stack_chk_fail@plt>\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x140,%rsp\n  mov    %rdi,-0x138(%rbp)\n  mov    %esi,-0x13c(%rbp)\n  mov    %fs:0x28,%rax\n  mov    %rax,-0x8(%rbp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,-0x118(%rbp)\n  movl   $0x0,-0x12c(%rbp)\n  movl   $0x0,-0x128(%rbp)\n  jmp    L0\nL6:\n  movq   $0x0,-0x110(%rbp)\n  movq   $0x0,-0x108(%rbp)\n  movq   $0x0,-0x100(%rbp)\n  movq   $0x0,-0xf8(%rbp)\n  movq   $0x0,-0xf0(%rbp)\n  movq   $0x0,-0xe8(%rbp)\n  movq   $0x0,-0xe0(%rbp)\n  movq   $0x0,-0xd8(%rbp)\n  movq   $0x0,-0xd0(%rbp)\n  movq   $0x0,-0xc8(%rbp)\n  movq   $0x0,-0xc0(%rbp)\n  movq   $0x0,-0xb8(%rbp)\n  movq   $0x0,-0xb0(%rbp)\n  movq   $0x0,-0xa8(%rbp)\n  movq   $0x0,-0xa0(%rbp)\n  movq   $0x0,-0x98(%rbp)\n  movq   $0x0,-0x90(%rbp)\n  movq   $0x0,-0x88(%rbp)\n  movq   $0x0,-0x80(%rbp)\n  movq   $0x0,-0x78(%rbp)\n  movq   $0x0,-0x70(%rbp)\n  movq   $0x0,-0x68(%rbp)\n  movq   $0x0,-0x60(%rbp)\n  movq   $0x0,-0x58(%rbp)\n  movq   $0x0,-0x50(%rbp)\n  movq   $0x0,-0x48(%rbp)\n  movq   $0x0,-0x40(%rbp)\n  movq   $0x0,-0x38(%rbp)\n  movq   $0x0,-0x30(%rbp)\n  movq   $0x0,-0x28(%rbp)\n  movq   $0x0,-0x20(%rbp)\n  movq   $0x0,-0x18(%rbp)\n  movl   $0x0,-0x124(%rbp)\n  movl   $0x0,-0x120(%rbp)\n  jmp    L1\nL3:\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movsbl %al,%edx\n  lea    -0x110(%rbp),%rax\n  mov    %edx,%esi\n  mov    %rax,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L2\n  lea    -0x110(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x11c(%rbp)\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%edx\n  mov    -0x11c(%rbp),%eax\n  cltq\n  mov    %dl,-0x110(%rbp,%rax,1)\n  mov    -0x11c(%rbp),%eax\n  add    $0x1,%eax\n  cltq\n  movb   $0x0,-0x110(%rbp,%rax,1)\n  addl   $0x1,-0x124(%rbp)\nL2:\n  addl   $0x1,-0x120(%rbp)\nL1:\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rdx\n  mov    -0x120(%rbp),%eax\n  cltq\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L3\n  mov    -0x124(%rbp),%eax\n  cmp    -0x12c(%rbp),%eax\n  jg     L4\n  mov    -0x124(%rbp),%eax\n  cmp    -0x12c(%rbp),%eax\n  jne    L5\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    -0x118(%rbp),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jns    L5\nL4:\n  mov    -0x128(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x138(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  mov    %rax,-0x118(%rbp)\n  mov    -0x124(%rbp),%eax\n  mov    %eax,-0x12c(%rbp)\nL5:\n  addl   $0x1,-0x128(%rbp)\nL0:\n  mov    -0x128(%rbp),%eax\n  cmp    -0x13c(%rbp),%eax\n  jl     L6\n  mov    -0x118(%rbp),%rax\n  mov    -0x8(%rbp),%rdx\n  sub    %fs:0x28,%rdx\n  je     L7\n  call   <__stack_chk_fail@plt>\nL7:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3669
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5255
            },
            "L1": {
                "label": "L1",
                "addr": 5070
            },
            "L2": {
                "label": "L2",
                "addr": 5063
            },
            "L3": {
                "label": "L3",
                "addr": 4890
            },
            "L4": {
                "label": "L4",
                "addr": 5200
            },
            "L5": {
                "label": "L5",
                "addr": 5248
            },
            "L6": {
                "label": "L6",
                "addr": 4555
            },
            "L7": {
                "label": "L7",
                "addr": 5300
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 158,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  xor    %eax,%eax\n  lea    0xe58(%rip),%rax        # 2000 <_fini+0xbf0>\n  mov    %rax,0x10(%rsp)\n  test   %esi,%esi\n  jle    13de <func0+0x265>\n  mov    %rdi,%r14\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x18(%rsp)\n  movl   $0x0,0xc(%rsp)\n  lea    0x20(%rsp),%r12\n  jmp    1264 <func0+0xeb>\n  mov    %r12,%rdi\n  call   1080 <strlen@plt>\n  movslq %eax,%rdx\n  mov    %bl,0x20(%rsp,%rdx,1)\n  add    $0x1,%eax\n  cltq\n  movb   $0x0,0x20(%rsp,%rax,1)\n  add    $0x1,%r13d\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     1218 <func0+0x9f>\n  movsbl %bl,%esi\n  mov    %r12,%rdi\n  call   10a0 <strchr@plt>\n  test   %rax,%rax\n  jne    11f4 <func0+0x7b>\n  jmp    11d7 <func0+0x5e>\n  mov    $0x0,%r13d\n  mov    0xc(%rsp),%eax\n  cmp    %r13d,%eax\n  jl     124b <func0+0xd2>\n  jne    1255 <func0+0xdc>\n  mov    0x10(%rsp),%rbx\n  mov    %rbx,%rsi\n  mov    %r15,%rdi\n  call   10b0 <strcmp@plt>\n  test   %eax,%eax\n  cmovns 0xc(%rsp),%r13d\n  mov    %r13d,0xc(%rsp)\n  cmovns %rbx,%r15\n  mov    %r15,0x10(%rsp)\n  jmp    1255 <func0+0xdc>\n  mov    %r13d,0xc(%rsp)\n  mov    %r15,0x10(%rsp)\n  add    $0x8,%r14\n  cmp    0x18(%rsp),%r14\n  je     13de <func0+0x265>\n  movq   $0x0,0x20(%rsp)\n  movq   $0x0,0x28(%rsp)\n  movq   $0x0,0x30(%rsp)\n  movq   $0x0,0x38(%rsp)\n  movq   $0x0,0x40(%rsp)\n  movq   $0x0,0x48(%rsp)\n  movq   $0x0,0x50(%rsp)\n  movq   $0x0,0x58(%rsp)\n  movq   $0x0,0x60(%rsp)\n  movq   $0x0,0x68(%rsp)\n  movq   $0x0,0x70(%rsp)\n  movq   $0x0,0x78(%rsp)\n  movq   $0x0,0x80(%rsp)\n  movq   $0x0,0x88(%rsp)\n  movq   $0x0,0x90(%rsp)\n  movq   $0x0,0x98(%rsp)\n  movq   $0x0,0xa0(%rsp)\n  movq   $0x0,0xa8(%rsp)\n  movq   $0x0,0xb0(%rsp)\n  movq   $0x0,0xb8(%rsp)\n  movq   $0x0,0xc0(%rsp)\n  movq   $0x0,0xc8(%rsp)\n  movq   $0x0,0xd0(%rsp)\n  movq   $0x0,0xd8(%rsp)\n  movq   $0x0,0xe0(%rsp)\n  movq   $0x0,0xe8(%rsp)\n  movq   $0x0,0xf0(%rsp)\n  movq   $0x0,0xf8(%rsp)\n  movq   $0x0,0x100(%rsp)\n  movq   $0x0,0x108(%rsp)\n  movq   $0x0,0x110(%rsp)\n  movq   $0x0,0x118(%rsp)\n  mov    (%r14),%r15\n  movzbl (%r15),%ebx\n  test   %bl,%bl\n  je     1212 <func0+0x99>\n  lea    0x1(%r15),%rbp\n  mov    $0x0,%r13d\n  jmp    1200 <func0+0x87>\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1408 <func0+0x28f>\n  mov    0x10(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  call   1090 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  xor    %eax,%eax\n  lea    D0(%rip),%rax\n  mov    %rax,0x10(%rsp)\n  test   %esi,%esi\n  jle    L0\n  mov    %rdi,%r14\n  lea    -0x1(%rsi),%eax\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x18(%rsp)\n  movl   $0x0,0xc(%rsp)\n  lea    0x20(%rsp),%r12\n  jmp    L1\nL4:\n  mov    %r12,%rdi\n  call   <strlen@plt>\n  movslq %eax,%rdx\n  mov    %bl,0x20(%rsp,%rdx,1)\n  add    $0x1,%eax\n  cltq\n  movb   $0x0,0x20(%rsp,%rax,1)\n  add    $0x1,%r13d\nL3:\n  add    $0x1,%rbp\n  movzbl -0x1(%rbp),%ebx\n  test   %bl,%bl\n  je     L2\nL8:\n  movsbl %bl,%esi\n  mov    %r12,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L3\n  jmp    L4\nL7:\n  mov    $0x0,%r13d\nL2:\n  mov    0xc(%rsp),%eax\n  cmp    %r13d,%eax\n  jl     L5\n  jne    L6\n  mov    0x10(%rsp),%rbx\n  mov    %rbx,%rsi\n  mov    %r15,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmovns 0xc(%rsp),%r13d\n  mov    %r13d,0xc(%rsp)\n  cmovns %rbx,%r15\n  mov    %r15,0x10(%rsp)\n  jmp    L6\nL5:\n  mov    %r13d,0xc(%rsp)\n  mov    %r15,0x10(%rsp)\nL6:\n  add    $0x8,%r14\n  cmp    0x18(%rsp),%r14\n  je     L0\nL1:\n  movq   $0x0,0x20(%rsp)\n  movq   $0x0,0x28(%rsp)\n  movq   $0x0,0x30(%rsp)\n  movq   $0x0,0x38(%rsp)\n  movq   $0x0,0x40(%rsp)\n  movq   $0x0,0x48(%rsp)\n  movq   $0x0,0x50(%rsp)\n  movq   $0x0,0x58(%rsp)\n  movq   $0x0,0x60(%rsp)\n  movq   $0x0,0x68(%rsp)\n  movq   $0x0,0x70(%rsp)\n  movq   $0x0,0x78(%rsp)\n  movq   $0x0,0x80(%rsp)\n  movq   $0x0,0x88(%rsp)\n  movq   $0x0,0x90(%rsp)\n  movq   $0x0,0x98(%rsp)\n  movq   $0x0,0xa0(%rsp)\n  movq   $0x0,0xa8(%rsp)\n  movq   $0x0,0xb0(%rsp)\n  movq   $0x0,0xb8(%rsp)\n  movq   $0x0,0xc0(%rsp)\n  movq   $0x0,0xc8(%rsp)\n  movq   $0x0,0xd0(%rsp)\n  movq   $0x0,0xd8(%rsp)\n  movq   $0x0,0xe0(%rsp)\n  movq   $0x0,0xe8(%rsp)\n  movq   $0x0,0xf0(%rsp)\n  movq   $0x0,0xf8(%rsp)\n  movq   $0x0,0x100(%rsp)\n  movq   $0x0,0x108(%rsp)\n  movq   $0x0,0x110(%rsp)\n  movq   $0x0,0x118(%rsp)\n  mov    (%r14),%r15\n  movzbl (%r15),%ebx\n  test   %bl,%bl\n  je     L7\n  lea    0x1(%r15),%rbp\n  mov    $0x0,%r13d\n  jmp    L8\nL0:\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L9\n  mov    0x10(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL9:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3672
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 5086
            },
            "L1": {
                "label": "L1",
                "addr": 4708
            },
            "L2": {
                "label": "L2",
                "addr": 4632
            },
            "L3": {
                "label": "L3",
                "addr": 4596
            },
            "L4": {
                "label": "L4",
                "addr": 4567
            },
            "L5": {
                "label": "L5",
                "addr": 4683
            },
            "L6": {
                "label": "L6",
                "addr": 4693
            },
            "L7": {
                "label": "L7",
                "addr": 4626
            },
            "L8": {
                "label": "L8",
                "addr": 4608
            },
            "L9": {
                "label": "L9",
                "addr": 5128
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 158,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  lea    0xe53(%rip),%rax        # 2000 <_fini+0xcc4>\n  mov    %rax,0x18(%rsp)\n  test   %esi,%esi\n  jle    12ef <func0+0x16f>\n  lea    -0x1(%rsi),%eax\n  movl   $0x0,0xc(%rsp)\n  mov    %rdi,%r12\n  lea    0x20(%rsp),%rbx\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x10(%rsp)\n  nopw   0x0(%rax,%rax,1)\n  mov    (%r12),%r13\n  pxor   %xmm0,%xmm0\n  movaps %xmm0,0x20(%rsp)\n  movzbl 0x0(%r13),%r15d\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  movaps %xmm0,0x60(%rsp)\n  movaps %xmm0,0x70(%rsp)\n  movaps %xmm0,0x80(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movaps %xmm0,0xa0(%rsp)\n  movaps %xmm0,0xb0(%rsp)\n  movaps %xmm0,0xc0(%rsp)\n  movaps %xmm0,0xd0(%rsp)\n  movaps %xmm0,0xe0(%rsp)\n  movaps %xmm0,0xf0(%rsp)\n  movaps %xmm0,0x100(%rsp)\n  movaps %xmm0,0x110(%rsp)\n  test   %r15b,%r15b\n  je     1330 <func0+0x1b0>\n  lea    0x1(%r13),%r14\n  xor    %ebp,%ebp\n  jmp    127d <func0+0xfd>\n  nopl   0x0(%rax)\n  movzbl (%r14),%r15d\n  add    $0x1,%r14\n  test   %r15b,%r15b\n  je     12b9 <func0+0x139>\n  movsbl %r15b,%esi\n  mov    %rbx,%rdi\n  call   10a0 <strchr@plt>\n  test   %rax,%rax\n  jne    1270 <func0+0xf0>\n  mov    %rbx,%rdi\n  add    $0x1,%r14\n  add    $0x1,%ebp\n  call   1080 <strlen@plt>\n  movslq %eax,%rsi\n  add    $0x1,%eax\n  mov    %r15b,0x20(%rsp,%rsi,1)\n  movzbl -0x1(%r14),%r15d\n  cltq\n  movb   $0x0,0x20(%rsp,%rax,1)\n  test   %r15b,%r15b\n  jne    127d <func0+0xfd>\n  cmp    %ebp,0xc(%rsp)\n  jl     1320 <func0+0x1a0>\n  jne    12e0 <func0+0x160>\n  mov    0x18(%rsp),%r14\n  mov    %r13,%rdi\n  mov    %r14,%rsi\n  call   10b0 <strcmp@plt>\n  test   %eax,%eax\n  cmovns %r14,%r13\n  mov    %r13,0x18(%rsp)\n  nopl   0x0(%rax)\n  add    $0x8,%r12\n  cmp    0x10(%rsp),%r12\n  jne    11e0 <func0+0x60>\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1334 <func0+0x1b4>\n  mov    0x18(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  mov    %ebp,0xc(%rsp)\n  mov    %r13,0x18(%rsp)\n  jmp    12e0 <func0+0x160>\n  nopl   0x0(%rax,%rax,1)\n  xor    %ebp,%ebp\n  jmp    12b9 <func0+0x139>\n  call   1090 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  lea    D0(%rip),%rax\n  mov    %rax,0x18(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movl   $0x0,0xc(%rsp)\n  mov    %rdi,%r12\n  lea    0x20(%rsp),%rbx\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x10(%rsp)\n  nopw   0x0(%rax,%rax,1)\nL7:\n  mov    (%r12),%r13\n  pxor   %xmm0,%xmm0\n  movaps %xmm0,0x20(%rsp)\n  movzbl 0x0(%r13),%r15d\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  movaps %xmm0,0x60(%rsp)\n  movaps %xmm0,0x70(%rsp)\n  movaps %xmm0,0x80(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movaps %xmm0,0xa0(%rsp)\n  movaps %xmm0,0xb0(%rsp)\n  movaps %xmm0,0xc0(%rsp)\n  movaps %xmm0,0xd0(%rsp)\n  movaps %xmm0,0xe0(%rsp)\n  movaps %xmm0,0xf0(%rsp)\n  movaps %xmm0,0x100(%rsp)\n  movaps %xmm0,0x110(%rsp)\n  test   %r15b,%r15b\n  je     L1\n  lea    0x1(%r13),%r14\n  xor    %ebp,%ebp\n  jmp    L2\n  nopl   0x0(%rax)\nL4:\n  movzbl (%r14),%r15d\n  add    $0x1,%r14\n  test   %r15b,%r15b\n  je     L3\nL2:\n  movsbl %r15b,%esi\n  mov    %rbx,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  jne    L4\n  mov    %rbx,%rdi\n  add    $0x1,%r14\n  add    $0x1,%ebp\n  call   <strlen@plt>\n  movslq %eax,%rsi\n  add    $0x1,%eax\n  mov    %r15b,0x20(%rsp,%rsi,1)\n  movzbl -0x1(%r14),%r15d\n  cltq\n  movb   $0x0,0x20(%rsp,%rax,1)\n  test   %r15b,%r15b\n  jne    L2\nL3:\n  cmp    %ebp,0xc(%rsp)\n  jl     L5\n  jne    L6\n  mov    0x18(%rsp),%r14\n  mov    %r13,%rdi\n  mov    %r14,%rsi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmovns %r14,%r13\n  mov    %r13,0x18(%rsp)\n  nopl   0x0(%rax)\nL6:\n  add    $0x8,%r12\n  cmp    0x10(%rsp),%r12\n  jne    L7\nL0:\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L8\n  mov    0x18(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL5:\n  mov    %ebp,0xc(%rsp)\n  mov    %r13,0x18(%rsp)\n  jmp    L6\n  nopl   0x0(%rax,%rax,1)\nL1:\n  xor    %ebp,%ebp\n  jmp    L3\nL8:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3667
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4847
            },
            "L1": {
                "label": "L1",
                "addr": 4912
            },
            "L2": {
                "label": "L2",
                "addr": 4733
            },
            "L3": {
                "label": "L3",
                "addr": 4793
            },
            "L4": {
                "label": "L4",
                "addr": 4720
            },
            "L5": {
                "label": "L5",
                "addr": 4896
            },
            "L6": {
                "label": "L6",
                "addr": 4832
            },
            "L7": {
                "label": "L7",
                "addr": 4576
            },
            "L8": {
                "label": "L8",
                "addr": 4916
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 158,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n\nchar *func0(char *words[], int count) {\n    char *max = \"\";\n    int maxu = 0;\n    for (int i = 0; i < count; i++) {\n        char unique[256] = {0};\n        int unique_count = 0;\n        for (int j = 0; words[i][j] != '\\0'; j++) {\n            if (!strchr(unique, words[i][j])) {\n                int len = strlen(unique);\n                unique[len] = words[i][j];\n                unique[len + 1] = '\\0';\n                unique_count++;\n            }\n        }\n        if (unique_count > maxu || (unique_count == maxu && strcmp(words[i], max) < 0)) {\n            max = words[i];\n            maxu = unique_count;\n        }\n    }\n    return max;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main() {\n    char *words1[] = {\"name\", \"of\", \"string\"};\n    assert(strcmp(func0(words1, 3), \"string\") == 0);\n\n    char *words2[] = {\"name\", \"enam\", \"game\"};\n    assert(strcmp(func0(words2, 3), \"enam\") == 0);\n\n    char *words3[] = {\"aaaaaaa\", \"bb\", \"cc\"};\n    assert(strcmp(func0(words3, 3), \"aaaaaaa\") == 0);\n\n    char *words4[] = {\"abc\", \"cba\"};\n    assert(strcmp(func0(words4, 2), \"abc\") == 0);\n\n    char *words5[] = {\"play\", \"this\", \"game\", \"of\", \"footbott\"};\n    assert(strcmp(func0(words5, 5), \"footbott\") == 0);\n\n    char *words6[] = {\"we\", \"are\", \"gonna\", \"rock\"};\n    assert(strcmp(func0(words6, 4), \"gonna\") == 0);\n\n    char *words7[] = {\"we\", \"are\", \"a\", \"mad\", \"nation\"};\n    assert(strcmp(func0(words7, 5), \"nation\") == 0);\n\n    char *words8[] = {\"this\", \"is\", \"a\", \"prrk\"};\n    assert(strcmp(func0(words8, 4), \"this\") == 0);\n\n    char *words9[] = {\"b\"};\n    assert(strcmp(func0(words9, 1), \"b\") == 0);\n\n    char *words10[] = {\"play\", \"play\", \"play\"};\n    assert(strcmp(func0(words10, 3), \"play\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  lea    0xe53(%rip),%rax        # 2000 <_fini+0xcb4>\n  mov    %rax,0x18(%rsp)\n  test   %esi,%esi\n  jle    12c7 <func0+0x147>\n  lea    -0x1(%rsi),%eax\n  movl   $0x0,0xc(%rsp)\n  mov    %rdi,%r12\n  lea    0x20(%rsp),%rbx\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x10(%rsp)\n  nopw   0x0(%rax,%rax,1)\n  mov    (%r12),%r13\n  pxor   %xmm0,%xmm0\n  movaps %xmm0,0x20(%rsp)\n  movzbl 0x0(%r13),%r15d\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  movaps %xmm0,0x60(%rsp)\n  movaps %xmm0,0x70(%rsp)\n  movaps %xmm0,0x80(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movaps %xmm0,0xa0(%rsp)\n  movaps %xmm0,0xb0(%rsp)\n  movaps %xmm0,0xc0(%rsp)\n  movaps %xmm0,0xd0(%rsp)\n  movaps %xmm0,0xe0(%rsp)\n  movaps %xmm0,0xf0(%rsp)\n  movaps %xmm0,0x100(%rsp)\n  movaps %xmm0,0x110(%rsp)\n  test   %r15b,%r15b\n  je     1340 <func0+0x1c0>\n  lea    0x1(%r13),%r14\n  xor    %ebp,%ebp\n  nopw   0x0(%rax,%rax,1)\n  movsbl %r15b,%esi\n  mov    %rbx,%rdi\n  call   10a0 <strchr@plt>\n  test   %rax,%rax\n  je     12f8 <func0+0x178>\n  movzbl (%r14),%r15d\n  add    $0x1,%r14\n  test   %r15b,%r15b\n  jne    1270 <func0+0xf0>\n  cmp    %ebp,0xc(%rsp)\n  jl     1331 <func0+0x1b1>\n  jne    12b8 <func0+0x138>\n  mov    0x18(%rsp),%r14\n  mov    %r13,%rdi\n  mov    %r14,%rsi\n  call   10b0 <strcmp@plt>\n  test   %eax,%eax\n  cmovns %r14,%r13\n  mov    %r13,0x18(%rsp)\n  nopl   (%rax)\n  add    $0x8,%r12\n  cmp    0x10(%rsp),%r12\n  jne    11e0 <func0+0x60>\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    1347 <func0+0x1c7>\n  mov    0x18(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  mov    %rbx,%rdi\n  add    $0x1,%r14\n  add    $0x1,%ebp\n  call   1080 <strlen@plt>\n  movslq %eax,%rsi\n  add    $0x1,%eax\n  cltq\n  mov    %r15b,0x20(%rsp,%rsi,1)\n  movb   $0x0,0x20(%rsp,%rax,1)\n  movzbl -0x1(%r14),%r15d\n  test   %r15b,%r15b\n  jne    1270 <func0+0xf0>\n  cmp    %ebp,0xc(%rsp)\n  jge    1298 <func0+0x118>\n  mov    %ebp,0xc(%rsp)\n  mov    %r13,0x18(%rsp)\n  jmp    12b8 <func0+0x138>\n  nop\n  xor    %ebp,%ebp\n  jmp    128e <func0+0x10e>\n  call   1090 <__stack_chk_fail@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x138,%rsp\n  mov    %fs:0x28,%rax\n  mov    %rax,0x128(%rsp)\n  lea    D0(%rip),%rax\n  mov    %rax,0x18(%rsp)\n  test   %esi,%esi\n  jle    L0\n  lea    -0x1(%rsi),%eax\n  movl   $0x0,0xc(%rsp)\n  mov    %rdi,%r12\n  lea    0x20(%rsp),%rbx\n  lea    0x8(%rdi,%rax,8),%rax\n  mov    %rax,0x10(%rsp)\n  nopw   0x0(%rax,%rax,1)\nL6:\n  mov    (%r12),%r13\n  pxor   %xmm0,%xmm0\n  movaps %xmm0,0x20(%rsp)\n  movzbl 0x0(%r13),%r15d\n  movaps %xmm0,0x30(%rsp)\n  movaps %xmm0,0x40(%rsp)\n  movaps %xmm0,0x50(%rsp)\n  movaps %xmm0,0x60(%rsp)\n  movaps %xmm0,0x70(%rsp)\n  movaps %xmm0,0x80(%rsp)\n  movaps %xmm0,0x90(%rsp)\n  movaps %xmm0,0xa0(%rsp)\n  movaps %xmm0,0xb0(%rsp)\n  movaps %xmm0,0xc0(%rsp)\n  movaps %xmm0,0xd0(%rsp)\n  movaps %xmm0,0xe0(%rsp)\n  movaps %xmm0,0xf0(%rsp)\n  movaps %xmm0,0x100(%rsp)\n  movaps %xmm0,0x110(%rsp)\n  test   %r15b,%r15b\n  je     L1\n  lea    0x1(%r13),%r14\n  xor    %ebp,%ebp\n  nopw   0x0(%rax,%rax,1)\nL3:\n  movsbl %r15b,%esi\n  mov    %rbx,%rdi\n  call   <strchr@plt>\n  test   %rax,%rax\n  je     L2\n  movzbl (%r14),%r15d\n  add    $0x1,%r14\n  test   %r15b,%r15b\n  jne    L3\nL9:\n  cmp    %ebp,0xc(%rsp)\n  jl     L4\nL8:\n  jne    L5\n  mov    0x18(%rsp),%r14\n  mov    %r13,%rdi\n  mov    %r14,%rsi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  cmovns %r14,%r13\n  mov    %r13,0x18(%rsp)\n  nopl   (%rax)\nL5:\n  add    $0x8,%r12\n  cmp    0x10(%rsp),%r12\n  jne    L6\nL0:\n  mov    0x128(%rsp),%rax\n  sub    %fs:0x28,%rax\n  jne    L7\n  mov    0x18(%rsp),%rax\n  add    $0x138,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL2:\n  mov    %rbx,%rdi\n  add    $0x1,%r14\n  add    $0x1,%ebp\n  call   <strlen@plt>\n  movslq %eax,%rsi\n  add    $0x1,%eax\n  cltq\n  mov    %r15b,0x20(%rsp,%rsi,1)\n  movb   $0x0,0x20(%rsp,%rax,1)\n  movzbl -0x1(%r14),%r15d\n  test   %r15b,%r15b\n  jne    L3\n  cmp    %ebp,0xc(%rsp)\n  jge    L8\nL4:\n  mov    %ebp,0xc(%rsp)\n  mov    %r13,0x18(%rsp)\n  jmp    L5\n  nop\nL1:\n  xor    %ebp,%ebp\n  jmp    L9\nL7:\n  call   <__stack_chk_fail@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3667
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4807
            },
            "L1": {
                "label": "L1",
                "addr": 4928
            },
            "L2": {
                "label": "L2",
                "addr": 4856
            },
            "L3": {
                "label": "L3",
                "addr": 4720
            },
            "L4": {
                "label": "L4",
                "addr": 4913
            },
            "L5": {
                "label": "L5",
                "addr": 4792
            },
            "L6": {
                "label": "L6",
                "addr": 4576
            },
            "L7": {
                "label": "L7",
                "addr": 4935
            },
            "L8": {
                "label": "L8",
                "addr": 4760
            },
            "L9": {
                "label": "L9",
                "addr": 4750
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 159,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    %edx,-0xc(%rbp)\n  mov    %rcx,-0x18(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jle    1134 <func0+0x3b>\n  mov    -0x4(%rbp),%edx\n  mov    -0xc(%rbp),%eax\n  add    %eax,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x0,(%rax)\n  jmp    1152 <func0+0x59>\n  mov    -0x4(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %eax,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x4(%rbp)\n  mov    %esi,-0x8(%rbp)\n  mov    %edx,-0xc(%rbp)\n  mov    %rcx,-0x18(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0xc(%rbp),%eax\n  jle    L0\n  mov    -0x4(%rbp),%edx\n  mov    -0xc(%rbp),%eax\n  add    %eax,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  add    $0x4,%rax\n  movl   $0x0,(%rax)\n  jmp    L1\nL0:\n  mov    -0x4(%rbp),%edx\n  mov    -0x8(%rbp),%eax\n  add    %eax,%edx\n  mov    -0x18(%rbp),%rax\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%rax\n  lea    0x4(%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\nL1:\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4404
            },
            "L1": {
                "label": "L1",
                "addr": 4434
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 159,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    110e <func0+0x15>\n  add    %edx,%edi\n  mov    $0x0,%edx\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret\n  add    %esi,%edi\n  sub    %esi,%edx\n  jmp    1108 <func0+0xf>",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    L0\n  add    %edx,%edi\n  mov    $0x0,%edx\nL1:\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret\nL0:\n  add    %esi,%edi\n  sub    %esi,%edx\n  jmp    L1",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4366
            },
            "L1": {
                "label": "L1",
                "addr": 4360
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 159,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    1118 <func0+0x18>\n  add    %edx,%edi\n  xor    %edx,%edx\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret\n  nopw   0x0(%rax,%rax,1)\n  add    %esi,%edi\n  sub    %esi,%edx\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    L0\n  add    %edx,%edi\n  xor    %edx,%edx\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret\n  nopw   0x0(%rax,%rax,1)\nL0:\n  add    %esi,%edi\n  sub    %esi,%edx\n  mov    %edi,(%rcx)\n  mov    %edx,0x4(%rcx)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4376
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 159,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int number, int need, int remaining, int result[2]) {\n    if (need > remaining) {\n        result[0] = number + remaining;\n        result[1] = 0;\n    } else {\n        result[0] = number + need;\n        result[1] = remaining - need;\n    }\n}",
        "c_test": "#include <assert.h>\n\nint issame(int a[2], int b[2]) {\n    return a[0] == b[0] && a[1] == b[1];\n}\n\nint main() {\n    int result[2];\n\n    func0(5, 6, 10, result);\n    assert(issame(result, (const int[]){11, 4}));\n\n    func0(4, 8, 9, result);\n    assert(issame(result, (const int[]){12, 1}));\n\n    func0(1, 10, 10, result);\n    assert(issame(result, (const int[]){11, 0}));\n\n    func0(2, 11, 5, result);\n    assert(issame(result, (const int[]){7, 0}));\n\n    func0(4, 5, 7, result);\n    assert(issame(result, (const int[]){9, 2}));\n\n    func0(4, 5, 1, result);\n    assert(issame(result, (const int[]){5, 0}));\n    \n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    1120 <func0+0x20>\n  lea    (%rdx,%rdi,1),%eax\n  xor    %edx,%edx\n  movd   %eax,%xmm0\n  movd   %edx,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rcx)\n  ret\n  xchg   %ax,%ax\n  lea    (%rsi,%rdi,1),%eax\n  sub    %esi,%edx\n  movd   %eax,%xmm0\n  movd   %edx,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rcx)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  cmp    %edx,%esi\n  jle    L0\n  lea    (%rdx,%rdi,1),%eax\n  xor    %edx,%edx\n  movd   %eax,%xmm0\n  movd   %edx,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rcx)\n  ret\n  xchg   %ax,%ax\nL0:\n  lea    (%rsi,%rdi,1),%eax\n  sub    %esi,%edx\n  movd   %eax,%xmm0\n  movd   %edx,%xmm1\n  punpckldq %xmm1,%xmm0\n  movq   %xmm0,(%rcx)\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4384
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 160,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %edx,-0x44(%rbp)\n  mov    %ecx,-0x48(%rbp)\n  mov    -0x48(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   10a0 <malloc@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x48(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   10a0 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    1210 <func0+0x97>\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x40(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x24(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x10(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x24(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x24(%rbp)\n  mov    -0x24(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     11c6 <func0+0x4d>\n  movl   $0x0,-0x20(%rbp)\n  jmp    1452 <func0+0x2d9>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0xdbe(%rip),%rdx        # 2000 <_fini+0x568>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    144e <func0+0x2d5>\n  jmp    1297 <func0+0x11e>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    1257 <func0+0xde>\n  jmp    1328 <func0+0x1af>\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    12e0 <func0+0x167>\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  pxor   %xmm0,%xmm0\n  cvtsi2sd %eax,%xmm0\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %eax,%xmm2\n  movq   %xmm2,%rax\n  movapd %xmm0,%xmm1\n  movq   %rax,%xmm0\n  call   10b0 <pow@plt>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  cvttsd2si %xmm0,%eax\n  mov    %eax,(%rdx)\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x20(%rbp)\n  mov    -0x20(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     1224 <func0+0xab>\n  movl   $0x0,-0x1c(%rbp)\n  jmp    175f <func0+0x5e6>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0xb7b(%rip),%rdx        # 2003 <_fini+0x56b>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  je     150a <func0+0x391>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0xb50(%rip),%rdx        # 2005 <_fini+0x56d>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    175b <func0+0x5e2>\n  jmp    150a <func0+0x391>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    14ca <func0+0x351>\n  jmp    159b <func0+0x422>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    1553 <func0+0x3da>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x9fb(%rip),%rdx        # 2003 <_fini+0x56b>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    16a4 <func0+0x52b>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    -0x8(%rbp),%rdx\n  add    %rsi,%rdx\n  mov    (%rdx),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    -0x10(%rbp),%rdx\n  add    %rsi,%rdx\n  imul   %ecx,%eax\n  mov    %eax,(%rdx)\n  jmp    172a <func0+0x5b1>\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x10(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edi\n  mov    -0x1c(%rbp),%ecx\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,4),%rsi\n  mov    -0x8(%rbp),%rcx\n  add    %rsi,%rcx\n  mov    (%rcx),%ecx\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,4),%rsi\n  mov    -0x10(%rbp),%rcx\n  add    %rsi,%rcx\n  cltd\n  idiv   %edi\n  mov    %eax,(%rcx)\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x1c(%rbp)\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     146a <func0+0x2f1>\n  movl   $0x0,-0x18(%rbp)\n  jmp    1a64 <func0+0x8eb>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x873(%rip),%rdx        # 2008 <_fini+0x570>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  je     1817 <func0+0x69e>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x848(%rip),%rdx        # 200a <_fini+0x572>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    1a60 <func0+0x8e7>\n  jmp    1817 <func0+0x69e>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    17d7 <func0+0x65e>\n  jmp    18a8 <func0+0x72f>\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    1860 <func0+0x6e7>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    0x6f3(%rip),%rdx        # 2008 <_fini+0x570>\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    19ae <func0+0x835>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x8(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x10(%rbp),%rax\n  add    %rsi,%rax\n  add    %ecx,%edx\n  mov    %edx,(%rax)\n  jmp    1a2f <func0+0x8b6>\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x10(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%ecx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x8(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x10(%rbp),%rax\n  add    %rsi,%rax\n  sub    %ecx,%edx\n  mov    %edx,(%rax)\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x18(%rbp)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     1777 <func0+0x5fe>\n  mov    -0x10(%rbp),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   1080 <free@plt>\n  mov    -0x14(%rbp),%eax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x50,%rsp\n  mov    %rdi,-0x38(%rbp)\n  mov    %rsi,-0x40(%rbp)\n  mov    %edx,-0x44(%rbp)\n  mov    %ecx,-0x48(%rbp)\n  mov    -0x48(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x10(%rbp)\n  mov    -0x48(%rbp),%eax\n  cltq\n  shl    $0x2,%rax\n  mov    %rax,%rdi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  movl   $0x0,-0x24(%rbp)\n  jmp    L0\nL1:\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x40(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x24(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x10(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\n  mov    -0x24(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x24(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x24(%rbp)\nL0:\n  mov    -0x24(%rbp),%eax\n  cmp    -0x48(%rbp),%eax\n  jl     L1\n  movl   $0x0,-0x20(%rbp)\n  jmp    L2\nL8:\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D0(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L3\n  jmp    L4\nL5:\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL4:\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L5\n  jmp    L6\nL7:\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL6:\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L7\n  mov    -0x20(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  pxor   %xmm0,%xmm0\n  cvtsi2sd %eax,%xmm0\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  pxor   %xmm2,%xmm2\n  cvtsi2sd %eax,%xmm2\n  movq   %xmm2,%rax\n  movapd %xmm0,%xmm1\n  movq   %rax,%xmm0\n  call   <pow@plt>\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rax,%rdx\n  cvttsd2si %xmm0,%eax\n  mov    %eax,(%rdx)\n  mov    -0x20(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x20(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL3:\n  addl   $0x1,-0x20(%rbp)\nL2:\n  mov    -0x20(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     L8\n  movl   $0x0,-0x1c(%rbp)\n  jmp    L9\nL17:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L10\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D2(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L11\n  jmp    L10\nL12:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL10:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L12\n  jmp    L13\nL14:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL13:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L14\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D1(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L15\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x1c(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    -0x8(%rbp),%rdx\n  add    %rsi,%rdx\n  mov    (%rdx),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    -0x10(%rbp),%rdx\n  add    %rsi,%rdx\n  imul   %ecx,%eax\n  mov    %eax,(%rdx)\n  jmp    L16\nL15:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x10(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rdx),%edi\n  mov    -0x1c(%rbp),%ecx\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,4),%rsi\n  mov    -0x8(%rbp),%rcx\n  add    %rsi,%rcx\n  mov    (%rcx),%ecx\n  movslq %ecx,%rcx\n  lea    0x0(,%rcx,4),%rsi\n  mov    -0x10(%rbp),%rcx\n  add    %rsi,%rcx\n  cltd\n  idiv   %edi\n  mov    %eax,(%rcx)\nL16:\n  mov    -0x1c(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x1c(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL11:\n  addl   $0x1,-0x1c(%rbp)\nL9:\n  mov    -0x1c(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     L17\n  movl   $0x0,-0x18(%rbp)\n  jmp    L18\nL26:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D3(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L19\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D4(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L20\n  jmp    L19\nL21:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL19:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L21\n  jmp    L22\nL23:\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL22:\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cmp    %eax,%edx\n  jne    L23\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,8),%rdx\n  mov    -0x38(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%rax\n  lea    D3(%rip),%rdx\n  mov    %rdx,%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L24\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%ecx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x8(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x10(%rbp),%rax\n  add    %rsi,%rax\n  add    %ecx,%edx\n  mov    %edx,(%rax)\n  jmp    L25\nL24:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x10(%rbp),%rax\n  add    %rdx,%rax\n  mov    (%rax),%edx\n  mov    -0x18(%rbp),%eax\n  cltq\n  add    $0x1,%rax\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x8(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rcx\n  mov    -0x10(%rbp),%rax\n  add    %rcx,%rax\n  mov    (%rax),%ecx\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x8(%rbp),%rax\n  add    %rsi,%rax\n  mov    (%rax),%eax\n  cltq\n  lea    0x0(,%rax,4),%rsi\n  mov    -0x10(%rbp),%rax\n  add    %rsi,%rax\n  sub    %ecx,%edx\n  mov    %edx,(%rax)\nL25:\n  mov    -0x18(%rbp),%eax\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x8(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x18(%rbp),%edx\n  movslq %edx,%rdx\n  add    $0x1,%rdx\n  lea    0x0(,%rdx,4),%rcx\n  mov    -0x8(%rbp),%rdx\n  add    %rcx,%rdx\n  mov    (%rax),%eax\n  mov    %eax,(%rdx)\nL20:\n  addl   $0x1,-0x18(%rbp)\nL18:\n  mov    -0x18(%rbp),%eax\n  cmp    -0x44(%rbp),%eax\n  jl     L26\n  mov    -0x10(%rbp),%rax\n  mov    (%rax),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x10(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x8(%rbp),%rax\n  mov    %rax,%rdi\n  call   <free@plt>\n  mov    -0x14(%rbp),%eax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3518
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8195,
                "bias": [
                    2939,
                    2555
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8197,
                "bias": [
                    2896
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8200,
                "bias": [
                    2163,
                    1779
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8202,
                "bias": [
                    2120
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4624
            },
            "L1": {
                "label": "L1",
                "addr": 4550
            },
            "L2": {
                "label": "L2",
                "addr": 5202
            },
            "L3": {
                "label": "L3",
                "addr": 5198
            },
            "L4": {
                "label": "L4",
                "addr": 4759
            },
            "L5": {
                "label": "L5",
                "addr": 4695
            },
            "L6": {
                "label": "L6",
                "addr": 4904
            },
            "L7": {
                "label": "L7",
                "addr": 4832
            },
            "L8": {
                "label": "L8",
                "addr": 4644
            },
            "L9": {
                "label": "L9",
                "addr": 5983
            },
            "L10": {
                "label": "L10",
                "addr": 5386
            },
            "L11": {
                "label": "L11",
                "addr": 5979
            },
            "L12": {
                "label": "L12",
                "addr": 5322
            },
            "L13": {
                "label": "L13",
                "addr": 5531
            },
            "L14": {
                "label": "L14",
                "addr": 5459
            },
            "L15": {
                "label": "L15",
                "addr": 5796
            },
            "L16": {
                "label": "L16",
                "addr": 5930
            },
            "L17": {
                "label": "L17",
                "addr": 5226
            },
            "L18": {
                "label": "L18",
                "addr": 6756
            },
            "L19": {
                "label": "L19",
                "addr": 6167
            },
            "L20": {
                "label": "L20",
                "addr": 6752
            },
            "L21": {
                "label": "L21",
                "addr": 6103
            },
            "L22": {
                "label": "L22",
                "addr": 6312
            },
            "L23": {
                "label": "L23",
                "addr": 6240
            },
            "L24": {
                "label": "L24",
                "addr": 6574
            },
            "L25": {
                "label": "L25",
                "addr": 6703
            },
            "L26": {
                "label": "L26",
                "addr": 6007
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "2a2a002a002f2f002b002d00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"**\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"*\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"//\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"+\""
                },
                "0x200a": {
                    "type": "string",
                    "value": "\"-\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 160,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x28(%rsp)\n  mov    %rsi,%r12\n  mov    %edx,%ebp\n  mov    %ecx,%r14d\n  movslq %ecx,%rbx\n  shl    $0x2,%rbx\n  mov    %rbx,%rdi\n  call   10a0 <malloc@plt>\n  mov    %rax,%r13\n  mov    %rbx,%rdi\n  call   10a0 <malloc@plt>\n  mov    %rax,%rbx\n  test   %r14d,%r14d\n  jle    11d7 <func0+0x5e>\n  mov    %r14d,%ecx\n  mov    $0x0,%eax\n  mov    (%r12,%rax,4),%edx\n  mov    %edx,0x0(%r13,%rax,4)\n  mov    %eax,(%rbx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    11c2 <func0+0x49>\n  test   %ebp,%ebp\n  jle    146a <func0+0x2f1>\n  mov    0x28(%rsp),%r15\n  mov    %r15,0x18(%rsp)\n  mov    %rbx,%r14\n  mov    %ebp,%ebp\n  lea    (%rbx,%rbp,4),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %rbx,%r12\n  jmp    1248 <func0+0xcf>\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x10(%rsp)\n  cltq\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rdi,0x20(%rsp)\n  pxor   %xmm0,%xmm0\n  cvtsi2sdl (%rdi),%xmm0\n  pxor   %xmm1,%xmm1\n  cvtsi2sdl 0x0(%r13,%rsi,1),%xmm1\n  call   10b0 <pow@plt>\n  cvttsd2si %xmm0,%eax\n  mov    0x20(%rsp),%rdi\n  mov    %eax,(%rdi)\n  mov    0x10(%rsp),%eax\n  mov    %eax,0x4(%rbp)\n  add    $0x8,%r15\n  add    $0x4,%r12\n  cmp    0x8(%rsp),%r12\n  je     12af <func0+0x136>\n  lea    0xdb1(%rip),%rsi        # 2000 <_fini+0xb70>\n  mov    (%r15),%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    1239 <func0+0xc0>\n  mov    %r12,%rbp\n  mov    (%r12),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     127a <func0+0x101>\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    126c <func0+0xf3>\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%rsi\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     11fc <func0+0x83>\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    1293 <func0+0x11a>\n  jmp    11fc <func0+0x83>\n  mov    %rbx,%r15\n  mov    0x28(%rsp),%rax\n  mov    %rax,0x20(%rsp)\n  jmp    134e <func0+0x1d5>\n  mov    %r15,%rbp\n  mov    (%r15),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     12df <func0+0x166>\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    12d1 <func0+0x158>\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%r12\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     130b <func0+0x192>\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%r12\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    12f4 <func0+0x17b>\n  lea    0xcef(%rip),%rsi        # 2001 <_fini+0xb71>\n  mov    0x10(%rsp),%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    138c <func0+0x213>\n  movslq 0x0(%rbp),%rax\n  lea    0x0(%r13,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   0x0(%r13,%r12,1),%eax\n  mov    %eax,(%rdx)\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x4(%rbp)\n  addq   $0x8,0x20(%rsp)\n  add    $0x4,%r15\n  cmp    0x8(%rsp),%r15\n  je     1423 <func0+0x2aa>\n  mov    0x20(%rsp),%rax\n  mov    (%rax),%rax\n  mov    %rax,0x10(%rsp)\n  lea    0xc9f(%rip),%rsi        # 2001 <_fini+0xb71>\n  mov    %rax,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  je     12c1 <func0+0x148>\n  lea    0xc8a(%rip),%rsi        # 2003 <_fini+0xb73>\n  mov    0x10(%rsp),%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    1339 <func0+0x1c0>\n  jmp    12c1 <func0+0x148>\n  movslq 0x0(%rbp),%rax\n  lea    0x0(%r13,%rax,4),%rcx\n  mov    (%rcx),%eax\n  cltd\n  idivl  0x0(%r13,%r12,1)\n  mov    %eax,(%rcx)\n  jmp    1333 <func0+0x1ba>\n  mov    %r14,%rbp\n  mov    (%r14),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     13bf <func0+0x246>\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    13b1 <func0+0x238>\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%r12\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     13eb <func0+0x272>\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%r12\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    13d4 <func0+0x25b>\n  lea    0xc14(%rip),%rsi        # 2006 <_fini+0xb76>\n  mov    %r15,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    145a <func0+0x2e1>\n  movslq 0x0(%rbp),%rax\n  mov    0x0(%r13,%r12,1),%edx\n  add    %edx,0x0(%r13,%rax,4)\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x4(%rbp)\n  addq   $0x8,0x18(%rsp)\n  add    $0x4,%r14\n  cmp    0x8(%rsp),%r14\n  je     146a <func0+0x2f1>\n  mov    0x18(%rsp),%rax\n  mov    (%rax),%r15\n  lea    0xbd4(%rip),%rsi        # 2006 <_fini+0xb76>\n  mov    %r15,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  je     13a1 <func0+0x228>\n  lea    0xbbf(%rip),%rsi        # 2008 <_fini+0xb78>\n  mov    %r15,%rdi\n  call   1090 <strcmp@plt>\n  test   %eax,%eax\n  jne    1412 <func0+0x299>\n  jmp    13a1 <func0+0x228>\n  movslq 0x0(%rbp),%rax\n  mov    0x0(%r13,%r12,1),%edx\n  sub    %edx,0x0(%r13,%rax,4)\n  jmp    140c <func0+0x293>\n  mov    0x0(%r13),%ebp\n  mov    %r13,%rdi\n  call   1080 <free@plt>\n  mov    %rbx,%rdi\n  call   1080 <free@plt>\n  mov    %ebp,%eax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x38,%rsp\n  mov    %rdi,0x28(%rsp)\n  mov    %rsi,%r12\n  mov    %edx,%ebp\n  mov    %ecx,%r14d\n  movslq %ecx,%rbx\n  shl    $0x2,%rbx\n  mov    %rbx,%rdi\n  call   <malloc@plt>\n  mov    %rax,%r13\n  mov    %rbx,%rdi\n  call   <malloc@plt>\n  mov    %rax,%rbx\n  test   %r14d,%r14d\n  jle    L0\n  mov    %r14d,%ecx\n  mov    $0x0,%eax\nL1:\n  mov    (%r12,%rax,4),%edx\n  mov    %edx,0x0(%r13,%rax,4)\n  mov    %eax,(%rbx,%rax,4)\n  add    $0x1,%rax\n  cmp    %rcx,%rax\n  jne    L1\nL0:\n  test   %ebp,%ebp\n  jle    L2\n  mov    0x28(%rsp),%r15\n  mov    %r15,0x18(%rsp)\n  mov    %rbx,%r14\n  mov    %ebp,%ebp\n  lea    (%rbx,%rbp,4),%rax\n  mov    %rax,0x8(%rsp)\n  mov    %rbx,%r12\n  jmp    L3\nL8:\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x10(%rsp)\n  cltq\n  lea    0x0(%r13,%rax,4),%rdi\n  mov    %rdi,0x20(%rsp)\n  pxor   %xmm0,%xmm0\n  cvtsi2sdl (%rdi),%xmm0\n  pxor   %xmm1,%xmm1\n  cvtsi2sdl 0x0(%r13,%rsi,1),%xmm1\n  call   <pow@plt>\n  cvttsd2si %xmm0,%eax\n  mov    0x20(%rsp),%rdi\n  mov    %eax,(%rdi)\n  mov    0x10(%rsp),%eax\n  mov    %eax,0x4(%rbp)\nL5:\n  add    $0x8,%r15\n  add    $0x4,%r12\n  cmp    0x8(%rsp),%r12\n  je     L4\nL3:\n  lea    D0(%rip),%rsi\n  mov    (%r15),%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L5\n  mov    %r12,%rbp\n  mov    (%r12),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L6\nL7:\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    L7\nL6:\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%rsi\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L8\nL9:\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%rsi\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    L9\n  jmp    L8\nL4:\n  mov    %rbx,%r15\n  mov    0x28(%rsp),%rax\n  mov    %rax,0x20(%rsp)\n  jmp    L10\nL17:\n  mov    %r15,%rbp\n  mov    (%r15),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L11\nL12:\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    L12\nL11:\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%r12\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L13\nL14:\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%r12\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    L14\nL13:\n  lea    D1(%rip),%rsi\n  mov    0x10(%rsp),%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L15\n  movslq 0x0(%rbp),%rax\n  lea    0x0(%r13,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   0x0(%r13,%r12,1),%eax\n  mov    %eax,(%rdx)\nL19:\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x4(%rbp)\nL18:\n  addq   $0x8,0x20(%rsp)\n  add    $0x4,%r15\n  cmp    0x8(%rsp),%r15\n  je     L16\nL10:\n  mov    0x20(%rsp),%rax\n  mov    (%rax),%rax\n  mov    %rax,0x10(%rsp)\n  lea    D1(%rip),%rsi\n  mov    %rax,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L17\n  lea    D2(%rip),%rsi\n  mov    0x10(%rsp),%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L18\n  jmp    L17\nL15:\n  movslq 0x0(%rbp),%rax\n  lea    0x0(%r13,%rax,4),%rcx\n  mov    (%rcx),%eax\n  cltd\n  idivl  0x0(%r13,%r12,1)\n  mov    %eax,(%rcx)\n  jmp    L19\nL25:\n  mov    %r14,%rbp\n  mov    (%r14),%edx\n  movslq %edx,%rax\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L20\nL21:\n  mov    %eax,0x0(%rbp)\n  mov    %eax,%edx\n  cltq\n  mov    (%rbx,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    L21\nL20:\n  mov    0x4(%rbp),%edx\n  movslq %edx,%rax\n  lea    0x0(,%rax,4),%r12\n  mov    (%rbx,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L22\nL23:\n  mov    %eax,0x4(%rbp)\n  movslq %eax,%rdx\n  lea    0x0(,%rdx,4),%r12\n  mov    %eax,%ecx\n  mov    (%rbx,%rdx,4),%eax\n  cmp    %ecx,%eax\n  jne    L23\nL22:\n  lea    D3(%rip),%rsi\n  mov    %r15,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L24\n  movslq 0x0(%rbp),%rax\n  mov    0x0(%r13,%r12,1),%edx\n  add    %edx,0x0(%r13,%rax,4)\nL27:\n  mov    0x0(%rbp),%eax\n  mov    %eax,0x4(%rbp)\nL26:\n  addq   $0x8,0x18(%rsp)\n  add    $0x4,%r14\n  cmp    0x8(%rsp),%r14\n  je     L2\nL16:\n  mov    0x18(%rsp),%rax\n  mov    (%rax),%r15\n  lea    D3(%rip),%rsi\n  mov    %r15,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  je     L25\n  lea    D4(%rip),%rsi\n  mov    %r15,%rdi\n  call   <strcmp@plt>\n  test   %eax,%eax\n  jne    L26\n  jmp    L25\nL24:\n  movslq 0x0(%rbp),%rax\n  mov    0x0(%r13,%r12,1),%edx\n  sub    %edx,0x0(%r13,%rax,4)\n  jmp    L27\nL2:\n  mov    0x0(%r13),%ebp\n  mov    %r13,%rdi\n  call   <free@plt>\n  mov    %rbx,%rdi\n  call   <free@plt>\n  mov    %ebp,%eax\n  add    $0x38,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3505
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8193,
                "bias": [
                    3311,
                    3231
                ]
            },
            "D2": {
                "label": "D2",
                "addr": 8195,
                "bias": [
                    3210
                ]
            },
            "D3": {
                "label": "D3",
                "addr": 8198,
                "bias": [
                    3092,
                    3028
                ]
            },
            "D4": {
                "label": "D4",
                "addr": 8200,
                "bias": [
                    3007
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4567
            },
            "L1": {
                "label": "L1",
                "addr": 4546
            },
            "L2": {
                "label": "L2",
                "addr": 5226
            },
            "L3": {
                "label": "L3",
                "addr": 4680
            },
            "L4": {
                "label": "L4",
                "addr": 4783
            },
            "L5": {
                "label": "L5",
                "addr": 4665
            },
            "L6": {
                "label": "L6",
                "addr": 4730
            },
            "L7": {
                "label": "L7",
                "addr": 4716
            },
            "L8": {
                "label": "L8",
                "addr": 4604
            },
            "L9": {
                "label": "L9",
                "addr": 4755
            },
            "L10": {
                "label": "L10",
                "addr": 4942
            },
            "L11": {
                "label": "L11",
                "addr": 4831
            },
            "L12": {
                "label": "L12",
                "addr": 4817
            },
            "L13": {
                "label": "L13",
                "addr": 4875
            },
            "L14": {
                "label": "L14",
                "addr": 4852
            },
            "L15": {
                "label": "L15",
                "addr": 5004
            },
            "L16": {
                "label": "L16",
                "addr": 5155
            },
            "L17": {
                "label": "L17",
                "addr": 4801
            },
            "L18": {
                "label": "L18",
                "addr": 4921
            },
            "L19": {
                "label": "L19",
                "addr": 4915
            },
            "L20": {
                "label": "L20",
                "addr": 5055
            },
            "L21": {
                "label": "L21",
                "addr": 5041
            },
            "L22": {
                "label": "L22",
                "addr": 5099
            },
            "L23": {
                "label": "L23",
                "addr": 5076
            },
            "L24": {
                "label": "L24",
                "addr": 5210
            },
            "L25": {
                "label": "L25",
                "addr": 5025
            },
            "L26": {
                "label": "L26",
                "addr": 5138
            },
            "L27": {
                "label": "L27",
                "addr": 5132
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "2a2a002f2f002b002d00",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"**\""
                },
                "0x2001": {
                    "type": "string",
                    "value": "\"*\""
                },
                "0x2003": {
                    "type": "string",
                    "value": "\"//\""
                },
                "0x2006": {
                    "type": "string",
                    "value": "\"+\""
                },
                "0x2008": {
                    "type": "string",
                    "value": "\"-\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 160,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  movslq %ecx,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  lea    0x0(,%r13,4),%rbx\n  sub    $0x28,%rsp\n  mov    %rdi,0x18(%rsp)\n  mov    %rbx,%rdi\n  mov    %edx,0x14(%rsp)\n  call   10a0 <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   10a0 <malloc@plt>\n  mov    %rax,%rbp\n  test   %r13d,%r13d\n  jle    11e5 <func0+0x65>\n  mov    %rbx,%rdx\n  mov    %r14,%rsi\n  mov    %r12,%rdi\n  call   1090 <memcpy@plt>\n  xor    %eax,%eax\n  nopl   0x0(%rax)\n  mov    %eax,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %r13,%rax\n  jne    11d8 <func0+0x58>\n  mov    0x14(%rsp),%eax\n  test   %eax,%eax\n  jle    1443 <func0+0x2c3>\n  mov    0x14(%rsp),%eax\n  mov    0x18(%rsp),%r14\n  lea    0x4(%rbp),%rdx\n  sub    $0x1,%eax\n  mov    %r14,%r13\n  lea    0x8(%r14,%rax,8),%rbx\n  nopl   0x0(%rax)\n  mov    (%r14),%rax\n  cmpb   $0x2a,(%rax)\n  jne    12c0 <func0+0x140>\n  cmpb   $0x2a,0x1(%rax)\n  jne    12c0 <func0+0x140>\n  cmpb   $0x0,0x2(%rax)\n  jne    12c0 <func0+0x140>\n  movslq -0x4(%rdx),%rax\n  mov    %rax,%r15\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%r15d\n  je     1251 <func0+0xd1>\n  cltq\n  mov    %eax,-0x4(%rdx)\n  mov    %rax,%r15\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %r15d,%eax\n  jne    1240 <func0+0xc0>\n  movslq (%rdx),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     1287 <func0+0x107>\n  nopw   0x0(%rax,%rax,1)\n  movslq %eax,%rcx\n  mov    %eax,(%rdx)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    1270 <func0+0xf0>\n  movslq %r15d,%rax\n  pxor   %xmm0,%xmm0\n  pxor   %xmm1,%xmm1\n  mov    %rdx,0x8(%rsp)\n  cvtsi2sdl (%r12,%r9,1),%xmm1\n  lea    (%r12,%rax,4),%rax\n  cvtsi2sdl (%rax),%xmm0\n  mov    %rax,(%rsp)\n  call   10b0 <pow@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%rdx\n  cvttsd2si %xmm0,%ecx\n  mov    %r15d,(%rdx)\n  mov    %ecx,(%rax)\n  add    $0x8,%r14\n  add    $0x4,%rdx\n  cmp    %r14,%rbx\n  jne    1210 <func0+0x90>\n  mov    0x14(%rsp),%r14d\n  mov    0x18(%rsp),%rbx\n  mov    %rbp,%rdi\n  mov    %rbp,%rsi\n  lea    0x0(%rbp,%r14,4),%r8\n  cs nopw 0x0(%rax,%rax,1)\n  mov    (%rbx),%r11\n  movzbl (%r11),%r10d\n  cmp    $0x2a,%r10d\n  jne    1488 <func0+0x308>\n  cmpb   $0x0,0x1(%r11)\n  jne    1488 <func0+0x308>\n  movslq (%rsi),%rax\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     132f <func0+0x1af>\n  nopw   0x0(%rax,%rax,1)\n  cltq\n  mov    %eax,(%rsi)\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %ecx,%eax\n  jne    1320 <func0+0x1a0>\n  movslq 0x4(%rsi),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r14\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     136a <func0+0x1ea>\n  cs nopw 0x0(%rax,%rax,1)\n  movslq %eax,%rdx\n  mov    %eax,0x4(%rsi)\n  mov    %eax,%r9d\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r14\n  cmp    %r9d,%eax\n  jne    1350 <func0+0x1d0>\n  sub    $0x2a,%r10d\n  jne    1375 <func0+0x1f5>\n  movzbl 0x1(%r11),%r10d\n  add    %r12,%r14\n  movslq %ecx,%rax\n  test   %r10d,%r10d\n  jne    14c0 <func0+0x340>\n  lea    (%r12,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   (%r14),%eax\n  mov    %eax,(%rdx)\n  mov    %ecx,0x4(%rsi)\n  add    $0x4,%rsi\n  add    $0x8,%rbx\n  cmp    %rsi,%r8\n  jne    12f0 <func0+0x170>\n  nopl   0x0(%rax)\n  mov    0x0(%r13),%rax\n  movzbl (%rax),%r10d\n  cmp    $0x2b,%r10d\n  jne    1470 <func0+0x2f0>\n  cmpb   $0x0,0x1(%rax)\n  jne    1470 <func0+0x2f0>\n  movslq (%rdi),%rax\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     13e7 <func0+0x267>\n  nopw   0x0(%rax,%rax,1)\n  cltq\n  mov    %eax,(%rdi)\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    13d8 <func0+0x258>\n  movslq 0x4(%rdi),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     1418 <func0+0x298>\n  xchg   %ax,%ax\n  movslq %eax,%rcx\n  mov    %eax,0x4(%rdi)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    1400 <func0+0x280>\n  add    %r12,%r9\n  movslq %edx,%rax\n  mov    (%r9),%ecx\n  cmp    $0x2b,%r10d\n  jne    14b0 <func0+0x330>\n  add    %ecx,(%r12,%rax,4)\n  mov    %edx,0x4(%rdi)\n  add    $0x4,%rdi\n  add    $0x8,%r13\n  cmp    %rdi,%r8\n  jne    13a8 <func0+0x228>\n  mov    %r12,%rdi\n  mov    (%r12),%r13d\n  call   1080 <free@plt>\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  add    $0x28,%rsp\n  mov    %r13d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  cmp    $0x2d,%r10d\n  jne    1432 <func0+0x2b2>\n  cmpb   $0x0,0x1(%rax)\n  je     13c4 <func0+0x244>\n  jmp    1432 <func0+0x2b2>\n  nopw   0x0(%rax,%rax,1)\n  cmpb   $0x2f,(%r11)\n  jne    1393 <func0+0x213>\n  cmpb   $0x2f,0x1(%r11)\n  jne    1393 <func0+0x213>\n  cmpb   $0x0,0x2(%r11)\n  je     130c <func0+0x18c>\n  jmp    1393 <func0+0x213>\n  nopl   (%rax)\n  sub    %ecx,(%r12,%rax,4)\n  jmp    142f <func0+0x2af>\n  nopl   0x0(%rax)\n  lea    (%r12,%rax,4),%r9\n  mov    (%r9),%eax\n  cltd\n  idivl  (%r14)\n  mov    %eax,(%r9)\n  jmp    1390 <func0+0x210>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  mov    %rsi,%r14\n  push   %r13\n  movslq %ecx,%r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  lea    0x0(,%r13,4),%rbx\n  sub    $0x28,%rsp\n  mov    %rdi,0x18(%rsp)\n  mov    %rbx,%rdi\n  mov    %edx,0x14(%rsp)\n  call   <malloc@plt>\n  mov    %rbx,%rdi\n  mov    %rax,%r12\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %r13d,%r13d\n  jle    L0\n  mov    %rbx,%rdx\n  mov    %r14,%rsi\n  mov    %r12,%rdi\n  call   <memcpy@plt>\n  xor    %eax,%eax\n  nopl   0x0(%rax)\nL1:\n  mov    %eax,0x0(%rbp,%rax,4)\n  add    $0x1,%rax\n  cmp    %r13,%rax\n  jne    L1\nL0:\n  mov    0x14(%rsp),%eax\n  test   %eax,%eax\n  jle    L2\n  mov    0x14(%rsp),%eax\n  mov    0x18(%rsp),%r14\n  lea    0x4(%rbp),%rdx\n  sub    $0x1,%eax\n  mov    %r14,%r13\n  lea    0x8(%r14,%rax,8),%rbx\n  nopl   0x0(%rax)\nL8:\n  mov    (%r14),%rax\n  cmpb   $0x2a,(%rax)\n  jne    L3\n  cmpb   $0x2a,0x1(%rax)\n  jne    L3\n  cmpb   $0x0,0x2(%rax)\n  jne    L3\n  movslq -0x4(%rdx),%rax\n  mov    %rax,%r15\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%r15d\n  je     L4\nL5:\n  cltq\n  mov    %eax,-0x4(%rdx)\n  mov    %rax,%r15\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %r15d,%eax\n  jne    L5\nL4:\n  movslq (%rdx),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L6\n  nopw   0x0(%rax,%rax,1)\nL7:\n  movslq %eax,%rcx\n  mov    %eax,(%rdx)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    L7\nL6:\n  movslq %r15d,%rax\n  pxor   %xmm0,%xmm0\n  pxor   %xmm1,%xmm1\n  mov    %rdx,0x8(%rsp)\n  cvtsi2sdl (%r12,%r9,1),%xmm1\n  lea    (%r12,%rax,4),%rax\n  cvtsi2sdl (%rax),%xmm0\n  mov    %rax,(%rsp)\n  call   <pow@plt>\n  mov    (%rsp),%rax\n  mov    0x8(%rsp),%rdx\n  cvttsd2si %xmm0,%ecx\n  mov    %r15d,(%rdx)\n  mov    %ecx,(%rax)\nL3:\n  add    $0x8,%r14\n  add    $0x4,%rdx\n  cmp    %r14,%rbx\n  jne    L8\n  mov    0x14(%rsp),%r14d\n  mov    0x18(%rsp),%rbx\n  mov    %rbp,%rdi\n  mov    %rbp,%rsi\n  lea    0x0(%rbp,%r14,4),%r8\n  cs nopw 0x0(%rax,%rax,1)\nL16:\n  mov    (%rbx),%r11\n  movzbl (%r11),%r10d\n  cmp    $0x2a,%r10d\n  jne    L9\n  cmpb   $0x0,0x1(%r11)\n  jne    L9\nL27:\n  movslq (%rsi),%rax\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L10\n  nopw   0x0(%rax,%rax,1)\nL11:\n  cltq\n  mov    %eax,(%rsi)\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %ecx,%eax\n  jne    L11\nL10:\n  movslq 0x4(%rsi),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r14\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     L12\n  cs nopw 0x0(%rax,%rax,1)\nL13:\n  movslq %eax,%rdx\n  mov    %eax,0x4(%rsi)\n  mov    %eax,%r9d\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r14\n  cmp    %r9d,%eax\n  jne    L13\nL12:\n  sub    $0x2a,%r10d\n  jne    L14\n  movzbl 0x1(%r11),%r10d\nL14:\n  add    %r12,%r14\n  movslq %ecx,%rax\n  test   %r10d,%r10d\n  jne    L15\n  lea    (%r12,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   (%r14),%eax\n  mov    %eax,(%rdx)\nL29:\n  mov    %ecx,0x4(%rsi)\nL26:\n  add    $0x4,%rsi\n  add    $0x8,%rbx\n  cmp    %rsi,%r8\n  jne    L16\n  nopl   0x0(%rax)\nL23:\n  mov    0x0(%r13),%rax\n  movzbl (%rax),%r10d\n  cmp    $0x2b,%r10d\n  jne    L17\n  cmpb   $0x0,0x1(%rax)\n  jne    L17\nL25:\n  movslq (%rdi),%rax\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     L18\n  nopw   0x0(%rax,%rax,1)\nL19:\n  cltq\n  mov    %eax,(%rdi)\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    L19\nL18:\n  movslq 0x4(%rdi),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L20\n  xchg   %ax,%ax\nL21:\n  movslq %eax,%rcx\n  mov    %eax,0x4(%rdi)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    L21\nL20:\n  add    %r12,%r9\n  movslq %edx,%rax\n  mov    (%r9),%ecx\n  cmp    $0x2b,%r10d\n  jne    L22\n  add    %ecx,(%r12,%rax,4)\nL28:\n  mov    %edx,0x4(%rdi)\nL24:\n  add    $0x4,%rdi\n  add    $0x8,%r13\n  cmp    %rdi,%r8\n  jne    L23\nL2:\n  mov    %r12,%rdi\n  mov    (%r12),%r13d\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  add    $0x28,%rsp\n  mov    %r13d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL17:\n  cmp    $0x2d,%r10d\n  jne    L24\n  cmpb   $0x0,0x1(%rax)\n  je     L25\n  jmp    L24\n  nopw   0x0(%rax,%rax,1)\nL9:\n  cmpb   $0x2f,(%r11)\n  jne    L26\n  cmpb   $0x2f,0x1(%r11)\n  jne    L26\n  cmpb   $0x0,0x2(%r11)\n  je     L27\n  jmp    L26\n  nopl   (%rax)\nL22:\n  sub    %ecx,(%r12,%rax,4)\n  jmp    L28\n  nopl   0x0(%rax)\nL15:\n  lea    (%r12,%rax,4),%r9\n  mov    (%r9),%eax\n  cltd\n  idivl  (%r14)\n  mov    %eax,(%r9)\n  jmp    L29",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4581
            },
            "L1": {
                "label": "L1",
                "addr": 4568
            },
            "L2": {
                "label": "L2",
                "addr": 5187
            },
            "L3": {
                "label": "L3",
                "addr": 4800
            },
            "L4": {
                "label": "L4",
                "addr": 4689
            },
            "L5": {
                "label": "L5",
                "addr": 4672
            },
            "L6": {
                "label": "L6",
                "addr": 4743
            },
            "L7": {
                "label": "L7",
                "addr": 4720
            },
            "L8": {
                "label": "L8",
                "addr": 4624
            },
            "L9": {
                "label": "L9",
                "addr": 5256
            },
            "L10": {
                "label": "L10",
                "addr": 4911
            },
            "L11": {
                "label": "L11",
                "addr": 4896
            },
            "L12": {
                "label": "L12",
                "addr": 4970
            },
            "L13": {
                "label": "L13",
                "addr": 4944
            },
            "L14": {
                "label": "L14",
                "addr": 4981
            },
            "L15": {
                "label": "L15",
                "addr": 5312
            },
            "L16": {
                "label": "L16",
                "addr": 4848
            },
            "L17": {
                "label": "L17",
                "addr": 5232
            },
            "L18": {
                "label": "L18",
                "addr": 5095
            },
            "L19": {
                "label": "L19",
                "addr": 5080
            },
            "L20": {
                "label": "L20",
                "addr": 5144
            },
            "L21": {
                "label": "L21",
                "addr": 5120
            },
            "L22": {
                "label": "L22",
                "addr": 5296
            },
            "L23": {
                "label": "L23",
                "addr": 5032
            },
            "L24": {
                "label": "L24",
                "addr": 5170
            },
            "L25": {
                "label": "L25",
                "addr": 5060
            },
            "L26": {
                "label": "L26",
                "addr": 5011
            },
            "L27": {
                "label": "L27",
                "addr": 4876
            },
            "L28": {
                "label": "L28",
                "addr": 5167
            },
            "L29": {
                "label": "L29",
                "addr": 5008
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 160,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <string.h>\n\nint func0(const char **operato, const int *operand, int operato_size, int operand_size) {\n    int *num = (int*)malloc(operand_size * sizeof(int));\n    int *posto = (int*)malloc(operand_size * sizeof(int));\n    for (int i = 0; i < operand_size; i++) {\n        num[i] = operand[i];\n        posto[i] = i;\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"**\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            num[posto[i]] = pow(num[posto[i]], num[posto[i + 1]]);\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"*\") == 0 || strcmp(operato[i], \"//\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"*\") == 0)\n                num[posto[i]] *= num[posto[i + 1]];\n            else\n                num[posto[i]] /= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    for (int i = 0; i < operato_size; i++) {\n        if (strcmp(operato[i], \"+\") == 0 || strcmp(operato[i], \"-\") == 0) {\n            while (posto[posto[i]] != posto[i]) posto[i] = posto[posto[i]];\n            while (posto[posto[i + 1]] != posto[i + 1]) posto[i + 1] = posto[posto[i + 1]];\n            if (strcmp(operato[i], \"+\") == 0)\n                num[posto[i]] += num[posto[i + 1]];\n            else\n                num[posto[i]] -= num[posto[i + 1]];\n            posto[i + 1] = posto[i];\n        }\n    }\n    int result = num[0];\n    free(num);\n    free(posto);\n    return result;\n}",
        "c_test": "#include <assert.h>\n\nint main() {\n    const char *operators1[] = {\"**\", \"*\", \"+\"};\n    int operands1[] = {2, 3, 4, 5};\n    assert(func0(operators1, operands1, 3, 4) == 37);\n\n    const char *operators2[] = {\"+\", \"*\", \"-\"};\n    int operands2[] = {2, 3, 4, 5};\n    assert(func0(operators2, operands2, 3, 4) == 9);\n\n    const char *operators3[] = {\"//\", \"*\"};\n    int operands3[] = {7, 3, 4};\n    assert(func0(operators3, operands3, 2, 3) == 8);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rsi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %ecx,%rbp\n  push   %rbx\n  mov    %rbp,%r13\n  shl    $0x2,%rbp\n  sub    $0x28,%rsp\n  mov    %rdi,0x18(%rsp)\n  mov    %rbp,%rdi\n  mov    %edx,0x14(%rsp)\n  call   10a0 <malloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r12\n  call   10a0 <malloc@plt>\n  mov    %rax,%rbp\n  test   %r13d,%r13d\n  jle    1258 <func0+0xd8>\n  mov    %r13d,%edx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  shl    $0x2,%rdx\n  call   1090 <memcpy@plt>\n  lea    -0x1(%r13),%eax\n  cmp    $0x2,%eax\n  jbe    1553 <func0+0x3d3>\n  mov    %r13d,%edx\n  movdqa 0xe0f(%rip),%xmm0        # 2000 <_fini+0xaa4>\n  movdqa 0xe17(%rip),%xmm2        # 2010 <_fini+0xab4>\n  mov    %rbp,%rax\n  shr    $0x2,%edx\n  shl    $0x4,%rdx\n  add    %rbp,%rdx\n  cs nopw 0x0(%rax,%rax,1)\n  movdqa %xmm0,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm2,%xmm0\n  movups %xmm1,-0x10(%rax)\n  cmp    %rax,%rdx\n  jne    1210 <func0+0x90>\n  mov    %r13d,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%r13b\n  je     1258 <func0+0xd8>\n  movslq %eax,%rdx\n  mov    %eax,0x0(%rbp,%rdx,4)\n  lea    0x0(,%rdx,4),%rcx\n  lea    0x1(%rax),%edx\n  cmp    %edx,%r13d\n  jle    1258 <func0+0xd8>\n  add    $0x2,%eax\n  mov    %edx,0x4(%rbp,%rcx,1)\n  cmp    %eax,%r13d\n  jle    1258 <func0+0xd8>\n  mov    %eax,0x8(%rbp,%rcx,1)\n  mov    0x14(%rsp),%eax\n  test   %eax,%eax\n  jle    14c3 <func0+0x343>\n  mov    0x14(%rsp),%eax\n  mov    0x18(%rsp),%r14\n  lea    0x4(%rbp),%r15\n  sub    $0x1,%eax\n  mov    %r14,%r13\n  lea    0x8(%r14,%rax,8),%rbx\n  nopl   0x0(%rax)\n  mov    (%r14),%rax\n  cmpb   $0x2a,(%rax)\n  jne    134e <func0+0x1ce>\n  cmpb   $0x2a,0x1(%rax)\n  jne    134e <func0+0x1ce>\n  cmpb   $0x0,0x2(%rax)\n  jne    134e <func0+0x1ce>\n  movslq -0x4(%r15),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r8\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     12d9 <func0+0x159>\n  nopw   0x0(%rax,%rax,1)\n  movslq %eax,%rdx\n  mov    %eax,-0x4(%r15)\n  mov    %eax,%ecx\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r8\n  cmp    %ecx,%eax\n  jne    12c0 <func0+0x140>\n  movslq (%r15),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%edx\n  je     1317 <func0+0x197>\n  nop\n  movslq %eax,%rdx\n  mov    %eax,(%r15)\n  mov    %eax,%ecx\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r9\n  cmp    %ecx,%eax\n  jne    12f0 <func0+0x170>\n  movslq -0x4(%r15),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r8\n  add    %r12,%r8\n  pxor   %xmm0,%xmm0\n  pxor   %xmm1,%xmm1\n  mov    %ecx,0x10(%rsp)\n  cvtsi2sdl (%r8),%xmm0\n  mov    %r8,0x8(%rsp)\n  cvtsi2sdl (%r12,%r9,1),%xmm1\n  call   10b0 <pow@plt>\n  mov    0x8(%rsp),%r8\n  mov    0x10(%rsp),%ecx\n  cvttsd2si %xmm0,%edx\n  mov    %ecx,(%r15)\n  mov    %edx,(%r8)\n  add    $0x8,%r14\n  add    $0x4,%r15\n  cmp    %r14,%rbx\n  jne    1280 <func0+0x100>\n  mov    0x14(%rsp),%r14d\n  mov    0x18(%rsp),%rbx\n  mov    %rbp,%rdi\n  mov    %rbp,%rsi\n  lea    0x0(%rbp,%r14,4),%r8\n  nopl   0x0(%rax)\n  mov    (%rbx),%r11\n  movzbl (%r11),%r10d\n  cmp    $0x2a,%r10d\n  jne    1508 <func0+0x388>\n  cmpb   $0x0,0x1(%r11)\n  jne    1508 <func0+0x388>\n  movslq (%rsi),%rax\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     13b7 <func0+0x237>\n  nopw   0x0(%rax,%rax,1)\n  cltq\n  mov    %eax,(%rsi)\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %ecx,%eax\n  jne    13a8 <func0+0x228>\n  movslq 0x4(%rsi),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r14\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     13ea <func0+0x26a>\n  xchg   %ax,%ax\n  movslq %eax,%rdx\n  mov    %eax,0x4(%rsi)\n  mov    %eax,%r9d\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r14\n  cmp    %r9d,%eax\n  jne    13d0 <func0+0x250>\n  sub    $0x2a,%r10d\n  jne    13f5 <func0+0x275>\n  movzbl 0x1(%r11),%r10d\n  add    %r12,%r14\n  movslq %ecx,%rax\n  test   %r10d,%r10d\n  jne    1540 <func0+0x3c0>\n  lea    (%r12,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   (%r14),%eax\n  mov    %eax,(%rdx)\n  mov    %ecx,0x4(%rsi)\n  add    $0x4,%rsi\n  add    $0x8,%rbx\n  cmp    %rsi,%r8\n  jne    1378 <func0+0x1f8>\n  nopl   0x0(%rax)\n  mov    0x0(%r13),%rax\n  movzbl (%rax),%r10d\n  cmp    $0x2b,%r10d\n  jne    14f0 <func0+0x370>\n  cmpb   $0x0,0x1(%rax)\n  jne    14f0 <func0+0x370>\n  movslq (%rdi),%rax\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     1467 <func0+0x2e7>\n  nopw   0x0(%rax,%rax,1)\n  cltq\n  mov    %eax,(%rdi)\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    1458 <func0+0x2d8>\n  movslq 0x4(%rdi),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     1498 <func0+0x318>\n  xchg   %ax,%ax\n  movslq %eax,%rcx\n  mov    %eax,0x4(%rdi)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    1480 <func0+0x300>\n  add    %r12,%r9\n  movslq %edx,%rax\n  mov    (%r9),%ecx\n  cmp    $0x2b,%r10d\n  jne    1530 <func0+0x3b0>\n  add    %ecx,(%r12,%rax,4)\n  mov    %edx,0x4(%rdi)\n  add    $0x4,%rdi\n  add    $0x8,%r13\n  cmp    %rdi,%r8\n  jne    1428 <func0+0x2a8>\n  mov    %r12,%rdi\n  mov    (%r12),%r13d\n  call   1080 <free@plt>\n  mov    %rbp,%rdi\n  call   1080 <free@plt>\n  add    $0x28,%rsp\n  mov    %r13d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\n  cmp    $0x2d,%r10d\n  jne    14b2 <func0+0x332>\n  cmpb   $0x0,0x1(%rax)\n  je     1444 <func0+0x2c4>\n  jmp    14b2 <func0+0x332>\n  nopw   0x0(%rax,%rax,1)\n  cmpb   $0x2f,(%r11)\n  jne    1413 <func0+0x293>\n  cmpb   $0x2f,0x1(%r11)\n  jne    1413 <func0+0x293>\n  cmpb   $0x0,0x2(%r11)\n  je     1394 <func0+0x214>\n  jmp    1413 <func0+0x293>\n  nopl   (%rax)\n  sub    %ecx,(%r12,%rax,4)\n  jmp    14af <func0+0x32f>\n  nopl   0x0(%rax)\n  lea    (%r12,%rax,4),%r9\n  mov    (%r9),%eax\n  cltd\n  idivl  (%r14)\n  mov    %eax,(%r9)\n  jmp    1410 <func0+0x290>\n  xor    %eax,%eax\n  jmp    1231 <func0+0xb1>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  mov    %rsi,%r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  movslq %ecx,%rbp\n  push   %rbx\n  mov    %rbp,%r13\n  shl    $0x2,%rbp\n  sub    $0x28,%rsp\n  mov    %rdi,0x18(%rsp)\n  mov    %rbp,%rdi\n  mov    %edx,0x14(%rsp)\n  call   <malloc@plt>\n  mov    %rbp,%rdi\n  mov    %rax,%r12\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %r13d,%r13d\n  jle    L0\n  mov    %r13d,%edx\n  mov    %r15,%rsi\n  mov    %r12,%rdi\n  shl    $0x2,%rdx\n  call   <memcpy@plt>\n  lea    -0x1(%r13),%eax\n  cmp    $0x2,%eax\n  jbe    L1\n  mov    %r13d,%edx\n  movdqa D0(%rip),%xmm0\n  movdqa D1(%rip),%xmm2\n  mov    %rbp,%rax\n  shr    $0x2,%edx\n  shl    $0x4,%rdx\n  add    %rbp,%rdx\n  cs nopw 0x0(%rax,%rax,1)\nL2:\n  movdqa %xmm0,%xmm1\n  add    $0x10,%rax\n  paddd  %xmm2,%xmm0\n  movups %xmm1,-0x10(%rax)\n  cmp    %rax,%rdx\n  jne    L2\n  mov    %r13d,%eax\n  and    $0xfffffffc,%eax\n  test   $0x3,%r13b\n  je     L0\nL31:\n  movslq %eax,%rdx\n  mov    %eax,0x0(%rbp,%rdx,4)\n  lea    0x0(,%rdx,4),%rcx\n  lea    0x1(%rax),%edx\n  cmp    %edx,%r13d\n  jle    L0\n  add    $0x2,%eax\n  mov    %edx,0x4(%rbp,%rcx,1)\n  cmp    %eax,%r13d\n  jle    L0\n  mov    %eax,0x8(%rbp,%rcx,1)\nL0:\n  mov    0x14(%rsp),%eax\n  test   %eax,%eax\n  jle    L3\n  mov    0x14(%rsp),%eax\n  mov    0x18(%rsp),%r14\n  lea    0x4(%rbp),%r15\n  sub    $0x1,%eax\n  mov    %r14,%r13\n  lea    0x8(%r14,%rax,8),%rbx\n  nopl   0x0(%rax)\nL9:\n  mov    (%r14),%rax\n  cmpb   $0x2a,(%rax)\n  jne    L4\n  cmpb   $0x2a,0x1(%rax)\n  jne    L4\n  cmpb   $0x0,0x2(%rax)\n  jne    L4\n  movslq -0x4(%r15),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r8\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L5\n  nopw   0x0(%rax,%rax,1)\nL6:\n  movslq %eax,%rdx\n  mov    %eax,-0x4(%r15)\n  mov    %eax,%ecx\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r8\n  cmp    %ecx,%eax\n  jne    L6\nL5:\n  movslq (%r15),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%edx\n  je     L7\n  nop\nL8:\n  movslq %eax,%rdx\n  mov    %eax,(%r15)\n  mov    %eax,%ecx\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r9\n  cmp    %ecx,%eax\n  jne    L8\n  movslq -0x4(%r15),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r8\nL7:\n  add    %r12,%r8\n  pxor   %xmm0,%xmm0\n  pxor   %xmm1,%xmm1\n  mov    %ecx,0x10(%rsp)\n  cvtsi2sdl (%r8),%xmm0\n  mov    %r8,0x8(%rsp)\n  cvtsi2sdl (%r12,%r9,1),%xmm1\n  call   <pow@plt>\n  mov    0x8(%rsp),%r8\n  mov    0x10(%rsp),%ecx\n  cvttsd2si %xmm0,%edx\n  mov    %ecx,(%r15)\n  mov    %edx,(%r8)\nL4:\n  add    $0x8,%r14\n  add    $0x4,%r15\n  cmp    %r14,%rbx\n  jne    L9\n  mov    0x14(%rsp),%r14d\n  mov    0x18(%rsp),%rbx\n  mov    %rbp,%rdi\n  mov    %rbp,%rsi\n  lea    0x0(%rbp,%r14,4),%r8\n  nopl   0x0(%rax)\nL17:\n  mov    (%rbx),%r11\n  movzbl (%r11),%r10d\n  cmp    $0x2a,%r10d\n  jne    L10\n  cmpb   $0x0,0x1(%r11)\n  jne    L10\nL28:\n  movslq (%rsi),%rax\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L11\n  nopw   0x0(%rax,%rax,1)\nL12:\n  cltq\n  mov    %eax,(%rsi)\n  mov    %rax,%rcx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %ecx,%eax\n  jne    L12\nL11:\n  movslq 0x4(%rsi),%rax\n  mov    %rax,%rdx\n  lea    0x0(,%rax,4),%r14\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     L13\n  xchg   %ax,%ax\nL14:\n  movslq %eax,%rdx\n  mov    %eax,0x4(%rsi)\n  mov    %eax,%r9d\n  mov    0x0(%rbp,%rdx,4),%eax\n  lea    0x0(,%rdx,4),%r14\n  cmp    %r9d,%eax\n  jne    L14\nL13:\n  sub    $0x2a,%r10d\n  jne    L15\n  movzbl 0x1(%r11),%r10d\nL15:\n  add    %r12,%r14\n  movslq %ecx,%rax\n  test   %r10d,%r10d\n  jne    L16\n  lea    (%r12,%rax,4),%rdx\n  mov    (%rdx),%eax\n  imul   (%r14),%eax\n  mov    %eax,(%rdx)\nL30:\n  mov    %ecx,0x4(%rsi)\nL27:\n  add    $0x4,%rsi\n  add    $0x8,%rbx\n  cmp    %rsi,%r8\n  jne    L17\n  nopl   0x0(%rax)\nL24:\n  mov    0x0(%r13),%rax\n  movzbl (%rax),%r10d\n  cmp    $0x2b,%r10d\n  jne    L18\n  cmpb   $0x0,0x1(%rax)\n  jne    L18\nL26:\n  movslq (%rdi),%rax\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  je     L19\n  nopw   0x0(%rax,%rax,1)\nL20:\n  cltq\n  mov    %eax,(%rdi)\n  mov    %rax,%rdx\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %edx,%eax\n  jne    L20\nL19:\n  movslq 0x4(%rdi),%rax\n  mov    %rax,%rcx\n  lea    0x0(,%rax,4),%r9\n  mov    0x0(%rbp,%rax,4),%eax\n  cmp    %eax,%ecx\n  je     L21\n  xchg   %ax,%ax\nL22:\n  movslq %eax,%rcx\n  mov    %eax,0x4(%rdi)\n  mov    %eax,%esi\n  mov    0x0(%rbp,%rcx,4),%eax\n  lea    0x0(,%rcx,4),%r9\n  cmp    %esi,%eax\n  jne    L22\nL21:\n  add    %r12,%r9\n  movslq %edx,%rax\n  mov    (%r9),%ecx\n  cmp    $0x2b,%r10d\n  jne    L23\n  add    %ecx,(%r12,%rax,4)\nL29:\n  mov    %edx,0x4(%rdi)\nL25:\n  add    $0x4,%rdi\n  add    $0x8,%r13\n  cmp    %rdi,%r8\n  jne    L24\nL3:\n  mov    %r12,%rdi\n  mov    (%r12),%r13d\n  call   <free@plt>\n  mov    %rbp,%rdi\n  call   <free@plt>\n  add    $0x28,%rsp\n  mov    %r13d,%eax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax)\nL18:\n  cmp    $0x2d,%r10d\n  jne    L25\n  cmpb   $0x0,0x1(%rax)\n  je     L26\n  jmp    L25\n  nopw   0x0(%rax,%rax,1)\nL10:\n  cmpb   $0x2f,(%r11)\n  jne    L27\n  cmpb   $0x2f,0x1(%r11)\n  jne    L27\n  cmpb   $0x0,0x2(%r11)\n  je     L28\n  jmp    L27\n  nopl   (%rax)\nL23:\n  sub    %ecx,(%r12,%rax,4)\n  jmp    L29\n  nopl   0x0(%rax)\nL16:\n  lea    (%r12,%rax,4),%r9\n  mov    (%r9),%eax\n  cltd\n  idivl  (%r14)\n  mov    %eax,(%r9)\n  jmp    L30\nL1:\n  xor    %eax,%eax\n  jmp    L31",
        "num_missing": 2,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3599
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8208,
                "bias": [
                    3607
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4696
            },
            "L1": {
                "label": "L1",
                "addr": 5459
            },
            "L2": {
                "label": "L2",
                "addr": 4624
            },
            "L3": {
                "label": "L3",
                "addr": 5315
            },
            "L4": {
                "label": "L4",
                "addr": 4942
            },
            "L5": {
                "label": "L5",
                "addr": 4825
            },
            "L6": {
                "label": "L6",
                "addr": 4800
            },
            "L7": {
                "label": "L7",
                "addr": 4887
            },
            "L8": {
                "label": "L8",
                "addr": 4848
            },
            "L9": {
                "label": "L9",
                "addr": 4736
            },
            "L10": {
                "label": "L10",
                "addr": 5384
            },
            "L11": {
                "label": "L11",
                "addr": 5047
            },
            "L12": {
                "label": "L12",
                "addr": 5032
            },
            "L13": {
                "label": "L13",
                "addr": 5098
            },
            "L14": {
                "label": "L14",
                "addr": 5072
            },
            "L15": {
                "label": "L15",
                "addr": 5109
            },
            "L16": {
                "label": "L16",
                "addr": 5440
            },
            "L17": {
                "label": "L17",
                "addr": 4984
            },
            "L18": {
                "label": "L18",
                "addr": 5360
            },
            "L19": {
                "label": "L19",
                "addr": 5223
            },
            "L20": {
                "label": "L20",
                "addr": 5208
            },
            "L21": {
                "label": "L21",
                "addr": 5272
            },
            "L22": {
                "label": "L22",
                "addr": 5248
            },
            "L23": {
                "label": "L23",
                "addr": 5424
            },
            "L24": {
                "label": "L24",
                "addr": 5160
            },
            "L25": {
                "label": "L25",
                "addr": 5298
            },
            "L26": {
                "label": "L26",
                "addr": 5188
            },
            "L27": {
                "label": "L27",
                "addr": 5139
            },
            "L28": {
                "label": "L28",
                "addr": 5012
            },
            "L29": {
                "label": "L29",
                "addr": 5295
            },
            "L30": {
                "label": "L30",
                "addr": 5136
            },
            "L31": {
                "label": "L31",
                "addr": 4657
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "0000000001000000020000000300000004000000040000000400000004000000",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "byte[16]",
                    "value": [
                        0,
                        0,
                        0,
                        0,
                        1,
                        0,
                        0,
                        0,
                        2,
                        0,
                        0,
                        0,
                        3,
                        0,
                        0,
                        0
                    ]
                },
                "0x2010": {
                    "type": "byte[16]",
                    "value": [
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0,
                        4,
                        0,
                        0,
                        0
                    ]
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 161,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   1090 <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    12a1 <func0+0x128>\n  call   10b0 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     1299 <func0+0x120>\n  call   10b0 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     123c <func0+0xc3>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   10a0 <tolower@plt>\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  jmp    129d <func0+0x124>\n  call   10b0 <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     129d <func0+0x124>\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   1080 <toupper@plt>\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  jmp    129d <func0+0x124>\n  addl   $0x1,-0x10(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  mov    -0xc(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     11ab <func0+0x32>\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jne    1324 <func0+0x1ab>\n  movl   $0x0,-0x8(%rbp)\n  jmp    1313 <func0+0x19a>\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x11(%rbp)\n  mov    -0x4(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x4(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x11(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x8(%rbp)\n  jl     12be <func0+0x145>\n  mov    -0x28(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  mov    -0x28(%rbp),%rax\n  mov    %rax,%rdi\n  call   <strlen@plt>\n  mov    %eax,-0x4(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L0\nL4:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x400,%eax\n  test   %eax,%eax\n  je     L1\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x100,%eax\n  test   %eax,%eax\n  je     L2\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   <tolower@plt>\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  jmp    L3\nL2:\n  call   <__ctype_b_loc@plt>\n  mov    (%rax),%rdx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  add    %rax,%rax\n  add    %rdx,%rax\n  movzwl (%rax),%eax\n  movzwl %ax,%eax\n  and    $0x200,%eax\n  test   %eax,%eax\n  je     L3\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  movzbl %al,%eax\n  mov    %eax,%edi\n  call   <toupper@plt>\n  mov    %eax,%edx\n  mov    -0xc(%rbp),%eax\n  movslq %eax,%rcx\n  mov    -0x28(%rbp),%rax\n  add    %rcx,%rax\n  mov    %dl,(%rax)\n  jmp    L3\nL1:\n  addl   $0x1,-0x10(%rbp)\nL3:\n  addl   $0x1,-0xc(%rbp)\nL0:\n  mov    -0xc(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jl     L4\n  mov    -0x10(%rbp),%eax\n  cmp    -0x4(%rbp),%eax\n  jne    L5\n  movl   $0x0,-0x8(%rbp)\n  jmp    L6\nL7:\n  mov    -0x8(%rbp),%eax\n  movslq %eax,%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x11(%rbp)\n  mov    -0x4(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  mov    -0x8(%rbp),%edx\n  movslq %edx,%rcx\n  mov    -0x28(%rbp),%rdx\n  add    %rcx,%rdx\n  movzbl (%rax),%eax\n  mov    %al,(%rdx)\n  mov    -0x4(%rbp),%eax\n  sub    -0x8(%rbp),%eax\n  cltq\n  lea    -0x1(%rax),%rdx\n  mov    -0x28(%rbp),%rax\n  add    %rax,%rdx\n  movzbl -0x11(%rbp),%eax\n  mov    %al,(%rdx)\n  addl   $0x1,-0x8(%rbp)\nL6:\n  mov    -0x4(%rbp),%eax\n  mov    %eax,%edx\n  shr    $0x1f,%edx\n  add    %edx,%eax\n  sar    %eax\n  cmp    %eax,-0x8(%rbp)\n  jl     L7\nL5:\n  mov    -0x28(%rbp),%rax\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4769
            },
            "L1": {
                "label": "L1",
                "addr": 4761
            },
            "L2": {
                "label": "L2",
                "addr": 4668
            },
            "L3": {
                "label": "L3",
                "addr": 4765
            },
            "L4": {
                "label": "L4",
                "addr": 4523
            },
            "L5": {
                "label": "L5",
                "addr": 4900
            },
            "L6": {
                "label": "L6",
                "addr": 4883
            },
            "L7": {
                "label": "L7",
                "addr": 4798
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 161,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  call   1090 <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    1208 <func0+0x8f>\n  mov    %rax,%r14\n  call   10b0 <__ctype_b_loc@plt>\n  mov    %rax,%r13\n  mov    %r12,%rbx\n  lea    -0x1(%r14),%eax\n  lea    0x1(%r12,%rax,1),%r15\n  mov    $0x0,%r14d\n  jmp    11e0 <func0+0x67>\n  test   $0x2,%ah\n  je     11d7 <func0+0x5e>\n  call   1080 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    (%rsp),%rsi\n  mov    %al,(%rsi)\n  jmp    11d7 <func0+0x5e>\n  add    $0x1,%r14d\n  add    $0x1,%rbx\n  cmp    %r15,%rbx\n  je     120e <func0+0x95>\n  mov    %rbx,(%rsp)\n  movzbl (%rbx),%ebp\n  mov    0x0(%r13),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  je     11d3 <func0+0x5a>\n  test   $0x1,%ah\n  je     11bb <func0+0x42>\n  call   10a0 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    11d7 <func0+0x5e>\n  mov    $0x0,%r14d\n  cmp    %r14d,0x8(%rsp)\n  je     1227 <func0+0xae>\n  mov    %r12,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  mov    0x8(%rsp),%rax\n  mov    %eax,%edi\n  shr    $0x1f,%edi\n  add    %eax,%edi\n  sar    %edi\n  cmp    $0x1,%eax\n  jle    1215 <func0+0x9c>\n  cltq\n  lea    -0x1(%r12,%rax,1),%rdx\n  mov    $0x0,%eax\n  movzbl (%r12,%rax,1),%ecx\n  movzbl (%rdx),%esi\n  mov    %sil,(%r12,%rax,1)\n  mov    %cl,(%rdx)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%edi\n  jg     1246 <func0+0xcd>\n  jmp    1215 <func0+0x9c>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  mov    %rdi,%r12\n  call   <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r14\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r13\n  mov    %r12,%rbx\n  lea    -0x1(%r14),%eax\n  lea    0x1(%r12,%rax,1),%r15\n  mov    $0x0,%r14d\n  jmp    L1\nL5:\n  test   $0x2,%ah\n  je     L2\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    (%rsp),%rsi\n  mov    %al,(%rsi)\n  jmp    L2\nL4:\n  add    $0x1,%r14d\nL2:\n  add    $0x1,%rbx\n  cmp    %r15,%rbx\n  je     L3\nL1:\n  mov    %rbx,(%rsp)\n  movzbl (%rbx),%ebp\n  mov    0x0(%r13),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  je     L4\n  test   $0x1,%ah\n  je     L5\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    L2\nL0:\n  mov    $0x0,%r14d\nL3:\n  cmp    %r14d,0x8(%rsp)\n  je     L6\nL7:\n  mov    %r12,%rax\n  add    $0x18,%rsp\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\nL6:\n  mov    0x8(%rsp),%rax\n  mov    %eax,%edi\n  shr    $0x1f,%edi\n  add    %eax,%edi\n  sar    %edi\n  cmp    $0x1,%eax\n  jle    L7\n  cltq\n  lea    -0x1(%r12,%rax,1),%rdx\n  mov    $0x0,%eax\nL8:\n  movzbl (%r12,%rax,1),%ecx\n  movzbl (%rdx),%esi\n  mov    %sil,(%r12,%rax,1)\n  mov    %cl,(%rdx)\n  add    $0x1,%rax\n  sub    $0x1,%rdx\n  cmp    %eax,%edi\n  jg     L8\n  jmp    L7",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4616
            },
            "L1": {
                "label": "L1",
                "addr": 4576
            },
            "L2": {
                "label": "L2",
                "addr": 4567
            },
            "L3": {
                "label": "L3",
                "addr": 4622
            },
            "L4": {
                "label": "L4",
                "addr": 4563
            },
            "L5": {
                "label": "L5",
                "addr": 4539
            },
            "L6": {
                "label": "L6",
                "addr": 4647
            },
            "L7": {
                "label": "L7",
                "addr": 4629
            },
            "L8": {
                "label": "L8",
                "addr": 4678
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 161,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   1090 <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    1280 <func0+0x100>\n  mov    %rax,%r15\n  mov    %r12,%rbx\n  call   10b0 <__ctype_b_loc@plt>\n  mov    %rax,%r14\n  lea    -0x1(%r15),%eax\n  xor    %r15d,%r15d\n  lea    0x1(%r12,%rax,1),%r13\n  jmp    11e3 <func0+0x63>\n  nopl   0x0(%rax,%rax,1)\n  test   $0x1,%ah\n  je     1220 <func0+0xa0>\n  call   10a0 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     11ff <func0+0x7f>\n  movzbl (%rbx),%ebp\n  mov    (%r14),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  jne    11c8 <func0+0x48>\n  add    $0x1,%rbx\n  add    $0x1,%r15d\n  cmp    %r13,%rbx\n  jne    11e3 <func0+0x63>\n  cmp    %r15d,0x8(%rsp)\n  je     1238 <func0+0xb8>\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  test   $0x2,%ah\n  je     11da <func0+0x5a>\n  call   1080 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    11da <func0+0x5a>\n  nopl   0x0(%rax)\n  mov    0x8(%rsp),%rax\n  mov    %eax,%ecx\n  sar    %ecx\n  je     1206 <func0+0x86>\n  movslq %eax,%r13\n  sub    $0x1,%ecx\n  mov    %r12,%rdx\n  lea    -0x2(%r12,%r13,1),%rdi\n  lea    -0x1(%r12,%r13,1),%rax\n  sub    %rcx,%rdi\n  nopl   0x0(%rax)\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    1260 <func0+0xe0>\n  jmp    1206 <func0+0x86>\n  nopl   0x0(%rax)\n  xor    %r15d,%r15d\n  jmp    11ff <func0+0x7f>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r15\n  mov    %r12,%rbx\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r14\n  lea    -0x1(%r15),%eax\n  xor    %r15d,%r15d\n  lea    0x1(%r12,%rax,1),%r13\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL4:\n  test   $0x1,%ah\n  je     L2\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\nL6:\n  add    $0x1,%rbx\n  cmp    %r13,%rbx\n  je     L3\nL1:\n  movzbl (%rbx),%ebp\n  mov    (%r14),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  jne    L4\n  add    $0x1,%rbx\n  add    $0x1,%r15d\n  cmp    %r13,%rbx\n  jne    L1\nL3:\n  cmp    %r15d,0x8(%rsp)\n  je     L5\nL7:\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  test   $0x2,%ah\n  je     L6\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    L6\n  nopl   0x0(%rax)\nL5:\n  mov    0x8(%rsp),%rax\n  mov    %eax,%ecx\n  sar    %ecx\n  je     L7\n  movslq %eax,%r13\n  sub    $0x1,%ecx\n  mov    %r12,%rdx\n  lea    -0x2(%r12,%r13,1),%rdi\n  lea    -0x1(%r12,%r13,1),%rax\n  sub    %rcx,%rdi\n  nopl   0x0(%rax)\nL8:\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    L8\n  jmp    L7\n  nopl   0x0(%rax)\nL0:\n  xor    %r15d,%r15d\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4736
            },
            "L1": {
                "label": "L1",
                "addr": 4579
            },
            "L2": {
                "label": "L2",
                "addr": 4640
            },
            "L3": {
                "label": "L3",
                "addr": 4607
            },
            "L4": {
                "label": "L4",
                "addr": 4552
            },
            "L5": {
                "label": "L5",
                "addr": 4664
            },
            "L6": {
                "label": "L6",
                "addr": 4570
            },
            "L7": {
                "label": "L7",
                "addr": 4614
            },
            "L8": {
                "label": "L8",
                "addr": 4704
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 161,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nchar* func0(char *s){\n    int nletter = 0;\n    int length = strlen(s);\n    for (int i = 0; i < length; i++) {\n        if (isalpha((unsigned char)s[i])) {\n            if (isupper((unsigned char)s[i])) s[i] = tolower((unsigned char)s[i]);\n            else if (islower((unsigned char)s[i])) s[i] = toupper((unsigned char)s[i]);\n        } else {\n            nletter += 1;\n        }\n    }\n    if (nletter == length) {\n        for (int i = 0; i < length / 2; i++) {\n            char temp = s[i];\n            s[i] = s[length - i - 1];\n            s[length - i - 1] = temp;\n        }\n    }\n    return s;\n}",
        "c_test": "#include <assert.h>\n#include <string.h>\n\nint main(){\n    char test1[] = \"AsDf\";\n    assert(strcmp(func0(test1), \"aSdF\") == 0);\n\n    char test2[] = \"1234\";\n    assert(strcmp(func0(test2), \"4321\") == 0);\n\n    char test3[] = \"ab\";\n    assert(strcmp(func0(test3), \"AB\") == 0);\n\n    char test4[] = \"#a@C\";\n    assert(strcmp(func0(test4), \"#A@c\") == 0);\n\n    char test5[] = \"#AsdfW^45\";\n    assert(strcmp(func0(test5), \"#aSDFw^45\") == 0);\n\n    char test6[] = \"#6@2\";\n    assert(strcmp(func0(test6), \"2@6#\") == 0);\n\n    char test7[] = \"#$a^D\";\n    assert(strcmp(func0(test7), \"#$A^d\") == 0);\n\n    char test8[] = \"#ccc\";\n    assert(strcmp(func0(test8), \"#CCC\") == 0);\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   1090 <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    1280 <func0+0x100>\n  mov    %rax,%r15\n  mov    %r12,%rbx\n  call   10b0 <__ctype_b_loc@plt>\n  mov    %rax,%r14\n  lea    -0x1(%r15),%eax\n  xor    %r15d,%r15d\n  lea    0x1(%r12,%rax,1),%r13\n  jmp    11e3 <func0+0x63>\n  nopl   0x0(%rax,%rax,1)\n  test   $0x1,%ah\n  je     1220 <func0+0xa0>\n  call   10a0 <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     11ff <func0+0x7f>\n  movzbl (%rbx),%ebp\n  mov    (%r14),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  jne    11c8 <func0+0x48>\n  add    $0x1,%rbx\n  add    $0x1,%r15d\n  cmp    %rbx,%r13\n  jne    11e3 <func0+0x63>\n  cmp    %r15d,0x8(%rsp)\n  je     1238 <func0+0xb8>\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\n  test   $0x2,%ah\n  je     11da <func0+0x5a>\n  call   1080 <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    11da <func0+0x5a>\n  nopl   0x0(%rax)\n  mov    0x8(%rsp),%rax\n  mov    %eax,%ecx\n  sar    %ecx\n  je     1206 <func0+0x86>\n  movslq %eax,%r13\n  sub    $0x1,%ecx\n  mov    %r12,%rdx\n  lea    -0x2(%r12,%r13,1),%rdi\n  lea    -0x1(%r12,%r13,1),%rax\n  sub    %rcx,%rdi\n  nopl   0x0(%rax)\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    1260 <func0+0xe0>\n  jmp    1206 <func0+0x86>\n  nopl   0x0(%rax)\n  xor    %r15d,%r15d\n  jmp    11ff <func0+0x7f>",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %r15\n  push   %r14\n  push   %r13\n  push   %r12\n  mov    %rdi,%r12\n  push   %rbp\n  push   %rbx\n  sub    $0x18,%rsp\n  call   <strlen@plt>\n  mov    %rax,0x8(%rsp)\n  test   %eax,%eax\n  jle    L0\n  mov    %rax,%r15\n  mov    %r12,%rbx\n  call   <__ctype_b_loc@plt>\n  mov    %rax,%r14\n  lea    -0x1(%r15),%eax\n  xor    %r15d,%r15d\n  lea    0x1(%r12,%rax,1),%r13\n  jmp    L1\n  nopl   0x0(%rax,%rax,1)\nL4:\n  test   $0x1,%ah\n  je     L2\n  call   <__ctype_tolower_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\nL6:\n  add    $0x1,%rbx\n  cmp    %rbx,%r13\n  je     L3\nL1:\n  movzbl (%rbx),%ebp\n  mov    (%r14),%rax\n  movzwl (%rax,%rbp,2),%eax\n  test   $0x4,%ah\n  jne    L4\n  add    $0x1,%rbx\n  add    $0x1,%r15d\n  cmp    %rbx,%r13\n  jne    L1\nL3:\n  cmp    %r15d,0x8(%rsp)\n  je     L5\nL7:\n  add    $0x18,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %rbp\n  pop    %r12\n  pop    %r13\n  pop    %r14\n  pop    %r15\n  ret\n  nopl   0x0(%rax,%rax,1)\nL2:\n  test   $0x2,%ah\n  je     L6\n  call   <__ctype_toupper_loc@plt>\n  mov    (%rax),%rax\n  mov    (%rax,%rbp,4),%eax\n  mov    %al,(%rbx)\n  jmp    L6\n  nopl   0x0(%rax)\nL5:\n  mov    0x8(%rsp),%rax\n  mov    %eax,%ecx\n  sar    %ecx\n  je     L7\n  movslq %eax,%r13\n  sub    $0x1,%ecx\n  mov    %r12,%rdx\n  lea    -0x2(%r12,%r13,1),%rdi\n  lea    -0x1(%r12,%r13,1),%rax\n  sub    %rcx,%rdi\n  nopl   0x0(%rax)\nL8:\n  movzbl (%rdx),%ecx\n  movzbl (%rax),%esi\n  sub    $0x1,%rax\n  add    $0x1,%rdx\n  mov    %sil,-0x1(%rdx)\n  mov    %cl,0x1(%rax)\n  cmp    %rax,%rdi\n  jne    L8\n  jmp    L7\n  nopl   0x0(%rax)\nL0:\n  xor    %r15d,%r15d\n  jmp    L3",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4736
            },
            "L1": {
                "label": "L1",
                "addr": 4579
            },
            "L2": {
                "label": "L2",
                "addr": 4640
            },
            "L3": {
                "label": "L3",
                "addr": 4607
            },
            "L4": {
                "label": "L4",
                "addr": 4552
            },
            "L5": {
                "label": "L5",
                "addr": 4664
            },
            "L6": {
                "label": "L6",
                "addr": 4570
            },
            "L7": {
                "label": "L7",
                "addr": 4614
            },
            "L8": {
                "label": "L8",
                "addr": 4704
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 162,
        "type": "O0",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1188 <func0+0x2f>\n  lea    0xe85(%rip),%rax        # 2000 <_fini+0xdd0>\n  mov    %rax,%rdi\n  call   1090 <strdup@plt>\n  jmp    122d <func0+0xd4>\n  movl   $0xffffffff,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    11e2 <func0+0x89>\n  mov    -0x10(%rbp),%edx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x15(%rbp)\n  movzbl -0x15(%rbp),%eax\n  xor    %eax,-0x14(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    11d8 <func0+0x7f>\n  mov    -0x14(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  je     11d1 <func0+0x78>\n  mov    -0x14(%rbp),%eax\n  shr    %eax\n  xor    $0xedb88320,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    11d4 <func0+0x7b>\n  shrl   -0x14(%rbp)\n  addl   $0x1,-0xc(%rbp)\n  cmpl   $0x7,-0xc(%rbp)\n  jbe    11b8 <func0+0x5f>\n  addl   $0x1,-0x10(%rbp)\n  mov    -0x10(%rbp),%edx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    1198 <func0+0x3f>\n  notl   -0x14(%rbp)\n  mov    $0x9,%edi\n  call   1070 <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  je     1229 <func0+0xd0>\n  mov    -0x14(%rbp),%edx\n  mov    -0x8(%rbp),%rax\n  lea    0xdec(%rip),%rcx        # 2005 <_fini+0xdd5>\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1080 <sprintf@plt>\n  mov    -0x8(%rbp),%rax\n  leave\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  sub    $0x30,%rsp\n  mov    %rdi,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L0\n  lea    D0(%rip),%rax\n  mov    %rax,%rdi\n  call   <strdup@plt>\n  jmp    L1\nL0:\n  movl   $0xffffffff,-0x14(%rbp)\n  movl   $0x0,-0x10(%rbp)\n  jmp    L2\nL7:\n  mov    -0x10(%rbp),%edx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  mov    %al,-0x15(%rbp)\n  movzbl -0x15(%rbp),%eax\n  xor    %eax,-0x14(%rbp)\n  movl   $0x0,-0xc(%rbp)\n  jmp    L3\nL6:\n  mov    -0x14(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  je     L4\n  mov    -0x14(%rbp),%eax\n  shr    %eax\n  xor    $0xedb88320,%eax\n  mov    %eax,-0x14(%rbp)\n  jmp    L5\nL4:\n  shrl   -0x14(%rbp)\nL5:\n  addl   $0x1,-0xc(%rbp)\nL3:\n  cmpl   $0x7,-0xc(%rbp)\n  jbe    L6\n  addl   $0x1,-0x10(%rbp)\nL2:\n  mov    -0x10(%rbp),%edx\n  mov    -0x28(%rbp),%rax\n  add    %rdx,%rax\n  movzbl (%rax),%eax\n  test   %al,%al\n  jne    L7\n  notl   -0x14(%rbp)\n  mov    $0x9,%edi\n  call   <malloc@plt>\n  mov    %rax,-0x8(%rbp)\n  cmpq   $0x0,-0x8(%rbp)\n  je     L8\n  mov    -0x14(%rbp),%edx\n  mov    -0x8(%rbp),%rax\n  lea    D1(%rip),%rcx\n  mov    %rcx,%rsi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <sprintf@plt>\nL8:\n  mov    -0x8(%rbp),%rax\nL1:\n  leave\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3717
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8197,
                "bias": [
                    3564
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4488
            },
            "L1": {
                "label": "L1",
                "addr": 4653
            },
            "L2": {
                "label": "L2",
                "addr": 4578
            },
            "L3": {
                "label": "L3",
                "addr": 4568
            },
            "L4": {
                "label": "L4",
                "addr": 4561
            },
            "L5": {
                "label": "L5",
                "addr": 4564
            },
            "L6": {
                "label": "L6",
                "addr": 4536
            },
            "L7": {
                "label": "L7",
                "addr": 4504
            },
            "L8": {
                "label": "L8",
                "addr": 4649
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e6f6e65002530385800",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"None\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"%08X\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 162,
        "type": "O1",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  mov    $0x0,%esi\n  mov    $0xffffffff,%r8d\n  test   %al,%al\n  jne    1193 <func0+0x3a>\n  lea    0xe84(%rip),%rdi        # 2000 <_fini+0xe00>\n  call   1080 <strdup@plt>\n  mov    %rax,%rbp\n  jmp    11f6 <func0+0x9d>\n  add    $0x1,%esi\n  mov    %esi,%eax\n  movzbl (%rdi,%rax,1),%eax\n  test   %al,%al\n  je     11be <func0+0x65>\n  movzbl %al,%eax\n  xor    %eax,%r8d\n  mov    $0x8,%edx\n  mov    %r8d,%eax\n  shr    %eax\n  xor    $0xedb88320,%eax\n  mov    %r8d,%ecx\n  shr    %ecx\n  test   $0x1,%r8b\n  cmove  %ecx,%eax\n  mov    %eax,%r8d\n  sub    $0x1,%edx\n  jne    119e <func0+0x45>\n  jmp    1186 <func0+0x2d>\n  mov    %r8d,%ebx\n  not    %ebx\n  mov    $0x9,%edi\n  call   1070 <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     11f6 <func0+0x9d>\n  mov    %ebx,%r8d\n  lea    0xe26(%rip),%rcx        # 2005 <_fini+0xe05>\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   1090 <__sprintf_chk@plt>\n  mov    %rbp,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  push   %rbx\n  sub    $0x8,%rsp\n  movzbl (%rdi),%eax\n  mov    $0x0,%esi\n  mov    $0xffffffff,%r8d\n  test   %al,%al\n  jne    L0\n  lea    D0(%rip),%rdi\n  call   <strdup@plt>\n  mov    %rax,%rbp\n  jmp    L1\nL4:\n  add    $0x1,%esi\n  mov    %esi,%eax\n  movzbl (%rdi,%rax,1),%eax\n  test   %al,%al\n  je     L2\nL0:\n  movzbl %al,%eax\n  xor    %eax,%r8d\n  mov    $0x8,%edx\nL3:\n  mov    %r8d,%eax\n  shr    %eax\n  xor    $0xedb88320,%eax\n  mov    %r8d,%ecx\n  shr    %ecx\n  test   $0x1,%r8b\n  cmove  %ecx,%eax\n  mov    %eax,%r8d\n  sub    $0x1,%edx\n  jne    L3\n  jmp    L4\nL2:\n  mov    %r8d,%ebx\n  not    %ebx\n  mov    $0x9,%edi\n  call   <malloc@plt>\n  mov    %rax,%rbp\n  test   %rax,%rax\n  je     L1\n  mov    %ebx,%r8d\n  lea    D1(%rip),%rcx\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  mov    %rax,%rdi\n  mov    $0x0,%eax\n  call   <__sprintf_chk@plt>\nL1:\n  mov    %rbp,%rax\n  add    $0x8,%rsp\n  pop    %rbx\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8192,
                "bias": [
                    3716
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8197,
                "bias": [
                    3622
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4499
            },
            "L1": {
                "label": "L1",
                "addr": 4598
            },
            "L2": {
                "label": "L2",
                "addr": 4542
            },
            "L3": {
                "label": "L3",
                "addr": 4510
            },
            "L4": {
                "label": "L4",
                "addr": 4486
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e6f6e65002530385800",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"None\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"%08X\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 162,
        "type": "O2",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     11fb <func0+0x9b>\n  push   %r12\n  xor    %esi,%esi\n  mov    $0xffffffff,%r8d\n  push   %rbx\n  sub    $0x8,%rsp\n  xchg   %ax,%ax\n  xor    %eax,%r8d\n  mov    $0x8,%eax\n  nopl   0x0(%rax,%rax,1)\n  mov    %r8d,%ecx\n  shr    %r8d\n  mov    %r8d,%edx\n  and    $0x1,%ecx\n  xor    $0xedb88320,%edx\n  test   %ecx,%ecx\n  cmovne %edx,%r8d\n  sub    $0x1,%eax\n  jne    1190 <func0+0x30>\n  lea    0x1(%rsi),%eax\n  mov    %rax,%rsi\n  movzbl (%rdi,%rax,1),%eax\n  test   %al,%al\n  jne    1180 <func0+0x20>\n  mov    $0x9,%edi\n  mov    %r8d,%ebx\n  call   1070 <malloc@plt>\n  not    %ebx\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     11f0 <func0+0x90>\n  mov    %rax,%rdi\n  mov    %ebx,%r8d\n  lea    0xe26(%rip),%rcx        # 2005 <_fini+0xdfd>\n  xor    %eax,%eax\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  call   1090 <__sprintf_chk@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %r12\n  ret\n  lea    0xdfe(%rip),%rdi        # 2000 <_fini+0xdf8>\n  jmp    1080 <strdup@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  push   %r12\n  xor    %esi,%esi\n  mov    $0xffffffff,%r8d\n  push   %rbx\n  sub    $0x8,%rsp\n  xchg   %ax,%ax\nL2:\n  xor    %eax,%r8d\n  mov    $0x8,%eax\n  nopl   0x0(%rax,%rax,1)\nL1:\n  mov    %r8d,%ecx\n  shr    %r8d\n  mov    %r8d,%edx\n  and    $0x1,%ecx\n  xor    $0xedb88320,%edx\n  test   %ecx,%ecx\n  cmovne %edx,%r8d\n  sub    $0x1,%eax\n  jne    L1\n  lea    0x1(%rsi),%eax\n  mov    %rax,%rsi\n  movzbl (%rdi,%rax,1),%eax\n  test   %al,%al\n  jne    L2\n  mov    $0x9,%edi\n  mov    %r8d,%ebx\n  call   <malloc@plt>\n  not    %ebx\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     L3\n  mov    %rax,%rdi\n  mov    %ebx,%r8d\n  lea    D0(%rip),%rcx\n  xor    %eax,%eax\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  call   <__sprintf_chk@plt>\nL3:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %r12\n  ret\nL0:\n  lea    D1(%rip),%rdi\n  jmp    1080 <strdup@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8197,
                "bias": [
                    3622
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3582
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4603
            },
            "L1": {
                "label": "L1",
                "addr": 4496
            },
            "L2": {
                "label": "L2",
                "addr": 4480
            },
            "L3": {
                "label": "L3",
                "addr": 4592
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e6f6e65002530385800",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"None\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"%08X\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 162,
        "type": "O3",
        "c_func": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// CRC32 function\nchar* func0(const char* text) {\n    if(strlen(text) == 0) {\n        return strdup(\"None\");\n    }\n\n    unsigned int crc = 0xFFFFFFFF; \n    unsigned int i, j;\n    unsigned char byte;\n\n    for(i = 0; text[i] != '\\0'; i++) {\n        byte = text[i];\n        crc = crc ^ byte;\n        for(j = 0; j < 8; j++) {\n            if(crc & 1) {\n                crc = (crc >> 1) ^ 0xEDB88320;\n            } else {\n                crc = crc >> 1;\n            }\n        }\n    }\n    crc = ~crc;\n\n    char* result = malloc(9);\n    if(result != NULL) {\n        sprintf(result, \"%08X\", crc);\n    }\n\n    return result;\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n\nint main() {\n  char* result;\n\n  // Test 1\n  result = func0(\"Hello world\");\n  assert(strcmp(result, \"8BD69E52\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 2\n  result = func0(\"\");\n  assert(strcmp(result, \"None\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 3\n  result = func0(\"foobar\");\n  assert(strcmp(result, \"9EF61F95\") == 0); \n  free(result); // Free the allocated memory\n\n  // Test 4\n  result = func0(\"abcd1234\");\n  assert(strcmp(result, \"3D3FB146\") == 0);\n  free(result); // Free the allocated memory\n\n  // Test 5\n  result = func0(\"test string\");\n  assert(strcmp(result, \"13471545\") == 0);\n  free(result); // Free the allocated memory\n  \n  return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     1267 <func0+0x107>\n  push   %r12\n  xor    %esi,%esi\n  mov    $0xffffffff,%r8d\n  push   %rbx\n  sub    $0x8,%rsp\n  xchg   %ax,%ax\n  movzbl %al,%eax\n  xor    %r8d,%eax\n  mov    %eax,%ecx\n  shr    %ecx\n  mov    %ecx,%edx\n  xor    $0xedb88320,%edx\n  test   $0x1,%al\n  cmovne %edx,%ecx\n  mov    %ecx,%edx\n  shr    %edx\n  mov    %edx,%eax\n  xor    $0xedb88320,%eax\n  and    $0x1,%ecx\n  cmovne %eax,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%edx\n  shr    %edx\n  mov    %edx,%ecx\n  xor    $0xedb88320,%ecx\n  test   $0x1,%al\n  cmovne %ecx,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%edx\n  shr    %edx\n  mov    %edx,%ecx\n  xor    $0xedb88320,%ecx\n  test   $0x1,%al\n  cmovne %ecx,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%r8d\n  shr    %r8d\n  mov    %r8d,%edx\n  xor    $0xedb88320,%edx\n  test   $0x1,%al\n  lea    0x1(%rsi),%eax\n  mov    %rax,%rsi\n  movzbl (%rdi,%rax,1),%eax\n  cmovne %edx,%r8d\n  test   %al,%al\n  jne    1180 <func0+0x20>\n  mov    $0x9,%edi\n  mov    %r8d,%ebx\n  call   1070 <malloc@plt>\n  not    %ebx\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     125c <func0+0xfc>\n  mov    %rax,%rdi\n  mov    %ebx,%r8d\n  lea    0xdba(%rip),%rcx        # 2005 <_fini+0xd91>\n  xor    %eax,%eax\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  call   1090 <__sprintf_chk@plt>\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %r12\n  ret\n  lea    0xd92(%rip),%rdi        # 2000 <_fini+0xd8c>\n  jmp    1080 <strdup@plt>",
        "asm_labeled": "<func0>:\n  endbr64\n  movzbl (%rdi),%eax\n  test   %al,%al\n  je     L0\n  push   %r12\n  xor    %esi,%esi\n  mov    $0xffffffff,%r8d\n  push   %rbx\n  sub    $0x8,%rsp\n  xchg   %ax,%ax\nL1:\n  movzbl %al,%eax\n  xor    %r8d,%eax\n  mov    %eax,%ecx\n  shr    %ecx\n  mov    %ecx,%edx\n  xor    $0xedb88320,%edx\n  test   $0x1,%al\n  cmovne %edx,%ecx\n  mov    %ecx,%edx\n  shr    %edx\n  mov    %edx,%eax\n  xor    $0xedb88320,%eax\n  and    $0x1,%ecx\n  cmovne %eax,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%edx\n  shr    %edx\n  mov    %edx,%ecx\n  xor    $0xedb88320,%ecx\n  test   $0x1,%al\n  cmovne %ecx,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%edx\n  shr    %edx\n  mov    %edx,%ecx\n  xor    $0xedb88320,%ecx\n  test   $0x1,%al\n  cmovne %ecx,%edx\n  mov    %edx,%eax\n  shr    %eax\n  mov    %eax,%ecx\n  xor    $0xedb88320,%ecx\n  and    $0x1,%edx\n  cmovne %ecx,%eax\n  mov    %eax,%r8d\n  shr    %r8d\n  mov    %r8d,%edx\n  xor    $0xedb88320,%edx\n  test   $0x1,%al\n  lea    0x1(%rsi),%eax\n  mov    %rax,%rsi\n  movzbl (%rdi,%rax,1),%eax\n  cmovne %edx,%r8d\n  test   %al,%al\n  jne    L1\n  mov    $0x9,%edi\n  mov    %r8d,%ebx\n  call   <malloc@plt>\n  not    %ebx\n  mov    %rax,%r12\n  test   %rax,%rax\n  je     L2\n  mov    %rax,%rdi\n  mov    %ebx,%r8d\n  lea    D0(%rip),%rcx\n  xor    %eax,%eax\n  mov    $0x9,%edx\n  mov    $0x1,%esi\n  call   <__sprintf_chk@plt>\nL2:\n  add    $0x8,%rsp\n  mov    %r12,%rax\n  pop    %rbx\n  pop    %r12\n  ret\nL0:\n  lea    D1(%rip),%rdi\n  jmp    1080 <strdup@plt>",
        "num_missing": 0,
        "address_mapping": {
            "D0": {
                "label": "D0",
                "addr": 8197,
                "bias": [
                    3514
                ]
            },
            "D1": {
                "label": "D1",
                "addr": 8192,
                "bias": [
                    3474
                ]
            },
            "L0": {
                "label": "L0",
                "addr": 4711
            },
            "L1": {
                "label": "L1",
                "addr": 4480
            },
            "L2": {
                "label": "L2",
                "addr": 4700
            }
        },
        "rodata_addr": 8192,
        "rodata_data": "4e6f6e65002530385800",
        "rodata_parsed": {
            "func0": {
                "0x2000": {
                    "type": "string",
                    "value": "\"None\""
                },
                "0x2005": {
                    "type": "string",
                    "value": "\"%08X\""
                }
            }
        },
        "structs": []
    },
    {
        "task_id": 163,
        "type": "O0",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %rdx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jge    1133 <func0+0x3a>\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    1174 <func0+0x7b>\n  cmpl   $0x9,-0x8(%rbp)\n  jg     1170 <func0+0x77>\n  mov    -0x8(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    1170 <func0+0x77>\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\n  addl   $0x1,-0x8(%rbp)\n  mov    -0x8(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    113b <func0+0x42>\n  nop\n  nop\n  pop    %rbp\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  push   %rbp\n  mov    %rsp,%rbp\n  mov    %edi,-0x14(%rbp)\n  mov    %esi,-0x18(%rbp)\n  mov    %rdx,-0x20(%rbp)\n  mov    %rcx,-0x28(%rbp)\n  mov    -0x28(%rbp),%rax\n  movl   $0x0,(%rax)\n  mov    -0x18(%rbp),%eax\n  cmp    -0x14(%rbp),%eax\n  jge    L0\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x4(%rbp)\n  mov    -0x18(%rbp),%eax\n  mov    %eax,-0x14(%rbp)\n  mov    -0x4(%rbp),%eax\n  mov    %eax,-0x18(%rbp)\nL0:\n  mov    -0x14(%rbp),%eax\n  mov    %eax,-0x8(%rbp)\n  jmp    L1\nL3:\n  cmpl   $0x9,-0x8(%rbp)\n  jg     L2\n  mov    -0x8(%rbp),%eax\n  and    $0x1,%eax\n  test   %eax,%eax\n  jne    L2\n  mov    -0x28(%rbp),%rax\n  mov    (%rax),%eax\n  lea    0x1(%rax),%ecx\n  mov    -0x28(%rbp),%rdx\n  mov    %ecx,(%rdx)\n  cltq\n  lea    0x0(,%rax,4),%rdx\n  mov    -0x20(%rbp),%rax\n  add    %rax,%rdx\n  mov    -0x8(%rbp),%eax\n  mov    %eax,(%rdx)\nL2:\n  addl   $0x1,-0x8(%rbp)\nL1:\n  mov    -0x8(%rbp),%eax\n  cmp    -0x18(%rbp),%eax\n  jle    L3\n  nop\n  nop\n  pop    %rbp\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4403
            },
            "L1": {
                "label": "L1",
                "addr": 4468
            },
            "L2": {
                "label": "L2",
                "addr": 4464
            },
            "L3": {
                "label": "L3",
                "addr": 4411
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 163,
        "type": "O1",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  cmp    %edi,%esi\n  jge    1116 <func0+0x1d>\n  mov    %edi,%eax\n  mov    %esi,%edi\n  mov    %eax,%esi\n  jmp    1116 <func0+0x1d>\n  add    $0x1,%edi\n  cmp    %edi,%esi\n  jl     1131 <func0+0x38>\n  cmp    $0x9,%edi\n  jg     110f <func0+0x16>\n  test   $0x1,%dil\n  jne    110f <func0+0x16>\n  mov    (%rcx),%eax\n  lea    0x1(%rax),%r8d\n  mov    %r8d,(%rcx)\n  cltq\n  mov    %edi,(%rdx,%rax,4)\n  jmp    110f <func0+0x16>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  cmp    %edi,%esi\n  jge    L0\n  mov    %edi,%eax\n  mov    %esi,%edi\n  mov    %eax,%esi\n  jmp    L0\nL2:\n  add    $0x1,%edi\n  cmp    %edi,%esi\n  jl     L1\nL0:\n  cmp    $0x9,%edi\n  jg     L2\n  test   $0x1,%dil\n  jne    L2\n  mov    (%rcx),%eax\n  lea    0x1(%rax),%r8d\n  mov    %r8d,(%rcx)\n  cltq\n  mov    %edi,(%rdx,%rax,4)\n  jmp    L2\nL1:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4374
            },
            "L1": {
                "label": "L1",
                "addr": 4401
            },
            "L2": {
                "label": "L2",
                "addr": 4367
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 163,
        "type": "O2",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  cmp    %edi,%esi\n  jge    1118 <func0+0x18>\n  mov    %edi,%eax\n  mov    %esi,%edi\n  mov    %eax,%esi\n  nopl   0x0(%rax)\n  cmp    $0x9,%edi\n  jg     1130 <func0+0x30>\n  test   $0x1,%dil\n  jne    1130 <func0+0x30>\n  movslq (%rcx),%rax\n  lea    0x1(%rax),%r8d\n  mov    %r8d,(%rcx)\n  mov    %edi,(%rdx,%rax,4)\n  add    $0x1,%edi\n  cmp    %edi,%esi\n  jge    1118 <func0+0x18>\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  cmp    %edi,%esi\n  jge    L0\n  mov    %edi,%eax\n  mov    %esi,%edi\n  mov    %eax,%esi\n  nopl   0x0(%rax)\nL0:\n  cmp    $0x9,%edi\n  jg     L1\n  test   $0x1,%dil\n  jne    L1\n  movslq (%rcx),%rax\n  lea    0x1(%rax),%r8d\n  mov    %r8d,(%rcx)\n  mov    %edi,(%rdx,%rax,4)\nL1:\n  add    $0x1,%edi\n  cmp    %edi,%esi\n  jge    L0\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4376
            },
            "L1": {
                "label": "L1",
                "addr": 4400
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    },
    {
        "task_id": 163,
        "type": "O3",
        "c_func": "#include <stdio.h>\n\nvoid func0(int a, int b, int *out, int *size) {\n    int m;\n    *size = 0;\n\n    if (b < a) {\n        m = a;\n        a = b;\n        b = m;\n    }\n\n    for (int i = a; i <= b; i++) {\n        if (i < 10 && i % 2 == 0) {\n            out[(*size)++] = i;\n        }\n    }\n}",
        "c_test": "#include <stdio.h>\n#include <assert.h>\n\nint issame(const int *a, int a_size, const int *b, int b_size) {\n    if (a_size != b_size) return 0;\n    for (int i = 0; i < a_size; i++) {\n        if (a[i] != b[i]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int result[10], size;\n\n    int expected1[] = {2, 4, 6, 8};\n    func0(2, 10, result, &size);\n    assert(issame(result, size, expected1, 4));\n\n    int expected2[] = {2, 4, 6, 8};\n    func0(10, 2, result, &size);\n    assert(issame(result, size, expected2, 4));\n\n    int expected3[] = {2, 4, 6, 8};\n    func0(132, 2, result, &size);\n    assert(issame(result, size, expected3, 4));\n\n    int expected4[] = {}; // Empty set\n    func0(17, 89, result, &size);\n    assert(issame(result, size, expected4, 0));\n\n    printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
        "asm": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  mov    %edi,%eax\n  cmp    %edi,%esi\n  jge    1114 <func0+0x14>\n  mov    %esi,%eax\n  mov    %edi,%esi\n  cmp    $0x9,%eax\n  jg     1148 <func0+0x48>\n  mov    $0x9,%edi\n  cmp    %edi,%esi\n  cmovg  %edi,%esi\n  nopl   0x0(%rax,%rax,1)\n  test   $0x1,%al\n  jne    1139 <func0+0x39>\n  movslq (%rcx),%rdi\n  lea    0x1(%rdi),%r8d\n  mov    %r8d,(%rcx)\n  mov    %eax,(%rdx,%rdi,4)\n  add    $0x1,%eax\n  cmp    %esi,%eax\n  jle    1128 <func0+0x28>\n  ret\n  nopl   0x0(%rax)\n  ret",
        "asm_labeled": "<func0>:\n  endbr64\n  movl   $0x0,(%rcx)\n  mov    %edi,%eax\n  cmp    %edi,%esi\n  jge    L0\n  mov    %esi,%eax\n  mov    %edi,%esi\nL0:\n  cmp    $0x9,%eax\n  jg     L1\n  mov    $0x9,%edi\n  cmp    %edi,%esi\n  cmovg  %edi,%esi\n  nopl   0x0(%rax,%rax,1)\nL3:\n  test   $0x1,%al\n  jne    L2\n  movslq (%rcx),%rdi\n  lea    0x1(%rdi),%r8d\n  mov    %r8d,(%rcx)\n  mov    %eax,(%rdx,%rdi,4)\nL2:\n  add    $0x1,%eax\n  cmp    %esi,%eax\n  jle    L3\n  ret\n  nopl   0x0(%rax)\nL1:\n  ret",
        "num_missing": 0,
        "address_mapping": {
            "L0": {
                "label": "L0",
                "addr": 4372
            },
            "L1": {
                "label": "L1",
                "addr": 4424
            },
            "L2": {
                "label": "L2",
                "addr": 4409
            },
            "L3": {
                "label": "L3",
                "addr": 4392
            }
        },
        "rodata_addr": null,
        "rodata_data": null,
        "rodata_parsed": {},
        "structs": []
    }
]